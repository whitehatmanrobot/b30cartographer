   else
        {
            // BUG_BUG paranoid:  may check that string is contiguous
            // parStrLiteral->loOffset + parStrLiteral->dwCount
            // should equal arTmpDest.loOffset
            ASSERT(parStrLiteral->loOffset + parStrLiteral->dwCount == arTmpDest.loOffset );
        }
        parStrLiteral->dwCount += dwI ;
    }
    if(!bHigh)
    {
        ERR(("hex string contains odd number of hex digits.\n"));
    }
    return(bHigh) ;
}


BOOL    BparseOrderDep(
IN  PABSARRAYREF      paarValue,
IN  PORDERDEPENDENCY  pordDest,
    PGLOBL            pglobl
)
//  an order dependency value has the syntax:
//  SECTION.integer
{
    ABSARRAYREF     aarSection ;  // points to SECTION token
    DWORD       dwDelIndex ;    //  if BdelimitToken
        //  found a delimiter, this contains the index to pubDelimiters
        //  of the delimiter that was found.
    DWORD   dwI ;  // number integers in RECT


    if(!BdelimitToken(paarValue, ".", &aarSection, &dwDelIndex) )
    {
        ERR(("required delimiter '.' missing in order dependency value.\n"));
        return(FALSE);
    }
    if(!BparseConstant(&aarSection, (PDWORD)&(pordDest->eSection),
        VALUE_CONSTANT_SEQSECTION , pglobl))
    {
        ERR(("A valid orderdep SECTION name was not supplied: %0.*s\n", aarSection.dw, aarSection.pub));
        return(FALSE);
    }

    //  now interpret remainder of paarValue as an integer.

    if(!BparseInteger(paarValue, &(pordDest->dwOrder), VALUE_INTEGER, pglobl))
    {
        ERR(("syntax error in integer portion of order dependency.\n"));
        return(FALSE) ;
    }

    //  verify there is nothing else in statement.

    (VOID) BeatLeadingWhiteSpaces(paarValue) ;
    if(paarValue->dw)
    {
        ERR(("extraneous characters found after the end of the orderDependency value: %0.*s\n",
            paarValue->dw, paarValue->pub));
        //    may want to print them out.
        //  not a fatal condition, continue.
    }
    return(TRUE) ;
}


PDWORD   pdwEndOfList(
  PDWORD   pdwNodeIndex,   //  index of first node in the list
  PGLOBL   pglobl)
// walks the list and returns pointer  to field containing the
//  actual END_OF_LIST  value so it can be overwritten to
//   extend the list.
{
    PLISTNODE    plstRoot ;  // start of LIST array
    DWORD       dwNodeIndex , dwPrevsNode, dwFirstNode;

    plstRoot = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;
    dwNodeIndex = *pdwNodeIndex ;

    if(dwNodeIndex == END_OF_LIST )
        return(pdwNodeIndex);   //  no actual node referenced.

    while(plstRoot[dwNodeIndex].dwNextItem != END_OF_LIST )
        dwNodeIndex = plstRoot[dwNodeIndex].dwNextItem ;
    return(&plstRoot[dwNodeIndex].dwNextItem);
}

#ifdef  GMACROS

 PBYTE    ExtendChain(PBYTE    pubDest,
 IN   BOOL    bOverWrite,
 IN OUT PGLOBL pglobl)
    //  Links together values from separate entries into one LIST
    //  the values may be of any type.  If the values are LISTS, this
    //  modifier creates LISTS of LISTS.
    //  returns new value of pubDest
{
    DWORD    dwNodeIndex;
    PLISTNODE    plstRoot ;  // start of LIST array

    plstRoot = (PLISTNODE) gMasterTable[MTI_LISTNODES].pubStruct ;

    if(bOverWrite)
        pubDest = (PBYTE)pdwEndOfList((PDWORD)pubDest, pglobl);  // walks the list and returns pointer
                    //  to the actual END_OF_LIST  value so it can be overwritten to
                    //   extend the list.


    //  Add one list node and write its index to pubDest.
    //  set nextnode field of node just added to END_OF_LIST.

    if(! BallocElementFromMasterTable(MTI_LISTNODES ,
        &dwNodeIndex, pglobl) )
    {
        return(NULL) ;
    }
    plstRoot[dwNodeIndex].dwNextItem = END_OF_LIST ;

    *(PDWORD)pubDest = dwNodeIndex ;

    // update pubDest to point to value field of of the node just added.
    // now the LIST() we will now proceed to parse will grow from this
    // value field.

    pubDest = (PBYTE)&(plstRoot[dwNodeIndex].dwData) ;
    return(pubDest) ;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\token1.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
/*  token1.c - functions to create the tokenmap  */


#include    "gpdparse.h"


// ----  functions defined in token1.c ---- //

BOOL    BcreateTokenMap(
PWSTR   pwstrFileName,
PGLOBL  pglobl )  ;

PARSTATE  PARSTscanForKeyword(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PARSTATE  PARSTparseColon(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PARSTATE  PARSTparseValue(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

BOOL  BparseKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BisExternKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL  BisColonNext(
PGLOBL  pglobl) ;

BOOL    BeatArbitraryWhite(
PGLOBL  pglobl) ;

BOOL    BeatComment(
PGLOBL  pglobl) ;

BOOL    BscanStringSegment(
PGLOBL  pglobl) ;

BOOL    BscanDelimitedString(
BYTE  ubDelimiter,
PBOOL    pbMacroDetected,
PGLOBL  pglobl) ;

PARSTATE    PARSTrestorePrevsFile(
PDWORD   pdwTKMindex,
PGLOBL  pglobl) ;

PWSTR
PwstrAnsiToUnicode(
IN  PSTR pstrAnsiString,
    PGLOBL  pglobl
) ;

PARSTATE    PARSTloadIncludeFile(
PDWORD   pdwTKMindex,
PWSTR   pwstrFileName,    // root GPD file
PGLOBL  pglobl);

BOOL    BloadFile(
PWSTR   pwstrFileName,
PGLOBL  pglobl ) ;

BOOL        BarchiveStrings(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

DWORD  DWidentifyKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl) ;

BOOL    BidentifyAttributeKeyword(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
) ;

BOOL    BcopyToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL          pglobl) ;

DWORD    dwStoreFileName(PWSTR    pwstrFileName,
PARRAYREF   parDest,
PGLOBL      pglobl) ;

VOID    vFreeFileNames(
PGLOBL  pglobl ) ;

VOID    vIdentifySource(
    PTKMAP   ptkmap,
    PGLOBL  pglobl) ;



//  functions defined in preproc1.c  //

BOOL  BPreProcess(
    PGLOBL  pglobl
) ;  //  from current file position, use file macros to access.

BOOL  DefineSymbol(
    PBYTE   symbol,
    PGLOBL  pglobl
) ;

// ---------------------------------------------------- //



//    define  Local Macro to access info for current file:


#define    mprngDictionary  ((PRANGE)(gMasterTable \
                            [MTI_RNGDICTIONARY].pubStruct))


//  static  DWORD  gdwLastIndex ;  // leave this in this file only!
//  Now is part of the GLOBL structure.


BOOL    BcreateTokenMap(
PWSTR   pwstrFileName,   // root GPD file
PGLOBL  pglobl)
/*  some things that occur within this function:

    Open and memory map initial file and any files specified
    by *Include.

    parse keyword, init aarKeyword field, set dwFlags,
    set dwKeywordID, parse Value , init aarValue,
    ArchiveStrings to tempHeap.  During parsing of Values,
    comments and continuation lines are replaced by whitespaces.

    Assume  each function in switch statement increments dwTKMindex
    by at most by 1.  Otherwise undetected TokenMap overflow may occur.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    DWORD   dwTKMindex = 0,   //  current tokenKeyMap index
            dwCnt ;   //  counts length of keyword or value string
    PBYTE   pubStart ;  // start address of keyword or value string
    PARSTATE  parst = PARST_KEYWORD ;


    // note in the case of the SOURCEBUFFERS, dwCurIndex is initialized
    // to zero by loadIncludeFile().  Since we never append onto
    // the existing source, dwCurIndex is used to track the current
    // position within the file (streamptr).

    //  mCurFile initialized to 0 at buffer allocation time.

    gdwLastIndex = 0 ;  // ok, allow BarchiveStrings() of all entries.

    gmrbd.rbd.dwSrcFileChecksum32 = 0 ;

{
    PBYTE  symbol ;


    symbol = "WINNT_40" ;    //  newer OSs support older OS features unless otherwise specified.
    if(! DefineSymbol(symbol, pglobl))
        return(FALSE) ;

#ifndef WINNT_40
    symbol = "WINNT_50" ;
    if(! DefineSymbol(symbol, pglobl))
        return(FALSE) ;
    symbol = "WINNT_51" ;
    if(! DefineSymbol(symbol, pglobl))
        return(FALSE) ;
#endif

    if(! DefineSymbol("PARSER_VER_1.0", pglobl))   //  support multiple versions at once.
        return(FALSE) ;
}

    if(! BloadFile(pwstrFileName, pglobl) )
    {
        return(FALSE) ;
    }

    if(!BPreProcess(pglobl) )
        return(FALSE) ;

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;


    while(parst != PARST_EXIT)
    {
        if(dwTKMindex >= gMasterTable[MTI_TOKENMAP].dwArraySize)
        {
            ERR(("Internal: no more tokenmap elements - restart.\n"));

            if(ERRSEV_RESTART > geErrorSev)
            {
                geErrorSev = ERRSEV_RESTART ;
                geErrorType = ERRTY_MEMORY_ALLOCATION ;
                gdwMasterTabIndex = MTI_TOKENMAP ;
            }
            return(FALSE) ;
        }
        switch(parst)
        {
            case (PARST_KEYWORD):
            {
                parst = PARSTscanForKeyword(&dwTKMindex, pglobl) ;
                break ;
            }
            case (PARST_COLON):
            {
                parst = PARSTparseColon(&dwTKMindex, pglobl) ;
                break ;
            }
            case (PARST_VALUE):
            {
                parst = PARSTparseValue(&dwTKMindex, pglobl) ;
                break ;
            }
            case (PARST_INCLUDEFILE):
            {
                parst = PARSTloadIncludeFile(&dwTKMindex, pwstrFileName, pglobl) ;
                if(!BPreProcess(pglobl) )
                    return(FALSE) ;
                break ;
            }
            case (PARST_EOF) :
            {
                parst = PARSTrestorePrevsFile(&dwTKMindex, pglobl) ;
                if((parst != PARST_EXIT)  &&  !BPreProcess(pglobl) )
                    return(FALSE) ;
                if(parst == PARST_EXIT  &&  mdwNestingLevel  &&  geErrorSev != ERRSEV_FATAL)
                {
                    ERR(("EOF reached before #Endif: was parsed!\n"));
                    geErrorType = ERRTY_SYNTAX ;
                    geErrorSev = ERRSEV_FATAL ;
                    return(FALSE) ;
                }
                break ;
            }
            case (PARST_ABORT) :
            {
                return(FALSE) ;  // abnormal termination.
                break ;
            }
            default:
            {
                ERR(("Internal error: no other PARST_ states exist!\n"));
                if(ERRSEV_FATAL > geErrorSev)
                {
                    geErrorSev = ERRSEV_FATAL ;
                    geErrorType = ERRTY_CODEBUG ;
                }
                return(FALSE) ;
            }
        }
    }
    return(TRUE) ;
}


PARSTATE  PARSTscanForKeyword(
PDWORD   pdwTKMindex,
PGLOBL   pglobl)
/*  this function exits with 2 possible codes:
    PARST_EOF:  end of source file encountered - return to parent file
    PARST_COLON:  a keyword or symbol keyword was parsed, now expecting
                a colon delimiter.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap

    // these two vars are just for inspiration, they may
    //  never be used.
    DWORD   dwCnt ;   //  counts length of keyword or value string
    PBYTE   pubStart ;  // start address of keyword or value string
    BYTE    ubSrc ;   //  a src byte


    /*  assume:
        no field in ptkmap[*pdwTKMindex] is initialized.
        pass all info by saving into ptkmap.

        always clear flags field and  consume remainder of
        line up to first linebreak char  in the event of
        a parsing error.

        we are looking for whichever occurs first:

        a) arbitrary white space
        c) { or }
        d) line break chars
        e) *keyword
        f) symbol keyword (not beginning with *)
        g) any other chars is a fatal error.
    */

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;

    // was the previous entry an *include ?
    if(*pdwTKMindex)
    {
        DWORD   dwKeywordID,  dwSubType;

        dwKeywordID = ptkmap[*pdwTKMindex - 1].dwKeywordID ;

        if( (dwKeywordID  < ID_SPECIAL)  &&
            (mMainKeywordTable[dwKeywordID].eType == TY_SPECIAL))
        {
            dwSubType = mMainKeywordTable[dwKeywordID].dwSubType ;

            if( dwSubType == SPEC_INCLUDE )
            {
                (*pdwTKMindex)-- ;  // make this the current entry again
                return(PARST_INCLUDEFILE) ;
            }
            else if( (dwSubType == SPEC_MEM_CONFIG_KB)  ||
                ( dwSubType == SPEC_MEM_CONFIG_MB) )
            {
                BexpandMemConfigShortcut(dwSubType) ;
                //  checks to make sure there are
                //  enough slots in the tokenmap before proceeding.
            }
        }

        if(*pdwTKMindex >  gdwLastIndex  &&
                ! BarchiveStrings(*pdwTKMindex - 1, pglobl) )
            return(PARST_ABORT) ;
        gdwLastIndex = *pdwTKMindex ;
        //  strings from each entry will get saved only once.
    }

    ptkmap[*pdwTKMindex].dwFileNameIndex =
        mpSourcebuffer[mCurFile - 1].dwFileNameIndex ;

    while(  mdwSrcInd < mdwSrcMax  )
    {
        if(!BeatArbitraryWhite(pglobl) )
            break ;

        ptkmap[*pdwTKMindex].dwLineNumber =
            mpSourcebuffer[mCurFile - 1].dwLineNumber  ;

        switch(ubSrc = mpubSrcRef[mdwSrcInd])
        {
            case '*':
            {
                if(mdwSrcInd + 1 >= mdwSrcMax)
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("Unexpected EOF encountered parsing Keyword.\n"));
                    mdwSrcInd++ ;  // move past *  this
                    // will trigger EOF detector.
                    break ;
                }
                //  assume it must be a keyword since it wasn't
                //  consumed by eatArbitraryWhite().
                mdwSrcInd++ ;  // move past *
                if(BparseKeyword(*pdwTKMindex, pglobl) )
                {
                    ptkmap[*pdwTKMindex].dwKeywordID =
                        DWidentifyKeyword(*pdwTKMindex, pglobl) ;
                    return(PARST_COLON) ;
                }
                else
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("syntax error in Keyword: %0.*s.\n", ptkmap[*pdwTKMindex].aarKeyword.dw + 1,
                                    ptkmap[*pdwTKMindex].aarKeyword.pub - 1));

                    ptkmap[*pdwTKMindex].dwFlags = 0 ;
                            // must clear the flags
                    mdwSrcInd-- ;  // go back to *
                    BeatComment(pglobl) ;  // may place cursor at EOF
                }
                break ;
            }
            case '{':
            case '}':
            {
                ptkmap[*pdwTKMindex].aarKeyword.pub = mpubSrcRef +
                                                        mdwSrcInd ;
                ptkmap[*pdwTKMindex].aarKeyword.dw = 1 ;
                ptkmap[*pdwTKMindex].aarValue.pub = 0 ;
                ptkmap[*pdwTKMindex].aarValue.dw = 0 ;
                ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;
                ptkmap[*pdwTKMindex].dwKeywordID =
                        DWidentifyKeyword(*pdwTKMindex, pglobl) ;
                (*pdwTKMindex)++ ;  // this is the complete entry!
                mdwSrcInd++ ;
                return(PARST_KEYWORD);  // re-enter this function
                break ;                 //  from the top.
            }
            case '\x1A':  // ignore control Z
                mdwSrcInd++ ;
                break;

            case '\n':
            {
                BYTE   ubTmp ;

                mdwSrcInd++ ;
                if(mdwSrcInd  < mdwSrcMax)
                {
                    ubTmp = mpubSrcRef[mdwSrcInd] ;
                    if(ubTmp  == '\r')
                    {
                        mdwSrcInd++ ;
                    }
                }
                mpSourcebuffer[mCurFile-1].dwLineNumber++ ;
                break ;  // eat 'em up yum!
            }
            case '\r':
            {
                BYTE   ubTmp ;

                mdwSrcInd++ ;
                if(mdwSrcInd  < mdwSrcMax)
                {
                    ubTmp = mpubSrcRef[mdwSrcInd] ;
                    if(ubTmp  == '\n')
                    {
                        mdwSrcInd++ ;
                    }
                }
                mpSourcebuffer[mCurFile-1].dwLineNumber++ ;
                break ;  // eat 'em up yum!
            }
            default:
            {
                if(BisExternKeyword(*pdwTKMindex, pglobl) )
                /*  if this token matches either EXTERN_GLOBAL
                or EXTERN_FEATURE  */
                {
                    if(!BisColonNext(pglobl) )
                    {
                        vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                        ERR(("syntax error:  Colon expected but missing.\n"));
                        ptkmap[*pdwTKMindex].dwFlags = 0 ;
                                    // must clear the flags
                                    //  if there is a syntax error.
                        BeatComment(pglobl) ;  // may place cursor at EOF
                    }
                    //  regardless of success or failure, we
                    //  remain in this function waiting for a *keyword.
                    break ;
                }
                //   parse token as a symbolkey.
                if(BparseKeyword(*pdwTKMindex, pglobl) )
                {
                    ptkmap[*pdwTKMindex].dwKeywordID = ID_SYMBOL ;
                    ptkmap[*pdwTKMindex].dwFlags |= TKMF_SYMBOL_KEYWORD ;
                    return (PARST_COLON) ;
                }
                else
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("syntax error: valid keyword token expected: %0.*s.\n", ptkmap[*pdwTKMindex].aarKeyword.dw,
                                    ptkmap[*pdwTKMindex].aarKeyword.pub));

                    ptkmap[*pdwTKMindex].dwFlags = 0 ;
                    BeatComment(pglobl) ;  // may place cursor at EOF
                }
                break ;
            }  //  end  default case
        }   //  end switch
    }  // end while
    return(PARST_EOF) ;  // falls out of for loop.
}



PARSTATE  PARSTparseColon(
PDWORD   pdwTKMindex,
PGLOBL   pglobl)
/*  this function exits with 3 possible codes:
    PARST_VALUE:  a colon parsed, now expecting a value.
    PARST_KEYWORD:  a line termination, EOF or illegal char was parsed.
        ready to parse a new entry.


    what looks to be a keyword has been parsed.
    attempt to look for a colon or line terminator.

    always clear flags field and  consume remainder of
    line up to first linebreak char  in the event of
    a parsing error.

*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    BYTE    ubSrc ;   //  a src byte

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;


    if(!BeatArbitraryWhite(pglobl) )
    {
        //  encountered EOF and no value found.
        ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;
        (*pdwTKMindex)++ ;  // entry complete
        return(PARST_KEYWORD) ;
    }
    if((ubSrc = mpubSrcRef[mdwSrcInd]) == ':')
    {
        mdwSrcInd++ ;  //  now expect a value
        return(PARST_VALUE) ;
    }
    else if(ubSrc == '\n'  ||  ubSrc == '\r')
    {
        //  encountered linebreak and no value found.
        ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;
        (*pdwTKMindex)++ ;  // entry complete
        return(PARST_KEYWORD) ;
    }
    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
    ERR(("Colon expected after keyword: *%0.*s.\n", ptkmap[*pdwTKMindex].aarKeyword.dw,
                    ptkmap[*pdwTKMindex].aarKeyword.pub));
    BeatComment(pglobl) ;  // may place cursor at EOF
    ptkmap[*pdwTKMindex].dwFlags = 0 ;
    return(PARST_KEYWORD) ;
}



PARSTATE  PARSTparseValue(
PDWORD   pdwTKMindex,
PGLOBL   pglobl)
/*  this function exits with 1 possible codes:
    PARST_KEYWORD:  correctly parsed value, a line termination, EOF
        or illegal char was parsed.   ready to parse a new entry.


    Cursor is initially just past the colon delimiter, the purpose of
    this function is to locate the end of the value construct.  That
    is parse up to the level 0 { or } or linebreak.
    Replace any comments and continuation constructs that occur
    within this value with spaces.

    This function makes no assumptions about the type
    of value, it only assumes the value may be comprised of none, one
    of more tokens (separated by optional whitespace) of the form:

        LIST(aaa, bbb, ccc)
        POINT(), RECT()
        integer: *, + - nnnn
        Symbols, CONSTANTS
        "strings%""  %{command params}
        qualified.names
        =macroname

    We cannot simply stop scanning when { or } or non-continuation
    linebreak is encountered because the chars { and } may occur
    within comments, strings or command parameters.  Each of these
    constructs are governed by different parsing rules and hence
    are parsed by their own specialized functions.

    This function assumes all comments are preceeded by a
    white character.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    BYTE    ubSrc ;   //  a src byte
    DWORD   dwOrgInd; // holds index of start of value.

    ptkmap = (PTKMAP) (gMasterTable[MTI_TOKENMAP].pubStruct) ;

    if(!BeatArbitraryWhite(pglobl) )
    {
        ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;
        (*pdwTKMindex)++ ;  // entry complete
        return(PARST_KEYWORD) ;
    }

    ptkmap[*pdwTKMindex].aarValue.pub = mpubSrcRef +
                                            mdwSrcInd ;
    dwOrgInd = mdwSrcInd ;

    while((ubSrc = mpubSrcRef[mdwSrcInd]) !=  '{'  &&   ubSrc !=  '}'  &&
            ubSrc !=  '\n'  &&  ubSrc !=  '\r')
    {
        switch(ubSrc)
        {
            case  '*':  // integer wildcard
            case  '-':  // integer neg sign
            case  '+':  // integer plus sign
            case  '.':  // separator for qualified name
            case  '?':  // valid char for symbolname
            case  '_':  // valid char for symbolname
            {
                mdwSrcInd++ ;   // go past this
                break ;
            }
            case  ':':  // additional token in value - shortcut?
            {
                ptkmap[*pdwTKMindex].dwFlags |= TKMF_COLON ;
                mdwSrcInd++ ;   // go past this
                break ;
            }
            case  '=':  // macroname indicator
            {
                ptkmap[*pdwTKMindex].dwFlags |= TKMF_MACROREF ;
                mdwSrcInd++ ;   // go past this
                break ;
            }

            case  '%':  // command parameter
            {
                if(!BscanDelimitedString('}', NULL, pglobl) )
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("Expected closing '}'.\n"));
                    ptkmap[*pdwTKMindex].dwFlags = 0 ;

                    return(PARST_KEYWORD) ;
                }
                break ;
            }

            case  '"' :   // this is a string construct
            {
                mdwSrcInd++ ;   // go past this
                if(!BscanStringSegment(pglobl) )
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("Error parsing string segment: %0.*s.\n",
                        mdwSrcInd - dwOrgInd,
                        ptkmap[*pdwTKMindex].aarValue.pub));

                    ptkmap[*pdwTKMindex].dwFlags = 0 ;

                    return(PARST_KEYWORD) ;
                }
                break ;
            }
            case '(':   //  arg list for LIST, POINT or RECT
            {
                BOOL  bMacroDetected ;

                if(!BscanDelimitedString(')', &bMacroDetected, pglobl) )
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("Expected closing ')'.\n"));

                    ptkmap[*pdwTKMindex].dwFlags = 0 ;

                    return(PARST_KEYWORD) ;
                }
                if(bMacroDetected)
                    ptkmap[*pdwTKMindex].dwFlags |= TKMF_MACROREF ;
                break ;
            }
            default:
            {
                if( (ubSrc  >= 'a' &&  ubSrc <= 'z')  ||
                    (ubSrc  >= 'A' &&  ubSrc <= 'Z')  ||
                    (ubSrc  >= '0' &&  ubSrc <= '9')  )
                {
                    mdwSrcInd++ ;   // looks legal, next char
                    break ;
                }
                else
                {
                    vIdentifySource(ptkmap + *pdwTKMindex, pglobl) ;
                    ERR(("illegal char encountered parsing value: %0.*s.\n",
                        mdwSrcInd - dwOrgInd,
                        ptkmap[*pdwTKMindex].aarValue.pub));
                    ERR(("    Line ignored.\n")) ;
                    ptkmap[*pdwTKMindex].dwFlags = 0 ;
                    BeatComment(pglobl) ;
                    ptkmap[*pdwTKMindex].dwKeywordID = gdwID_IgnoreBlock;
                    (*pdwTKMindex)++ ;  // entry complete

                    return(PARST_KEYWORD) ;
                }
            }
        }
        if(!BeatArbitraryWhite(pglobl) )
        {
            ptkmap[*pdwTKMindex].aarValue.dw =
                                mdwSrcInd - dwOrgInd ;
            if(!(mdwSrcInd - dwOrgInd))
                ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;
            (*pdwTKMindex)++ ;  // entry complete
            return(PARST_KEYWORD) ; // end of file encountered.
        }
    }

    ptkmap[*pdwTKMindex].aarValue.dw = mdwSrcInd - dwOrgInd ;
    if(!(mdwSrcInd - dwOrgInd))
        ptkmap[*pdwTKMindex].dwFlags |= TKMF_NOVALUE ;

    (*pdwTKMindex)++ ;  // entry complete
    return(PARST_KEYWORD) ;
}








/*  all of the following helper functions
  leaves the cursor after the object being parsed
  if successful, otherwise cursor is unchanged
  except for consuming leading whitespace.
  Return value means sucess in parsing or
  simply that EOF was not encountered, see
  specific function.  */




BOOL  BparseKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*  assumes  mdwSrcInd points to start of keyword (char
    just after *).   Determine end of keyword.  mdwSrcInd advanced
    past end of keyword.  Initializes tokenmap entry aarKeyword.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    DWORD   dwCnt ;   //  counts length of keyword or value string
    BYTE    ubSrc ;   //  a src byte

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;

    ptkmap[dwTKMindex].aarKeyword.pub = mpubSrcRef +
                                            mdwSrcInd ;

    for(dwCnt = 0 ; mdwSrcInd < mdwSrcMax ; mdwSrcInd++, dwCnt++)
    {
        ubSrc = mpubSrcRef[mdwSrcInd] ;
        if(ubSrc  == '?')
        {
            mdwSrcInd++ ;
            dwCnt++ ;
            break;  // the ? char is permitted as a terminator only.
        }
        if( (ubSrc  < 'a' ||  ubSrc > 'z')  &&
            (ubSrc  < 'A' ||  ubSrc > 'Z')  &&
            (ubSrc  < '0' ||  ubSrc > '9')  &&
            (ubSrc  != '_')  )
        {
            break ;  // end of keyword token.
        }
    }
    ptkmap[dwTKMindex].aarKeyword.dw = dwCnt ;
    return(dwCnt != 0);
}


BOOL    BisExternKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*  if this token matches either EXTERN_GLOBAL
    or EXTERN_FEATURE, this function sets the approp
    flag in the tokenentry, advances  mdwSrcInd past
    qualifier and returns true.   Else it leaves everything
    undisturbed and returns false.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    DWORD   dwCnt ;   //  counts length of keyword or value string
    BYTE    ubSrc ;   //  a src byte

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;


    if((dwCnt = strlen("EXTERN_GLOBAL"))
        &&  (mdwSrcInd + dwCnt <= mdwSrcMax)
        &&  !strncmp(mpubSrcRef + mdwSrcInd ,  "EXTERN_GLOBAL", dwCnt ))
    {
        ptkmap[dwTKMindex].dwFlags |= TKMF_EXTERN_GLOBAL ;
    }
    else  if(dwCnt = strlen("EXTERN_FEATURE")  &&
        mdwSrcInd + dwCnt <= mdwSrcMax  &&
        !strncmp(mpubSrcRef + mdwSrcInd ,  "EXTERN_FEATURE", dwCnt ))
    {
        ptkmap[dwTKMindex].dwFlags |= TKMF_EXTERN_FEATURE ;
    }
    else
        return(FALSE);

    mdwSrcInd += dwCnt ;  // skip past qualifier
    return(TRUE);
}

BOOL  BisColonNext(
PGLOBL   pglobl)
{
    if(BeatArbitraryWhite(pglobl)  &&  mpubSrcRef[mdwSrcInd] == ':')
    {
        mdwSrcInd++ ;  // advance past colon.
        return(TRUE) ;
    }
    return(FALSE);  // leave pointing to non-colon object.
}

BOOL    BeatArbitraryWhite(
PGLOBL   pglobl)
/*  does nothing if not positioned
    at arbitrary whitespace, returns FALSE
    only if EOF  is encountered.
    Will replace comments and continuation constructs
    with spaces.
*/
{
    BYTE    ubSrc ;   //  a src byte

    while( mdwSrcInd < mdwSrcMax )
    {
        switch(ubSrc = mpubSrcRef[mdwSrcInd])
        {
            case '*':     //  a comment?
            {
                if(mdwSrcInd + 1 < mdwSrcMax  &&
                    mpubSrcRef[mdwSrcInd + 1]  == '%')
                {
                    if(!BeatComment(pglobl) )  // leave pointing at linebreak.
                        return(FALSE) ;  //  reached EOF.
                }
                else
                    return(TRUE) ;  // reached non-white.
                break ;
            }
            case ' ':
            case '\t':
            {
                mdwSrcInd++ ;  // go to next char
                break ;
            }
            case '\r':    // eat continuation constructs
            case '\n':    //  do not process normal EOL chars.
            {
                BYTE   ubTmp ;

                if(mdwSrcInd + 1 < mdwSrcMax)
                {
                    ubTmp = mpubSrcRef[mdwSrcInd + 1] ;
                    if(ubTmp  == '+')
                    {
                        mpubSrcRef[mdwSrcInd] = ' ' ;
                        mpubSrcRef[mdwSrcInd + 1] = ' ' ;
                        mdwSrcInd += 2 ;  // skip past '+'
                        mpSourcebuffer[mCurFile-1].dwLineNumber++ ;
                        break ;
                    }
                    else  if( ((ubTmp  == '\n') || (ubTmp  == '\r'))
                          &&  (ubTmp  != ubSrc)
                          &&  (mdwSrcInd + 2 < mdwSrcMax)
                          &&  (mpubSrcRef[mdwSrcInd + 2]  == '+') )
                    {
                        mpubSrcRef[mdwSrcInd] = ' ' ;
                        mpubSrcRef[mdwSrcInd + 1] = ' ' ;
                        mpubSrcRef[mdwSrcInd + 2] = ' ' ;
                        mdwSrcInd += 3 ;  // skip past '+'
                        mpSourcebuffer[mCurFile-1].dwLineNumber++ ;
                        break ;
                    }
                }
                return(TRUE) ;  // reached logical linebreak.
            }
            default:
                return(TRUE) ;  // reached non-white.
        }
    }
    return(FALSE) ;  //  reached EOF.
}

BOOL    BeatComment(
PGLOBL   pglobl)
//  replaces entire comment  with spaces until
//  linebreak char or EOF  is encountered.
{
    BYTE    ubSrc ;   //  a src byte

    for(  ;  mdwSrcInd < mdwSrcMax  ;  mdwSrcInd++)
    {
        ubSrc = mpubSrcRef[mdwSrcInd] ;
        if(ubSrc == '\n'  ||  ubSrc == '\r' )
            return(TRUE) ;  // reached linebreak char.
        mpubSrcRef[mdwSrcInd] = ' ' ;  // replace with space.
    }
    return(FALSE) ;  //  reached EOF.
}


BOOL    BscanStringSegment(
PGLOBL   pglobl)
//  cursor set just after first "
{
    BYTE    ubSrc  = '\0',   //  a src byte
            ubPrevs ;


    while(  mdwSrcInd < mdwSrcMax  )
    {
        ubPrevs = ubSrc ;
        ubSrc = mpubSrcRef[mdwSrcInd] ;

        if(ubSrc == '<'  &&  ubPrevs  != '%')
        {
            mdwSrcInd++ ;  // skip <
            if(!BscanDelimitedString('>', NULL, pglobl) )
            {
                ERR(("\nMissing closing > in string segment.\n"));
                return(FALSE) ;
            }
            continue ;  // leaves cursor pointing after '>'
        }
        else if(ubSrc == '"'  &&  ubPrevs  != '%')
        {
            mdwSrcInd++ ;  // end of literal string
            return(TRUE) ;
        }
        else if(ubSrc == '\n'  ||  ubSrc == '\r')
            break ;
        else
            mdwSrcInd++ ;  // scan through string
    }
    ERR(("\nLinebreak or EOF was encountered while parsing string segment.\n"));
    return(FALSE) ;
}


BOOL    BscanDelimitedString(
BYTE     ubDelimiter,      //  the byte that signifies the end.
PBOOL    pbMacroDetected,  //  set true if '=' was encountered.
PGLOBL   pglobl)
//  cursor set just after first <
{
    BYTE    ubSrc ;   //  a src byte

    if(pbMacroDetected)
        *pbMacroDetected = FALSE;

    while(  mdwSrcInd < mdwSrcMax  )
    {
        ubSrc = mpubSrcRef[mdwSrcInd] ;

        if(ubSrc == ubDelimiter)
        {       // end of hex substring construct
            mdwSrcInd++ ;
            return(TRUE) ;
        }
        else  if(ubSrc ==  ' '  ||   ubSrc ==  '\t'  ||
            ubSrc ==  '\n'  ||  ubSrc ==  '\r')
        {
            if(!BeatArbitraryWhite(pglobl) )
                break ;
            ubSrc = mpubSrcRef[mdwSrcInd] ;

            if(ubSrc ==  '\n'  ||  ubSrc ==  '\r')
                break ;
        }
        else
        {
            mdwSrcInd++ ;  // keep parsing

            if(ubSrc ==  '='  &&  pbMacroDetected)
                *pbMacroDetected = TRUE ;
        }
    }
    ERR(("unexpected linebreak or EOF.\n"));
    return(FALSE) ;   // BUG_BUG!  unexpected linebreak or EOF
                    //  in hex substring if delimiter was >
                    //  LIST, POINT, etc if delimiter was ).
                    //  command parameter if delimiter was }
}


PARSTATE    PARSTrestorePrevsFile(
PDWORD   pdwTKMindex,
PGLOBL   pglobl)
/*  this function exits with 2 possible codes:
    PARST_EXIT:  no more files left in stack !
    PARST_KEYWORD:  returned to prevs file.  Ready to
        resume parsing of new tokenmap entry.

    The only function that issues PARST_EOF  is  parseKeyword().
    It handles all processing for the previous keyword.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;

    mCurFile-- ;  // pop stack

    MemFree(mpSourcebuffer[mCurFile].pubSrcBuf) ;
    if(mCurFile)
        return(PARST_KEYWORD) ;

    ptkmap[*pdwTKMindex].dwKeywordID = ID_EOF ;
    (*pdwTKMindex)++ ;
    //  this is the last entry in the tokenmap.
    return(PARST_EXIT) ;  //  reached end of rootfile.
}



PWSTR
PwstrAnsiToUnicode(
    IN  PSTR pstrAnsiString,
        PGLOBL   pglobl
)

/*++

Routine Description:

    Make a Unicode copy of the input ANSI string
    Warning: caller must delete Unicode copy when finished

Arguments:

    pstrAnsiString - Pointer to the input ANSI string

Return Value:

    Pointer to the resulting Unicode string
    NULL if there is an error

--*/

{
    PWSTR   pwstr;  // holds Unicode string
    DWORD dwLen ;

    ASSERT(pstrAnsiString != NULL);

    dwLen = strlen(pstrAnsiString) + 1;

    if (pwstr = (PWSTR)MemAlloc(dwLen * sizeof(WCHAR)))
    {
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pstrAnsiString, dwLen,
                    pwstr, dwLen);
        //
        // Make sure the Unicode string is null-terminated
        //
        pwstr[dwLen - 1] = NUL;
    }
    else
    {
        ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
            dwLen * sizeof(WCHAR)));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
    }
    return pwstr;
}


PARSTATE    PARSTloadIncludeFile(
PDWORD   pdwTKMindex,
PWSTR    pwstrRootFileName,    // root GPD file
PGLOBL   pglobl)
/*  this function exits with 2 possible codes:
    PARST_ABORT:  unable to read included file, force termination.
    PARST_KEYWORD:  opened file, updated  SOURCEBUFFER stack,
        ready to parse a new tokenmap entry which will overwrite the
        *Include entry.

    pdwTKMindex points to tokenmap entry containing the
    *include keyword.

    Each Memory Mapped file is referenced by a SOURCEBUFFER
    structure.

    typedef  struct
    {
        PBYTE  pubSrcBuf ;      //  start of file bytes.
        DWORD  dwCurIndex ;     //  stream ptr
        DWORD  dwArraySize ;    //  filesize
        PWSTR   pwstrFileName ;
        HFILEMAP   hFile ;         //  used to access/close file.
    } SOURCEBUFFER, * PSOURCEBUFFER ;
    //  the tagname is 'sb'

*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    ARRAYREF      arStrValue ;  // dest for BparseString.
    PWSTR   pwstrFileName ;  //  , pwstrFullyQualifiedName = NULL;
    WCHAR * pwDLLQualifiedName = NULL ;
    PBYTE   pubFileName ;
    PARSTATE    parst = PARST_KEYWORD;
    PWSTR   pwstrLastBackSlash ;
    DWORD  pathlen = 0 ;
    DWORD  namelen =  0 ;

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;

    //  does a value exist?

    if(ptkmap[*pdwTKMindex].dwFlags & TKMF_NOVALUE  ||
        !BparseString(&(ptkmap[*pdwTKMindex].aarValue), &arStrValue, pglobl) )
    {
        ERR(("syntax error in filename for *Include keyword.\n"));
        //  fatal error.    override initial error code.
        return(PARST_ABORT) ;
    }
#if !defined(DEVSTUDIO)
    //  nothing here !
#endif
    pubFileName = mpubOffRef + arStrValue.loOffset ;

    pwstrFileName = PwstrAnsiToUnicode(pubFileName, pglobl) ;

    if(!pwstrFileName)
    {
        parst = PARST_ABORT ;
        goto FREE_MEM ;
    }
#if !defined(DEVSTUDIO)

    //  how large should pwDLLQualifiedName be???

    pathlen = wcslen(pwstrRootFileName) ;
    namelen =  pathlen + wcslen(pwstrFileName)  + 1;

    if (!(pwDLLQualifiedName =
        (PWSTR)MemAlloc(namelen * sizeof(WCHAR)) ))
    {
        ERR(("Fatal: unable to alloc requested memory: %d WCHARs.\n",
            namelen));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
        return(PARST_ABORT) ;
    }

    wcsncpy(pwDLLQualifiedName, pwstrRootFileName , namelen);

    if (pwstrLastBackSlash = wcsrchr(pwDLLQualifiedName,TEXT('\\')))
    {
        *(pwstrLastBackSlash + 1) = NUL;

        // wcscat(pwDLLQualifiedName, pwstrFileName) ;
        StringCchCatW(pwDLLQualifiedName, namelen, pwstrFileName);
    }
    else
    {
        ERR(("Internal Error: Must specify fully qualified path to Root GPD file.\n"));
        //  fatal error.    override initial error code.
        parst = PARST_ABORT ;
        goto FREE_MEM ;
    }

    if(! BloadFile(pwDLLQualifiedName, pglobl) )
#else
    if(! BloadFile(pwstrFileName, pglobl) )
#endif
        parst = PARST_ABORT ;
    else
        parst = PARST_KEYWORD ;

FREE_MEM:

    if(pwstrFileName)
        MemFree(pwstrFileName) ;
    if(pwDLLQualifiedName)
        MemFree(pwDLLQualifiedName) ;
    return(parst) ;
}


BOOL    BloadFile(
PWSTR   pwstrFileName,
PGLOBL  pglobl)
{
    PBYTE  pub ;
    PGPDFILEDATEINFO    pfdi ;
    DWORD       dwNodeIndex ;
    HANDLE          hFile;


    //  mCurFile points to first uninitialized SOURCEBUFFER element
    if(mCurFile  >= mMaxFiles)
    {
        //  nesting level too deep.

        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_SOURCEBUFFER ;
        }
        return(FALSE) ;
    }


    pfdi = (PGPDFILEDATEINFO) gMasterTable[MTI_GPDFILEDATEINFO].pubStruct ;
    //  address of first GPDFILEDATEINFO struct

    if(! BallocElementFromMasterTable(MTI_GPDFILEDATEINFO , &dwNodeIndex, pglobl) )
    {
        return(FALSE) ;
    }



    mpSourcebuffer[mCurFile].dwFileNameIndex =
        dwStoreFileName(pwstrFileName, &pfdi[dwNodeIndex].arFileName, pglobl) ;
        // store Unicode representation of filename for diagnostic purposes.

    if(mpSourcebuffer[mCurFile].dwFileNameIndex == INVALID_INDEX)
    {
        return(FALSE) ;  // something failed
    }

    mpSourcebuffer[mCurFile].dwLineNumber = 1 ;  // new rule:  line 0 does not exist.


    mpSourcebuffer[mCurFile].hFile = MapFileIntoMemory(
        pwstrFileName, (PVOID  *)&(pub),
        &(mpSourcebuffer[mCurFile].dwArraySize)) ;

    if(!mpSourcebuffer[mCurFile].hFile  || !pub)
    {
        ERR(("unable to open GPD file: %S\n", pwstrFileName));
        //  set fatal error
        geErrorSev = ERRSEV_FATAL ;
        geErrorType = ERRTY_FILE_OPEN ;
        return(FALSE) ;
    }
    //  mapping successful.   allocate writable buffer.
    mpSourcebuffer[mCurFile].pubSrcBuf =
            MemAlloc(mpSourcebuffer[mCurFile].dwArraySize) ;
    if(!(mpSourcebuffer[mCurFile].pubSrcBuf))
    {
        ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
            mpSourcebuffer[mCurFile].dwArraySize));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
        gdwMasterTabIndex = MTI_SOURCEBUFFER ;
        UnmapFileFromMemory(mpSourcebuffer[mCurFile].hFile) ;
        return(FALSE) ;   // This is unrecoverable
    }
    memcpy(mpSourcebuffer[mCurFile].pubSrcBuf,
        pub, mpSourcebuffer[mCurFile].dwArraySize) ;

    UnmapFileFromMemory(mpSourcebuffer[mCurFile].hFile) ;

    //  reopen to determine timestamp.

    hFile  = CreateFile(pwstrFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if(!GetFileTime(hFile, NULL, NULL,
                        &pfdi[dwNodeIndex].FileTime) )
        {
            ERR(("GetFileTime '%S' failed.\n", pwstrFileName));
        }
        CloseHandle(hFile);
    }
    else
    {
        geErrorSev  = ERRSEV_FATAL;
        geErrorType = ERRTY_FILE_OPEN;
        ERR(("CreateFile '%S' failed.\n", pwstrFileName));
    }

    gmrbd.rbd.dwSrcFileChecksum32 =
        ComputeCrc32Checksum(
            mpSourcebuffer[mCurFile].pubSrcBuf,
            mpSourcebuffer[mCurFile].dwArraySize,
            gmrbd.rbd.dwSrcFileChecksum32      ) ;

    mCurFile++ ;  // we now have an open file on the stack
    mdwSrcInd  = 0 ;  // initialize stream ptr to start of file.
    return(TRUE) ;
}


BOOL        BarchiveStrings(
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*
    you see the Memory Mapped file only exists until
    parsing reaches EOF.  At that time its closed.
    And all the aars stored in the tokenmap become useless.
    So to extend their lifetime, we copy the strings to
    a temporary heap.  A heap that isn't going to be
    saved as part of the GPD binary file.
*/
{
    PTKMAP   ptkmap ;   // start of tokenmap
    DWORD   dwKeywordID ;
    ABSARRAYREF    aarDest ;

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;
    dwKeywordID = ptkmap[dwTKMindex].dwKeywordID ;

    if((dwKeywordID != ID_NULLENTRY)  &&  (dwKeywordID != ID_EOF) )
    {
        //  copy keyword string over
        if(!BcopyToTmpHeap(&aarDest, &(ptkmap[dwTKMindex].aarKeyword), pglobl))
            return(FALSE) ;
        ptkmap[dwTKMindex].aarKeyword.pub = aarDest.pub ;
        ptkmap[dwTKMindex].aarKeyword.dw  = aarDest.dw  ;

        if(!(ptkmap[dwTKMindex].dwFlags & TKMF_NOVALUE))
        {
            //  copy value string over.
            if(!BcopyToTmpHeap(&aarDest, &(ptkmap[dwTKMindex].aarValue), pglobl))
                return(FALSE) ;
            ptkmap[dwTKMindex].aarValue.pub = aarDest.pub ;
            ptkmap[dwTKMindex].aarValue.dw  = aarDest.dw  ;
        }
    }
    return(TRUE) ;
}






DWORD  DWidentifyKeyword(
DWORD   dwTKMindex,
PGLOBL  pglobl)
/*  assumes  keywords are not symbol keywords.
    if they are attribute keywords they will be labeled
    as ID_UNRECOGNIZED.
    returns (KeywordID)  */
{
    PTKMAP   ptkmap ;   // start of tokenmap
    DWORD   dwCnt ;   //  counts length of keyword or value string
    DWORD   dwKeyID ;  //  array index of MainKeywordTable
                    //  also serves as the keywordID
    PBYTE   pubKey ;
    DWORD   dwStart, dwEnd ;

    ptkmap = (PTKMAP) gMasterTable[MTI_TOKENMAP].pubStruct ;

    if(ptkmap[dwTKMindex].dwFlags & TKMF_SYMBOL_KEYWORD)
    {
        return(ID_SYMBOL) ;  //  safety net.
    }

    dwStart = mprngDictionary[NON_ATTR].dwStart ;
    dwEnd = mprngDictionary[NON_ATTR].dwEnd ;

    for(dwKeyID = dwStart ;  dwKeyID  < dwEnd  ;  dwKeyID++ )
    {
        pubKey = mMainKeywordTable[dwKeyID].pstrKeyword ;
        dwCnt = strlen(pubKey) ;
        if(dwCnt != ptkmap[dwTKMindex].aarKeyword.dw)
            continue ;
        if(strncmp(ptkmap[dwTKMindex].aarKeyword.pub, pubKey, dwCnt))
            continue ;
        return(dwKeyID);
    }
    return(ID_UNRECOGNIZED) ;    //  does not attempt to identify
            //  attributes, this is done in BInterpretTokens().
}


BOOL    BidentifyAttributeKeyword(
PTKMAP  ptkmap,   // pointer to tokenmap
PGLOBL  pglobl
)
/*
    //  Assume this is an attribute keyword.
    //  If the flags TKMF_EXTERN_GLOBAL or _FEATURE
    //  the GPD author is explicitly identifying
    //  this as an attribute.   Else look at the current
    //  state as an indication of which attribute dictionary
    //  to look at.
*/
{
    DWORD       dwKeywordID ;
    STATE       stOldState;
    KEYWORD_SECTS   eSection ;
    DWORD   dwStart, dwEnd , dwKeyID,
        dwCnt ;   //  counts length of keyword or value string
    PBYTE   pubKey ;

    if(ptkmap->dwFlags & TKMF_EXTERN_GLOBAL )
        eSection = GLOBAL_ATTR ;
    else if(ptkmap->dwFlags & TKMF_EXTERN_FEATURE )
        eSection = FEATURE_ATTR ;
    else
    {
        if(mdwCurStsPtr)
            stOldState = mpstsStateStack[mdwCurStsPtr - 1].stState ;
        else
            stOldState = STATE_ROOT ;
        switch(stOldState)
        {
            case (STATE_ROOT):
            case (STATE_CASE_ROOT):
            case (STATE_DEFAULT_ROOT):
            {
                eSection =  GLOBAL_ATTR;
                break ;
            }
            case (STATE_FEATURE):
            case (STATE_CASE_FEATURE):
            case (STATE_DEFAULT_FEATURE):
            {
                eSection =  FEATURE_ATTR;
                break ;
            }
            case (STATE_OPTIONS):
            case (STATE_CASE_OPTION):
            case (STATE_DEFAULT_OPTION):
            {
                eSection =  OPTION_ATTR;
                break ;
            }
            case (STATE_COMMAND):
            {
                eSection =  COMMAND_ATTR;
                break ;
            }
            case (STATE_FONTCART):
            {
                eSection = FONTCART_ATTR ;
                break ;
            }
            case (STATE_TTFONTSUBS):
            {
                eSection = TTFONTSUBS_ATTR ;
                break ;
            }
            case (STATE_OEM):
            {
                eSection = OEM_ATTR ;
                break ;
            }
            default:   //  STATE_UIGROUP, STATE_SWITCH_anything  etc.
            {
                return(FALSE);  // no attributes allowed in this state.
            }
        }
    }
    dwStart = mprngDictionary[eSection].dwStart ;
    dwEnd = mprngDictionary[eSection].dwEnd ;

    for(dwKeyID = dwStart ;  dwKeyID  < dwEnd  ;  dwKeyID++ )
    {
        pubKey = mMainKeywordTable[dwKeyID].pstrKeyword ;
        dwCnt = strlen(pubKey) ;
        if(dwCnt != ptkmap->aarKeyword.dw)
            continue ;
        if(strncmp(ptkmap->aarKeyword.pub, pubKey, dwCnt))
            continue ;
        ptkmap->dwKeywordID = dwKeyID;
        return(TRUE);
    }
    return(FALSE);  // keyword not found in dictionary.
}


BOOL    BcopyToTmpHeap(
PABSARRAYREF    paarDest,
PABSARRAYREF    paarSrc,
PGLOBL          pglobl)
/*  copy aarstring to the temp heap
    does not create null terminated strings!  */
{

#define  mpubOffReft     (gMasterTable[MTI_TMPHEAP].pubStruct)
#define  mloCurHeapt     (gMasterTable[MTI_TMPHEAP].dwCurIndex)
#define  mdwMaxHeapt     (gMasterTable[MTI_TMPHEAP].dwArraySize)

    if(mloCurHeapt + paarSrc->dw >= mdwMaxHeapt)
    {
        ERR(("Out of heap space, restart.\n"));

        if(ERRSEV_RESTART > geErrorSev)
        {
            geErrorSev = ERRSEV_RESTART ;
            geErrorType = ERRTY_MEMORY_ALLOCATION ;
            gdwMasterTabIndex = MTI_TMPHEAP ;
        }
        return(FALSE) ;
    }
    paarDest->dw = paarSrc->dw ;
    paarDest->pub = mpubOffReft + mloCurHeapt ;

    memcpy(paarDest->pub, paarSrc->pub, paarSrc->dw ) ;
    mloCurHeapt += paarSrc->dw ;
    return(TRUE) ;

#undef  mpubOffReft
#undef  mloCurHeapt
#undef  mdwMaxHeapt
}


#define     mCurFileName   (gMasterTable[MTI_FILENAMES].dwCurIndex)
#define     mpFileNamesArray  ((PWSTR *)(gMasterTable \
                            [MTI_FILENAMES].pubStruct))



DWORD    dwStoreFileName(PWSTR    pwstrFileName,
PARRAYREF   parDest,
PGLOBL      pglobl)
    // goes into a permanent
    //  stack of filenames - to be deleted at return buffers
    //  time.   Returns index in array where name has been
    //  stored.
    //  also saves filename into heap.  So we can access the GPD file
    //  and check its timestamp whenever we load the BUD file.
{
    DWORD  dwNodeIndex, dwLen ;

    if(!BallocElementFromMasterTable(MTI_FILENAMES, &dwNodeIndex, pglobl))
        return(INVALID_INDEX) ;

    dwLen = wcslen(pwstrFileName) + 1 ;  // need room for terminating null.
    mpFileNamesArray[dwNodeIndex] = MemAlloc(dwLen * 2) ;
    if(!mpFileNamesArray[dwNodeIndex])
    {
        ERR(("Fatal: unable to alloc requested memory: %d bytes.\n",
            dwLen * 2));
        geErrorType = ERRTY_MEMORY_ALLOCATION ;
        geErrorSev = ERRSEV_FATAL ;
        return(INVALID_INDEX) ;
    }
    // wcscpy(mpFileNamesArray[dwNodeIndex], pwstrFileName) ;
    StringCchCopyW(mpFileNamesArray[dwNodeIndex], dwLen, pwstrFileName) ;

    parDest->dwCount = (dwLen - 1) * 2 ;  // doesn't include the NUL term.

    if(!BwriteToHeap(&parDest->loOffset, (PBYTE)pwstrFileName, dwLen * 2, 2, pglobl) )  //  includes Null termination
        return(INVALID_INDEX) ;

    return(dwNodeIndex) ;
}



VOID    vFreeFileNames(
PGLOBL   pglobl )
{

    //  free all buffers holding the filenames.

    while(mCurFileName)
    {
        mCurFileName-- ;  // pop stack
        MemFree(mpFileNamesArray[mCurFileName]) ;
    }
}


VOID    vIdentifySource(
    PTKMAP   ptkmap,
    PGLOBL   pglobl )
{
    PWSTR    pwstrFileName ;

    if(ptkmap->dwKeywordID  ==  ID_EOF)
    {
        ERR(("\nEnd of File reached.\n")) ;
        return;
    }

    pwstrFileName = mpFileNamesArray[ptkmap->dwFileNameIndex] ;

    if(pwstrFileName)
#if defined(DEVSTUDIO)  //  Emit compiler-style line messages
        ERR(("\n%S(%d): ", pwstrFileName, ptkmap->dwLineNumber)) ;
#else
        ERR(("\n%S: line: %d ...\n", pwstrFileName, ptkmap->dwLineNumber)) ;
#endif
}


#undef  mCurFileName
#undef  mpFileNamesArray
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\gpd\states.c ===
//   Copyright (c) 1996-1999  Microsoft Corporation
------ state of the system ---------

Each parsing of an open brace should change
the state of the system.

As a feature, option, switch(feature), case(option)
or other construct is parsed  this is noted.

this construct stack allows us to select the appropriate
context for parsing:

is this a local keyword to this option (construct) or is it
EXTERN:?

What tree structure should be built for this construct?

then the parsing code should continue parsing
tokens as normal.


There will be tables that state what the
local keywords are for each situation.

constructs:
UIGroup, Feature, Option, Switch, Case,
Commands, Font, OEM



state stack:
each state is of the form:  state / symbol

The stack is empty at the root level.

state   allowed transitions         may contain

root     UIGroup                    any global attributes
         Feature
         Switch
         Commands
         Font
         OEM

UIGroup  Feature                    none
         UIGroup

Feature  Switch                     feature attributes
         Options

Switch   Case                       none

Options  Switch                     option attributes
                                    relocatable Global Attributes

Case     Switch
                                    relocatable local Attributes
                                       of immediately enclosing
                                       construct outside of Switch.
                                    relocatable Global Attributes

Commands none                       command attributes

ShortCommands none                  cmdName:invocation

Font     none                       font attributes

OEM      none                       oem  attributes


Note:  Commands and Fonts are considered
relocatable Global Attributes

Tables:  root attributes (divide into relocatable and non)
         feature attributes  ()
         option attributes    ()
         command attributes
         font attributes
         oem  attributes

Tables of allowed transitions:

Rules: how to construct a tree and where to plant the tree
   for a local or global attribute


----  implementation of this state machine -------

typedef  enum  {CONSTRUCT, LOCAL, GLOBAL,
         INVALID_CONSTRUCT, INVALID_LOCAL,  INVALID_GLOBAL,
         INVALID_UNRECOGNIZED, COMMENT, EOF }  keywordClass ;

GroundState()
{
   STATE  StateStack[] ;

   for(1)
   {
      extract Keyword(keyword)
      class = ClassifyKeyword(keyword)
      switch (class)
      {
         case  (CONSTRUCT):
            parseSymbol(symbol) ;
            parseOpenBrace() ; //  somewhere we need to register symbol
                           //  and allocate memory for structure
                           //  and return ptr or index to new
                           //  or existing structure
            changeState(keyword) ;
         case  (COMMENT):
            absorbCommentLine() ;
         case  (LOCAL) :
            ProcessLocalAttribute(keyword) ;
         case  (GLOBAL) :
            ProcessGlobalAttribute(keyword) ;
         case  (SPECIAL) :
            ProcessSpecialAttribute(keyword) ;
         case  (EOF)
            return(1);
         default:
            ErrorHandling() ;
      }
      if(rc == FATAL)
         return(1);
   }
}

class = ClassifyKeyword(keyword)
{

   if(commentline)
      return(COMMENT) ;
   if(EOF)
      return(EOF) ;

   The current state determines which sets of
   keywords are allowed.

   state = DetermineCurrentState()

   implement this table:

   for each state there is a list of all the keywords
   arranged in a fixed order (by keyword ID) each keyword
   is assigned a classification:
      Valid Constructs
      InValid Constructs
      Valid Local Attribute
      InValid Local Attribute
      Valid Global Attribute
      InValid Global Attribute
      Valid Special Attribute
      InValid Special Attribute

   if(keyword not found it table)
      return(INVALID_UNRECOGNIZED) ;

   return(classTable[keyword][state]) ;
}

typedef  enum {ROOT, UIGROUP, FEATURE, SWITCH, OPTIONS, CASE_ROOT,
         CASE_FEATURE, CASE_OPTION, COMMAND, SHORT_COMMAND,
         FONT, OEM, any other passive construct} STATES ;

Sample Table

KEYWORD                STATES ---->
                                                         *Command
                      *UIGroup  *Switch   *CaseRoot *CaseOption    *Font
                 *Root     *Feature  *Options  *CaseFeature   *ShortCmd *OEM
UIGroup        : VC   VC   IC   IC   IC   IC   IC   IC   IC   IC   IC   IC
Feature        : VC   VC   IC   IC   IC   IC   IC   IC   IC   IC   IC   IC
Switch         : VC   IC   VC   IC   VC   VC   VC   VC   IC   IC   IC   IC
Options        : IC   IC   VC   IC   IC   IC   IC   IC   IC   IC   IC   IC
Case           : IC   IC   IC   VC   IC   IC   IC   IC   IC   IC   IC   IC
Command        : VC   IC   IC   IC   VC   VC   VC   VC   IC   IC   IC   IC
Font           : VC   IC   IC   IC   VC   VC   VC   VC   IC   IC   IC   IC
OEM            : VC   IC   IC   IC   IC   IC   IC   IC   IC   IC   IC   IC
UIConstraints  : IS   IS   VS   IS   VS   IS   IS   IS   IS   IS   IS   IS

note:  UIConstraints appearing in a Feature is treated differently
   than appearing under Options.  The processing of UIConstraints
   causes one, two or many elements to be added to the Constraints
   Array.  This is in stark contrast to normal keywords hence
   the classification of Special.




state stack:
each state is of the form:  state / symbol

DetermineCurrentState()
{
   //  this state is only used to determine
   //  which catagories of keywords are
   //  assigned which TYPES in ClassifyKeyword().

   if(CurState == 0)
      return(ROOT) ;  // No further processing needed.
   return(stateStack[CurState - 1].state) ;
}

changeState(keyword, symbol, mode)
{

    // Change needed:  shortcut  *Command
    // does not initiate a state change.  This should
    // be treated as a special keyword.


   // mode determines if the *Command keyword
   // introduces a normal command construct or
   // the short version.

   switch(keyword)
   {
      case (*UIGroup):
         addState(UIGROUP, symbol);
      case (*Feature):
         addState(FEATURE, symbol);
      case (*Switch):
         addState(SWITCH, symbol);
      case (*Option):
         addState(OPTIONS, symbol);
      case (*Font):
         addState(FONT, symbol);
      case (*OEM):
         addState(OEM, symbol);
      case (*Command):
      {
         if(mode == short)
            addState(SHORT_CMD, symbol);
         else
            addState(COMMAND, symbol);
      }
      case (*Case):
      {
         if(stateStack[CurState - 2].state == ROOT  ||
            stateStack[CurState - 2].state == CASE_ROOT)
            addState(CASE_ROOT, symbol);
         if(stateStack[CurState - 2].state == FEATURE  ||
            stateStack[CurState - 2].state == CASE_FEATURE)
            addState(CASE_FEATURE, symbol);
         if(stateStack[CurState - 2].state == OPTIONS  ||
            stateStack[CurState - 2].state == CASE_OPTIONS)
            addState(CASE_OPTIONS, symbol);
      }
   }
}



//  these two functions will grow an appropriate
//  tree for each keyword based on the StateStack
//  and plant the tree in the appropriate attribute
//  field in the appropriate structure, (index) etc.
//  or add a branch to an existing tree,
//  and set the value at the node of the tree.

ProcessLocalAttribute(keyword) ;
ProcessGlobalAttribute(keyword, lpvalue)
{
   locate entry in Dglobals corresponding
   to keyword.

   OR the current branch (constructed using the state stack)
   with any existing tree pointed to by entry in Dglobals.

   if this branch exists in the existing tree, locate the offset
   in heap and overwrite that by
   (lptype)(lpRef + attributeTree[i].offset) = (lptype)lpvalue ;

   otherwise
   offset = lpCurHeapPos - lpRef ;
   lpCurHeapPos += sizeof(datatype) ;

   Note:  an attribute tree  should not be constructed
   piecemeal.  It is an error if the tree is subsequently
   redefined/elaborated using a different feature nesting
   order.

}


may need to keep a table for each keyword
with the following info per keyword.

keyword, datastructure, offset within datastructure, sizeof(data)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\ppd\ppd.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppd.c

Abstract:

    Public interface to the PPD parser

Environment:

    Windows NT PostScript driver

Revision History:

    10/14/96 -davidx-
        Add new interface function MapToDeviceOptIndex.

    09/30/96 -davidx-
        Cleaner handling of ManualFeed and AutoSelect feature.

    09/24/96 -davidx-
        Implement ResolveUIConflicts.

    09/23/96 -davidx-
        Implement ChangeOptionsViaID.

    08/30/96 -davidx-
        Changes after the 1st code review.

    08/19/96 -davidx-
        Implemented most of the interface functions except:
            ChangeOptionsViaID
            ResolveUIConflicts

    08/16/96 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"

#ifndef KERNEL_MODE

#ifndef WINNT_40

#include "appcompat.h"

#else  // WINNT_40

#endif // !WINNT_40

#endif // !KERNEL_MODE

//
// Forward declaration of local static functions
//

BOOL BCheckFeatureConflict(PUIINFO, POPTSELECT, DWORD, PDWORD, DWORD, DWORD);
BOOL BCheckFeatureOptionConflict(PUIINFO, DWORD, DWORD, DWORD, DWORD);
BOOL BSearchConstraintList(PUIINFO, DWORD, DWORD, DWORD);
DWORD DwReplaceFeatureOption(PUIINFO, POPTSELECT, DWORD, DWORD, DWORD);
DWORD DwInternalMapToOptIndex(PUIINFO, PFEATURE, LONG, LONG, PDWORD);


//
// DeleteRawBinaryData only called from driverui
//
#ifndef KERNEL_MODE

void
DeleteRawBinaryData(
    IN PTSTR    ptstrPpdFilename
    )

/*++

Routine Description:

    Delete raw binary printer description data.

Arguments:

    ptstrDataFilename - Specifies the name of the original printer description file

Return Value:

    none

--*/

{
    PTSTR           ptstrBpdFilename;

    // only for test purposes. Upgrades are hard to debug...
    ERR(("Deleting .bpd file\n"));

    //
    // Sanity check
    //

    if (ptstrPpdFilename == NULL)
    {
        RIP(("PPD filename is NULL.\n"));
        return;
    }

    //
    // Generate BPD filename from the specified PPD filename
    //

    if (! (ptstrBpdFilename = GenerateBpdFilename(ptstrPpdFilename)))
        return;

    if (!DeleteFile(ptstrBpdFilename))
        ERR(("DeleteRawBinaryData failed: %d\n", GetLastError()));

    MemFree(ptstrBpdFilename);
}
#endif


PRAWBINARYDATA
LoadRawBinaryData(
    IN PTSTR    ptstrDataFilename
    )

/*++

Routine Description:

    Load raw binary printer description data.

Arguments:

    ptstrDataFilename - Specifies the name of the original printer description file

Return Value:

    Pointer to raw binary printer description data
    NULL if there is an error

--*/

{
    PRAWBINARYDATA  pRawData;

    //
    // Sanity check
    //

    if (ptstrDataFilename == NULL)
    {
        RIP(("PPD filename is NULL.\n"));
        return NULL;
    }

    //
    // Attempt to load cached binary printer description data first
    //

    if ((pRawData = PpdLoadCachedBinaryData(ptstrDataFilename)) == NULL)
    {
        #if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

        //
        // If there is no cached binary data or it's out-of-date, we'll parse
        // the ASCII text file and cache the resulting binary data.
        //

        pRawData = PpdParseTextFile(ptstrDataFilename);

        #endif
    }

    //
    // Initialize various pointer fields inside the printer description data
    //

    if (pRawData)
    {
        PINFOHEADER pInfoHdr;
        PUIINFO     pUIInfo;
        PPPDDATA    pPpdData;

        pInfoHdr = (PINFOHEADER) pRawData;
        pUIInfo = GET_UIINFO_FROM_INFOHEADER(pInfoHdr);
        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pInfoHdr);

        ASSERT(pUIInfo != NULL && pUIInfo->dwSize == sizeof(UIINFO));
        ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

        pRawData->pvReserved = NULL;
        pRawData->pvPrivateData = pRawData;

        pUIInfo->pubResourceData = (PBYTE) pInfoHdr;
        pUIInfo->pInfoHeader = pInfoHdr;

        #ifndef KERNEL_MODE

            #ifndef WINNT_40  // Win2K user mode driver

            if (GetAppCompatFlags2(VER40) & GACF2_NOCUSTOMPAPERSIZES)
            {
                pUIInfo->dwFlags &= ~FLAG_CUSTOMSIZE_SUPPORT;
            }

            #else  // WINNT_40

            /* NT4 solution here */

            #endif // !WINNT_40

        #endif  // !KERNEL_MODE
    }

    if (pRawData == NULL)
        ERR(("LoadRawBinaryData failed: %d\n", GetLastError()));

    return pRawData;
}



VOID
UnloadRawBinaryData(
    IN PRAWBINARYDATA   pRawData
    )

/*++

Routine Description:

    Unload raw binary printer description data previously loaded using LoadRawBinaryData

Arguments:

    pRawData - Points to raw binary printer description data

Return Value:

    NONE

--*/

{
    ASSERT(pRawData != NULL);
    MemFree(pRawData);
}



PINFOHEADER
InitBinaryData(
    IN PRAWBINARYDATA   pRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    )

/*++

Routine Description:

    Initialize and return an instance of binary printer description data

Arguments:

    pRawData - Points to raw binary printer description data
    pInfoHdr - Points to an existing of binary data instance
    pOptions - Specifies the options used to initialize the binary data instance

Return Value:

    Pointer to an initialized binary data instance

Note:

    If pInfoHdr parameter is NULL, the parser returns a new binary data instance
    which should be freed by calling FreeBinaryData. If pInfoHdr parameter is not
    NULL, the existing binary data instance is reinitialized.

    If pOption parameter is NULL, the parser should use the default option values
    for generating the binary data instance. The parser may have special case
    optimization to handle this case.

--*/

{
    //
    // For PPD parser, all instances of the binary printer description
    // are the same as the original raw binary data.
    //

    ASSERT(pRawData != NULL && pRawData == pRawData->pvPrivateData);
    ASSERT(pInfoHdr == NULL || pInfoHdr == (PINFOHEADER) pRawData);

    return (PINFOHEADER) pRawData;
}



VOID
FreeBinaryData(
    IN PINFOHEADER pInfoHdr
    )

/*++

Routine Description:

    Free an instance of the binary printer description data

Arguments:

    pInfoHdr - Points to a binary data instance previously returned from an
        InitBinaryData(pRawData, NULL, pOptions) call

Return Value:

    NONE

--*/

{
    //
    // For PPD parser, there is nothing to be done here.
    //

    ASSERT(pInfoHdr != NULL);
}



PINFOHEADER
UpdateBinaryData(
    IN PRAWBINARYDATA   pRawData,
    IN PINFOHEADER      pInfoHdr,
    IN POPTSELECT       pOptions
    )

/*++

Routine Description:

    Update an instance of binary printer description data

Arguments:

    pRawData - Points to raw binary printer description data
    pInfoHdr - Points to an existing of binary data instance
    pOptions - Specifies the options used to update the binary data instance

Return Value:

    Pointer to the updated binary data instance
    NULL if there is an error

--*/

{
    //
    // For PPD parser, there is nothing to be done here.
    //

    ASSERT(pRawData != NULL && pRawData == pRawData->pvPrivateData);
    ASSERT(pInfoHdr == NULL || pInfoHdr == (PINFOHEADER) pRawData);

    return pInfoHdr;
}



BOOL
InitDefaultOptions(
    IN PRAWBINARYDATA   pRawData,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    )

/*++

Routine Description:

    Initialize the option array with default settings from the printer description file

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures for storing the default settings
    iMaxOptions - Max number of entries in pOptions array
    iMode - Specifies what the caller is interested in:
        MODE_DOCUMENT_STICKY
        MODE_PRINTER_STICKY
        MODE_DOCANDPRINTER_STICKY

Return Value:

    FALSE if the input option array is not large enough to hold
    all default option values, TRUE otherwise.

--*/

{
    INT         iStart, iOptions, iIndex;
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeature;
    POPTSELECT  pTempOptions;
    BOOL        bResult = TRUE;

    ASSERT(pOptions != NULL);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    iOptions = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;
    ASSERT(iOptions <= MAX_PRINTER_OPTIONS);

    if ((pTempOptions = MemAllocZ(MAX_PRINTER_OPTIONS*sizeof(OPTSELECT))) == NULL)
    {
        ERR(("Memory allocation failed\n"));

        ZeroMemory(pOptions, iMaxOptions*sizeof(OPTSELECT));
        return FALSE;
    }

    //
    // Construct the default option array
    //

    ASSERT(NULL_OPTSELECT == 0);

    for (iIndex = 0; iIndex < iOptions; iIndex++)
    {
        pFeature = PGetIndexedFeature(pUIInfo, iIndex);

        ASSERT(pFeature != NULL);

        pTempOptions[iIndex].ubCurOptIndex = (BYTE)
            ((pFeature->dwFlags & FEATURE_FLAG_NOUI) ?
                OPTION_INDEX_ANY :
                pFeature->dwDefaultOptIndex);
    }

    //
    // Resolve any conflicts between default option selections
    //

    ResolveUIConflicts(pRawData, pTempOptions, MAX_PRINTER_OPTIONS, iMode);

    //
    // Determine if the caller is interested in doc- and/or printer-sticky options
    //

    switch (iMode)
    {
    case MODE_DOCUMENT_STICKY:

        iStart = 0;
        iOptions = pRawData->dwDocumentFeatures;
        break;

    case MODE_PRINTER_STICKY:

        iStart = pRawData->dwDocumentFeatures;
        iOptions = pRawData->dwPrinterFeatures;
        break;

    default:

        ASSERT(iMode == MODE_DOCANDPRINTER_STICKY);
        iStart = 0;
        break;
    }

    //
    // Make sure the input option array is large enough
    //

    if (iOptions > iMaxOptions)
    {
        RIP(("Option array too small: %d < %d\n", iMaxOptions, iOptions));
        iOptions = iMaxOptions;
        bResult = FALSE;
    }

    //
    // Copy the default option array
    //

    CopyMemory(pOptions, pTempOptions+iStart, iOptions*sizeof(OPTSELECT));

    MemFree(pTempOptions);
    return bResult;
}



VOID
ValidateDocOptions(
    IN PRAWBINARYDATA   pRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions
    )

/*++

Routine Description:

    Validate the devmode option array and correct any invalid option selections

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures that need validation
    iMaxOptions - Max number of entries in pOptions array

Return Value:

    None

--*/

{
    INT         cFeatures, iIndex;
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;

    ASSERT(pOptions != NULL);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);
    ASSERT(pUIInfo != NULL);

    cFeatures = pRawData->dwDocumentFeatures;
    ASSERT(cFeatures <= MAX_PRINTER_OPTIONS);

    if (cFeatures > iMaxOptions)
    {
        RIP(("Option array too small: %d < %d\n", iMaxOptions, cFeatures));
        cFeatures = iMaxOptions;
    }

    //
    // loop through doc-sticky features to validate each option selection(s)
    //

    for (iIndex = 0; iIndex < cFeatures; iIndex++)
    {
        PFEATURE pFeature;
        INT      cAllOptions, cSelectedOptions, iNext;
        BOOL     bValid;

        if ((pOptions[iIndex].ubCurOptIndex == OPTION_INDEX_ANY) &&
            (pOptions[iIndex].ubNext == NULL_OPTSELECT))
        {
            //
            // We use OPTION_INDEX_ANY intentionally, so don't change it.
            //

            continue;
        }

        pFeature = PGetIndexedFeature(pUIInfo, iIndex);
        ASSERT(pFeature != NULL);

        //
        // number of available options
        //

        cAllOptions = pFeature->Options.dwCount;

        //
        // number of selected options
        //

        cSelectedOptions = 0;

        iNext = iIndex;

        bValid = TRUE;

        do
        {
            cSelectedOptions++;

            if ((iNext >= iMaxOptions) ||
                (pOptions[iNext].ubCurOptIndex >= cAllOptions) ||
                (cSelectedOptions > cAllOptions))
            {
                //
                // either the option index is out of range,
                // or the current option selection is invalid,
                // or the number of selected options (for PICKMANY)
                // exceeds available options
                //

                bValid = FALSE;
                break;
            }

            iNext = pOptions[iNext].ubNext;

        } while (iNext != NULL_OPTSELECT);

        if (!bValid)
        {
            ERR(("Corrected invalid option array value for feature %d\n", iIndex));

            pOptions[iIndex].ubCurOptIndex = (BYTE)
                ((pFeature->dwFlags & FEATURE_FLAG_NOUI) ?
                    OPTION_INDEX_ANY :
                    pFeature->dwDefaultOptIndex);

            pOptions[iIndex].ubNext = NULL_OPTSELECT;
        }
    }
}



BOOL
CheckFeatureOptionConflict(
    IN PRAWBINARYDATA   pRawData,
    IN DWORD            dwFeature1,
    IN DWORD            dwOption1,
    IN DWORD            dwFeature2,
    IN DWORD            dwOption2
    )

/*++

Routine Description:

    Check if (dwFeature1, dwOption1) constrains (dwFeature2, dwOption2)

Arguments:

    pRawData - Points to raw binary printer description data
    dwFeature1, dwOption1 - Feature and option indices of the first feature/option pair
    dwFeature2, dwOption2 - Feature and option indices of the second feature/option pair

Return Value:

    TRUE if (dwFeature1, dwOption1) constrains (dwFeature2, dwOption2)
    FALSE otherwise

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    return BCheckFeatureOptionConflict(pUIInfo, dwFeature1, dwOption1, dwFeature2, dwOption2);
}



BOOL
ResolveUIConflicts(
    IN PRAWBINARYDATA   pRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    )

/*++

Routine Description:

    Resolve any conflicts between printer feature option selections

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures for storing the modified options
    iMaxOptions - Max number of entries in pOptions array
    iMode - Specifies how the conflicts should be resolved:
        MODE_DOCUMENT_STICKY - only resolve conflicts between doc-sticky features
        MODE_PRINTER_STICKY - only resolve conflicts between printer-sticky features
        MODE_DOCANDPRINTER_STICKY - resolve conflicts all features

Return Value:

    TRUE if there is no conflicts between printer feature option selection
    FALSE otherwise

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeatures;
    PDWORD      pdwFlags;
    POPTSELECT  pTempOptions;
    DWORD       dwStart, dwOptions, dwIndex, dwTotalFeatureCount;
    BOOL        bReturnValue = TRUE;
    BOOL        bCheckConflictOnly;

    struct _PRIORITY_INFO {

        DWORD   dwFeatureIndex;
        DWORD   dwPriority;

    } *pPriorityInfo;

    ASSERT(pOptions);

    //
    // Initialize pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    pFeatures = OFFSET_TO_POINTER(pInfoHdr, pUIInfo->loFeatureList);
    dwTotalFeatureCount = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;

    if (iMaxOptions < (INT) dwTotalFeatureCount)
    {
        ERR(("Option array for ResolveUIConflicts is too small.\n"));
        return bReturnValue;
    }

    //
    // Determine if the caller is interested in doc- and/or printer-sticky options
    //

    bCheckConflictOnly = ((iMode & DONT_RESOLVE_CONFLICT) != 0);
    iMode &= ~DONT_RESOLVE_CONFLICT;

    switch (iMode)
    {
    case MODE_DOCUMENT_STICKY:

        dwStart = 0;
        dwOptions = pRawData->dwDocumentFeatures;
        break;

    case MODE_PRINTER_STICKY:

        dwStart = pRawData->dwDocumentFeatures;
        dwOptions = pRawData->dwPrinterFeatures;
        break;

    default:

        ASSERT(iMode == MODE_DOCANDPRINTER_STICKY);
        dwStart = 0;
        dwOptions = dwTotalFeatureCount;
        break;
    }

    if (dwOptions == 0)
        return TRUE;

    //
    // This problem is not completely solvable in the worst case.
    // But the approach below should work if the PPD is well-formed.
    //
    //  for each feature starting from the highest priority one
    //  and down to the lowest priority one do:
    //    for each selected option of the feature do:
    //      if the option is not constrained, continue
    //      else do one of the following:
    //        if the conflict feature has lower priority, continue
    //        else resolve the current feature/option pair:
    //          if UIType is PickMany, deselect the current option
    //          else try to change the option to:
    //            Default option
    //            each option of the feature in sequence
    //            OPTION_INDEX_ANY as the last resort
    //

    pPriorityInfo = MemAlloc(dwOptions * sizeof(struct _PRIORITY_INFO));
    pTempOptions = MemAlloc(iMaxOptions * sizeof(OPTSELECT));
    pdwFlags = MemAllocZ(dwOptions * sizeof(DWORD));

    if (pPriorityInfo && pTempOptions && pdwFlags)
    {
        //
        // Copy the options array into a temporary working buffer
        //

        CopyMemory(pTempOptions, pOptions, sizeof(OPTSELECT) * iMaxOptions);

        //
        // Sort the feature indices according to their priority
        //

        for (dwIndex = 0; dwIndex < dwOptions; dwIndex++)
        {
            pPriorityInfo[dwIndex].dwFeatureIndex = dwIndex + dwStart;
            pPriorityInfo[dwIndex].dwPriority = pFeatures[dwIndex + dwStart].dwPriority;
        }

        for (dwIndex = 0; dwIndex < dwOptions; dwIndex++)
        {
            struct _PRIORITY_INFO tempPriorityInfo;
            DWORD dwLoop, dwMax = dwIndex;

            for (dwLoop = dwIndex + 1; dwLoop < dwOptions; dwLoop++)
            {
                if (pPriorityInfo[dwLoop].dwPriority > pPriorityInfo[dwMax].dwPriority)
                    dwMax = dwLoop;
            }

            if (dwMax != dwIndex)
            {
                tempPriorityInfo = pPriorityInfo[dwMax];
                pPriorityInfo[dwMax] = pPriorityInfo[dwIndex];
                pPriorityInfo[dwIndex] = tempPriorityInfo;
            }
        }

        //
        // Loop through every feature, starting from the highest
        // priority one down to the lowest priority one.
        //

        for (dwIndex = 0; dwIndex < dwOptions; )
        {
            DWORD   dwCurFeature, dwCurOption, dwCurNext;
            BOOL    bConflict = FALSE;

            //
            // Loop through every selected option of the current feature
            //

            dwCurNext = dwCurFeature = pPriorityInfo[dwIndex].dwFeatureIndex;

            do
            {
                DWORD   dwFeature, dwOption, dwNext;

                dwCurOption = pTempOptions[dwCurNext].ubCurOptIndex;
                dwCurNext = pTempOptions[dwCurNext].ubNext;

                //
                // Check if the current feature/option pair is constrained
                //

                for (dwFeature = dwStart; dwFeature < dwStart + dwOptions; dwFeature++)
                {
                    dwNext = dwFeature;

                    do
                    {
                        dwOption = pTempOptions[dwNext].ubCurOptIndex;
                        dwNext = pTempOptions[dwNext].ubNext;

                        if (BCheckFeatureOptionConflict(pUIInfo,
                                                        dwFeature,
                                                        dwOption,
                                                        dwCurFeature,
                                                        dwCurOption))
                        {
                            bConflict = TRUE;
                            break;
                        }
                    }
                    while (dwNext != NULL_OPTSELECT);

                    //
                    // Check if a conflict was detected
                    //

                    if (bConflict)
                    {
                        VERBOSE(("Conflicting option selections: (%d, %d) - (%d, %d)\n",
                                 dwFeature, dwOption,
                                 dwCurFeature, dwCurOption));

                        if (pdwFlags[dwFeature - dwStart] & 0x10000)
                        {
                            //
                            // The conflicting feature has higher priority than
                            // the current feature. Change the selected option
                            // of the current feature.
                            //

                            pdwFlags[dwCurFeature - dwStart] =
                                DwReplaceFeatureOption(pUIInfo,
                                                       pTempOptions,
                                                       dwCurFeature,
                                                       dwCurOption,
                                                       pdwFlags[dwCurFeature - dwStart]);
                        }
                        else
                        {
                            //
                            // The conflicting feature has lower priority than
                            // the current feature. Change the selected option
                            // of the conflicting feature.
                            //

                            pdwFlags[dwFeature - dwStart] =
                                DwReplaceFeatureOption(pUIInfo,
                                                       pTempOptions,
                                                       dwFeature,
                                                       dwOption,
                                                       pdwFlags[dwFeature - dwStart]);
                        }

                        break;
                    }
                }
            }
            while ((dwCurNext != NULL_OPTSELECT) && !bConflict);

            //
            // If no conflict is found for the selected options of
            // the current feature, then move on to the next feature.
            // Otherwise, repeat the loop on the current feature.
            //

            if (! bConflict)
            {
                //
                // Make the current feature as visited
                //

                pdwFlags[dwCurFeature - dwStart] |= 0x10000;

                dwIndex++;
            }
            else
            {
                //
                // If a conflict is found, set the return value to false
                //

                bReturnValue = FALSE;
            }
        }

        //
        // Copy the resolved options array from the temporary working
        // buffer back to the input options array. This results in
        // all option selections being compacted at the beginning
        // of the array.
        //

        if (! bCheckConflictOnly)
        {
            INT iNext = (INT) dwTotalFeatureCount;

            for (dwIndex = 0; dwIndex < dwTotalFeatureCount; dwIndex ++)
            {
                VCopyOptionSelections(pOptions,
                                      dwIndex,
                                      pTempOptions,
                                      dwIndex,
                                      &iNext,
                                      iMaxOptions);
            }
        }
    }
    else
    {
        //
        // If we couldn't allocate temporary working buffer,
        // then return to the caller without doing anything.
        //

        ERR(("Memory allocation failed.\n"));
    }

    MemFree(pTempOptions);
    MemFree(pdwFlags);
    MemFree(pPriorityInfo);

    return bReturnValue;
}



BOOL
EnumEnabledOptions(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    OUT PBOOL           pbEnabledOptions,
    IN INT              iMode
    )

/*++

Routine Description:

    Determine which options of the specified feature should be enabled
    based on the current option selections of printer features

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to the current feature option selections
    dwFeatureIndex - Specifies the index of the feature in question
    pbEnabledOptions - An array of BOOLs, each entry corresponds to an option
        of the specified feature. On exit, if the entry is TRUE, the corresponding
        option is enabled. Otherwise, the corresponding option should be disabled.
    iMode - Specifies what the caller is interested in:
         MODE_DOCUMENT_STICKY
         MODE_PRINTER_STICKY
         MODE_DOCANDPRINTER_STICKY

Return Value:

    TRUE if any option for the specified feature is enabled,
    FALSE if all options of the specified feature are disabled
    (i.e. the feature itself is disabled)

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeature;
    DWORD       dwIndex, dwCount;
    BOOL        bFeatureEnabled = FALSE;

    ASSERT(pOptions && pbEnabledOptions);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if (! (pFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex)))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    dwCount = pFeature->Options.dwCount;

    //
    // Go through each option of the specified feature and
    // determine whether it should be enabled or disabled.
    //

    for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {
        DWORD   dwFeature, dwOption;
        BOOL    bEnabled = TRUE;

        for (dwFeature = 0;
             dwFeature < pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;
             dwFeature ++)
        {
            if (BCheckFeatureConflict(pUIInfo,
                                      pOptions,
                                      dwFeature,
                                      &dwOption,
                                      dwFeatureIndex,
                                      dwIndex))
            {
                bEnabled = FALSE;
                break;
            }
        }

        pbEnabledOptions[dwIndex] = bEnabled;
        bFeatureEnabled = bFeatureEnabled || bEnabled;
    }

    return bFeatureEnabled;
}



BOOL
EnumNewUIConflict(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions,
    OUT PCONFLICTPAIR   pConflictPair
    )

/*++

Routine Description:

    Check if there are any conflicts between the currently selected options
    for the specified feature an other feature/option selections.

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to the current feature/option selections
    dwFeatureIndex - Specifies the index of the interested printer feature
    pbSelectedOptions - Specifies which options for the specified feature are selected
    pConflictPair - Return the conflicting pair of feature/option selections

Return Value:

    TRUE if there is a conflict between the selected options for the specified feature
    and other feature option selections.

    FALSE if the selected options for the specified feature is consistent with other
    feature option selections.

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pSpecifiedFeature;
    DWORD       dwIndex, dwCount, dwPriority;
    BOOL        bConflict = FALSE;

    ASSERT(pOptions && pbSelectedOptions && pConflictPair);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if (! (pSpecifiedFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex)))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    dwCount = pSpecifiedFeature->Options.dwCount;

    //
    // Go through the selected options of the specified feature
    // and check if they are constrained.
    //

    for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
    {
        DWORD       dwFeature, dwOption;
        PFEATURE    pFeature;

        //
        // Skip options which are not selected
        //

        if (! pbSelectedOptions[dwIndex])
            continue;

        for (dwFeature = 0;
             dwFeature < pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;
             dwFeature ++)
        {
            if (dwFeature == dwFeatureIndex)
                continue;

            if (BCheckFeatureConflict(pUIInfo,
                                      pOptions,
                                      dwFeature,
                                      &dwOption,
                                      dwFeatureIndex,
                                      dwIndex))
            {
                pFeature = PGetIndexedFeature(pUIInfo, dwFeature);
                ASSERT(pFeature != NULL);

                //
                // Remember the highest priority conflict-pair
                //

                if (!bConflict || pFeature->dwPriority > dwPriority)
                {
                    dwPriority = pFeature->dwPriority;

                    if (dwPriority >= pSpecifiedFeature->dwPriority)
                    {
                        pConflictPair->dwFeatureIndex1 = dwFeature;
                        pConflictPair->dwOptionIndex1 = dwOption;
                        pConflictPair->dwFeatureIndex2 = dwFeatureIndex;
                        pConflictPair->dwOptionIndex2 = dwIndex;
                    }
                    else
                    {
                        pConflictPair->dwFeatureIndex1 = dwFeatureIndex;
                        pConflictPair->dwOptionIndex1 = dwIndex;
                        pConflictPair->dwFeatureIndex2 = dwFeature;
                        pConflictPair->dwOptionIndex2 = dwOption;
                    }
                }

                bConflict = TRUE;
            }
        }

        //
        // For PickMany UI types, the current selections for the specified
        // feature could potentially conflict with each other.
        //

        if (pSpecifiedFeature->dwUIType == UITYPE_PICKMANY)
        {
            for (dwOption = 0; dwOption < dwCount; dwOption++)
            {
                if (BCheckFeatureOptionConflict(pUIInfo,
                                                dwFeatureIndex,
                                                dwOption,
                                                dwFeatureIndex,
                                                dwIndex))
                {
                    if (!bConflict || pSpecifiedFeature->dwPriority > dwPriority)
                    {
                        dwPriority = pSpecifiedFeature->dwPriority;
                        pConflictPair->dwFeatureIndex1 = dwFeatureIndex;
                        pConflictPair->dwOptionIndex1 = dwOption;
                        pConflictPair->dwFeatureIndex2 = dwFeatureIndex;
                        pConflictPair->dwOptionIndex2 = dwIndex;
                    }

                    bConflict = TRUE;
                }
            }
        }
    }

    return bConflict;
}



BOOL
EnumNewPickOneUIConflict(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pOptions,
    IN DWORD            dwFeatureIndex,
    IN DWORD            dwOptionIndex,
    OUT PCONFLICTPAIR   pConflictPair
    )

/*++

Routine Description:

    Check if there are any conflicts between the currently selected option
    for the specified feature an other feature/option selections.

    This is similar to EnumNewUIConflict above except that only one selected
    option is allowed for the specified feature.

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to the current feature/option selections
    dwFeatureIndex - Specifies the index of the interested printer feature
    dwOptionIndex - Specifies the selected option of the specified feature
    pConflictPair - Return the conflicting pair of feature/option selections

Return Value:

    TRUE if there is a conflict between the selected option for the specified feature
    and other feature/option selections.

    FALSE if the selected option for the specified feature is consistent with other
    feature/option selections.

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pSpecifiedFeature, pFeature;
    DWORD       dwPriority, dwFeature, dwOption;
    BOOL        bConflict = FALSE;

    ASSERT(pOptions && pConflictPair);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if ((pSpecifiedFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex)) == NULL ||
        (dwOptionIndex >= pSpecifiedFeature->Options.dwCount))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    //
    // Check if the specified feature/option is constrained
    //

    for (dwFeature = 0;
         dwFeature < pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;
         dwFeature ++)
    {
        if (dwFeature == dwFeatureIndex)
            continue;

        if (BCheckFeatureConflict(pUIInfo,
                                  pOptions,
                                  dwFeature,
                                  &dwOption,
                                  dwFeatureIndex,
                                  dwOptionIndex))
        {
            pFeature = PGetIndexedFeature(pUIInfo, dwFeature);

            ASSERT(pFeature != NULL);

            //
            // Remember the highest priority conflict-pair
            //

            if (!bConflict || pFeature->dwPriority > dwPriority)
            {
                dwPriority = pFeature->dwPriority;

                if (dwPriority >= pSpecifiedFeature->dwPriority)
                {
                    pConflictPair->dwFeatureIndex1 = dwFeature;
                    pConflictPair->dwOptionIndex1 = dwOption;
                    pConflictPair->dwFeatureIndex2 = dwFeatureIndex;
                    pConflictPair->dwOptionIndex2 = dwOptionIndex;
                }
                else
                {
                    pConflictPair->dwFeatureIndex1 = dwFeatureIndex;
                    pConflictPair->dwOptionIndex1 = dwOptionIndex;
                    pConflictPair->dwFeatureIndex2 = dwFeature;
                    pConflictPair->dwOptionIndex2 = dwOption;
                }
            }

            bConflict = TRUE;
        }
    }

    return bConflict;
}



BOOL
ChangeOptionsViaID(
    IN PINFOHEADER      pInfoHdr,
    IN OUT POPTSELECT   pOptions,
    IN DWORD            dwFeatureID,
    IN PDEVMODE         pDevmode
    )

/*++

Routine Description:

    Modifies an option array using the information in public devmode fields

Arguments:

    pInfoHdr - Points to an instance of binary printer description data
    pOptions - Points to the option array to be modified
    dwFeatureID - Specifies which field(s) of the input devmode should be used
    pDevmode - Specifies the input devmode

Return Value:
    TRUE if successful, FALSE if the specified feature ID is not supported
    or there is an error

Note:

    We assume the input devmode fields have been validated by the caller.

--*/

{
    PRAWBINARYDATA  pRawData;
    PUIINFO         pUIInfo;
    PFEATURE        pFeature;
    DWORD           dwFeatureIndex;
    LONG            lParam1, lParam2;
    BOOL            abEnabledOptions[MAX_PRINTER_OPTIONS];
    PDWORD          pdwPaperIndex = (PDWORD)abEnabledOptions;
    DWORD           dwCount, dwOptionIndex, i;

    ASSERT(pOptions && pDevmode);

    //
    // Get a pointer to the FEATURE structure corresponding to
    // the specified feature ID.
    //

    pRawData = (PRAWBINARYDATA) pInfoHdr;
    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if ((dwFeatureID >= MAX_GID) ||
        (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureID)) == NULL)
    {
        VERBOSE(("ChangeOptionsViaID failed: feature ID = %d\n", dwFeatureID));
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);

    //
    // Handle it according to what dwFeatureID is specified
    //

    lParam1 = lParam2 = 0;

    switch (dwFeatureID)
    {
    case GID_PAGESIZE:

        //
        // Don't select any PageRegion option by default
        //

        {
            PFEATURE    pPageRgnFeature;
            DWORD       dwPageRgnIndex;

            if (pPageRgnFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGEREGION))
            {
                dwPageRgnIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pPageRgnFeature);

                pOptions[dwPageRgnIndex].ubCurOptIndex =
                    (BYTE) pPageRgnFeature->dwNoneFalseOptIndex;
            }
        }

        //
        // If the devmode specifies PostScript custom page size,
        // we assume the parameters have already been validated
        // during devmode merge proces. So here we simply return
        // the custom page size option index.
        //

        if ((pDevmode->dmFields & DM_PAPERSIZE) &&
            (pDevmode->dmPaperSize == DMPAPER_CUSTOMSIZE))
        {
            ASSERT(SUPPORT_CUSTOMSIZE(pUIInfo));
            pOptions[dwFeatureIndex].ubCurOptIndex = (BYTE) pUIInfo->dwCustomSizeOptIndex;
            return TRUE;
        }

        lParam1 = pDevmode->dmPaperWidth * DEVMODE_PAPER_UNIT;
        lParam2 = pDevmode->dmPaperLength * DEVMODE_PAPER_UNIT;
        break;

    case GID_INPUTSLOT:

        lParam1 = pDevmode->dmDefaultSource;
        break;

    case GID_RESOLUTION:

        //
        // If none is set, this function is not called with par. GID_RESOLUTION
        //

        ASSERT(pDevmode->dmFields & (DM_PRINTQUALITY | DM_YRESOLUTION));

        switch (pDevmode->dmFields & (DM_PRINTQUALITY | DM_YRESOLUTION))
        {

        case DM_PRINTQUALITY:        // set both if only one is set

            lParam1 = lParam2 = pDevmode->dmPrintQuality;
            break;

        case DM_YRESOLUTION:        // set both if only one is set

            lParam1 = lParam2 = pDevmode->dmYResolution;
            break;

        default:
            lParam1 = pDevmode->dmPrintQuality;
            lParam2 = pDevmode->dmYResolution;
            break;
        }
        break;

    case GID_DUPLEX:

        lParam1 = pDevmode->dmDuplex;
        break;

    case GID_MEDIATYPE:

        lParam1 = pDevmode->dmMediaType;
        break;

    case GID_COLLATE:

        lParam1 = pDevmode->dmCollate;
        break;

    default:

        VERBOSE(("ChangeOptionsViaID failed: feature ID = %d\n", dwFeatureID));
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    ASSERT(pFeature->dwUIType != UITYPE_PICKMANY);

    if (dwFeatureID == GID_PAGESIZE)
    {
        dwCount = DwInternalMapToOptIndex(pUIInfo, pFeature, lParam1, lParam2, pdwPaperIndex);

        if (dwCount == 0 )
            return TRUE;

        if (dwCount > 1 )
        {
            POPTION  pOption;
            LPCTSTR  pDisplayName;

            for (i = 0; i < dwCount; i++)
            {
                if (pOption = PGetIndexedOption(pUIInfo, pFeature, pdwPaperIndex[i]))
                {
                    if ((pDisplayName = OFFSET_TO_POINTER(pRawData, pOption->loDisplayName)) &&
                        (_tcsicmp(pDevmode->dmFormName, pDisplayName) == EQUAL_STRING) )
                    {
                        dwOptionIndex = pdwPaperIndex[i];
                        break;
                    }
                }
            }

            if (i >= dwCount)
                dwOptionIndex = pdwPaperIndex[0];
        }
        else
            dwOptionIndex = pdwPaperIndex[0];

        pOptions[dwFeatureIndex].ubCurOptIndex = (BYTE)dwOptionIndex;
    }
    else
    {
        pOptions[dwFeatureIndex].ubCurOptIndex =
            (BYTE) DwInternalMapToOptIndex(pUIInfo, pFeature, lParam1, lParam2, NULL);
    }

    return TRUE;
}



DWORD
MapToDeviceOptIndex(
    IN PINFOHEADER      pInfoHdr,
    IN DWORD            dwFeatureID,
    IN LONG             lParam1,
    IN LONG             lParam2,
    OUT PDWORD          pdwOptionIndexes
    )

/*++

Routine Description:

    Map logical values to device feature option index

Arguments:

    pInfoHdr - Points to an instance of binary printer description data
    dwFeatureID - Indicate which feature the logical values are related to
    lParam1, lParam2  - Parameters depending on dwFeatureID
    pdwOptionIndexes - if Not NULL, means fill this array with all indicies
                       which match the search criteria. In this case the return value
                       is the number of elements in the array initialized. Currently
                       we assume the array is large enough (256 elements).
                       (It should be non-NULL only for GID_PAGESIZE.)

    dwFeatureID = GID_PAGESIZE:
        map logical paper specification to physical page size option

        lParam1 = paper width in microns
        lParam2 = paper height in microns

    dwFeatureID = GID_RESOLUTION:
        map logical resolution to physical resolution option

        lParam1 = x-resolution in dpi
        lParam2 = y-resolution in dpi

Return Value:

    If pdwOptionIndexes is NULL, returns index of the feature option corresponding
    to the specified logical values; OPTION_INDEX_ANY if the specified logical
    values cannot be mapped to any feature option.

    If pdwOptionIndexes is not NULL (for GID_PAGESIZE), returns the number of elements
    filled in the output buffer. Zero means the specified logical values cannot be mapped
    to any feature option.

--*/

{
    PRAWBINARYDATA  pRawData;
    PUIINFO         pUIInfo;
    PFEATURE        pFeature;

    //
    // Get a pointer to the FEATURE structure corresponding to
    // the specified feature ID.
    //

    pRawData = (PRAWBINARYDATA) pInfoHdr;
    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if ((dwFeatureID >= MAX_GID) ||
        (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureID)) == NULL)
    {
        VERBOSE(("MapToDeviceOptIndex failed: feature ID = %d\n", dwFeatureID));

        if (!pdwOptionIndexes)
            return OPTION_INDEX_ANY;
        else
            return 0;
    }

    //
    // pdwOptionIndexes can be non-NULL only if dwFeatureID is GID_PAGESIZE.
    //

    ASSERT(dwFeatureID == GID_PAGESIZE || pdwOptionIndexes == NULL);

    return DwInternalMapToOptIndex(pUIInfo, pFeature, lParam1, lParam2, pdwOptionIndexes);
}



BOOL
CombineOptionArray(
    IN PRAWBINARYDATA   pRawData,
    OUT POPTSELECT      pCombinedOptions,
    IN INT              iMaxOptions,
    IN POPTSELECT       pDocOptions,
    IN POPTSELECT       pPrinterOptions
    )

/*++

Routine Description:

    Combine doc-sticky with printer-sticky option selections to form a single option array

Arguments:

    pRawData - Points to raw binary printer description data
    pCombinedOptions - Points to an array of OPTSELECTs for holding the combined options
    iMaxOptions - Max number of entries in pCombinedOptions array
    pDocOptions - Specifies the array of doc-sticky options
    pPrinterOptions - Specifies the array of printer-sticky options

Return Value:

    FALSE if the combined option array is not large enough to store
    all the option values, TRUE otherwise.

Note:

    Either pDocOptions or pPrinterOptions could be NULL but not both. If pDocOptions
    is NULL, then in the combined option array, the options for document-sticky
    features will be OPTION_INDEX_ANY. Same is true when pPrinterOptions is NULL.

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeatures;
    INT         iCount, iDocOptions, iPrinterOptions, iNext;

    //
    // Calculate the number of features: both doc-sticky and printer-sticky
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    pFeatures = OFFSET_TO_POINTER(pInfoHdr, pUIInfo->loFeatureList);

    iDocOptions = (INT) pRawData->dwDocumentFeatures;
    iPrinterOptions = (INT) pRawData->dwPrinterFeatures;
    iNext = iDocOptions + iPrinterOptions;
    ASSERT(iNext <= iMaxOptions);

    //
    // Copy doc-sticky options into the combined array.
    // Take care of the special case where pDocOptions is NULL.
    //

    if (pDocOptions == NULL)
    {
        for (iCount = 0; iCount < iDocOptions; iCount++)
        {
            pCombinedOptions[iCount].ubCurOptIndex = OPTION_INDEX_ANY;
            pCombinedOptions[iCount].ubNext = NULL_OPTSELECT;
        }
    }
    else
    {
        for (iCount = 0; iCount < iDocOptions; iCount++)
        {
            VCopyOptionSelections(pCombinedOptions,
                                  iCount,
                                  pDocOptions,
                                  iCount,
                                  &iNext,
                                  iMaxOptions);
        }
    }

    //
    // Copy printer-sticky options into the combined option array.
    //

    if (pPrinterOptions == NULL)
    {
        for (iCount = 0; iCount < iPrinterOptions; iCount++)
        {
            pCombinedOptions[iCount + iDocOptions].ubCurOptIndex = OPTION_INDEX_ANY;
            pCombinedOptions[iCount + iDocOptions].ubNext = NULL_OPTSELECT;
        }
    }
    else
    {
        for (iCount = 0; iCount < iPrinterOptions; iCount++)
        {
            VCopyOptionSelections(pCombinedOptions,
                                  iCount + iDocOptions,
                                  pPrinterOptions,
                                  iCount,
                                  &iNext,
                                  iMaxOptions);
        }
    }

    if (iNext > iMaxOptions)
        WARNING(("Option array too small: size = %d, needed = %d\n", iMaxOptions, iNext));

    return (iNext <= iMaxOptions);
}



BOOL
SeparateOptionArray(
    IN PRAWBINARYDATA   pRawData,
    IN POPTSELECT       pCombinedOptions,
    OUT POPTSELECT      pOptions,
    IN INT              iMaxOptions,
    IN INT              iMode
    )

/*++

Routine Description:

    Separate an option array into doc-sticky and for printer-sticky options

Arguments:

    pRawData - Points to raw binary printer description data
    pCombinedOptions - Points to the combined option array to be separated
    pOptions - Points to an array of OPTSELECT structures
        for storing the separated option array
    iMaxOptions - Max number of entries in pOptions array
    iMode - Whether the caller is interested in doc- or printer-sticky options:
        MODE_DOCUMENT_STICKY
        MODE_PRINTER_STICKY

Return Value:

    FALSE if the destination option array is not large enough to hold
    the separated option values, TRUE otherwise.

--*/

{
    INT iStart, iCount, iOptions, iNext;

    //
    // Determine if the caller is interested in doc-sticky or printer-sticky options
    //

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        iStart = 0;
        iOptions = (INT) pRawData->dwDocumentFeatures;
    }
    else
    {
        ASSERT (iMode == MODE_PRINTER_STICKY);
        iStart = (INT) pRawData->dwDocumentFeatures;
        iOptions = (INT) pRawData->dwPrinterFeatures;
    }

    iNext = iOptions;
    ASSERT(iNext <= iMaxOptions);

    //
    // Separate the requested options out of the combined option array
    //

    for (iCount = 0; iCount < iOptions; iCount++)
    {
        VCopyOptionSelections(pOptions,
                              iCount,
                              pCombinedOptions,
                              iStart + iCount,
                              &iNext,
                              iMaxOptions);
    }

    if (iNext > iMaxOptions)
        WARNING(("Option array too small: size = %d, needed = %d\n", iMaxOptions, iNext));

    return (iNext <= iMaxOptions);
}



BOOL
ReconstructOptionArray(
    IN PRAWBINARYDATA   pRawData,
    IN OUT POPTSELECT   pOptions,
    IN INT              iMaxOptions,
    IN DWORD            dwFeatureIndex,
    IN PBOOL            pbSelectedOptions
    )

/*++

Routine Description:

    Modify an option array to change the selected options for the specified feature

Arguments:

    pRawData - Points to raw binary printer description data
    pOptions - Points to an array of OPTSELECT structures to be modified
    iMaxOptions - Max number of entries in pOptions array
    dwFeatureIndex - Specifies the index of printer feature in question
    pbSelectedOptions - Which options of the specified feature is selected

Return Value:

    FALSE if the input option array is not large enough to hold
    all modified option values. TRUE otherwise.

Note:

    Number of BOOLs in pSelectedOptions must match the number of options
    for the specified feature.

    This function always leaves the option array in a compact format (i.e.
    all unused entries are left at the end of the array).

--*/

{
    INT         iNext, iCount, iDest;
    DWORD       dwIndex;
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeature;
    POPTSELECT  pTempOptions;

    ASSERT(pOptions && pbSelectedOptions);

    //
    // Get pointers to various data structures
    //

    PPD_GET_UIINFO_FROM_RAWDATA(pRawData, pInfoHdr, pUIInfo);

    ASSERT(pUIInfo != NULL);

    if (! (pFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex)))
    {
        ASSERT(FALSE);
        return FALSE;
    }

    //
    // Assume the entire input option array is used by default. This is
    // not exactly true but it shouldn't have any adverse effects either.
    //

    iNext = iMaxOptions;

    //
    // Special case (faster) for non-PickMany UI types
    //

    if (pFeature->dwUIType != UITYPE_PICKMANY)
    {
        for (dwIndex = 0, iCount = 0;
             dwIndex < pFeature->Options.dwCount;
             dwIndex ++)
        {
            if (pbSelectedOptions[dwIndex])
            {
                pOptions[dwFeatureIndex].ubCurOptIndex = (BYTE) dwIndex;
                ASSERT(pOptions[dwFeatureIndex].ubNext == NULL_OPTSELECT);
                iCount++;
            }
        }

        //
        // Exactly one option is allowed to be selected
        //

        ASSERT(iCount == 1);
    }
    else
    {
        //
        // Handle PickMany UI type:
        //  allocate a temporary option array and copy the input option values
        //  except the option values for the specified feature.
        //

        if (pTempOptions = MemAllocZ(iMaxOptions * sizeof(OPTSELECT)))
        {
            DWORD   dwOptions;

            dwOptions = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;
            iNext = dwOptions;

            if (iNext > iMaxOptions)
            {
                ASSERT(FALSE);
                return FALSE;
            }

            for (dwIndex = 0; dwIndex < dwOptions; dwIndex++)
            {
                if (dwIndex != dwFeatureIndex)
                {
                    VCopyOptionSelections(pTempOptions,
                                          dwIndex,
                                          pOptions,
                                          dwIndex,
                                          &iNext,
                                          iMaxOptions);
                }
            }

            //
            // Reconstruct the option values for the specified feature
            //

            pTempOptions[dwFeatureIndex].ubCurOptIndex = OPTION_INDEX_ANY;
            pTempOptions[dwFeatureIndex].ubNext = NULL_OPTSELECT;

            iDest = dwFeatureIndex;
            iCount = 0;

            for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex ++)
            {
                if (pbSelectedOptions[dwIndex])
                {
                    if (iCount++ == 0)
                    {
                        //
                        // The first selected option
                        //

                        pTempOptions[iDest].ubCurOptIndex = (BYTE) dwIndex;
                    }
                    else
                    {
                        //
                        // Subsequent selected options
                        //

                        if (iNext < iMaxOptions)
                        {
                            pTempOptions[iDest].ubNext = (BYTE) iNext;
                            pTempOptions[iNext].ubCurOptIndex = (BYTE) dwIndex;
                            iDest = iNext;
                        }

                        iNext++;
                    }
                }
            }

            pTempOptions[iDest].ubNext = NULL_OPTSELECT;

            //
            // Copy the reconstructed option array from the temporary buffer
            // back to the input option array provided by the caller.
            //

            CopyMemory(pOptions, pTempOptions, iMaxOptions * sizeof(OPTSELECT));
            MemFree(pTempOptions);
        }
        else
        {
            ERR(("Cannot allocate memory for temporary option array\n"));
        }
    }

    return (iNext <= iMaxOptions);
}



PTSTR
GenerateBpdFilename(
    PTSTR   ptstrPpdFilename
    )

/*++

Routine Description:

    Generate a filename for the cached binary PPD data given a PPD filename

Arguments:

    ptstrPpdFilename - Specifies the PPD filename

Return Value:

    Pointer to BPD filename string, NULL if there is an error

--*/

{
    PTSTR   ptstrBpdFilename, ptstrExtension;
    INT     iLength;

    //
    // If the PPD filename has .PPD extension, replace it with .BPD extension.
    // Otherwise, append .BPD extension at the end.
    //

    iLength = _tcslen(ptstrPpdFilename);

    if ((ptstrExtension = _tcsrchr(ptstrPpdFilename, TEXT('.'))) == NULL ||
        _tcsicmp(ptstrExtension, PPD_FILENAME_EXT) != EQUAL_STRING)
    {
        WARNING(("Bad PPD filename extension: %ws\n", ptstrPpdFilename));

        ptstrExtension = ptstrPpdFilename + iLength;
        iLength += _tcslen(BPD_FILENAME_EXT);
    }

    //
    // Allocate memory and compose the BPD filename
    //

    if (ptstrBpdFilename = MemAlloc((iLength + 1) * sizeof(TCHAR)))
    {
        StringCchCopyW(ptstrBpdFilename, iLength + 1, ptstrPpdFilename);

        //
        // The first if-block ensures that (ptstrExtension - ptstrPpdFileName) is
        // non-negative, and (iLength + 1) is greater than (ptstrExtension - ptstrPpdFileName).
        //
        StringCchCopyW(ptstrBpdFilename + (ptstrExtension - ptstrPpdFilename),
                       (iLength + 1) - (ptstrExtension - ptstrPpdFilename),
                       BPD_FILENAME_EXT);

        VERBOSE(("BPD filename: %ws\n", ptstrBpdFilename));
    }
    else
    {
        ERR(("Memory allocation failed: %d\n", GetLastError()));
    }

    return ptstrBpdFilename;
}



PRAWBINARYDATA
PpdLoadCachedBinaryData(
    PTSTR   ptstrPpdFilename
    )

/*++

Routine Description:

    Load cached binary PPD data file into memory

Arguments:

    ptstrPpdFilename - Specifies the PPD filename

Return Value:

    Pointer to PPD data if successful, NULL if there is an error

--*/

{
    HFILEMAP        hFileMap;
    DWORD           dwSize;
    PVOID           pvData;
    PTSTR           ptstrBpdFilename;
    PRAWBINARYDATA  pRawData, pCopiedData;
    BOOL            bValidCache = FALSE;

    //
    // Generate BPD filename from the specified PPD filename
    //

    if (! (ptstrBpdFilename = GenerateBpdFilename(ptstrPpdFilename)))
        return NULL;

    //
    // First map the data file into memory
    //

    if (! (hFileMap = MapFileIntoMemory(ptstrBpdFilename, &pvData, &dwSize)))
    {
        TERSE(("Couldn't map file '%ws' into memory: %d\n", ptstrBpdFilename, GetLastError()));
        MemFree(ptstrBpdFilename);
        return NULL;
    }

    //
    // Verify size, parser version number, and signature.
    // Allocate a memory buffer and copy data into it.
    //

    pRawData = pvData;
    pCopiedData = NULL;

    if ((dwSize > sizeof(INFOHEADER) + sizeof(UIINFO) + sizeof(PPDDATA)) &&
        (dwSize >= pRawData->dwFileSize) &&
        (pRawData->dwParserVersion == PPD_PARSER_VERSION) &&
        (pRawData->dwParserSignature == PPD_PARSER_SIGNATURE) &&
        (BIsRawBinaryDataUpToDate(pRawData)))
    {
        #ifndef WINNT_40

        PPPDDATA  pPpdData;

        //
        // For Win2K+ systems, we support MUI where user can switch UI language
        // and MUI knows to redirect resource loading calls to the correct resource
        // DLL (built by MUI). However, PPD parser caches some display names into
        // the .bpd file, where the display names are obtained based on the UI
        // language when the parsing occurs. To support MUI, we store the UI language
        // ID into the .bpd file and now if we see the current user's UI language ID
        // doesn't match to the one stored in the .bpd file, we need to throw away
        // the old .bpd file and reparse the .ppd, so we can get correct display names
        // under current UI language.
        //

        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER)pRawData);

        if (pPpdData && pPpdData->dwUserDefUILangID == (DWORD)GetUserDefaultUILanguage())
        {
            bValidCache = TRUE;
        }

        #else

        bValidCache = TRUE;

        #endif // !WINNT_40
    }

    if (bValidCache &&
        (pCopiedData = MemAlloc(dwSize)))
    {
        CopyMemory(pCopiedData, pRawData, dwSize);
    }
    else
    {
        ERR(("Invalid binary PPD data\n"));
        SetLastError(ERROR_INVALID_DATA);
    }

    MemFree(ptstrBpdFilename);
    UnmapFileFromMemory(hFileMap);

    return pCopiedData;
}



BOOL
BSearchConstraintList(
    PUIINFO     pUIInfo,
    DWORD       dwConstraintIndex,
    DWORD       dwFeature,
    DWORD       dwOption
    )

/*++

Routine Description:

    Check if the specified feature/option appears in a constraint list

Arguments:

    pUIInfo - Points to a UIINFO structure
    dwConstraintIndex - Specifies the constraint list to be searched
    dwFeature, dwOption - Specifies the feature/option we're interested in

Return Value:

    TRUE if dwFeature/dwOption appears on the specified constraint list
    FALSE otherwise

--*/

{
    PUICONSTRAINT   pConstraint;
    BOOL            bMatch = FALSE;

    pConstraint = OFFSET_TO_POINTER(pUIInfo->pInfoHeader, pUIInfo->UIConstraints.loOffset);

    //
    // Go through each item on the constraint list
    //

    while (!bMatch && (dwConstraintIndex != NULL_CONSTRAINT))
    {
        ASSERT(dwConstraintIndex < pUIInfo->UIConstraints.dwCount);

        if (pConstraint[dwConstraintIndex].dwFeatureIndex == dwFeature)
        {
            //
            // If the option index is OPTION_INDEX_ANY, it matches
            // any option other than None/False.
            //

            if (pConstraint[dwConstraintIndex].dwOptionIndex == OPTION_INDEX_ANY)
            {
                PFEATURE    pFeature;

                pFeature = PGetIndexedFeature(pUIInfo, dwFeature);
                ASSERT(pFeature != NULL);

                bMatch = (pFeature->dwNoneFalseOptIndex != dwOption);
            }
            else
            {
                bMatch = (pConstraint[dwConstraintIndex].dwOptionIndex == dwOption);
            }
        }

        dwConstraintIndex = pConstraint[dwConstraintIndex].dwNextConstraint;
    }

    return bMatch;
}



BOOL
BCheckFeatureOptionConflict(
    PUIINFO     pUIInfo,
    DWORD       dwFeature1,
    DWORD       dwOption1,
    DWORD       dwFeature2,
    DWORD       dwOption2
    )

/*++

Routine Description:

    Check if there is a conflict between a pair of feature/options

Arguments:

    pUIInfo - Points to a UIINFO structure
    dwFeature1, dwOption1 - Specifies the first feature/option
    dwFeature2, dwOption2 - Specifies the second feature/option

Return Value:

    TRUE if dwFeature1/dwOption1 constrains dwFeature2/dwOption2,
    FALSE otherwise

--*/

{
    PFEATURE    pFeature;
    POPTION     pOption;

    //
    // Check for special case:
    //  either dwOption1 or dwOption2 is OPTION_INDEX_ANY
    //

    if ((dwOption1 == OPTION_INDEX_ANY) ||
        (dwOption2 == OPTION_INDEX_ANY) ||
        (dwFeature1 == dwFeature2 && dwOption1 == dwOption2))
    {
        return FALSE;
    }

    //
    // Go through the constraint list associated with dwFeature1
    //

    if (! (pFeature = PGetIndexedFeature(pUIInfo, dwFeature1)))
        return FALSE;

    if ((dwOption1 != pFeature->dwNoneFalseOptIndex) &&
        BSearchConstraintList(pUIInfo,
                              pFeature->dwUIConstraintList,
                              dwFeature2,
                              dwOption2))
    {
        return TRUE;
    }

    //
    // Go through the constraint list associated with dwFeature1/dwOption1
    //

    if ((pOption = PGetIndexedOption(pUIInfo, pFeature, dwOption1)) &&
        BSearchConstraintList(pUIInfo,
                              pOption->dwUIConstraintList,
                              dwFeature2,
                              dwOption2))
    {
        return TRUE;
    }

    //
    // Automatically check the reciprocal constraint for:
    //  (dwFeature2, dwOption2) => (dwFeature1, dwOption1)
    //

    if (! (pFeature = PGetIndexedFeature(pUIInfo, dwFeature2)))
        return FALSE;

    if ((dwOption2 != pFeature->dwNoneFalseOptIndex) &&
        BSearchConstraintList(pUIInfo,
                              pFeature->dwUIConstraintList,
                              dwFeature1,
                              dwOption1))
    {
        return TRUE;
    }

    if ((pOption = PGetIndexedOption(pUIInfo, pFeature, dwOption2)) &&
        BSearchConstraintList(pUIInfo,
                              pOption->dwUIConstraintList,
                              dwFeature1,
                              dwOption1))
    {
        return TRUE;
    }

    return FALSE;
}



BOOL
BCheckFeatureConflict(
    PUIINFO     pUIInfo,
    POPTSELECT  pOptions,
    DWORD       dwFeature1,
    PDWORD      pdwOption1,
    DWORD       dwFeature2,
    DWORD       dwOption2
    )

/*++

Routine Description:

    Check if there is a conflict between the current option selections
    of a feature and the specified feature/option

Arguments:

    pUIInfo - Points to a UIINFO structure
    pOptions - Points to the current feature option selections
    dwFeature1 - Specifies the feature whose current option selections we're interested in
    pdwOption1 - In case of a conflict, returns the option of dwFeature1
        which caused the conflict
    dwFeature2, dwOption2 - Specifies the feature/option to be checked

Return Value:

    TRUE if there is a conflict between the current selections of dwFeature1
    and dwFeature2/dwOption2, FALSE otherwise.

--*/

{
    DWORD   dwIndex = dwFeature1;

    do
    {
        if (BCheckFeatureOptionConflict(pUIInfo,
                                        dwFeature1,
                                        pOptions[dwIndex].ubCurOptIndex,
                                        dwFeature2,
                                        dwOption2))
        {
            *pdwOption1 = pOptions[dwIndex].ubCurOptIndex;
            return TRUE;
        }

        dwIndex = pOptions[dwIndex].ubNext;

    } while (dwIndex != NULL_OPTSELECT);

    return FALSE;
}



DWORD
DwReplaceFeatureOption(
    PUIINFO     pUIInfo,
    POPTSELECT  pOptions,
    DWORD       dwFeatureIndex,
    DWORD       dwOptionIndex,
    DWORD       dwHint
    )

/*++

Routine Description:

    description-of-function

Arguments:

    pUIInfo - Points to UIINFO structure
    pOptions - Points to the options array to be modified
    dwFeatureIndex, dwOptionIndex - Specifies the feature/option to be replaced
    dwHint - Hint on how to replace the specified feature option.

Return Value:

    New hint value to be used next time this function is called on the same feature.

Note:

    HIWORD of dwHint should be returned untouched. LOWORD of dwHint is
    used by this function to determine how to replace the specified feature/option.

--*/

{
    PFEATURE    pFeature;
    DWORD       dwNext;

    pFeature = PGetIndexedFeature(pUIInfo, dwFeatureIndex);
    ASSERT(pFeature != NULL);

    if (pFeature->dwUIType == UITYPE_PICKMANY)
    {
        //
        // For PickMany feature, simply unselect the specified feature option.
        //

        dwNext = dwFeatureIndex;

        while ((pOptions[dwNext].ubCurOptIndex != dwOptionIndex) &&
               (dwNext = pOptions[dwNext].ubNext) != NULL_OPTSELECT)
        {
        }

        if (dwNext != NULL_OPTSELECT)
        {
            DWORD   dwLast;

            pOptions[dwNext].ubCurOptIndex = OPTION_INDEX_ANY;

            //
            // Compact the list of selected options for the specified
            // feature to filter out any redundant OPTION_INDEX_ANY entries.
            //

            dwLast = dwNext = dwFeatureIndex;

            do
            {
                if (pOptions[dwNext].ubCurOptIndex != OPTION_INDEX_ANY)
                {
                    pOptions[dwLast].ubCurOptIndex = pOptions[dwNext].ubCurOptIndex;
                    dwLast = pOptions[dwLast].ubNext;
                }

                dwNext = pOptions[dwNext].ubNext;
            }
            while (dwNext != NULL_OPTSELECT);

            pOptions[dwLast].ubNext = NULL_OPTSELECT;
        }
        else
        {
            ERR(("Trying to replace non-existent feature/option.\n"));
        }

        return dwHint;
    }
    else
    {
        //
        // For non-PickMany feature, use the hint paramater to determine
        // how to replace the specified feature option:
        //
        //  If this is the first time we're trying to replace the
        //  selected option of the specified feature, then we'll
        //  replace it with the default option for that feature.
        //
        //  Otherwise, we'll try each option of the specified feature in turn.
        //
        //  If we've exhausted all of the options for the specified
        //  (which should happen if the PPD file is well-formed),
        //  then we'll use OPTION_INDEX_ANY as the last resort.
        //

        dwNext = dwHint & 0xffff;

        if (dwNext == 0)
            dwOptionIndex = pFeature->dwDefaultOptIndex;
        else if (dwNext > pFeature->Options.dwCount)
            dwOptionIndex = OPTION_INDEX_ANY;
        else
            dwOptionIndex = dwNext - 1;

        pOptions[dwFeatureIndex].ubCurOptIndex = (BYTE) dwOptionIndex;

        return (dwHint & 0xffff0000) | (dwNext + 1);
    }
}



DWORD
DwInternalMapToOptIndex(
    PUIINFO     pUIInfo,
    PFEATURE    pFeature,
    LONG        lParam1,
    LONG        lParam2,
    OUT PDWORD  pdwOptionIndexes
    )

/*++

Routine Description:

    Map logical values to device feature option index

Arguments:

    pUIInfo - Points to UIINFO structure
    pFeature - Specifies the interested feature
    lParam1, lParam2  - Parameters depending on pFeature->dwFeatureID
    pdwOptionIndexes - if Not NULL, means fill this array with all indicies
                       which match the search criteria. In this case the return value
                       is the number of elements in the array initialized. Currently
                       we assume the array is large enough (256 elements).
                       (It should be non-NULL only for GID_PAGESIZE.)

    GID_PAGESIZE:
        map logical paper specification to physical PageSize option

        lParam1 = paper width in microns
        lParam2 = paper height in microns

    GID_RESOLUTION:
        map logical resolution to physical Resolution option

        lParam1 = x-resolution in dpi
        lParam2 = y-resolution in dpi

    GID_INPUTSLOT:
        map logical paper source to physical InputSlot option

        lParam1 = DEVMODE.dmDefaultSource

    GID_DUPLEX:
        map logical duplex selection to physical Duplex option

        lParam1 = DEVMODE.dmDuplex

    GID_COLLATE:
        map logical collate selection to physical Collate option

        lParam1 = DEVMODE.dmCollate

    GID_MEDIATYPE:
        map logical media type to physical MediaType option

        lParam1 = DEVMODE.dmMediaType

Return Value:

    If pdwOptionIndexes is NULL, returns index of the feature option corresponding
    to the specified logical values; OPTION_INDEX_ANY if the specified logical
    values cannot be mapped to any feature option.

    If pdwOptionIndexes is not NULL (for GID_PAGESIZE), returns the number of elements
    filled in the output buffer. Zero means the specified logical values cannot be mapped
    to any feature option.

--*/

{
    DWORD   dwIndex, dwOptionIndex;

    //
    // Handle it according to what dwFeatureID is specified
    //

    dwOptionIndex = pFeature->dwNoneFalseOptIndex;

    switch (pFeature->dwFeatureID)
    {
    case GID_PAGESIZE:
        {
            PPAGESIZE   pPaper;
            LONG        lXDelta, lYDelta;
            DWORD       dwExactMatch;

            //
            // lParam1 = paper width
            // lParam1 = paper height
            //

            //
            // Go through the list of paper sizes supported by the printer
            // and see if we can find an exact match to the requested size.
            // (The tolerance is 1mm). If not, remember the closest match found.
            //

            dwExactMatch = 0;

            for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
            {
                pPaper = PGetIndexedOption(pUIInfo, pFeature, dwIndex);
                ASSERT(pPaper != NULL);

                //
                // Custom page size is handled differently - skip it here.
                //

                if (pPaper->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
                    continue;

                lXDelta = abs(pPaper->szPaperSize.cx - lParam1);
                lYDelta = abs(pPaper->szPaperSize.cy - lParam2);

                if (lXDelta <= 1000 && lYDelta <= 1000)
                {
                    //
                    // Exact match is found
                    //

                    if (pdwOptionIndexes)
                    {
                        pdwOptionIndexes[dwExactMatch++] = dwIndex;
                    }
                    else
                    {
                        dwOptionIndex = dwIndex;
                        break;
                    }
                }
            }

            if (dwExactMatch > 0)
            {
                //
                // Exact match(es) found
                //

                dwOptionIndex = dwExactMatch;
            }
            else if (dwIndex >= pFeature->Options.dwCount)
            {
                //
                // No exact match found
                //

                if (SUPPORT_CUSTOMSIZE(pUIInfo) &&
                    BFormSupportedThruCustomSize((PRAWBINARYDATA) pUIInfo->pInfoHeader, lParam1, lParam2, NULL))
                {
                    dwOptionIndex = pUIInfo->dwCustomSizeOptIndex;
                }
                else
                {
                    //
                    // We used to use dwClosestIndex as dwOptionIndex here, but see bug #124203, we now
                    // choose to behave the same as Unidrv that if there is no exact match, we return no
                    // match instead of the cloest match.
                    //

                    dwOptionIndex = OPTION_INDEX_ANY;
                }

                if (pdwOptionIndexes)
                {
                    if (dwOptionIndex == OPTION_INDEX_ANY)
                        dwOptionIndex = 0;
                    else
                    {
                        pdwOptionIndexes[0] = dwOptionIndex;
                        dwOptionIndex = 1;
                    }
                }
            }
        }
        break;

    case GID_INPUTSLOT:

        //
        // lParam1 = DEVMODE.dmDefaultSource
        //

        dwOptionIndex = OPTION_INDEX_ANY;

        if (lParam1 >= DMBIN_USER)
        {
            //
            // An input slot is specifically requested.
            //

            dwIndex = lParam1 - DMBIN_USER;

            if (dwIndex < pFeature->Options.dwCount)
                dwOptionIndex = dwIndex;
        }
        else if (lParam1 == DMBIN_MANUAL || lParam1 == DMBIN_ENVMANUAL)
        {
            //
            // Manual feed is requested
            //

            for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex ++)
            {
                PINPUTSLOT  pInputSlot;

                if ((pInputSlot = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) &&
                    (pInputSlot->dwPaperSourceID == DMBIN_MANUAL))
                {
                    dwOptionIndex = dwIndex;
                    break;
                }
            }
        }

        if (dwOptionIndex == OPTION_INDEX_ANY)
        {
            //
            // Treat all other cases as if no input slot is explicitly requested.
            // At print time, the driver will choose an input slot based on
            // the form-to-tray assignment table.
            //

            dwOptionIndex = 0;
        }
        break;

    case GID_RESOLUTION:

        //
        // lParam1 = x-resolution
        // lParam2 = y-resolution
        //

        {
            PRESOLUTION pRes;

            //
            // check whether it's one of the predefined DMRES_-values
            //

            if ((lParam1 < 0) && (lParam2 < 0))
            {
                DWORD dwHiResId=0, dwLoResId, dwMedResId, dwDraftResId=0;
                DWORD dwHiResProd=0, dwMedResProd=0, dwLoResProd= 0xffffffff, dwDraftResProd= 0xffffffff;
                BOOL  bValid = FALSE; // if there is at least one valid entry
                DWORD dwResProd;

                // no need to sort all the available options, just pick out the interesting ones
                for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
                {
                    if ((pRes = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) != NULL)
                    {
                        bValid = TRUE;

                        dwResProd = pRes->iXdpi * pRes->iYdpi; // use product as sort criteria

                        if (dwResProd > dwHiResProd) // take highest as high resolution
                        {
                            // previous max. is now second highest
                            dwMedResProd= dwHiResProd;
                            dwMedResId  = dwHiResId;

                            dwHiResProd = dwResProd;
                            dwHiResId   = dwIndex;
                        }
                        else if (dwResProd == dwHiResProd)
                        {
                            // duplicates possible, if e.g. 300x600 as well as 600x300 supported
                            // skip that
                        }
                        else if (dwResProd > dwMedResProd)  // take second highest as medium,
                        {   // can only be hit if not max.
                            dwMedResProd= dwResProd;
                            dwMedResId  = dwIndex;
                        }

                        if (dwResProd < dwDraftResProd)     // take lowest as draft
                        {
                            // previous min. is now second lowest
                            dwLoResProd    = dwDraftResProd;
                            dwLoResId      = dwDraftResId;

                            dwDraftResProd = dwResProd;
                            dwDraftResId   = dwIndex;
                        }
                        else if (dwResProd == dwDraftResProd)
                        {
                            // duplicates possible, if e.g. 300x600 as well as 600x300 supported
                            // skip that
                        }
                        else if (dwResProd < dwLoResProd)     // take second lowest as low
                        {// can only be hit if not min.
                            dwLoResProd = dwResProd;
                            dwLoResId   = dwIndex;
                        }
                    }
                }

                if (!bValid) // no valid entry ?
                {
                    return OPTION_INDEX_ANY;
                }

                //
                // Correct medium, might not be touched if less than 3 resolution options
                //

                if (dwMedResProd == 0)
                {
                    dwMedResProd = dwHiResProd;
                    dwMedResId   = dwHiResId;
                }

                //
                // Correct low, might not be touched if less than 3 resolution options
                //

                if (dwLoResProd == 0xffffffff)
                {
                    dwLoResProd = dwDraftResProd;
                    dwLoResId   = dwDraftResId;
                }

                //
                // if different, take the higher of the requested resolutions
                //

                switch(min(lParam1, lParam2))
                {
                case DMRES_DRAFT:
                    return dwDraftResId;

                case DMRES_LOW:
                    return dwLoResId;

                case DMRES_MEDIUM:
                    return dwMedResId;

                case DMRES_HIGH:
                    return dwHiResId;
                }

                //
                // requested is not one of the known predefined values
                //

                return OPTION_INDEX_ANY;
            }

            //
            // First try to match both x- and y-resolution exactly
            //

            dwOptionIndex = OPTION_INDEX_ANY;

            for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
            {
                if ((pRes = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) &&
                    (pRes->iXdpi == lParam1) &&
                    (pRes->iYdpi == lParam2))
                {
                    dwOptionIndex = dwIndex;
                    break;
                }
            }

            if (dwOptionIndex != OPTION_INDEX_ANY)
                break;

            //
            // If no exact match is found, then relax the criteria a bit and
            // compare the max of x- and y-resolution.
            //

            lParam1 = max(lParam1, lParam2);

            for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
            {
                if ((pRes = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) &&
                    (max(pRes->iXdpi, pRes->iYdpi) == lParam1))
                {
                    dwOptionIndex = dwIndex;
                    break;
                }
            }
        }
        break;

    case GID_DUPLEX:

        //
        // lParam1 = DEVMODE.dmDuplex
        //

        for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
        {
            PDUPLEX pDuplex;

            if ((pDuplex = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) &&
                ((LONG) pDuplex->dwDuplexID == lParam1))
            {
                dwOptionIndex = dwIndex;
                break;
            }
        }
        break;

    case GID_COLLATE:

        //
        // lParam1 = DEVMODE.dmCollate
        //

        for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
        {
            PCOLLATE pCollate;

            if ((pCollate = PGetIndexedOption(pUIInfo, pFeature, dwIndex)) &&
                ((LONG) pCollate->dwCollateID == lParam1))
            {
                dwOptionIndex = dwIndex;
                break;
            }
        }
        break;

    case GID_MEDIATYPE:

        //
        // lParam1 = DEVMODE.dmMediaType
        //

        if (lParam1 >= DMMEDIA_USER)
        {
            dwIndex = lParam1 - DMMEDIA_USER;

            if (dwIndex < pFeature->Options.dwCount)
                dwOptionIndex = dwIndex;
        }
        break;

    default:

        VERBOSE(("DwInternalMapToOptIndex failed: feature ID = %d\n", pFeature->dwFeatureID));
        break;
    }

    return dwOptionIndex;
}



PTSTR
PtstrGetDefaultTTSubstTable(
    PUIINFO pUIInfo
    )

/*++

Routine Description:

    Return a copy of the default font substitution table

Arguments:

    pUIInfo - Pointer to UIINFO structure

Return Value:

    Pointer to a copy of the default font substitution table
    NULL if there is an error

--*/

{
    PTSTR   ptstrDefault, ptstrTable = NULL;
    DWORD   dwSize;

    //
    // Make a copy of the default font substitution table
    //

    if ((ptstrDefault = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pUIInfo->loFontSubstTable)) &&
        (dwSize = pUIInfo->dwFontSubCount) &&
        (ptstrTable = MemAlloc(dwSize)))
    {
        ASSERT(BVerifyMultiSZPair(ptstrDefault, dwSize));
        CopyMemory(ptstrTable, ptstrDefault, dwSize);
    }

    return ptstrTable;
}



VOID
VConvertOptSelectArray(
    PRAWBINARYDATA  pRawData,
    POPTSELECT      pNt5Options,
    DWORD           dwNt5MaxCount,
    PBYTE           pubNt4Options,
    DWORD           dwNt4MaxCount,
    INT             iMode
    )

/*++

Routine Description:

    Convert NT4 feature/option selections to NT5 format

Arguments:

    pRawData - Points to raw binary printer description data
    pNt5Options - Points to NT5 feature/option selection array
    pNt4Options - Points to NT4 feature/option selection array
    iMode - Convert doc- or printer-sticky options?

Return Value:

    NONE

--*/

{
    PPPDDATA    pPpdData;
    PBYTE       pubNt4Mapping;
    DWORD       dwNt5Index, dwNt5Offset, dwCount;
    DWORD       dwNt4Index, dwNt4Offset;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pRawData);

    ASSERT(pPpdData != NULL);

    //
    // Determine whether we're converting doc-sticky or
    // printer-sticky feature selections.
    //

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        dwCount = pRawData->dwDocumentFeatures;
        dwNt5Offset = dwNt4Offset = 0;
    }
    else
    {
        dwCount = pRawData->dwPrinterFeatures;
        dwNt5Offset = pRawData->dwDocumentFeatures;
        dwNt4Offset = pPpdData->dwNt4DocFeatures;
    }

    //
    // Get a pointer to the NT4-NT5 feature index mapping table
    //

    pubNt4Mapping = OFFSET_TO_POINTER(pRawData, pPpdData->Nt4Mapping.loOffset);

    ASSERT(pubNt4Mapping != NULL);

    ASSERT(pPpdData->Nt4Mapping.dwCount ==
           pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures);

    //
    // Convert the feature option selection array
    //

    for (dwNt5Index=0; dwNt5Index < dwCount; dwNt5Index++)
    {
        dwNt4Index = pubNt4Mapping[dwNt5Index + dwNt5Offset] - dwNt4Offset;

        if (dwNt4Index < dwNt4MaxCount && pubNt4Options[dwNt4Index] != OPTION_INDEX_ANY)
            pNt5Options[dwNt5Index].ubCurOptIndex = pubNt4Options[dwNt4Index];
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\ppd\ppdchar.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdchar.c

Abstract:

    Functions for parsing the lexical elements of a PPD file

Environment:

    PostScript driver, PPD parser

Revision History:

    08/20/96 -davidx-
        Common coding style for NT 5.0 drivers.

    03/26/96 -davidx-
    	Created it.

--*/

#include "lib.h"
#include "ppd.h"
#include "ppdparse.h"



PFILEOBJ
PCreateFileObj(
    PTSTR   ptstrFilename
    )

/*++

Routine Description:

    Create an input file object

Arguments:

    ptstrFilename - Specifies the input file name

Return Value:

    Pointer to the newly-created file object
    NULL if there is an error

--*/

{
    PFILEOBJ    pFile;

    if (! (pFile = MemAllocZ(sizeof(FILEOBJ))) ||
        ! (pFile->ptstrFileName = DuplicateString(ptstrFilename)))
    {
        ERR(("Memory allocation failed\n"));
        MemFree(pFile);
        return NULL;
    }

    pFile->hFileMap = MapFileIntoMemory(ptstrFilename,
                                        (PVOID *) &pFile->pubStart,
                                        &pFile->dwFileSize);

    if (pFile->hFileMap == NULL)
    {
        ERR(("Couldn't open file: %ws\n", ptstrFilename));
        MemFree(pFile);
        pFile = NULL;
    }
    else
    {
        pFile->pubNext = pFile->pubStart;
        pFile->pubEnd = pFile->pubStart + pFile->dwFileSize;
        pFile->iLineNumber = 1;
        pFile->bNewLine = TRUE;
    }

    return pFile;
}



VOID
VDeleteFileObj(
    PFILEOBJ    pFile
    )

/*++

Routine Description:

    Delete an input file object

Arguments:

    pFile - Specifies the file object to be deleted

Return Value:

    NONE

--*/

{
    ASSERT(pFile && pFile->hFileMap);

    UnmapFileFromMemory(pFile->hFileMap);
    MemFree(pFile->ptstrFileName);
    MemFree(pFile);
}



INT
IGetNextChar(
    PFILEOBJ    pFile
    )

/*++

Routine Description:

    Read the next character from the input file

Arguments:

    pFile - Specifies the input file

Return Value:

    Next character from the input file
    EOF_CHAR if end-of-file is encountered

--*/

{
    INT iBadChars = 0;

    //
    // Skip non-printable control characters
    //

    while (!END_OF_FILE(pFile) && !IS_VALID_CHAR(*pFile->pubNext))
        iBadChars++, pFile->pubNext++;

    if (iBadChars)
    {
        TERSE(("%ws: Non-printable characters on line %d\n",
               pFile->ptstrFileName,
               pFile->iLineNumber));
    }

    if (END_OF_FILE(pFile))
        return EOF_CHAR;

    //
    // A newline is a carriage-return, a line-feed, or CR-LF combination
    //

    if (*pFile->pubNext == LF ||
        *pFile->pubNext == CR && (END_OF_FILE(pFile) || pFile->pubNext[1] != LF))
    {
        pFile->bNewLine = TRUE;
        pFile->iLineNumber++;

    }
    else
    {
        pFile->bNewLine = FALSE;
    }

    return *(pFile->pubNext++); // return current character and advance pointer to next char
}



VOID
VUngetChar(
    PFILEOBJ    pFile
    )

/*++

Routine Description:

    Return the last character read to the input file

Arguments:

    pFile - Specifies the input file

Return Value:

    NONE

--*/

{
    ASSERT(pFile->pubNext > pFile->pubStart);
    pFile->pubNext--;
    
    if (pFile->bNewLine)
    {
        ASSERT(pFile->iLineNumber > 1);
        pFile->iLineNumber--;
        pFile->bNewLine = FALSE;
    }
}



VOID
VSkipSpace(
    PFILEOBJ    pFile
    )

/*++

Routine Description:

    Skip all characters until the next non-space character

Arguments:

    pFile - Specifies the input file

Return Value:

    NONE

--*/

{
    while (!END_OF_FILE(pFile) && IS_SPACE(*pFile->pubNext))
        pFile->pubNext++;
}



VOID
VSkipLine(
    PFILEOBJ    pFile
    )

/*++

Routine Description:

    Skip the remaining characters on the current input line

Arguments:

    pFile - Specifies the input file

Return Value:

    NONE

--*/

{
    while (!END_OF_LINE(pFile) && IGetNextChar(pFile) != EOF_CHAR)
        NULL;
}



BOOL
BIs7BitAscii(
    PSTR        pstr
    )

/*++

Routine Description:

    Check if a character string consists only of printable 7-bit ASCII characters

Arguments:

    pstr - Specifies the character string to be checked

Return Value:

    TRUE if the specified string consists only of printable 7-bit ASCII characters
    FALSE otherwise

--*/

{
    PBYTE   pub = (PBYTE) pstr;

    while (*pub && gubCharMasks[*pub] && *pub < 127)
        pub++;

    return (*pub == 0);
}



//
// Table to indicate which characters are allowed in what fields
//

#define DEFAULT_MASK (KEYWORD_MASK|XLATION_MASK|QUOTED_MASK|STRING_MASK)
#define BINARY_MASK  (QUOTED_MASK|XLATION_MASK)

const BYTE gubCharMasks[256] = {

    /* 00 :   */ 0,
    /* 01 :   */ 0,
    /* 02 :   */ 0,
    /* 03 :   */ 0,
    /* 04 :   */ 0,
    /* 05 :   */ 0,
    /* 06 :   */ 0,
    /* 07 :   */ 0,
    /* 08 :   */ 0,
    /* 09 :   */ DEFAULT_MASK ^ KEYWORD_MASK,
    /* 0A :   */ QUOTED_MASK,
    /* 0B :   */ 0,
    /* 0C :   */ 0,
    /* 0D :   */ QUOTED_MASK,
    /* 0E :   */ 0,
    /* 0F :   */ 0,
    /* 10 :   */ 0,
    /* 11 :   */ 0,
    /* 12 :   */ 0,
    /* 13 :   */ 0,
    /* 14 :   */ 0,
    /* 15 :   */ 0,
    /* 16 :   */ 0,
    /* 17 :   */ 0,
    /* 18 :   */ 0,
    /* 19 :   */ 0,
    /* 1A :   */ 0,
    /* 1B :   */ 0,
    /* 1C :   */ 0,
    /* 1D :   */ 0,
    /* 1E :   */ 0,
    /* 1F :   */ 0,
    /* 20 :   */ DEFAULT_MASK ^ KEYWORD_MASK,
    /* 21 : ! */ DEFAULT_MASK,
    /* 22 : " */ DEFAULT_MASK ^ QUOTED_MASK,
    /* 23 : # */ DEFAULT_MASK,
    /* 24 : $ */ DEFAULT_MASK,
    /* 25 : % */ DEFAULT_MASK,
    /* 26 : & */ DEFAULT_MASK,
    /* 27 : ' */ DEFAULT_MASK,
    /* 28 : ( */ DEFAULT_MASK,
    /* 29 : ) */ DEFAULT_MASK,
    /* 2A : * */ DEFAULT_MASK,
    /* 2B : + */ DEFAULT_MASK,
    /* 2C : , */ DEFAULT_MASK,
    /* 2D : - */ DEFAULT_MASK,
    /* 2E : . */ DEFAULT_MASK,
    /* 2F : / */ DEFAULT_MASK ^ (KEYWORD_MASK|STRING_MASK),
    /* 30 : 0 */ DEFAULT_MASK | DIGIT_MASK,
    /* 31 : 1 */ DEFAULT_MASK | DIGIT_MASK,
    /* 32 : 2 */ DEFAULT_MASK | DIGIT_MASK,
    /* 33 : 3 */ DEFAULT_MASK | DIGIT_MASK,
    /* 34 : 4 */ DEFAULT_MASK | DIGIT_MASK,
    /* 35 : 5 */ DEFAULT_MASK | DIGIT_MASK,
    /* 36 : 6 */ DEFAULT_MASK | DIGIT_MASK,
    /* 37 : 7 */ DEFAULT_MASK | DIGIT_MASK,
    /* 38 : 8 */ DEFAULT_MASK | DIGIT_MASK,
    /* 39 : 9 */ DEFAULT_MASK | DIGIT_MASK,
    /* 3A : : */ DEFAULT_MASK ^ (KEYWORD_MASK|XLATION_MASK),
    /* 3B : ; */ DEFAULT_MASK,
    /* 3C : < */ DEFAULT_MASK,
    /* 3D : = */ DEFAULT_MASK,
    /* 3E : > */ DEFAULT_MASK,
    /* 3F : ? */ DEFAULT_MASK,
    /* 40 : @ */ DEFAULT_MASK,
    /* 41 : A */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 42 : B */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 43 : C */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 44 : D */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 45 : E */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 46 : F */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 47 : G */ DEFAULT_MASK,
    /* 48 : H */ DEFAULT_MASK,
    /* 49 : I */ DEFAULT_MASK,
    /* 4A : J */ DEFAULT_MASK,
    /* 4B : K */ DEFAULT_MASK,
    /* 4C : L */ DEFAULT_MASK,
    /* 4D : M */ DEFAULT_MASK,
    /* 4E : N */ DEFAULT_MASK,
    /* 4F : O */ DEFAULT_MASK,
    /* 50 : P */ DEFAULT_MASK,
    /* 51 : Q */ DEFAULT_MASK,
    /* 52 : R */ DEFAULT_MASK,
    /* 53 : S */ DEFAULT_MASK,
    /* 54 : T */ DEFAULT_MASK,
    /* 55 : U */ DEFAULT_MASK,
    /* 56 : V */ DEFAULT_MASK,
    /* 57 : W */ DEFAULT_MASK,
    /* 58 : X */ DEFAULT_MASK,
    /* 59 : Y */ DEFAULT_MASK,
    /* 5A : Z */ DEFAULT_MASK,
    /* 5B : [ */ DEFAULT_MASK,
    /* 5C : \ */ DEFAULT_MASK,
    /* 5D : ] */ DEFAULT_MASK,
    /* 5E : ^ */ DEFAULT_MASK,
    /* 5F : _ */ DEFAULT_MASK,
    /* 60 : ` */ DEFAULT_MASK,
    /* 61 : a */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 62 : b */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 63 : c */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 64 : d */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 65 : e */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 66 : f */ DEFAULT_MASK | HEX_DIGIT_MASK,
    /* 67 : g */ DEFAULT_MASK,
    /* 68 : h */ DEFAULT_MASK,
    /* 69 : i */ DEFAULT_MASK,
    /* 6A : j */ DEFAULT_MASK,
    /* 6B : k */ DEFAULT_MASK,
    /* 6C : l */ DEFAULT_MASK,
    /* 6D : m */ DEFAULT_MASK,
    /* 6E : n */ DEFAULT_MASK,
    /* 6F : o */ DEFAULT_MASK,
    /* 70 : p */ DEFAULT_MASK,
    /* 71 : q */ DEFAULT_MASK,
    /* 72 : r */ DEFAULT_MASK,
    /* 73 : s */ DEFAULT_MASK,
    /* 74 : t */ DEFAULT_MASK,
    /* 75 : u */ DEFAULT_MASK,
    /* 76 : v */ DEFAULT_MASK,
    /* 77 : w */ DEFAULT_MASK,
    /* 78 : x */ DEFAULT_MASK,
    /* 79 : y */ DEFAULT_MASK,
    /* 7A : z */ DEFAULT_MASK,
    /* 7B : { */ DEFAULT_MASK,
    /* 7C : | */ DEFAULT_MASK,
    /* 7D : } */ DEFAULT_MASK,
    /* 7E : ~ */ DEFAULT_MASK,
    /* 7F :   */ BINARY_MASK,
    /* 80 :   */ BINARY_MASK,
    /* 81 :   */ BINARY_MASK,
    /* 82 :   */ BINARY_MASK,
    /* 83 :   */ BINARY_MASK,
    /* 84 :   */ BINARY_MASK,
    /* 85 :   */ BINARY_MASK,
    /* 86 :   */ BINARY_MASK,
    /* 87 :   */ BINARY_MASK,
    /* 88 :   */ BINARY_MASK,
    /* 89 :   */ BINARY_MASK,
    /* 8A :   */ BINARY_MASK,
    /* 8B :   */ BINARY_MASK,
    /* 8C :   */ BINARY_MASK,
    /* 8D :   */ BINARY_MASK,
    /* 8E :   */ BINARY_MASK,
    /* 8F :   */ BINARY_MASK,
    /* 90 :   */ BINARY_MASK,
    /* 91 :   */ BINARY_MASK,
    /* 92 :   */ BINARY_MASK,
    /* 93 :   */ BINARY_MASK,
    /* 94 :   */ BINARY_MASK,
    /* 95 :   */ BINARY_MASK,
    /* 96 :   */ BINARY_MASK,
    /* 97 :   */ BINARY_MASK,
    /* 98 :   */ BINARY_MASK,
    /* 99 :   */ BINARY_MASK,
    /* 9A :   */ BINARY_MASK,
    /* 9B :   */ BINARY_MASK,
    /* 9C :   */ BINARY_MASK,
    /* 9D :   */ BINARY_MASK,
    /* 9E :   */ BINARY_MASK,
    /* 9F :   */ BINARY_MASK,
    /* A0 :   */ BINARY_MASK,
    /* A1 :   */ BINARY_MASK,
    /* A2 :   */ BINARY_MASK,
    /* A3 :   */ BINARY_MASK,
    /* A4 :   */ BINARY_MASK,
    /* A5 :   */ BINARY_MASK,
    /* A6 :   */ BINARY_MASK,
    /* A7 :   */ BINARY_MASK,
    /* A8 :   */ BINARY_MASK,
    /* A9 :   */ BINARY_MASK,
    /* AA :   */ BINARY_MASK,
    /* AB :   */ BINARY_MASK,
    /* AC :   */ BINARY_MASK,
    /* AD :   */ BINARY_MASK,
    /* AE :   */ BINARY_MASK,
    /* AF :   */ BINARY_MASK,
    /* B0 :   */ BINARY_MASK,
    /* B1 :   */ BINARY_MASK,
    /* B2 :   */ BINARY_MASK,
    /* B3 :   */ BINARY_MASK,
    /* B4 :   */ BINARY_MASK,
    /* B5 :   */ BINARY_MASK,
    /* B6 :   */ BINARY_MASK,
    /* B7 :   */ BINARY_MASK,
    /* B8 :   */ BINARY_MASK,
    /* B9 :   */ BINARY_MASK,
    /* BA :   */ BINARY_MASK,
    /* BB :   */ BINARY_MASK,
    /* BC :   */ BINARY_MASK,
    /* BD :   */ BINARY_MASK,
    /* BE :   */ BINARY_MASK,
    /* BF :   */ BINARY_MASK,
    /* C0 :   */ BINARY_MASK,
    /* C1 :   */ BINARY_MASK,
    /* C2 :   */ BINARY_MASK,
    /* C3 :   */ BINARY_MASK,
    /* C4 :   */ BINARY_MASK,
    /* C5 :   */ BINARY_MASK,
    /* C6 :   */ BINARY_MASK,
    /* C7 :   */ BINARY_MASK,
    /* C8 :   */ BINARY_MASK,
    /* C9 :   */ BINARY_MASK,
    /* CA :   */ BINARY_MASK,
    /* CB :   */ BINARY_MASK,
    /* CC :   */ BINARY_MASK,
    /* CD :   */ BINARY_MASK,
    /* CE :   */ BINARY_MASK,
    /* CF :   */ BINARY_MASK,
    /* D0 :   */ BINARY_MASK,
    /* D1 :   */ BINARY_MASK,
    /* D2 :   */ BINARY_MASK,
    /* D3 :   */ BINARY_MASK,
    /* D4 :   */ BINARY_MASK,
    /* D5 :   */ BINARY_MASK,
    /* D6 :   */ BINARY_MASK,
    /* D7 :   */ BINARY_MASK,
    /* D8 :   */ BINARY_MASK,
    /* D9 :   */ BINARY_MASK,
    /* DA :   */ BINARY_MASK,
    /* DB :   */ BINARY_MASK,
    /* DC :   */ BINARY_MASK,
    /* DD :   */ BINARY_MASK,
    /* DE :   */ BINARY_MASK,
    /* DF :   */ BINARY_MASK,
    /* E0 :   */ BINARY_MASK,
    /* E1 :   */ BINARY_MASK,
    /* E2 :   */ BINARY_MASK,
    /* E3 :   */ BINARY_MASK,
    /* E4 :   */ BINARY_MASK,
    /* E5 :   */ BINARY_MASK,
    /* E6 :   */ BINARY_MASK,
    /* E7 :   */ BINARY_MASK,
    /* E8 :   */ BINARY_MASK,
    /* E9 :   */ BINARY_MASK,
    /* EA :   */ BINARY_MASK,
    /* EB :   */ BINARY_MASK,
    /* EC :   */ BINARY_MASK,
    /* ED :   */ BINARY_MASK,
    /* EE :   */ BINARY_MASK,
    /* EF :   */ BINARY_MASK,
    /* F0 :   */ BINARY_MASK,
    /* F1 :   */ BINARY_MASK,
    /* F2 :   */ BINARY_MASK,
    /* F3 :   */ BINARY_MASK,
    /* F4 :   */ BINARY_MASK,
    /* F5 :   */ BINARY_MASK,
    /* F6 :   */ BINARY_MASK,
    /* F7 :   */ BINARY_MASK,
    /* F8 :   */ BINARY_MASK,
    /* F9 :   */ BINARY_MASK,
    /* FA :   */ BINARY_MASK,
    /* FB :   */ BINARY_MASK,
    /* FC :   */ BINARY_MASK,
    /* FD :   */ BINARY_MASK,
    /* FE :   */ BINARY_MASK,
    /* FF :   */ BINARY_MASK,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\ppd\ppdentry.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdentry.c

Abstract:

    Functions for parsing syntactical elements of a PPD file

Environment:

    PostScript driver, PPD parser

Revision History:

    08/20/96 -davidx-
        Common coding style for NT 5.0 drivers.

    03/26/96 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"
#include "ppdparse.h"

//
// Forward declaration of local functions
//

PPDERROR IParseKeyword(PPARSERDATA);
PPDERROR IParseValue(PPARSERDATA);
PPDERROR IParseField(PFILEOBJ, PBUFOBJ, BYTE);



PPDERROR
IParseEntry(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Parse one entry from a PPD file

Arguments:

    pParserData - Points to parser data structure

Return Value:

    Status code

--*/

{
    PPDERROR    iStatus;
    INT         iChar;
    PFILEOBJ    pFile = pParserData->pFile;

    //
    // Clear values from previous entry
    //

    CLEAR_BUFFER(&pParserData->Keyword);
    CLEAR_BUFFER(&pParserData->Option);
    CLEAR_BUFFER(&pParserData->Xlation);
    CLEAR_BUFFER(&pParserData->Value);

    pParserData->dwValueType = VALUETYPE_NONE;

    //
    // Parse the keyword field and skip over trailing white spaces
    //

    if ((iStatus = IParseKeyword(pParserData)) != PPDERR_NONE)
        return iStatus;

    //
    // Look at the first non-space character after the keyword field
    //

    VSkipSpace(pFile);

    if ((iChar = IGetNextChar(pFile)) == EOF_CHAR)
        return PPDERR_EOF;

    if (IS_NEWLINE(iChar))
        return PPDERR_NONE;

    if (iChar != SEPARATOR_CHAR)
    {
        //
        // Parse the option field and skip over trailing white spaces
        //

        ASSERT(iChar != EOF_CHAR);
        VUngetChar(pFile);

        if ((iStatus = IParseField(pFile, &pParserData->Option, KEYWORD_MASK)) != PPDERR_NONE)
            return iStatus;

        VSkipSpace(pFile);

        //
        // Look at the first non-space character after the option field
        //

        if ((iChar = IGetNextChar(pFile)) == XLATION_CHAR)
        {
            //
            // Parse the translation string field
            //

            if ((iStatus = IParseField(pFile, &pParserData->Xlation, XLATION_MASK)) != PPDERR_NONE)
                return iStatus;

            iChar = IGetNextChar(pFile);
        }
        
        if (iChar != SEPARATOR_CHAR)
            return ISyntaxError(pFile, "Missing ':'");
    }

    //
    // Parse the value field and interpret the entry if it's valid
    //
    
    if ((iStatus = IParseValue(pParserData)) == PPDERR_NONE)
    {
        //
        // Take care of any embedded hexdecimals in the translation string
        //
    
        if (! IS_BUFFER_EMPTY(&pParserData->Xlation) &&
            ! BConvertHexString(&pParserData->Xlation))
        {
            return ISyntaxError(pFile, "Invalid hexdecimals in the translation string");
        }

        //
        // Interpret the current entry
        //

        iStatus = IInterpretEntry(pParserData);
    }

    return iStatus;
}



PPDERROR
IParseKeyword(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Parse the keyword field of a PPD file entry

Arguments:

    pParserData - Points to parser data structure

Return Value:

    Status code

--*/

{
    PFILEOBJ    pFile = pParserData->pFile;
    INT         iChar;

    while (TRUE)
    {
        //
        // Get the first character of a line
        //

        if ((iChar = IGetNextChar(pFile)) == EOF_CHAR)
            return PPDERR_EOF;

        //
        // Ignore empty lines
        //

        if (IS_NEWLINE(iChar))
            continue;

        if (IS_SPACE(iChar))
        {
            VSkipSpace(pFile);
            
            if ((iChar = IGetNextChar(pFile)) == EOF_CHAR)
                return PPDERR_EOF;

            if (IS_NEWLINE(iChar))
                continue;

            return ISyntaxError(pFile, "Missing '*'");
        }

        //
        // If the line is not empty, the first character must be the keyword character
        //

        if (! IS_KEYWORD_CHAR(iChar))
            return ISyntaxError(pFile, "Missing '*'");
        
        //
        // If the second character is not %, then the line is a normal entry.
        // Otherwise, the line is a comment.
        //

        if ((iChar = IGetNextChar(pFile)) == EOF_CHAR)
            return PPDERR_EOF;

        if (!IS_NEWLINE(iChar) && iChar != COMMENT_CHAR)
        {
            VUngetChar(pFile);
            break;
        }

        VSkipLine(pFile);
    }

    return IParseField(pFile, &pParserData->Keyword, KEYWORD_MASK);
}



PPDERROR
IParseValue(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Parse the value field of a PPD file entry

Arguments:

    pParserData - Points to parser data structure
    
Return Value:

    Status code

--*/

{
    PPDERROR    iStatus;
    INT         iChar;
    PBUFOBJ     pBufObj = &pParserData->Value;
    PFILEOBJ    pFile = pParserData->pFile;

    //
    // The value is either a StringValue, a SymbolValue, or a QuotedValue
    // depending on the first non-space character
    //

    VSkipSpace(pFile);

    if ((iChar = IGetNextChar(pFile)) == EOF_CHAR)
        return PPDERR_EOF;

    if (iChar == QUOTE_CHAR)
    {
        //
        // The value is a quoted string
        //

        pParserData->dwValueType = VALUETYPE_QUOTED;
        
        if ((iStatus = IParseField(pFile, pBufObj, QUOTED_MASK)) != PPDERR_NONE)
            return iStatus;

        //
        // Read the closing quote character
        //

        if ((iChar = IGetNextChar(pFile)) != QUOTE_CHAR)
            return ISyntaxError(pFile, "Unbalanced '\"'");
    }
    else if (iChar == SYMBOL_CHAR)
    {
        //
        // The value is a symbol reference
        //

        pParserData->dwValueType = VALUETYPE_SYMBOL;
        ADD_CHAR_TO_BUFFER(pBufObj, iChar);

        if ((iStatus = IParseField(pFile, pBufObj, KEYWORD_MASK)) != PPDERR_NONE)
            return iStatus;
    }
    else
    {
        PBYTE   pubEnd;

        //
        // The value is a string
        //

        pParserData->dwValueType = VALUETYPE_STRING;
        VUngetChar(pFile);

        if ((iStatus = IParseField(pFile, pBufObj, STRING_MASK)) != PPDERR_NONE)
            return iStatus;

        //
        // Ignore any trailing spaces
        //

        ASSERT(pBufObj->dwSize > 0);
        pubEnd = pBufObj->pbuf + (pBufObj->dwSize - 1);

        while (IS_SPACE(*pubEnd))
            *pubEnd-- = NUL;

        pBufObj->dwSize= (DWORD)(pubEnd - pBufObj->pbuf) + 1;
        ASSERT(pBufObj->dwSize > 0);
    }

    //
    // Ignore extra characters after the entry value
    //

    VSkipSpace(pFile);
    iChar = IGetNextChar(pFile);

    if (! IS_NEWLINE(iChar))
    {
        if (iChar != XLATION_CHAR)
        {
            TERSE(("%ws: Extra chars at the end of line %d\n",
                   pFile->ptstrFileName,
                   pFile->iLineNumber));
        }

        VSkipLine(pFile);
    }

    return PPDERR_NONE;
}



PPDERROR
IParseField(
    PFILEOBJ    pFile,
    PBUFOBJ     pBufObj,
    BYTE        ubMask
    )

/*++

Routine Description:

    Parse one field of a PPD file entry

Arguments:

    pFile - Specifies the input file object
    pBufObj - Specifies the buffer for storing the field value
    ubMask - Mask to limit the set of allowable characters

Return Value:

    Status code

--*/

{
    PPDERROR    iStatus;
    INT         iChar;

    while ((iChar = IGetNextChar(pFile)) != EOF_CHAR)
    {
        if (! IS_MASKED_CHAR(iChar, ubMask))
        {
            //
            // Encountered a not-allowed character
            //

            if (IS_BUFFER_EMPTY(pBufObj) && !(ubMask & QUOTED_MASK))
                return ISyntaxError(pFile, "Empty field");

            //
            // Always put a null byte at the end
            //

            pBufObj->pbuf[pBufObj->dwSize] = 0;

            VUngetChar(pFile);
            return PPDERR_NONE;
        }
        else
        {
            //
            // If we're parsing a quoted string and we encountered a line
            // starting with the keyword character, then we'll assume 
            // the closing quote is missing. Just give a warning and continue.
            //

            if ((ubMask & QUOTED_MASK) &&
                IS_KEYWORD_CHAR(iChar) &&
                !IS_BUFFER_EMPTY(pBufObj) &&
                IS_NEWLINE(pBufObj->pbuf[pBufObj->dwSize - 1]))
            {
                (VOID) ISyntaxError(pFile, "Expecting '\"'");
            }

            //
            // Grow the buffer if it's full. If we're not allowed to
            // grow it, then return a syntax error.
            //

            if (IS_BUFFER_FULL(pBufObj))
            {
                if (ubMask & (STRING_MASK|QUOTED_MASK))
                {
                    if ((iStatus = IGrowValueBuffer(pBufObj)) != PPDERR_NONE)
                        return iStatus;
                }
                else
                {
                    return ISyntaxError(pFile, "Field too long");
                }
            }

            ADD_CHAR_TO_BUFFER(pBufObj, iChar);
        }
    }

    return PPDERR_EOF;
}



BOOL
BConvertHexString(
    PBUFOBJ pBufObj
    )

/*++

Routine Description:

    Convert embedded hexdecimal strings into binary data

Arguments:

    pBufObj - Specifies the buffer object to be converted

Return Value:

    TRUE if everything is ok
    FALSE if the embedded hexdecimal string is ill-formed

--*/

#define HexDigitValue(c) \
        (((c) >= '0' && (c) <= '9') ? ((c) - '0') : \
         ((c) >= 'A' && (c) <= 'F') ? ((c) - 'A' + 10) : ((c) - 'a' + 10))

{
    PBYTE   pubSrc, pubDest;
    DWORD   dwSize;
    DWORD   dwHexMode = 0;

    pubSrc = pubDest = pBufObj->pbuf;
    dwSize = pBufObj->dwSize;

    while (dwSize--)
    {
        if (dwHexMode)
        {
            //
            // We're currently inside a hex string:
            //  switch to normal mode if '>' is encountered
            //  otherwise, only valid hex digits, newline, and spaces are allowed
            //

            if (IS_HEX_DIGIT(*pubSrc))
            {
                //
                // If we're currently on odd hex digit, save the hex digit value
                // in the upper nibble of the destination byte.
                // If we're on even hex digit, save the hex digit value in the
                // lower nibble of the destination byte. If the destination byte
                // is zero and NUL is not allowed, then return with error.
                //

                if (dwHexMode & 1)
                    *pubDest = HexDigitValue(*pubSrc) << 4;
                else
                    *pubDest++ |= HexDigitValue(*pubSrc);

                dwHexMode++;
            }
            else if (*pubSrc == '>')
            {
                if ((dwHexMode & 1) == 0)
                {
                    TERSE(("Odd number of hexdecimal digits\n"));
                    return FALSE;
                }

                dwHexMode = 0;
            }
            else if (!IS_SPACE(*pubSrc) && !IS_NEWLINE(*pubSrc))
            {
                TERSE(("Invalid hexdecimal digit\n"));
                return FALSE;
            }
        }
        else
        {
            //
            // We're not currently inside a hex string:
            //  switch to hex mode if '<' is encountered
            //  otherwise, simply copy the source byte to the destination
            //

            if (*pubSrc == '<')
                dwHexMode = 1;
            else
                *pubDest++ = *pubSrc;
        }

        pubSrc++;
    }

    if (dwHexMode)
    {
        TERSE(("Missing '>' in hexdecimal string\n"));
        return FALSE;
    }

    //
    // Modified the buffer size if it's changed
    //

    *pubDest = 0;
    pBufObj->dwSize = (DWORD)(pubDest - pBufObj->pbuf);
    return TRUE;
}



PPDERROR
ISyntaxErrorMessage(
    PFILEOBJ    pFile,
    PSTR        pstrMsg
    )

/*++

Routine Description:

    Display syntax error message

Arguments:

    pFile - Specifies the input file object
    pstrMsg - Indicate the reason for the syntax error

Return Value:

    PPDERR_SYNTAX

--*/

{
    //
    // Display an error message
    //

    TERSE(("%ws: %s on line %d\n", pFile->ptstrFileName, pstrMsg, pFile->iLineNumber));

    //
    // Skip any remaining characters on the current line
    //

    VSkipLine(pFile);

    return PPDERR_SYNTAX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\ppd\ppdparse.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdparse.c

Abstract:

    Parser for converting PPD file from ASCII text to binary data

Environment:

    PostScript driver, PPD parser

Revision History:

    12/03/96 -davidx-
        Check binary file date against all source printer description files.

    09/30/96 -davidx-
        Cleaner handling of ManualFeed and AutoSelect feature.

    09/17/96 -davidx-
        Add link field to order dependency structure.

    08/22/96 -davidx-
        New binary data format for NT 5.0.

    08/20/96 -davidx-
        Common coding style for NT 5.0 drivers.

    03/26/96 -davidx-
        Created it.

--*/


#include "lib.h"
#include "ppd.h"
#include "ppdparse.h"
#include "ppdrsrc.h"

//
// Round up n to a multiple of m
//

#define ROUND_UP_MULTIPLE(n, m) ((((n) + (m) - 1) / (m)) * (m))

//
// Round up n to a multiple of sizeof(DWORD) = 4
//

#define DWORD_ALIGN(n) (((n) + 3) & ~3)

//
// Raise an exception to cause VPackBinaryData to fail
//

#define PACK_BINARY_DATA_EXCEPTION() RaiseException(0xC0000000, 0, 0, NULL);

//
// Display a semantic error message
//

#define SEMANTIC_ERROR(arg) { TERSE(arg); pParserData->bErrorFlag = TRUE; }

//
// Data structure to store meta-information about a printer feature
// Note that the default order dependency value is relative to MAX_ORDER_VALUE.
// Explicitly specified order value must be less than MAX_ORDER_VALUE.
//
// We assume all printer-sticky features have higher priority than
// all doc-sticky features. The priority values for printer-sticky
// feature must be >= PRNPROP_BASE_PRIORITY.
//

#define MAX_ORDER_VALUE         0x7fffffff
#define PRNPROP_BASE_PRIORITY   0x10000

typedef struct _FEATUREDATA {

    DWORD   dwFeatureID;        // predefined feature ID
    DWORD   dwOptionSize;       // size of the associated option structure
    DWORD   dwPriority;         // feature priority
    DWORD   dwFlags;            // feature flags

} FEATUREDATA, *PFEATUREDATA;


//
// Special code page value used internally in this file.
// Make sure they don't conflict with standard code page values.
//

#define CP_ERROR        0xffffffff
#define CP_UNICODE      0xfffffffe



PFEATUREDATA
PGetFeatureData(
    DWORD   dwFeatureID
    )

/*++

Routine Description:

    Return meta-information about the requested feature

Arguments:

    dwFeatureID - Specifies what feature the caller is interested in

Return Value:

    Pointer to a FEATUREDATA structure corresponding to the request feature

--*/

{
    static FEATUREDATA FeatureData[] =
    {
        { GID_RESOLUTION,     sizeof(RESOLUTION),  10,  0},
        { GID_PAGESIZE,       sizeof(PAGESIZE),    50,  0},
        { GID_PAGEREGION,     sizeof(OPTION),      40,  FEATURE_FLAG_NOUI},
        { GID_DUPLEX,         sizeof(DUPLEX),      20,  0},
        { GID_INPUTSLOT,      sizeof(INPUTSLOT),   30,  0},
        { GID_MEDIATYPE,      sizeof(MEDIATYPE),   10,  0},
        { GID_COLLATE,        sizeof(COLLATE),     10,  0},
        { GID_OUTPUTBIN,      sizeof(OUTPUTBIN),   10,  0},
        { GID_MEMOPTION,      sizeof(MEMOPTION),   10,  0},
        { GID_LEADINGEDGE,    sizeof(OPTION),      25,  FEATURE_FLAG_NOUI | FEATURE_FLAG_NOINVOCATION},
        { GID_USEHWMARGINS,   sizeof(OPTION),      25,  FEATURE_FLAG_NOUI | FEATURE_FLAG_NOINVOCATION},
        { GID_UNKNOWN,        sizeof(OPTION),       0,  0},
    };

    DWORD   dwIndex;

    for (dwIndex = 0; FeatureData[dwIndex].dwFeatureID != GID_UNKNOWN; dwIndex++)
    {
        if (FeatureData[dwIndex].dwFeatureID == dwFeatureID)
            break;
    }

    return &FeatureData[dwIndex];
}



VOID
VGrowPackBuffer(
    PPARSERDATA pParserData,
    DWORD       dwBytesNeeded
    )

/*++

Routine Description:

    Grow the buffer used to hold packed binary data if necessary

Arguments:

    pParserData - Points to parser data structure
    dwBytesNeeded - Number of bytes needed

Return Value:

    NONE

--*/

#define PACK_BUFFER_MAX 1024    // measured in number of pages

{
    VALIDATE_PARSER_DATA(pParserData);

    //
    // We need to commit more memory if the number of bytes needed plus the
    // number of bytes used is over the maximum number of bytes committed.
    //

    if ((dwBytesNeeded += pParserData->dwBufSize) > pParserData->dwCommitSize)
    {
        //
        // Check if we're being called for the first time.
        // In that case, we'll need to reserved the virtual address space.
        //

        if (pParserData->pubBufStart == NULL)
        {
            SYSTEM_INFO SystemInfo;
            PBYTE       pbuf;

            GetSystemInfo(&SystemInfo);
            pParserData->dwPageSize = SystemInfo.dwPageSize;

            pbuf = VirtualAlloc(NULL,
                                PACK_BUFFER_MAX * SystemInfo.dwPageSize,
                                MEM_RESERVE,
                                PAGE_READWRITE);

            if (pbuf == NULL)
            {
                ERR(("Cannot reserve memory: %d\n", GetLastError()));
                PACK_BINARY_DATA_EXCEPTION();
            }

            pParserData->pubBufStart = pbuf;
            pParserData->pInfoHdr = (PINFOHEADER) pbuf;
            pParserData->pUIInfo = (PUIINFO) (pbuf + sizeof(INFOHEADER));
            pParserData->pPpdData = (PPPDDATA) (pbuf + sizeof(INFOHEADER) + sizeof(UIINFO));
        }

        //
        // Make sure we're not overflowing
        //

        if (dwBytesNeeded > (PACK_BUFFER_MAX * pParserData->dwPageSize))
        {
            ERR(("Binary printer description is too big.\n"));
            PACK_BINARY_DATA_EXCEPTION();
        }

        //
        // Commit the extra amount of memory needed (rounded up
        // to the next page boundary). Note that the memory allocated
        // using VirtualAlloc is zero-initialized.
        //

        dwBytesNeeded -= pParserData->dwCommitSize;
        dwBytesNeeded = ROUND_UP_MULTIPLE(dwBytesNeeded, pParserData->dwPageSize);
        pParserData->dwCommitSize += dwBytesNeeded;

        if (! VirtualAlloc(pParserData->pubBufStart,
                           pParserData->dwCommitSize,
                           MEM_COMMIT,
                           PAGE_READWRITE))
        {
            ERR(("Cannot commit memory: %d\n", GetLastError()));
            PACK_BINARY_DATA_EXCEPTION();
        }
    }
}



PVOID
PvFindListItem(
    PVOID   pvList,
    PCSTR   pstrName,
    PDWORD  pdwIndex
    )

/*++

Routine Description:

    Find a named item from a linked-list

Arguments:

    pParserData - Points to parser data structure
    pstrName - Specifies the item name to be found
    pdwIndex - Points to a variable for returning a zero-based item index

Return Value:

    Points to the named listed item, NULL if the named item is not in the list

Note:

    We're not bothering with fancy data structures here because the parser
    is used infrequently to convert a ASCII printer description file to its
    binary version. After that, the driver will access binary data directly.

--*/

{
    PLISTOBJ pItem;
    DWORD    dwIndex;

    for (pItem = pvList, dwIndex = 0;
        pItem && strcmp(pItem->pstrName, pstrName) != EQUAL_STRING;
        pItem = pItem->pNext, dwIndex++)
    {
    }

    if (pdwIndex)
        *pdwIndex = dwIndex;

    return pItem;
}



DWORD
DwCountListItem(
    PVOID   pvList
    )

/*++

Routine Description:

    Count the number of items in a linked-list

Arguments:

    pvList - Points to a linked-list

Return Value:

    Number of items in a linked-list

--*/

{
    PLISTOBJ pItem;
    DWORD    dwCount;

    for (pItem = pvList, dwCount = 0;
        pItem != NULL;
        pItem = pItem->pNext, dwCount++)
    {
    }

    return dwCount;
}



VOID
VPackStringUnicode(
    PPARSERDATA pParserData,
    PTRREF     *ploDest,
    PWSTR       pwstrSrc
    )

/*++

Routine Description:

    Pack a Unicode string into the binary data file

Arguments:

    pParserData - Points to the parser data structure
    ploDest - Returns the byte offset of the packed Unicode string
    pwstrSrc - Specifies the source Unicode string to be packed

Return Value:

    NONE

--*/

{
    if (pwstrSrc == NULL)
        *ploDest = 0;
    else
    {
        DWORD   dwSize = (wcslen(pwstrSrc) + 1) * sizeof(WCHAR);

        VGrowPackBuffer(pParserData, dwSize);
        CopyMemory(pParserData->pubBufStart + pParserData->dwBufSize, pwstrSrc, dwSize);

        *ploDest = pParserData->dwBufSize;
        pParserData->dwBufSize += DWORD_ALIGN(dwSize);
    }
}



VOID
VPackStringRsrc(
    PPARSERDATA pParserData,
    PTRREF     *ploDest,
    INT         iStringId
    )

/*++

Routine Description:

    Pack a Unicode string resource into the binary data file

Arguments:

    pParserData - Points to the parser data structure
    ploDest - Returns the byte offset of the packed Unicode string
    iStringId - Specifies the resource ID of the Unicode string to be packed

Return Value:

    NONE

--*/

{
    WCHAR   awchBuffer[MAX_XLATION_LEN];

    if (! LoadString(ghInstance, iStringId, awchBuffer, MAX_XLATION_LEN))
        awchBuffer[0] = NUL;

    VPackStringUnicode(pParserData, ploDest, awchBuffer);
}



VOID
VPackStringAnsi(
    PPARSERDATA pParserData,
    PTRREF     *ploDest,
    PSTR        pstrSrc
    )

/*++

Routine Description:

    Pack an ANSI string into the binary data file

Arguments:

    pParserData - Points to the parser data structure
    ploDest - Returns the byte offset of the packed ANSI string
    pstrSrc - Specifies the source ANSI string to be packed

Return Value:

    NONE

--*/

{
    if (pstrSrc == NULL)
        *ploDest = 0;
    else
    {
        DWORD   dwSize = strlen(pstrSrc) + 1;

        VGrowPackBuffer(pParserData, dwSize);
        CopyMemory(pParserData->pubBufStart + pParserData->dwBufSize, pstrSrc, dwSize);

        *ploDest = pParserData->dwBufSize;
        pParserData->dwBufSize += DWORD_ALIGN(dwSize);
    }
}



INT
ITranslateToUnicodeString(
    PWSTR   pwstr,
    PCSTR   pstr,
    INT     iLength,
    UINT    uCodePage
    )

/*++

Routine Description:

    Translate an ANSI string to Unicode string

Arguments:

    pwstr - Buffer for storing Unicode string
    pstr - Pointer to ANSI string to be translated
    iLength - Length of ANSI string, in bytes
    uCodePage - Code page used to do the translation

Return Value:

    Number of Unicode characters translated
    0 if there is an error

--*/

{
    ASSERT(iLength >= 0);

    if (uCodePage == CP_UNICODE)
    {
        INT i;

        //
        // Make sure the Unicode translation string has even number of bytes
        //

        if (iLength & 1)
        {
            TERSE(("Odd number of bytes in Unicode translation string.\n"));
            iLength--;
        }

        //
        // We assume Unicode values are specified in big-endian format in
        // the PPD file. Internally we store Unicode values in little-endian
        // format. So we need to swap bytes here.
        //

        iLength /= sizeof(WCHAR);

        for (i=iLength; i--; pstr += 2)
            *pwstr++ = (pstr[0] << 8) | ((BYTE) pstr[1]);
    }
    else
    {
        if (uCodePage == CP_ERROR)
            uCodePage = CP_ACP;

        iLength = MultiByteToWideChar(uCodePage, 0, pstr, iLength, pwstr, iLength);

        ASSERT(iLength >= 0);
    }

    return iLength;
}



VOID
VPackStringAnsiToUnicode(
    PPARSERDATA pParserData,
    PTRREF     *ploDest,
    PSTR        pstrSrc,
    INT         iLength
    )

/*++

Routine Description:

    Convert an ANSI string to Unicode and pack it into the binary data file

Arguments:

    pParserData - Points to the parser data structure
    ploDest - Returns the byte offset of the packed Unicode string
    pstrSrc - Specifies the source ANSI string to be packed
    iLength - Specifies the byte length of the ANSI string

Return Value:

    NONE

--*/

{
    INT     iSize;
    PTSTR   ptstr;

    //
    // Source string is NULL
    //

    if (pstrSrc == NULL)
    {
        *ploDest = 0;
        return;
    }

    //
    // If source string length is -1, it means
    // the source string is null-terminated.
    //

    if (iLength == -1)
        iLength = strlen(pstrSrc);

    if (pParserData->uCodePage == CP_UNICODE)
    {
        //
        // Source string is Unicode string
        //

        iSize = iLength + sizeof(WCHAR);
    }
    else
    {
        //
        // Source string is ANSI string
        //

        iSize = (iLength + 1) * sizeof(WCHAR);
    }

    VGrowPackBuffer(pParserData, iSize);
    ptstr = (PTSTR) (pParserData->pubBufStart + pParserData->dwBufSize);
    *ploDest = pParserData->dwBufSize;
    pParserData->dwBufSize += DWORD_ALIGN(iSize);

    ITranslateToUnicodeString(ptstr, pstrSrc, iLength, pParserData->uCodePage);
}



VOID
VPackStringXlation(
    PPARSERDATA pParserData,
    PTRREF     *ploDest,
    PSTR        pstrName,
    PINVOCOBJ   pXlation
    )

/*++

Routine Description:

    Figure out the display name of an item, convert it from ANSI
    to Unicode string, and pack it into the binary data

Arguments:

    pParserData - Points to the parser data structure
    ploDest - Returns the byte offset of the packed Unicode string
    pstrName - Specifies the name string associated with the item
    pXlation - Specifies the translation string associated with the item

Return Value:

    NONE

--*/

{
    //
    // The display name of an item is its translation string if there is one.
    // Otherwise, the display name is the same as the name of the item.
    //
    // If the translation is present, use the current language encoding
    // to convert it to Unicode. Otherwise, we always use the ISOLatin1
    // encoding to convert the name of the item to Unicode.
    //

    if (pXlation && pXlation->pvData && pParserData->uCodePage != CP_ERROR)
        VPackStringAnsiToUnicode(pParserData, ploDest, pXlation->pvData, pXlation->dwLength);
    else
    {
        UINT uCodePage = pParserData->uCodePage;

        pParserData->uCodePage = 1252;
        VPackStringAnsiToUnicode(pParserData, ploDest, pstrName, -1);
        pParserData->uCodePage = uCodePage;
    }
}



VOID
VPackInvocation(
    PPARSERDATA pParserData,
    PINVOCATION pInvocation,
    PINVOCOBJ   pInvocObj
    )

/*++

Routine Description:

    Pack an invocation string into the binary data

Arguments:

    pParserData - Points to the parser data structure
    pInvocation - Returns information about the packed invocation string
    pInvocObj - Points to the invocation string to be packed

Return Value:

    NONE

--*/

{
    if (IS_SYMBOL_INVOC(pInvocObj))
    {
        //
        // The invocation is a symbol reference
        //

        PSYMBOLOBJ  pSymbol = pInvocObj->pvData;

        pInvocation->dwCount = pSymbol->Invocation.dwLength;

        //
        // For symbol invocation, Invocation.pvData actually stores the
        // 32-bit offset value (See function VPackSymbolDefinitions), so
        // it's safe to cast it into ULONG/DWORD.
        //

        pInvocation->loOffset = (PTRREF) PtrToUlong(pSymbol->Invocation.pvData);
    }
    else if (pInvocObj->dwLength == 0)
    {
        pInvocation->dwCount = 0;
        pInvocation->loOffset = 0;
    }
    else
    {
        //
        // Notice that we're always padding a zero byte at the end of
        // the invocation string. This byte is not counted in dwLength.
        //

        VGrowPackBuffer(pParserData, pInvocObj->dwLength+1);

        CopyMemory(pParserData->pubBufStart + pParserData->dwBufSize,
                   pInvocObj->pvData,
                   pInvocObj->dwLength);

        pInvocation->dwCount = pInvocObj->dwLength;
        pInvocation->loOffset = pParserData->dwBufSize;
        pParserData->dwBufSize += DWORD_ALIGN(pInvocObj->dwLength+1);
    }
}


VOID
VPackPatch(
    PPARSERDATA pParserData,
    PJOBPATCHFILE     pPackedPatch,
    PJOBPATCHFILEOBJ  pPatchObj
    )

/*++

Routine Description:

    Pack an job file patch invocation string into the binary data

Arguments:

    pParserData - Points to the parser data structure
    pInvocation - Returns information about the packed invocation string
    pInvocObj - Points to the invocation string to be packed

Return Value:

    NONE

--*/

{
    if (pPatchObj->Invocation.dwLength == 0)
    {
        pPackedPatch->dwCount = 0;
        pPackedPatch->loOffset = 0;
    }
    else
    {
        //
        // Notice that we're always padding a zero byte at the end of
        // the invocation string. This byte is not counted in dwLength.
        //

        VGrowPackBuffer(pParserData, pPatchObj->Invocation.dwLength+1);

        CopyMemory(pParserData->pubBufStart + pParserData->dwBufSize,
                   pPatchObj->Invocation.pvData,
                   pPatchObj->Invocation.dwLength);

        pPackedPatch->loOffset = pParserData->dwBufSize;
        pPackedPatch->dwCount = pPatchObj->Invocation.dwLength;

        pParserData->dwBufSize += DWORD_ALIGN(pPatchObj->Invocation.dwLength+1);
    }

    pPackedPatch->lJobPatchNo = pPatchObj->lPatchNo;
}



VOID
VPackSymbolDefinitions(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack all symbol definitions into the binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PINVOCOBJ   pInvocObj;
    PSYMBOLOBJ  pSymbol;

    VALIDATE_PARSER_DATA(pParserData);

    for (pSymbol = pParserData->pSymbols;
        pSymbol != NULL;
        pSymbol = pSymbol->pNext)
    {
        pInvocObj = &pSymbol->Invocation;
        ASSERT(! IS_SYMBOL_INVOC(pInvocObj));

        if (pInvocObj->dwLength == 0)
            pInvocObj->pvData = NULL;
        else
        {
            //
            // Notice that we're always padding a zero byte at the end of
            // the invocation string. This byte is not counted in dwLength.
            //

            VGrowPackBuffer(pParserData, pInvocObj->dwLength+1);

            CopyMemory(pParserData->pubBufStart + pParserData->dwBufSize,
                       pInvocObj->pvData,
                       pInvocObj->dwLength);

            pInvocObj->pvData = (PVOID)ULongToPtr(pParserData->dwBufSize);
            pParserData->dwBufSize += DWORD_ALIGN(pInvocObj->dwLength+1);
        }
    }
}



VOID
VResolveSymbolInvocation(
    PPARSERDATA pParserData,
    PINVOCOBJ   pInvocObj
    )

/*++

Routine Description:

    Check if an invocation string is a symbol reference and resolve it if necessary

Arguments:

    pParserData - Points to the parser data structure
    pInvocObj - Specifies the invocation string to be resolved

Return Value:

    NONE

--*/

{
    if (IS_SYMBOL_INVOC(pInvocObj))
    {
        PSTR        pstrName;
        PSYMBOLOBJ  pSymbol;

        pstrName = (PSTR) pInvocObj->pvData;

        if ((pSymbol = PvFindListItem(pParserData->pSymbols, pstrName, NULL)) == NULL)
        {
            SEMANTIC_ERROR(("Undefined symbol: %s\n", pstrName));
            pInvocObj->dwLength = 0;
            pInvocObj->pvData = NULL;
        }
        else
            pInvocObj->pvData = (PVOID) pSymbol;
    }
}



VOID
VResolveSymbolReferences(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Resolve all symbol references in the parsed PPD data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PFEATUREOBJ pFeature;
    POPTIONOBJ  pOption;
    PJOBPATCHFILEOBJ  pJobPatchFile;

    VALIDATE_PARSER_DATA(pParserData);

    VResolveSymbolInvocation(pParserData, &pParserData->Password);
    VResolveSymbolInvocation(pParserData, &pParserData->ExitServer);
    VResolveSymbolInvocation(pParserData, &pParserData->PatchFile);
    VResolveSymbolInvocation(pParserData, &pParserData->JclBegin);
    VResolveSymbolInvocation(pParserData, &pParserData->JclEnterPS);
    VResolveSymbolInvocation(pParserData, &pParserData->JclEnd);
    VResolveSymbolInvocation(pParserData, &pParserData->ManualFeedFalse);

    for (pFeature = pParserData->pFeatures;
        pFeature != NULL;
        pFeature = pFeature->pNext)
    {
        VResolveSymbolInvocation(pParserData, &pFeature->QueryInvoc);

        for (pOption = pFeature->pOptions;
            pOption != NULL;
            pOption = pOption->pNext)
        {
            VResolveSymbolInvocation(pParserData, &pOption->Invocation);
        }
    }

    for (pJobPatchFile = pParserData->pJobPatchFiles;
        pJobPatchFile != NULL;
        pJobPatchFile = pJobPatchFile->pNext)
    {
        VResolveSymbolInvocation(pParserData, &pJobPatchFile->Invocation);
    }
}



BOOL
BFindUIConstraintFeatureOption(
    PPARSERDATA pParserData,
    PCSTR       pstrKeyword,
    PFEATUREOBJ *ppFeature,
    PDWORD      pdwFeatureIndex,
    PCSTR       pstrOption,
    POPTIONOBJ  *ppOption,
    PDWORD      pdwOptionIndex
    )

/*++

Routine Description:

    Find the feature/option specified in UIConstraints and OrderDependency entries

Arguments:

    pParserData - Points to the parser data structure
    pstrKeyword - Specifies the feature keyword string
    ppFeature - Return a pointer to the feature structure found
    pdwFeatureIndex - Return the index of the feature found
    pstrOption - Specifies the option keyword string
    ppOption - Return a pointer to the option structure found
    pdwOptionIndex - Return the index of the option found

Return Value:

    TRUE if successful, FALSE if the specified feature/option is not found

--*/

{
    if (! (pstrKeyword = PstrStripKeywordChar(pstrKeyword)))
        return FALSE;

    //
    // HACK:
    //  replace *ManualFeed True option with *InputSlot ManualFeed option
    //  replace *CustomPageSize True option with *PageSize CustomPageSize option
    //

    if ((strcmp(pstrKeyword, gstrManualFeedKwd) == EQUAL_STRING) &&
        (*pstrOption == NUL ||
         strcmp(pstrOption, gstrTrueKwd) == EQUAL_STRING ||
         strcmp(pstrOption, gstrOnKwd) == EQUAL_STRING))
    {
        pstrKeyword = gstrInputSlotKwd;
        pstrOption = gstrManualFeedKwd;
    }
    else if ((strcmp(pstrKeyword, gstrCustomSizeKwd) == EQUAL_STRING) &&
             (*pstrOption == NUL || strcmp(pstrOption, gstrTrueKwd) == EQUAL_STRING))
    {
        pstrKeyword = gstrPageSizeKwd;
        pstrOption = gstrCustomSizeKwd;
    }
    else if (strcmp(pstrKeyword, gstrVMOptionKwd) == EQUAL_STRING)
        pstrKeyword = gstrInstallMemKwd;

    //
    // Find the specified feature
    //

    if (! (*ppFeature = PvFindListItem(pParserData->pFeatures, pstrKeyword, pdwFeatureIndex)))
        return FALSE;

    //
    // Find the specified option
    //

    if (*pstrOption)
    {
        return (*ppOption = PvFindListItem((*ppFeature)->pOptions,
                                           pstrOption,
                                           pdwOptionIndex)) != NULL;
    }
    else
    {
        *ppOption = NULL;
        *pdwOptionIndex = OPTION_INDEX_ANY;
        return TRUE;
    }
}



VOID
VPackUIConstraints(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack UIConstraints information into binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PUICONSTRAINT   pPackedConstraint;
    PFEATUREOBJ     pFeature;
    POPTIONOBJ      pOption;
    PLISTOBJ        pConstraint;
    DWORD           dwConstraints, dwConstraintBufStart;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // By default, there is no constaint for all features and options
    //

    for (pFeature = pParserData->pFeatures;
        pFeature != NULL;
        pFeature = pFeature->pNext)
    {
        pFeature->dwConstraint = NULL_CONSTRAINT;

        for (pOption = pFeature->pOptions;
            pOption != NULL;
            pOption = pOption->pNext)
        {
            pOption->dwConstraint = NULL_CONSTRAINT;
        }
    }

    //
    // Count the number of *UIConstraints entries
    //

    dwConstraints = DwCountListItem(pParserData->pUIConstraints);

    if (dwConstraints == 0)
        return;
    //
    // Don't yet grow the buffer, we only number the number of constraints after we
    // evaluated the *ManualFeed: False constraints. pPackedConstraint points right
    // after the end of the current buffer
    //
    pPackedConstraint = (PUICONSTRAINT) (pParserData->pubBufStart + pParserData->dwBufSize);
    dwConstraintBufStart = pParserData->dwBufSize;

    //
    // Interpret each *UIConstraints entry
    //

    dwConstraints = 0;

    for (pConstraint = pParserData->pUIConstraints;
        pConstraint != NULL;
        pConstraint = pConstraint->pNext)
    {
        PFEATUREOBJ pFeature2;
        POPTIONOBJ  pOption2;
        DWORD       dwFeatureIndex, dwOptionIndex, dwManFeedFalsePos = 0;
        CHAR        achWord1[MAX_WORD_LEN];
        CHAR        achWord2[MAX_WORD_LEN];
        CHAR        achWord3[MAX_WORD_LEN];
        CHAR        achWord4[MAX_WORD_LEN];
        PSTR        pstr = pConstraint->pstrName;
        BOOL        bSuccess = FALSE;

        //
        // The value for a UIConstraints entry consists of four separate components:
        //  featureName1 [optionName1] featureName2 [optionName2]
        //

        (VOID) BFindNextWord(&pstr, achWord1);

        if (IS_KEYWORD_CHAR(*pstr))
            achWord2[0] = NUL;
        else
            (VOID) BFindNextWord(&pstr, achWord2);

        (VOID) BFindNextWord(&pstr, achWord3);
        (VOID) BFindNextWord(&pstr, achWord4);

        //
        // hack the *ManualFeed False constraints
        //
        if ((IS_KEYWORD_CHAR(achWord1[0])) &&
            (strcmp(&(achWord1[1]), gstrManualFeedKwd) == EQUAL_STRING) &&
            (strcmp(achWord2, gstrFalseKwd) == EQUAL_STRING))
        {
            //
            // check the validity of the constraint feature/option. Fall through if invalid
            //
            if (BFindUIConstraintFeatureOption(pParserData,
                                               achWord3,
                                               &pFeature,
                                               &dwFeatureIndex,
                                               achWord4,
                                               &pOption,
                                               &dwOptionIndex))
                dwManFeedFalsePos = 1;
        }
        else if ((IS_KEYWORD_CHAR(achWord3[0])) &&
                 (strcmp(&(achWord3[1]), gstrManualFeedKwd) == EQUAL_STRING) &&
                 (strcmp(achWord4, gstrFalseKwd) == EQUAL_STRING))
        {
            //
            // check the validity of the constraint feature/option. Fall through if invalid
            //
            if (BFindUIConstraintFeatureOption(pParserData,
                                               achWord1,
                                               &pFeature,
                                               &dwFeatureIndex,
                                               achWord2,
                                               &pOption,
                                               &dwOptionIndex))
                dwManFeedFalsePos = 2;

        }
        if (dwManFeedFalsePos)
        {
            //
            // get the index of the manual feed input slot
            //
            DWORD dwInputSlotFeatIndex, dwManFeedSlotIndex, dwInputSlotCount, dwSlotIndex;
            PFEATUREOBJ pInputSlotFeature;

            if ((pInputSlotFeature = PvFindListItem(pParserData->pFeatures, gstrInputSlotKwd, &dwInputSlotFeatIndex)) == NULL)
            {
                ERR(("Input slot feature not found !!!"));
                continue;
            }

            //
            // get the number of input slots. Note that this includes the dummy "*UseFormTrayTable" slot.
            //
            dwInputSlotCount = DwCountListItem((PVOID) pInputSlotFeature->pOptions);

            if (dwInputSlotCount <= 2) // to make sense there must be at least 3 slot, incl. UseFormTrayTable+ManualFeed
            {
                ERR(("ManualFeed used - internally at least 3 input slots expected !"));
                continue;
            }

            //
            // grow the buffer for constraints. Two less than input slots because
            //      1 input slot is the dummy UseFormTrayTable slot
            //      1 input slot is the ManualFeed slot that I don't want to constraint
            //
            VGrowPackBuffer(pParserData, (dwInputSlotCount -2) * sizeof(UICONSTRAINT));

            if (dwManFeedFalsePos == 1)
            {
                //
                // add constraints to each input slot for the constrained feature
                //
                POPTIONOBJ pNextObj = pInputSlotFeature->pOptions;

                ASSERT(strcmp(pNextObj->pstrName, "*UseFormTrayTable") == EQUAL_STRING); // in case we change the logic some time later...

                //
                // since the UseFormTrayTable is the first option, start with the second
                //
                pNextObj = pNextObj->pNext;
                ASSERT(pNextObj != NULL);

                while (pNextObj)
                {
                    //
                    // skip the manual feed input slot, don't constrain that
                    //
                    if (strcmp(pNextObj->pstrName, gstrManualFeedKwd) == EQUAL_STRING)
                    {
                        pNextObj = pNextObj->pNext;
                        continue;
                    }

                    pPackedConstraint[dwConstraints].dwNextConstraint = pNextObj->dwConstraint;
                    pNextObj->dwConstraint = dwConstraints;

                    pPackedConstraint[dwConstraints].dwFeatureIndex = dwFeatureIndex;
                    pPackedConstraint[dwConstraints].dwOptionIndex = dwOptionIndex;
                    dwConstraints++;

                    pNextObj = pNextObj->pNext;
                }
            }
            else
            {
                //
                // find the option index of the manual feed slot
                //
                if (PvFindListItem(pInputSlotFeature->pOptions, gstrManualFeedKwd, &dwManFeedSlotIndex) == NULL)
                {
                    ERR(("ManualFeed slot not found among InputSlots !!!"));
                    continue;
                }

                //
                // add constraints to the affected feature for all input slots BUT the manual feed slot
                // and the UseFormTrayTable slot
                // start with slot index 1, because the first slot is always *UseFormTrayTable
                //
                for (dwSlotIndex = 1; dwSlotIndex < dwInputSlotCount; dwSlotIndex++)
                {
                    if (dwSlotIndex == dwManFeedSlotIndex)
                        continue;

                    if (pOption == NULL)
                    {
                        //
                        // OptionKeyword1 field is not present
                        //

                        pPackedConstraint[dwConstraints].dwNextConstraint = pFeature->dwConstraint;
                        pFeature->dwConstraint = dwConstraints;
                    }
                    else
                    {
                        //
                        // OptionKeyword1 field is present
                        //

                        pPackedConstraint[dwConstraints].dwNextConstraint = pOption->dwConstraint;
                        pOption->dwConstraint = dwConstraints;
                    }

                    pPackedConstraint[dwConstraints].dwFeatureIndex = dwInputSlotFeatIndex;
                    pPackedConstraint[dwConstraints].dwOptionIndex = dwSlotIndex;
                    dwConstraints++;
                }
            }

            //
            // increase the committed buffer size so additional VGrowPackBuffer calls can allocate
            // additional pages if needed for more *ManualFeed False constraints
            //
            pParserData->dwBufSize += DWORD_ALIGN((dwInputSlotCount -2) * sizeof(UICONSTRAINT));

            continue;
        } // back to the normal course of events.

        if (BFindUIConstraintFeatureOption(pParserData,
                                           achWord1,
                                           &pFeature,
                                           &dwFeatureIndex,
                                           achWord2,
                                           &pOption,
                                           &dwOptionIndex) &&
            BFindUIConstraintFeatureOption(pParserData,
                                           achWord3,
                                           &pFeature2,
                                           &dwFeatureIndex,
                                           achWord4,
                                           &pOption2,
                                           &dwOptionIndex))
        {
            VGrowPackBuffer(pParserData, sizeof(UICONSTRAINT));

            if (pOption == NULL)
            {
                //
                // OptionKeyword1 field is not present
                //

                pPackedConstraint[dwConstraints].dwNextConstraint = pFeature->dwConstraint;
                pFeature->dwConstraint = dwConstraints;
            }
            else
            {
                //
                // OptionKeyword1 field is present
                //

                pPackedConstraint[dwConstraints].dwNextConstraint = pOption->dwConstraint;
                pOption->dwConstraint = dwConstraints;
            }

            pPackedConstraint[dwConstraints].dwFeatureIndex = dwFeatureIndex;
            pPackedConstraint[dwConstraints].dwOptionIndex = dwOptionIndex;

            dwConstraints++;
            bSuccess = TRUE;

            //
            // increase the committed buffer size so additional VGrowPackBuffer calls can allocate
            // additional pages if needed for more *ManualFeed False constraints
            //
            pParserData->dwBufSize += DWORD_ALIGN(sizeof(UICONSTRAINT));

        }

        if (! bSuccess)
            SEMANTIC_ERROR(("Invalid *UIConstraints entry: %s\n", pConstraint->pstrName));
    }

    //
    // Save the packed UIConstraints information in the binary data
    //

    if (dwConstraints == 0)
    {
        pParserData->pUIInfo->UIConstraints.dwCount = 0;
        pParserData->pUIInfo->UIConstraints.loOffset = 0;
    }
    else
    {
        pParserData->pUIInfo->UIConstraints.dwCount = dwConstraints;
        pParserData->pUIInfo->UIConstraints.loOffset = dwConstraintBufStart;
    }
}



VOID
VPackOrderDependency(
    PPARSERDATA pParserData,
    PARRAYREF   parefDest,
    PLISTOBJ    pOrderDep
    )

/*++

Routine Description:

    Pack OrderDependency/QueryOrderDependency information into binary data

Arguments:

    pParserData - Points to the parser data structure
    parefDest - Stores information about where the order dependency info is packed
    pOrderDep - Specifies the list of order dependencies to be packed

Return Value:

    NONE

--*/

{
    static const STRTABLE SectionStrs[] =
    {
        { "DocumentSetup",  SECTION_DOCSETUP},
        { "AnySetup",       SECTION_ANYSETUP},
        { "PageSetup",      SECTION_PAGESETUP},
        { "Prolog",         SECTION_PROLOG},
        { "ExitServer",     SECTION_EXITSERVER},
        { "JCLSetup",       SECTION_JCLSETUP},
        { NULL,             SECTION_UNASSIGNED}
    };

    PORDERDEPEND    pPackedDep;
    PFEATUREOBJ     pFeature;
    POPTIONOBJ      pOption;
    DWORD           dwOrderDep, dwFeatures, dwIndex;
    DWORD           dwFeatureIndex, dwOptionIndex, dwSection;
    LONG            lOrder;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // The maximum number of entries we need is:
    //  number of printer features + number of order dependency entries
    //

    dwFeatures = pParserData->pInfoHdr->RawData.dwDocumentFeatures +
                 pParserData->pInfoHdr->RawData.dwPrinterFeatures;

    dwOrderDep = dwFeatures + DwCountListItem(pOrderDep);
    VGrowPackBuffer(pParserData, dwOrderDep * sizeof(ORDERDEPEND));
    pPackedDep = (PORDERDEPEND) (pParserData->pubBufStart + pParserData->dwBufSize);

    //
    // Create a default order dependency entry for each feature
    //

    for (pFeature = pParserData->pFeatures, dwFeatureIndex = 0;
        pFeature != NULL;
        pFeature = pFeature->pNext, dwFeatureIndex++)
    {
        pPackedDep[dwFeatureIndex].lOrder = MAX_ORDER_VALUE;
        pPackedDep[dwFeatureIndex].dwSection = SECTION_UNASSIGNED;
        pPackedDep[dwFeatureIndex].dwPPDSection = SECTION_UNASSIGNED;
        pPackedDep[dwFeatureIndex].dwFeatureIndex = dwFeatureIndex;
        pPackedDep[dwFeatureIndex].dwOptionIndex = OPTION_INDEX_ANY;
    }

    //
    // Interpret each order dependency entry
    //

    for (dwOrderDep = dwFeatures; pOrderDep != NULL; pOrderDep = pOrderDep->pNext)
    {
        CHAR    achWord1[MAX_WORD_LEN];
        CHAR    achWord2[MAX_WORD_LEN];
        PSTR    pstr = pOrderDep->pstrName;
        BOOL    bSuccess = FALSE;

        //
        // Each order dependency entry has the following components:
        //  order section mainKeyword [optionKeyword]
        //

        if (BGetFloatFromString(&pstr, &lOrder, FLTYPE_INT) &&
            BFindNextWord(&pstr, achWord1) &&
            BSearchStrTable(SectionStrs, achWord1, &dwSection) &&
            BFindNextWord(&pstr, achWord1))
        {
            (VOID) BFindNextWord(&pstr, achWord2);

            if (BFindUIConstraintFeatureOption(pParserData,
                                               achWord1,
                                               &pFeature,
                                               &dwFeatureIndex,
                                               achWord2,
                                               &pOption,
                                               &dwOptionIndex))
            {
                //
                // Check if an OrderDependency for the same feature/option
                // has appeared before.
                //

                for (dwIndex = 0; dwIndex < dwOrderDep; dwIndex++)
                {
                    if (pPackedDep[dwIndex].dwFeatureIndex == dwFeatureIndex &&
                        pPackedDep[dwIndex].dwOptionIndex == dwOptionIndex)
                    {
                        break;
                    }
                }

                if (dwIndex < dwOrderDep && pPackedDep[dwIndex].lOrder < MAX_ORDER_VALUE)
                {
                    TERSE(("Duplicate order dependency entry: %s\n", pOrderDep->pstrName));
                }
                else
                {
                    if (dwIndex >= dwOrderDep)
                        dwIndex = dwOrderDep++;

                    //
                    // Ensure the specified order value is less than MAX_ORDER_VALUE
                    //

                    if (lOrder >= MAX_ORDER_VALUE)
                    {
                        WARNING(("Order dependency value too big: %s\n", pOrderDep->pstrName));
                        lOrder = MAX_ORDER_VALUE - 1;
                    }

                    pPackedDep[dwIndex].dwSection = dwSection;
                    pPackedDep[dwIndex].dwPPDSection = dwSection;
                    pPackedDep[dwIndex].lOrder = lOrder;
                    pPackedDep[dwIndex].dwFeatureIndex = dwFeatureIndex;
                    pPackedDep[dwIndex].dwOptionIndex = dwOptionIndex;
                }

                bSuccess = TRUE;
            }
        }

        if (! bSuccess)
            SEMANTIC_ERROR(("Invalid order dependency: %s\n", pOrderDep->pstrName));
    }

    //
    // Tell the caller where the packed order dependency information is stored
    //

    if (dwOrderDep == 0)
    {
        parefDest->dwCount = 0;
        parefDest->loOffset = 0;
        return;
    }

    parefDest->dwCount = dwOrderDep;
    parefDest->loOffset = pParserData->dwBufSize;
    pParserData->dwBufSize += DWORD_ALIGN(dwOrderDep * sizeof(ORDERDEPEND));

    //
    // Sort order dependency information using the order value
    //

    for (dwIndex = 0; dwIndex+1 < dwOrderDep; dwIndex++)
    {
        DWORD   dwMinIndex, dwLoop;

        //
        // Nothing fancy here - straight-forward selection sort
        //

        dwMinIndex = dwIndex;

        for (dwLoop = dwIndex+1; dwLoop < dwOrderDep; dwLoop++)
        {
            if ((pPackedDep[dwLoop].lOrder < pPackedDep[dwMinIndex].lOrder) ||
                (pPackedDep[dwLoop].lOrder == pPackedDep[dwMinIndex].lOrder &&
                 pPackedDep[dwLoop].dwSection < pPackedDep[dwMinIndex].dwSection))
            {
                dwMinIndex = dwLoop;
            }
        }

        if (dwMinIndex != dwIndex)
        {
            ORDERDEPEND TempDep;

            TempDep = pPackedDep[dwIndex];
            pPackedDep[dwIndex] = pPackedDep[dwMinIndex];
            pPackedDep[dwMinIndex] = TempDep;
        }
    }

    //
    // Resolve AnySetup into either DocumentSetup or PageSetup
    //

    dwSection = SECTION_DOCSETUP;

    for (dwIndex = 0; dwIndex < dwOrderDep; dwIndex++)
    {
        if (pPackedDep[dwIndex].dwSection == SECTION_PAGESETUP)
            dwSection = SECTION_PAGESETUP;
        else if (pPackedDep[dwIndex].dwSection == SECTION_ANYSETUP)
            pPackedDep[dwIndex].dwSection = dwSection;
    }

    //
    // Maintain a linked-list of order dependency entries for each feature
    // starting with the entry whose dwOptionIndex = OPTION_INDEX_ANY.
    //

    for (dwIndex = 0; dwIndex < dwOrderDep; dwIndex++)
        pPackedDep[dwIndex].dwNextOrderDep = NULL_ORDERDEP;

    for (dwIndex = 0; dwIndex < dwOrderDep; dwIndex++)
    {
        DWORD   dwLastIndex, dwLoop;

        if (pPackedDep[dwIndex].dwOptionIndex != OPTION_INDEX_ANY)
            continue;

        dwLastIndex = dwIndex;

        for (dwLoop = 0; dwLoop < dwOrderDep; dwLoop++)
        {
            if (pPackedDep[dwLoop].dwFeatureIndex == pPackedDep[dwIndex].dwFeatureIndex &&
                pPackedDep[dwLoop].dwOptionIndex != OPTION_INDEX_ANY)
            {
                pPackedDep[dwLastIndex].dwNextOrderDep = dwLoop;
                dwLastIndex = dwLoop;
            }
        }

        pPackedDep[dwLastIndex].dwNextOrderDep = NULL_ORDERDEP;
    }

    //
    // !!!CR
    // Needs to flag out-of-order OrderDependency.
    //
}



VOID
VCountAndSortPrinterFeatures(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Count the number of doc- and printer-sticky features
    and sort them into two separate groups

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PFEATUREOBJ pFeature, pNext, pDocFeatures, pPrinterFeatures;
    DWORD       dwDocFeatures, dwPrinterFeatures;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Count the number of doc- and printer-sticky features
    //

    pDocFeatures = pPrinterFeatures = NULL;
    dwDocFeatures = dwPrinterFeatures = 0;
    pFeature = pParserData->pFeatures;

    while (pFeature != NULL)
    {
        pNext = pFeature->pNext;

        if (pFeature->bInstallable)
        {
            pFeature->pNext = pPrinterFeatures;
            pPrinterFeatures = pFeature;
            dwPrinterFeatures++;
        }
        else
        {
            pFeature->pNext = pDocFeatures;
            pDocFeatures = pFeature;
            dwDocFeatures++;
        }

        pFeature = pNext;
    }

    ASSERTMSG((dwDocFeatures + dwPrinterFeatures <= MAX_PRINTER_OPTIONS),
              ("Too many printer features.\n"));

    //
    // Rearrange the features so that all doc-sticky features
    // are in front of printer-sticky features
    //

    pFeature = NULL;

    while (pPrinterFeatures != NULL)
    {
        pNext = pPrinterFeatures->pNext;
        pPrinterFeatures->pNext = pFeature;
        pFeature = pPrinterFeatures;
        pPrinterFeatures = pNext;
    }

    while (pDocFeatures != NULL)
    {
        pNext = pDocFeatures->pNext;
        pDocFeatures->pNext = pFeature;
        pFeature = pDocFeatures;
        pDocFeatures = pNext;
    }

    pParserData->pFeatures = pFeature;
    pParserData->pInfoHdr->RawData.dwDocumentFeatures = dwDocFeatures;
    pParserData->pInfoHdr->RawData.dwPrinterFeatures = dwPrinterFeatures;
}



VOID
VProcessPrinterFeatures(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Process printer features and handle any special glitches

Arguments:

    pParserData - Points to parser data structure

Return Value:

    NONE

--*/

{
    PFEATUREOBJ pFeature;
    POPTIONOBJ  pOption;

    for (pFeature = pParserData->pFeatures; pFeature; pFeature = pFeature->pNext)
    {
        //
        // If a feature has no option but has a default specified, then
        // synthesize an option with empty invocation string.
        //

        if (pFeature->pstrDefault && pFeature->pOptions == NULL)
        {
            pOption = ALLOC_PARSER_MEM(pParserData, pFeature->dwOptionSize);

            if (pOption == NULL)
            {
                ERR(("Memory allocation failed: %d\n", GetLastError()));
                PACK_BINARY_DATA_EXCEPTION();
            }

            //
            // NOTE: it's ok for both pOption->pstrName and pFeature->pstrDefault
            // to point to the same string here. The memory is deallocated when
            // the parser heap is destroyed.
            //

            pOption->pstrName = pFeature->pstrDefault;
            pFeature->pOptions = pOption;
        }

        //
        // Special handling of *InputSlot feature
        //  Make sure the very first option is always "*UseFormTrayTable"
        //

        if (pFeature->dwFeatureID == GID_INPUTSLOT)
        {
            pOption = ALLOC_PARSER_MEM(pParserData, pFeature->dwOptionSize);

            if (pOption == NULL)
            {
                ERR(("Memory allocation failed: %d\n", GetLastError()));
                PACK_BINARY_DATA_EXCEPTION();
            }

            pOption->pstrName = "*UseFormTrayTable";
            pOption->pNext = pFeature->pOptions;
            pFeature->pOptions = pOption;

            ((PTRAYOBJ) pOption)->dwTrayIndex = DMBIN_FORMSOURCE;
        }
    }
}



VOID
VPackPrinterFeatures(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack printer feature and option information into binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PFEATUREOBJ pFeature;
    PFEATURE    pPackedFeature;
    POPTIONOBJ  pOption;
    POPTION     pPackedOption;
    DWORD       dwFeatureIndex, dwOptionIndex, dwCount;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Reserve space in the binary data for an array of FEATURE structures
    //

    dwCount = pParserData->pInfoHdr->RawData.dwDocumentFeatures +
              pParserData->pInfoHdr->RawData.dwPrinterFeatures;

    VGrowPackBuffer(pParserData, dwCount * sizeof(FEATURE));
    pPackedFeature = (PFEATURE) (pParserData->pubBufStart + pParserData->dwBufSize);
    pParserData->pUIInfo->loFeatureList = pParserData->dwBufSize;
    pParserData->dwBufSize += DWORD_ALIGN(dwCount * sizeof(FEATURE));

    for (pFeature = pParserData->pFeatures, dwFeatureIndex = 0;
        pFeature != NULL;
        pFeature = pFeature->pNext, dwFeatureIndex++, pPackedFeature++)
    {
        PFEATUREDATA    pFeatureData;

        //
        // Pack feature information
        //

        VPackStringAnsi(pParserData, &pPackedFeature->loKeywordName, pFeature->pstrName);

        VPackStringXlation(pParserData,
                           &pPackedFeature->loDisplayName,
                           pFeature->pstrName,
                           &pFeature->Translation);

        VPackInvocation(pParserData, &pPackedFeature->QueryInvocation, &pFeature->QueryInvoc);

        pFeatureData = PGetFeatureData(pFeature->dwFeatureID);
        pPackedFeature->dwFlags = pFeatureData->dwFlags;
        pPackedFeature->dwOptionSize = pFeatureData->dwOptionSize;
        pPackedFeature->dwFeatureID = pFeature->dwFeatureID;
        pPackedFeature->dwUIType = pFeature->dwUIType;
        pPackedFeature->dwUIConstraintList = pFeature->dwConstraint;
        pPackedFeature->dwNoneFalseOptIndex = OPTION_INDEX_ANY;

        if (pFeature->bInstallable)
        {
            pPackedFeature->dwPriority = pFeatureData->dwPriority + PRNPROP_BASE_PRIORITY;
            pPackedFeature->dwFeatureType = FEATURETYPE_PRINTERPROPERTY;
        }
        else
        {
            ASSERT(pFeatureData->dwPriority < PRNPROP_BASE_PRIORITY);
            pPackedFeature->dwPriority = pFeatureData->dwPriority;
            pPackedFeature->dwFeatureType = FEATURETYPE_DOCPROPERTY;
        }

        //
        // For non-PickMany features, use the very first option as the default
        // if none is explicitly specified. Otherwise, default to OPTION_INDEX_ANY.
        //

        pPackedFeature->dwDefaultOptIndex =
        (pFeature->dwUIType == UITYPE_PICKMANY) ? OPTION_INDEX_ANY : 0;

        //
        // If this feature is a predefined feature, save a reference to it
        //

        if (pFeature->dwFeatureID < MAX_GID)
        {
            pParserData->pUIInfo->aloPredefinedFeatures[pFeature->dwFeatureID] =
            pParserData->pUIInfo->loFeatureList + (dwFeatureIndex * sizeof(FEATURE));
        }

        //
        // Reserve space in the binary data for an array of OPTION structures
        //

        if ((dwCount = DwCountListItem(pFeature->pOptions)) == 0)
        {
            TERSE(("No options for feature: %s\n", pFeature->pstrName));
            pPackedFeature->Options.loOffset = 0;
            pPackedFeature->Options.dwCount = 0;
            continue;
        }

        ASSERTMSG((dwCount < OPTION_INDEX_ANY),
                  ("Too many options for feature: %s\n", pFeature->pstrName));

        VGrowPackBuffer(pParserData, dwCount * pFeatureData->dwOptionSize);
        pPackedOption = (POPTION) (pParserData->pubBufStart + pParserData->dwBufSize);
        pPackedFeature->Options.loOffset = pParserData->dwBufSize;
        pPackedFeature->Options.dwCount = dwCount;
        pParserData->dwBufSize += DWORD_ALIGN(dwCount * pFeatureData->dwOptionSize);

        for (pOption = pFeature->pOptions, dwOptionIndex = 0;
            pOption != NULL;
            pOption = pOption->pNext, dwOptionIndex++)
        {
            BOOL bIsDefaultOption = FALSE; // TRUE if current option is default

            //
            // Pack option information
            //

            VPackStringAnsi(pParserData,
                            &pPackedOption->loKeywordName,
                            pOption->pstrName);

            VPackStringXlation(pParserData,
                               &pPackedOption->loDisplayName,
                               pOption->pstrName,
                               &pOption->Translation);

            VPackInvocation(pParserData,
                            &pPackedOption->Invocation,
                            &pOption->Invocation);

            pPackedOption->dwUIConstraintList = pOption->dwConstraint;

            //
            // Check if the current option is the default option
            // or if it's the None/False option
            //

            if (pFeature->pstrDefault &&
                strcmp(pOption->pstrName, pFeature->pstrDefault) == EQUAL_STRING)
            {
                pPackedFeature->dwDefaultOptIndex = dwOptionIndex;
                bIsDefaultOption = TRUE;
            }

            if (strcmp(pOption->pstrName, gstrNoneKwd) == EQUAL_STRING ||
                strcmp(pOption->pstrName, gstrFalseKwd) == EQUAL_STRING)
            {
                pPackedFeature->dwNoneFalseOptIndex = dwOptionIndex;
            }

            //
            // Handle extra fields after the generic OPTION structure
            //

            switch (pFeature->dwFeatureID)
            {
            case GID_PAGESIZE:

                {
                    PPAGESIZE   pPageSize = (PPAGESIZE) pPackedOption;
                    PPAPEROBJ   pPaper = (PPAPEROBJ) pOption;
                    PRECT       prect;
                    PSIZE       psize;

                    if (strcmp(pOption->pstrName, gstrCustomSizeKwd) == EQUAL_STRING)
                    {
                        PPPDDATA    pPpdData;
                        LONG        lMax;

                        //
                        // Special case for CustomPageSize option
                        //

                        pPpdData = pParserData->pPpdData;
                        psize = &pPageSize->szPaperSize;
                        prect = &pPageSize->rcImgArea;

                        pPageSize->szPaperSize = pPaper->szDimension;
                        pPageSize->rcImgArea = pPaper->rcImageArea;
                        pPageSize->dwPaperSizeID = DMPAPER_CUSTOMSIZE;

                        VPackStringRsrc(pParserData,
                                        &pPackedOption->loDisplayName,
                                        IDS_PSCRIPT_CUSTOMSIZE);

                        //
                        // If either MaxMediaWidth or MaxMediaHeight is missing,
                        // we'll use the max width or height values from
                        // ParamCustomPageSize.
                        //

                        if (psize->cx <= 0)
                            psize->cx = MAXCUSTOMPARAM_WIDTH(pPpdData);

                        if (psize->cy <= 0)
                            psize->cy = MAXCUSTOMPARAM_HEIGHT(pPpdData);

                        if (psize->cx > 0 &&
                            psize->cy > 0 &&
                            MINCUSTOMPARAM_ORIENTATION(pPpdData) <= 3)
                        {
                            pParserData->pUIInfo->dwFlags |= FLAG_CUSTOMSIZE_SUPPORT;
                            pParserData->pUIInfo->dwCustomSizeOptIndex = dwOptionIndex;

                            //
                            // Make sure the hardware margins are not larger than
                            // the maximum media width or height.
                            //
                            // This is only significant for cut-sheet device.
                            //

                            if (pParserData->dwCustomSizeFlags & CUSTOMSIZE_CUTSHEET)
                            {
                                lMax = min(psize->cx, psize->cy);

                                if (prect->left < 0 || prect->left >= lMax)
                                    prect->left = 0;

                                if (prect->right < 0 || prect->right >= lMax)
                                    prect->right = 0;

                                if (prect->top < 0 || prect->top >= lMax)
                                    prect->top = 0;

                                if (prect->bottom < 0 || prect->bottom >= lMax)
                                    prect->bottom = 0;
                            }

                            //
                            // Validate custom page size parameters
                            //

                            if (MAXCUSTOMPARAM_WIDTH(pPpdData) > psize->cx)
                                MAXCUSTOMPARAM_WIDTH(pPpdData) = psize->cx;

                            if (MINCUSTOMPARAM_WIDTH(pPpdData) <= MICRONS_PER_INCH)
                                MINCUSTOMPARAM_WIDTH(pPpdData) = MICRONS_PER_INCH;

                            if (MAXCUSTOMPARAM_HEIGHT(pPpdData) > psize->cy)
                                MAXCUSTOMPARAM_HEIGHT(pPpdData) = psize->cy;

                            if (MINCUSTOMPARAM_HEIGHT(pPpdData) <= MICRONS_PER_INCH)
                                MINCUSTOMPARAM_HEIGHT(pPpdData) = MICRONS_PER_INCH;
                        }
                    }
                    else
                    {
                        psize = &pPaper->szDimension;
                        prect = &pPaper->rcImageArea;

                        if (strcmp(pOption->pstrName, gstrLetterSizeKwd) == EQUAL_STRING)
                        {
                            if ((abs(psize->cx - LETTER_PAPER_WIDTH) < 1000) &&
                                (abs(psize->cy - LETTER_PAPER_LENGTH) < 1000))
                            {
                                pParserData->pUIInfo->dwFlags |= FLAG_LETTER_SIZE_EXISTS;
                            }
                        }
                        else if (strcmp(pOption->pstrName, gstrA4SizeKwd) == EQUAL_STRING)
                        {
                            if ((abs(psize->cx - A4_PAPER_WIDTH) < 1000) &&
                                (abs(psize->cy - A4_PAPER_LENGTH) < 1000))
                            {
                                pParserData->pUIInfo->dwFlags |= FLAG_A4_SIZE_EXISTS;
                            }
                        }

                        //
                        // Verify paper dimension
                        //

                        if (psize->cx <= 0 || psize->cy <= 0)
                        {
                            SEMANTIC_ERROR(("Invalid PaperDimension for: %s\n",
                                            pOption->pstrName));

                            psize->cx = DEFAULT_PAPER_WIDTH;
                            psize->cy = DEFAULT_PAPER_LENGTH;
                        }

                        pPageSize->szPaperSize = pPaper->szDimension;

                        //
                        // Verify imageable area
                        //

                        if (prect->left < 0 || prect->left >= prect->right ||
                            prect->bottom < 0|| prect->bottom >= prect->top ||
                            prect->right > psize->cx ||
                            prect->top > psize->cy)
                        {
                            SEMANTIC_ERROR(("Invalid ImageableArea for: %s\n",
                                            pOption->pstrName));

                            prect->left = prect->bottom = 0;
                            prect->right = psize->cx;
                            prect->top = psize->cy;
                        }

                        //
                        // Convert from PS to GDI coordinate system
                        //

                        pPageSize->rcImgArea.left = prect->left;
                        pPageSize->rcImgArea.right = prect->right;
                        pPageSize->rcImgArea.top = psize->cy - prect->top;
                        pPageSize->rcImgArea.bottom = psize->cy - prect->bottom;

                        //
                        // Driver paper size ID starts at DRIVER_PAPERSIZE_ID
                        //

                        pPageSize->dwPaperSizeID = dwOptionIndex + DRIVER_PAPERSIZE_ID;
                    }
                }

                break;

            case GID_RESOLUTION:

                {
                    PRESOLUTION pResolution = (PRESOLUTION) pPackedOption;
                    PRESOBJ     pResObj = (PRESOBJ) pOption;
                    PSTR        pstr = pOption->pstrName;
                    LONG        lXdpi, lYdpi;
                    BOOL        bValid;

                    pResolution->iXdpi = pResolution->iYdpi = DEFAULT_RESOLUTION;
                    pResolution->fxScreenFreq = pResObj->fxScreenFreq;
                    pResolution->fxScreenAngle = pResObj->fxScreenAngle;

                    if (BGetIntegerFromString(&pstr, &lXdpi))
                    {
                        lYdpi = lXdpi;

                        while (*pstr && !IS_DIGIT(*pstr))
                            pstr++;

                        if ((*pstr == NUL || BGetIntegerFromString(&pstr, &lYdpi)) &&
                            (lXdpi > 0 && lXdpi <= MAX_SHORT) &&
                            (lYdpi > 0 && lYdpi <= MAX_SHORT))
                        {
                            pResolution->iXdpi = (INT) lXdpi;
                            pResolution->iYdpi = (INT) lYdpi;
                            bValid = TRUE;
                        }
                    }

                    if (! bValid)
                        SEMANTIC_ERROR(("Invalid resolution option: %s\n", pOption->pstrName));
                }
                break;

            case GID_DUPLEX:

                {
                    PDUPLEX pDuplex = (PDUPLEX) pPackedOption;

                    if (strcmp(pOption->pstrName, gstrDuplexTumble) == EQUAL_STRING)
                    {
                        //
                        // Horizontal == ShortEdge == Tumble
                        //

                        pDuplex->dwDuplexID = DMDUP_HORIZONTAL;
                    }
                    else if (strcmp(pOption->pstrName, gstrDuplexNoTumble) == EQUAL_STRING)
                    {
                        //
                        // Vertical == LongEdge == NoTumble
                        //

                        pDuplex->dwDuplexID = DMDUP_VERTICAL;
                    }
                    else
                        pDuplex->dwDuplexID = DMDUP_SIMPLEX;
                }
                break;

            case GID_COLLATE:

                {
                    PCOLLATE pCollate = (PCOLLATE) pPackedOption;

                    pCollate->dwCollateID =
                    (strcmp(pOption->pstrName, gstrTrueKwd) == EQUAL_STRING ||
                     strcmp(pOption->pstrName, gstrOnKwd) == EQUAL_STRING) ?
                    DMCOLLATE_TRUE :
                    DMCOLLATE_FALSE;
                }
                break;

            case GID_MEDIATYPE:

                ((PMEDIATYPE) pPackedOption)->dwMediaTypeID = dwOptionIndex + DMMEDIA_USER;
                break;

            case GID_INPUTSLOT:

                {
                    PINPUTSLOT  pInputSlot = (PINPUTSLOT) pPackedOption;
                    PTRAYOBJ    pTray = (PTRAYOBJ) pOption;
                    DWORD       dwReqPageRgn;

                    if ((dwReqPageRgn = pTray->dwReqPageRgn) == REQRGN_UNKNOWN)
                        dwReqPageRgn = pParserData->dwReqPageRgn;

                    if (dwReqPageRgn != REQRGN_FALSE)
                        pInputSlot->dwFlags |= INPUTSLOT_REQ_PAGERGN;

                    //
                    // Special handling of predefined input slots:
                    //  ManualFeed and AutoSelect
                    //

                    switch (pTray->dwTrayIndex)
                    {
                    case DMBIN_FORMSOURCE:

                        pInputSlot->dwPaperSourceID = pTray->dwTrayIndex;
                        break;

                    case DMBIN_MANUAL:

                        pInputSlot->dwPaperSourceID = pTray->dwTrayIndex;

                        VPackStringRsrc(pParserData,
                                        &pPackedOption->loDisplayName,
                                        IDS_TRAY_MANUALFEED);
                        break;

                    default:

                        pInputSlot->dwPaperSourceID = dwOptionIndex + DMBIN_USER;
                        break;
                    }
                }
                break;

            case GID_OUTPUTBIN:

                {
                    PBINOBJ pBinObj = (PBINOBJ) pOption;

                    //
                    // if this is the default bin, set the default output order, if specified
                    // by the DefaultOutputOrder entry in the PPD-file
                    //

                    if (bIsDefaultOption && pParserData->bDefOutputOrderSet)
                    {
                        //
                        // If multiple bins: warn if different options specified
                        //

                        if ((dwCount > 1) &&
                            (pBinObj->bReversePrint != pParserData->bDefReversePrint))
                        {
                            TERSE(("Warning: explicit *DefaultPageOrder overwrites PageStackOrder of OutputBin\n"));
                        }


                        ((POUTPUTBIN) pPackedOption)->bOutputOrderReversed = pParserData->bDefReversePrint;
                    }
                    else
                    {
                        //
                        // for non-default bins, the default output order has no effect - the PPD spec says
                        // "*DefaultOutputOrder indicates the default stacking order of the default output bin."
                        //

                        ((POUTPUTBIN) pPackedOption)->bOutputOrderReversed = pBinObj->bReversePrint;
                    }
                }

                break;

            case GID_MEMOPTION:

                {
                    PMEMOPTION  pMemOption = (PMEMOPTION) pPackedOption;
                    PMEMOBJ     pMemObj = (PMEMOBJ) pOption;
                    DWORD       dwMinFreeMem;

                    //
                    // Store PPD's original *VMOption value into dwInstalledMem.
                    // This is only used for the new PPD helper function GetOptionAttribute().
                    // (see comments in inc\parser.h)
                    //

                    pMemOption->dwInstalledMem = pMemObj->dwFreeVM;

                    dwMinFreeMem = pParserData->dwLangLevel <= 1 ? MIN_FREEMEM_L1 : MIN_FREEMEM_L2;
                    if (pMemObj->dwFreeVM < dwMinFreeMem)
                    {
                        SEMANTIC_ERROR(("Invalid memory option: %s\n", pOption->pstrName));
                        pMemObj->dwFreeVM = dwMinFreeMem;
                    }

                    pMemOption->dwFreeMem = pMemObj->dwFreeVM;
                    pMemOption->dwFreeFontMem = pMemObj->dwFontMem;
                }
                break;

            case GID_LEADINGEDGE:

                if (strcmp(pOption->pstrName, gstrLongKwd) == EQUAL_STRING)
                {
                    pParserData->pPpdData->dwLeadingEdgeLong = dwOptionIndex;

                    if (dwOptionIndex == pPackedFeature->dwDefaultOptIndex)
                        pParserData->pPpdData->dwCustomSizeFlags &= ~CUSTOMSIZE_SHORTEDGEFEED;
                }
                else if (strcmp(pOption->pstrName, gstrShortKwd) == EQUAL_STRING)
                {
                    pParserData->pPpdData->dwLeadingEdgeShort = dwOptionIndex;

                    if (dwOptionIndex == pPackedFeature->dwDefaultOptIndex)
                        pParserData->pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_SHORTEDGEFEED;
                }

                break;

            case GID_USEHWMARGINS:

                if (strcmp(pOption->pstrName, gstrTrueKwd) == EQUAL_STRING)
                {
                    pParserData->pPpdData->dwUseHWMarginsTrue = dwOptionIndex;
                    pParserData->pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_CUTSHEET;

                    if (dwOptionIndex == pPackedFeature->dwDefaultOptIndex)
                        pParserData->pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_DEFAULTCUTSHEET;
                }
                else if (strcmp(pOption->pstrName, gstrFalseKwd) == EQUAL_STRING)
                {
                    pParserData->pPpdData->dwUseHWMarginsFalse = dwOptionIndex;
                    pParserData->pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_ROLLFED;

                    if (dwOptionIndex == pPackedFeature->dwDefaultOptIndex)
                        pParserData->pPpdData->dwCustomSizeFlags &= ~CUSTOMSIZE_DEFAULTCUTSHEET;
                }
                break;
            }

            pPackedOption = (POPTION) ((PBYTE) pPackedOption + pFeatureData->dwOptionSize);
        }
    }
}



VOID
VPackNt4Mapping(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack NT4 feature index mapping information

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PPPDDATA    pPpdData;
    PFEATURE    pPackedFeatures;
    PBYTE       pubNt4Mapping;
    DWORD       dwCount, dwIndex, dwNt4Index;
    INT         iInputSlotIndex;
    BYTE        ubInputSlotOld, ubInputSlotNew;

    pPpdData = pParserData->pPpdData;
    pPpdData->dwNt4Checksum = pParserData->wNt4Checksum;
    pPpdData->dwNt4DocFeatures = pParserData->pUIInfo->dwDocumentFeatures;
    pPpdData->dwNt4PrnFeatures = pParserData->pUIInfo->dwPrinterFeatures;

    iInputSlotIndex = -1;
    ubInputSlotNew = 0xff;

    if (pParserData->iDefInstallMemIndex >= 0)
        pParserData->iDefInstallMemIndex += pPpdData->dwNt4DocFeatures;

    dwCount = pPpdData->dwNt4DocFeatures + pPpdData->dwNt4PrnFeatures;
    pPpdData->Nt4Mapping.dwCount = dwCount;

    VGrowPackBuffer(pParserData, dwCount * sizeof(BYTE));
    pubNt4Mapping = (PBYTE) (pParserData->pubBufStart + pParserData->dwBufSize);
    pPpdData->Nt4Mapping.loOffset = pParserData->dwBufSize;
    pParserData->dwBufSize += DWORD_ALIGN(dwCount * sizeof(BYTE));

    pPackedFeatures = (PFEATURE) (pParserData->pubBufStart + pParserData->pUIInfo->loFeatureList);

    for (dwIndex=dwNt4Index=0; dwIndex <= dwCount; dwIndex++)
    {
        BOOL    bMapped = TRUE;

        //
        // ManualFeed used to be a feature in NT4,
        // but not anymore in NT5
        //

        if (pParserData->iReqPageRgnIndex == (INT) dwIndex)
            ubInputSlotNew = (BYTE) dwNt4Index;

        if (pParserData->iManualFeedIndex == (INT) dwIndex)
        {
            pPpdData->dwNt4DocFeatures++;
            dwNt4Index++;
        }

        //
        // DefaultInstalledMemory causes a bogus feature to be added on NT4
        //

        if (pParserData->iDefInstallMemIndex == (INT) dwIndex)
        {
            pPpdData->dwNt4PrnFeatures++;
            dwNt4Index++;
        }

        if (dwIndex == dwCount)
            break;

        switch (pPackedFeatures[dwIndex].dwFeatureID)
        {
        case GID_MEDIATYPE:
        case GID_OUTPUTBIN:

            // a feature in NT4 only if within Open/CloseUI

            if (pParserData->aubOpenUIFeature[pPackedFeatures[dwIndex].dwFeatureID])
                break;

            // fall through

        case GID_PAGEREGION:
        case GID_LEADINGEDGE:
        case GID_USEHWMARGINS:

            // not a feature in NT4

            bMapped = FALSE;
            break;

        case GID_INPUTSLOT:

            iInputSlotIndex = dwIndex;
            break;
        }

        if (bMapped)
        {
            pubNt4Mapping[dwIndex] = (BYTE) dwNt4Index;
            dwNt4Index++;
        }
        else
        {
            pPpdData->dwNt4DocFeatures--;
            pubNt4Mapping[dwIndex] = 0xff;
        }
    }

    //
    // RequiresPageRegion causes InputSlot feature to be created on NT4
    //

    if (iInputSlotIndex >= 0 && pParserData->iReqPageRgnIndex >= 0)
    {
        ubInputSlotOld = pubNt4Mapping[iInputSlotIndex];

        if (ubInputSlotOld > ubInputSlotNew)
        {
            for (dwIndex=0; dwIndex < dwCount; dwIndex++)
            {
                if (pubNt4Mapping[dwIndex] >= ubInputSlotNew &&
                    pubNt4Mapping[dwIndex] <  ubInputSlotOld)
                {
                    pubNt4Mapping[dwIndex]++;
                }
            }
        }
        else if (ubInputSlotOld < ubInputSlotNew)
        {
            for (dwIndex=0; dwIndex < dwCount; dwIndex++)
            {
                if (pubNt4Mapping[dwIndex] >  ubInputSlotOld &&
                    pubNt4Mapping[dwIndex] <= ubInputSlotNew)
                {
                    pubNt4Mapping[dwIndex]--;
                }
            }
        }

        pubNt4Mapping[iInputSlotIndex] = ubInputSlotNew;
    }
}



VOID
VPackDeviceFonts(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack device font information into binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PDEVFONT    pDevFont;
    PFONTREC    pFontObj;
    DWORD       dwIndex, dwFonts;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Count the number of device fonts and
    // reserve enough space in the packed binary data
    //

    if ((dwFonts = DwCountListItem(pParserData->pFonts)) == 0)
        return;

    VGrowPackBuffer(pParserData, dwFonts * sizeof(DEVFONT));
    pParserData->pPpdData->DeviceFonts.dwCount = dwFonts;
    pParserData->pPpdData->DeviceFonts.loOffset = pParserData->dwBufSize;

    pDevFont = (PDEVFONT) (pParserData->pubBufStart + pParserData->dwBufSize);
    pParserData->dwBufSize += DWORD_ALIGN(dwFonts * sizeof(DEVFONT));

    //
    // Pack information about each device font
    //

    for (pFontObj = pParserData->pFonts;
        pFontObj != NULL;
        pFontObj = pFontObj->pNext)
    {
        VPackStringAnsi(pParserData, &pDevFont->loFontName, pFontObj->pstrName);

        VPackStringXlation(pParserData,
                           &pDevFont->loDisplayName,
                           pFontObj->pstrName,
                           &pFontObj->Translation);

        VPackStringAnsi(pParserData, &pDevFont->loEncoding, pFontObj->pstrEncoding);
        VPackStringAnsi(pParserData, &pDevFont->loCharset, pFontObj->pstrCharset);
        VPackStringAnsi(pParserData, &pDevFont->loVersion, pFontObj->pstrVersion);

        pDevFont->dwStatus = pFontObj->dwStatus;
        pDevFont++;
    }

    //
    // Calculate the byte-offset to the default DEVFONT structure (if any)
    //

    if (pParserData->pstrDefaultFont &&
        PvFindListItem(pParserData->pFonts, pParserData->pstrDefaultFont, &dwIndex))
    {
        pParserData->pPpdData->loDefaultFont = pParserData->pPpdData->DeviceFonts.loOffset +
                                               (dwIndex * sizeof(DEVFONT));
    }
}



VOID
VPackJobPatchFiles(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack *JobPatchFile information into binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PJOBPATCHFILE     pPackedPatch;
    PJOBPATCHFILEOBJ  pJobPatchFile;
    DWORD             dwJobPatchFiles;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Count the number of *JobPatchFile entries
    //

    dwJobPatchFiles = DwCountListItem((PVOID) pParserData->pJobPatchFiles);

    if (dwJobPatchFiles > 0)
    {
        //
        // Reserve enough space in the packed binary data
        //

        VGrowPackBuffer(pParserData, dwJobPatchFiles * sizeof(JOBPATCHFILE));
        pParserData->pPpdData->JobPatchFiles.dwCount = dwJobPatchFiles;
        pParserData->pPpdData->JobPatchFiles.loOffset = pParserData->dwBufSize;

        pPackedPatch = (PJOBPATCHFILE) (pParserData->pubBufStart + pParserData->dwBufSize);
        pParserData->dwBufSize += DWORD_ALIGN(dwJobPatchFiles * sizeof(JOBPATCHFILE));

        //
        // Pack each *JobPatchFile invocation string
        //

        for (pJobPatchFile = pParserData->pJobPatchFiles;
            pJobPatchFile != NULL;
            pJobPatchFile = pJobPatchFile->pNext)
        {
            VPackPatch(pParserData, pPackedPatch, pJobPatchFile);
            pPackedPatch++;
        }
    }
}



typedef struct _TTFSUBSTRESINFO
{
    BOOL bCJK;
    WORD wIDBegin;
    WORD wIDEnd;
}
TTFSUBSTRESINFO;

static TTFSUBSTRESINFO TTFSubstResInfo[] =
{
    { FALSE, IDS_1252_BEGIN, IDS_1252_END},
    { TRUE,  IDS_932_BEGIN,  IDS_932_END},
    { TRUE,  IDS_936_BEGIN,  IDS_936_END},
    { TRUE,  IDS_949_BEGIN,  IDS_949_END},
};



VOID
VPackDefaultTrueTypeSubstTable(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack the default TrueType font substitution table into the binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

#define MAX_FONT_NAME   256

{
    INT     iNumInfo, iInfo, iCount, iLenTT, iLenPS, i;
    DWORD   dwSize, dwLeft, dw;
    TCHAR   tchBuf[MAX_FONT_NAME];
    PTSTR   ptstrTable;
    HRSRC   hrRcData;
    HGLOBAL hgRcData;
    PWORD   pwRcData;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Calculate how much memory we need to hold the default TrueType to
    // PostScript substitution names. The counter is initialized to 1, instead
    // of 0, for the last NUL terminator. Count the names from the STRING
    // resource, then from RCDATA resource.
    //
    //
    dwSize = 1;

    iNumInfo = sizeof(TTFSubstResInfo) / sizeof(TTFSUBSTRESINFO);

    for (iInfo = 0; iInfo < iNumInfo; iInfo++)
    {
        iCount = TTFSubstResInfo[iInfo].wIDEnd - TTFSubstResInfo[iInfo].wIDBegin + 1;

        for (i = 0; i < iCount; i++)
        {
            iLenTT = LoadString(ghInstance,
                                TTFSubstResInfo[iInfo].wIDBegin + i,
                                tchBuf, MAX_FONT_NAME);

            if (iLenTT == 0)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load TT string failed: %d\n", GetLastError()));
                return;
            }

            iLenPS = LoadString(ghInstance,
                                TTFSubstResInfo[iInfo].wIDBegin + i + TT2PS_INTERVAL,
                                tchBuf, MAX_FONT_NAME);

            if (iLenPS == 0)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load PS string failed: %d\n", GetLastError()));
                return;
            }

            dwSize += (iLenTT + 1) + (iLenPS + 1);

            if (TTFSubstResInfo[iInfo].bCJK == TRUE)
            {
                // We need names beginning with '@' too for CJK.
                dwSize += (1 + iLenTT + 1) + (1 + iLenPS + 1);
            }
        }

        if (TTFSubstResInfo[iInfo].bCJK == TRUE)
        {
            hrRcData = FindResource(ghInstance, (LPCTSTR)TTFSubstResInfo[iInfo].wIDBegin, RT_RCDATA);
            if (hrRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: find RCDATA failed: %d\n", GetLastError()));
                return;
            }

            // Load the resource and get its size.
            hgRcData = LoadResource(ghInstance, hrRcData);
            if (hgRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load RCDATA failed: %d\n", GetLastError()));
                return;
            }

            // The first WORD of the IDR resource tells the size of the strings.
            pwRcData = (PWORD)LockResource(hgRcData);
            if (pwRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: lock RCDATA failed: %d\n", GetLastError()));
                return;
            }

            dw = *pwRcData;
            if (dw % 2)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: RCDATA size is odd.\n"));
                return;
            }

            dwSize += dw / 2;
        }
    }

    //
    // Reserve enough space in the packed binary data
    //

    dwSize *= sizeof(TCHAR);

    VGrowPackBuffer(pParserData, dwSize);
    ptstrTable = (PTSTR) (pParserData->pubBufStart + pParserData->dwBufSize);

    pParserData->pUIInfo->loFontSubstTable = pParserData->dwBufSize;
    pParserData->pUIInfo->dwFontSubCount = dwSize;
    pParserData->dwBufSize += DWORD_ALIGN(dwSize);

    //
    // Save the default substitution table in the binary data
    //

    dwLeft = dwSize;

    for (iInfo = 0; iInfo < iNumInfo; iInfo++)
    {
        iCount = TTFSubstResInfo[iInfo].wIDEnd - TTFSubstResInfo[iInfo].wIDBegin + 1;

        for (i = 0; i < iCount; i++)
        {
            iLenTT = LoadString(ghInstance,
                                TTFSubstResInfo[iInfo].wIDBegin + i,
                                ptstrTable, dwLeft);

            if (iLenTT == 0)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load TT string failed: %d\n", GetLastError()));
                goto fail_cleanup;
            }

            ptstrTable += iLenTT + 1;
            dwLeft -= (iLenTT + 1) * sizeof (TCHAR);

            iLenPS = LoadString(ghInstance,
                                TTFSubstResInfo[iInfo].wIDBegin + i + TT2PS_INTERVAL,
                                ptstrTable, dwLeft);

            if (iLenPS == 0)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load PS string failed: %d\n", GetLastError()));
                goto fail_cleanup;
            }

            ptstrTable += iLenPS + 1;
            dwLeft -= (iLenPS + 1) * sizeof (TCHAR);

            if (TTFSubstResInfo[iInfo].bCJK == TRUE)
            {
                // We need names beginning with '@' too for CJK.

                *ptstrTable++ = L'@';
                dwLeft -= sizeof (TCHAR);

                if (!LoadString(ghInstance, TTFSubstResInfo[iInfo].wIDBegin + i,
                                ptstrTable, dwLeft))
                {
                    ERR(("VPackDefaultTrueTypeSubstTable: load TT string failed: %d\n", GetLastError()));
                    goto fail_cleanup;
                }

                ptstrTable += iLenTT + 1;
                dwLeft -= (iLenTT + 1) * sizeof (TCHAR);

                *ptstrTable++ = L'@';
                dwLeft -= sizeof (TCHAR);

                if (!LoadString(ghInstance, TTFSubstResInfo[iInfo].wIDBegin + i + TT2PS_INTERVAL,
                                ptstrTable, dwLeft))
                {
                    ERR(("VPackDefaultTrueTypeSubstTable: load PS string failed: %d\n", GetLastError()));
                    goto fail_cleanup;
                }

                ptstrTable += iLenPS + 1;
                dwLeft -= (iLenPS + 1) * sizeof (TCHAR);
            }
        }

        if (TTFSubstResInfo[iInfo].bCJK == TRUE)
        {
            hrRcData = FindResource(ghInstance, (LPCTSTR)TTFSubstResInfo[iInfo].wIDBegin, RT_RCDATA);
            if (hrRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: find RCDATA failed: %d\n", GetLastError()));
                goto fail_cleanup;
            }

            hgRcData = LoadResource(ghInstance, hrRcData);
            if (hgRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: load RCDATA failed: %d\n", GetLastError()));
                goto fail_cleanup;
            }

            pwRcData = (PWORD)LockResource(hgRcData);
            if (pwRcData == NULL)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: lock RCDATA failed: %d\n", GetLastError()));
                goto fail_cleanup;
            }

            dw = *pwRcData++;
            if (dw % 2)
            {
                ERR(("VPackDefaultTrueTypeSubstTable: RCDATA size is odd.\n"));
                goto fail_cleanup;
            }

            memcpy(ptstrTable, pwRcData, dw);

            ptstrTable += dw / 2;
            dwLeft -= dw;
        }
    }

    //
    // Succeed
    //

    return;

    //
    // Fail
    //

    fail_cleanup:

    pParserData->pUIInfo->loFontSubstTable = 0;
    pParserData->pUIInfo->dwFontSubCount = 0;
}



VOID
VPackTrueTypeSubstTable(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack the TrueType font substitution table into the binary data

Arguments:

    pParserData - Points to the parser data structure

Return Value:

    NONE

--*/

{
    PTTFONTSUB  pTTFontSub;
    DWORD       dwSize;
    PTSTR       ptstrTable, ptstrStart;

    //
    // Figure out how much space we'll need to store the font substitution table.
    // This is an estimate and may be a little higher than what we actually need.
    //

    ASSERT(pParserData->pTTFontSubs != NULL);

    for (pTTFontSub = pParserData->pTTFontSubs, dwSize = 1;
        pTTFontSub != NULL;
        pTTFontSub = pTTFontSub->pNext)
    {
        if (pTTFontSub->Translation.dwLength)
            dwSize += pTTFontSub->Translation.dwLength + 1;
        else
            dwSize += strlen(pTTFontSub->pstrName) + 1;

        dwSize += pTTFontSub->PSName.dwLength + 1;
    }

    //
    // Reserve enough space in the packed binary data
    //

    dwSize *= sizeof(TCHAR);
    VGrowPackBuffer(pParserData, dwSize);
    ptstrStart = ptstrTable = (PTSTR) (pParserData->pubBufStart + pParserData->dwBufSize);
    pParserData->pUIInfo->loFontSubstTable = pParserData->dwBufSize;
    pParserData->dwBufSize += DWORD_ALIGN(dwSize);

    for (pTTFontSub = pParserData->pTTFontSubs;
        pTTFontSub != NULL;
        pTTFontSub = pTTFontSub->pNext)
    {
        INT iChars;

        //
        // TrueType font family name
        //

        if (pTTFontSub->Translation.dwLength)
        {
            iChars = ITranslateToUnicodeString(
                                              ptstrTable,
                                              pTTFontSub->Translation.pvData,
                                              pTTFontSub->Translation.dwLength,
                                              pParserData->uCodePage);
        }
        else
        {
            iChars = ITranslateToUnicodeString(
                                              ptstrTable,
                                              pTTFontSub->pstrName,
                                              strlen(pTTFontSub->pstrName),
                                              1252);

        }

        if (iChars <= 0)
            break;

        ptstrTable += iChars + 1;

        //
        // PS font family name
        //

        iChars = ITranslateToUnicodeString(
                                          ptstrTable,
                                          pTTFontSub->PSName.pvData,
                                          pTTFontSub->PSName.dwLength,
                                          pParserData->uCodePage);

        if (iChars <= 0)
            break;

        ptstrTable += iChars + 1;
    }

    if (pTTFontSub != NULL)
    {
        ERR(("Error packing font substitution table\n"));
        ptstrTable = ptstrStart;
    }

    *ptstrTable++ = NUL;
    pParserData->pUIInfo->dwFontSubCount = (DWORD)(ptstrTable - ptstrStart) * sizeof(TCHAR);
}



VOID
VPackFileDateInfo(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack source PPD filenames and dates

Arguments:

    pParserData - Points to parser data structure

Return Value:

    NONE

--*/

{
    PRAWBINARYDATA  pRawData;
    DWORD           dwCount;
    PFILEDATEINFO   pFileDateInfo;
    PTSTR           ptstrFullname;
    PLISTOBJ        pItem;
    HANDLE          hFile;

    pRawData = &pParserData->pInfoHdr->RawData;
    dwCount = DwCountListItem(pParserData->pPpdFileNames);

    if (pRawData->FileDateInfo.dwCount = dwCount)
    {
        VGrowPackBuffer(pParserData, dwCount * sizeof(FILEDATEINFO));
        pRawData->FileDateInfo.loOffset = pParserData->dwBufSize;
        pFileDateInfo = (PFILEDATEINFO) (pParserData->pubBufStart + pParserData->dwBufSize);
        pParserData->dwBufSize += DWORD_ALIGN(dwCount * sizeof(FILEDATEINFO));

        for (pItem = pParserData->pPpdFileNames; pItem; pItem = pItem->pNext)
        {
            dwCount--;
            ptstrFullname = (PTSTR) pItem->pstrName;

            VPackStringUnicode(pParserData,
                               &pFileDateInfo[dwCount].loFileName,
                               ptstrFullname);

            hFile = CreateFile(ptstrFullname,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                               NULL);

            if ((hFile == INVALID_HANDLE_VALUE) ||
                !GetFileTime(hFile, NULL, NULL, &pFileDateInfo[dwCount].FileTime))
            {
                ERR(("GetFileTime '%ws' failed: %d\n", ptstrFullname, GetLastError()));
                GetSystemTimeAsFileTime(&pFileDateInfo[dwCount].FileTime);
            }

            if (hFile != INVALID_HANDLE_VALUE)
                CloseHandle(hFile);
        }
    }
}



VOID
VMapLangEncodingToCodePage(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Map LanguageEncoding to code page

Arguments:

    pParserData - Points to parser data structure

Return Value:

    NONE

--*/

{
    UINT    uCodePage = CP_ACP;
    CPINFO  cpinfo;

    switch (pParserData->dwLangEncoding)
    {
    case LANGENC_ISOLATIN1:
        uCodePage = 1252;
        break;

    case LANGENC_JIS83_RKSJ:
        uCodePage = 932;
        break;

    case LANGENC_UNICODE:
        uCodePage = CP_UNICODE;
        break;

    case LANGENC_NONE:
        break;

    default:
        RIP(("Unknown language encoding: %d\n", pParserData->dwLangEncoding));
        break;
    }

    //
    // Make sure the requested code page is available
    //

    if (uCodePage != CP_UNICODE &&
        uCodePage != CP_ACP &&
        !GetCPInfo(uCodePage, &cpinfo))
    {
        WARNING(("Code page %d is not available\n", uCodePage));
        uCodePage = CP_ERROR;
    }

    pParserData->uCodePage = uCodePage;
}



BOOL
BPackBinaryData(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Pack the parsed PPD information into binary format

Arguments:

    pParserData - Points to parser data structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   dwSize;
    DWORD   dwMinFreeMem;
    BOOL    bResult = FALSE;

    VALIDATE_PARSER_DATA(pParserData);

    __try
    {
        //
        // Quick-access pointers to various data structures.
        //

        PINFOHEADER pInfoHdr;
        PUIINFO     pUIInfo;
        PPPDDATA    pPpdData;

        //
        // Pack fixed header data structures
        //

        dwSize = sizeof(INFOHEADER) + sizeof(UIINFO) + sizeof(PPDDATA);
        VGrowPackBuffer(pParserData, dwSize);
        pParserData->dwBufSize = DWORD_ALIGN(dwSize);
        pInfoHdr = pParserData->pInfoHdr;
        pUIInfo = pParserData->pUIInfo;
        pPpdData = pParserData->pPpdData;

        pInfoHdr->RawData.dwParserSignature = PPD_PARSER_SIGNATURE;
        pInfoHdr->RawData.dwParserVersion = PPD_PARSER_VERSION;

        #if 0
        pInfoHdr->RawData.dwChecksum32 = pParserData->dwChecksum32;
        #endif

        pInfoHdr->loUIInfoOffset = sizeof(INFOHEADER);
        pInfoHdr->loDriverOffset = sizeof(INFOHEADER) + sizeof(UIINFO);

        //
        // Pack source PPD filenames and dates
        //

        VPackFileDateInfo(pParserData);

        //
        // Perform a few miscellaneous checks
        //

        if (pParserData->pOpenFeature)
            SEMANTIC_ERROR(("Missing CloseUI for: %s\n", pParserData->pOpenFeature->pstrName));

        if (pParserData->bInstallableGroup)
            SEMANTIC_ERROR(("Missing CloseGroup: InstallableOptions\n"));

        if (pParserData->NickName.dwLength == 0)
            SEMANTIC_ERROR(("Missing *NickName and *ShortNickName entry\n"));

        if (pParserData->Product.dwLength == 0)
            SEMANTIC_ERROR(("Missing *Product entry\n"));

        if (pParserData->dwSpecVersion == 0)
            SEMANTIC_ERROR(("Missing *PPD-Adobe and *FormatVersion entry\n"));

        if (pParserData->dwLangLevel == 0)
        {
            SEMANTIC_ERROR(("Missing *LanguageLevel entry\n"));
            pParserData->dwLangLevel = 1;
        }

        dwMinFreeMem = pParserData->dwLangLevel <= 1 ? MIN_FREEMEM_L1 : MIN_FREEMEM_L2;
        if (pParserData->dwFreeMem < dwMinFreeMem)
        {
            SEMANTIC_ERROR(("Invalid *FreeVM entry\n"));
            pParserData->dwFreeMem = dwMinFreeMem;
        }

        //
        // Map LanguageEncoding to code page
        //

        VMapLangEncodingToCodePage(pParserData);

        //
        // Count the number of doc- and printer-sticky features
        // and sort them into two separate groups
        //

        VCountAndSortPrinterFeatures(pParserData);

        //
        // Fill out fields in the UIINFO structure
        //

        pUIInfo->dwSize = sizeof(UIINFO);
        pUIInfo->dwDocumentFeatures = pInfoHdr->RawData.dwDocumentFeatures;
        pUIInfo->dwPrinterFeatures = pInfoHdr->RawData.dwPrinterFeatures;
        pUIInfo->dwTechnology = DT_RASPRINTER;
        pUIInfo->dwMaxCopies = MAX_COPIES;
        pUIInfo->dwMinScale = MIN_SCALE;
        pUIInfo->dwMaxScale = MAX_SCALE;
        pUIInfo->dwSpecVersion = pParserData->dwSpecVersion;
        pUIInfo->dwLangEncoding = pParserData->dwLangEncoding;
        pUIInfo->dwLangLevel = pParserData->dwLangLevel;
        pUIInfo->dwPrintRate = pUIInfo->dwPrintRatePPM = pParserData->dwThroughput;

        #ifndef WINNT_40
        pUIInfo->dwPrintRateUnit = PRINTRATEUNIT_PPM;
        #endif

        //
        // Note: We assume all printers can support binary protocol
        //

        pUIInfo->dwProtocols = pParserData->dwProtocols | PROTOCOL_BINARY;

        pUIInfo->dwJobTimeout = pParserData->dwJobTimeout;
        pUIInfo->dwWaitTimeout = pParserData->dwWaitTimeout;
        pUIInfo->dwTTRasterizer = pParserData->dwTTRasterizer;
        pUIInfo->dwFreeMem = pParserData->dwFreeMem;
        pUIInfo->fxScreenAngle = pParserData->fxScreenAngle;
        pUIInfo->fxScreenFreq = pParserData->fxScreenFreq;
        pUIInfo->dwCustomSizeOptIndex = OPTION_INDEX_ANY;

        pPpdData->dwPpdFilever = pParserData->dwPpdFilever;
        pPpdData->dwFlags = pParserData->dwPpdFlags;

        //
        // Our internal unit is microns, thus 25400 units per inch.
        //

        pUIInfo->ptMasterUnits.x =
        pUIInfo->ptMasterUnits.y = 25400;

        pUIInfo->dwFlags = FLAG_FONT_DOWNLOADABLE |
                           FLAG_ORIENT_SUPPORT;

        if (pParserData->dwColorDevice)
            pUIInfo->dwFlags |= FLAG_COLOR_DEVICE;

        if (pParserData->dwLSOrientation != LSO_MINUS90)
            pUIInfo->dwFlags |= FLAG_ROTATE90;

        if (PvFindListItem(pParserData->pFeatures, "StapleLocation", NULL) ||
            PvFindListItem(pParserData->pFeatures, "StapleX", NULL) &&
            PvFindListItem(pParserData->pFeatures, "StapleY", NULL))
        {
            pUIInfo->dwFlags |= FLAG_STAPLE_SUPPORT;
        }

        if (pParserData->bDefReversePrint)
            pUIInfo->dwFlags |= FLAG_REVERSE_PRINT;

        if (pParserData->dwLangLevel > 1)
        {
            if (pParserData->bEuroInformationSet)
            {
                if (!pParserData->bHasEuro)
                    pUIInfo->dwFlags |= FLAG_ADD_EURO;
            }
            else if (pParserData->dwPSVersion < 3011)
                    pUIInfo->dwFlags |= FLAG_ADD_EURO;
        }

        if (pParserData->bTrueGray)
            pUIInfo->dwFlags |= FLAG_TRUE_GRAY;

        VPackStringAnsiToUnicode(
                                pParserData,
                                &pUIInfo->loNickName,
                                pParserData->NickName.pvData,
                                pParserData->NickName.dwLength);

        //
        // Pack symbol definitions and resolve symbol references
        //

        VPackSymbolDefinitions(pParserData);
        VResolveSymbolReferences(pParserData);

        VPackInvocation(pParserData, &pUIInfo->Password, &pParserData->Password);
        VPackInvocation(pParserData, &pUIInfo->ExitServer, &pParserData->ExitServer);

        //
        // Copy and validate custom page size parameters
        //

        pPpdData->dwUseHWMarginsTrue =
        pPpdData->dwUseHWMarginsFalse =
        pPpdData->dwLeadingEdgeLong =
        pPpdData->dwLeadingEdgeShort = OPTION_INDEX_ANY;
        pPpdData->dwCustomSizeFlags = pParserData->dwCustomSizeFlags;

        CopyMemory(pPpdData->CustomSizeParams,
                   pParserData->CustomSizeParams,
                   sizeof(pPpdData->CustomSizeParams));

        //
        // Process the printer features and handle any special glitches
        //

        VProcessPrinterFeatures(pParserData);

        //
        // Pack UIConstraints information
        //

        VPackUIConstraints(pParserData);

        //
        // Pack OrderDependency and QueryOrderDependency information
        //

        VPackOrderDependency(pParserData, &pPpdData->OrderDeps, pParserData->pOrderDep);
        VPackOrderDependency(pParserData, &pPpdData->QueryOrderDeps, pParserData->pQueryOrderDep);

        //
        // Pack printer features and options
        //

        VPackPrinterFeatures(pParserData);

        //
        // Fill out fields in PPDDATA structure
        //

        pPpdData->dwSizeOfStruct = sizeof(PPDDATA);
        pPpdData->dwExtensions = pParserData->dwExtensions;
        pPpdData->dwSetResType = pParserData->dwSetResType;
        pPpdData->dwPSVersion = pParserData->dwPSVersion;

        //
        // Scan the document-sticky feature list to check if "OutputOrder" is available.
        // If it is, remember its feature index, which will be used by UI code.
        //

        {
            PFEATURE    pFeature;
            DWORD       dwIndex;
            PCSTR       pstrKeywordName;

            pPpdData->dwOutputOrderIndex = INVALID_FEATURE_INDEX;

            pFeature = OFFSET_TO_POINTER(pInfoHdr, pUIInfo->loFeatureList);

            ASSERT(pFeature != NULL);

            for (dwIndex = 0; dwIndex < pUIInfo->dwDocumentFeatures; dwIndex++, pFeature++)
            {
                if ((pstrKeywordName = OFFSET_TO_POINTER(pInfoHdr, pFeature->loKeywordName)) &&
                    strcmp(pstrKeywordName, "OutputOrder") == EQUAL_STRING)
                {
                    pPpdData->dwOutputOrderIndex = dwIndex;
                    break;
                }
            }
        }

        VPackInvocation(pParserData, &pPpdData->PSVersion, &pParserData->PSVersion);
        VPackInvocation(pParserData, &pPpdData->Product, &pParserData->Product);

        if (SUPPORT_CUSTOMSIZE(pUIInfo))
        {
            //
            // If neither roll-fed nor cut-sheet flag is set, assume to be roll-fed
            //

            if (! (pPpdData->dwCustomSizeFlags & (CUSTOMSIZE_CUTSHEET|CUSTOMSIZE_ROLLFED)))
                pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_ROLLFED;

            //
            // If roll-fed flag is not set, default must be cut-sheet
            //

            if (! (pPpdData->dwCustomSizeFlags & CUSTOMSIZE_ROLLFED))
                pPpdData->dwCustomSizeFlags |= CUSTOMSIZE_DEFAULTCUTSHEET;
        }

        VPackInvocation(pParserData, &pPpdData->PatchFile, &pParserData->PatchFile);
        VPackInvocation(pParserData, &pPpdData->JclBegin, &pParserData->JclBegin);
        VPackInvocation(pParserData, &pPpdData->JclEnterPS, &pParserData->JclEnterPS);
        VPackInvocation(pParserData, &pPpdData->JclEnd, &pParserData->JclEnd);
        VPackInvocation(pParserData, &pPpdData->ManualFeedFalse, &pParserData->ManualFeedFalse);

        //
        // Pack NT4 feature index mapping information
        //

        VPackNt4Mapping(pParserData);

        //
        // Pack device font information
        //

        VPackDeviceFonts(pParserData);

        //
        // Pack JobPatchFile information
        //

        VPackJobPatchFiles(pParserData);

        //
        // Pack default TrueType font substitution table
        //

        if (pParserData->pTTFontSubs == NULL || pParserData->uCodePage == CP_ERROR)
            VPackDefaultTrueTypeSubstTable(pParserData);
        else
            VPackTrueTypeSubstTable(pParserData);

        pInfoHdr->RawData.dwFileSize = pParserData->dwBufSize;
        bResult = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        ERR(("PackBinaryData failed.\n"));
    }

    return bResult;
}



BOOL
BSaveBinaryDataToFile(
    PPARSERDATA pParserData,
    PTSTR       ptstrPpdFilename
    )

/*++

Routine Description:

    Cache the binary PPD data in a file

Arguments:

    pParserData - Points to parser data structure
    ptstrPpdFilename - Specifies the PPD filename

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PTSTR   ptstrBpdFilename;
    HANDLE  hFile;
    DWORD   dwBytesWritten;
    BOOL    bResult = FALSE;

    VALIDATE_PARSER_DATA(pParserData);

    //
    // Generate a binary file name based the original filename
    // Create a file and write data to it
    //

    if ((ptstrBpdFilename = GenerateBpdFilename(ptstrPpdFilename)) != NULL &&
        (hFile = CreateFile(ptstrBpdFilename,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS,
                            NULL)) != INVALID_HANDLE_VALUE)
    {
        bResult = WriteFile(hFile,
                            pParserData->pubBufStart,
                            pParserData->dwBufSize,
                            &dwBytesWritten,
                            NULL) &&
                  (pParserData->dwBufSize == dwBytesWritten);

        CloseHandle(hFile);
    }

    if (! bResult)
        ERR(("Couldn't cache binary PPD data: %d\n", GetLastError()));

    MemFree(ptstrBpdFilename);
    return bResult;
}



VOID
VFreeParserData(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Free up memory used to hold parser data structure

Arguments:

    pParserData - Points to parser data structure

Return Value:

    NONE

--*/

{
    VALIDATE_PARSER_DATA(pParserData);

    if (pParserData->pubBufStart)
        VirtualFree(pParserData->pubBufStart, 0, MEM_RELEASE);

    MemFree(pParserData->Value.pbuf);
    HeapDestroy(pParserData->hHeap);
}



PPARSERDATA
PAllocParserData(
    VOID
    )

/*++

Routine Description:

    Allocate memory to hold PPD parser data

Arguments:

    NONE

Return Value:

    Pointer to allocated parser data structure
    NULL if there is an error

--*/

{
    PPARSERDATA pParserData;
    HANDLE      hHeap;

    //
    // Create a heap and allocate memory space from it
    //

    if (! (hHeap = HeapCreate(0, 16*1024, 0)) ||
        ! (pParserData = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(PARSERDATA))))
    {
        ERR(("Memory allocation failed: %d\n", GetLastError()));

        if (hHeap)
            HeapDestroy(hHeap);

        return NULL;
    }

    pParserData->hHeap = hHeap;
    pParserData->pvStartSig = pParserData->pvEndSig = pParserData;

    //
    // Initialize the parser data structure - we only need to worry
    // about non-zero fields here.
    //

    pParserData->dwChecksum32 = 0xFFFFFFFF;
    pParserData->dwFreeMem = min(MIN_FREEMEM_L1, MIN_FREEMEM_L2);
    pParserData->dwJobTimeout = DEFAULT_JOB_TIMEOUT;
    pParserData->dwWaitTimeout = DEFAULT_WAIT_TIMEOUT;
    pParserData->iManualFeedIndex =
    pParserData->iReqPageRgnIndex =
    pParserData->iDefInstallMemIndex = -1;
    pParserData->wNt4Checksum = 0;
    pParserData->dwPpdFlags = PPDFLAG_PRINTPSERROR;

    //
    // Initialize buffers for storing keyword, option, translation, and value.
    // Build up data structures to speed up keyword lookup
    //

    SET_BUFFER(&pParserData->Keyword, pParserData->achKeyword);
    SET_BUFFER(&pParserData->Option,  pParserData->achOption);
    SET_BUFFER(&pParserData->Xlation, pParserData->achXlation);

    if (IGrowValueBuffer(&pParserData->Value) != PPDERR_NONE ||
        ! BInitKeywordLookup(pParserData))
    {
        VFreeParserData(pParserData);
        return NULL;
    }

    return pParserData;
}



BOOL
BRememberSourceFilename(
    PPARSERDATA pParserData,
    PTSTR       ptstrFilename
    )

/*++

Routine Description:

    Remember the full pathname to the source PPD file

Arguments:

    pParserData - Points to parser data structure
    ptstrFilename - Specifies the source PPD filename

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PLISTOBJ    pItem;
    TCHAR       ptstrFullname[MAX_PATH];
    PTSTR       ptstrFilePart;
    DWORD       dwSizeChars, dwSizeChars2;
    DWORD       dwSizeBytes;  // size of buffer to hold pathname

    //
    // Get the full pathname to the specified source PPD file
    //

    dwSizeChars = GetFullPathName(ptstrFilename, MAX_PATH, ptstrFullname, &ptstrFilePart);

    if (dwSizeChars == 0)
    {
        ERR(("GetFullPathName failed: %d\n", GetLastError()));
        return FALSE;
    }

    //
    // Remember the source PPD filenames
    //

    dwSizeBytes = (dwSizeChars + 1) * sizeof(TCHAR);

    if (! (pItem = ALLOC_PARSER_MEM(pParserData, sizeof(LISTOBJ) + dwSizeBytes)))
        return FALSE;

    pItem->pstrName = (PSTR) ((PBYTE) pItem + sizeof(LISTOBJ));

    // let GetFullPathName write directly into the real buffer!
    dwSizeChars2 = GetFullPathName(ptstrFilename, dwSizeChars + 1, (PTSTR)pItem->pstrName, &ptstrFilePart);

    if((dwSizeChars2 == 0)  ||  (dwSizeChars2 > dwSizeChars))
    {
        ERR(("GetFullPathName failed: %d\n", GetLastError()));
        return FALSE;       // no need to free pItem since  Heap is destroyed automatically.
    }

    pItem->pNext = pParserData->pPpdFileNames;
    pParserData->pPpdFileNames = pItem;
    return TRUE;
}



// 16-bit crc checksum table - copied from win95

static const WORD Crc16Table[] =
{
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
    0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
    0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
    0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
    0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
    0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
    0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
    0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
    0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
    0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
    0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
    0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
    0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
    0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
    0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
    0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
    0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
    0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
    0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
    0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
    0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
    0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
    0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
    0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
    0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
    0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
};

WORD
WComputeCrc16Checksum(
    IN PBYTE    pbuf,
    IN DWORD    dwCount,
    IN WORD     wChecksum
    )

/*++

Routine Description:

    Compute the 16-bit CRC checksum on a buffer of data

Arguments:

    pbuf - Points to a data buffer
    dwCount - Number of bytes in the data buffer
    wChecksum - Initial checksum value

Return Value:

    Resulting checksum value

--*/

{
    while (dwCount--)
        wChecksum = Crc16Table[(wChecksum >> 8) ^ *pbuf++] ^ (wChecksum << 8);

    return wChecksum;
}



DWORD
dwComputeFeatureOptionChecksum(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Compute checksum for only feature/option keyword strings.

Arguments:

    pParserData - Points to parser data structure

Return Value:

    32bit checksum value

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwFeatureCount, dwFeatureIndex, dwOptionCount, dwOptionIndex;
    PBYTE       pBuf;
    DWORD       dwBufSize;

    VALIDATE_PARSER_DATA(pParserData);

    pInfoHdr =  pParserData->pInfoHdr;
    pUIInfo  =  (PUIINFO)((PBYTE)pInfoHdr + sizeof(INFOHEADER));

    dwFeatureCount = pInfoHdr->RawData.dwDocumentFeatures + pInfoHdr->RawData.dwPrinterFeatures;

    pFeature = OFFSET_TO_POINTER(pInfoHdr, pUIInfo->loFeatureList);

    ASSERT(dwFeatureCount == 0 || pFeature != NULL);

    for (dwFeatureIndex = 0; dwFeatureIndex < dwFeatureCount; dwFeatureIndex++, pFeature++)
    {
        pBuf = OFFSET_TO_POINTER(pInfoHdr, pFeature->loKeywordName);

        ASSERT(pBuf != NULL);

        dwBufSize = strlen((PSTR)pBuf) + 1;

        pParserData->dwChecksum32 = ComputeCrc32Checksum(pBuf, dwBufSize, pParserData->dwChecksum32);

        if (dwOptionCount = pFeature->Options.dwCount)
        {
            pOption = OFFSET_TO_POINTER(pInfoHdr, pFeature->Options.loOffset);

            ASSERT(pOption != NULL);

            for (dwOptionIndex = 0; dwOptionIndex < dwOptionCount; dwOptionIndex++)
            {
                pBuf = OFFSET_TO_POINTER(pInfoHdr, pOption->loKeywordName);
                dwBufSize = strlen((PSTR)pBuf) + 1;

                pParserData->dwChecksum32 = ComputeCrc32Checksum(pBuf, dwBufSize, pParserData->dwChecksum32);
                pOption = (POPTION)((PBYTE)pOption + pFeature->dwOptionSize);
            }
        }
    }

    return pParserData->dwChecksum32;
}



DWORD
dwCalcMaxKeywordSize(
    IN PPARSERDATA pParserData,
    IN INT         iMode
    )

/*++

Routine Description:

    Calculate the maximum buffer size for storing feature/option
    keyword pairs in Registry.

Arguments:

    pParserData - Points to parser data structure
    iMode       - For either doc- or printer- sticky features

Return Value:

    The maximum buffer size needed for storing feature/option keyword paris.

--*/

{
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwStart, dwFeatureCount, dwFeatureIndex, dwOptionCount, dwOptionIndex;
    PSTR        pBuf;
    DWORD       dwMaxSize, dwOptionSize, dwOptionMax;

    VALIDATE_PARSER_DATA(pParserData);

    dwMaxSize = 0;

    pInfoHdr = pParserData->pInfoHdr;
    pUIInfo  = pParserData->pUIInfo;

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        dwStart = 0;
        dwFeatureCount = pUIInfo->dwDocumentFeatures;
    }
    else
    {
        ASSERT(iMode == MODE_PRINTER_STICKY);

        dwStart = pUIInfo->dwDocumentFeatures;
        dwFeatureCount = pUIInfo->dwPrinterFeatures;
    }

    pFeature = OFFSET_TO_POINTER(pInfoHdr, pUIInfo->loFeatureList);

    ASSERT(dwFeatureCount == 0 || pFeature != NULL);

    pFeature += dwStart;

    for (dwFeatureIndex = 0; dwFeatureIndex < dwFeatureCount; dwFeatureIndex++, pFeature++)
    {
        pBuf = OFFSET_TO_POINTER(pInfoHdr, pFeature->loKeywordName);

        ASSERT(pBuf != NULL);

        dwMaxSize += strlen(pBuf) + 1;

        dwOptionMax = 0;
        if (dwOptionCount = pFeature->Options.dwCount)
        {
            pOption = OFFSET_TO_POINTER(pInfoHdr, pFeature->Options.loOffset);

            ASSERT(pOption != NULL);

            for (dwOptionIndex = 0; dwOptionIndex < dwOptionCount; dwOptionIndex++)
            {
                pBuf = OFFSET_TO_POINTER(pInfoHdr, pOption->loKeywordName);
                dwOptionSize = strlen(pBuf) + 1;

                if (pFeature->dwUIType != UITYPE_PICKMANY)
                {
                    if (dwOptionMax < dwOptionSize)
                        dwOptionMax = dwOptionSize;
                }
                else // count all options for PickMany feature
                    dwMaxSize += dwOptionSize;

                pOption = (POPTION)((PBYTE)pOption + pFeature->dwOptionSize);
            }
        }

        //
        // Add the max option keyword size here for non-PickMany feature
        //

        if (pFeature->dwUIType != UITYPE_PICKMANY)
            dwMaxSize += dwOptionMax;

        //
        // One extra byte for the \0x0A delimiter between features
        //

        dwMaxSize += 1;
    }

    dwMaxSize += KEYWORD_SIZE_EXTRA;

    return dwMaxSize;
}



PPDERROR
IParseFile(
    PPARSERDATA pParserData,
    PTSTR       ptstrFilename
    )

/*++

Routine Description:

    Parse a PPD file

Arguments:

    pParserData - Points to parser data structure
    ptstrFilename - Specifies the name of the file to be parsed

Return Value:

    PPDERR_NONE if successful, error code otherwise

--*/

{
    PPDERROR    iStatus;
    PFILEOBJ    pFile;
    INT         iSyntaxErrors = 0;

    //
    // Map the file into memory for read-only access
    //

    VALIDATE_PARSER_DATA(pParserData);
    ASSERT(ptstrFilename != NULL);

    if (! BRememberSourceFilename(pParserData, ptstrFilename) ||
        ! (pFile = PCreateFileObj(ptstrFilename)))
    {
        return PPDERR_FILE;
    }

    pParserData->pFile = pFile;

    #if 0
    //
    // Compute the 32-bit CRC checksum of the file content
    //

    pParserData->dwChecksum32 =
    ComputeCrc32Checksum(pFile->pubStart, pFile->dwFileSize, pParserData->dwChecksum32);
    #endif

    //
    // Compute the 16-bit CRC checksum as well for PS4 compatibility
    //

    pParserData->wNt4Checksum =
    WComputeCrc16Checksum(pFile->pubStart, pFile->dwFileSize, pParserData->wNt4Checksum);

    //
    // Process entries in the file
    //

    while ((iStatus = IParseEntry(pParserData)) != PPDERR_EOF)
    {
        if (iStatus == PPDERR_SYNTAX)
            iSyntaxErrors++;
        else if (iStatus != PPDERR_NONE)
        {
            VDeleteFileObj(pFile);
            return iStatus;
        }
    }

    if (END_OF_FILE(pFile) && !END_OF_LINE(pFile))
        TERSE(("Incomplete last line ignored.\n"));

    //
    // Unmap the file and return to the caller
    //

    VDeleteFileObj(pFile);

    return (iSyntaxErrors > 0) ? PPDERR_SYNTAX : PPDERR_NONE;
}



PRAWBINARYDATA
PpdParseTextFile(
    PTSTR   ptstrPpdFilename
    )

/*++

Routine Description:

    PPD parser main entry point

Arguments:

    ptstrPpdFilename - Specifies the PPD file to be parsed

Return Value:

    Pointer to parsed binary PPD data, NULL if there is an error

--*/

{
    PPARSERDATA     pParserData;
    PPDERROR        iStatus;
    PRAWBINARYDATA  pRawData = NULL;

    //
    // Allocate parser data structure
    //

    ASSERT(ptstrPpdFilename != NULL);

    if (! (pParserData = PAllocParserData()))
        return NULL;

    //
    // Parse the PPD file
    //

    iStatus = IParseFile(pParserData, ptstrPpdFilename);

    if (iStatus == PPDERR_NONE || iStatus == PPDERR_SYNTAX)
    {
        //
        // Pack the parsed information into binary format
        //

        pParserData->bErrorFlag = FALSE;

        if (BPackBinaryData(pParserData))
        {
            //
            // After binary data is packed, we calculate the 32bit checksum
            // for only feature/option keyword strings (instead of for the
            // whole PPD file). Doing this will enable us to retain option
            // selections when the PPD file is modified without feature/option
            // changes.
            //

            pParserData->pInfoHdr->RawData.dwChecksum32 = dwComputeFeatureOptionChecksum(pParserData);

            //
            // Calculate the maximum buffer sizes for storing feature/option
            // keyword pairs in Registry
            //

            pParserData->pUIInfo->dwMaxDocKeywordSize = dwCalcMaxKeywordSize(pParserData, MODE_DOCUMENT_STICKY);
            pParserData->pUIInfo->dwMaxPrnKeywordSize = dwCalcMaxKeywordSize(pParserData, MODE_PRINTER_STICKY);

            #ifndef WINNT_40

            pParserData->pPpdData->dwUserDefUILangID = (DWORD)GetUserDefaultUILanguage();

            #else

            pParserData->pPpdData->dwUserDefUILangID = 0;

            #endif

            //
            // Save binary data to a file
            //

            (VOID) BSaveBinaryDataToFile(pParserData, ptstrPpdFilename);

            //
            // Here we'll copy the packed binary data to a different buffer.
            // This is necessary because the packed data buffer was allocated
            // using VirtualAlloc. If we return that pointer back to the caller,
            // the caller would need to call VirtualFree to release it.
            //

            if (pRawData = MemAlloc(pParserData->dwBufSize))
            {
                CopyMemory(pRawData, pParserData->pubBufStart, pParserData->dwBufSize);
            }
            else
                ERR(("Memory allocation failed: %d\n", GetLastError()));
        }
    }

    if (iStatus == PPDERR_SYNTAX || pParserData->bErrorFlag)
        WARNING(("Errors found in %ws\n", ptstrPpdFilename));

    VFreeParserData(pParserData);
    return pRawData;
}



PPDERROR
IGrowValueBuffer(
    PBUFOBJ pBufObj
    )

/*++

Routine Description:

    Grow the buffer used for holding the entry value

Arguments:

    pBufObj - Specifies the buffer to be enlarged

Return Value:

    PPDERR_NONE if successful, error code otherwise

--*/

#define VALUE_BUFFER_INCREMENT  (1*KBYTES)

{
    DWORD   dwNewLen = pBufObj->dwMaxLen + VALUE_BUFFER_INCREMENT;
    PBYTE   pbuf;

    if (! IS_BUFFER_FULL(pBufObj))
        WARNING(("Trying to grow buffer while it's not yet full.\n"));

    if (! (pbuf = MemAllocZ(dwNewLen)))
    {
        ERR(("Memory allocation failed: %d\n", GetLastError()));
        return PPDERR_MEMORY;
    }

    if (pBufObj->pbuf)
    {
        CopyMemory(pbuf, pBufObj->pbuf, pBufObj->dwSize);
        MemFree(pBufObj->pbuf);
    }

    pBufObj->pbuf = pbuf;
    pBufObj->dwMaxLen = dwNewLen;
    return PPDERR_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\ppd\ppdkwd.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdkwd.c

Abstract:

    Functions for interpreting the semantics elements of a PPD file

Environment:

    PostScript driver, PPD parser

Revision History:

    09/30/96 -davidx-
        Cleaner handling of ManualFeed and AutoSelect feature.

    08/20/96 -davidx-
        Common coding style for NT 5.0 drivers.

    03/26/96 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"
#include "ppdparse.h"
#include <math.h>

//
// Data structure for representing entries in a keyword table
//

typedef PPDERROR (*KWDPROC)(PPARSERDATA);

typedef struct _KWDENTRY {

    PCSTR   pstrKeyword;        // keyword name
    KWDPROC pfnProc;            // keyword handler function
    DWORD   dwFlags;            // misc. flag bits

} KWDENTRY, *PKWDENTRY;

//
// Constants for KWDENTRY.flags field. The low order byte is used to indicate value types.
//

#define REQ_OPTION      0x0100
#define ALLOW_MULTI     0x0200
#define ALLOW_HEX       0x0400
#define DEFAULT_PROC    0x0800

#define INVOCA_VALUE    (VALUETYPE_QUOTED | VALUETYPE_SYMBOL)
#define QUOTED_VALUE    (VALUETYPE_QUOTED | ALLOW_HEX)
#define QUOTED_NOHEX    VALUETYPE_QUOTED
#define STRING_VALUE    VALUETYPE_STRING

#define GENERIC_ENTRY(featureId)    ((featureId) << 16)

//
// Give a warning when there are duplicate entries for the same option
//

#define WARN_DUPLICATE() \
        TERSE(("%ws: Duplicate entries of '*%s %s' on line %d\n", \
               pParserData->pFile->ptstrFileName, \
               pParserData->achKeyword, \
               pParserData->achOption, \
               pParserData->pFile->iLineNumber))

//
// Default keyword prefix string
//

#define HAS_DEFAULT_PREFIX(pstr) \
        (strncmp((pstr), gstrDefault, strlen(gstrDefault)) == EQUAL_STRING)

//
// Determine whether a string starts with JCL prefix
//

#define HAS_JCL_PREFIX(pstr) (strncmp((pstr), "JCL", 3) == EQUAL_STRING)

//
// Forward declaration of local functions
//

PPDERROR IVerifyValueType(PPARSERDATA, DWORD);
PPDERROR IGenericOptionProc(PPARSERDATA, PFEATUREOBJ);
PPDERROR IGenericDefaultProc(PPARSERDATA, PFEATUREOBJ);
PPDERROR IGenericQueryProc(PPARSERDATA, PFEATUREOBJ);
PFEATUREOBJ PCreateFeatureItem(PPARSERDATA, DWORD);
PKWDENTRY PSearchKeywordTable(PPARSERDATA, PSTR, PINT);



PPDERROR
IInterpretEntry(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Interpret an entry parsed from a printer description file

Arguments:

    pParserData - Points to parser data structure

Return Value:

    Status code

--*/

{
    PSTR        pstrKeyword, pstrRealKeyword;
    PPDERROR    iStatus;
    PKWDENTRY   pKwdEntry;
    INT         iIndex;
    BOOL        bQuery, bDefault;

    //
    // Get a pointer to the keyword string and look for
    // *? and *Default prefix in front of the keyword.
    //

    pstrRealKeyword = pstrKeyword = pParserData->achKeyword;
    bQuery = bDefault = FALSE;

    // NOTE: We don't have any use for query entries so don't parse them here.
    // This helps us somewhat to preserve the feature index from NT4.

    if (FALSE && *pstrKeyword == QUERY_CHAR)
    {
        bQuery = TRUE;
        pstrRealKeyword++;
    }
    else if (HAS_DEFAULT_PREFIX(pstrKeyword))
    {
        bDefault = TRUE;
        pstrRealKeyword += strlen(gstrDefault);
    }

    //
    // Set up a convenient pointer to the entry value
    //

    pParserData->pstrValue = (PSTR) pParserData->Value.pbuf;

    //
    // If we're within an OpenUI/CloseUI pair and the keyword
    // in the current entry matches what's in OpenUI, then we
    // will handle the current entry using a generic procedure.
    //

    if (pParserData->pOpenFeature &&
        pParserData->pOpenFeature->dwFeatureID == GID_UNKNOWN &&
        strcmp(pstrRealKeyword, pParserData->pOpenFeature->pstrName) == EQUAL_STRING)
    {
        pKwdEntry = NULL;
    }
    else
    {
        //
        // Find out if the keyword has built-in support
        //

        pKwdEntry = PSearchKeywordTable(pParserData, pstrRealKeyword, &iIndex);

        //
        // For *Default keywords, if we failed to find the keyword without
        // the prefix, try it again with the prefix.
        //

        if (bDefault &&
            (pKwdEntry == NULL || pKwdEntry->pfnProc != NULL) &&
            (pKwdEntry = PSearchKeywordTable(pParserData, pstrKeyword, &iIndex)))
        {
            bDefault = FALSE;
        }

        //
        // Ignore unsupported keywords
        //

        if ((pKwdEntry == NULL) ||
            ((bQuery || bDefault) && (pKwdEntry->pfnProc != NULL)))
        {
            VERBOSE(("Keyword not supported: *%s\n", pstrKeyword));
            return PPDERR_NONE;
        }
    }

    //
    // Determine if the entry should be handle by the generic procedure
    //

    if (pKwdEntry == NULL || pKwdEntry->pfnProc == NULL)
    {
        PFEATUREOBJ pFeature;
        DWORD       dwValueType;
        PPDERROR    (*pfnGenericProc)(PPARSERDATA, PFEATUREOBJ);

        //
        // Make sure the value type matches what's expected
        //

        if (bQuery)
        {
            pfnGenericProc = IGenericQueryProc;
            dwValueType = INVOCA_VALUE;
        }
        else if (bDefault)
        {
            pfnGenericProc = IGenericDefaultProc;
            dwValueType = STRING_VALUE;
        }
        else
        {
            pfnGenericProc = IGenericOptionProc;
            dwValueType = INVOCA_VALUE | REQ_OPTION;
        }

        if ((iStatus = IVerifyValueType(pParserData, dwValueType)) != PPDERR_NONE)
            return iStatus;

        //
        // Call the appropriate generic procedure
        //

        pFeature = (pKwdEntry == NULL) ?
                        pParserData->pOpenFeature :
                        PCreateFeatureItem(pParserData, HIWORD(pKwdEntry->dwFlags));

        return pfnGenericProc(pParserData, pFeature);
    }
    else
    {
        //
        // Screen out duplicate keyword entries
        //

        if (! (pKwdEntry->dwFlags & (ALLOW_MULTI|REQ_OPTION)))
        {
            if (pParserData->pubKeywordCounts[iIndex])
            {
                WARN_DUPLICATE();
                return PPDERR_NONE;
            }

            pParserData->pubKeywordCounts[iIndex]++;
        }

        //
        // Make sure the value type matches what's expected
        // Take care of embedded hexdecimal strings if necessary
        //

        if ((iStatus = IVerifyValueType(pParserData, pKwdEntry->dwFlags)) != PPDERR_NONE)
            return iStatus;

        //
        // Invoke the specific procedure to handle built-in keywords
        //

        return (pKwdEntry->pfnProc)(pParserData);
    }
}



PPDERROR
IVerifyValueType(
    PPARSERDATA pParserData,
    DWORD       dwExpectedType
    )

/*++

Routine Description:

    Verify the value type of the current entry matches what's expected

Arguments:

    pParserData - Points to parser data structure
    dwExpectedType - Expected value type

Return Value:

    Status code

--*/

{
    DWORD   dwValueType;

    //
    // Check for following syntax error conditions:
    // 1. The entry requires an option keyword but no option keyword is present
    // 2. The entry doesn't require an option keyword but an option keyword is present
    //

    if ((dwExpectedType & REQ_OPTION) &&
        IS_BUFFER_EMPTY(&pParserData->Option))
    {
        return ISyntaxError(pParserData->pFile, "Missing option keyword");
    }

    if (! (dwExpectedType & REQ_OPTION) &&
        ! IS_BUFFER_EMPTY(&pParserData->Option))
    {
        return ISyntaxError(pParserData->pFile, "Extra option keyword");
    }

    //
    // Tolerate the following syntax error conditions:
    // 1. The entry requires a quoted value but a string value is provided.
    // 2. The entry requires a string value but a quoted value is provided.
    //

    switch (dwValueType = pParserData->dwValueType)
    {
    case VALUETYPE_STRING:

        if (dwExpectedType & VALUETYPE_QUOTED)
        {
            TERSE(("%ws: Expect QuotedValue instead of StringValue on line %d\n",
                   pParserData->pFile->ptstrFileName,
                   pParserData->pFile->iLineNumber));

            dwValueType = VALUETYPE_QUOTED;
        }
        break;

    case VALUETYPE_QUOTED:

        if (dwExpectedType & VALUETYPE_STRING)
        {
            TERSE(("%ws: Expect StringValue instead of QuotedValue on line %d\n",
                   pParserData->pFile->ptstrFileName,
                   pParserData->pFile->iLineNumber));

            if (IS_BUFFER_EMPTY(&pParserData->Value))
                return ISyntaxError(pParserData->pFile, "Empty string value");

            dwValueType = VALUETYPE_STRING;
        }
        break;
    }

    //
    // Return syntax error if the provided value type doesn't match what's expected
    //

    if ((dwExpectedType & dwValueType) == 0)
        return ISyntaxError(pParserData->pFile, "Value type mismatch");

    //
    // If the value field is a quoted string and one of the following conditions
    // is true, then we need to process any embedded hexdecimal strings within
    // the quoted string:
    // 1. The entry expects a QuotedValue.
    // 2. The entry expects an InvocationValue and appears inside JCLOpenUI/JCLCloseUI
    //

    if (dwValueType == VALUETYPE_QUOTED)
    {
        if ((dwExpectedType & ALLOW_HEX) ||
            ((dwExpectedType & VALUETYPE_MASK) == INVOCA_VALUE && pParserData->bJclFeature))
        {
            if (! BConvertHexString(&pParserData->Value))
                return ISyntaxError(pParserData->pFile, "Invalid embedded hexdecimal string");
        }
        else if (! BIs7BitAscii(pParserData->pstrValue))
        {
            //
            // Only allow 7-bit ASCII characters inside invocation string
            //

            return ISyntaxError(pParserData->pFile, "Non-printable ASCII character");
        }
    }

    return PPDERR_NONE;
}



BOOL
BGetIntegerFromString(
    PSTR   *ppstr,
    LONG   *plValue
    )

/*++

Routine Description:

    Parse an unsigned decimal integer value from a character string

Arguments:

    ppstr - Points to a string pointer. On entry, it contains a pointer
        to the beginning of the number string. On exit, it points to
        the first non-space character after the number string.
    plValue - Points to a variable for storing parsed number

Return Value:

    TRUE if a number is successfully parsed, FALSE if there is an error

--*/

{
    LONG    lValue;
    PSTR    pstr = *ppstr;
    BOOL    bNegative = FALSE;

    //
    // Skip any leading space characters and
    // look for the sign character (if any)
    //

    while (IS_SPACE(*pstr))
        pstr++;

    if (*pstr == '-')
    {
        bNegative = TRUE;
        pstr++;
    }

    if (! IS_DIGIT(*pstr))
    {
        TERSE(("Invalid integer number: %s\n", pstr));
        return FALSE;
    }

    //
    // NOTE: Overflow conditions are ignored.
    //

    lValue = 0;

    while (IS_DIGIT(*pstr))
        lValue = lValue * 10 + (*pstr++ - '0');

    //
    // Skip any trailing space characters
    //

    while (IS_SPACE(*pstr))
        pstr++;

    *ppstr = pstr;
    *plValue = bNegative ? -lValue : lValue;
    return TRUE;
}



BOOL
BGetFloatFromString(
    PSTR   *ppstr,
    PLONG   plValue,
    INT     iType
    )

/*++

Routine Description:

    Parse an unsigned floating-point number from a character string

Arguments:

    ppstr - Points to a string pointer. On entry, it contains a pointer
        to the beginning of the number string. On exit, it points to
        the first non-space character after the number string.
    plValue - Points to a variable for storing the parsed number
    iType - How to convert the floating-point number before returning
            FLTYPE_FIX - convert it to 24.8 format fixed-point number
            FLTYPE_INT - convert it to integer
            FLTYPE_POINT - convert it from point to micron
            FLTYPE_POINT_ROUNDUP - round it up and convert it from point to micron
            FLTYPE_POINT_ROUNDDOWN - round it down and convert it from point to micron

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    double  value, scale;
    PSTR    pstr = *ppstr;
    BOOL    bNegative = FALSE, bFraction = FALSE;

    //
    // Skip any leading space characters and
    // look for the sign character (if any)
    //

    while (IS_SPACE(*pstr))
        pstr++;

    if (*pstr == '-')
    {
        bNegative = TRUE;
        pstr++;
    }

    if (!IS_DIGIT(*pstr) && *pstr != '.')
    {
        TERSE(("Invalid floating-point number\n"));
        return FALSE;
    }

    //
    // Integer portion
    //

    value = 0.0;

    while (IS_DIGIT(*pstr))
        value = value * 10.0 + (*pstr++ - '0');

    //
    // Fractional portion
    //

    if (*pstr == '.')
    {
        bFraction = TRUE;
        pstr++;

        if (! IS_DIGIT(*pstr))
        {
            TERSE(("Invalid floating-point number\n"));
            return FALSE;
        }

        scale = 0.1;

        while (IS_DIGIT(*pstr))
        {
            value += scale * (*pstr++ - '0');
            scale *= 0.1;
        }
    }

    //
    // Skip any trailing space characters
    //

    while (IS_SPACE(*pstr))
        pstr++;

    //
    // Perform requested round up or round down only if
    // fractional portion is present.
    //

    if (bFraction)
    {
        if (iType == FLTYPE_POINT_ROUNDUP)
            value = ceil(value);
        else if (iType == FLTYPE_POINT_ROUNDDOWN)
            value = (LONG)value;
    }

    //
    // Convert the return value to the specified format
    //

    switch (iType)
    {
    case FLTYPE_POINT:
    case FLTYPE_POINT_ROUNDUP:
    case FLTYPE_POINT_ROUNDDOWN:

        value = (value * 25400.0) / 72.0;
        break;

    case FLTYPE_FIX:

        value *= FIX_24_8_SCALE;
        break;

    default:

        ASSERT(iType == FLTYPE_INT);
        break;
    }

    //
    // Guard against overflow conditions
    //

    if (value >= MAX_LONG)
    {
        TERSE(("Floating-point number overflow\n"));
        return FALSE;
    }

    *ppstr = pstr;
    *plValue = (LONG) (value + 0.5);

    if (bNegative)
    {
        TERSE(("Negative number treated as 0\n"));
        *plValue = 0;
    }

    return TRUE;
}



BOOL
BSearchStrTable(
    PCSTRTABLE  pTable,
    PSTR        pstrKeyword,
    DWORD      *pdwValue
    )

/*++

Routine Description:

    Search for a keyword from a string table

Arguments:

    pTable - Specifies the string table to be search
    pstrKeyword - Specifies the keyword we're interested in
    pdwValue - Points to a variable for storing value corresponding to the given keyword

Return Value:

    TRUE if the given keyword is found in the table, FALSE otherwise

--*/

{
    ASSERT(pstrKeyword != NULL);

    while (pTable->pstrKeyword != NULL &&
           strcmp(pTable->pstrKeyword, pstrKeyword) != EQUAL_STRING)
    {
        pTable++;
    }

    *pdwValue = pTable->dwValue;
    return (pTable->pstrKeyword != NULL);
}



PSTR
PstrParseString(
    PPARSERDATA pParserData,
    PBUFOBJ     pBufObj
    )

/*++

Routine Description:

    Duplicate a character string from a buffer object

Arguments:

    pParserData - Points to parser data structure
    pBufObj - Specifies the buffer object containing the character string to be duplicated

Return Value:

    Pointer to a copy of the specified string
    NULL if there is an error

--*/

{
    PSTR    pstr;

    ASSERT(! IS_BUFFER_EMPTY(pBufObj));

    if (pstr = ALLOC_PARSER_MEM(pParserData, pBufObj->dwSize + 1))
        CopyMemory(pstr, pBufObj->pbuf, pBufObj->dwSize + 1);
    else
        ERR(("Memory allocation failed: %d\n", GetLastError()));

    return pstr;
}



PPDERROR
IParseInvocation(
    PPARSERDATA pParserData,
    PINVOCOBJ   pInvocation
    )

/*++

Routine Description:

    Parse the content of value buffer to an invocation string

Arguments:

    pParserData - Points to parser data structure
    pInvocation - Specifies a buffer for storing the parsed invocation string

Return Value:

    Status code

--*/

{
    ASSERT(pInvocation->pvData == NULL);

    //
    // Determine if the invocation is a quoted string or a symbol reference.
    // In case of symbol reference, we save the name of the symbol in pvData
    // field (including the leading ^ character).
    //

    if (pParserData->dwValueType == VALUETYPE_SYMBOL)
    {
        PSTR    pstrSymbolName;

        if (! (pstrSymbolName = PstrParseString(pParserData, &pParserData->Value)))
            return PPDERR_MEMORY;

        pInvocation->pvData = pstrSymbolName;
        MARK_SYMBOL_INVOC(pInvocation);
    }
    else
    {
        PVOID   pvData;

        if (! (pvData = ALLOC_PARSER_MEM(pParserData, pParserData->Value.dwSize + 1)))
        {
            ERR(("Memory allocation failed\n"));
            return PPDERR_MEMORY;
        }

        pInvocation->pvData = pvData;
        pInvocation->dwLength = pParserData->Value.dwSize;
        ASSERT(! IS_SYMBOL_INVOC(pInvocation));

        CopyMemory(pvData, pParserData->Value.pbuf, pInvocation->dwLength + 1);
    }

    return PPDERR_NONE;
}



PPDERROR
IParseInteger(
    PPARSERDATA pParserData,
    PDWORD      pdwValue
    )

/*++

Routine Description:

    Intrepret the value field of an entry as unsigned integer

Arguments:

    pParserData - Points to parser data structure
    pdwValue - Points to a variable for storing parsed integer value

Return Value:

    Status code

--*/

{
    PSTR    pstr = pParserData->pstrValue;
    LONG    lValue;

    if (BGetIntegerFromString(&pstr, &lValue))
    {
        if (lValue >= 0)
        {
            *pdwValue = lValue;
            return PPDERR_NONE;

        } else
            TERSE(("Negative integer value not allowed: %s.\n", pParserData->pstrValue));
    }

    *pdwValue = 0;
    return PPDERR_SYNTAX;
}



PPDERROR
IParseBoolean(
    PPARSERDATA pParserData,
    DWORD      *pdwValue
    )

/*++

Routine Description:

    Interpret the value of an entry as a boolen, i.e. True or False

Arguments:

    pParserData - Points to parser data structure
    pdwValue - Points to a variable for storing the parsed boolean value

Return Value:

    Status code

--*/

{
    static const STRTABLE BooleanStrs[] =
    {
        gstrTrueKwd,    TRUE,
        gstrFalseKwd,   FALSE,
        NULL,           FALSE
    };

    if (! BSearchStrTable(BooleanStrs, pParserData->pstrValue, pdwValue))
        return ISyntaxError(pParserData->pFile, "Invalid boolean constant");

    return PPDERR_NONE;
}



BOOL
BFindNextWord(
    PSTR   *ppstr,
    PSTR    pstrWord
    )

/*++

Routine Description:

    Find the next word in a character string. Words are separated by spaces.

Arguments:

    ppstr - Points to a string pointer. On entry, it contains a pointer
        to the beginning of the word string. On exit, it points to
        the first non-space character after the word string.
    pstrWord - Points to a buffer for storing characters from the next word
        The size of this buffer must be at least MAX_WORD_LEN characters

Return Value:

    TRUE if next word is found, FALSE otherwise

--*/

{
    PSTR    pstr = *ppstr;

    pstrWord[0] = NUL;

    //
    // Skip any leading spaces
    //

    while (IS_SPACE(*pstr))
        pstr++;

    if (*pstr != NUL)
    {
        PSTR    pstrStart;
        INT     iWordLen;

        //
        // Go to the end of the word
        //

        pstrStart = pstr;

        while (*pstr && !IS_SPACE(*pstr))
            pstr++;

        //
        // Copy the word into the specified buffer
        //

        if ((iWordLen = (INT)(pstr - pstrStart)) < MAX_WORD_LEN)
        {
            CopyMemory(pstrWord, pstrStart, iWordLen);
            pstrWord[iWordLen] = NUL;
        }

        //
        // Skip to the next non-space character
        //

        while (IS_SPACE(*pstr))
            pstr++;
    }

    *ppstr = pstr;
    return (*pstrWord != NUL);
}



PPDERROR
IParseVersionNumber(
    PPARSERDATA pParserData,
    PDWORD      pdwVersion
    )

/*++

Routine Description:

    Parse a version number. The format of a version number is Version[.Revision]
    where both Version and Revision are integers.

Arguments:

    pParserData - Points to parser data structure
    pdwVersion - Points to a variable for storing the parsed version number

Return Value:

    Status code

--*/

{
    PSTR        pstr;
    LONG        lVersion, lRevision = 0;

    //
    // Parse the major version number followed by minor revision number
    //

    pstr = pParserData->pstrValue;

    if (! BGetIntegerFromString(&pstr, &lVersion))
        return ISyntaxError(pParserData->pFile, "Invalid version number");

    if (*pstr == '.')
    {
        pstr++;

        if (! BGetIntegerFromString(&pstr, &lRevision))
            return ISyntaxError(pParserData->pFile, "Invalid revision number");
    }

    //
    // High-order word contains version number and
    // low-order word contains revision number
    //

    if (lVersion < 0  || lVersion > MAX_WORD ||
        lRevision < 0 || lRevision > MAX_WORD)
    {
        return ISyntaxError(pParserData->pFile, "Version number out-of-range");
    }

    *pdwVersion = (lVersion << 16) | lRevision;
    return PPDERR_NONE;
}



PPDERROR
IParseXlation(
    PPARSERDATA pParserData,
    PINVOCOBJ   pXlation
    )

/*++

Routine Description:

    Parse the information in the translation string field to an INVOCOBJ

Arguments:

    pParserData - Points to parser data structure
    pXlation - Returns information about parsed translation string

Return Value:

    Status code

--*/

{
    PBUFOBJ pBufObj = &pParserData->Xlation;

    //
    // Allocate memory to hold the translation string (plus a null terminator)
    //

    pXlation->pvData = ALLOC_PARSER_MEM(pParserData, pBufObj->dwSize + 1);

    if (pXlation->pvData == NULL)
    {
        ERR(("Memory allocation failed\n"));
        return PPDERR_MEMORY;
    }

    pXlation->dwLength = pBufObj->dwSize;
    ASSERT(! IS_SYMBOL_INVOC(pXlation));
    CopyMemory(pXlation->pvData, pBufObj->pbuf, pBufObj->dwSize);

    return PPDERR_NONE;
}



PCSTR
PstrStripKeywordChar(
    PCSTR   pstrKeyword
    )

/*++

Routine Description:

    Strip off the keyword prefix character from the input string

Arguments:

    pstrKeyword - Points to a string prefixed by the keyword character

Return Value:

    Pointer to the keyword string after the keyword character is stripped
    NULL if the keyword string is empty

--*/

{
    if (IS_KEYWORD_CHAR(*pstrKeyword))
        pstrKeyword++;

    return *pstrKeyword ? pstrKeyword : NULL;
}



PVOID
PvCreateListItem(
    PPARSERDATA pParserData,
    PLISTOBJ   *ppList,
    DWORD       dwItemSize,
    PSTR        pstrListTag
    )

/*++

Routine Description:

    Create a new item in the specified linked-list
    Make sure no existing item has the same name

Arguments:

    pParserData - Points to parser data structure
    ppList - Specifies the linked-list
    dwItemSize - Linked-list item size
    pListTag - Specifies the name of the linked-list (for debugging purpose)

Return Value:

    Pointer to newly created linked-list item
    NULL if there is an error

--*/

{
    PLISTOBJ    pItem;
    PSTR        pstrItemName;

    //
    // Check if the item appeared in the list already
    // Create a new item data structure if not
    //

    pItem = PvFindListItem(*ppList, pParserData->Option.pbuf, NULL);

    if (pItem != NULL)
    {
        if (pstrListTag)
            TERSE(("%s %s redefined\n", pstrListTag, pItem->pstrName));
    }
    else
    {
        if (! (pItem = ALLOC_PARSER_MEM(pParserData, dwItemSize)) ||
            ! (pstrItemName = PstrParseString(pParserData, &pParserData->Option)))
        {
            ERR(("Memory allocation failed: %d\n", GetLastError()));
            return NULL;
        }

        pItem->pstrName = pstrItemName;
        pItem->pNext = NULL;

        //
        // Put the newly created item at the end of the linked-list
        //

        while (*ppList != NULL)
            ppList = (PLISTOBJ *) &((*ppList)->pNext);

        *ppList = pItem;
    }

    return pItem;
}



PFEATUREOBJ
PCreateFeatureItem(
    PPARSERDATA pParserData,
    DWORD       dwFeatureID
    )

/*++

Routine Description:

    Create a new printer feature structure or find an existing one

Arguments:

    pParserData - Points to parser data structure
    dwFeatureID - Printer feature identifier

Return Value:

    Pointer to a newly created or an existing printer feature structure
    NULL if there is an error

--*/

{
    static struct {

        PCSTR   pstrKeyword;
        DWORD   dwFeatureID;
        DWORD   dwOptionSize;

    } FeatureInfo[] = {

        gstrPageSizeKwd,  GID_PAGESIZE,     sizeof(PAPEROBJ),
        "PageRegion",     GID_PAGEREGION,   sizeof(OPTIONOBJ),
        "Duplex",         GID_DUPLEX,       sizeof(OPTIONOBJ),
        gstrInputSlotKwd, GID_INPUTSLOT,    sizeof(TRAYOBJ),
        "Resolution",     GID_RESOLUTION,   sizeof(RESOBJ),
        "JCLResolution",  GID_RESOLUTION,   sizeof(RESOBJ),
        "OutputBin",      GID_OUTPUTBIN,    sizeof(BINOBJ),
        "MediaType",      GID_MEDIATYPE,    sizeof(OPTIONOBJ),
        "Collate",        GID_COLLATE,      sizeof(OPTIONOBJ),
        "InstalledMemory",GID_MEMOPTION,    sizeof(MEMOBJ),
        "LeadingEdge",    GID_LEADINGEDGE,  sizeof(OPTIONOBJ),
        "UseHWMargins",   GID_USEHWMARGINS, sizeof(OPTIONOBJ),
        NULL,             GID_UNKNOWN,      sizeof(OPTIONOBJ)
    };

    PFEATUREOBJ pFeature;
    PCSTR       pstrKeyword;
    BUFOBJ      SavedBuffer;
    INT         iIndex = 0;

    if (dwFeatureID == GID_UNKNOWN)
    {
        //
        // Given a feature name, first find out if it refers to
        // one of the predefined features
        //

        pstrKeyword = PstrStripKeywordChar(pParserData->achOption);
        ASSERT(pstrKeyword != NULL);

        while (FeatureInfo[iIndex].pstrKeyword &&
               strcmp(FeatureInfo[iIndex].pstrKeyword, pstrKeyword) != EQUAL_STRING)
        {
            iIndex++;
        }

        if (FeatureInfo[iIndex].pstrKeyword)
            pParserData->aubOpenUIFeature[FeatureInfo[iIndex].dwFeatureID] = 1;
    }
    else
    {
        //
        // We're given a predefined feature identifier.
        // Map to its corresponding feature name.
        //

        while (FeatureInfo[iIndex].pstrKeyword &&
               dwFeatureID != FeatureInfo[iIndex].dwFeatureID)
        {
            iIndex++;
        }

        pstrKeyword = FeatureInfo[iIndex].pstrKeyword;
        ASSERT(pstrKeyword != NULL);
    }

    //
    // If we're dealing with a predefined feature, the first search the current
    // list of printer features based on the predefined feature identifier.
    //

    pFeature = NULL;

    if (FeatureInfo[iIndex].dwFeatureID != GID_UNKNOWN)
    {
        for (pFeature = pParserData->pFeatures;
             pFeature && pFeature->dwFeatureID != FeatureInfo[iIndex].dwFeatureID;
             pFeature = pFeature->pNext)
        {
        }
    }

    //
    // Create a new printer feature item or find an existing printer feature item
    // based on the feature name.
    //

    if (pFeature == NULL)
    {
        SavedBuffer = pParserData->Option;
        pParserData->Option.pbuf = (PBYTE) pstrKeyword;
        pParserData->Option.dwSize = strlen(pstrKeyword);

        pFeature = PvCreateListItem(pParserData,
                                    (PLISTOBJ *) &pParserData->pFeatures,
                                    sizeof(FEATUREOBJ),
                                    NULL);

        pParserData->Option = SavedBuffer;
    }

    if (pFeature)
    {
        //
        // Parse the translation string for the feature name
        //

        if (dwFeatureID == GID_UNKNOWN &&
            ! IS_BUFFER_EMPTY(&pParserData->Xlation) &&
            ! pFeature->Translation.pvData &&
            IParseXlation(pParserData, &pFeature->Translation) != PPDERR_NONE)
        {
            ERR(("Failed to parse feature name translation string\n"));
            return NULL;
        }

        if (pFeature->dwOptionSize == 0)
        {
            //
            // Store information about newly created feature item
            //

            pFeature->dwOptionSize = FeatureInfo[iIndex].dwOptionSize;
            pFeature->dwFeatureID = FeatureInfo[iIndex].dwFeatureID;

            //
            // All predefined features are doc-sticky except for InstalledMemory/VMOption
            //

            if (pFeature->dwFeatureID == GID_MEMOPTION ||
                pFeature->dwFeatureID == GID_UNKNOWN && pParserData->bInstallableGroup)
            {
                pFeature->bInstallable = TRUE;
            }
        }
    }
    else
    {
        ERR(("Couldn't create printer feature item for: %s\n", pstrKeyword));
    }

    return pFeature;
}



PVOID
PvCreateXlatedItem(
    PPARSERDATA pParserData,
    PVOID       ppList,
    DWORD       dwItemSize
    )

/*++

Routine Description:

    Create a feature option item and parse the associated translation string

Arguments:

    pParserData - Points to parser data structure
    ppList - Points to the list of feature option items
    dwItemSize - Size of a feature option item

Return Value:

    Pointer to newly created feature option item
    NULL if there is an error

--*/

{
    POPTIONOBJ  pOption;

    if (! (pOption = PvCreateListItem(pParserData, ppList, dwItemSize, NULL)) ||
        (! IS_BUFFER_EMPTY(&pParserData->Xlation) &&
         ! pOption->Translation.pvData &&
         IParseXlation(pParserData, &pOption->Translation) != PPDERR_NONE))
    {
        ERR(("Couldn't process entry: *%s %s\n",
             pParserData->achKeyword,
             pParserData->achOption));

        return NULL;
    }

    return pOption;
}



PVOID
PvCreateOptionItem(
    PPARSERDATA pParserData,
    DWORD       dwFeatureID
    )

/*++

Routine Description:

    Create a feature option item for a predefined printer feature

Arguments:

    pParserData - Points to parser data structure
    dwFeatureID - Specifies a predefined feature identifier

Return Value:

    Pointer to an existing feature option item or a newly created one if none exists
    NULL if there is an error

--*/

{
    PFEATUREOBJ pFeature;

    ASSERT(dwFeatureID != GID_UNKNOWN);

    if (! (pFeature = PCreateFeatureItem(pParserData, dwFeatureID)))
        return NULL;

    return PvCreateXlatedItem(pParserData, &pFeature->pOptions, pFeature->dwOptionSize);
}



INT
ICountFeatureList(
    PFEATUREOBJ pFeature,
    BOOL        bInstallable
    )

{
    INT i = 0;

    //
    // Count the number of features of the specified type
    //

    while (pFeature != NULL)
    {
        if (pFeature->bInstallable == bInstallable)
            i++;

        pFeature = pFeature->pNext;
    }

    return i;
}



PPDERROR
IGenericOptionProc(
    PPARSERDATA pParserData,
    PFEATUREOBJ pFeature
    )

/*++

Routine Description:

    Function for handling a generic feature option entry

Arguments:

    pParserData - Points to parser data structure
    pFeature - Points to feature data structure

Return Value:

    Status code

--*/

{
    POPTIONOBJ  pOption;

    //
    // Handle special case
    //

    if (pFeature == NULL)
        return PPDERR_MEMORY;

    //
    // Create a feature option item and parse the option name and translation string
    //

    if (! (pOption = PvCreateXlatedItem(pParserData, &pFeature->pOptions, pFeature->dwOptionSize)))
        return PPDERR_MEMORY;

    if (pOption->Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // Parse the invocation string
    //

    return IParseInvocation(pParserData, &pOption->Invocation);
}



PPDERROR
IGenericDefaultProc(
    PPARSERDATA pParserData,
    PFEATUREOBJ pFeature
    )

/*++

Routine Description:

    Function for handling a generic default option entry

Arguments:

    pParserData - Points to parser data structure
    pFeature - Points to feature data structure

Return Value:

    Status code

--*/

{
    //
    // Check if there is a memory error before this function is called
    //

    if (pFeature == NULL)
        return PPDERR_MEMORY;

    //
    // Watch out for duplicate *Default entries for the same feature
    //

    if (pFeature->pstrDefault)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // NOTE: Hack to take in account of a bug in NT4 driver.
    // This is used to build up NT4-NT5 feature index mapping.
    //

    if (pFeature->dwFeatureID == GID_MEMOPTION &&
        pParserData->iDefInstallMemIndex < 0)
    {
        pParserData->iDefInstallMemIndex = ICountFeatureList(pParserData->pFeatures, TRUE);
    }

    //
    // Remember the default option keyword
    //

    if (pFeature->pstrDefault = PstrParseString(pParserData, &pParserData->Value))
        return PPDERR_NONE;
    else
        return PPDERR_MEMORY;
}



PPDERROR
IGenericQueryProc(
    PPARSERDATA pParserData,
    PFEATUREOBJ pFeature
    )

/*++

Routine Description:

    Function for handling a generic query invocation entry

Arguments:

    pParserData - Points to parser data structure
    pFeature - Points to feature data structure

Return Value:

    Status code

--*/

{
    //
    // Check if there is a memory error before this function is called
    //

    if (pFeature == NULL)
        return PPDERR_MEMORY;

    //
    // Watch out for duplicate *Default entries for the same feature
    //

    if (pFeature->QueryInvoc.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // Parse the query invocation string
    //

    return IParseInvocation(pParserData, &pFeature->QueryInvoc);
}



//
// Functions for handling predefined PPD keywords
//

//
// Specifies the imageable area of a media option
//

PPDERROR
IImageAreaProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pOption;
    PSTR        pstr;
    RECT        *pRect;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_PAGESIZE)))
        return PPDERR_MEMORY;

    pRect = &pOption->rcImageArea;

    if (pRect->top > 0 || pRect->right > 0)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // Parse imageable area: left, bottom, right, top
    //

    pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &pRect->left, FLTYPE_POINT_ROUNDUP) ||
        ! BGetFloatFromString(&pstr, &pRect->bottom, FLTYPE_POINT_ROUNDUP) ||
        ! BGetFloatFromString(&pstr, &pRect->right, FLTYPE_POINT_ROUNDDOWN) ||
        ! BGetFloatFromString(&pstr, &pRect->top, FLTYPE_POINT_ROUNDDOWN) ||
        pRect->left >= pRect->right || pRect->bottom >= pRect->top)
    {
        return ISyntaxError(pParserData->pFile, "Invalid imageable area");
    }

    return PPDERR_NONE;
}

//
// Specifies the paper dimension of a media option
//

PPDERROR
IPaperDimProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pOption;
    PSTR        pstr;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_PAGESIZE)))
        return PPDERR_MEMORY;

    if (pOption->szDimension.cx > 0 || pOption->szDimension.cy > 0)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // Parse paper width and height
    //

    pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &pOption->szDimension.cx, FLTYPE_POINT) ||
        ! BGetFloatFromString(&pstr, &pOption->szDimension.cy, FLTYPE_POINT))
    {
        return ISyntaxError(pParserData->pFile, "Invalid paper dimension");
    }

    return PPDERR_NONE;
}

//
// Interpret PageStackOrder and OutputOrder options
//

BOOL
BParseOutputOrder(
    PSTR    pstr,
    PBOOL   pbValue
    )

{
    static const STRTABLE OutputOrderStrs[] =
    {
        "Normal",   FALSE,
        "Reverse",  TRUE,
        NULL,       FALSE
    };

    DWORD   dwValue;
    BOOL    bResult;

    bResult = BSearchStrTable(OutputOrderStrs, pstr, &dwValue);

    *pbValue = dwValue;
    return bResult;
}

//
// Specifies the page stack order for an output bin
//

PPDERROR
IPageStackOrderProc(
    PPARSERDATA pParserData
    )

{
    PFEATUREOBJ pFeature;
    PBINOBJ     pOutputBin;

    //
    // Have we seen the OutputBin feature yet?
    //

    for (pFeature = pParserData->pFeatures;
         pFeature && pFeature->dwFeatureID != GID_OUTPUTBIN;
         pFeature = pFeature->pNext)
    {
    }

    //
    // If PageStackOrder entry appears before OutputBin feature, ignore it
    //

    if (pFeature == NULL)
    {
        BOOL bReverse;
        if (!BParseOutputOrder(pParserData->pstrValue, &bReverse))
            return ISyntaxError(pParserData->pFile, "Invalid PageStackOrder option");
        if (bReverse)
            TERSE(("%ws: Ignored *PageStackOrder: Reverse on line %d because OutputBin not yet defined\n",
                       pParserData->pFile->ptstrFileName,
                       pParserData->pFile->iLineNumber));

        return PPDERR_NONE;
    }

    //
    // Add an option for OutputBin feature
    //

    pOutputBin = PvCreateXlatedItem(pParserData, &pFeature->pOptions, pFeature->dwOptionSize);

    if (pOutputBin == NULL)
        return PPDERR_MEMORY;

    return BParseOutputOrder(pParserData->pstrValue, &pOutputBin->bReversePrint) ?
                PPDERR_NONE :
                ISyntaxError(pParserData->pFile, "Invalid PageStackOrder option");
}

//
// Specifies the default page output order
// NOTE: This function gets called only if *DefaultOutputOrder
// entry appears outside of OpenUI/CloseUI.
//

PPDERROR
IDefOutputOrderProc(
    PPARSERDATA pParserData
    )

{
    pParserData->bDefOutputOrderSet = BParseOutputOrder(pParserData->pstrValue, &pParserData->bDefReversePrint);

    return pParserData->bDefOutputOrderSet ?
                PPDERR_NONE :
                ISyntaxError(pParserData->pFile, "Invalid DefaultOutputOrder option");
}

//
// Specifies whether an input slot requires page region specification
//

PPDERROR
IReqPageRgnProc(
    PPARSERDATA pParserData
    )

{
    PTRAYOBJ    pOption;
    DWORD       dwValue;

    //
    // NOTE: Hack for doing NT4-NT5 feature index conversion
    //

    if (pParserData->iReqPageRgnIndex < 0)
    {
        PFEATUREOBJ pFeature = pParserData->pFeatures;

        while (pFeature && pFeature->dwFeatureID != GID_INPUTSLOT)
            pFeature = pFeature->pNext;

        if (pFeature == NULL)
            pParserData->iReqPageRgnIndex = ICountFeatureList(pParserData->pFeatures, FALSE);
    }

    //
    // The value should be either True or False
    //

    if (IParseBoolean(pParserData, &dwValue) != PPDERR_NONE)
        return PPDERR_SYNTAX;

    dwValue = dwValue ? REQRGN_TRUE : REQRGN_FALSE;

    //
    // *RequiresPageRegion All: entry has special meaning
    //

    if (strcmp(pParserData->achOption, "All") == EQUAL_STRING)
    {
        if (pParserData->dwReqPageRgn == REQRGN_UNKNOWN)
            pParserData->dwReqPageRgn = dwValue;
        else
            WARN_DUPLICATE();
    }
    else
    {
        if (! (pOption = PvCreateOptionItem(pParserData, GID_INPUTSLOT)))
            return PPDERR_MEMORY;

        if (pOption->dwReqPageRgn == REQRGN_UNKNOWN)
            pOption->dwReqPageRgn = dwValue;
        else
            WARN_DUPLICATE();
    }

    return PPDERR_NONE;
}

//
// Specifies Duplex feature options
//

PPDERROR
IDefaultDuplexProc(
    PPARSERDATA pParserData
    )

{
    return IGenericDefaultProc(pParserData,
                               PCreateFeatureItem(pParserData, GID_DUPLEX));
}

PPDERROR
IDuplexProc(
    PPARSERDATA pParserData
    )

{
    if (strcmp(pParserData->achOption, gstrNoneKwd) != EQUAL_STRING &&
        strcmp(pParserData->achOption, gstrDuplexTumble) != EQUAL_STRING &&
        strcmp(pParserData->achOption, gstrDuplexNoTumble) != EQUAL_STRING)
    {
        return ISyntaxError(pParserData->pFile, "Invalid Duplex option");
    }

    return IGenericOptionProc(pParserData,
                              PCreateFeatureItem(pParserData, GID_DUPLEX));
}

//
// Specifies ManualFeed True/False invocation strings
//

PPDERROR
IDefManualFeedProc(
    PPARSERDATA pParserData
    )

{
    //
    // NOTE: Hack for doing NT4-NT5 feature index conversion
    //

    if (pParserData->iManualFeedIndex < 0)
        pParserData->iManualFeedIndex = ICountFeatureList(pParserData->pFeatures, FALSE);

    return PPDERR_NONE;
}

PPDERROR
IManualFeedProc(
    PPARSERDATA pParserData
    )

{
    POPTIONOBJ  pOption;
    INT         iResult = PPDERR_NONE;

    //
    // NOTE: Hack for doing NT4-NT5 feature index conversion
    //

    if (pParserData->iManualFeedIndex < 0)
        pParserData->iManualFeedIndex = ICountFeatureList(pParserData->pFeatures, FALSE);

    if (strcmp(pParserData->achOption, gstrTrueKwd) == EQUAL_STRING ||
        strcmp(pParserData->achOption, gstrOnKwd) == EQUAL_STRING)
    {
        //
        // The way manual feed is handled in PPD spec is incredibly klugy.
        // Hack here to treat *ManualFeed True as one of the input slot
        // selections so that downstream component can handle it uniformly.
        //

        StringCchCopyA(pParserData->achOption, CCHOF(pParserData->achOption), gstrManualFeedKwd);

        pParserData->Option.dwSize = strlen(gstrManualFeedKwd);

        StringCchCopyA(pParserData->achXlation, CCHOF(pParserData->achXlation), "");

        pParserData->Xlation.dwSize = 0;

        if (! (pOption = PvCreateOptionItem(pParserData, GID_INPUTSLOT)))
        {
            iResult = PPDERR_MEMORY;
        }
        else if (pOption->Invocation.pvData)
        {
            TERSE(("%ws: Duplicate entries of '*ManualFeed True' on line %d\n",
                   pParserData->pFile->ptstrFileName,
                   pParserData->pFile->iLineNumber));
        }
        else
        {
            ((PTRAYOBJ) pOption)->dwTrayIndex = DMBIN_MANUAL;
            iResult = IParseInvocation(pParserData, &pOption->Invocation);
        }
    }
    else if (strcmp(pParserData->achOption, gstrFalseKwd) == EQUAL_STRING ||
             strcmp(pParserData->achOption, gstrNoneKwd) == EQUAL_STRING ||
             strcmp(pParserData->achOption, gstrOffKwd) == EQUAL_STRING)
    {
        //
        // Save *ManualFeed False invocation string separately.
        // It's always emitted before any tray invocation string.
        //

        if (pParserData->ManualFeedFalse.pvData)
        {
            WARN_DUPLICATE();
        }
        else
        {
            iResult = IParseInvocation(pParserData, &pParserData->ManualFeedFalse);
        }
    }
    else
    {
        iResult = ISyntaxError(pParserData->pFile, "Unrecognized ManualFeed option");
    }

    return iResult;
}

//
// Specifies JCLResolution invocation string
//

PPDERROR
IJCLResProc(
    PPARSERDATA pParserData
    )

{
    POPTIONOBJ  pOption;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_RESOLUTION)))
        return PPDERR_MEMORY;

    if (pOption->Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    pParserData->dwSetResType = RESTYPE_JCL;
    return IParseInvocation(pParserData, &pOption->Invocation);
}

//
// Specifies the default JCLResolution option
//

PPDERROR
IDefaultJCLResProc(
    PPARSERDATA pParserData
    )

{
    return IGenericDefaultProc(pParserData,
                               PCreateFeatureItem(pParserData, GID_RESOLUTION));
}

//
// Specifies SetResolution invocation string
//

PPDERROR
ISetResProc(
    PPARSERDATA pParserData
    )

{
    POPTIONOBJ  pOption;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_RESOLUTION)))
        return PPDERR_MEMORY;

    if (pOption->Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    pParserData->dwSetResType = RESTYPE_EXITSERVER;
    return IParseInvocation(pParserData, &pOption->Invocation);
}

//
// Specifies default halftone screen angle
//

PPDERROR
IScreenAngleProc(
    PPARSERDATA pParserData
    )

{
    PSTR    pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &pParserData->fxScreenAngle, FLTYPE_FIX))
        return ISyntaxError(pParserData->pFile, "Invalid screen angle");

    return PPDERR_NONE;
}

//
// Specifies default halftone screen frequency
//

PPDERROR
IScreenFreqProc(
    PPARSERDATA pParserData
    )

{
    PSTR    pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &pParserData->fxScreenFreq, FLTYPE_FIX) ||
        pParserData->fxScreenFreq <= 0)
    {
        return ISyntaxError(pParserData->pFile, "Invalid screen frequency");
    }
    else
        return PPDERR_NONE;
}

//
// Specifies default halftone screen angle for a resolution option
//

PPDERROR
IResScreenAngleProc(
    PPARSERDATA pParserData
    )

{
    PRESOBJ pOption;
    PSTR    pstr = pParserData->pstrValue;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_RESOLUTION)))
        return PPDERR_MEMORY;

    if (! BGetFloatFromString(&pstr, &pOption->fxScreenAngle, FLTYPE_FIX))
        return ISyntaxError(pParserData->pFile, "Invalid screen angle");

    return PPDERR_NONE;
}

//
// Specifies default halftone screen frequency for a resolution option
//

PPDERROR
IResScreenFreqProc(
    PPARSERDATA pParserData
    )

{
    PRESOBJ pOption;
    PSTR    pstr = pParserData->pstrValue;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_RESOLUTION)))
        return PPDERR_MEMORY;

    if (! BGetFloatFromString(&pstr, &pOption->fxScreenFreq, FLTYPE_FIX) ||
        pOption->fxScreenFreq <= 0)
    {
        return ISyntaxError(pParserData->pFile, "Invalid screen frequency");
    }
    else
        return PPDERR_NONE;
}

//
// Specifies device font information
//

PPDERROR
IFontProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE FontStatusStrs[] =
    {
        "ROM",      FONTSTATUS_ROM,
        "Disk",     FONTSTATUS_DISK,
        NULL,       FONTSTATUS_UNKNOWN
    };

    PFONTREC    pFont;
    PSTR        pstr;
    CHAR        achWord[MAX_WORD_LEN];
    DWORD       cbSize;

    //
    // Create a new device font item
    //

    if (! (pFont = PvCreateXlatedItem(pParserData, &pParserData->pFonts, sizeof(FONTREC))))
        return PPDERR_MEMORY;

    if (pFont->pstrEncoding != NULL)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // encoding
    //

    pstr = pParserData->pstrValue;

    if (! BFindNextWord(&pstr, achWord))
        return ISyntaxError(pParserData->pFile, "Invalid *Font entry");

    cbSize = strlen(achWord) + 1;
    if (! (pFont->pstrEncoding = ALLOC_PARSER_MEM(pParserData, cbSize)))
        return PPDERR_MEMORY;

    StringCchCopyA(pFont->pstrEncoding, cbSize / sizeof(char), achWord);

    //
    // version
    //

    (VOID) BFindNextWord(&pstr, achWord);

    {
        PSTR    pstrStart, pstrEnd;

        if (pstrStart = strchr(achWord, '('))
            pstrStart++;
        else
            pstrStart = achWord;

        if (pstrEnd = strrchr(pstrStart, ')'))
            *pstrEnd = NUL;

        cbSize = strlen(pstrStart) + 1;
        if (! (pFont->pstrVersion = ALLOC_PARSER_MEM(pParserData, cbSize)))
            return PPDERR_MEMORY;

        StringCchCopyA(pFont->pstrVersion, cbSize / sizeof(char), pstrStart);
    }

    //
    // charset
    //

    (VOID) BFindNextWord(&pstr, achWord);

    cbSize = strlen(achWord) + 1;
    if (! (pFont->pstrCharset = ALLOC_PARSER_MEM(pParserData, cbSize)))
        return PPDERR_MEMORY;

    StringCchCopyA(pFont->pstrCharset, cbSize / sizeof(char), achWord);

    //
    // status
    //

    (VOID) BFindNextWord(&pstr, achWord);
    (VOID) BSearchStrTable(FontStatusStrs, achWord, &pFont->dwStatus);

    return PPDERR_NONE;
}

//
// Specifies the default device font
//

PPDERROR
IDefaultFontProc(
    PPARSERDATA pParserData
    )

{
    if (strcmp(pParserData->pstrValue, "Error") == EQUAL_STRING)
        pParserData->pstrDefaultFont = NULL;
    else if (! (pParserData->pstrDefaultFont = PstrParseString(pParserData, &pParserData->Value)))
        return PPDERR_MEMORY;

    return PPDERR_NONE;
}

//
// Mark the beginning of a new printer feature section
//

PPDERROR
IOpenUIProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE UITypeStrs[] =
    {
        "PickOne",  UITYPE_PICKONE,
        "PickMany", UITYPE_PICKMANY,
        "Boolean",  UITYPE_BOOLEAN,
        NULL,       UITYPE_PICKONE
    };

    PCSTR   pstrKeyword;

    //
    // Guard against nested or unbalanced OpenUI
    //

    if (pParserData->pOpenFeature != NULL)
    {
        TERSE(("Missing CloseUI for *%s\n", pParserData->pOpenFeature->pstrName));
        pParserData->pOpenFeature = NULL;
    }

    //
    // Make sure the keyword is well-formed
    //

    if (! (pstrKeyword = PstrStripKeywordChar(pParserData->achOption)))
        return ISyntaxError(pParserData->pFile, "Empty keyword");

    //
    // HACK: special-case handling of "*OpenUI: *ManualFeed" entry
    //

    if (strcmp(pstrKeyword, gstrManualFeedKwd) == EQUAL_STRING)
        return PPDERR_NONE;

    if (! (pParserData->pOpenFeature = PCreateFeatureItem(pParserData, GID_UNKNOWN)))
        return PPDERR_MEMORY;

    //
    // Determine the type of feature option list
    //

    if (! BSearchStrTable(UITypeStrs,
                          pParserData->pstrValue,
                          &pParserData->pOpenFeature->dwUIType))
    {
        ISyntaxError(pParserData->pFile, "Unrecognized UI type");
    }

    //
    // Are we dealing with JCLOpenUI?
    //

    pParserData->bJclFeature = HAS_JCL_PREFIX(pstrKeyword);
    return PPDERR_NONE;
}

//
// Mark the end of a new printer feature section
//

PPDERROR
ICloseUIProc(
    PPARSERDATA pParserData
    )

{
    PCSTR       pstrKeyword;
    PFEATUREOBJ pOpenFeature;

    //
    // Make sure the CloseUI entry is balanced with a previous OpenUI entry
    //

    pOpenFeature = pParserData->pOpenFeature;
    pParserData->pOpenFeature = NULL;
    pstrKeyword = PstrStripKeywordChar(pParserData->pstrValue);

    //
    // HACK: special-case handling of "*CloseUI: *ManualFeed" entry
    //

    if (pstrKeyword && strcmp(pstrKeyword, gstrManualFeedKwd) == EQUAL_STRING)
        return PPDERR_NONE;

    if (pOpenFeature == NULL ||
        pstrKeyword == NULL ||
        strcmp(pstrKeyword, pOpenFeature->pstrName) != EQUAL_STRING ||
        pParserData->bJclFeature != HAS_JCL_PREFIX(pstrKeyword))
    {
        return ISyntaxError(pParserData->pFile, "Invalid CloseUI entry");
    }

    return PPDERR_NONE;
}

//
// Process OpenGroup and CloseGroup entries
//
// !!! OpenGroup, CloseGroup, OpenSubGroup, and CloseSubGroup
// keywords are not completely supported. Currently, we
// only pay specific attention to the InstallableOptions group.
//
// If the group information is needed in the future by the
// user interface, the following functions should be beefed up.
//

PPDERROR
IOpenCloseGroupProc(
    PPARSERDATA pParserData,
    BOOL        bOpenGroup
    )

{
    PSTR    pstrGroupName = pParserData->pstrValue;

    //
    // We're only interested in the InstallableOptions group
    //

    if (strcmp(pstrGroupName, "InstallableOptions") == EQUAL_STRING)
    {
        if (pParserData->bInstallableGroup == bOpenGroup)
            return ISyntaxError(pParserData->pFile, "Unbalanced OpenGroup/CloseGroup");

        pParserData->bInstallableGroup = bOpenGroup;
    }
    else
    {
        VERBOSE(("Group %s ignored\n", pstrGroupName));
    }

    return PPDERR_NONE;
}

//
// Process OpenGroup entries
//

PPDERROR
IOpenGroupProc(
    PPARSERDATA pParserData
    )

{
    return IOpenCloseGroupProc(pParserData, TRUE);
}

//
// Process CloseGroup entries
//

PPDERROR
ICloseGroupProc(
    PPARSERDATA pParserData
    )

{
    return IOpenCloseGroupProc(pParserData, FALSE);
}

//
// Handle OpenSubGroup entries
//

PPDERROR
IOpenSubGroupProc(
    PPARSERDATA pParserData
    )

{
    return PPDERR_NONE;
}

//
// Handle CloseSubGroup entries
//

PPDERROR
ICloseSubGroupProc(
    PPARSERDATA pParserData
    )

{
    return PPDERR_NONE;
}

//
// Parse a UIConstraints entry
//

PPDERROR
IUIConstraintsProc(
    PPARSERDATA pParserData
    )

{
    PLISTOBJ    pItem;

    if (! (pItem = ALLOC_PARSER_MEM(pParserData, sizeof(LISTOBJ))) ||
        ! (pItem->pstrName = PstrParseString(pParserData, &pParserData->Value)))
    {
        ERR(("Memory allocation failed\n"));
        return PPDERR_MEMORY;
    }

    pItem->pNext = pParserData->pUIConstraints;
    pParserData->pUIConstraints = pItem;
    return PPDERR_NONE;
}

//
// Parse an OrderDependency entry
//

PPDERROR
IOrderDepProc(
    PPARSERDATA pParserData
    )

{
    PLISTOBJ    pItem;

    if (! (pItem = ALLOC_PARSER_MEM(pParserData, sizeof(LISTOBJ))) ||
        ! (pItem->pstrName = PstrParseString(pParserData, &pParserData->Value)))
    {
        ERR(("Memory allocation failed\n"));
        return PPDERR_MEMORY;
    }

    pItem->pNext = pParserData->pOrderDep;
    pParserData->pOrderDep = pItem;
    return PPDERR_NONE;
}

//
// Parse QueryOrderDependency entries
//

PPDERROR
IQueryOrderDepProc(
    PPARSERDATA pParserData
    )

{
    PLISTOBJ    pItem;

    if (! (pItem = ALLOC_PARSER_MEM(pParserData, sizeof(LISTOBJ))) ||
        ! (pItem->pstrName = PstrParseString(pParserData, &pParserData->Value)))
    {
        ERR(("Memory allocation failed\n"));
        return PPDERR_MEMORY;
    }

    pItem->pNext = pParserData->pQueryOrderDep;
    pParserData->pQueryOrderDep = pItem;
    return PPDERR_NONE;
}

//
// Specifies memory configuration information
//

PPDERROR
IVMOptionProc(
    PPARSERDATA pParserData
    )

{
    PMEMOBJ pOption;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_MEMOPTION)))
        return PPDERR_MEMORY;

    if (pOption->dwFreeVM)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    return IParseInteger(pParserData, &pOption->dwFreeVM);
}

//
// Specifies font cache size information
//

PPDERROR
IFCacheSizeProc(
    PPARSERDATA pParserData
    )

{
    PMEMOBJ pOption;

    if (! (pOption = PvCreateOptionItem(pParserData, GID_MEMOPTION)))
        return PPDERR_MEMORY;

    if (pOption->dwFontMem)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    return IParseInteger(pParserData, &pOption->dwFontMem);
}

//
// Specifies the minimum amount of free VM
//

PPDERROR
IFreeVMProc(
    PPARSERDATA pParserData
    )

{
    return IParseInteger(pParserData, &pParserData->dwFreeMem);
}

//
// Include another file
//

PPDERROR
IIncludeProc(
    PPARSERDATA pParserData
    )

#define MAX_INCLUDE_LEVEL   10

{
    WCHAR       awchFilename[MAX_PATH];
    PFILEOBJ    pPreviousFile;
    PPDERROR    iStatus;

    if (pParserData->iIncludeLevel >= MAX_INCLUDE_LEVEL)
    {
        ERR(("There appears to be recursive *Include.\n"));
        return PPDERR_FILE;
    }

    if (! MultiByteToWideChar(CP_ACP, 0, pParserData->pstrValue, -1, awchFilename,  MAX_PATH))
        return ISyntaxError(pParserData->pFile, "Invalid include filename");

    VERBOSE(("Including file %ws ...\n", awchFilename));

    pPreviousFile = pParserData->pFile;
    pParserData->iIncludeLevel++;

    iStatus = IParseFile(pParserData, awchFilename);

    pParserData->iIncludeLevel--;
    pParserData->pFile = pPreviousFile;

    return iStatus;
}

//
// Specifies the printer description file format version number
//

PPDERROR
IPPDAdobeProc(
    PPARSERDATA pParserData
    )

{
    return IParseVersionNumber(pParserData, &pParserData->dwSpecVersion);
}

//
// Specifies the printer description file format version number
//

PPDERROR
IFormatVersionProc(
    PPARSERDATA pParserData
    )

{
    if (pParserData->dwSpecVersion != 0)
        return PPDERR_NONE;

    return IParseVersionNumber(pParserData, &pParserData->dwSpecVersion);
}

//
// Specifies the PPD file version number
//

PPDERROR
IFileVersionProc(
    PPARSERDATA pParserData
    )

{
    return IParseVersionNumber(pParserData, &pParserData->dwPpdFilever);
}

//
// Specifies the protocols supported by the device
//

PPDERROR
IProtocolsProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE ProtocolStrs[] =
    {
        "PJL",  PROTOCOL_PJL,
        "BCP",  PROTOCOL_BCP,
        "TBCP", PROTOCOL_TBCP,
        "SIC",  PROTOCOL_SIC,
        NULL,   0
    };

    CHAR    achWord[MAX_WORD_LEN];
    DWORD   dwProtocol;
    PSTR    pstr = pParserData->pstrValue;

    while (BFindNextWord(&pstr, achWord))
    {
        if (BSearchStrTable(ProtocolStrs, achWord, &dwProtocol))
            pParserData->dwProtocols |= dwProtocol;
        else
            TERSE(("Unknown protocol: %s\n", achWord));
    }

    return PPDERR_NONE;
}

//
// Specifies whether the device supports color output
//

PPDERROR
IColorDeviceProc(
    PPARSERDATA pParserData
    )

{
    return IParseBoolean(pParserData, &pParserData->dwColorDevice);
}

//
// Specifies whether the device fonts already have the Euro
//

PPDERROR
IHasEuroProc(
    PPARSERDATA pParserData
    )

{
    PPDERROR rc;

    if (rc = IParseBoolean(pParserData, &pParserData->bHasEuro) != PPDERR_NONE)
        return rc;

    pParserData->bEuroInformationSet = TRUE;

    return PPDERR_NONE;
}

//
// Specifies whether the device fonts already have the Euro
//

PPDERROR
ITrueGrayProc(
    PPARSERDATA pParserData
    )

{
    return IParseBoolean(pParserData, &pParserData->bTrueGray);
}

//
// Specifies the language extensions supported by the device
//

PPDERROR
IExtensionsProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE ExtensionStrs[] =
    {
        "DPS",          LANGEXT_DPS,
        "CMYK",         LANGEXT_CMYK,
        "Composite",    LANGEXT_COMPOSITE,
        "FileSystem",   LANGEXT_FILESYSTEM,
        NULL,           0
    };

    CHAR    achWord[MAX_WORD_LEN];
    INT     dwExtension;
    PSTR    pstr = pParserData->pstrValue;

    while (BFindNextWord(&pstr, achWord))
    {
        if (BSearchStrTable(ExtensionStrs, achWord, &dwExtension))
            pParserData->dwExtensions |= dwExtension;
        else
            TERSE(("Unknown extension: %s\n", achWord));
    }

    return PPDERR_NONE;
}

//
// Specifies whether the device has a file system on disk
//

PPDERROR
IFileSystemProc(
    PPARSERDATA pParserData
    )

{
    DWORD       dwFileSystem;
    PPDERROR    iStatus;

    if ((iStatus = IParseBoolean(pParserData, &dwFileSystem)) == PPDERR_NONE)
    {
        if (dwFileSystem)
            pParserData->dwExtensions |= LANGEXT_FILESYSTEM;
        else
            pParserData->dwExtensions &= ~LANGEXT_FILESYSTEM;
    }

    return iStatus;
}

//
// Specifies the device name
//

PPDERROR
INickNameProc(
    PPARSERDATA pParserData
    )

{
    //
    // Use NickName only if ShortNickName entry is not present
    //

    if (pParserData->NickName.pvData == NULL)
        return IParseInvocation(pParserData, &pParserData->NickName);
    else
        return PPDERR_NONE;
}

//
// Specifies the short device name
//

PPDERROR
IShortNameProc(
    PPARSERDATA pParserData
    )

{
    pParserData->NickName.dwLength = 0;
    pParserData->NickName.pvData = NULL;

    return IParseInvocation(pParserData, &pParserData->NickName);
}

//
// Specifies the PostScript language level
//

PPDERROR
ILangLevelProc(
    PPARSERDATA pParserData
    )

{
    return IParseInteger(pParserData, &pParserData->dwLangLevel);
}

//
// Specifies PPD language encoding options
//

PPDERROR
ILangEncProc(
    PPARSERDATA pParserData
    )

{
    //
    // NOTE: Only the following two language encodings are supported because
    // the rest of them are not used (according to our discussions with Adobe).
    // In any case, we don't have any direct way of translating ANSI strings
    // in other encodings to Unicode.
    //
    // A possible future PPD extension is to allow Unicode encoding directly
    // in translation strings.
    //

    static const STRTABLE LangEncStrs[] =
    {
        "ISOLatin1",    LANGENC_ISOLATIN1,
        "WindowsANSI",  LANGENC_ISOLATIN1, // WindowsANSI means CharSet=0, which is now page 1252->ISO Latin1
        "None",         LANGENC_NONE,
        "Unicode",      LANGENC_UNICODE,
        "JIS83-RKSJ",   LANGENC_JIS83_RKSJ,
        NULL,           LANGENC_NONE
    };

    if (! BSearchStrTable(LangEncStrs, pParserData->pstrValue, &pParserData->dwLangEncoding))
        return ISyntaxError(pParserData->pFile, "Unsupported LanguageEncoding keyword");
    else
        return PPDERR_NONE;
}

//
// Identifies the natural language used in the PPD file
//

PPDERROR
ILangVersProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE LangVersionStrs[] = {

        "English",        LANGENC_ISOLATIN1,
        "Danish",         LANGENC_ISOLATIN1,
        "Dutch",          LANGENC_ISOLATIN1,
        "Finnish",        LANGENC_ISOLATIN1,
        "French",         LANGENC_ISOLATIN1,
        "German",         LANGENC_ISOLATIN1,
        "Italian",        LANGENC_ISOLATIN1,
        "Norwegian",      LANGENC_ISOLATIN1,
        "Portuguese",     LANGENC_ISOLATIN1,
        "Spanish",        LANGENC_ISOLATIN1,
        "Swedish",        LANGENC_ISOLATIN1,
        "Japanese",       LANGENC_JIS83_RKSJ,
        "Chinese",        LANGENC_NONE,
        "Russian",        LANGENC_NONE,

        NULL,             LANGENC_NONE
    };

    if (pParserData->dwLangEncoding == LANGENC_NONE &&
        ! BSearchStrTable(LangVersionStrs, pParserData->pstrValue, &pParserData->dwLangEncoding))
    {
        return ISyntaxError(pParserData->pFile, "Unsupported LanguageVersion keyword");
    }

    return PPDERR_NONE;
}

//
// Specifies the available TrueType rasterizer options
//

PPDERROR
ITTRasterizerProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE RasterizerStrs[] =
    {
        "None",         TTRAS_NONE,
        "Accept68K",    TTRAS_ACCEPT68K,
        "Type42",       TTRAS_TYPE42,
        "TrueImage",    TTRAS_TRUEIMAGE,
        NULL,           TTRAS_NONE
    };

    if (! BSearchStrTable(RasterizerStrs, pParserData->pstrValue, &pParserData->dwTTRasterizer))
        return ISyntaxError(pParserData->pFile, "Unknown TTRasterizer option");
    else
        return PPDERR_NONE;
}

//
// Specifies the exitserver invocation string
//

PPDERROR
IExitServerProc(
    PPARSERDATA pParserData
    )

{
    return IParseInvocation(pParserData, &pParserData->ExitServer);
}

//
// Specifies the password string
//

PPDERROR
IPasswordProc(
    PPARSERDATA pParserData
    )

{
    return IParseInvocation(pParserData, &pParserData->Password);
}

//
// Specifies the PatchFile invocation string
//

PPDERROR
IPatchFileProc(
    PPARSERDATA pParserData
    )

{
    return IParseInvocation(pParserData, &pParserData->PatchFile);
}

//
// Specifies JobPatchFile invocation strings
//

PPDERROR
IJobPatchFileProc(
    PPARSERDATA pParserData
    )

{
    PJOBPATCHFILEOBJ  pItem;
    PSTR              pTmp;

    //
    // Create a new job patch file item
    //

    if (! (pItem = PvCreateListItem(pParserData,
                                    (PLISTOBJ *) &pParserData->pJobPatchFiles,
                                    sizeof(JOBPATCHFILEOBJ),
                                    "JobPatchFile")))
    {
        return PPDERR_MEMORY;
    }

    //
    // Parse the job patch file invocation string
    //

    if (pItem->Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    //
    // warn if number of patch file is invalid
    //

    pTmp = pItem->pstrName;

    if (!BGetIntegerFromString(&pTmp, &pItem->lPatchNo))
    {
        TERSE(("Warning: invalid JobPatchFile number '%s' on line %d\n",
               pParserData->achOption, pParserData->pFile->iLineNumber));
        pItem->lPatchNo = 0;
    }

    return IParseInvocation(pParserData, &pItem->Invocation);
}

//
// Specifies PostScript interpreter version and revision number
//

PPDERROR
IPSVersionProc(
    PPARSERDATA pParserData
    )

{
    PSTR        pstr = pParserData->Value.pbuf;
    DWORD       dwVersion;
    PPDERROR    status;

    //
    // Save the first PSVersion string
    //

    if ((pParserData->PSVersion.pvData == NULL) &&
        ((status = IParseInvocation(pParserData, &pParserData->PSVersion)) != PPDERR_NONE))
    {
        return status;
    }

    //
    // Skip non-digit characters
    //

    while (*pstr && !IS_DIGIT(*pstr))
        pstr++;

    //
    // Extract the PS interpreter version number
    //

    dwVersion = 0;

    while (*pstr && IS_DIGIT(*pstr))
        dwVersion = dwVersion * 10 + (*pstr++ - '0');

    if (dwVersion > 0)
    {
        //
        // Remember the lowest PSVersion number
        //

        if (pParserData->dwPSVersion == 0 || pParserData->dwPSVersion > dwVersion)
            pParserData->dwPSVersion = dwVersion;

        return PPDERR_NONE;
    }
    else
        return ISyntaxError(pParserData->pFile, "Invalid PSVersion entry");
}

//
// Specifies the Product string
//

PPDERROR
IProductProc(
    PPARSERDATA pParserData
    )

{
        //
        // only store the first *Product entry, though there may be multiple
        //

        if (pParserData->Product.dwLength != 0)
                return PPDERR_NONE;

    return IParseInvocation(pParserData, &pParserData->Product);
}

//
// Specifies the default job timeout value
//

PPDERROR
IJobTimeoutProc(
    PPARSERDATA pParserData
    )

{
    return IParseInteger(pParserData, &pParserData->dwJobTimeout);
}

//
// Specifies the default wait timeout value
//

PPDERROR
IWaitTimeoutProc(
    PPARSERDATA pParserData
    )

{
    return IParseInteger(pParserData, &pParserData->dwWaitTimeout);
}

//
// Specifies whether error handler should be enabled by default
//

PPDERROR
IPrintPSErrProc(
    PPARSERDATA pParserData
    )

{
    DWORD   dwValue;

    if (IParseBoolean(pParserData, &dwValue) != PPDERR_NONE)
        return PPDERR_SYNTAX;

    if (dwValue)
        pParserData->dwPpdFlags |= PPDFLAG_PRINTPSERROR;
    else
        pParserData->dwPpdFlags &= ~PPDFLAG_PRINTPSERROR;

    return PPDERR_NONE;
}

//
// Specifies PJL commands to start a job
//

PPDERROR
IJCLBeginProc(
    PPARSERDATA pParserData
    )

{
    pParserData->dwPpdFlags |= PPDFLAG_HAS_JCLBEGIN;
    return IParseInvocation(pParserData, &pParserData->JclBegin);
}

//
// Specifies PJL commands to switch into PostScript language
//

PPDERROR
IJCLToPSProc(
    PPARSERDATA pParserData
    )

{
    pParserData->dwPpdFlags |= PPDFLAG_HAS_JCLENTERPS;
    return IParseInvocation(pParserData, &pParserData->JclEnterPS);
}

//
// Specifies PJL commands to end a job
//

PPDERROR
IJCLEndProc(
    PPARSERDATA pParserData
    )

{
    pParserData->dwPpdFlags |= PPDFLAG_HAS_JCLEND;
    return IParseInvocation(pParserData, &pParserData->JclEnd);
}

//
// Specifies the default landscape orientation mode
//

PPDERROR
ILSOrientProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE LsoStrs[] =
    {
        "Any",      LSO_ANY,
        "Plus90",   LSO_PLUS90,
        "Minus90",  LSO_MINUS90,
        NULL,       LSO_ANY
    };

    if (! BSearchStrTable(LsoStrs, pParserData->pstrValue, &pParserData->dwLSOrientation))
        return ISyntaxError(pParserData->pFile, "Unrecognized landscape orientation");
    else
        return PPDERR_NONE;
}



PPAPEROBJ
PCreateCustomSizeOption(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Create a CustomPageSize option for PageSize feature (if necessary)

Arguments:

    pParserData - Points to parser data structure

Return Value:

    Pointer to newly created CustomPageSize option item or
    the existing CustomPageSize option item if it already exists.

    NULL if there is an error.

--*/

{
    PPAPEROBJ   pCustomSize;
    BUFOBJ      SavedBuffer;

    //
    // Create an item corresponding to *PageSize feature if needed
    //

    SavedBuffer = pParserData->Option;
    pParserData->Option.pbuf = (PBYTE) gstrCustomSizeKwd;
    pParserData->Option.dwSize = strlen(gstrCustomSizeKwd);

    pCustomSize = PvCreateOptionItem(pParserData, GID_PAGESIZE);

    pParserData->Option = SavedBuffer;

    return pCustomSize;;
}

//
// Specifies custom paper size invocation string
//

PPDERROR
ICustomSizeProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pCustomSize;

    if (strcmp(pParserData->achOption, gstrTrueKwd) != EQUAL_STRING)
    {
        ISyntaxError(pParserData->pFile, "Invalid *CustomPageSize option");
        return PPDERR_NONE;
    }

    if (! (pCustomSize = PCreateCustomSizeOption(pParserData)))
        return PPDERR_MEMORY;

    if (pCustomSize->Option.Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    return IParseInvocation(pParserData, &pCustomSize->Option.Invocation);
}

//
// Specifies custom paper size parameters
//

PPDERROR
IParamCustomProc(
    PPARSERDATA pParserData
    )

{
    static const STRTABLE CustomParamStrs[] =
    {
        "Width",        CUSTOMPARAM_WIDTH,
        "Height",       CUSTOMPARAM_HEIGHT,
        "WidthOffset",  CUSTOMPARAM_WIDTHOFFSET,
        "HeightOffset", CUSTOMPARAM_HEIGHTOFFSET,
        "Orientation",  CUSTOMPARAM_ORIENTATION,
        NULL,           0
    };

    CHAR    achWord[MAX_WORD_LEN];
    LONG    lMinVal, lMaxVal;
    INT     iType;
    DWORD   dwParam;
    LONG    lOrder;
    PSTR    pstr = pParserData->pstrValue;

    //
    // The format for a ParamCustomPageSize entry:
    //  ParameterName Order Type MinVal MaxVal
    //

    if (! BSearchStrTable(CustomParamStrs, pParserData->achOption, &dwParam) ||
        ! BGetIntegerFromString(&pstr, &lOrder) ||
        ! BFindNextWord(&pstr, achWord) ||
        lOrder <= 0 || lOrder > CUSTOMPARAM_MAX)
    {
        return ISyntaxError(pParserData->pFile, "Bad *ParamCustomPageSize entry");
    }

    //
    // Expected type is "int" for Orientation parameter and "points" for other parameters
    //

    iType = (dwParam == CUSTOMPARAM_ORIENTATION) ?
                ((strcmp(achWord, "int") == EQUAL_STRING) ? FLTYPE_INT : FLTYPE_ERROR) :
                ((strcmp(achWord, "points") == EQUAL_STRING) ? FLTYPE_POINT : FLTYPE_ERROR);

    if (iType == FLTYPE_ERROR ||
        ! BGetFloatFromString(&pstr, &lMinVal, iType) ||
        ! BGetFloatFromString(&pstr, &lMaxVal, iType) ||
        lMinVal > lMaxVal)
    {
        return ISyntaxError(pParserData->pFile, "Bad *ParamCustomPageSize entry");
    }

    pParserData->CustomSizeParams[dwParam].dwOrder = lOrder;
    pParserData->CustomSizeParams[dwParam].lMinVal = lMinVal;
    pParserData->CustomSizeParams[dwParam].lMaxVal = lMaxVal;

    return PPDERR_NONE;
}

//
// Specifies the maximum height of custom paper size
//

PPDERROR
IMaxWidthProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pCustomSize;
    LONG        lValue;
    PSTR        pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &lValue, FLTYPE_POINT) || lValue <= 0)
        return ISyntaxError(pParserData->pFile, "Invalid media width");

    if (! (pCustomSize = PCreateCustomSizeOption(pParserData)))
        return PPDERR_MEMORY;

    pCustomSize->szDimension.cx = lValue;
    return PPDERR_NONE;
}

//
// Specifies the maximum height of custom paper size
//

PPDERROR
IMaxHeightProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pCustomSize;
    LONG        lValue;
    PSTR        pstr = pParserData->pstrValue;

    if (! BGetFloatFromString(&pstr, &lValue, FLTYPE_POINT) || lValue <= 0)
        return ISyntaxError(pParserData->pFile, "Invalid media height");

    if (! (pCustomSize = PCreateCustomSizeOption(pParserData)))
        return PPDERR_MEMORY;

    pCustomSize->szDimension.cy = lValue;
    return PPDERR_NONE;
}

//
// Specifies the hardware margins on cut-sheet devices
//

PPDERROR
IHWMarginsProc(
    PPARSERDATA pParserData
    )

{
    PPAPEROBJ   pCustomSize;
    RECT        rc;
    PSTR        pstr = pParserData->pstrValue;

    //
    // Parse hardware margins: left, bottom, right, top
    //

    if (! BGetFloatFromString(&pstr, &rc.left, FLTYPE_POINT) ||
        ! BGetFloatFromString(&pstr, &rc.bottom, FLTYPE_POINT) ||
        ! BGetFloatFromString(&pstr, &rc.right, FLTYPE_POINT) ||
        ! BGetFloatFromString(&pstr, &rc.top, FLTYPE_POINT))
    {
        return ISyntaxError(pParserData->pFile, "Invalid HWMargins");
    }

    if (! (pCustomSize = PCreateCustomSizeOption(pParserData)))
        return PPDERR_MEMORY;

    pCustomSize->rcImageArea = rc;

    //
    // The presence of HWMargins entry indicates the device supports cut-sheet
    //

    pParserData->dwCustomSizeFlags |= CUSTOMSIZE_CUTSHEET;
    return PPDERR_NONE;
}

//
// Function to process *CenterRegistered entry
//

PPDERROR
ICenterRegProc(
    PPARSERDATA pParserData
    )

{
    DWORD   dwValue;

    if (IParseBoolean(pParserData, &dwValue) != PPDERR_NONE)
        return PPDERR_SYNTAX;

    if (dwValue)
        pParserData->dwCustomSizeFlags |= CUSTOMSIZE_CENTERREG;
    else
        pParserData->dwCustomSizeFlags &= ~CUSTOMSIZE_CENTERREG;

    return PPDERR_NONE;
}

//
// Function to process *ADORequiresEExec entry
//

PPDERROR
IReqEExecProc(
    PPARSERDATA pParserData
    )

{
    DWORD   dwValue;

    if (IParseBoolean(pParserData, &dwValue) != PPDERR_NONE)
        return PPDERR_SYNTAX;

    if (dwValue)
        pParserData->dwPpdFlags |= PPDFLAG_REQEEXEC;
    else
        pParserData->dwPpdFlags &= ~PPDFLAG_REQEEXEC;

    return PPDERR_NONE;
}

//
// Function to process *ADOTTFontSub entry
//

PPDERROR
ITTFontSubProc(
    PPARSERDATA pParserData
    )

{
    PTTFONTSUB pTTFontSub;

    //
    // Create a new font substitution item
    //

    if (! (pTTFontSub = PvCreateXlatedItem(
                                pParserData,
                                &pParserData->pTTFontSubs,
                                sizeof(TTFONTSUB))))
    {
        return PPDERR_MEMORY;
    }

    //
    // Parse the PS family name
    //

    if (pTTFontSub->PSName.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    if (*pParserData->pstrValue == NUL)
        return ISyntaxError(pParserData->pFile, "Missing TrueType font family name");

    return IParseInvocation(pParserData, &pTTFontSub->PSName);
}

//
// Function to process *Throughput entry
//

PPDERROR
IThroughputProc(
    PPARSERDATA pParserData
    )

{
    return IParseInteger(pParserData, &pParserData->dwThroughput);
}

//
// Function to ignore the current entry
//

PPDERROR
INullProc(
    PPARSERDATA pParserData
    )

{
    return PPDERR_NONE;
}

//
// Define a named symbol
//

PPDERROR
ISymbolValueProc(
    PPARSERDATA pParserData
    )

{
    PSYMBOLOBJ  pSymbol;

    if (pParserData->dwValueType == VALUETYPE_SYMBOL)
        return ISyntaxError(pParserData->pFile, "Symbol value cannot be another symbol");

    //
    // Create a new symbol item
    //

    if (! (pSymbol = PvCreateListItem(pParserData,
                                      (PLISTOBJ *) &pParserData->pSymbols,
                                      sizeof(SYMBOLOBJ),
                                      "Symbol")))
    {
        return PPDERR_MEMORY;
    }

    //
    // Parse the symbol value
    //

    if (pSymbol->Invocation.pvData)
    {
        WARN_DUPLICATE();
        return PPDERR_NONE;
    }

    return IParseInvocation(pParserData, &pSymbol->Invocation);
}



//
// Built-in keyword table
//

const CHAR gstrDefault[]        = "Default";
const CHAR gstrPageSizeKwd[]    = "PageSize";
const CHAR gstrInputSlotKwd[]   = "InputSlot";
const CHAR gstrManualFeedKwd[]  = "ManualFeed";
const CHAR gstrCustomSizeKwd[]  = "CustomPageSize";
const CHAR gstrLetterSizeKwd[]  = "Letter";
const CHAR gstrA4SizeKwd[]      = "A4";
const CHAR gstrLongKwd[]        = "Long";
const CHAR gstrShortKwd[]       = "Short";
const CHAR gstrTrueKwd[]        = "True";
const CHAR gstrFalseKwd[]       = "False";
const CHAR gstrOnKwd[]          = "On";
const CHAR gstrOffKwd[]         = "Off";
const CHAR gstrNoneKwd[]        = "None";
const CHAR gstrVMOptionKwd[]    = "VMOption";
const CHAR gstrInstallMemKwd[]  = "InstalledMemory";
const CHAR gstrDuplexTumble[]   = "DuplexTumble";
const CHAR gstrDuplexNoTumble[] = "DuplexNoTumble";

const KWDENTRY gPpdBuiltInKeywordTable[] =
{
    { gstrPageSizeKwd,          NULL,                GENERIC_ENTRY(GID_PAGESIZE) },
    { "PageRegion",             NULL,                GENERIC_ENTRY(GID_PAGEREGION) },
    { gstrInputSlotKwd,         NULL,                GENERIC_ENTRY(GID_INPUTSLOT) },
    { "MediaType",              NULL,                GENERIC_ENTRY(GID_MEDIATYPE) },
    { "OutputBin",              NULL,                GENERIC_ENTRY(GID_OUTPUTBIN) },
    { "Collate",                NULL,                GENERIC_ENTRY(GID_COLLATE) },
    { "Resolution",             NULL,                GENERIC_ENTRY(GID_RESOLUTION) },
    { "InstalledMemory",        NULL,                GENERIC_ENTRY(GID_MEMOPTION) },
    { "LeadingEdge",            NULL,                GENERIC_ENTRY(GID_LEADINGEDGE) },
    { "UseHWMargins",           NULL,                GENERIC_ENTRY(GID_USEHWMARGINS) },

    { "Duplex",                 IDuplexProc,         INVOCA_VALUE | REQ_OPTION },
    { "DefaultDuplex",          IDefaultDuplexProc,  STRING_VALUE },
    { "PaperDimension",         IPaperDimProc,       QUOTED_NOHEX | REQ_OPTION },
    { "ImageableArea",          IImageAreaProc,      QUOTED_NOHEX | REQ_OPTION },
    { "RequiresPageRegion",     IReqPageRgnProc,     STRING_VALUE | REQ_OPTION },
    { gstrManualFeedKwd,        IManualFeedProc,     INVOCA_VALUE | REQ_OPTION },
    { "DefaultManualFeed",      IDefManualFeedProc,  STRING_VALUE },
    { "PageStackOrder",         IPageStackOrderProc, STRING_VALUE | REQ_OPTION },
    { "DefaultOutputOrder",     IDefOutputOrderProc, STRING_VALUE },
    { "JCLResolution",          IJCLResProc,         INVOCA_VALUE | REQ_OPTION | ALLOW_HEX },
    { "DefaultJCLResolution",   IDefaultJCLResProc,  STRING_VALUE },
    { "SetResolution",          ISetResProc,         INVOCA_VALUE | REQ_OPTION },
    { "ScreenAngle",            IScreenAngleProc,    QUOTED_VALUE },
    { "ScreenFreq",             IScreenFreqProc,     QUOTED_VALUE },
    { "ResScreenAngle",         IResScreenAngleProc, QUOTED_NOHEX | REQ_OPTION },
    { "ResScreenFreq",          IResScreenFreqProc,  QUOTED_NOHEX | REQ_OPTION },
    { "Font",                   IFontProc,           STRING_VALUE | REQ_OPTION },
    { "DefaultFont",            IDefaultFontProc,    STRING_VALUE },
    { "OpenUI",                 IOpenUIProc,         STRING_VALUE | REQ_OPTION },
    { "CloseUI",                ICloseUIProc,        STRING_VALUE | ALLOW_MULTI },
    { "JCLOpenUI",              IOpenUIProc,         STRING_VALUE | REQ_OPTION },
    { "JCLCloseUI",             ICloseUIProc,        STRING_VALUE | ALLOW_MULTI },
    { "OrderDependency",        IOrderDepProc,       STRING_VALUE | ALLOW_MULTI },
    { "UIConstraints",          IUIConstraintsProc,  STRING_VALUE | ALLOW_MULTI },
    { "QueryOrderDependency",   IQueryOrderDepProc,  STRING_VALUE | ALLOW_MULTI },
    { "NonUIOrderDependency",   IOrderDepProc,       STRING_VALUE | ALLOW_MULTI },
    { "NonUIConstraints",       IUIConstraintsProc,  STRING_VALUE | ALLOW_MULTI },
    { "VMOption",               IVMOptionProc,       QUOTED_NOHEX | REQ_OPTION },
    { "FCacheSize",             IFCacheSizeProc,     STRING_VALUE | REQ_OPTION },
    { "FreeVM",                 IFreeVMProc,         QUOTED_VALUE },
    { "OpenGroup",              IOpenGroupProc,      STRING_VALUE | ALLOW_MULTI },
    { "CloseGroup",             ICloseGroupProc,     STRING_VALUE | ALLOW_MULTI },
    { "OpenSubGroup",           IOpenSubGroupProc,   STRING_VALUE | ALLOW_MULTI },
    { "CloseSubGroup",          ICloseSubGroupProc,  STRING_VALUE | ALLOW_MULTI },
    { "Include",                IIncludeProc,        QUOTED_VALUE | ALLOW_MULTI },
    { "PPD-Adobe",              IPPDAdobeProc,       QUOTED_VALUE },
    { "FormatVersion",          IFormatVersionProc,  QUOTED_VALUE },
    { "FileVersion",            IFileVersionProc,    QUOTED_VALUE },
    { "ColorDevice",            IColorDeviceProc,    STRING_VALUE },
    { "Protocols",              IProtocolsProc,      STRING_VALUE | ALLOW_MULTI },
    { "Extensions",             IExtensionsProc,     STRING_VALUE | ALLOW_MULTI },
    { "FileSystem",             IFileSystemProc,     STRING_VALUE },
    { "NickName",               INickNameProc,       QUOTED_VALUE },
    { "ShortNickName",          IShortNameProc,      QUOTED_VALUE },
    { "LanguageLevel",          ILangLevelProc,      QUOTED_NOHEX },
    { "LanguageEncoding",       ILangEncProc,        STRING_VALUE },
    { "LanguageVersion",        ILangVersProc,       STRING_VALUE },
    { "TTRasterizer",           ITTRasterizerProc,   STRING_VALUE },
    { "ExitServer",             IExitServerProc,     INVOCA_VALUE },
    { "Password",               IPasswordProc,       INVOCA_VALUE },
    { "PatchFile",              IPatchFileProc,      INVOCA_VALUE },
    { "JobPatchFile",           IJobPatchFileProc,   INVOCA_VALUE | REQ_OPTION },
    { "PSVersion",              IPSVersionProc,      QUOTED_NOHEX | ALLOW_MULTI },
    { "ModelName",              INullProc,                       QUOTED_VALUE },
    { "Product",                IProductProc,        QUOTED_NOHEX | ALLOW_MULTI },
    { "SuggestedJobTimeout",    IJobTimeoutProc,     QUOTED_VALUE },
    { "SuggestedWaitTimeout",   IWaitTimeoutProc,    QUOTED_VALUE },
    { "PrintPSErrors",          IPrintPSErrProc,     STRING_VALUE },
    { "JCLBegin",               IJCLBeginProc,       QUOTED_VALUE },
    { "JCLToPSInterpreter",     IJCLToPSProc,        QUOTED_VALUE },
    { "JCLEnd",                 IJCLEndProc,         QUOTED_VALUE },
    { "LandscapeOrientation",   ILSOrientProc,       STRING_VALUE },
    { gstrCustomSizeKwd,        ICustomSizeProc,     INVOCA_VALUE | REQ_OPTION },
    { "ParamCustomPageSize",    IParamCustomProc,    STRING_VALUE | REQ_OPTION },
    { "MaxMediaWidth",          IMaxWidthProc,       QUOTED_VALUE },
    { "MaxMediaHeight",         IMaxHeightProc,      QUOTED_VALUE },
    { "HWMargins",              IHWMarginsProc,      STRING_VALUE },
    { "CenterRegistered",       ICenterRegProc,      STRING_VALUE },
    { "ADORequiresEExec",        IReqEExecProc,       STRING_VALUE },
    { "ADOTTFontSub",            ITTFontSubProc,      QUOTED_VALUE | REQ_OPTION },
    { "ADTrueGray",             ITrueGrayProc,       STRING_VALUE },
    { "ADHasEuro",              IHasEuroProc,        STRING_VALUE },
    { "Throughput",             IThroughputProc,     QUOTED_NOHEX },
    { "SymbolValue",            ISymbolValueProc,    INVOCA_VALUE | REQ_OPTION },
    { "Status",                 INullProc,           QUOTED_VALUE | ALLOW_MULTI },
    { "PrinterError",           INullProc,           QUOTED_VALUE | ALLOW_MULTI },
    { "SymbolLength",           INullProc,           STRING_VALUE | REQ_OPTION },
    { "SymbolEnd",              INullProc,           STRING_VALUE | ALLOW_MULTI },
    { "End",                    INullProc,           VALUETYPE_NONE | ALLOW_MULTI },
};

#define NUM_BUILTIN_KEYWORDS (sizeof(gPpdBuiltInKeywordTable) / sizeof(KWDENTRY))



DWORD
DwHashKeyword(
    PSTR    pstrKeyword
    )

/*++

Routine Description:

    Compute the hash value for the specified keyword string

Arguments:

    pstrKeyword - Pointer to the keyword string to be hashed

Return Value:

    Hash value computed using the specified keyword string

--*/

{
    PBYTE   pub = (PBYTE) pstrKeyword;
    DWORD   dwHashValue = 0;

    while (*pub)
        dwHashValue = (dwHashValue << 1) ^ *pub++;

    return dwHashValue;
}



PKWDENTRY
PSearchKeywordTable(
    PPARSERDATA pParserData,
    PSTR        pstrKeyword,
    INT        *piIndex
    )

/*++

Routine Description:

    Check if a keyword appears in the built-in keyword table

Arguments:

    pParserData - Points to parser data structure
    pstrKeyword - Specifies the keyword to be searched
    piIndex - Returns the index of the entry in the built-in keyword
        table corresponding to the specified keyword.

Return Value:

    Pointer to the entry in the built-in table corresponding to the
    specified keyword. NULL if the specified keyword is not supported.

--*/

{
    DWORD   dwHashValue;
    INT     iIndex;

    ASSERT(pstrKeyword != NULL);
    dwHashValue = DwHashKeyword(pstrKeyword);

    for (iIndex = 0; iIndex < NUM_BUILTIN_KEYWORDS; iIndex++)
    {
        if (pParserData->pdwKeywordHashs[iIndex] == dwHashValue &&
            strcmp(gPpdBuiltInKeywordTable[iIndex].pstrKeyword, pstrKeyword) == EQUAL_STRING)
        {
            *piIndex = iIndex;
            return (PKWDENTRY) &gPpdBuiltInKeywordTable[iIndex];
        }
    }

    return NULL;
}



BOOL
BInitKeywordLookup(
    PPARSERDATA pParserData
    )

/*++

Routine Description:

    Build up data structures to speed up keyword lookup

Arguments:

    pParserData - Points to parser data structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   iIndex, iCount;

    //
    // Allocate memory to hold extra data structures
    //

    iCount = NUM_BUILTIN_KEYWORDS;
    pParserData->pdwKeywordHashs = ALLOC_PARSER_MEM(pParserData, iCount * sizeof(DWORD));
    pParserData->pubKeywordCounts = ALLOC_PARSER_MEM(pParserData, iCount * sizeof(BYTE));

    if (!pParserData->pdwKeywordHashs || !pParserData->pubKeywordCounts)
    {
        ERR(("Memory allocation failed: %d\n", GetLastError()));
        return FALSE;
    }

    //
    // Precompute the hash values for built-in keywords
    //

    for (iIndex = 0; iIndex < iCount; iIndex++)
    {
        pParserData->pdwKeywordHashs[iIndex] =
            DwHashKeyword((PSTR) gPpdBuiltInKeywordTable[iIndex].pstrKeyword);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\ppd\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Common sources shared by both um and km directory

!ENDIF

SOURCES=\
    ..\ppd.c \
    ..\custsize.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\makentf\cjkfonts.c ===
/*++

Copyright (c) 1996 Adobe Systems Incorporated
Copyright (c) 1996  Microsoft Corporation

Module Name:

    cjkfonts.c

Abstract:

    Convert CJK AFMs to NTMs.

Environment:

    Windows NT PostScript driver: makentf utility.

Revision History:

    02/10/98 -ksuzuki-
        Added OCF font support using 83pv font; did code cleanup, especially
        of the CreateCJKGlyphSets function.

    01/13/96 -rkiesler-
        Wrote it.
-*/

#include "lib.h"
#include "ppd.h"
#include "pslib.h"
#include "psglyph.h"
#include "afm2ntm.h"
#include "cjkfonts.h"
#include "winfont.h"

extern BOOL bVerbose;

ULONG
CreateCJKGlyphSets(
    PBYTE         *pUV2CCMaps,
    PBYTE         *pUV2CIDMaps,
    PGLYPHSETDATA *pGlyphSets,
    PWINCODEPAGE   pWinCodePage,
    PULONG        *pUniPsTbl
    )
/*++

Routine Description:

    Given memory mapped file ptrs to H and V Unicode to CharCode map files
    and H and V Unicode to CID map files, create 2 GLYPHSETDATA structures
    which represent H and V variants of the character collection. Create
    ptrs to 2 tables which map glyph indices to CIDs for each variant.

Arguments:

    pUV2CCMaps - Pointer to two memory mapped map files. These map Unicode
    value to corresponding character code. pUV2CCMaps[0] and pUV2CCMaps[1]
    for H and V respectively.

    pUV2CIDMaps - Pointer to two memory mapped map files. These Unicode to
    corresponding CID. pUV2CIDMaps[0] and pUV2CIDMaps[1] for H and V
    respectively.

    pGlyphSets - two position array of GLYPHSETDATA pointers which upon
    successful completion contain the addresses of the newly allocated
    GLYPHSETDATA structs representing the H and V variants of the char
    collection.

    pWinCodePage - Pts to a WINCODEPAGE struct which provides Windows
    specific info about this charset.

    pUniPsTbl - two position array of ULONG ptrs which each pts to a table
    which maps 0-based Glyph Indices of chars in the GLYPHRUNS of the
    GLYPHSETDATA for this char collection to CIDs.

Return Value:

    TRUE  => success.
    FALSE => error.

--*/

{
    PBYTE           pToken, pGlyphSetName;
    ULONG           cChars, cRuns, cRanges, curCID;
    USHORT          cCharRun;
    PGLYPHRUN       pGlyphRuns;
    PCMAP           pUv2CcMap[NUM_VARIANTS];
    PCMAP           pUv2CidMap[NUM_VARIANTS];
    ULONG           c, i, uv;
    PVOID           pMapTbl;
    PCMAPRANGE      pCMapRange;
    PCMAP           pSrchCMap;
    ULONG           cGlyphSetBytes[NUM_VARIANTS], cSizeBytes[NUM_VARIANTS];
    BOOLEAN         bFound, bInRun;
    USHORT          wcRunStrt;
    DWORD           dwGSNameSize, dwCodePageInfoSize, dwGlyphRunSize, dwCPIGSNameSize;
    DWORD           dwEncodingNameOffset;
    PCODEPAGEINFO   pCodePageInfo;
	BOOL			bSingleCodePage;


	if (bVerbose) printf("%%%%[Begin Create CJK glyphset]%%%%\n\n");

    //////////////////////////////////////////////////////////////////////////
    //
    // Create the local Unicode->CharCode and Unicode->CID Maps sorted in
    // starting Unicode order.
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Get pointer to, and determine size of, the name strings for each variant.
    //
    for (i = 0; i < NUM_VARIANTS; i++)
    {
        //
        // Process the Unicode->CharCode map to determine the number of its
        // chars and runs.
        //
        if (NumUV2CCRuns(pUV2CCMaps[i], &cRuns, &cChars) == FALSE)
        {
            return(FALSE);
        }

        //
        // Alloc memory for create local CMap structs needed to build
        // GLYPHSETs.
        //
        pUv2CcMap[i] = (PCMAP)MemAllocZ(sizeof(CMAP) + sizeof(CMAPRANGE) * (cRuns - 1));
        if (pUv2CcMap[i] == NULL)
        {
            ERR(("makentf - CreateCJKGlyphSets: MemAllocZ\n"));
            return(FALSE);
        }
        pUv2CcMap[i]->cChars = cChars;

        if (BuildUV2CCMap(pUV2CCMaps[i], pUv2CcMap[i]) == FALSE)
        {
            return(FALSE);
        }

        //
        // Sort the CMap ranges in starting Unicode order.
        //
        qsort(pUv2CcMap[i]->CMapRange,
                (size_t)pUv2CcMap[i]->cRuns,
                (size_t)sizeof(CMAPRANGE),
                CmpCMapRunsChCode);

        //
        // Process the Unicode->CID map to determine the number of its
        // chars and runs.
        //
        if (NumUV2CIDRuns(pUV2CIDMaps[i], &cRuns, &cChars) == FALSE)
        {
            return(FALSE);
        }

        pUv2CidMap[i] = (PCMAP)MemAllocZ(sizeof(CMAP) + sizeof(CMAPRANGE) * (cRuns - 1));
        if (pUv2CidMap[i] == NULL)
        {
            ERR(("makentf - CreateCJKGlyphSets: MemAllocZ\n"));
            return(FALSE);
        }
        pUv2CidMap[i]->cChars = cChars;

        if (BuildUV2CIDMap(pUV2CIDMaps[i], pUv2CidMap[i]) == FALSE)
        {
            return(FALSE);
        }

        //
        // Sort CMap Ranges in Starting char code order.
        //
        qsort(pUv2CidMap[i]->CMapRange,
                (size_t)pUv2CidMap[i]->cRuns,
                (size_t)sizeof(CMAPRANGE),
                CmpCMapRunsChCode);
    }

	//
	// CJK fonts never have multiple codepages, but, we figure it out anyway
	// just in case.
	//
	bSingleCodePage = (pWinCodePage->usNumBaseCsets == 1) ? TRUE : FALSE;


    //////////////////////////////////////////////////////////////////////////
    //
    // Create H GLYPHSETDATA
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Count chars and runs in H CMaps.
    //
    // Look up all Unicode points in the H Unicode->CID map and the H Unicode->
    // CharCode map to determine number of GLYPHRUNs required for the
    // GLYPHSETDATA we are about to create.
    //
    cChars = cRuns = 0;
    bInRun = bFound = FALSE;

    for (uv = 0; uv < NUM_UNICODE_CHARS; uv++)
    {
        //
        // Search for the Unicode value in H Unicode->CharCode map.
        //
        pCMapRange = (PCMAPRANGE)bsearch(&uv,
                                            pUv2CidMap[H_CMAP]->CMapRange,
                                            pUv2CidMap[H_CMAP]->cRuns,
                                            sizeof(CMAPRANGE),
                                            FindChCodeRun);

        bFound = (pCMapRange != NULL);

        if (bFound)
        {
            //
            // Found this unicode value in H Unicode->CID map. Determine if it
            // maps to a CharCode in H Unicode->CharCode map.
            //
            bFound = (bsearch(&uv,
                                pUv2CcMap[H_CMAP]->CMapRange,
                                pUv2CcMap[H_CMAP]->cRuns,
                                sizeof(CMAPRANGE),
                                FindChCodeRun) != NULL);

            if (bFound)
            {
                cChars++;
            }
        }

        //
        // Determine if this is a new run.
        //
        bInRun = bFound && bInRun;
        if (bFound && !bInRun)
        {
            cRuns++;
            bInRun = TRUE;
        }
    }

    //
    // Compute amount of memory required for H GLYPHSET.
    // Note to account for the H/V char appended to the GlyphSet name.
    //
    dwGSNameSize = ALIGN4(strlen(pWinCodePage->pszCPname) + 2);
    dwCodePageInfoSize = ALIGN4(pWinCodePage->usNumBaseCsets * sizeof(CODEPAGEINFO));
    dwGlyphRunSize = ALIGN4(cRuns * sizeof(GLYPHRUN));

    cGlyphSetBytes[H_CMAP]  = ALIGN4(sizeof(GLYPHSETDATA));
    cGlyphSetBytes[H_CMAP] += dwGSNameSize;
    cGlyphSetBytes[H_CMAP] += dwCodePageInfoSize;
    cGlyphSetBytes[H_CMAP] += dwGlyphRunSize;

	//
	// Account for the size of the mapping table.
	//
	cGlyphSetBytes[H_CMAP] += bSingleCodePage ? ALIGN4((cChars * sizeof (WORD))) : (cChars * sizeof (DWORD));

    //
    // Account for size of CODEPAGE name strings found in CODEPAGEINFO
    // struct(s).
    //
    for (dwCPIGSNameSize = 0, i = 0; i < pWinCodePage->usNumBaseCsets; i++)
    {
        dwCPIGSNameSize += ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[i]].pGSName) + 1);
    }
    cGlyphSetBytes[H_CMAP] += dwCPIGSNameSize;

    //
    // Alloc memory for H GLYPHSET, Unicode->CID mapping table.
    //
    pGlyphSets[H_CMAP] = (PGLYPHSETDATA)MemAllocZ(cGlyphSetBytes[H_CMAP]);
    if (pGlyphSets[H_CMAP] == NULL)
    {
        ERR(("makentf - CreateCJKGlyphSets: malloc\n"));
        return(FALSE);
    }

    pUniPsTbl[H_CMAP] = (PULONG)MemAllocZ(cChars * sizeof(ULONG));
    if (pUniPsTbl[H_CMAP] == NULL)
    {
        ERR(("makentf - CreateCJKGlyphSets: malloc\n"));
        return(FALSE);
    }

    //
    // Init GLYPHSETDATA for H.
    //
    pGlyphSets[H_CMAP]->dwSize = cGlyphSetBytes[H_CMAP];
    pGlyphSets[H_CMAP]->dwVersion = GLYPHSETDATA_VERSION;
    pGlyphSets[H_CMAP]->dwFlags = 0;
    pGlyphSets[H_CMAP]->dwGlyphSetNameOffset = ALIGN4(sizeof(GLYPHSETDATA));
    pGlyphSets[H_CMAP]->dwGlyphCount = cChars;
    pGlyphSets[H_CMAP]->dwCodePageCount = pWinCodePage->usNumBaseCsets;
    pGlyphSets[H_CMAP]->dwCodePageOffset = pGlyphSets[H_CMAP]->dwGlyphSetNameOffset + dwGSNameSize;
    pGlyphSets[H_CMAP]->dwRunCount = cRuns;
    pGlyphSets[H_CMAP]->dwRunOffset = pGlyphSets[H_CMAP]->dwCodePageOffset + dwCodePageInfoSize + dwCPIGSNameSize;
    pGlyphSets[H_CMAP]->dwMappingTableOffset = pGlyphSets[H_CMAP]->dwRunOffset + dwGlyphRunSize;

	//
	// Set the mapping table type flag to dwFlags field.
	//
	pGlyphSets[H_CMAP]->dwFlags |= bSingleCodePage ? GSD_MTT_WCC : GSD_MTT_DWCPCC;

    //
    // Store GlyphSet name
    //
    pGlyphSetName = (PBYTE)MK_PTR(pGlyphSets[H_CMAP], dwGlyphSetNameOffset);
    StringCchCopyA(pGlyphSetName, dwGSNameSize, pWinCodePage->pszCPname);
    pGlyphSetName[strlen(pWinCodePage->pszCPname)] = 'H';
    pGlyphSetName[strlen(pWinCodePage->pszCPname) + 1] = '\0';

    //
    // Initialize a CODEPAGEINFO struct for each base charset supported
    // by this font.
    //
    pCodePageInfo = (PCODEPAGEINFO)MK_PTR(pGlyphSets[H_CMAP], dwCodePageOffset);
    dwEncodingNameOffset = dwCodePageInfoSize;

    for (i = 0; i < pWinCodePage->usNumBaseCsets; i++, pCodePageInfo++)
    {
        //
        // Save CODEPAGEINFO name, id. We don't use PS encoding vectors.
        //
        pCodePageInfo->dwCodePage = aPStoCP[pWinCodePage->pCsetList[i]].usACP;
        pCodePageInfo->dwWinCharset = (DWORD)aPStoCP[pWinCodePage->pCsetList[i]].jWinCharset;
        pCodePageInfo->dwEncodingNameOffset = dwEncodingNameOffset;
        pCodePageInfo->dwEncodingVectorDataSize = 0;
        pCodePageInfo->dwEncodingVectorDataOffset = 0;

        //
        // Copy codepage name string to end of array of CODEPAGEINFOs.
        //
        StringCchCopyA((PBYTE)MK_PTR(pCodePageInfo, dwEncodingNameOffset),
                ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[i]].pGSName) + 1),
                aPStoCP[pWinCodePage->pCsetList[i]].pGSName);

        //
        // Adjust the offset to the CodePage name for the next CODEPAGEINFO structure.
        //
        dwEncodingNameOffset -= ALIGN4(sizeof (CODEPAGEINFO));
        dwEncodingNameOffset += ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[i]].pGSName) + 1);
    }

    //
    // Process H Unicode->CID/CharCode maps to determine the number of its
    // chars and runs.
    //
    cRuns = 0;
    cCharRun = 0;
    bInRun = FALSE;
    pGlyphRuns = GSD_GET_GLYPHRUN(pGlyphSets[H_CMAP]);
    pMapTbl = GSD_GET_MAPPINGTABLE(pGlyphSets[H_CMAP]);

    for (uv = c = 0; (uv < NUM_UNICODE_CHARS) && (c < cChars); uv++)
    {
        pCMapRange = bsearch(&uv,
                                pUv2CidMap[H_CMAP]->CMapRange,
                                pUv2CidMap[H_CMAP]->cRuns,
                                sizeof(CMAPRANGE),
                                FindChCodeRun);

        bFound = (pCMapRange != NULL);

        if (bFound)
        {
            curCID = pCMapRange->CIDStrt + uv - pCMapRange->ChCodeStrt;

            pCMapRange = bsearch(&uv,
                                    pUv2CcMap[H_CMAP]->CMapRange,
                                    pUv2CcMap[H_CMAP]->cRuns,
                                    sizeof(CMAPRANGE),
                                    FindChCodeRun);

            bFound = (pCMapRange != NULL);

            if (bFound)
            {
                //
                // Found this Unicode value in Unicode->CharCode map. Store in
                // mapping table. Note that CJK fonts only support 1 charset
                // per font.
                //
                pUniPsTbl[H_CMAP][c] = curCID;

				if (bSingleCodePage)
				{
					if (pCMapRange != NULL)
						((WORD*)pMapTbl)[c] = (WORD)(pCMapRange->CIDStrt + (uv - pCMapRange->ChCodeStrt));
					else
						((WORD*)pMapTbl)[c] = (WORD)uv;
				}
				else
				{
                	((DWORD*)pMapTbl)[c] = aPStoCP[pWinCodePage->pCsetList[0]].usACP << 16;
                	if (pCMapRange != NULL)
                	{
                    	((DWORD*)pMapTbl)[c] |= pCMapRange->CIDStrt + (uv - pCMapRange->ChCodeStrt);
                	}
                	else
                	{
                    	((DWORD*)pMapTbl)[c] |= uv;
                	}
				}

                c++;
                cCharRun++;
            }
        }

        //
        // Determine if this is a new Unicode run.
        //
        if (bFound && !bInRun)
        {
            //
            // This is the beginning of a new run.
            //
            bInRun = TRUE;
            pGlyphRuns[cRuns].wcLow = (USHORT) (uv & 0xffff);
        }

        //
        // Determine if this is the end of a run.
        //
        if (bInRun && (!bFound || uv == NUM_UNICODE_CHARS || c == cChars))
        {
            //
            // This is the end of a run.
            //
            bInRun = FALSE;
            pGlyphRuns[cRuns].wGlyphCount = cCharRun;
            cRuns++;
            cCharRun = 0;
        }
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // Create V GLYPHSETDATA
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Count chars and runs in V maps.
    //
    // For the V GLYPHSETDATA, if a Unicode value is not found in V Unicode->
    // CID map, we will then need to check H Unicode->CID map.
    //
    cChars = cRuns = 0;
    bInRun = bFound = FALSE;

    for (uv = 0; uv < NUM_UNICODE_CHARS; uv++)
    {
        //
        // Search for the Unicode value in V, and then H Unicode->CID maps if
        // not found.
        //
        pCMapRange = bsearch(&uv,
                                pUv2CidMap[V_CMAP]->CMapRange,
                                pUv2CidMap[V_CMAP]->cRuns,
                                sizeof(CMAPRANGE),
                                FindChCodeRun);

        bFound = (pCMapRange != NULL);

        if (bFound == FALSE)
        {
            pCMapRange = bsearch(&uv,
                                    pUv2CidMap[H_CMAP]->CMapRange,
                                    pUv2CidMap[H_CMAP]->cRuns,
                                    sizeof(CMAPRANGE),
                                    FindChCodeRun);

            bFound = (pCMapRange != NULL);
        }

        if (bFound)
        {
            //
            // Found this unicode value. Determine if it maps to a CharCode in
            // H or V Unicode->CharCode map.
            //
            pCMapRange = bsearch(&uv,
                                    pUv2CcMap[V_CMAP]->CMapRange,
                                    pUv2CcMap[V_CMAP]->cRuns,
                                    sizeof(CMAPRANGE),
                                    FindChCodeRun);

            bFound = (pCMapRange != NULL);

            if (bFound == FALSE)
            {
                pCMapRange = bsearch(&uv,
                                        pUv2CcMap[H_CMAP]->CMapRange,
                                        pUv2CcMap[H_CMAP]->cRuns,
                                        sizeof(CMAPRANGE),
                                        FindChCodeRun);

                bFound = (pCMapRange != NULL);
            }

            if (bFound)
            {
                cChars++;
            }
        }

        //
        // Determine if this is a new run.
        //
        bInRun = bFound && bInRun;
        if (bFound && !bInRun)
        {
            cRuns++;
            bInRun = TRUE;
        }
    }

    //
    // Compute amount of memory required for V GLYPHSET.
    //
    dwGSNameSize = ALIGN4(strlen(pWinCodePage->pszCPname) + 2);
    dwCodePageInfoSize = ALIGN4(pWinCodePage->usNumBaseCsets * sizeof(CODEPAGEINFO));
    dwGlyphRunSize = ALIGN4(cRuns * sizeof(GLYPHRUN));

    cGlyphSetBytes[V_CMAP]  = ALIGN4(sizeof(GLYPHSETDATA));
    cGlyphSetBytes[V_CMAP] += dwGSNameSize;
    cGlyphSetBytes[V_CMAP] += dwCodePageInfoSize;
    cGlyphSetBytes[V_CMAP] += dwGlyphRunSize;

	//
	// Account for the size of the mapping table.
	//
	cGlyphSetBytes[V_CMAP] += bSingleCodePage ? ALIGN4((cChars * sizeof (WORD))) : (cChars * sizeof (DWORD));

    //
    // Account for size of CODEPAGE name strings found in CODEPAGEINFO
    // struct(s).
    //
    for (dwCPIGSNameSize = 0, i = 0; i < pWinCodePage->usNumBaseCsets; i++)
    {
        dwCPIGSNameSize += ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[i]].pGSName) + 1);
    }
    cGlyphSetBytes[V_CMAP] += dwCPIGSNameSize;

    //
    // Alloc memory for V GLYPHSET, Unicode->CID mapping table.
    //
    pGlyphSets[V_CMAP] = (PGLYPHSETDATA)MemAllocZ(cGlyphSetBytes[V_CMAP]);
    if (pGlyphSets[V_CMAP] == NULL)
    {
        ERR(("makentf - CreateCJKGlyphSets: malloc\n"));
        return(FALSE);
    }

    pUniPsTbl[V_CMAP] = (PULONG)MemAllocZ(cChars * sizeof(ULONG));
    if (pUniPsTbl[V_CMAP] == NULL)
    {
        ERR(("makentf - CreateCJKGlyphSets: malloc\n"));
        return(FALSE);
    }

    //
    // Init GLYPHSETDATA for V.
    //
    pGlyphSets[V_CMAP]->dwSize = cGlyphSetBytes[V_CMAP];
    pGlyphSets[V_CMAP]->dwVersion = GLYPHSETDATA_VERSION;
    pGlyphSets[V_CMAP]->dwFlags = 0;
    pGlyphSets[V_CMAP]->dwGlyphSetNameOffset = ALIGN4(sizeof(GLYPHSETDATA));
    pGlyphSets[V_CMAP]->dwGlyphCount = cChars;
    pGlyphSets[V_CMAP]->dwCodePageCount = pWinCodePage->usNumBaseCsets;
    pGlyphSets[V_CMAP]->dwCodePageOffset = pGlyphSets[V_CMAP]->dwGlyphSetNameOffset + dwGSNameSize;
    pGlyphSets[V_CMAP]->dwRunCount = cRuns;
    pGlyphSets[V_CMAP]->dwRunOffset = pGlyphSets[V_CMAP]->dwCodePageOffset + dwCodePageInfoSize + dwCPIGSNameSize;
    pGlyphSets[V_CMAP]->dwMappingTableOffset = pGlyphSets[V_CMAP]->dwRunOffset + dwGlyphRunSize;

	//
	// Set the mapping table type flag to dwFlags field.
	//
	pGlyphSets[V_CMAP]->dwFlags |= bSingleCodePage ? GSD_MTT_WCC : GSD_MTT_DWCPCC;

    //
    // Store GlyphSet name
    //
    pGlyphSetName = (PBYTE)MK_PTR(pGlyphSets[V_CMAP], dwGlyphSetNameOffset);
    StringCchCopyA(pGlyphSetName, dwGSNameSize, pWinCodePage->pszCPname);
    pGlyphSetName[strlen(pWinCodePage->pszCPname)] = 'V';
    pGlyphSetName[strlen(pWinCodePage->pszCPname) + 1] = '\0';

    //
    // Initialize a CODEPAGEINFO struct for each base charset supported
    // by this font.
    //
    pCodePageInfo = (PCODEPAGEINFO) MK_PTR(pGlyphSets[V_CMAP], dwCodePageOffset);
    dwEncodingNameOffset = dwCodePageInfoSize;

    for (i = 0; i < pWinCodePage->usNumBaseCsets; i++, pCodePageInfo++)
    {
        //
        // Save CODEPAGEINFO name, id. We don't use PS encoding vectors.
        //
        pCodePageInfo->dwCodePage = aPStoCP[pWinCodePage->pCsetList[i]].usACP;
        pCodePageInfo->dwWinCharset = (DWORD)aPStoCP[pWinCodePage->pCsetList[i]].jWinCharset;
        pCodePageInfo->dwEncodingNameOffset = dwEncodingNameOffset;
        pCodePageInfo->dwEncodingVectorDataSize = 0;
        pCodePageInfo->dwEncodingVectorDataOffset = 0;

        //
        // Copy codepage name string to end of array of CODEPAGEINFOs.
        //
        StringCchCopyA((PBYTE)MK_PTR(pCodePageInfo, dwEncodingNameOffset),
                ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[i]].pGSName) + 1),
                aPStoCP[pWinCodePage->pCsetList[i]].pGSName);

        //
        // Adjust the offset to the CodePage name for the next CODEPAGEINFO structure.
        //
        dwEncodingNameOffset -= sizeof(CODEPAGEINFO);
        dwEncodingNameOffset += ALIGN4(strlen((PSZ)MK_PTR(pCodePageInfo, dwEncodingNameOffset)) + 1);
    }

    //
    // Create V Glyphset by merging V and H Maps.
    //

    //
    // Determine number of runs, chars in the Glyphset created when V and H
    // Maps are merged.
    //
    cRuns = 0;
    cCharRun = 0;
    bInRun = bFound = FALSE;
    pGlyphRuns = GSD_GET_GLYPHRUN(pGlyphSets[V_CMAP]);
    pMapTbl = GSD_GET_MAPPINGTABLE(pGlyphSets[V_CMAP]);

    for (uv = c = 0; (uv < NUM_UNICODE_CHARS) && (c < cChars); uv++)
    {
        pCMapRange = bsearch(&uv,
                                pUv2CidMap[V_CMAP]->CMapRange,
                                pUv2CidMap[V_CMAP]->cRuns,
                                sizeof(CMAPRANGE),
                                FindChCodeRun);

        bFound = (pCMapRange != NULL);

        if (bFound == FALSE)
        {
            pCMapRange = bsearch(&uv,
                                    pUv2CidMap[H_CMAP]->CMapRange,
                                    pUv2CidMap[H_CMAP]->cRuns,
                                    sizeof(CMAPRANGE),
                                    FindChCodeRun);

            bFound = (pCMapRange != NULL);
        }

        //
        // Found this Unicode value. Determine if it maps to a CharCode in H
        // or V Unicode->CC map.
        //
        if (bFound)
        {
            curCID = pCMapRange->CIDStrt + (uv - pCMapRange->ChCodeStrt);

            pCMapRange = bsearch(&uv,
                                    pUv2CcMap[V_CMAP]->CMapRange,
                                    pUv2CcMap[V_CMAP]->cRuns,
                                    sizeof(CMAPRANGE),
                                    FindChCodeRun);

            bFound = (pCMapRange != NULL);

            if (bFound == FALSE)
            {
                pCMapRange = bsearch(&uv,
                                        pUv2CcMap[H_CMAP]->CMapRange,
                                        pUv2CcMap[H_CMAP]->cRuns,
                                        sizeof(CMAPRANGE),
                                        FindChCodeRun);

                bFound = (pCMapRange != NULL);
            }

            if (bFound)
            {
                //
                // Found this Unicode value in Unicode->CharCode map. Store in
                // mapping table. Note that CJK fonts only support 1 charset
                // per font.
                //
                pUniPsTbl[V_CMAP][c] = curCID;

				if (bSingleCodePage)
				{
					if (pCMapRange != NULL)
						((WORD*)pMapTbl)[c] = (WORD)(pCMapRange->CIDStrt + (uv - pCMapRange->ChCodeStrt));
					else
						((WORD*)pMapTbl)[c] = (WORD)uv;
				}
				else
				{
                	((DWORD*)pMapTbl)[c] = aPStoCP[pWinCodePage->pCsetList[0]].usACP << 16;
                	if (pCMapRange != NULL)
                	{
                    	((DWORD*)pMapTbl)[c] |= pCMapRange->CIDStrt + (uv - pCMapRange->ChCodeStrt);
                	}
                	else
                	{
                    	((DWORD*)pMapTbl)[c] |= uv;
                	}
				}

                c++;
                cCharRun++;
            }
        }

        //
        // Determine if this is a new Unicode run.
        //
        if (bFound && !bInRun)
        {
            //
            // This is the beginning of a new run.
            //
            bInRun = TRUE;
            pGlyphRuns[cRuns].wcLow = (USHORT) (uv & 0xffff);
        }

        //
        // Determine if this is the end of a run.
        //
        if (bInRun && (!bFound || uv == NUM_UNICODE_CHARS || c == cChars))
        {
            //
            // This is the end of a run.
            //
            bInRun = FALSE;
            pGlyphRuns[cRuns].wGlyphCount = cCharRun;
            cRuns++;
            cCharRun = 0;
        }
    }

	if (bVerbose)
	{
		for (i = 0; i < NUM_VARIANTS; i++)
		{
			printf("GLYPHSETDATA:dwFlags:%08X\n", pGlyphSets[i]->dwFlags);
			printf("GLYPHSETDATA:dwGlyphSetNameOffset:%s\n",
						(PSZ)MK_PTR(pGlyphSets[i], dwGlyphSetNameOffset));
			printf("GLYPHSETDATA:dwGlyphCount:%ld\n", pGlyphSets[i]->dwGlyphCount);
			printf("GLYPHSETDATA:dwRunCount:%ld\n", pGlyphSets[i]->dwRunCount);
			printf("GLYPHSETDATA:dwCodePageCount:%ld\n", pGlyphSets[i]->dwCodePageCount);
			{
				DWORD dw;
				PCODEPAGEINFO pcpi = (PCODEPAGEINFO)MK_PTR(pGlyphSets[i], dwCodePageOffset);
				for (dw = 1; dw <= pGlyphSets[i]->dwCodePageCount; dw++)
				{
					printf("CODEPAGEINFO#%ld:dwCodePage:%ld\n", dw, pcpi->dwCodePage);
					printf("CODEPAGEINFO#%ld:dwWinCharset:%ld\n", dw, pcpi->dwWinCharset);
					printf("CODEPAGEINFO#%ld:dwEncodingNameOffset:%s\n",
								dw, (PSZ)MK_PTR(pcpi, dwEncodingNameOffset));
					pcpi++;
				}
			}
			printf("\n");
		}
	}

    //
    // Clean-up: free the local Maps.
    //
    for (i = 0; i < NUM_VARIANTS; i++)
    {
        //
        // Free temporary data structs.
        //
        if (pUv2CcMap[i] != NULL)
        {
            MemFree(pUv2CcMap[i]);
        }
        if (pUv2CidMap[i] != NULL)
        {
            MemFree(pUv2CidMap[i]);
        }
    }

	if (bVerbose) printf("%%[End Create CJK glyphset]%%%%\n\n");

    return(TRUE);
}

BOOLEAN
NumUV2CIDRuns(
    PBYTE   pCMapFile,
    PULONG  pcRuns,
    PULONG  pcChars
    )
/*++

Routine Description:

    Given a memory mapped file ptr to a Postscript CMap, determine
    the number of CIDRanges (Runs) and total number of chars.

Arguments:

    pCMapFile - Pointer to a memory mapped CMap file.
    pcRuns - Pointer to a ULONG which will contain the number of runs.
    pcChars - Pointer to a ULONG which will contain the number of chars.

Return Value:

    TRUE => success
    FALSE => error

--*/
{
    PBYTE   pToken;
    ULONG   cRanges, i;
    USHORT  chRunStrt, chRunEnd;
    BYTE    LineBuffer[25];
    USHORT  usLineLen;

    *pcRuns = *pcChars = 0;

    //
    // Search for the CID ranges, and determine the number of runs and
    // total number of chars in this GLYPHSET.
    //
    for (; (pCMapFile = FindStringToken(pCMapFile, CID_RANGE_TOK)) != NULL; )
    {
        GET_NUM_CID_RANGES(pCMapFile, cRanges);
        *pcRuns += cRanges;
        NEXT_LINE(pCMapFile);
        for (i = 0; i < cRanges; i++)
        {
            PARSE_TOKEN(pCMapFile, pToken);
            //
            // Get begin and end range codes.
            //
            if (!AsciiToHex(pToken, &chRunStrt))
            {
                return(FALSE);
            }
            if (!AsciiToHex(pCMapFile, &chRunEnd))
            {
                return(FALSE);
            }

            //
            // Compute size of run.
            //
            *pcChars += chRunEnd - chRunStrt + 1;
            NEXT_LINE(pCMapFile);
        }
    }
    return(TRUE);
}

BOOLEAN
BuildUV2CIDMap(
    PBYTE   pCMapFile,
    PCMAP   pCMap
    )
/*++

Routine Description:

    Given a memory mapped file ptr to a Postscript CMap, create a CMAP
    struture which contains char run information.

Arguments:

    pCMapFile - Pointer to a memory mapped CMap file.
    pCMap - Pointer to pre allocated memory large enough to contain the CMap.

Return Value:

    TRUE => success.
    FALSE => error.

--*/
{
    ULONG   i, cRuns, cRanges;
    USHORT  chRunStrt, chRunEnd;
    PBYTE   pToken;

    //
    // Process the CMap to determine the number of CID runs
    // and the number of chars in this char collection.
    //
    cRuns = cRanges = 0;
    for (; (pCMapFile = FindStringToken(pCMapFile, CID_RANGE_TOK)) != NULL; )
    {
        GET_NUM_CID_RANGES(pCMapFile, cRanges);

        //
        // Skip to first range.
        //
        NEXT_LINE(pCMapFile);
        for (i = 0; i < cRanges; i++)
        {
            //
            // Retrieve the start and stop codes.
            //
            PARSE_TOKEN(pCMapFile, pToken);

            //
            // Get begin and end range codes.
            //
            if (!AsciiToHex(pToken, &chRunStrt))
            {
                return(FALSE);
            }
            if (!AsciiToHex(pCMapFile, &chRunEnd))
            {
                return(FALSE);
            }
            pCMap->CMapRange[cRuns + i].ChCodeStrt = chRunStrt;
            pCMap->CMapRange[cRuns + i].cChars = chRunEnd - chRunStrt + 1;

            //
            // Get CID.
            //
            PARSE_TOKEN(pCMapFile, pToken);
            pCMap->CMapRange[cRuns + i].CIDStrt = atol(pCMapFile);
            NEXT_LINE(pCMapFile);
        }
        cRuns += cRanges;
    }
    pCMap->cRuns = cRuns;
    return(TRUE);
}

BOOLEAN
NumUV2CCRuns(
    PBYTE   pFile,
    PULONG  pcRuns,
    PULONG  pcChars
    )
/*++

Routine Description:

    Given a memory mapped file ptr to a Unicode to CharCode mapping,
    determine the number of runs and total number of chars.

Arguments:

    pFile - Pointer to a memory mapped file.
    pcRuns - Pointer to a ULONG which will contain the number of runs.
    pcChars - Pointer to a ULONG which will contain the number of chars.

Return Value:

    TRUE => success
    FALSE => error

--*/
{
    PBYTE   pToken;
    USHORT  lastUnicode, lastCharCode;
    USHORT  currentUnicode, currentCharCode;
    ULONG   numChars, numRuns;

    *pcRuns = *pcChars = 0;
    numChars = numRuns = 0;

    lastUnicode = lastCharCode = 0;
    currentUnicode = currentCharCode = 0;

    while (TRUE)
    {
        PARSE_TOKEN(pFile, pToken);
        if (StrCmp(pToken, "EOF") != 0)
        {
            if (!AsciiToHex(pToken, &currentUnicode))
            {
                return(FALSE);
            }

            PARSE_TOKEN(pFile, pToken);
            if (StrCmp(pToken, "EOF") != 0)
            {
                if (!AsciiToHex(pToken, &currentCharCode))
                {
                    return(FALSE);
                }
            }
            else
                return(FALSE);

            (*pcChars)++;
        }
        else
            return(TRUE);

        if ((currentUnicode > (lastUnicode + 1)) ||
            (currentCharCode != (lastCharCode + 1)))
        {
            (*pcRuns)++;
        }

        lastUnicode = currentUnicode;
        lastCharCode = currentCharCode;
    }
}

BOOLEAN
BuildUV2CCMap(
    PBYTE   pFile,
    PCMAP   pCMap
    )
/*++

Routine Description:

    Given a memory mapped file ptr to a Unicode to CharCode mapping,
    create a CMAP struture which contains char run information.

Arguments:

    pFile - Pointer to a memory mapped file.
    pCMap - Pointer to pre allocated memory large enough to contain the CMAP.

Return Value:

    TRUE => success.
    FALSE => error.

--*/
{
    PBYTE   pToken;
    USHORT  startUnicode, startCharCode;
    USHORT  lastUnicode, lastCharCode;
    USHORT  currentUnicode, currentCharCode;
    ULONG   cRuns;
    BOOL    done = FALSE;

    startUnicode = startCharCode = 0;
    lastUnicode = lastCharCode = 0;
    currentUnicode = currentCharCode = 0;
    cRuns = 0;

    while (!done)
    {
        PARSE_TOKEN(pFile, pToken);
        if (StrCmp(pToken, "EOF") != 0)
        {
            if (!AsciiToHex(pToken, &currentUnicode))
            {
                return(FALSE);
            }

            PARSE_TOKEN(pFile, pToken);
            if (StrCmp(pToken, "EOF") != 0)
            {
                if (!AsciiToHex(pToken, &currentCharCode))
                {
                    return(FALSE);
                }
            }
            else
                return(FALSE);
        }
        else
            done = TRUE;

        if ((currentUnicode > (lastUnicode + 1)) ||
            (currentCharCode != (lastCharCode + 1)) ||
            (done))
        {
            if (startUnicode > 0)
            {
                pCMap->CMapRange[cRuns].ChCodeStrt = startUnicode;
                pCMap->CMapRange[cRuns].cChars = lastUnicode - startUnicode + 1;
                pCMap->CMapRange[cRuns].CIDStrt = startCharCode;
                cRuns++;
            }
            startUnicode = currentUnicode;
            startCharCode = currentCharCode;
        }

        lastUnicode = currentUnicode;
        lastCharCode = currentCharCode;
    }

    pCMap->cRuns = cRuns;

    return(TRUE);
}

int __cdecl
CmpCMapRunsCID(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Compares the starting CID of two CMAPRANGE structs.

Arguments:

    p1, p2 - CMAPRANGEs to compare.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PCMAPRANGE ptr1 = (PCMAPRANGE) p1, ptr2 = (PCMAPRANGE) p2;

    //
    // Compare starting CIDs of the ranges.
    //
    if (ptr1->CIDStrt > ptr2->CIDStrt)
        return(1);
    else if (ptr1->CIDStrt < ptr2->CIDStrt)
        return(-1);
    else
        return(0);
}

int __cdecl
CmpCMapRunsChCode(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Compares the starting Char Code of two CMAPRANGE structs.

Arguments:

    p1, p2 - CMAPRANGEs to compare.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PCMAPRANGE ptr1 = (PCMAPRANGE) p1, ptr2 = (PCMAPRANGE) p2;

    //
    // Compare starting CIDs of the ranges.
    //
    if (ptr1->ChCodeStrt < ptr2->ChCodeStrt)
        return(-1);
    else if (ptr1->ChCodeStrt > ptr2->ChCodeStrt)
        return(1);
    else
        return(0);
}

int __cdecl
FindChCodeRun(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Determines if a Charcode falls within a particular CMap run.

Arguments:

    p1 - CID
    p2 - PCMAPRANGE to check

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PULONG ptr1 = (PULONG) p1;
    PCMAPRANGE ptr2 = (PCMAPRANGE) p2;

    //
    // Determine if CID is in the current range.
    //
    if (*ptr1 < ptr2->ChCodeStrt)
        return(-1);
    else if (*ptr1 >= (ULONG) ptr2->ChCodeStrt + ptr2->cChars)
        return(1);
    else
        return(0);
}

int __cdecl
FindCIDRun(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Determines if a CID falls within a particular CMap run.

Arguments:

    p1 - CID
    p2 - PCMAPRANGE to check

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PULONG ptr1 = (PULONG) p1;
    PCMAPRANGE ptr2 = (PCMAPRANGE) p2;

    //
    // Determine if CID is in the current range.
    //
    if (*ptr1 < ptr2->CIDStrt)
        return(-1);
    else if (*ptr1 >= ptr2->CIDStrt + ptr2->cChars)
        return(1);
    else
        return(0);
}

CHSETSUPPORT
IsCJKFont(
    PBYTE   pAFM
    )
/*++

Routine Description:

    Determine if a font is a CJK (Far Eastern) font.

Arguments:

    pAFM - ptr to memory mapped AFM file

Return Value:

    0 - Font not CJK
    Otherwise, font is CJK, and return value is the Win Codepage value

--*/
{
    PBYTE   pToken;
    USHORT  i;

    //
    // Search for CharacterSet token.
    //
    pToken = pAFMCharacterSetString;
    if (pToken == NULL)
    {
        //
        // We can't determine if this font is CJK, so assume it isn't.
        //
        return 0;
    }

    //
    // Search for CharSet (actually Adobe Char Collection) name in CJK table.
    //
    for (i = 0; i < CjkColTbl.usNumEntries; i++)
    {
        if (!StrCmp(pToken, (PBYTE) (((PKEY) (CjkColTbl.pTbl))[i].pName)))
        {
            return(CSUP(((PKEY) (CjkColTbl.pTbl))[i].usValue));
        }
    }

    //
    // Not a recognized CJK font.
    //
    return 0;
}

BOOLEAN
IsVGlyphSet(
    PGLYPHSETDATA   pGlyphSetData
    )
/*++

Routine Description:

    Determine if a Glyphset is a CJK V variant. Should ONLY be used with
    CJK Glyphsets, otherwise result could be unpredictable!

Arguments:

    pGlyphSetData - ptr to GLYPHSETDATA

Return Value:

    TRUE - this is a V variant
    FALSE - not a V variant

--*/
{
    PBYTE   pName;

    pName = (PBYTE) MK_PTR(pGlyphSetData, dwGlyphSetNameOffset);
    return((pName[strlen(pName) - 1] == 'V'));
}

BOOLEAN
IsCIDFont(
    PBYTE   pAFM
    )
/*++

Routine Description:

    Determine if a font is a CID font.

Arguments:

    pAFM - ptr to memory mapped AFM file

Return Value:

    0 - Font not clone.
    Otherwise, font is a CID font, and return value non-zero.

--*/
{
    PBYTE   pToken;

    if (pToken = FindAFMToken(pAFM, PS_CIDFONT_TOK))
    {
        if (!StrCmp(pToken, "true"))
            return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\ppd\ppdrsrc.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdrsrc.h

Abstract:

    PPD parser string resource IDs - This is needed because the
    binary printer description data contains the default TrueType
    to Type1 font substitution table and the TrueType font name
    must be localized.

Environment:

    Windows NT PostScript driver

Revision History:

    08/20/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _PPDRSRC_H_
#define _PPDRSRC_H_

//
// Resource IDs starts at 30K to minimize the chance of conflicting
// with other string resources in the driver DLL.
//

#define IDS_TRAY_MANUALFEED                     30700
#define IDS_PSCRIPT_CUSTOMSIZE                  30701


//
// String IDs for TT->PS substitution
//

#define TT2PS_INTERVAL                          20

// Roman
#define IDR_1252                                30800

#define IDS_1252_BEGIN                          30800

#define IDS_TT_ARIAL                            30800
#define IDS_TT_ARIAL_NARROW                     30801
#define IDS_TT_BOOK_ANTIQUA                     30802
#define IDS_TT_BOOKMAN_OLD_STYLE                30803
#define IDS_TT_CENTURY_GOTHIC                   30804
#define IDS_TT_CENTURY_SCHOOLBOOK               30805
#define IDS_TT_COURIER_NEW                      30806
#define IDS_TT_MONOTYPE_CORSIVA                 30807
#define IDS_TT_MONOTYPE_SORTS                   30808
#define IDS_TT_TIMES_NEW_ROMAN                  30809
#define IDS_TT_SYMBOL                           30810

#define IDS_PS_HELVETICA						(IDS_TT_ARIAL				+ TT2PS_INTERVAL)
#define IDS_PS_HELVETICA_NARROW					(IDS_TT_ARIAL_NARROW		+ TT2PS_INTERVAL)
#define IDS_PS_PALATINO							(IDS_TT_BOOK_ANTIQUA		+ TT2PS_INTERVAL)
#define IDS_PS_ITC_BOOKMAN						(IDS_TT_BOOKMAN_OLD_STYLE	+ TT2PS_INTERVAL)
#define IDS_PS_AVANTEGARDE						(IDS_TT_CENTURY_GOTHIC		+ TT2PS_INTERVAL)
#define IDS_PS_NEWCENTURYSCHLBK					(IDS_TT_CENTURY_SCHOOLBOOK	+ TT2PS_INTERVAL)
#define IDS_PS_COURIER							(IDS_TT_COURIER_NEW			+ TT2PS_INTERVAL)
#define IDS_PS_ZAPFCHANCERY						(IDS_TT_MONOTYPE_CORSIVA	+ TT2PS_INTERVAL)
#define IDS_PS_ZAPFDINGBATS						(IDS_TT_MONOTYPE_SORTS		+ TT2PS_INTERVAL)
#define IDS_PS_TIMES							(IDS_TT_TIMES_NEW_ROMAN		+ TT2PS_INTERVAL)
#define IDS_PS_SYMBOL							(IDS_TT_SYMBOL				+ TT2PS_INTERVAL)

#define IDS_1252_END                            30810


// Japanese
#define IDR_932                                 30900

#define IDS_932_BEGIN                           30900

#define IDS_TT_MS_MINCHO                        30900
#define IDS_TT_MS_GOTHIC                        30901

#define IDS_PS_RYUMIN_LIGHT                     (IDS_TT_MS_MINCHO           + TT2PS_INTERVAL)
#define IDS_PS_GOTHICBBB_MEDIUM 				(IDS_TT_MS_GOTHIC           + TT2PS_INTERVAL)

#define IDS_932_END                             30901


// Chinese Simplified
#define IDR_936                                 31000

#define IDS_936_BEGIN                           31000

#define IDS_TT_KAITI_GB2312                     31000
#define IDS_TT_FANGSONG_GB2312                  31001

#define IDS_PS_STKAITI_REGULAR                  (IDS_TT_KAITI_GB2312        + TT2PS_INTERVAL)
#define IDS_PS_STFANGSONG_LIGHT                 (IDS_TT_FANGSONG_GB2312     + TT2PS_INTERVAL)

#define IDS_936_END                             31001


// Korean
#define IDR_949                                 31100

#define IDS_949_BEGIN                           31100

#define IDS_TT_BATANG                           31100
#define IDS_TT_BATANGCHE                        31101
#define IDS_TT_GUNGSUH                          31102
#define IDS_TT_GUNGSUHCHE                       31103
#define IDS_TT_GULIM                            31104
#define IDS_TT_GULIMCHE                         31105
#define IDS_TT_DOTUM                            31106
#define IDS_TT_DOTUMCHE                         31107

#define IDS_PS_HYSMYEONGJO_MEDIUM               (IDS_TT_BATANG              + TT2PS_INTERVAL)
#define IDS_PS_HYSMYEONGJO_MEDIUM_HW            (IDS_TT_BATANGCHE           + TT2PS_INTERVAL)
#define IDS_PS_HYGUNGSO_BOLD                    (IDS_TT_GUNGSUH             + TT2PS_INTERVAL)
#define IDS_PS_HYGUNGSO_BOLD_HW                 (IDS_TT_GUNGSUHCHE          + TT2PS_INTERVAL)
#define IDS_PS_HYRGOTHIC_MEDIUM                 (IDS_TT_GULIM               + TT2PS_INTERVAL)
#define IDS_PS_HYRGOTHIC_MEDIUM_HW              (IDS_TT_GULIMCHE            + TT2PS_INTERVAL)
#define IDS_PS_HYGOTHIC_MEDIUM                  (IDS_TT_DOTUM               + TT2PS_INTERVAL)
#define IDS_PS_HYGOTHIC_MEDIUM_HW               (IDS_TT_DOTUMCHE            + TT2PS_INTERVAL)

#define IDS_949_END                             31107


#endif  // !_PPDRSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\makentf\afm2ntm.c ===
/*++

Copyright (c) 1996 Adobe Systems Incorporated
Copyright (c) 1996  Microsoft Corporation

Module Name:

    afm2ntm.c

Abstract:

    Convert AFM to NTM.

Environment:

    Windows NT PostScript driver: makentf utility.

Revision History:

    09/11/97 -ksuzuki-
        Added code to support localized menu name, fixed pitch CJK font, and
        two IFIMETRICS.

    12/11/96 -rkiesler-
        Wrote functions.

    09/16/96 -slam-
        Created initial framework.

--*/


#include "lib.h"
#include "ppd.h"
#include "pslib.h"
#include "psglyph.h"
#include "afm2ntm.h"
#include "cjkfonts.h"
#include "winfont.h"


//
// Extarnals
//
extern PSTR pAFMFileName;
extern BOOL bVerbose;
extern BOOL bOptimize;

VOID
SortWinCPT(
    IN OUT  WINCPT      *pSortedWinCpts,
    IN      WINCPTOPS   *pCPtoPS
);

//
// Globals.
//
#define NUM_DPCHARSET 16

PUPSCODEPT  pPsNames;
BOOL        isSymbolCharSet=FALSE;

//
// The purpose of the NTMSIZEINFO and IFIMETRICSSIZEINFO structures is
// to hold aligned size of each structure element.
//
typedef struct _NTMSIZEINFO
{
    int nSize;
    int nFontNameSize;
    int nDisplayNameSize;
    int nGlyphSetNameSize;
    int nCharWidthSize;
    int nKernPairSize;
    int nCharDefSize;
    int nTotalSize;
}
NTMSIZEINFO;

typedef struct _IFIMETRICSSIZEINFO
{
    int nSize;
    int nIfiExtraSize;
    int nFamilyNameSize;
    int nStyleNameSize;
    int nFaceNameSize;
    int nUniqueNameSize;
    int nFontSimSize;
    int nBoldSize;
    int nItalicSize;
    int nBoldItalicSize;
    int nCharSetSize;
    int nTotalSize;
}
IFIMETRICSSIZEINFO;

#define INIT_NTMSIZEINFO(nsi) \
{\
    (nsi).nSize = -1;\
    (nsi).nFontNameSize = -1;\
    (nsi).nDisplayNameSize = -1;\
    (nsi).nGlyphSetNameSize = -1;\
    (nsi).nCharWidthSize = -1;\
    (nsi).nKernPairSize = -1;\
    (nsi).nCharDefSize = -1;\
    (nsi).nTotalSize = -1;\
};

#define INIT_IFIMETRICSSIZEINFO(isi) \
{\
    (isi).nSize = -1;\
    (isi).nIfiExtraSize = -1;\
    (isi).nFamilyNameSize = -1;\
    (isi).nStyleNameSize = -1;\
    (isi).nFaceNameSize = -1;\
    (isi).nUniqueNameSize = -1;\
    (isi).nFontSimSize = -1;\
    (isi).nBoldSize = -1;\
    (isi).nItalicSize = -1;\
    (isi).nBoldItalicSize = -1;\
    (isi).nCharSetSize = -1;\
    (isi).nTotalSize = -1;\
};

#define GET_NTMTOTALSIZE(nsi) \
{\
    if ((nsi).nSize == -1 \
        || (nsi).nFontNameSize == -1 \
        || (nsi).nDisplayNameSize == -1 \
        || (nsi).nGlyphSetNameSize == -1 \
        || (nsi).nCharWidthSize == -1 \
        || (nsi).nKernPairSize == -1 \
        || (nsi).nCharDefSize == -1)\
    {\
        ERR(("makentf - afm2ntm: GET_NTMTOTALSIZE\n"));\
    }\
    (nsi).nTotalSize = (nsi).nSize \
                        + (nsi).nFontNameSize \
                        + (nsi).nDisplayNameSize \
                        + (nsi).nGlyphSetNameSize \
                        + (nsi).nCharWidthSize \
                        + (nsi).nKernPairSize \
                        + (nsi).nCharDefSize;\
};

#define GET_IFIMETRICSTOTALSIZE(isi) \
{\
    if ((isi).nSize == -1 \
        || (isi).nIfiExtraSize == -1 \
        || (isi).nFamilyNameSize == -1 \
        || (isi).nStyleNameSize == -1 \
        || (isi).nFaceNameSize == -1 \
        || (isi).nUniqueNameSize == -1 \
        || (isi).nFontSimSize == -1 \
        || (isi).nBoldSize == -1 \
        || (isi).nItalicSize == -1 \
        || (isi).nBoldItalicSize == -1 \
        || (isi).nCharSetSize == -1)\
    {\
        ERR(("makentf - afm2ntm: GET_IFIMETRICSTOTALSIZE\n"));\
    }\
    (isi).nTotalSize = (isi).nSize \
                        + (isi).nIfiExtraSize \
                        + (isi).nFamilyNameSize \
                        + (isi).nStyleNameSize \
                        + (isi).nFaceNameSize \
                        + (isi).nUniqueNameSize \
                        + (isi).nFontSimSize \
                        + (isi).nBoldSize \
                        + (isi).nItalicSize \
                        + (isi).nBoldItalicSize \
                        + (isi).nCharSetSize;\
};

#define FREE_AFMTONTM_MEMORY \
{\
    if (pNameStr2 != pNameStr) MemFree(pNameStr2);\
    MemFree(pNameStr);\
    MemFree(pFontChars);\
    MemFree(pCharDefTbl);\
};


PNTM
AFMToNTM(
    PBYTE           pAFM,
    PGLYPHSETDATA   pGlyphSetData,
    PULONG          pUniPs,
    CHSETSUPPORT    *pCharSet,
    BOOL            bIsCJKFont,
    BOOL            bIsPitchChanged
    )

/*++

Routine Description:

    Convert AFM to NTM.

Arguments:

    pAFM - pointer to memory mapped AFM file.

    pGlyphSetData - pointer to the GLYPHSETDATA struct which represents
    this font's preferred charset.

    pUniPs - Points to a table which maps 0-based Glyph Indices of chars
    in the GLYPHRUNS of the GLYPHSETDATA struct for this font to indices
    into the UnicodetoPs structure which maps Unicode points to PS char
    information. This mapping array is created by the CreateGlyphSets
    function defined in this module.

Return Value:

    NULL => error
    otherwise => ptr to a NTM.

--*/

{
    USHORT          multiCharSet=0;
    IFIEXTRA        *pifiEx;
    PBYTE           pChMetrics, pToken, pChWidthTok, pCharDefTbl, pby;
    CHSETSUPPORT    chSets;
    PSZ             pszGlyphSetName, pszFontName, pszFamilyName, pszEngFamilyName;
    int             cGlyphSetNameLen, cFontNameLen, cFamilyNameLen, cEngFamilyNameLen;
    int             cNameStrLen, wcNameStrLen, cNameStr2Len, wcNameStr2Len, chCnt;
    PNTM            pNTM;
    PIFIMETRICS     pifi, pifi2;
    PWIDTHRUN       pWidthRuns;
    SHORT           sIntLeading, sAscent, sExternalLeading;
    ULONG           ulNTMSize, ulIFISize, ulIFISize2;
    ULONG           ulChCnt, ulCharDefTbl, ulKernPairs, ulAliases;
    ETMINFO         EtmInfo;
    PPSFAMILYINFO   pFamilyInfo;
    RECT            rcBBox;
    LPPANOSE        ppanose;
    PGLYPHRUN       pGlyphRun;
    PSTR            pNameStr, pNameStr2;
    FD_KERNINGPAIR  *pKernPairs;
    PPSCHARMETRICS  pFontChars;
    BOOLEAN         bIsVGlyphSet, bIsMSFaceName, bIsFixedPitch, bIsItalic, bIsBold;
    USHORT          jWinCharSet;
    CHARSETINFO     csi;
    char            szStyleName[64], szUniqueID[32];
    int             i, j;
    BOOL            bRightFamilyInfo = TRUE;

    NTMSIZEINFO         nsi;
    IFIMETRICSSIZEINFO  isi;

    VERBOSE(("Entering AFMToNTM...\n"));

    INIT_NTMSIZEINFO(nsi);
    INIT_IFIMETRICSSIZEINFO(isi);

    pNTM = NULL;
    pFontChars = NULL;
    pCharDefTbl = NULL;
    pNameStr = pNameStr2 = NULL;
    szStyleName[0] = szUniqueID[0] = '\0';

    if (bVerbose) printf("AFM file name:%s\n", pAFMFileName);


    //////////////////////////////////////////////////////////////////////////
    //
    // We support two kinds of CJK AFM files: Adobe CID font AFM or
    // clone PS font AFM. Adobe CID font AFM always has the following
    // key-value pairs.
    //
    //      FontName Ryumin-Light
    //      CharacterSet Adobe-Japan1-1 (or others except 'Adobe-Japan1-0')
    //      IsCIDFont true (must be there)
    //
    // Note that the FontName value does not include encoding name.
    // Just font family name only.
    //
    // Clone PS font AFM has the following special key-value pairs.
    //
    //      FontName RicohKaisho
    //      CharacterSet Adobe-Japan1-0
    //      IsCIDFont false (or must not be there)
    //
    // The FontName value of clone PS font AFM shouldn't include encoding
    // name neither, the CharacterSet value is 'Adobe-Japan1-0' for J, and
    // IsCIDFont key should not be specified or must be 'false'.
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Find which glyphset we are dealing with.
    //
    bIsVGlyphSet = IsVGlyphSet(pGlyphSetData);

    pszGlyphSetName = (PSTR)MK_PTR(pGlyphSetData, dwGlyphSetNameOffset);

    cGlyphSetNameLen = strlen(pszGlyphSetName);

    if (bOptimize)
    {
        //
        // Set referense mark if optimization option is specified. This mark is
        // checked later by the WriteNTF function to exclude unreferenced
        // glyphset data when writing to an NTF file.
        //
        pGlyphSetData->dwReserved[0] = 1;
    }


    //
    // Save number of chars defined in the font.
    // Get ptr to AFM char metrics, then the current
    // pos should be the character count field.
    //
    pToken = FindAFMToken(pAFM, PS_CH_METRICS_TOK);
    if (pToken == NULL)    // Fixed bug 354007
    {
        ERR(("makentf - afm2ntm: CH Metrics missing\n"));
        return NULL;
    }

    for (i = 0; i < (int) StrLen(pToken); i++)
    {
        if (!IS_NUM(&pToken[i]))
        {
            ERR(("makentf - afm2ntm: CH Metrics is not a number\n"));
            return NULL;
        }
    }

    chCnt = atoi(pToken);

    //
    // Get number of GLYPHs from GlyphsetData. We'll need to use define
    // char width table entries and char defined entries for all
    // possible glyphs in the glyphset, even those that are not defined
    // in this particular font.
    //
    ulChCnt = pGlyphSetData->dwGlyphCount;

    //
    // Alloc memory for an array of PSCHARMETRICS structs, one for each char
    // in the font, and build the table of char metrics.
    //
    if ((pFontChars =
        (PPSCHARMETRICS)
        MemAllocZ((size_t) chCnt * sizeof(PSCHARMETRICS))) == NULL)
    {
        ERR(("makentf - afm2ntm: malloc\n"));
        return NULL;
    }

    //
    // Alloc memory for the IsCharDefined table, an array of bits which
    // indicate which chars in the GLYPHSET are defined in this font.
    //
    ulCharDefTbl = ((ulChCnt + 7) / 8) * sizeof (BYTE);

    if ((pCharDefTbl = (PBYTE)MemAllocZ((size_t)ulCharDefTbl)) == NULL)
    {
        ERR(("makentf - afm2ntm: malloc\n"));
        MemFree(pFontChars);
        return NULL;
    }

    //
    // Build table of PSCHARMETRICS info.
    //
    if (!BuildPSCharMetrics(pAFM, pUniPs, pFontChars, pCharDefTbl, ulChCnt))
    {
        ERR(("makentf - afm2ntm: BuildPSCharMetrics\n"));
        MemFree(pFontChars);
        MemFree(pCharDefTbl);
        return NULL;
    }

    //
    // Get font name from AFM and use it to obtain the MS family name
    // from the table in memory.
    //
    pszEngFamilyName = NULL;
    cEngFamilyNameLen = 0;

    pFamilyInfo = NULL;
    pszFontName = FindAFMToken(pAFM, PS_FONT_NAME_TOK);
    if (pszFontName == NULL)   // Fixed bug 354007
    {
        ERR(("makentf - afm2ntm: Font Name Missing\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }

    for (cFontNameLen = 0; !EOL(&pszFontName[cFontNameLen]); cFontNameLen++);

    pFamilyInfo = (PPSFAMILYINFO) bsearch(pszFontName,
                                    (PBYTE) (((PPSFAMILYINFO) (pFamilyTbl->pTbl))[0].pFontName),
                                    pFamilyTbl->usNumEntries,
                                    sizeof(PSFAMILYINFO),
                                    StrCmp);

    if (bIsMSFaceName = (pFamilyInfo != NULL))
    {
        bRightFamilyInfo = TRUE;
        if (bIsPitchChanged && (pFamilyInfo->usPitch == DEFAULT_PITCH))
        {
            bRightFamilyInfo = FALSE;
            if (pFamilyInfo > ((PPSFAMILYINFO) (pFamilyTbl->pTbl)))
            {
                pFamilyInfo = pFamilyInfo - 1;
                if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                    (pFamilyInfo->usPitch != DEFAULT_PITCH ))
                    bRightFamilyInfo = TRUE;
            }
            if (bRightFamilyInfo == FALSE)
            {
                pFamilyInfo = pFamilyInfo + 1;
                if (pFamilyInfo <
                    (((PPSFAMILYINFO) (pFamilyTbl->pTbl)) + pFamilyTbl->usNumEntries))
                {
                    pFamilyInfo = pFamilyInfo + 1;
                    if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                        (pFamilyInfo->usPitch != DEFAULT_PITCH))
                        bRightFamilyInfo = TRUE;
                }
            }
        }
        else if (!bIsPitchChanged && (pFamilyInfo->usPitch != DEFAULT_PITCH))
        {
            bRightFamilyInfo = FALSE;
            if (pFamilyInfo > ((PPSFAMILYINFO) (pFamilyTbl->pTbl)))
            {
                pFamilyInfo = pFamilyInfo - 1;
                if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                    (pFamilyInfo->usPitch == DEFAULT_PITCH))
                    bRightFamilyInfo = TRUE;
            }
            if (bRightFamilyInfo == FALSE)
            {
                pFamilyInfo = pFamilyInfo + 1;
                if (pFamilyInfo <
                    (((PPSFAMILYINFO) (pFamilyTbl->pTbl)) + pFamilyTbl->usNumEntries))
                {
                    pFamilyInfo = pFamilyInfo + 1;
                    if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                        (pFamilyInfo->usPitch == DEFAULT_PITCH))
                        bRightFamilyInfo = TRUE;
                }
            }
        }

    }
    if (bIsMSFaceName && (bRightFamilyInfo == TRUE))
    {
        pszFamilyName = pFamilyInfo->FamilyKey.pName;
        cFamilyNameLen = strlen(pszFamilyName);

        pszEngFamilyName = pFamilyInfo->pEngFamilyName;
        cEngFamilyNameLen = strlen(pszEngFamilyName);

        if (!cEngFamilyNameLen) pszEngFamilyName = NULL;
    }
    else if ((pszFamilyName =
            FindAFMToken(pAFM, PS_FONT_FAMILY_NAME_TOK)) != NULL)
    {
        for (cFamilyNameLen = 0; !EOL(&pszFamilyName[cFamilyNameLen]); cFamilyNameLen++);
    }
    else
    {
        pszFamilyName = pszFontName;
        cFamilyNameLen = cFontNameLen;
    }

    if (bVerbose)
    {
        printf("MSFaceName%sfound:", bIsMSFaceName ? " " : " not ");
        printf("%s\n", bIsMSFaceName ? pszFamilyName : "n/a");
        printf("MSFaceName length:%d\n", bIsMSFaceName ? cFamilyNameLen : -1);
        printf("This is a %s font.\n", bIsVGlyphSet ? "vertical" : "horizontal");
    }

    //
    // Predetermine if this font supports multiple charsets.
    //
    if (pCharSet)
    {
        if (CSET_SUPPORT(*pCharSet, CS_ANSI))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_EASTEUROPE))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_RUSSIAN))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_GREEK))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_TURKISH))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_HEBREW))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_ARABIC))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_BALTIC))
            multiCharSet++;
        if (CSET_SUPPORT(*pCharSet, CS_SYMBOL))
            multiCharSet++;

        //
        // Save Windows Codepage id. Just use the id stored in the first
        // CODEPAGEINFO in the GLYPHSETDATA for this font.
        //
        // The order of this check is important since jWinCharSet
        // should match the first dpCharSets array if it exists.
        //
        if (CSET_SUPPORT(*pCharSet, CS_ANSI))
            jWinCharSet = ANSI_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_EASTEUROPE))
            jWinCharSet = EASTEUROPE_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_RUSSIAN))
            jWinCharSet = RUSSIAN_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_GREEK))
            jWinCharSet = GREEK_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_TURKISH))
            jWinCharSet = TURKISH_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_HEBREW))
            jWinCharSet = HEBREW_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_ARABIC))
            jWinCharSet = ARABIC_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_BALTIC))
            jWinCharSet = BALTIC_CHARSET;
        else if (CSET_SUPPORT(*pCharSet, CS_SYMBOL))
            jWinCharSet = SYMBOL_CHARSET;
    }
    else
    {
        PCODEPAGEINFO cpi = (PCODEPAGEINFO)MK_PTR(pGlyphSetData, dwCodePageOffset);
        jWinCharSet = (USHORT)(cpi->dwWinCharset & 0xffff);
    }

    //
    // Get codepage info for the MultiByteToWideChar function calls.
    //
    // We want to translate a string into a readable one, not into a symbolic
    // one, so that we use ANSI charset when dealing with SYMBOL charset.
    //
    if (jWinCharSet == SYMBOL_CHARSET)
    {
        DWORD dwTmp = ANSI_CHARSET;
        if (!TranslateCharsetInfo(&dwTmp, &csi, TCI_SRCCHARSET))
            csi.ciACP = CP_ACP;
    }
    else if (!TranslateCharsetInfo((DWORD FAR*)jWinCharSet, &csi, TCI_SRCCHARSET))
        csi.ciACP = CP_ACP;


    //////////////////////////////////////////////////////////////////////////
    //
    // Get the size of each element of NTM structure
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Sizes known so far.
    //
    nsi.nSize = ALIGN4(sizeof (NTM));
    nsi.nGlyphSetNameSize = ALIGN4(cGlyphSetNameLen + 1);
    nsi.nCharDefSize = ALIGN4(ulCharDefTbl);

    //
    // Size of the font name. Glyphset name is required for CJK font.
    //
    nsi.nFontNameSize = ALIGN4(cFontNameLen + 1);

    if (bIsCJKFont)
    {
        nsi.nFontNameSize += nsi.nGlyphSetNameSize;
    }

    //
    // Size of the display name. Use pszFamilyName regardless of
    // Roman, C, J, and K fonts. Add one for '@' if it's CJK
    // vertical font.
    //
    i = cFamilyNameLen + 1;
    if (bIsCJKFont && bIsVGlyphSet) i++;
    nsi.nDisplayNameSize = ALIGN4(i);

    //
    // Determine if font is fixed pitch.
    //
    bIsFixedPitch = FALSE;

    if (bIsCJKFont)
    {
        bIsFixedPitch = IsCJKFixedPitchEncoding(pGlyphSetData);
    }
    else if ((pToken = FindAFMToken(pAFM, PS_PITCH_TOK)) != NULL)
    {
        if (!StrCmp(pToken, "true"))
        {
            //
            // This is a fixed pitch font.
            //
            bIsFixedPitch = !StrCmp(pToken, "true");

        }
    }

    if (bIsFixedPitch)
    {
        nsi.nCharWidthSize = 0;
    }
    else
    {
        //
        // Proportional font. Determine number of WIDTHRUNs for this font.
        //
        // Fix bug 240339, jjia, 8/3/98
        nsi.nCharWidthSize =
                GetAFMCharWidths(pAFM, NULL, pFontChars, pUniPs,
                pGlyphSetData->dwGlyphCount, NULL, NULL);
    }

    //
    // Determine if there is the pair kerning info for this font.
    //
    if (ulKernPairs = GetAFMKernPairs(pAFM, NULL, pGlyphSetData))
    {
        //
        // Account for size of kern pairs.
        //
        nsi.nKernPairSize = ALIGN4((ulKernPairs + 1) * sizeof(FD_KERNINGPAIR));
    }
    else
    {
        nsi.nKernPairSize = 0;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // Get the size of each element of IFIMETRICS structure
    //
    //////////////////////////////////////////////////////////////////////////

    isi.nSize = ALIGN4(sizeof (IFIMETRICS));
    //
    // From AdobePS5-NT4 5.1, make the size of NT4 IFIEXTRA same as the one
    // of NT5 or later versions. NT4 IFIEXTRA size is 16 and NT5 IFIEXTRA
    // size is 24.
    //
    if (sizeof (IFIEXTRA) <= 16)
        isi.nIfiExtraSize = 24;
    else
        isi.nIfiExtraSize = ALIGN4(sizeof (IFIEXTRA));

    //
    // For Roman we provide single IFIMETRICS, but we provide two IFIMETRICS
    // for CJK. Font family name element of the first IFIMETRICS begins with
    // a menu name in English then localized one. Font family name element of
    // the second IFIMETRICS begins with a localized menu name then English
    // one. We use pNameStr and pNameStr2 for the English and localized menu
    // names respectively.
    //
    // Prepare pNameStr. Account for encoding name if we are dealing with
    // CJK font.
    //
    i = 0;
    if (bIsCJKFont)
    {
        if (bIsVGlyphSet)
        {
            //
            // V GS, account for preceding '@' char.
            //
            i++;
        }

        if (pszEngFamilyName)
        {
            //
            // IFIMetrics English menu name = [@]fontname
            //
            if ((pNameStr = (PSTR) MemAllocZ(i + cEngFamilyNameLen + 1)) == NULL)
            {
                ERR(("makentf - afm2ntm: malloc\n"));
                FREE_AFMTONTM_MEMORY;
                return NULL;
            }

            if (i) pNameStr[0] = '@';
            memcpy(&(pNameStr[i]), pszEngFamilyName, cEngFamilyNameLen);
            i += cEngFamilyNameLen;
        }
        else
        {
            int cGsNameLen;

            //
            // IFIMetrics English menu name = [@]fontname + GS name string,
            // but it does not end with '-H' or '-V'.
            //
            cGsNameLen = cGlyphSetNameLen - 2;

            if ((pNameStr = (PSTR) MemAllocZ(i + cFontNameLen + cGsNameLen + 1)) == NULL)
            {
                ERR(("makentf - afm2ntm: malloc\n"));
                FREE_AFMTONTM_MEMORY;
                return NULL;
            }

            if (i) pNameStr[0] = '@';
            memcpy(&(pNameStr[i]), pszFontName, cFontNameLen);
            memcpy(&(pNameStr[i + cFontNameLen]), pszGlyphSetName, cGsNameLen);

            i += cFontNameLen + cGsNameLen;
        }
    }
    else
    {
        if ((pNameStr = (PSTR) MemAllocZ(cFamilyNameLen + 1)) == NULL)
        {
            ERR(("makentf - afm2ntm: malloc\n"));
            FREE_AFMTONTM_MEMORY;
            return NULL;
        }
        memcpy(pNameStr, pszFamilyName, cFamilyNameLen);
        i += cFamilyNameLen;
    }
    pNameStr[i] = '\0';

    cNameStrLen = strlen(pNameStr);
    wcNameStrLen = MultiByteToWideChar(csi.ciACP, 0,
                                        pNameStr, cNameStrLen, 0, 0);
    if (!wcNameStrLen)
    {
        ERR(("makentf - afm2ntm: MultiByteToWideChar\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }

    //
    // Prepair pNameStr2. This if for CJK font only. If MS face name
    // is not available, use same name as pNameStr.
    //
    pNameStr2 = NULL;
    cNameStr2Len = wcNameStr2Len = 0;
    if (bIsCJKFont)
    {
        if (bIsMSFaceName)
        {
            //
            // If we are dealing with V encoding, its MS menu name can not be
            // found in psfamily.dat so that add '@' to make it a V menu name.
            //
            i = bIsVGlyphSet ? 1 : 0;

            if ((pNameStr2 = (PSTR)MemAllocZ(i + cFamilyNameLen + 1)) == NULL)
            {
                ERR(("makentf - afm2ntm: malloc\n"));
                FREE_AFMTONTM_MEMORY;
                return NULL;
            }

            if (i) pNameStr2[0] = '@';
            memcpy(&(pNameStr2[i]), pszFamilyName, cFamilyNameLen);
            pNameStr2[i + cFamilyNameLen] = '\0';
        }
        else
        {
            pNameStr2 = pNameStr;
        }

        cNameStr2Len = strlen(pNameStr2);
        wcNameStr2Len = MultiByteToWideChar(csi.ciACP, 0,
                                            pNameStr2, cNameStr2Len, 0, 0);
        if (!wcNameStr2Len)
        {
            ERR(("makentf - afm2ntm: MultiByteToWideChar\n"));
            FREE_AFMTONTM_MEMORY;
            return NULL;
        }
    }


    if (bVerbose)
    {
        printf("Font menu name in English:%s\n", pNameStr);
        printf("Localized Font menu name%savailable:", pNameStr2 ? " " : " not ");
        printf("%s\n", pNameStr2 ? pNameStr2 : "n/a");
    }

    //
    // WIN31 COMPATABILITY!  Check to see if this face name has aliases.
    // if it does, then we need to set the FM_INFO_FAMILY_EQUIV bit of
    // pTmpIFI->flInfo, and fill in an array of family aliases. Note that
    // the cjGetFamilyAliases function gives us the number in Unicode size.
    //
    isi.nFamilyNameSize = ALIGN4(cjGetFamilyAliases(NULL, pNameStr, 0));

    if (pNameStr2)
    {
        //
        // We add one more face name. Thus, set FM_INFO_FAMILY_EQUIV bit
        // (later) and add two, instead of one, for the two-null terminators.
        //
        isi.nFamilyNameSize += ALIGN4((wcNameStr2Len + 2) * sizeof (WCHAR));
    }

    //
    // Account for size of Adobe PS font name. This is zero because it
    // shares the face name for Win3.1 compatibility.
    //
    isi.nFaceNameSize = 0;

    //
    // Account for the sizes of the style and unique names in Unicode string.
    //
    // Style name: conbine Weight and ' Italic' if non-zero ItalicAngle values
    // is present.
    //
    // Unique name: convert UniqueID value into Unicode string. If UniqueID
    // is not found, leave the name blank.
    //
    pToken = FindAFMToken(pAFM, PS_WEIGHT_TOK);
    if (pToken == NULL)
    {
        ERR(("makentf - afm2ntm: Weight value missing\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }
    AFM2NTMStrCpy(szStyleName, CCHOF(szStyleName), pToken);

    pToken = FindAFMToken(pAFM, PS_ITALIC_TOK);
    if (pToken)
    {
        if (atoi(pToken) > 0)
            StringCchCatA(szStyleName, CCHOF(szStyleName), " Italic");
    }

    isi.nStyleNameSize = ALIGN4((strlen(szStyleName) + 1) * 2);

    pToken = FindUniqueID(pAFM);
    if (pToken)
    {
        AFM2NTMStrCpy(szUniqueID, CCHOF(szUniqueID), pToken);
        isi.nUniqueNameSize = ALIGN4((strlen(szUniqueID) + 1) * 2);
    }
    else
        isi.nUniqueNameSize = 0;

    //
    // If font doesn't support (Italics OR Bold), reserve additional memory
    // at end of IFIMETRICS for structures required to do Italics simulation.
    //
    bIsItalic = FALSE;
    bIsBold = FALSE;
    j = bIsCJKFont ? 1 : 0;

    if ((pToken = FindAFMToken(pAFM, PS_ITALIC_TOK)) != NULL)
    {
        if ( StrCmp(pToken, "0") && StrCmp(pToken, "0.0") )
             bIsItalic = TRUE;
    }

    if ((pToken = FindAFMToken(pAFM, PS_WEIGHT_TOK)) != NULL)
    {
        for (i = 0; i < WeightKeyTbl[j].usNumEntries; i++)
        {
            if (!StrCmp(pToken, (PBYTE)(((PKEY) (WeightKeyTbl[j].pTbl))[i].pName)))
            {
                if ((((PKEY) (WeightKeyTbl[j].pTbl))[i].usValue) == FW_BOLD)
                {
                    bIsBold = TRUE;
                }
                break;
            }
        }
    }

    // Reserve space for dpFontSim
    if (!bIsBold || !bIsItalic)
        isi.nFontSimSize = ALIGN4(sizeof(FONTSIM));
    else
        isi.nFontSimSize = 0;

    // Reserve space for dpBold
    if (!bIsBold)
        isi.nBoldSize = ALIGN4(sizeof(FONTDIFF));
    else
        isi.nBoldSize = 0;

    // Reserve space for dpItalic
    if (!bIsItalic)
        isi.nItalicSize = ALIGN4(sizeof(FONTDIFF));
    else
        isi.nItalicSize = 0;

    // Reserve space for dpBoldItalic
    if (!bIsBold || !bIsItalic)
        isi.nBoldItalicSize = ALIGN4(sizeof(FONTDIFF));
    else
        isi.nBoldItalicSize = 0;

    // Determine if this font supports multiple char sets.
    if (pCharSet)
    {
        if (multiCharSet > 1)
            isi.nCharSetSize = ALIGN4(NUM_DPCHARSET);
        else
            isi.nCharSetSize = 0;
    }
    else
    {
        isi.nCharSetSize = 0;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // Allocate memory for NTM, IFIMETRICS, and strings. We provide
    // the secondary IFIMETRICS and strings if we are dealing with
    // CJK font.
    //
    //////////////////////////////////////////////////////////////////////////

    GET_NTMTOTALSIZE(nsi);
    ulNTMSize = (ULONG)nsi.nTotalSize;

    GET_IFIMETRICSTOTALSIZE(isi);
    ulIFISize = (ULONG)isi.nTotalSize;

    ulIFISize2 = bIsCJKFont ? ulIFISize * 2 : ulIFISize;

    pNTM = (PNTM) MemAllocZ((size_t)(ulNTMSize + ulIFISize2));
    if (pNTM == NULL)
    {
        ERR(("makentf - afm2ntm: malloc\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // Construct NTM structure
    //
    //////////////////////////////////////////////////////////////////////////

    pNTM->dwSize = ulNTMSize + ulIFISize2;
    pNTM->dwVersion = NTM_VERSION;
    pNTM->dwFlags = 0;

    //
    // Store the font name.
    //
    pNTM->dwFontNameOffset = ALIGN4(sizeof(NTM));

    pby = (PBYTE)MK_PTR(pNTM, dwFontNameOffset);
    memcpy(pby, pszFontName, cFontNameLen);
    pby += cFontNameLen;

    if (bIsCJKFont)
    {
        //
        // Append glyphset name string to the font name.
        //
        memcpy(pby, pszGlyphSetName, cGlyphSetNameLen);
        pby += cGlyphSetNameLen;
    }

    *pby = '\0';

    //
    // Store the display name.
    //
    pNTM->dwDisplayNameOffset = pNTM->dwFontNameOffset
                                    + (DWORD)nsi.nFontNameSize;

    pby = (PBYTE)MK_PTR(pNTM, dwDisplayNameOffset);
    if (bIsCJKFont && bIsVGlyphSet) *pby++ = '@';
    memcpy(pby, pszFamilyName, cFamilyNameLen);
    *(pby + cFamilyNameLen) = '\0';

    //
    // Get PS font version from AFM and store in NTM.
    //
    pToken = FindAFMToken(pAFM, PS_FONT_VERSION_TOK);
    if (pToken == NULL)  // Fixed bug 354007
    {
        ERR(("makentf - afm2ntm: Font Version value missing\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }

    pNTM->dwFontVersion = atoi(pToken) << 16 | atoi(&pToken[4]);

    //
    // Get the name string of the GLYPHSETDATA associated with this font
    // and store it in NTM.
    //
    pNTM->dwGlyphSetNameOffset = pNTM->dwDisplayNameOffset
                                    + (DWORD)nsi.nDisplayNameSize;

    StringCchCopyA((PBYTE)MK_PTR(pNTM, dwGlyphSetNameOffset), nsi.nGlyphSetNameSize, pszGlyphSetName);

    //
    // Store the count of Glyphs.
    //
    pNTM->dwGlyphCount = ulChCnt;

    //
    // Calculate offset, create ptr to IFIMETRICS.
    //
    pNTM->dwIFIMetricsOffset = ulNTMSize;
    pifi = (PIFIMETRICS) MK_PTR(pNTM, dwIFIMetricsOffset);

    //
    // Calculate offset, create ptr to the secondly IFIMETRICS if necessary.
    //
    if (bIsCJKFont)
    {
        pNTM->dwIFIMetricsOffset2 = ulNTMSize + ulIFISize;
        pifi2 = (PIFIMETRICS)MK_PTR(pNTM, dwIFIMetricsOffset2);
    }
    else
    {
        pNTM->dwIFIMetricsOffset2 = 0;
        pifi2 = NULL;
    }

    //
    // For both Fixed and Prop fonts, we need to get the ETMInfo.
    // (Fix bug 211966, PPeng, 6-6-97)
    //
    GetAFMETM(pAFM, pFontChars, &EtmInfo);

    //
    // According to AFM spec, if a 'CharWidth' token is found in AFM, the
    // font must be fixed pitch.
    //
    if (bIsFixedPitch)
    {
        //
        // This is a fixed pitch font. Get the AvgWidth - which is anyone's width
        //
        pNTM->dwDefaultCharWidth = 0;
        pNTM->dwCharWidthCount = 0;
        pNTM->dwCharWidthOffset = 0;

        //
        // We just get a reasonable number from the AFM different from zero.
        // This number is used in computing font transfroms.
        //
        if ((pToken = FindAFMToken(pAFM, PS_CH_METRICS_TOK)) != NULL)
        {
            //
            // Get width of first char defined in AFM and use as
            // average width.
            //
            NEXT_TOKEN(pToken);
            pChWidthTok = FindAFMToken(pToken, PS_CH_WIDTH_TOK);
            if (pChWidthTok == NULL)
            {
                pChWidthTok = FindAFMToken(pToken, PS_CH_WIDTH0_TOK);
            }
            if (pChWidthTok != NULL)
            {
                pToken = pChWidthTok;
                pifi->fwdAveCharWidth =
                    pifi->fwdMaxCharInc = (FWORD)atoi(pToken);
            }
        }

        pifi->fwdMaxCharInc = pifi->fwdAveCharWidth ;

        if (bIsCJKFont)
        {
            // DCR: couldn't divide by 2 simply for C and K.
            pifi->fwdAveCharWidth /= 2;
        }

        ASSERTMSG(pifi->fwdAveCharWidth, ("PSCRIPT: pifi->fwdAveCharWidth == 0\n"));
    }
    else
    {
        //
        // Proportional font. Generate WIDTHRUNs.
        //
        pNTM->dwCharWidthOffset = pNTM->dwGlyphSetNameOffset
                                    + (DWORD)nsi.nGlyphSetNameSize;

        pWidthRuns = (PWIDTHRUN) MK_PTR(pNTM, dwCharWidthOffset);
        pNTM->dwCharWidthCount = GetAFMCharWidths(pAFM,
                                                    &pWidthRuns,
                                                    pFontChars,
                                                    pUniPs,
                                                    pGlyphSetData->dwGlyphCount,
                                                    &pifi->fwdAveCharWidth,
                                                    &pifi->fwdMaxCharInc);

        // Fix bug 240339, jjia, 8/3/98
        if (pWidthRuns[0].dwCharWidth == WIDTHRUN_COMPLEX)
        {
            pWidthRuns[0].dwCharWidth = WIDTHRUN_COMPLEX +
                                        sizeof(WIDTHRUN);
        }
    }

    //
    // For both Prop and Fixed fonts
    // (Fix bug 210314, PPeng, 6-10-97)
    //
    pNTM->dwDefaultCharWidth = pifi->fwdAveCharWidth;

    //
    // Construct kerning pairs.
    //
    if (ulKernPairs)
    {
        //
        // Fill NTM with kern pair data.
        //
        pNTM->dwKernPairOffset = pNTM->dwGlyphSetNameOffset
                                    + (DWORD)nsi.nGlyphSetNameSize
                                    + (DWORD)nsi.nCharWidthSize;

        pKernPairs = (FD_KERNINGPAIR *) MK_PTR(pNTM, dwKernPairOffset);
        pNTM->dwKernPairCount = GetAFMKernPairs(pAFM, pKernPairs, pGlyphSetData);
    }
    else
    {
        //
        // No pair kerning info for this font.
        //
        pNTM->dwKernPairCount = 0;
        pNTM->dwKernPairOffset = 0;
    }

    //
    // Store the CharDefined tbl.
    //
    pNTM->dwCharDefFlagOffset = pNTM->dwGlyphSetNameOffset
                                    + (DWORD)nsi.nGlyphSetNameSize
                                    + (DWORD)nsi.nCharWidthSize
                                    + (DWORD)nsi.nKernPairSize;

    memcpy((PBYTE) MK_PTR(pNTM, dwCharDefFlagOffset), pCharDefTbl, ulCharDefTbl);

    //
    // Get font character set from AFM and store in NTM
    //
    pToken = pAFMCharacterSetString;
    if (pToken != NULL)
    {
        if (StrCmp(pToken, PS_STANDARD_CHARSET_TOK) == 0)
            pNTM->dwCharSet = CHARSET_STANDARD;
        else if (StrCmp(pToken, PS_SPECIAL_CHARSET_TOK) == 0)
            pNTM->dwCharSet = CHARSET_SPECIAL;
        else if (StrCmp(pToken, PS_EXTENDED_CHARSET_TOK) == 0)
            pNTM->dwCharSet = CHARSET_EXTENDED;
        else
            pNTM->dwCharSet = CHARSET_UNKNOWN;
    }

    //
    // Save the codepage of the font if there is only one of it is used for
    // the font.
    //
    if (pGlyphSetData->dwCodePageCount == 1)
        pNTM->dwCodePage = ((PCODEPAGEINFO)MK_PTR(pGlyphSetData, dwCodePageOffset))->dwCodePage;
    else
        pNTM->dwCodePage = 0;

    //
    // Cleare the reserved area.
    //
    pNTM->dwReserved[0] =
    pNTM->dwReserved[1] =
    pNTM->dwReserved[2] = 0;


    //////////////////////////////////////////////////////////////////////////
    //
    // Construct IFIMETRICS structure
    //
    //////////////////////////////////////////////////////////////////////////

    pifi->cjThis = ulIFISize;
    pifi->cjIfiExtra = isi.nIfiExtraSize;
    pifi->lEmbedId  = 0; // only useful for tt fonts
    pifi->lCharBias = 0; // only useful for tt fonts

    pifi->flInfo =  FM_INFO_ARB_XFORMS                  |
                    FM_INFO_NOT_CONTIGUOUS              |
                    FM_INFO_TECH_OUTLINE_NOT_TRUETYPE   |
                    FM_INFO_1BPP                        |
                    FM_INFO_RIGHT_HANDED;

    //
    // Everything in IFIEXTRA is leave blank for now.
    // Only the number of glyphs is filled in.
    //
    pifiEx = (PIFIEXTRA)((PBYTE)pifi + isi.nSize);
    pifiEx->cig = pGlyphSetData->dwGlyphCount;

    //
    // Store font family name to IFIMETRICS. Copy font name aliases too if any.
    // Note that this routine also converts the appropriate family name str to
    // unicode prior to storing it in IFIMETRICS.
    //
    pifi->dpwszFamilyName = (PTRDIFF)(isi.nSize + isi.nIfiExtraSize);
    ulAliases = cjGetFamilyAliases(pifi, pNameStr, csi.ciACP);

    //
    // Adjust ulAliases to the first null terminator if FM_INFO_FAMILY_EQUIV
    // bit is set.
    //
    if (pifi->flInfo & FM_INFO_FAMILY_EQUIV)
        ulAliases -= sizeof (WCHAR);

    if (pNameStr2)
    {
        pifi->flInfo |= FM_INFO_FAMILY_EQUIV;

        pby = (PBYTE)MK_PTR(pifi, dpwszFamilyName) + ulAliases;
        MultiByteToWideChar(csi.ciACP, 0,
                            pNameStr2, cNameStr2Len,
                            (PWSTR)pby, wcNameStr2Len);
        pby += wcNameStr2Len * sizeof (WCHAR);

        //
        // Terminate with two WCHAR nulls.
        //
        *((PWSTR)pby) = (WCHAR)'\0';
        pby += sizeof (WCHAR);
        *((PWSTR)pby) = (WCHAR)'\0';
        pby += sizeof (WCHAR);
    }

    //
    // Face name shares the family name/aliases for Win3.1 compatibility.
    //
    pifi->dpwszFaceName = pifi->dpwszFamilyName;

    //
    // Store style and unique names. Style name has to be available but
    // unique name may not be available.
    //
    pifi->dpwszStyleName = pifi->dpwszFamilyName + (PTRDIFF)isi.nFamilyNameSize;
    pby = (PBYTE)MK_PTR(pifi, dpwszStyleName);
    MULTIBYTETOUNICODE((LPWSTR)pby, isi.nStyleNameSize, NULL, szStyleName, strlen(szStyleName));

    if (isi.nUniqueNameSize)
    {
        pifi->dpwszUniqueName = pifi->dpwszStyleName + (PTRDIFF)isi.nStyleNameSize;
        pby = (PBYTE)MK_PTR(pifi, dpwszUniqueName);
        MULTIBYTETOUNICODE((LPWSTR)pby, isi.nUniqueNameSize, NULL, szUniqueID, strlen(szUniqueID));
    }
    else
    {
        pifi->dpwszUniqueName = pifi->dpwszStyleName + isi.nStyleNameSize - sizeof (WCHAR);
    }

    //
    // Save Windows characterset.
    //
    pifi->jWinCharSet = (BYTE)jWinCharSet;

    //
    // Store the font's family type flags.
    //
    if (pFamilyInfo != NULL)
    {
        pifi->jWinPitchAndFamily = (BYTE) pFamilyInfo->FamilyKey.usValue & 0xff;
    }
    else
    {
        pifi->jWinPitchAndFamily = FF_SWISS;
    }

    //
    // Set pitch flags.
    //
    if (bIsFixedPitch)
    {
        pifi->jWinPitchAndFamily |= FIXED_PITCH;
        pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;

        if (!bIsCJKFont)
            pifi->flInfo |= FM_INFO_CONSTANT_WIDTH;
        else
            pifi->flInfo |= FM_INFO_DBCS_FIXED_PITCH;
    }
    else
    {
        pifi->jWinPitchAndFamily |= VARIABLE_PITCH;
    }

    //
    // Get weight from AFM key.
    //
    pifi->usWinWeight = FW_NORMAL;
    pifi->fsSelection = 0;
    j = bIsCJKFont ? 1 : 0;

    if ((pToken = FindAFMToken(pAFM, PS_WEIGHT_TOK)) != NULL)
        for (i = 0; i < WeightKeyTbl[j].usNumEntries; i++)
        {
            if (!StrCmp(pToken, (PBYTE) (((PKEY) (WeightKeyTbl[j].pTbl))[i].pName)))
            {
                pifi->usWinWeight = (((PKEY) (WeightKeyTbl[j].pTbl))[i].usValue);
                if (pifi->usWinWeight == FW_BOLD)
                {
                    pifi->fsSelection = FM_SEL_BOLD;
                }
                break;
            }
        }

    //
    // Is this really how to set font selection flags?
    // AFMtoPFM converter treats angle as a float, but etm.etmslant
    // field is a short.
    //
    //
    // Set Italic sel flag if necessary.
    //
    if ((pToken = FindAFMToken(pAFM, PS_ITALIC_TOK)) != NULL)
        pNTM->etm.etmSlant = (SHORT)atoi(pToken);
    if (pNTM->etm.etmSlant)
    {
        pifi->fsSelection |= FM_SEL_ITALIC;
    }


#if 0
    //
    // DCR: so, what are we gonna do with this?
    //
    FSHORT fsSelection = 0;

    //
    // Excerpts from bodind's code. Not sure if we need this
    // useful.
    //
    if (pjPFM[OFF_Underline])
        fsSelection |= FM_SEL_UNDERSCORE;
    if (pjPFM[OFF_StrikeOut])
        fsSelection |= FM_SEL_STRIKEOUT;
    if (READ_WORD(&pjPFM[OFF_Weight]) > FW_NORMAL)
        fsSelection |= FM_SEL_BOLD;
#endif


    pifi->fsType = FM_NO_EMBEDDING;
    pifi->fwdUnitsPerEm = EM; // hardcoded for type 1 fonts

    //
    // Use FontBBox2 if found. Otherwise, use FontBBox. FontBBox2 is
    // the bounding box values of the characters not the union of all
    // the characters described in the AFM file but the characters
    // actually used in a specific character set such as 90ms.
    //
    if (((pToken = FindAFMToken(pAFM, PS_FONT_BBOX2_TOK)) == NULL) &&
        ((pToken = FindAFMToken(pAFM, PS_FONT_BBOX_TOK)) == NULL))
    {
        ERR(("makentf - afm2ntm: FontBBox not found\n"));
        FREE_AFMTONTM_MEMORY;
        return NULL;
    }
    //
    // Save font bounding box.
    //
    PARSE_RECT(pToken, rcBBox);
    sIntLeading = (SHORT) (rcBBox.top - rcBBox.bottom) - EM;
    if (sIntLeading < 0)
        sIntLeading = 0;

    sAscent                = (USHORT) rcBBox.top & 0xffff;
    pifi->fwdWinAscender   = sAscent;

    //
    // Poof! Magic Metrics...
    //
    sExternalLeading = 196;

    // see pfm.c, win31 sources, this computation
    // produces quantity that is >= |rcBBox.bottom|

    pifi->fwdWinDescender  = EM - sAscent + sIntLeading;

    pifi->fwdMacAscender   =  sAscent;
    pifi->fwdMacDescender  = -pifi->fwdWinDescender;
    pifi->fwdMacLineGap    =  (FWORD) sExternalLeading - sIntLeading;
    if (pifi->fwdMacLineGap < 0)
        pifi->fwdMacLineGap = 0;

    pifi->fwdTypoAscender  = pifi->fwdMacAscender;
    pifi->fwdTypoDescender = pifi->fwdMacDescender;
    pifi->fwdTypoLineGap   = pifi->fwdMacLineGap;

    if (pifi->fwdAveCharWidth > pifi->fwdMaxCharInc)
    {
        //
        // fix the bug in the header if there is one,
        // We do not want to change AveCharWidht, it is used for
        // computing font xforms, Max is used for nothing as fas as I know.
        //
        pifi->fwdMaxCharInc = pifi->fwdAveCharWidth;
    }

    //
    // Create EXTTEXTMETRICs. Poof! More magic.
    //
    pNTM->etm.etmSize = sizeof(EXTTEXTMETRIC);
    pNTM->etm.etmCapHeight = EtmInfo.etmCapHeight;
    pNTM->etm.etmXHeight = EtmInfo.etmXHeight;
    pNTM->etm.etmLowerCaseAscent = EtmInfo.etmLowerCaseAscent;
    pNTM->etm.etmLowerCaseDescent = EtmInfo.etmLowerCaseDescent;
    pNTM->etm.etmPointSize = 12 * 20;   /* Nominal point size = 12 */
    pNTM->etm.etmOrientation = 0;
    pNTM->etm.etmMasterHeight = 1000;
    pNTM->etm.etmMinScale = 3;
    pNTM->etm.etmMaxScale = 1000;
    pNTM->etm.etmMasterUnits = 1000;

    if ((pToken = FindAFMToken(pAFM, PS_UNDERLINE_POS_TOK)) != NULL)
        pNTM->etm.etmUnderlineOffset = (SHORT)atoi(pToken);

    if ((pToken = FindAFMToken(pAFM, PS_UNDERLINE_THICK_TOK)) != NULL)
        pNTM->etm.etmUnderlineWidth = (SHORT)atoi(pToken);

    pNTM->etm.etmSuperScript = -500;
    pNTM->etm.etmSubScript = 250;
    pNTM->etm.etmSuperScriptSize = 500;
    pNTM->etm.etmSubScriptSize = 500;
    pNTM->etm.etmDoubleUpperUnderlineOffset = pNTM->etm.etmUnderlineOffset / 2;
    pNTM->etm.etmDoubleLowerUnderlineOffset = pNTM->etm.etmUnderlineOffset;

    pNTM->etm.etmDoubleUpperUnderlineWidth = // same as LowerUnderlineWidth
    pNTM->etm.etmDoubleLowerUnderlineWidth = pNTM->etm.etmUnderlineWidth / 2;

    pNTM->etm.etmStrikeOutOffset = 500;
    pNTM->etm.etmStrikeOutWidth = 50;  // ATM sets it to 50 (also all PFMs have 50)
    pNTM->etm.etmNKernPairs = (USHORT) ulKernPairs & 0xffff;

    //
    // No track kerning. This mimics the behavior of old AFM->PFM utility.
    //
    pNTM->etm.etmNKernTracks = 0;

    //
    // SuperScripts and Subscripts come from etm:
    //
    pifi->fwdSubscriptXSize      =  // same as YSize
    pifi->fwdSubscriptYSize      = pNTM->etm.etmSubScriptSize;

    pifi->fwdSubscriptXOffset    = 0;
    pifi->fwdSubscriptYOffset    = pNTM->etm.etmSubScript;

    pifi->fwdSuperscriptXSize    = // same as YSize
    pifi->fwdSuperscriptYSize    = pNTM->etm.etmSuperScriptSize;

    pifi->fwdSuperscriptXOffset  = 0;
    pifi->fwdSuperscriptYOffset  = pNTM->etm.etmSuperScript;

    pifi->fwdUnderscoreSize = pNTM->etm.etmUnderlineWidth;

    //
    // fwdUnderscorePosition is typically negative - AFM may have negative value already
    //
    if (pNTM->etm.etmUnderlineOffset <0)
        pifi->fwdUnderscorePosition = -pNTM->etm.etmUnderlineOffset;
    else
        pifi->fwdUnderscorePosition = pNTM->etm.etmUnderlineOffset;

    // Make it compatible with ATM. Fix bug Adobe #211202
    pifi->fwdUnderscorePosition = -(pifi->fwdUnderscorePosition -
                                    pifi->fwdUnderscoreSize / 2);

    pifi->fwdStrikeoutSize = pNTM->etm.etmStrikeOutWidth;

    //
    // This is what KentSe was using to position strikeout and it looked good [bodind]
    // Instead we could have used etmStrikeoutOffset (usually equal to 500) which
    // was too big.
    //

    // Make it compatible with ATM. Fix bug Adobe #211202
    // pifi->fwdStrikeoutPosition = ((LONG)pNTM->etm.etmLowerCaseAscent / 2);
    if (pNTM->etm.etmCapHeight != 0)
        pifi->fwdStrikeoutPosition = (pNTM->etm.etmCapHeight - pifi->fwdUnderscoreSize) / 2;
    else
        pifi->fwdStrikeoutPosition = (pNTM->etm.etmXHeight - pifi->fwdUnderscoreSize) / 2;

    pifi->fwdLowestPPEm = pNTM->etm.etmMinScale;

    //
    // Per bodind, Win 3.1 values for first, last, break and default char can
    // be hardcoded.
    //
    pifi->chFirstChar   = 0x20;
    pifi->chLastChar    = 0xff;

    if (!bIsCJKFont)
    {
        pifi->chBreakChar   = 0x20;

        // The following line of code should work, however, there seems to be
        // a bug in afm -> pfm conversion utility which makes
        // DefaultChar == 0x20 instead of 149 - 20 (for bullet).

        // pifi->chDefaultChar = pjPFM[OFF_DefaultChar] + pjPFM[OFF_FirstChar];

        // Therefore, instead, I will use 149 which seems to work for all fonts.

        pifi->chDefaultChar = 149;
    }
    else
    {
        pifi->chBreakChar   =
        pifi->chDefaultChar = 0x00;
    }

    //
    // Get Unicode values for first and last char from GLYPHSETDATA. We
    // should do this on a per GLYPHSETDATA basis rather than a per font
    // basis, but the calculations are so simple just do it on the fly,
    // rather than dragging first and last char around with the
    // GLYPHSETDATA.
    //
    pGlyphRun = (PGLYPHRUN) MK_PTR(pGlyphSetData, dwRunOffset);
    pifi->wcFirstChar = pGlyphRun->wcLow;
    (ULONG_PTR) pGlyphRun += (pGlyphSetData->dwRunCount - 1) * sizeof(GLYPHRUN);
    pifi->wcLastChar = pGlyphRun->wcLow + pGlyphRun->wGlyphCount - 1;

    MultiByteToWideChar(csi.ciACP, 0,
                        &pifi->chDefaultChar, 1,
                        &pifi->wcDefaultChar, sizeof(WCHAR));
    MultiByteToWideChar(csi.ciACP, 0,
                        &pifi->chBreakChar, 1,
                        &pifi->wcBreakChar, sizeof(WCHAR));

    pifi->fwdCapHeight = pNTM->etm.etmCapHeight;
    pifi->fwdXHeight   = pNTM->etm.etmXHeight;

    // All the fonts that this font driver will see are to be rendered left
    // to right

    pifi->ptlBaseline.x = 1;
    pifi->ptlBaseline.y = 0;

    pifi->ptlAspect.y = 300;
    pifi->ptlAspect.x = 300;

    // italic angle from etm.

    pifi->lItalicAngle = pNTM->etm.etmSlant;

    if (pifi->lItalicAngle == 0)
    {
        // The base class of font is not italicized,

        pifi->ptlCaret.x = 0;
        pifi->ptlCaret.y = 1;
    }
    else
    {
        // ptlCaret.x = -sin(lItalicAngle);
        // ptlCaret.y =  cos(lItalicAngle);
        //!!! until I figure out the fast way to get sin and cos I cheat: [bodind]

        pifi->ptlCaret.x = 1;
        pifi->ptlCaret.y = 3;
    }

    //!!! The font box; This is bogus, this info is not in .pfm file!!! [bodind]
    //!!! but I suppose that this info is not too useful anyway, it is nowhere
    //!!! used in the engine or elsewhere in the ps driver.
    //!!! left and right are bogus, top and bottom make sense.

    pifi->rclFontBox.left   = 0;                              // bogus
    pifi->rclFontBox.top    = (LONG) pifi->fwdTypoAscender;   // correct
    pifi->rclFontBox.right  = (LONG) pifi->fwdMaxCharInc;     // bogus
    pifi->rclFontBox.bottom = (LONG) pifi->fwdTypoDescender;  // correct

    // achVendorId, unknown, don't bother figure it out from copyright msg

    pifi->achVendId[0] = 'U';
    pifi->achVendId[1] = 'n';
    pifi->achVendId[2] = 'k';
    pifi->achVendId[3] = 'n';
    pifi->cKerningPairs = ulKernPairs;

    // Panose

    pifi->ulPanoseCulture = FM_PANOSE_CULTURE_LATIN;
    ppanose = &(pifi->panose);
    ppanose->bFamilyType = PAN_ANY;
    ppanose->bSerifStyle =
        ((pifi->jWinPitchAndFamily & 0xf0) == FF_SWISS) ?
            PAN_SERIF_NORMAL_SANS : PAN_ANY;

    ppanose->bWeight = (BYTE) WINWT_TO_PANWT(pifi->usWinWeight);
    ppanose->bProportion = (pifi->jWinPitchAndFamily & FIXED_PITCH) ?
                                PAN_PROP_MONOSPACED : PAN_ANY;
    ppanose->bContrast        = PAN_ANY;
    ppanose->bStrokeVariation = PAN_ANY;
    ppanose->bArmStyle        = PAN_ANY;
    ppanose->bLetterform      = PAN_ANY;
    ppanose->bMidline         = PAN_ANY;
    ppanose->bXHeight         = PAN_ANY;
    // If the font is not italic or Not-Bold, the driver can simulate it
    // Set the dpBold, dpItalic, and dpBoldItalic correctly, PPeng, 6-3-1997

    // Depends on AFM, we need to set some of the sim structure:
    // Normal - need dpBold, dpItalic, and dpBoldItalic
    // Bold   - need dpItalic
    // Italic - need dpBoldItalic
    // BoldItalic - Nothing

    // Don't move code around !!
    // At this point, bIsBold and bIsItalic should be set already
    // Don't move code around !!

    if (!bIsBold || !bIsItalic)
    {

        FONTSIM *pFontSim;
        FONTDIFF *pFontDiff;
        FONTDIFF FontDiff;

        // Preset temporary FontDiff structure
        FontDiff.jReserved1         =   0;
        FontDiff.jReserved2         =   0;
        FontDiff.jReserved3         =   0;
        FontDiff.bWeight            =   pifi->panose.bWeight;
        FontDiff.usWinWeight        =   pifi->usWinWeight;
        FontDiff.fsSelection        =   pifi->fsSelection;
        FontDiff.fwdAveCharWidth    =   pifi->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc      =   pifi->fwdMaxCharInc;
        FontDiff.ptlCaret           =   pifi->ptlCaret;

        // Initialize FONTSIM structure
        pifi->dpFontSim = pifi->dpwszStyleName + (PTRDIFF)(isi.nStyleNameSize + isi.nUniqueNameSize);

        pFontSim = (FONTSIM *) MK_PTR(pifi, dpFontSim);

        pFontSim->dpBold = pFontSim->dpBoldItalic = pFontSim->dpItalic = 0;

        // Notice the FontDiff data are arranged right after FontSim
        // in the following order: dpBold, dpItalic, dpBoldItalic

        if (!bIsBold)
        {
            // Right after FontSim.
            pFontSim->dpBold = ALIGN4(sizeof(FONTSIM));

            pFontDiff = (FONTDIFF *) MK_PTR(pFontSim, dpBold);
            *pFontDiff = FontDiff;

            pFontDiff->bWeight = PAN_WEIGHT_BOLD;
            pFontDiff->fsSelection |= FM_SEL_BOLD;
            pFontDiff->usWinWeight = FW_BOLD;
            pFontDiff->fwdAveCharWidth += 1;
            pFontDiff->fwdMaxCharInc += 1;

            // if already Italic, CANNOT Un-italic it
            if (bIsItalic)
            {
                pFontDiff->ptlCaret.x = 1;
                pFontDiff->ptlCaret.y = 3;
            }
            else
            {
                pFontDiff->ptlCaret.x = 0;
                pFontDiff->ptlCaret.y = 1;
            }
        }

        if (!bIsItalic)
        {
            if (pFontSim->dpBold)
            {
                // Right after FontDiff for dpBold, or...
                pFontSim->dpItalic = pFontSim->dpBold + ALIGN4(sizeof(FONTDIFF));
            }
            else
            {
                // ...right after FontSim.
                pFontSim->dpItalic = ALIGN4(sizeof(FONTSIM));
            }

            pFontDiff = (FONTDIFF *) MK_PTR(pFontSim, dpItalic);
            *pFontDiff = FontDiff;

            pFontDiff->fsSelection |= FM_SEL_ITALIC;

            // Italic angle is approximately 18 degree
            pFontDiff->ptlCaret.x = 1;
            pFontDiff->ptlCaret.y = 3;
        }

        // Make BoldItalic simulation if necessary - besides dpBold or dpItalic
        if (!bIsItalic || !bIsBold)
        {
            if (pFontSim->dpItalic)
            {
                // Right after FontDiff for dpItalic, or...
                pFontSim->dpBoldItalic = pFontSim->dpItalic + ALIGN4(sizeof(FONTDIFF));
            }
            else if (pFontSim->dpBold)
            {
                // ...right after FontDiff for dpBold if dpItalic is not set, or...
                pFontSim->dpBoldItalic = pFontSim->dpBold + ALIGN4(sizeof(FONTDIFF));
            }
            else
            {
                // ...right after FontSim if none of other two is set.
                pFontSim->dpBoldItalic = ALIGN4(sizeof(FONTSIM));
            }

            pFontDiff = (FONTDIFF *) MK_PTR(pFontSim, dpBoldItalic);
            *pFontDiff = FontDiff;

            pFontDiff->bWeight = PAN_WEIGHT_BOLD;
            pFontDiff->fsSelection |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pFontDiff->usWinWeight = FW_BOLD;
            pFontDiff->fwdAveCharWidth += 1;
            pFontDiff->fwdMaxCharInc += 1;

            // Italic angle is approximately 18 degree
            pFontDiff->ptlCaret.x = 1;
            pFontDiff->ptlCaret.y = 3;
        }
    }
    else
        pifi->dpFontSim = 0;

    if (multiCharSet > 1)
    {
        PBYTE pDpCharSet;

        pifi->dpCharSets = ulIFISize - ALIGN4(NUM_DPCHARSET);
        pDpCharSet = (BYTE *)MK_PTR(pifi, dpCharSets);

        // The order of this check is important since jWinCharSet
        // should match the first dpCharSets array if it exists.
        i = 0;
        if (CSET_SUPPORT(*pCharSet, CS_ANSI))
            pDpCharSet[i++] = ANSI_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_EASTEUROPE))
            pDpCharSet[i++] = EASTEUROPE_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_RUSSIAN))
            pDpCharSet[i++] = RUSSIAN_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_GREEK))
            pDpCharSet[i++] = GREEK_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_TURKISH))
            pDpCharSet[i++] = TURKISH_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_HEBREW))
            pDpCharSet[i++] = HEBREW_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_ARABIC))
            pDpCharSet[i++] = ARABIC_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_BALTIC))
            pDpCharSet[i++] = BALTIC_CHARSET;
        if (CSET_SUPPORT(*pCharSet, CS_SYMBOL))
            pDpCharSet[i++] = SYMBOL_CHARSET;

        while (i < 16)
            pDpCharSet[i++] = DEFAULT_CHARSET;

    }
    else
        pifi->dpCharSets = 0; // no multiple charsets in ps fonts

    //
    // Copy the first IFIMETRICS to the secondly if necessary, and then
    // switch English and localized font menu names.
    //
    if (bIsCJKFont)
    {
        ASSERT(pifi2 != NULL);

        memcpy(pifi2, pifi, isi.nTotalSize);

        pifi2->flInfo &= ~FM_INFO_FAMILY_EQUIV;

        ulAliases = cjGetFamilyAliases(pifi2, pNameStr2, csi.ciACP);

        if (pifi2->flInfo & FM_INFO_FAMILY_EQUIV)
            ulAliases -= sizeof (WCHAR);

        pifi2->flInfo |= FM_INFO_FAMILY_EQUIV;

        pby = (PBYTE)MK_PTR(pifi2, dpwszFamilyName) + ulAliases;
        MultiByteToWideChar(csi.ciACP, 0,
                                pNameStr, cNameStrLen,
                                (PWSTR)pby, wcNameStrLen);
        pby += wcNameStrLen * sizeof (WCHAR);

        //
        // Terminate with two WCHAR nulls.
        //
        *((PWSTR)pby) = (WCHAR)'\0';
        pby += sizeof (WCHAR);
        *((PWSTR)pby) = (WCHAR)'\0';
        pby += sizeof (WCHAR);

        //
        // Face name shares the family name/aliases for Win3.1 compatibility.
        //
        pifi2->dpwszFaceName = pifi2->dpwszFamilyName;

#if 1
        //
        // We now support style and unique names too.
        //
        pifi2->dpwszStyleName = pifi2->dpwszFamilyName + (PTRDIFF)isi.nFamilyNameSize;
        pby = (PBYTE)MK_PTR(pifi2, dpwszStyleName);
        MULTIBYTETOUNICODE((LPWSTR)pby, isi.nStyleNameSize, NULL, szStyleName, strlen(szStyleName));

        if (isi.nUniqueNameSize)
        {
            pifi2->dpwszUniqueName = pifi2->dpwszStyleName + (PTRDIFF)isi.nStyleNameSize;
            pby = (PBYTE)MK_PTR(pifi2, dpwszUniqueName);
            MULTIBYTETOUNICODE((LPWSTR)pby, isi.nUniqueNameSize, NULL, szUniqueID, strlen(szUniqueID));
        }
        else
        {
            pifi2->dpwszUniqueName = pifi2->dpwszStyleName + isi.nStyleNameSize - sizeof (WCHAR);
        }
#else
        //
        // These names don't exist, so point to the NULL char.
        // This is too for Win3.1 compatibility.
        //
        pifi2->dpwszStyleName = pifi2->dpwszFamilyName + ulAliases - sizeof (WCHAR);
        pifi2->dpwszUniqueName = pifi2->dpwszStyleName;
#endif

#ifdef FORCE_2NDIFIMETRICS_FIRST
        {
            DWORD dw = pNTM->dwIFIMetricsOffset;

            pNTM->dwIFIMetricsOffset  = pNTM->dwIFIMetricsOffset2;
            pNTM->dwIFIMetricsOffset2 = dw;
        }
#endif
    }


    if (bVerbose)
    {
        printf("NTM:dwFontNameOffset:%s\n", (PSZ)MK_PTR(pNTM, dwFontNameOffset));
        printf("NTM:dwDisplayNameOffset:%s\n", (PSZ)MK_PTR(pNTM, dwDisplayNameOffset));
        printf("NTM:dwGlyphSetNameOffset:%s\n", (PSZ)MK_PTR(pNTM, dwGlyphSetNameOffset));
        printf("NTM:dwGlyphCount:%ld\n", pNTM->dwGlyphCount);
        printf("NTM:dwCharWidthCount:%ld\n", pNTM->dwCharWidthCount);
        printf("NTM:dwDefaultCharWidth:%ld\n", pNTM->dwDefaultCharWidth);
        printf("NTM:dwCharSet:%ld\n", pNTM->dwCharSet);
        printf("NTM:dwCodePage:%ld\n", pNTM->dwCodePage);

        pifi = (PIFIMETRICS)MK_PTR(pNTM, dwIFIMetricsOffset);

        printf("IFIMETRICS:dpwszFamilyName:%S\n", (LPWSTR)MK_PTR(pifi, dpwszFamilyName));
        printf("IFIMETRICS:dpwszStyleName:%S\n", (LPWSTR)MK_PTR(pifi, dpwszStyleName));
        printf("IFIMETRICS:dpwszFaceName:%S\n", (LPWSTR)MK_PTR(pifi, dpwszFaceName));
        printf("IFIMETRICS:dpwszUniqueName:%S\n", (LPWSTR)MK_PTR(pifi, dpwszUniqueName));

        printf("IFIMETRICS:jWinCharSet:%d\n", (WORD)pifi->jWinCharSet);
        printf("IFIMETRICS:jWinPitchAndFamily:%02X\n", (WORD)pifi->jWinPitchAndFamily);
        printf("IFIMETRICS:usWinWeight:%d\n", (int)pifi->usWinWeight);
        printf("IFIMETRICS:flInfo:%08lX\n", pifi->flInfo);
        printf("IFIMETRICS:fsSelection:%04X\n", (WORD)pifi->fsSelection);
        printf("IFIMETRICS:fsType:%04X\n", (WORD)pifi->fsType);

        printf("IFIMETRICS:fwdUnitsPerEm:%d\n", (int)pifi->fwdUnitsPerEm);
        printf("IFIMETRICS:fwdLowestPPEm:%d\n", (int)pifi->fwdLowestPPEm);

        printf("IFIMETRICS:fwdWinAscender:%d\n", (int)pifi->fwdWinAscender);
        printf("IFIMETRICS:fwdWinDescender:%d\n", (int)pifi->fwdWinDescender);
        printf("IFIMETRICS:fwdMacAscender:%d\n", (int)pifi->fwdMacAscender);
        printf("IFIMETRICS:fwdMacDescender:%d\n", (int)pifi->fwdMacDescender);
        printf("IFIMETRICS:fwdMacLineGap:%d\n", (int)pifi->fwdMacLineGap);
        printf("IFIMETRICS:fwdTypoAscender:%d\n", (int)pifi->fwdTypoAscender);
        printf("IFIMETRICS:fwdTypoDescender:%d\n", (int)pifi->fwdTypoDescender);
        printf("IFIMETRICS:fwdTypoLineGap:%d\n", (int)pifi->fwdTypoLineGap);
        printf("IFIMETRICS:fwdAveCharWidth:%d\n", (int)pifi->fwdAveCharWidth);
        printf("IFIMETRICS:fwdMaxCharInc:%d\n", (int)pifi->fwdMaxCharInc);
        printf("IFIMETRICS:fwdCapHeight:%d\n", (int)pifi->fwdCapHeight);
        printf("IFIMETRICS:fwdXHeight:%d\n", (int)pifi->fwdXHeight);

        printf("IFIMETRICS:fwdSubscriptXSize:%d\n", (int)pifi->fwdSubscriptXSize);
        printf("IFIMETRICS:fwdSubscriptYSize:%d\n", (int)pifi->fwdSubscriptYSize);
        printf("IFIMETRICS:fwdSubscriptXOffset:%d\n", (int)pifi->fwdSubscriptXOffset);
        printf("IFIMETRICS:fwdSubscriptYOffset:%d\n", (int)pifi->fwdSubscriptYOffset);
        printf("IFIMETRICS:fwdSuperscriptXSize:%d\n", (int)pifi->fwdSuperscriptXSize);
        printf("IFIMETRICS:fwdSuperscriptYSize:%d\n", (int)pifi->fwdSuperscriptYSize);
        printf("IFIMETRICS:fwdSuperscriptXOffset:%d\n", (int)pifi->fwdSuperscriptXOffset);
        printf("IFIMETRICS:fwdSuperscriptYOffset:%d\n", (int)pifi->fwdSuperscriptYOffset);
        printf("IFIMETRICS:fwdUnderscoreSize:%d\n", (int)pifi->fwdUnderscoreSize);
        printf("IFIMETRICS:fwdUnderscorePosition:%d\n", (int)pifi->fwdUnderscorePosition);
        printf("IFIMETRICS:fwdStrikeoutSize:%d\n", (int)pifi->fwdStrikeoutSize);
        printf("IFIMETRICS:fwdStrikeoutPosition:%d\n", (int)pifi->fwdStrikeoutPosition);

        printf("IFIMETRICS:chFirstChar:%02X\n", (WORD)pifi->chFirstChar);
        printf("IFIMETRICS:chLastChar:%02X\n", (WORD)pifi->chLastChar);
        printf("IFIMETRICS:chDefaultChar:%02X\n", (WORD)pifi->chDefaultChar);
        printf("IFIMETRICS:chBreakChar:%02X\n", (WORD)pifi->chBreakChar);
        printf("IFIMETRICS:ptlBaseline:(%ld, %ld)\n", pifi->ptlBaseline.x, pifi->ptlBaseline.y);
        printf("IFIMETRICS:ptlAspect:(%ld, %ld)\n", pifi->ptlAspect.x, pifi->ptlAspect.y);
        printf("IFIMETRICS:ptlCaret:(%ld, %ld)\n", pifi->ptlCaret.x, pifi->ptlCaret.y);
        printf("IFIMETRICS:rclFontBox:(%ld, %ld, %ld, %ld)\n",
                    pifi->rclFontBox.left, pifi->rclFontBox.top,
                    pifi->rclFontBox.right, pifi->rclFontBox.bottom);

        if (pifi->dpFontSim)
        {
            FONTSIM* pFontSim = (FONTSIM*)MK_PTR(pifi, dpFontSim);

            if (pFontSim->dpBold)
                printf("FONTSIM:Bold\n");
            if (pFontSim->dpItalic)
                printf("FONTSIM:Italic\n");
            if (pFontSim->dpBoldItalic)
                printf("FONTSIM:BoldItalic\n");
        }

        printf("GLYPHSETDATA:dwFlags:%08X\n", pGlyphSetData->dwFlags);
        printf("GLYPHSETDATA:dwGlyphSetNameOffset:%s\n",
                    (PSZ)MK_PTR(pGlyphSetData, dwGlyphSetNameOffset));
        printf("GLYPHSETDATA:dwGlyphCount:%ld\n", pGlyphSetData->dwGlyphCount);
        printf("GLYPHSETDATA:dwRunCount:%ld\n", pGlyphSetData->dwRunCount);
        printf("GLYPHSETDATA:dwCodePageCount:%ld\n", pGlyphSetData->dwCodePageCount);
        {
            DWORD dw;
            PCODEPAGEINFO pcpi = (PCODEPAGEINFO)MK_PTR(pGlyphSetData, dwCodePageOffset);
            for (dw = 1; dw <= pGlyphSetData->dwCodePageCount; dw++)
            {
                printf("CODEPAGEINFO#%ld:dwCodePage:%ld\n", dw, pcpi->dwCodePage);
                printf("CODEPAGEINFO#%ld:dwWinCharset:%ld\n", dw, pcpi->dwWinCharset);
                printf("CODEPAGEINFO#%ld:dwEncodingNameOffset:%s\n",
                            dw, (PSZ)MK_PTR(pcpi, dwEncodingNameOffset));
                pcpi++;
            }
        }

        printf("\n");
    }


    //////////////////////////////////////////////////////////////////
    //
    // Free strings and char metrics info.
    //
    //////////////////////////////////////////////////////////////////

    FREE_AFMTONTM_MEMORY;

    return(pNTM);
}

PBYTE
FindAFMToken(
    PBYTE   pAFM,
    PSZ     pszToken
    )

/*++

Routine Description:

    Finds an AFM token in a memory mapped AFM file stream.

Arguments:

    pAFM - pointer to memory mapped AFM file.
    pszToken - pointer to null-term string containing token to search for

Return Value:

    NULL => error
    otherwise => ptr to token's value. This is defined as the first non-blank
    char after the token name. If EOL(FindAfmToken(pAFM, pszToken)) then
    pszToken was found but it has no value (e.g. EndCharMetrics).


--*/

{
    PBYTE   pCurToken;
    int     i;

    VERBOSE(("Entering FindAFMToken... %s\n", pszToken));

    while (TRUE)
    {
        PARSE_TOKEN(pAFM, pCurToken);
        if (!(StrCmp(pCurToken, PS_COMMENT_TOK)))
        {
            NEXT_LINE(pAFM);
        }
        else
        {
            for (i = 0; i < MAX_TOKENS; i++)
            {
                if (!(StrCmp(pCurToken, pszToken)))
                {
                    return(pAFM);
                }
                else if (!(StrCmp(pCurToken, PS_EOF_TOK)))
                {
                    return NULL;
                }
            }
            NEXT_TOKEN(pAFM);
        }
    }

    return NULL;
}

CHSETSUPPORT
GetAFMCharSetSupport(
    PBYTE           pAFM,
    CHSETSUPPORT    *pGlyphSet
    )

/*++

Routine Description:

    Given a ptr to a memory mapped AFM, determine which Windows charset(s)
    it supports.

Arguments:

    pAFMetrx - pointer to CharMetrics in a memory mapped AFM file.

Return Value:

    Contains bit fields which indicate which csets are supported. Use
    CS_SUP(CS_xxx) macro to determine if a particular cset is supported.

--*/

{
    PBYTE           pToken;
    USHORT          i, chCnt;
    CHSETSUPPORT    flCsetSupport;
    PBYTE           pAFMMetrx;

    isSymbolCharSet = FALSE;

    *pGlyphSet = CS_NOCHARSET;

    //
    // Check to see if this is a CJK font.
    //
    if ((flCsetSupport = IsCJKFont(pAFM)))
    {
        return(flCsetSupport);
    }

    pToken = pAFMCharacterSetString;
    if (pToken != NULL)
    {
        if (StrCmp(pToken, PS_STANDARD_CHARSET_TOK) == 0)
            *pGlyphSet = CS_228;
        else
            *pGlyphSet = CS_314;
    }
    else
        *pGlyphSet = CS_228;

    //
    // Check to see if a EncodingScheme token in the AFM file. If so, check
    // if this is a standard encoding font or a Pi (Symbol) font.
    //
    if ((pToken = FindAFMToken(pAFM, PS_ENCODING_TOK)) != NULL)
    {
        if (StrCmp(pToken, PS_STANDARD_ENCODING) == 0)
        {
            return(CSUP(CS_ANSI));
        }
    }

    //
    // Find the beginning of the char metrics.
    //
    pAFMMetrx = FindAFMToken(pAFM, PS_CH_METRICS_TOK);
    if (pAFMMetrx == NULL)    // Fixed bug 354007
    {
        *pGlyphSet = CS_NOCHARSET;
        ERR(("makentf - invalid StartCharMetrics\n"));
        return(CS_NOCHARSET);
    }

    //
    // Current pos should be the character count field.
    //
    for (i = 0; i < StrLen(pAFMMetrx); i++)
    {
        if (!IS_NUM(&pAFMMetrx[i]))
        {
            *pGlyphSet = CS_NOCHARSET;
            ERR(("makentf - invalid StartCharMetrics\n"));
            return(CS_NOCHARSET);
        }
    }
    chCnt = (USHORT)atoi(pAFMMetrx);
    (ULONG_PTR) pAFMMetrx += i;

    //
    // Process each char.
    //
    flCsetSupport = 0;
    i = 0;
    do
    {
        PARSE_TOKEN(pAFMMetrx, pToken);

        if (StrCmp(pToken, PS_CH_NAME_TOK) == 0)
        {
            if (StrCmp(pAFMMetrx, PS_CH_NAME_EASTEUROPE) == 0)
                flCsetSupport |= CSUP(CS_EASTEUROPE);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_RUSSIAN) == 0)
                flCsetSupport |= CSUP(CS_RUSSIAN);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_ANSI) == 0)
                flCsetSupport |= CSUP(CS_ANSI);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_GREEK) == 0)
                flCsetSupport |= CSUP(CS_GREEK);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_TURKISH) == 0)
                flCsetSupport |= CSUP(CS_TURKISH);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_HEBREW) == 0)
                flCsetSupport |= CSUP(CS_HEBREW);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_ARABIC) == 0)
                flCsetSupport |= CSUP(CS_ARABIC);

            else if (StrCmp(pAFMMetrx, PS_CH_NAME_BALTIC) == 0)
                flCsetSupport |= CSUP(CS_BALTIC);

            i++;
        }
        else if (StrCmp(pToken, PS_EOF_TOK) == 0)
        {
            break;
        }

        NEXT_TOKEN(pAFMMetrx);

    } while (i < chCnt);

    //
    // Assume symbol if none of the other char set is supported.
    //
    if (flCsetSupport == 0)
    {
        *pGlyphSet = CS_NOCHARSET;
        flCsetSupport = CSUP(CS_SYMBOL);
        isSymbolCharSet = TRUE;
    }

    return flCsetSupport;
}

int __cdecl
StrCmp(
    const VOID *str1,
    const VOID *str2
    )
/*++

Routine Description:

    Compare two strings which are terminated by either a null char or a
    space.

Arguments:

    str1, str2 - Strings to compare.

Return Value:

    -1  => str1 < str2
     1  => str1 > str2
     0  => str1 = str2

--*/

{
    PBYTE   s1 = (PBYTE) str1, s2 = (PBYTE) str2;

    // Error case, just return less then.
    if ((s1 == NULL) || (s2 == NULL))
        return(-1);

    while (!IS_WHTSPACE(s1) && !IS_WHTSPACE(s2))
    {
        if (*s1 < *s2)
        {
            return(-1);
        }
        else if (*s1 > *s2)
        {
            return(1);
        }
        s1++;
        s2++;
     }
     //
     // Strings must be same length to be an exact match.
     //
     if (IS_WHTSPACE(s1) && IS_WHTSPACE(s2))
     {
        return(0);
     }
     else if (IS_WHTSPACE(s1))
     // else if ((*s1 == ' ') || (*s1 == '\0'))
     {
        //
        // s1 is shorter, so is lower in collating sequence than s2.
        //
        return(-1);
     }
     else
        //
        // s2 is shorter, so is lower in collating sequence than s1.
        //
        return(1);
}

size_t
StrLen(
    PBYTE   pString
    )
{
    ULONG   i;

    //
    // Scan for next space, ';' token seperator, or end of line.
    //
    for (i = 0; !EOL(&pString[i]); i++)
        if(pString[i] == ';' || pString[i] == ' ')
            break;
    return(i);
}

int
AFM2NTMStrCpy(
    const VOID *str1,
    size_t     cchDest,
    const VOID *str2
    )
/*++

Routine Description:

    Copies str2 to str1. Strings may be terminated by either a null char or a
    space.

Arguments:

    str2 - source string
    str1 - dest string
    cchDest - size (in chars) of the dest buffer

Return Value:

    Number of bychars copied

--*/

{
    PBYTE   s1 = (PBYTE) str1, s2 = (PBYTE) str2;
    ULONG   n = 0;

    if (cchDest > 0)
    {
        while (!IS_WHTSPACE(&s2[n]) && (cchDest > 0))
        {
            s1[n] = s2[n++];
            cchDest--;
        }

        if (cchDest == 0)
        {
            //
            // In this case n must be the original cchDest
            // value, so we have to truncate the dest string.
            //
            n--;
        }

        s1[n] = '\0';
    }

    return(n);
}

static int __cdecl
StrPos(
    const PBYTE str1,
    CHAR c
    )
/*++

Routine Description:

    Retuns index of char c in str1. String may be terminated by either a
    CR/LF, or a ':'.

Arguments:

    str1 - string to search
    c - search char

Return Value:

    Index of c in str1, or -1 if not found

--*/

{
    ULONG   i = 0;

    while (!EOL(&str1[i]))
    {
        if (str1[i++] == c)
            return(i - 1);
    }
    return(-1);
}

int __cdecl
CmpUniCodePts(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Compares the Unicode char code field of two UPSCODEPT structs.

Arguments:

    p1, p2 - Strings to compare.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PUPSCODEPT ptr1 = (PUPSCODEPT) p1, ptr2 = (PUPSCODEPT) p2;

    //
    // Compare Unicode code point fields.
    //
    if (ptr1->wcUnicodeid > ptr2->wcUnicodeid)
        return(1);
    else if (ptr1->wcUnicodeid < ptr2->wcUnicodeid)
        return(-1);
    else
        return(0);
}

static int __cdecl
CmpUnicodePsNames(
    const VOID  *p1,
    const VOID  *p2
    )

/*++

Routine Description:

    Compares two strings. This routine is meant to be used only for looking
    up a char name key in an array of UPSCODEPT structs.

Arguments:
    p1 - a null or whitespace terminated string.
    p2 - points to a UPSCODEPT struct.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PBYTE ptr1 = (PBYTE) p1;
    PUPSCODEPT ptr2 = (PUPSCODEPT) p2;

    //
    // Compare name fields.
    //
    return (StrCmp(ptr1, ptr2->pPsName));
}

static int __cdecl
CmpPsChars(
    const VOID  *p1,
    const VOID  *p2
    )

/*++

Routine Description:

    Compares a null or space terminated string to the pPsName string field
    of a PSCHARMETRICS struct.

Arguments:
    p1 - a null or whitespace terminated string.
    p2 - points to a PSCHARMETRICS struct.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PBYTE ptr1 = (PBYTE) p1;
    PPSCHARMETRICS ptr2 = (PPSCHARMETRICS) p2;

    //
    // Compare name fields.
    //
    return (StrCmp(ptr1, ptr2->pPsName));
}

static int __cdecl
CmpPsNameWinCpt(
    const VOID  *p1,
    const VOID  *p2
    )

/*++

Routine Description:

    Compares a null or space terminated string to the pPsName string field
    of a WINCPT struct.

Arguments:
    p1 - a null or whitespace terminated string.
    p2 - points to a WINCPT struct.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PBYTE ptr1 = (PBYTE) p1;
    PWINCPT ptr2 = (PWINCPT) p2;

    //
    // Compare name fields.
    //
    return(StrCmp(ptr1, ptr2->pPsName));
}

static int __cdecl
CmpKernPairs(
    const VOID  *p1,
    const VOID  *p2
    )

/*++

Routine Description:

    Compares 2 FD_KERNINGPAIR structs according to a key = wcSecond << 16 +
    wcFirst.

Arguments:
    p1, p2 - ptrs to FD_KERNINGPAIRS to compare.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    FD_KERNINGPAIR *ptr1 = (FD_KERNINGPAIR *) p1;
    FD_KERNINGPAIR *ptr2 = (FD_KERNINGPAIR *) p2;
    ULONG   key1, key2;

    //
    // Compute key for each kern pair.
    //
    key1 = (ptr1->wcSecond << 16) + ptr1->wcFirst;
    key2 = (ptr2->wcSecond << 16) + ptr2->wcFirst;

    if (key1 > key2)
    {
        return(1);
    }
    else if (key2 > key1)
    {
        return(-1);
    }
    else
    {
        return(0);
    }
}

int __cdecl
CmpGlyphRuns(
    const VOID *p1,
    const VOID *p2
    )
/*++

Routine Description:

    Compares the starting Unicode point of two GLYPHRUN structs.

Arguments:

    p1, p2 - GLYPHRUNs to compare.

Return Value:

    -1  => p1 < p2
     1  => p1 > p2
     0  => p1 = p2

--*/
{
    PGLYPHRUN ptr1 = (PGLYPHRUN) p1, ptr2 = (PGLYPHRUN) p2;

    //
    // Compare Unicode code point fields.
    //
    if (ptr1->wcLow > ptr2->wcLow)
        return(1);
    else if (ptr1->wcLow < ptr2->wcLow)
        return(-1);
    else
        return(0);
}

ULONG
CreateGlyphSets(
    PGLYPHSETDATA  *pGlyphSet,
    PWINCODEPAGE    pWinCodePage,
    PULONG         *pUniPs
    )

/*++

Routine Description:

    Create a GLYPHSETDATA data structure, which maps Unicode pts to Windows
    codepage/codepoints.

Arguments:

    pGlyphSet - A PGLYPHSETDATA pointer which upon successful
    completion contains the address of the newly allocated GLYPHSETDATA
    struct.

    pWinCodePage - a pointer to a windows code page info struct
    used to create the GLYPHSETDATA struct.

    pUniPs - Upon successful completion, -> a table which maps 0-based Glyph
    Indices of chars in the GLYPHRUNS of the GLYPHSETDATA struct for this
    charset to indices into the UnicodetoPs structure which maps Unicode
    points to PS char information.

Return Value:

    NULL => error
    Otherwise total size of all GLYPHSETDATAs and related structs which are
    created.

--*/

{
    int             i, j;
    ULONG           c;
    int             cRuns;
    int             cChars;
    int             cCharRun;
    WCHAR           wcLast;
    WCHAR           wcRunStrt;
    PGLYPHSETDATA   pGlyphSetData;
    PGLYPHRUN       pGlyphRuns;
    ULONG           ulSize;
    PVOID           pMapTable;
    PWINCPT         pWinCpt;
    PCODEPAGEINFO   pCodePageInfo;
    BOOLEAN         bFound, bIsPiFont;
    DWORD           dwEncodingNameOffset;
    DWORD           dwGSNameSize, dwCodePageInfoSize, dwCPIGSNameSize, dwGlyphRunSize;
    BOOL            bSingleCodePage;

    bSingleCodePage = (pWinCodePage->usNumBaseCsets == 1) ? TRUE : FALSE;

    ulSize = 0;
    cChars = cRuns = i = 0;

    if ((bIsPiFont = pWinCodePage->pCsetList[0] == CS_SYMBOL))
    {
        //
        // This is a symbol font. We takes care of PS char codes from 0x20 to
        // 0xff. We also map PS char codes to a single run in the Unicode
        // private range.
        //
        cChars = (256 - 32) + 256;
        cRuns = 1 * 2;
        bSingleCodePage = FALSE;
        VERBOSE(("Pi Font"));
    }
    else
    {
        //
        // Process all unicode code pts. to determine the number of Unicode
        // point runs present in this windows codepage.
        //

        do
        {
            //
            // Proceed until the starting codepoint of next run is found.
            //
            // for (j = 0; j < pWinCodePage->usNumBaseCsets &&
            //         i < NUM_PS_CHARS;
            //         j++)
            //     if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
            //         break;
            //     else
            //        i++;
            //
            bFound = FALSE;

            for (; i < NUM_PS_CHARS; i++)
            {
                for (j = 0; j < pWinCodePage->usNumBaseCsets; j++)
                {
                    if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                if (bFound)
                    break;
            }

            //
            // Check to see if we've scanned all Unicode points.
            //
            if (i == NUM_PS_CHARS)
                break;

            //
            // Start a new run.
            //
            cCharRun = 0;
            wcRunStrt = UnicodetoPs[i].wcUnicodeid;

            //
            // Chars are only part of the run if they are supported
            // in the current charset.
            //
            while (i < NUM_PS_CHARS &&
                UnicodetoPs[i].wcUnicodeid == wcRunStrt + cCharRun)
            {
                for (j = 0; j < pWinCodePage->usNumBaseCsets; j++)
                {
                    if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
                    {
                        cCharRun++;
                        break;
                    }
                }
                i++;
            }
            if (cCharRun)
            {
                cChars += cCharRun;
                cRuns++;
            }
        } while (i < NUM_PS_CHARS);
    }

    //
    // Compute the total amount of memory required for the GLYPHSETDATA array
    // and all other related data. We need
    // 1. one CODEPAGEINFO struct for each base charset supported by this font,
    // 2. one GLYPHRUN struct for each run, and
    // 3. four bytes per char to store codepage and codepoint or two bytes per
    //    char to store only codepoint for the mapping table.
    //
    dwGSNameSize = ALIGN4(strlen(pWinCodePage->pszCPname) + 1);
    dwCodePageInfoSize = ALIGN4(pWinCodePage->usNumBaseCsets * sizeof (CODEPAGEINFO));
    dwGlyphRunSize = ALIGN4(cRuns * sizeof (GLYPHRUN));

    ulSize = ALIGN4(sizeof(GLYPHSETDATA))
                + dwGSNameSize
                + dwCodePageInfoSize
                + dwGlyphRunSize;

    //
    // Account for the size of the mapping table.
    //
    ulSize += bSingleCodePage ? ALIGN4((cChars * sizeof (WORD))) : (cChars * sizeof (DWORD));

    //
    // Account for the size of CODEPAGE name strings found in CODEPAGEINFO
    // struct(s).
    //
    for (dwCPIGSNameSize = 0, j = 0; j < pWinCodePage->usNumBaseCsets; j++)
    {
        dwCPIGSNameSize += ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[j]].pGSName) + 1);
    }
    ulSize += dwCPIGSNameSize;

    //
    // Allocate memory for the GLYPHSETDATA struct.
    //
    if ((pGlyphSetData = (PGLYPHSETDATA) MemAllocZ((size_t) ulSize)) == NULL)
    {
        ERR(("makentf - CreateGlyphSets: malloc\n"));
        return(FALSE);
    }

    //
    // Allocate an array of ULONGs to store the index of each char into
    // the Unicode->Ps translation table.
    //
    if (!bIsPiFont)
    {
        if ((*pUniPs = (PULONG) MemAllocZ((size_t)(cChars * sizeof(ULONG)))) == NULL)
        {
            ERR(("makentf - CreateGlyphSets: malloc\n"));
            return(FALSE);
        }
    }

    //
    // Init GLYPHSETDATA fields.
    //
    pGlyphSetData->dwSize = ulSize;
    pGlyphSetData->dwVersion = GLYPHSETDATA_VERSION;
    pGlyphSetData->dwFlags = 0;
    pGlyphSetData->dwGlyphSetNameOffset = ALIGN4(sizeof(GLYPHSETDATA));
    pGlyphSetData->dwGlyphCount = cChars;
    pGlyphSetData->dwCodePageCount = pWinCodePage->usNumBaseCsets;
    pGlyphSetData->dwCodePageOffset = pGlyphSetData->dwGlyphSetNameOffset + dwGSNameSize;
    pGlyphSetData->dwRunCount = cRuns;
    pGlyphSetData->dwRunOffset = pGlyphSetData->dwCodePageOffset + dwCodePageInfoSize + dwCPIGSNameSize;
    pGlyphSetData->dwMappingTableOffset = pGlyphSetData->dwRunOffset + dwGlyphRunSize;

    //
    // Set the mapping table type flag to dwFlags field.
    //
    pGlyphSetData->dwFlags |= bSingleCodePage ? GSD_MTT_WCC : GSD_MTT_DWCPCC;

    //
    // Store code page name
    //
    StringCchCopyA((PSZ) MK_PTR(pGlyphSetData, dwGlyphSetNameOffset), dwGSNameSize, pWinCodePage->pszCPname);

    //
    // Initialize a CODEPAGEINFO struct for each base charset supported
    // by this font.
    //
    pCodePageInfo = (PCODEPAGEINFO) MK_PTR(pGlyphSetData, dwCodePageOffset);
    dwEncodingNameOffset = dwCodePageInfoSize;

    for (j = 0; j < pWinCodePage->usNumBaseCsets; j++, pCodePageInfo++)
    {
        //
        // Save CODEPAGEINFO. We don't use PS encoding vectors.
        //
        pCodePageInfo->dwCodePage = aPStoCP[pWinCodePage->pCsetList[j]].usACP;
        pCodePageInfo->dwWinCharset = (DWORD)aPStoCP[pWinCodePage->pCsetList[j]].jWinCharset;
        pCodePageInfo->dwEncodingNameOffset = dwEncodingNameOffset;
        pCodePageInfo->dwEncodingVectorDataSize = 0;
        pCodePageInfo->dwEncodingVectorDataOffset = 0;

        //
        // Copy codepage name string to end of array of CODEPAGEINFOs.
        //
        StringCchCopyA((PBYTE)MK_PTR(pCodePageInfo, dwEncodingNameOffset),
                ALIGN4(strlen(aPStoCP[pWinCodePage->pCsetList[j]].pGSName) + 1),
                aPStoCP[pWinCodePage->pCsetList[j]].pGSName);

        //
        // Adjust the offset to the codepage name for the next CODEPAGINFO structure
        //
        dwEncodingNameOffset -= ALIGN4(sizeof (CODEPAGEINFO));
        dwEncodingNameOffset += ALIGN4(strlen((PBYTE)MK_PTR(pCodePageInfo, dwEncodingNameOffset)) + 1);
    }

    //
    // Init ptr to the mapping table.
    //
    pGlyphRuns = GSD_GET_GLYPHRUN(pGlyphSetData);
    pMapTable = GSD_GET_MAPPINGTABLE(pGlyphSetData);

    //
    // Make another pass through the Unicode points to initialize the Unicode
    // runs and gi->codepage/codept mapping array for this codepage.
    //
    cRuns = 0;
    if (bIsPiFont)
    {
        //
        // Glyphset for Pi fonts has 1 run of 256 minus 0x20(it's 0x1f
        // actually) chars over the Unicode private range.
        //
        pGlyphRuns[cRuns].wcLow = NOTDEF1F;
        pGlyphRuns[cRuns].wGlyphCount = 256 - NOTDEF1F;

        pGlyphRuns[cRuns + 1].wcLow = UNICODE_PRV_STRT;
        pGlyphRuns[cRuns + 1].wGlyphCount = 256;

        //
        // We know that Pi fonts support only single encoding, but we also
        // provide the mapping table for Unicode range f000...f0ff, which
        // is mapped to PS code point 00...ff.
        //
        for (i = 0; i < 256 - NOTDEF1F; i++)
        {
            ((DWORD*)pMapTable)[i] =
                aPStoCP[pWinCodePage->pCsetList[0]].usACP << 16 | (i + NOTDEF1F);
        }

        for (i = 0; i < 256; i++)
        {
            ((DWORD*)pMapTable)[i + 256 - NOTDEF1F] =
                aPStoCP[pWinCodePage->pCsetList[0]].usACP << 16 | i;
        }
    }
    else
    {
        cChars = i = 0;
        do
        {
            //
            // Proceed until the starting codepoint of next run is found.
            //
            // for (j = 0; j < pWinCodePage->usNumBaseCsets &&
            //         i < NUM_PS_CHARS;
            //         j++)
            //     if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
            //         break;
            //     else
            //         i++;
            //
            bFound = FALSE;
            for (; i < NUM_PS_CHARS; i++)
            {
                for (j = 0; j < pWinCodePage->usNumBaseCsets; j++)
                {
                    if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
                    {
                        bFound = TRUE;
                        break;
                    }
                }
                if (bFound)
                    break;
            }


            //
            // Check to see if we've scanned all Unicode points.
            //
            if (i == NUM_PS_CHARS)
                break;

            //
            // Start a new run.
            //
            cCharRun = 0;
            wcRunStrt = UnicodetoPs[i].wcUnicodeid;

            //
            // Chars are only part of the run if they are supported
            // in the current charset.
            //
            while (i < NUM_PS_CHARS &&
                    UnicodetoPs[i].wcUnicodeid == wcRunStrt + cCharRun)
            {
                for (j = 0, bFound = FALSE;
                    j < pWinCodePage->usNumBaseCsets && !bFound; j++)
                {
                    if (CSET_SUPPORT(UnicodetoPs[i].flCharSets, pWinCodePage->pCsetList[j]))
                    {
                        if (((pWinCpt =
                            (PWINCPT) bsearch(UnicodetoPs[i].pPsName,
                                                aPStoCP[pWinCodePage->pCsetList[j]].aWinCpts,
                                                aPStoCP[pWinCodePage->pCsetList[j]].ulChCnt,
                                                sizeof(WINCPT),
                                                CmpPsNameWinCpt))
                                                != NULL))
                        {
                            //
                            // Found a corresponding PS char in the current
                            // windows codepage. Save it in the mapping table.
                            //
                            if (bSingleCodePage)
                            {
                                ((WORD*)pMapTable)[cChars] = pWinCpt->usWinCpt;
                            }
                            else
                            {
                                ((DWORD*)pMapTable)[cChars] =
                                    aPStoCP[pWinCodePage->pCsetList[j]].usACP << 16 | pWinCpt->usWinCpt;
                            }
                            bFound = TRUE;
                        }
                        else if (j == (pWinCodePage->usNumBaseCsets - 1))
                        {
                            //
                            // Corresponding PS char was not found. Use Win
                            // codept 0 as .notdef char and base codepage.
                            //
                            if (bSingleCodePage)
                                ((WORD*)pMapTable)[cChars] = 0;
                            else
                                ((DWORD*)pMapTable)[cChars] =
                                    aPStoCP[pWinCodePage->pCsetList[0]].usACP << 16;
                            bFound = TRUE;
                        }

                        //
                        // If char is present in this codepage, save index in
                        // Unicode->Ps table.
                        //
                        if (bFound)
                        {
                            (*pUniPs)[cChars] = i;
                            cChars++;
                            cCharRun++;
                        }
                    }
                }
                i++;
            }
            if (cCharRun)
            {
                pGlyphRuns[cRuns].wcLow = wcRunStrt;
                pGlyphRuns[cRuns].wGlyphCount = (WORD)cCharRun;
                cRuns++;
            }
        } while (i < NUM_PS_CHARS);
    }

    //
    // Return success.
    //
    *pGlyphSet = pGlyphSetData;

    if (bVerbose && !bOptimize)
    {
        printf("GLYPHSETDATA:dwFlags:%08X\n", pGlyphSetData->dwFlags);
        printf("GLYPHSETDATA:dwGlyphSetNameOffset:%s\n",
                    (PSZ)MK_PTR(pGlyphSetData, dwGlyphSetNameOffset));
        printf("GLYPHSETDATA:dwGlyphCount:%ld\n", pGlyphSetData->dwGlyphCount);
        printf("GLYPHSETDATA:dwRunCount:%ld\n", pGlyphSetData->dwRunCount);
        printf("GLYPHSETDATA:dwCodePageCount:%ld\n", pGlyphSetData->dwCodePageCount);
        {
            DWORD dw;
            PCODEPAGEINFO pcpi = (PCODEPAGEINFO)MK_PTR(pGlyphSetData, dwCodePageOffset);
            for (dw = 1; dw <= pGlyphSetData->dwCodePageCount; dw++)
            {
                printf("CODEPAGEINFO#%ld:dwCodePage:%ld\n", dw, pcpi->dwCodePage);
                printf("CODEPAGEINFO#%ld:dwWinCharset:%ld\n", dw, pcpi->dwWinCharset);
                printf("CODEPAGEINFO#%ld:dwEncodingNameOffset:%s\n",
                            dw, (PSZ)MK_PTR(pcpi, dwEncodingNameOffset));
                pcpi++;
            }
        }

        if (bIsPiFont)
        {
            printf("(Single codepage with dwFlags bit 0 cleared.)\n");
            printf("(Special for Symbol glyphset)\n");
        }

        printf("\n");
    }

    return(ulSize);
}

LONG
FindClosestCodePage(
    PWINCODEPAGE    *pWinCodePages,
    ULONG           ulNumCodePages,
    CHSETSUPPORT    chSets,
    PCHSETSUPPORT   pchCsupMatch
    )

/*++

Routine Description:

    Given a list of ptrs to WINCODEPAGE structs, determine which WINCODEPAGE's
    component charsets best match the charsets value in chSets.

Arguments:

    pWinCodePages - List of PWINCODEPAGES.

    ulNumCodePages - Number of entries in pWinCodePages

    chSets - CHSETSUPPORT value which indicates which standard charsets
    are supported by this font.

    pchCsupMatch - Pointer to a CHSETSUPPORT variable which returns the
    supported charsets of the code page which most closely matches the
    chSets value. If no matching codepages are found, the value will be 0.

Return Value:

    -1 => no matching Codepages were found.
    Otherwise this is the index in pWinCodePages of the "best match" codepage.

--*/

{
    ULONG   c;
    LONG    j;
    LONG    cpMatch;
    LONG    nCurCsets, nLastCsets;
    FLONG   flCurCset;

    cpMatch = -1;

    //
    // Scan the list of Windows codepages.
    //
    for (c = 0, nLastCsets = 0; c < ulNumCodePages; c++)
    {
        //
        // Hack..Hack! If this is the Unicode codepage, ignore it as
        // no NTMs should reference it!
        //
        if (strcmp(pWinCodePages[c]->pszCPname, UNICODE_GS_NAME))
        {
            nCurCsets = flCurCset = 0;

            //
            // Determine which charsets in the current codepage are
            // a match for those supported by the current font.
            //
            for (j = 0; j < pWinCodePages[c]->usNumBaseCsets; j++)
            {
                if (CSET_SUPPORT(chSets, pWinCodePages[c]->pCsetList[j]))
                {
                    nCurCsets++;
                }
                flCurCset |= CSUP(pWinCodePages[c]->pCsetList[j]);
            }

            if (flCurCset == (FLONG) chSets)
            {
                //
                // Found a charset which supports ALL of the font's charsets.
                //
                cpMatch = (LONG) c;
                *pchCsupMatch = flCurCset;
                break;
            }
            else if (nCurCsets > nLastCsets)
            {
                //
                // This Windows codepage is the maximal match so far.
                //
                nLastCsets = nCurCsets;
                cpMatch = (LONG) c;
                *pchCsupMatch = flCurCset;
            }
        }
    }

    return(cpMatch);
}

ULONG
GetAFMCharWidths(
    PBYTE           pAFM,
    PWIDTHRUN       *pWidthRuns,
    PPSCHARMETRICS  pFontChars,
    PULONG          pUniPs,
    ULONG           ulChCnt,
    PUSHORT         pusAvgCharWidth,
    PUSHORT         pusMaxCharWidth

    )
/*++

Routine Description:

    Given a memory mapped AFM file ptr and a ptr to a which maps glyph indices
    to UPSCODEPT Unicode->Ps translation structs, fill memory with a list of
    WIDTHRUN structs which provide char width information.

Arguments:

    pAFM - Pointer to memory mapped AFM file.

    pWidthRuns - If NULL, this is a size request and the function returns the
    total size in bytes of all WIDTHRUN structs required for this font.
    Otherwise the ptr is assumed to point to a buffer large enough to
    hold the number of required WIDTHRUNs.

    pFontChars - pointer a table of PS font char metrics info previously
    created by calling the BuildPSCharMetrics function. This array contains
    per char metric information.

    pUniPs - Points to a table which maps 0-based Glyph Indices of chars
    in the GLYPHRUNS of the GLYPHSETDATA struct for this font to indices
    into the UnicodetoPs structure which maps Unicode points to PS char
    information. This mapping array is created by the CreateGlyphSet function
    defined in this module.

    ulChCnt - Number of chars in the GLYPHSET for this font. This most likely
    is not the same as the number of chars defined in the font's AFM.

    pulAvgCharWidth - pts to a USHORT used to return the average char
    width of the font. If NULL the average char width is not returned.

    pulMaxCharWidth - pts to a USHORT used to return the max char
    width of the font. If NULL the max char width is not returned.

Return Value:

    0 => error.
    Otherwise returns number of WIDTHRUN structs required for this font.

--*/

{
    ULONG i, j, curChar;
    int cRuns, cRealRuns;
    int cChars;
    int cCharRun;
    ULONG firstCharWidth;
    ULONG curCharWidth;
    ULONG notdefwidth;
    WCHAR wcRunStrt;
    USHORT  chCnt;
    PBYTE   pToken;
    PBYTE   pChMet;
    PPSCHARMETRICS pCurChar;
    BOOLEAN bIsPiFont, bIsCJKFont;
    CHAR    ch;
    BYTE    CharNameBuffer[32];
    PBYTE   pChName;
    // fix bug 240339, jjia, 8/3/98
    BOOLEAN bWidthRunComplex;
    PWORD   pWidthArray;
    // Fixed bug Adobe #367195.
    // In this program, when handling PiFont, we always assume the first character
    // in the CharMetrics is a space (32) char. However, some special font such as
    // HoeflerText-Ornaments does not follow this rule. the 1st char in the font is 9,
    // the 2ed char is 32. Added this flag to handle this kind of fonts.
    BOOLEAN bTwoSpace = FALSE;

    //
    // Determine if this is a Pi or CJK font.
    //
    bIsPiFont = IsPiFont(pAFM);
    bIsCJKFont = (IsCJKFont(pAFM) != 0);

    //
    // Get ptr to AFM char metrics.
    //
    pChMet = FindAFMToken(pAFM, PS_CH_METRICS_TOK);
    if (pChMet == NULL)    // Fixed bug 354007
        return (FALSE);

    //
    // Current pos should be the character count field.
    //
    for (i = 0; i < (int) StrLen(pChMet); i++)
    {
        if (!IS_NUM(&pChMet[i]))
        {
            return(FALSE);
        }
    }
    chCnt = (USHORT)atoi(pChMet);
    (ULONG_PTR) pChMet += i;

    //
    // If requested, make a pass through the PS Char Metrics to determine
    // the max char width.
    //
    if (pusMaxCharWidth != NULL)
    {
        *pusMaxCharWidth = 0;
        for (i = 0; i < chCnt; i++)
        {
            if (pFontChars[i].chWidth > *pusMaxCharWidth)
            {
                *pusMaxCharWidth = (USHORT) pFontChars[i].chWidth & 0xffff;
            }
        }
    }

    //
    // Search for .notdef char in list of PS chars, get .notdef char width.
    //
    if (bIsPiFont)
    {
        notdefwidth = pFontChars[0].chWidth;
    }
    else if ((pCurChar = (PPSCHARMETRICS) bsearch("space",
                                            pFontChars[0].pPsName,
                                            (size_t) chCnt,
                                            sizeof(PSCHARMETRICS),
                                            strcmp)) != NULL)
        notdefwidth = pCurChar->chWidth;
    else
        notdefwidth = 0;

    //
    // If average width was requested, process string of sample chars 1
    // at a time to compute average char width.
    // DCR --: Assume the sample is western alphabetic + space.
    // Need to fix this for non-western fonts !!!.
    //
    if (pusAvgCharWidth != NULL)
    {

        LONG    lWidth, count;  // a long to prevent OverFlow
        WINCPTOPS           *pCPtoPS;
        WINCPT              sortedWinCpts[MAX_CSET_CHARS]; // maxiaml 255 chars
        CHSETSUPPORT flCsupGlyphSet;
        ULONG   k;
        BYTE    *pSampleStr;


        //
        // Determine which charsets this font supports.
        //
        (VOID)GetAFMCharSetSupport(pAFM, &flCsupGlyphSet);
        if (flCsupGlyphSet == CS_228 || flCsupGlyphSet == CS_314)
        {
            pCPtoPS = &aPStoCP[CS_228];
        }
        else
        {
            // default - use the ANSI code page table
            pCPtoPS = &aPStoCP[CS_ANSI];
        }

        SortWinCPT(&(sortedWinCpts[0]), pCPtoPS);

        lWidth = 0;
        count = 0;
        k = 0x20; // start from FirstChar !!
        for (i = 0; i < pCPtoPS->ulChCnt && k <= 0xFF; i++, k++)
        {

            pCurChar = NULL;

            if (bIsPiFont)
            {
                if (i<chCnt)
                    pCurChar = &(pFontChars[ i ]);
                // We don't need Not-Encoded characters in a PiFont.
                if (pCurChar && strcmp(pCurChar->pPsName, "-1") == 0 )
                    pCurChar = NULL;
            }
            else
            {
                // sortedWinCpts is sorted by usWinCpt, so skip UP to what we want
                while (k > sortedWinCpts[i].usWinCpt && i < pCPtoPS->ulChCnt )
                {
                    i++;
                }

                // Take notdef chars in the 0x20 to 0xff range - gaps
                while (k < sortedWinCpts[i].usWinCpt && k <= 0xFF )
                {
                    k++;
                    lWidth += notdefwidth;
                    count++;
                }

                pSampleStr = NULL;
                if (k == sortedWinCpts[i].usWinCpt)
                    pSampleStr = sortedWinCpts[i].pPsName;
                if (pSampleStr == NULL)
                    continue;

                pCurChar = (PPSCHARMETRICS) bsearch(pSampleStr,
                                                        pFontChars[0].pPsName,
                                                        (size_t) chCnt,
                                                        sizeof(PSCHARMETRICS),
                                                        strcmp);
            }

            if (pCurChar != NULL && pCurChar->pPsName && pCurChar->pPsName[0] != 0 &&
                pCurChar->chWidth > 0)
            {
                lWidth += (LONG) pCurChar->chWidth;
                count++;
            }
            else
            {
                lWidth += notdefwidth;
                count++;
            }
        }

        if (count)
            lWidth = (lWidth + count/2)/count;

        if (lWidth == 0)
        {
            lWidth = 0 ;
            // This is a buggy font.  Or CJK font!!!
            // In this case we must come up with the reasonable number different from
            // zero. This number is used in computing font trasfroms.
            for (i = 0; i <= chCnt; i++)
                lWidth += (LONG) (pFontChars[i].chWidth & 0xffff);

            lWidth =  (lWidth + chCnt / 2) / chCnt ;

            // ASSERTMSG(*pusAvgCharWidth, ("PSCRIPT: pifi->fwdAveCharWidth == 0\n"));
        }

        // Now assign it to the original (short) width
        *pusAvgCharWidth = (FWORD) lWidth;


        if (*pusAvgCharWidth == 0 || (bIsCJKFont && *pusAvgCharWidth < EM))
        {
            *pusAvgCharWidth = EM;
        }
        if (bIsCJKFont)
        {
            // DCR: couldn't divide by 2 simply for C and K.
            *pusAvgCharWidth = *pusAvgCharWidth / 2;
        }
    }

    //
    // Determine the amount of memory required for the WIDTHRUNS which cover
    // all possible points in the font's charset.
    //
    i = cRuns = 0;
    if (bIsPiFont)
    {
        curChar = 1;
        if (atoi(pFontChars[i].pPsName) == (BYTE) ' ')
        {
            curCharWidth = pFontChars[i].chWidth;
        }
        else
        {
            // Fixed bug Adobe #367195
            if (atoi(pFontChars[i + 1].pPsName) == (BYTE) ' ')
                bTwoSpace = TRUE;

            curCharWidth = notdefwidth;
        }
    }
    else
    {
        //
        // Setup ptr to "char name" based on whether this is a
        // western or CJK font.
        //
        if (bIsCJKFont)
        {
            _ultoa(pUniPs[i], CharNameBuffer, 10);
            pChName = CharNameBuffer;
        }
        else
        {
            pChName = UnicodetoPs[pUniPs[i]].pPsName;
        }

        if ((pCurChar = (PPSCHARMETRICS) bsearch(pChName,
                                               pFontChars,
                                                (size_t) chCnt,
                                                sizeof(PSCHARMETRICS),
                                                CmpPsChars)) == NULL)
        {
            curCharWidth = notdefwidth;
        }
        else
        {
            curCharWidth = pCurChar->chWidth;
        }
    }
    do
    {
        //
        // Start new run.
        //
        cCharRun = 1;
        wcRunStrt = (USHORT) (i & 0xffff);

        for (firstCharWidth = curCharWidth, i++; i < ulChCnt; i++)
        {
            if (bIsPiFont)
            {
                if (curChar < chCnt)
                {
                    // Fixed bug Adobe #367185
                    if ((bTwoSpace) &&
                        ((ULONG) atoi(pFontChars[curChar].pPsName) == (i - 1 + (BYTE) ' ')))
                    {
                        curCharWidth = pFontChars[curChar].chWidth;
                        curChar++;
                    }
                    else if ((!bTwoSpace) &&
                        ((ULONG) atoi(pFontChars[curChar].pPsName) == (i + (BYTE) ' ')))
                    {
                        curCharWidth = pFontChars[curChar].chWidth;
                        curChar++;
                    }
                    else
                    {
                        curCharWidth = notdefwidth;
                    }
                }
                else
                {
                    curCharWidth = notdefwidth;
                }

            }
            else
            {
                //
                // Setup ptr to "char name" based on whether this is a
                // western or CJK font.
                //
                if (bIsCJKFont)
                {
                    _ultoa(pUniPs[i], CharNameBuffer, 10);
                    pChName = CharNameBuffer;
                }
                else
                {
                    pChName = UnicodetoPs[pUniPs[i]].pPsName;
                }
                if((pCurChar = (PPSCHARMETRICS) bsearch(pChName,
                                                           pFontChars,
                                                            (size_t) chCnt,
                                                            sizeof(PSCHARMETRICS),
                                                            CmpPsChars)) != NULL)
                {
                    curCharWidth = pCurChar->chWidth;
                }
                else
                {
                    curCharWidth = notdefwidth;
                }
            }
            if ((curCharWidth == firstCharWidth) &&
                    ((SHORT) i == (wcRunStrt + cCharRun)))
            {
                cCharRun++;
            }
            else
            {
                break;
            }
        }
        cRuns++;
    } while (i < ulChCnt);

    // Fix bug 240339, jjia, 8/3/98
    if ((cRuns * sizeof(WIDTHRUN)) >
        (ulChCnt * sizeof(WORD) + sizeof(WIDTHRUN)))
        bWidthRunComplex = TRUE;
    else
        bWidthRunComplex = FALSE;

    if (pWidthRuns == NULL)
    {
        //
        // Return number of WIDTHRUNs only.
        //
        if (!bIsPiFont)
        {
            // Fix bug 240339, jjia, 8/3/98
            if (bWidthRunComplex)
                return (ALIGN4(ulChCnt * sizeof(WORD) + sizeof(WIDTHRUN)));
            else
                return (ALIGN4(cRuns * sizeof(WIDTHRUN)));
        }
        else
        {
            //
            // Hack to support 2 Unicode runs.
            //
            return (ALIGN4(cRuns * 2 * sizeof(WIDTHRUN)));

        }
    }

    //
    // Create the list of WIDTHRUNs.
    //
    cRealRuns = cRuns;
    i = cRuns = 0;

    // Fix bug 240339, jjia, 8/3/98
    if (bWidthRunComplex && (!bIsPiFont))
    {
        (*pWidthRuns)[0].wStartGlyph = (WORD) (i & 0xffff);
        (*pWidthRuns)[0].dwCharWidth = WIDTHRUN_COMPLEX;
        (*pWidthRuns)[0].wGlyphCount = (WORD)ulChCnt;
        cRuns = 1;
        pWidthArray = (PWORD)&(*pWidthRuns)[1];

        for (; i < ulChCnt; i++)
        {
            if (bIsCJKFont)
            {
                _ultoa(pUniPs[i], CharNameBuffer, 10);
                pChName = CharNameBuffer;
            }
            else
            {
                pChName = UnicodetoPs[pUniPs[i]].pPsName;
            }
            if((pCurChar = (PPSCHARMETRICS) bsearch(pChName,
                                                    pFontChars,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    CmpPsChars)) == NULL)
            {
                //
                // Char is not defined in this font.
                //
                pWidthArray[i] = (WORD)notdefwidth;
            }
            else
            {
                //
                // Char is defined in this font.
                //
                pWidthArray[i] = (WORD)(pCurChar->chWidth);
            }
        }
        return (cRuns);
    }


    if (bIsPiFont)
    {
        curChar = 1;
        if (atoi(pFontChars[i].pPsName) == (BYTE) ' ')
        {
            curCharWidth = pFontChars[i].chWidth;
        }
        else
        {
            // Fixed bug Adobe #367195
            if (atoi(pFontChars[i + 1].pPsName) == (BYTE) ' ')
                bTwoSpace = TRUE;

            curCharWidth = notdefwidth;
        }
    }
    else
    {
        //
        // Setup ptr to "char name" based on whether this is a
        // western or CJK font.
        //
        if (bIsCJKFont)
        {
            _ultoa(pUniPs[i], CharNameBuffer, 10);
            pChName = CharNameBuffer;
        }
        else
        {
            pChName = UnicodetoPs[pUniPs[i]].pPsName;
        }
        if ((pCurChar = (PPSCHARMETRICS) bsearch(pChName,
                                                   pFontChars,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    CmpPsChars)) != NULL)
        {
            curCharWidth = pCurChar->chWidth;
        }
        else
        {
            curCharWidth = notdefwidth;
        }
    }

    do
    {
        //
        // Start new run.
        //
        cCharRun = 1;
        wcRunStrt = (USHORT) (i & 0xffff);
        for (firstCharWidth = curCharWidth, i++; i < ulChCnt; i++)
        {
            if (bIsPiFont)
            {
                if (curChar < chCnt)
                {
                    // Fixed bug Adobe #367185
                    if ((bTwoSpace) &&
                        ((ULONG) atoi(pFontChars[curChar].pPsName) == (i - 1 + (BYTE) ' ')))
                    {
                        curCharWidth = pFontChars[curChar].chWidth;
                        curChar++;
                    }
                    else if ((!bTwoSpace) &&
                        ((ULONG) atoi(pFontChars[curChar].pPsName) == (i + (BYTE) ' ')))
                    {
                        curCharWidth = pFontChars[curChar].chWidth;
                        curChar++;
                    }
                    else
                    {
                        curCharWidth = notdefwidth;
                    }
                }
                else
                {
                    curCharWidth = notdefwidth;
                }

            }
            else
            {
                //
                // Setup ptr to "char name" based on whether this is a
                // western or CJK font.
                //
                if (bIsCJKFont)
                {
                    _ultoa(pUniPs[i], CharNameBuffer, 10);
                    pChName = CharNameBuffer;
                }
                else
                {
                    pChName = UnicodetoPs[pUniPs[i]].pPsName;
                }
                if((pCurChar = (PPSCHARMETRICS) bsearch(pChName,
                                                       pFontChars,
                                                        (size_t) chCnt,
                                                        sizeof(PSCHARMETRICS),
                                                        CmpPsChars)) == NULL)
                {
                    //
                    // Char is not defined in this font.
                    //
                    curCharWidth = notdefwidth;
                }
                else
                {
                    //
                    // Char is defined in this font.
                    //
                    curCharWidth = pCurChar->chWidth;
                }
            }
            if ((curCharWidth == firstCharWidth) &&
                ((SHORT) i == (wcRunStrt + cCharRun)))
            {
                cCharRun++;
            }
            else
            {
                break;
            }
        }
        (*pWidthRuns)[cRuns].wStartGlyph = wcRunStrt;
        (*pWidthRuns)[cRuns].dwCharWidth = firstCharWidth;
        (*pWidthRuns)[cRuns].wGlyphCount = (WORD)cCharRun;
        if (bIsPiFont)
        {
            //
            // Hack to support 2 unicode runs.
            //
            (*pWidthRuns)[cRuns + cRealRuns].wStartGlyph = wcRunStrt;
            (*pWidthRuns)[cRuns + cRealRuns].dwCharWidth = firstCharWidth;
            (*pWidthRuns)[cRuns + cRealRuns].wGlyphCount = (WORD)cCharRun;
        }
        cRuns++;
    } while (cRuns < cRealRuns);


    if (bIsPiFont)
    {
        return(cRuns * 2);
    }
    else
    {
        return(cRuns);
    }
}

ULONG
GetAFMETM(
    PBYTE           pAFM,
    PPSCHARMETRICS  pFontChars,
    PETMINFO        pEtmInfo
    )
/*++

Routine Description:

    Given a memory mapped AFM file ptr and a ptr to a which maps glyph indices
    to UPSCODEPT Unicode->Ps translation structs, fill memory with a list of
    WIDTHRUN structs which provide char width information.

Arguments:

    pAFM - Pointer to memory mapped AFM file.

    pFontChars - pointer a table of PS font char metrics info previously
    created by calling the BuildPSCharMetrics function. This array contains
    per char metric information.

    pulEtmInfo - pts to an ETMINFO struct used to return EXTEXTMETRIC
    info which must be derived from the AFM char metrics. If NULL the
    structure is not returned.

Return Value:

    0 => error.
    1 => success

--*/

{
    ULONG i;
    USHORT  chCnt;
    PPSCHARMETRICS pCurChar;
    BOOLEAN bIsPiFont;
    CHSETSUPPORT csIsCJKFont;
    PBYTE   pChMet;
    PSTR    pCJKCapH, pCJKx;

    //
    // Determine if this is a Pi or CJK font.
    //
    bIsPiFont = IsPiFont(pAFM);
    csIsCJKFont = IsCJKFont(pAFM);

    //
    // Get ptr to AFM char metrics.
    //
    pChMet = FindAFMToken(pAFM, PS_CH_METRICS_TOK);
    if (pChMet == NULL)    // Fixed bug 354007
        return (FALSE);

    //
    // Current pos should be the character count field.
    //
    for (i = 0; i < (int) StrLen(pChMet); i++)
    {
        if (!IS_NUM(&pChMet[i]))
        {
            return(FALSE);
        }
    }
    chCnt = (USHORT)atoi(pChMet);
    (ULONG_PTR) pChMet += i;

    //
    // Get EXTEXTMETRIC info if requested.
    //
    if (pEtmInfo != NULL)
    {
        if (bIsPiFont)
        {
            //
            // For Pi Fonts, chars are indexed by char code.
            //

            if ((BYTE) CAP_HEIGHT_CH - (BYTE) ' ' < chCnt)
                pCurChar = &(pFontChars[(BYTE) CAP_HEIGHT_CH - (BYTE) ' ']);
            else
                pCurChar = NULL;  // default to 0 CapHeight

        }
        else
        {
            if (!csIsCJKFont)
            {
                pCurChar = (PPSCHARMETRICS) bsearch(CAP_HEIGHT_CHAR,
                                                    pFontChars[0].pPsName,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    strcmp);
            }
            else
            {
                // We need CID of "H" in CJK
                if (csIsCJKFont & (CSUP(CS_CHINESEBIG5) | CSUP(CS_GB2312)))
                    pCJKCapH = "853";
                else if (csIsCJKFont & (CSUP(CS_SHIFTJIS) | CSUP(CS_SHIFTJIS83)))
                    pCJKCapH = "271";
                else if (csIsCJKFont & (CSUP(CS_HANGEUL) | CSUP(CS_JOHAB)))
                    pCJKCapH = "8134";
                else
                    pCJKCapH = CAP_HEIGHT_CHAR;

                pCurChar = (PPSCHARMETRICS) bsearch(pCJKCapH,
                                                    pFontChars[0].pPsName,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    strcmp);
            }
        }

        if (pCurChar != NULL)
        {
            pEtmInfo->etmCapHeight = (USHORT) pCurChar->rcChBBox.top & 0xffff;
        }
        else
        {
            pEtmInfo->etmCapHeight = 0;
        }

        if (bIsPiFont)
        {
            //
            // For Pi Fonts, chars are indexed by char code.
            //
            if ((BYTE) X_HEIGHT_CH - (BYTE) ' ' < chCnt)
                pCurChar = &(pFontChars[(BYTE) X_HEIGHT_CH - (BYTE) ' ']);
            else
                pCurChar = NULL;  // default to 0
        }
        else
        {
            if (!csIsCJKFont)
            {
                pCurChar = (PPSCHARMETRICS) bsearch(X_HEIGHT_CHAR,
                                                    pFontChars[0].pPsName,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    strcmp);
            }
            else
            {
                // We need CID of "x" in CJK
                if (csIsCJKFont & (CSUP(CS_CHINESEBIG5) | CSUP(CS_GB2312)))
                    pCJKx = "901";
                else if (csIsCJKFont & (CSUP(CS_SHIFTJIS) | CSUP(CS_SHIFTJIS83)))
                    pCJKx = "319";
                else if (csIsCJKFont & (CSUP(CS_HANGEUL) | CSUP(CS_JOHAB)))
                    pCJKx = "8182";
                else
                    pCJKx = X_HEIGHT_CHAR;

                pCurChar = (PPSCHARMETRICS) bsearch(pCJKx,
                                                    pFontChars[0].pPsName,
                                                    (size_t) chCnt,
                                                    sizeof(PSCHARMETRICS),
                                                    strcmp);
            }
        }

        if (pCurChar != NULL)
        {
            pEtmInfo->etmXHeight = (USHORT) pCurChar->rcChBBox.top & 0xffff;
        }
        else
        {
            pEtmInfo->etmXHeight = 0;
        }

        if (bIsPiFont)
        {
            //
            // For Pi Fonts, chars are indexed by char code.
            //
            if ((BYTE) LWR_ASCENT_CH - (BYTE) ' ' < chCnt)
                pCurChar = &(pFontChars[(BYTE) LWR_ASCENT_CH - (BYTE) ' ']);
            else
                pCurChar = NULL;  // default to 0
        }
        else
        {
            pCurChar = (PPSCHARMETRICS) bsearch(LWR_ASCENT_CHAR,
                                                pFontChars[0].pPsName,
                                                (size_t) chCnt,
                                                sizeof(PSCHARMETRICS),
                                                strcmp);
        }

        if (pCurChar != NULL)
        {
            pEtmInfo->etmLowerCaseAscent = (USHORT) pCurChar->rcChBBox.top & 0xffff;
        }
        else
        {
            pEtmInfo->etmLowerCaseAscent = 0;
        }

        if (bIsPiFont)
        {
            //
            // For Pi Fonts, chars are indexed by char code.
            //
            if ((BYTE) LWR_DESCENT_CH - (BYTE) ' '  < chCnt)
                pCurChar = &(pFontChars[(BYTE) LWR_DESCENT_CH - (BYTE) ' ']);
            else
                pCurChar = NULL;  // default to 0
        }
        else
        {
            pCurChar = (PPSCHARMETRICS) bsearch(LWR_DESCENT_CHAR,
                                                pFontChars[0].pPsName,
                                                (size_t) chCnt,
                                                sizeof(PSCHARMETRICS),
                                                strcmp);
        }

        if (pCurChar != NULL)
        {
            pEtmInfo->etmLowerCaseDescent = (USHORT) pCurChar->rcChBBox.bottom & 0xffff;
        }
        else
        {
            pEtmInfo->etmLowerCaseDescent = 0;
        }
    }

    return TRUE;

}

ULONG
GetAFMKernPairs(
    PBYTE           pAFM,
    FD_KERNINGPAIR  *pKernPairs,
    PGLYPHSETDATA   pGlyphSetData
    )

/*++

Routine Description:

    Given a memory mapped AFM file ptr and a ptr to a GLYPHSETDATA which
    describes the supported charset for the font, fill memory with a list of
    FD_KERNINGPAIR structs which provide pair kerning information.

Arguments:

    pAFM - Pointer to memory mapped AFM file.

    pKernPairs - If NULL, this is a size request and the function returns the
    total size in bytes of all FD_KERNINGPAIR structs required for this font.
    Otherwise the ptr is assumed to point to a buffer large enough to
    hold the number of required FD_KERNINGPAIRs.

    pGlyphSetData - Points to a GLYPHSETDATA structure which describes the
    Unicode->code point mappings for the charset to be used with this font.

Return Value:

    0 => no kerning.
    Otherwise returns number of FD_KERNINGPAIR structs required for this font.

--*/

{
    PBYTE       pKernData;
    PBYTE       pToken;
    PUPSCODEPT  pKernStrtChar, pKernEndChar;
    PGLYPHRUN   pGlyphRuns;
    ULONG       i, cMaxKernPairs, cKernPairs;
    BOOLEAN     bFound;

    //
    // for the time being, no kerning for Pi or CJK fonts.
    //
    if (IsPiFont(pAFM) || IsCJKFont(pAFM))
    {
        return(FALSE);
    }

    //
    // Is there kerning info for this font?
    //
    if ((pKernData = FindAFMToken(pAFM, PS_KERN_DATA_TOK)) == NULL)
    {
        //
        // There is no kerning info for this font.
        //
        return(FALSE);
    }

    //
    // Get ptr to AFM kerning data.
    //
    if ((pKernData = FindAFMToken(pAFM, PS_NUM_KERN_PAIRS_TOK)) == NULL)
    {
        //
        // There is no kerning info for this font.
        //
        return(FALSE);
    }

    //
    // Current pos should be the kern pair count field.
    //
    for (i = 0; i < (int) StrLen(pKernData); i++)
    {
        if (!IS_NUM(&pKernData[i]))
        {
            return(FALSE);
        }
    }
    cMaxKernPairs = atoi(pKernData);
    NEXT_LINE(pKernData);
    cKernPairs = 0;
    pGlyphRuns = (PGLYPHRUN) (MK_PTR(pGlyphSetData, dwRunOffset));

    //
    // Get the kern pairs from the AFM.
    //
    do
    {
        PARSE_TOKEN(pKernData, pToken);

        if (!StrCmp(pToken, PS_KERN_PAIR_TOK))
        {
            //
            // Kern pair token found. Get Unicode id for start and end
            // chars. Determine if these chars are supported in the
            // charset to be used with the current font.
            //
            if((pKernStrtChar = (PUPSCODEPT) bsearch(pKernData,
                                                       PstoUnicode,
                                                        (size_t) NUM_PS_CHARS,
                                                        sizeof(UPSCODEPT),
                                                        CmpUnicodePsNames)) == NULL)
            {
                //
                // No Unicode code pt for this char.
                //
                break;
            }

            //
            // Determine if the char is present in the Unicode runs for
            // this glyphset.
            //
            bFound = FALSE;
            for (i = 0; i < pGlyphSetData->dwRunCount &&
                    pKernStrtChar->wcUnicodeid >= pGlyphRuns[i].wcLow &&
                    !bFound;
                    i++)
            {
                bFound =
                    pKernStrtChar->wcUnicodeid <
                        pGlyphRuns[i].wcLow + pGlyphRuns[i].wGlyphCount;
            }

            if (!bFound)
            {
                //
                // Char is not supported, so ignore this kern pair.
                //
                NEXT_LINE(pKernData);
                break;
            }

            //
            // Get the 2nd char in the kern pair.
            //
            PARSE_TOKEN(pKernData, pToken);

            //
            // Determine if the 2nd char is supported in this charset.
            //
            if((pKernEndChar = (PUPSCODEPT) bsearch(pKernData,
                                                       PstoUnicode,
                                                        (size_t) NUM_PS_CHARS,
                                                        sizeof(UPSCODEPT),
                                                        CmpUnicodePsNames)) == NULL)
            {
                //
                // No Unicode code pt for this char.
                //
                break;
            }

            //
            // Determine if the char is present in the Unicode runs for
            // this glyphset.
            //
            bFound = FALSE;
            for (i = 0; i < pGlyphSetData->dwRunCount &&
                    pKernEndChar->wcUnicodeid >= pGlyphRuns[i].wcLow &&
                    !bFound;
                    i++)
            {
                bFound =
                    pKernEndChar->wcUnicodeid <
                        pGlyphRuns[i].wcLow + pGlyphRuns[i].wGlyphCount;
            }

            if (!bFound)
            {
                //
                // Char is not supported, so ignore this kern pair.
                //
                NEXT_LINE(pKernData);
                break;
            }

            //
            // Account for another kern pair.
            //
            if (pKernPairs != NULL)
            {
                pKernPairs[cKernPairs].wcFirst = pKernStrtChar->wcUnicodeid;
                pKernPairs[cKernPairs].wcSecond = pKernEndChar->wcUnicodeid;
                PARSE_TOKEN(pKernData, pToken);
                pKernPairs[cKernPairs].fwdKern = (FWORD)atoi(pKernData);
            }
            cKernPairs++;
        }
        else if (!StrCmp(pToken, PS_EOF_TOK) ||
            !StrCmp(pToken, PS_END_KERN_PAIRS_TOK))
        {
            break;
        }
        NEXT_TOKEN(pKernData);
    } while (cKernPairs < cMaxKernPairs);

    if (pKernPairs != NULL)
    {
        //
        // Sort kerning pairs by key = wcSecond << 16 + wcFIrst.
        //
        qsort(pKernPairs, (size_t) cKernPairs, (size_t) sizeof(FD_KERNINGPAIR),
            CmpKernPairs);

        //
        // Array of kerning pairs is terminated by a FD_KERNINGPAIR with
        // all fields set to 0.
        //
        pKernPairs[cKernPairs].wcFirst = 0;
        pKernPairs[cKernPairs].wcSecond = 0;
        pKernPairs[cKernPairs].fwdKern = 0;
    }
    return(cKernPairs);
}

ULONG
BuildPSFamilyTable(
    PBYTE   pDatFile,
    PTBL    *pPsFamilyTbl,
    ULONG   ulFileSize
)
/*++

Routine Description:

    Builds a table of PSFAMILYINFO structs from a text file of font info.
    The table is sorted in family name sequence. See the file PSFAMILY.DAT
    for info on the input file format.

Arguments:

    pDatFile - Ptr to memory mapped file image of .DAT file.

    pPsFamilyTbl - Ptr to memory to contain a ptr to a table of PSFAMILYINFO
    structs, which will be sorted in sFamilyName order.

    ulFileSize - size in bytes of memory mapped file stream.

Return Value:

    Number of entries in newly created table pointed to by *pPsFamilyTbl.
    0 => error

--*/
{
    USHORT  cFams;
    ULONG   i, j;
    CHAR    pFamilyType[CHAR_NAME_LEN];
    CHAR    pPitchType[CHAR_NAME_LEN];
    CHAR    *pStartLine;
    ULONG   cNameSize, cEngFamilyNameSize;
    ULONG   cFamilyTypeSize, cFamilyNameSize;
    ULONG   cDelimiters;
    PPSFAMILYINFO pPsFontFamMap;

    //
    // Make a pass through the file to determine number of families.
    //
    i = 0;
    cFams = 0;
    do
    {
        cDelimiters = 0;
        //
        // Skip leading whitespace.
        //
        while (IS_WHTSPACE(&pDatFile[i]) && i < ulFileSize)
            i++;

        //
        // We're at start of new line. If this is a comment, skip
        // this line.
        //
        if (IS_COMMENT(&pDatFile[i]))
            while (i <= ulFileSize && !EOL(&pDatFile[i]))
                i++;

        while (!EOL(&pDatFile[i]) && i < ulFileSize)
        {
            //
            // Search for lines with 3 ':' delimiters.
            //
            if (pDatFile[i++] == ':')
            {
                cDelimiters++;
            }
        }
        if (cDelimiters >= 3)
        {

            //
            // Found another family name mapping.
            //
            cFams++;
        }
    } while (i < ulFileSize);

    //
    // Allocate memory for family info table.
    //
    if ((*pPsFamilyTbl =
        (PTBL) MemAllocZ((size_t) (cFams * sizeof(PSFAMILYINFO)) + sizeof(TBL))) == NULL)
        return(FALSE);
    (*pPsFamilyTbl)->pTbl = (PVOID) ((ULONG_PTR) *pPsFamilyTbl + sizeof(TBL));
    pPsFontFamMap = (PPSFAMILYINFO) ((*pPsFamilyTbl)->pTbl);

    //
    // Parse file again, building table of PSFAMILYINFOs.
    //
    i = 0;
    cFams = 0;
    do
    {
        //
        // Skip leading whitespace.
        //
        while (IS_WHTSPACE(&pDatFile[i]) && i < ulFileSize)
            i++;

        //
        // We're at start of new line. If this is a comment, skip
        // this line.
        //
        if (IS_COMMENT(&pDatFile[i]))
            while (i <= ulFileSize && !EOL(&pDatFile[i]))
                i++;
        else
            pStartLine = &pDatFile[i];

        while (!EOL(&pDatFile[i]) && i < ulFileSize)
            //
            // Search for lines with 3 ':' delimiters.
            //
            if (pDatFile[i++] == ':')
            {
                //
                // Check for English family name mapping.
                //
                if (pDatFile[i] == ':')
                {
                    cEngFamilyNameSize = 0;
                }
                else if ((cEngFamilyNameSize = StrPos(&pDatFile[i], ':')) == -1)
                {
                    //
                    // No more delimeters on this line, skip it.
                    //
                    i += StrLen(&pDatFile[i]);
                    break;
                }

                i += cEngFamilyNameSize + 1;

                //
                // Check for another family name mapping. If present, build
                // a FAMILYINFO struct for it.
                //
                if ((cFamilyNameSize = StrPos(&pDatFile[i], ':')) == -1)
                {
                    //
                    // No more delimeters on this line, skip it.
                    //
                    i += StrLen(&pDatFile[i]);
                    break;
                }

                i +=  cFamilyNameSize + 1;

                //
                // Check for font family type name
                //
                if ((cFamilyTypeSize = StrPos(&pDatFile[i], ':')) != -1)
                {
                    i +=  cFamilyTypeSize + 1;
                }
                else
                {
                    cFamilyTypeSize = 0;
                }

                //
                // Make sure there are still chars for Win family type name
                // or pitch name.
                //
                if (EOL(&pDatFile[i]) || i >= ulFileSize)
                {
                    //
                    // Just ran out of file buffer.
                    //
                    break;
                }

                //
                // Get the font and family names.
                //
                cNameSize = StrPos(pStartLine, ':');
                memcpy(pPsFontFamMap[cFams].pFontName, pStartLine, cNameSize);
                pPsFontFamMap[cFams].pFontName[cNameSize] = '\0';
                pStartLine += cNameSize + 1;

                if (cEngFamilyNameSize)
                {
                    memcpy(pPsFontFamMap[cFams].pEngFamilyName, pStartLine, cEngFamilyNameSize);
                    pPsFontFamMap[cFams].pEngFamilyName[cEngFamilyNameSize] = '\0';
                }
                pStartLine += cEngFamilyNameSize + 1;

                memcpy(pPsFontFamMap[cFams].FamilyKey.pName, pStartLine, cFamilyNameSize);
                pPsFontFamMap[cFams].FamilyKey.pName[cFamilyNameSize] = '\0';

                // if cFamilyTypeSize != 0, means there must be a pitch name
                if (cFamilyTypeSize)
                {
                    pStartLine += cFamilyNameSize + 1;
                    memcpy(pFamilyType, pStartLine, cFamilyTypeSize);
                    pFamilyType[cFamilyTypeSize] = '\0';

                    AFM2NTMStrCpy(pPitchType, CCHOF(pPitchType), &pDatFile[i]);
                    i += strlen(pPitchType);
                }
                else
                {
                    //
                    // Get Win family type name (e.g. Swiss, Roman, etc.). Store
                    // appropriate family type value in the FAMILYINFO.
                    //
                    AFM2NTMStrCpy(pFamilyType, CCHOF(pFamilyType), &pDatFile[i]);
                    i += strlen(pFamilyType);
                }

                //
                // Search for family type in table. Default is FF_DONTCARE.
                //
                pPsFontFamMap[cFams].FamilyKey.usValue = FF_DONTCARE;
                for (j = 0; j < FamilyKeyTbl.usNumEntries; j++)
                {
                    if (!strcmp(pFamilyType, ((PKEY) (FamilyKeyTbl.pTbl))[j].pName))
                    {
                        pPsFontFamMap[cFams].FamilyKey.usValue = ((PKEY) (FamilyKeyTbl.pTbl))[j].usValue;
                        break;
                    }
                }

                //
                // Search for family type in table. Default is FF_DONTCARE.
                //
                pPsFontFamMap[cFams].usPitch = DEFAULT_PITCH;
                if (cFamilyTypeSize)
                {
                    for (j = 0; j < PitchKeyTbl.usNumEntries; j++)
                    {
                        if (!strcmp(pPitchType, ((PKEY) (PitchKeyTbl.pTbl))[j].pName))
                        {
                            pPsFontFamMap[cFams].usPitch = ((PKEY) (PitchKeyTbl.pTbl))[j].usValue;
                            break;
                        }
                    }
                }

                cFams++;
            }
    } while (i < ulFileSize);

    (*pPsFamilyTbl)->usNumEntries = cFams;

    //
    // Sort FAMILYINFO table in font name order.
    //
    qsort(&(pPsFontFamMap[0].pFontName), (size_t) cFams,
        (size_t) sizeof(PSFAMILYINFO), strcmp);

    return(cFams);
}

ULONG
BuildPSCharMetrics(
    PBYTE           pAFM,
    PULONG          pUniPs,
    PPSCHARMETRICS  pFontChars,
    PBYTE           pCharDefTbl,
    ULONG           cGlyphSetChars
)
/*++

Routine Description:

    Builds a array of bit flags used to determine if a particular char is
    defined for a given font.

Arguments:

    pAFM - Ptr to memory mapped file image of .AFM file.

    pUniPs - Points to a table which maps 0-based Glyph Indices of chars
    in the GLYPHRUNS of the GLYPHSETDATA struct for this font to indices
    into the UnicodetoPs structure which maps Unicode points to PS char
    information. This mapping array is created by the CreateGlyphSet function
    defined in this module.

    pFontChars - Ptr to memory to contains an array of PSCHARMETRICS structs,
    which contains PS char name, and char width info for each char defined
    in the font's AFM. The amount of memory required in bytes is
    sizeof(PSCHARMETRICS) * num of chars in the font.

    pCharDefTbl - Ptr to memory of size ((cGlyphSetChars + 7) /8)) bytes,
    will contain bit flags indicating if a char is supported in the given font.

    cGlyphSetChars - Number of chars in the GLYPHSET for this font. This
    most likely is NOT the same as the number of chars defined in the
    font's AFM.

Return Value:

    TRUE => success
    FALSE => error

--*/
{
    ULONG i, j;
    PBYTE   pChMet, pToken;
    USHORT  chCnt;
    ULONG curCharWidth;
    PBYTE   pCharNameTok;
    BOOLEAN bIsPiFont, bIsCJKFont;
    BYTE    CharNameBuffer[32];
    PBYTE   pChName;

    //
    // Is this is a symbol font, the char "names" will actually be the
    // default char codes in the AFM.
    //
    if (bIsPiFont = IsPiFont(pAFM))
    {
        pCharNameTok = PS_CH_CODE_TOK;
    }
    else
    {
        pCharNameTok = PS_CH_NAME_TOK;
    }
    bIsCJKFont = (IsCJKFont(pAFM) != 0);

    //
    // Check validity of output pointers.
    //
    if (pFontChars == NULL || pCharDefTbl == NULL)
    {
        return(FALSE);
    }

    //
    // Get ptr to AFM char metrics.
    //
    pChMet = FindAFMToken(pAFM, PS_CH_METRICS_TOK);
    if (pChMet == NULL)    // Fixed bug 354007
        return (FALSE);

    //
    // Current pos should be the character count field.
    //
    for (i = 0; i < (int) StrLen(pChMet); i++)
    {
        if (!IS_NUM(&pChMet[i]))
        {
            return(FALSE);
        }
    }
    chCnt = (USHORT)atoi(pChMet);
    (ULONG_PTR) pChMet += i;

    //
    // Make a pass through the AFM Char Metrics, creating an array of
    // PSCHARMETRICS structs.
    //
    i = 0;

    do
    {
        PARSE_TOKEN(pChMet, pToken);

        if (!StrCmp(pToken, PS_CH_WIDTH_TOK) ||
            !StrCmp(pToken, PS_CH_WIDTH0_TOK))
        {
            pFontChars[i].chWidth = atoi(pChMet);
        }

        if (!StrCmp(pToken, pCharNameTok))
        {
            AFM2NTMStrCpy(pFontChars[i].pPsName, CCHOF(pFontChars[i].pPsName), pChMet);
        }
        if (!StrCmp(pToken, PS_CH_BBOX_TOK))
        {
            //
            // Save char bounding box.
            //
            PARSE_RECT(pChMet, pFontChars[i].rcChBBox);
            i++;
        }
        else if (!StrCmp(pToken, PS_EOF_TOK))
        {
            break;
        }
        NEXT_TOKEN(pChMet);

    } while (i < chCnt);

    //
    // Sort the list of PSCHARMETRICSs in PS Name sequence. If this is
    // a Pi font, chars are already sorted in CC order.
    //
    if (!bIsPiFont)
    {
        qsort(pFontChars, (size_t) chCnt, (size_t) sizeof(PSCHARMETRICS),
            CmpPsChars);
    }

    //
    // Build array of bit flags which indicate whether each char in the
    // GLYPHSETDATA is actually defined in the AFM.
    //
    for (i = 0; i < ((cGlyphSetChars + 7) / 8); i++)
    {
        pCharDefTbl[i] = 0;
    }

    for (i = 0; i < cGlyphSetChars; i++)
    {
        if (bIsPiFont)
        {
            //
            // Make the first char (0x1f:'.notdef1f') undefined.
            //
            if (i == 0)
                continue;

            //
            // Char is defined unless there are < 256 chars in the font.
            //
            if (i < chCnt)
                DEFINE_CHAR(i, pCharDefTbl);
            else
                break;
        }
        else
        {
            //
            // Setup ptr to "char name" based on whether this is a
            // western or CJK font.
            //
            if (bIsCJKFont)
            {
                // Make CID 0 undefined glyph.
                if (pUniPs[i] == 0)
                    continue;

                _ultoa(pUniPs[i], CharNameBuffer, 10);
                pChName = CharNameBuffer;
            }
            else
            {
                pChName = UnicodetoPs[pUniPs[i]].pPsName;
            }

            if (((PPSCHARMETRICS) bsearch(pChName,
                                            pFontChars,
                                            (size_t) chCnt,
                                            sizeof(PSCHARMETRICS),
                                            CmpPsChars)) != NULL)
            {
                //
                // Char is defined in this font.
                //
                DEFINE_CHAR(i, pCharDefTbl);
            }
        }
    }
    return(TRUE);
}

ULONG
cjGetFamilyAliases(
    IFIMETRICS *pifi,
    PSTR        pstr,
    UINT        cp
    )

/*++

Routine Description:

    Fill in the family name of the IFIMETRICS structure.

Arguments:

    pifi - Ptr to IFIMETRICS. If NULL, return size of family alias strings
           only.
    pstr - Ptr to null terminated Font Menu Name string.
    cp   - Codepage value.

Return Value:

    ?

--*/

{
    PSTR       *pTable;
    PWSTR       pwstr;
    DWORD       cWchars, cw;
    ULONG       ulLength;

    // assume no alias table found.

    pTable = (PSTR *)(NULL);

    // This is a hardcoded Win31 Hack that we need to be compatible
    // with since some apps have hardcoded font names.

    if (!(strcmp(pstr, "Times")))
        pTable = TimesAlias;

    else if (!(strcmp(pstr, "Helvetica")))
        pTable = HelveticaAlias;

#if 0
// Disabled due to bug #259664 fix
    else if (!(strcmp(pstr, "Courier")))
        pTable = CourierAlias;
#endif

    else if (!(strcmp(pstr, "Helvetica Narrow")))
        pTable = HelveticaNarrowAlias;

    else if (!(strcmp(pstr, "Palatino")))
        pTable = PalatinoAlias;

    else if (!(strcmp(pstr, "Bookman")))
        pTable = BookmanAlias;

    else if (!(strcmp(pstr, "NewCenturySchlbk")))
        pTable = NewCenturySBAlias;

    else if (!(strcmp(pstr, "AvantGarde")))
        pTable = AvantGardeAlias;

    else if (!(strcmp(pstr, "ZapfChancery")))
        pTable = ZapfChanceryAlias;

    else if (!(strcmp(pstr, "ZapfDingbats")))
        pTable = ZapfDingbatsAlias;


    //
    // If font name does not match any of the family alias names,
    // use font name itself as IFIMETRICS family name.
    //
    if (pTable == NULL)
    {
        ulLength = strlen(pstr);
        cWchars = MultiByteToWideChar(cp, 0, pstr, ulLength, 0, 0);
        if (pifi != NULL)
        {
            pwstr = (PWSTR)MK_PTR(pifi, dpwszFamilyName);
            MultiByteToWideChar(cp, 0, pstr, ulLength, pwstr, cWchars);
            pwstr[cWchars]= (WCHAR)'\0';
        }
        return((cWchars + 1) * sizeof (WCHAR));
    }

    //
    // A family alias name match was found.
    //
    if (pifi != NULL)
    {
        //
        // This call is a request to actually copy the string table.
        //
        pwstr = (PWSTR)MK_PTR(pifi, dpwszFamilyName);
        pifi->flInfo |= FM_INFO_FAMILY_EQUIV;
    }

    cWchars = 0;
    while (*pTable)
    {
        ulLength = strlen(*pTable);
        cw = MultiByteToWideChar(cp, 0, *pTable, ulLength, 0, 0);
        if (pifi != NULL)
        {
            MultiByteToWideChar(cp, 0, *pTable, ulLength, &pwstr[cWchars], cw);
            pwstr[cWchars + cw] = (WCHAR)'\0';
        }
        cWchars += cw + 1;
        pTable++;
    }
    if (pifi != NULL)
    {
        //
        // Add terminator to end of string array.
        //
        pwstr[cWchars] = (WCHAR)'\0';
    }
    return((cWchars + 1) * sizeof(WCHAR));
}

PBYTE
FindStringToken(
    PBYTE   pPSFile,
    PBYTE   pToken
    )
/*++

Routine Description:

    Find the first occurrence of pToken occurring in the stream pPSFile.
    pToken is terminated by the first occurrence of a space or NULL char.

Arguments:

    pPSFile - Ptr to memory mapped file stream to search.
    pToken - Ptr to string token to search for.

Return Value:

    !=NULL => ptr to first occurence of pToken
    ==NULL => token not found

--*/
{
    while (TRUE)
    {
        while (IS_WHTSPACE(pPSFile) && !EOL(pPSFile))
        {
            pPSFile++;
        }
        if (!StrCmp(pPSFile, DSC_EOF_TOK))
        {
            break;
        }
        else if (!StrCmp(pPSFile, pToken))
        {
            return(pPSFile);
        }
        else
        {
            pPSFile += StrLen(pPSFile) + 1;
        }
    }
    return(FALSE);
}

BOOLEAN
AsciiToHex(
    PBYTE   pStr,
    PUSHORT pNum
    )
/*++

Routine Description:

    Treat the the space or null terminated input string as a series of hex
    digits convert it to a USHORT.

Arguments:

    pStr - Ptr to string to convert.
    pNum - Ptr to variable which returns numeric value.

Return Value:

    TRUE => String converted
    FALSE => String could not be converted
--*/
{
    USHORT  usHexNum, ulDigit;
    CHAR    curChar;

    usHexNum = 0;
    while (!EOL(pStr) && !IS_HEX_DIGIT(pStr))
    {
        pStr++;
    }

    for( ; IS_HEX_DIGIT(pStr); pStr++);

    ulDigit = 1;
    for (pStr--; IS_HEX_DIGIT(pStr) && !EOL(pStr) && ulDigit; pStr--)
    {
        if (IS_NUM(pStr))
        {
            usHexNum += (*pStr - '0') * ulDigit;
        }
        else
        {
            curChar = (CHAR)toupper(*pStr);
            usHexNum += ((curChar - 'A') + 10) * ulDigit;
        }
        ulDigit <<= 4;
    }
    if (usHexNum)
    {
        *pNum = usHexNum;
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

BOOLEAN
IsPiFont(
    PBYTE   pAFM
    )
/*++

Routine Description:

    Determine if the font represented by the passed AFM is a font which
    uses the Symbol charset.

Arguments:

    pAFM - Ptr to AFM.

Return Value:

    TRUE => Font is PI font, uses "Symbol" Glyphset
    FALSE => Font not PI font
--*/
{
    // This routine used to do a lot more. Should change
    // to a macro later.
    return((BOOLEAN)isSymbolCharSet);
}

BOOLEAN
IsCJKFixedPitchEncoding(
    PGLYPHSETDATA pGlyphSetData
    )
/*++

Routine Description:

    Determine if the encoding is the one for fixed pitch font.

Arguments:

    pGlyphSetData - Ptr to GLYPHSETDATA

Return Value:

    TRUE => Fixed pitch font's encoding
    FALSE => Proportional font's encoding
--*/
{
    BOOLEAN bResult;
    char*   pszGlyphSetName;
    char**  pszPropCjkGsName;

    bResult = TRUE;

    pszGlyphSetName = (char*)MK_PTR(pGlyphSetData, dwGlyphSetNameOffset);

    for (pszPropCjkGsName = PropCjkGsNames; *pszPropCjkGsName; pszPropCjkGsName++)
    {
        if (!strcmp(pszGlyphSetName, *pszPropCjkGsName))
        {
            bResult = FALSE;
            break;
        }
    }

    return bResult;
}

PBYTE
FindUniqueID(
    PBYTE   pAFM
    )

/*++

Routine Description:

    Finds UniqueID token in a memory mapped AFM file stream.
    UniqueID is assumed on 'Comment UniqueID' line.

Arguments:

    pAFM - pointer to memory mapped AFM file.

Return Value:

    NULL => error
    otherwise => ptr to UniqueID value.

--*/

{
    PBYTE   pCurToken;

    while (TRUE)
    {
        PARSE_TOKEN(pAFM, pCurToken);
        if (!StrCmp(pCurToken, PS_COMMENT_TOK))
        {
            if (!StrCmp(pAFM, "UniqueID"))
            {
                pAFM += 8;
                while (IS_WHTSPACE(pAFM)) pAFM++;
                return pAFM;
            }
        }
        else if (!StrCmp(pCurToken, PS_EOF_TOK))
        {
            return NULL;
        }
        NEXT_LINE(pAFM);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\parsers\ppd\ppdparse.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdparse.h

Abstract:

    Declarations for PPD parser

Environment:

    PostScript driver, PPD parser

Revision History:

    08/20/96 -davidx-
        Common coding style for NT 5.0 drivers.

    03/26/96 -davidx-
        Created it.

--*/


#ifndef _PPDPARSE_H_
#define _PPDPARSE_H_

//
// PPD parser memory management functions
//
// NOTE: newly allocated memory is always zero initialized
// The parser allocates its working memory from the heap and
// everything is freed at the end when the heap is destroyed.
//

#define ALLOC_PARSER_MEM(pParserData, size) \
        ((PVOID) HeapAlloc((pParserData)->hHeap, HEAP_ZERO_MEMORY, (size)))

//
// Character constants
//

#define KEYWORD_CHAR    '*'
#define COMMENT_CHAR    '%'
#define SYMBOL_CHAR     '^'
#define SEPARATOR_CHAR  ':'
#define XLATION_CHAR    '/'
#define QUERY_CHAR      '?'
#define QUOTE_CHAR      '"'
#define TAB             '\t'
#define SPACE           ' '
#define CR              '\r'
#define LF              '\n'
#define IS_SPACE(c)     ((c) == SPACE || (c) == TAB)
#define IS_NEWLINE(c)   ((c) == CR || (c) == LF)

//
// Masks to indicate which characters can appear in what fields
//

#define KEYWORD_MASK        0x01
#define XLATION_MASK        0x02
#define QUOTED_MASK         0x04
#define STRING_MASK         0x08
#define DIGIT_MASK          0x10
#define HEX_DIGIT_MASK      0x20

extern const BYTE gubCharMasks[256];

#define IS_VALID_CHAR(ch)        (gubCharMasks[(BYTE) (ch)] != 0)
#define IS_MASKED_CHAR(ch, mask) (gubCharMasks[(BYTE) (ch)] & (mask))
#define IS_DIGIT(ch)             (gubCharMasks[(BYTE) (ch)] & DIGIT_MASK)
#define IS_HEX_DIGIT(ch)         (gubCharMasks[(BYTE) (ch)] & (DIGIT_MASK|HEX_DIGIT_MASK))
#define IS_KEYWORD_CHAR(ch)      ((ch) == KEYWORD_CHAR)

//
// Tags to identify various data types
//

#define VALUETYPE_NONE      0x01
#define VALUETYPE_STRING    0x02
#define VALUETYPE_QUOTED    0x04
#define VALUETYPE_SYMBOL    0x08

#define VALUETYPE_MASK      0xff

//
// Error code constants
//

#define PPDERR_NONE         0
#define PPDERR_MEMORY       (-1)
#define PPDERR_FILE         (-2)
#define PPDERR_SYNTAX       (-3)
#define PPDERR_EOF          (-4)

typedef INT PPDERROR;

//
// Special length value to indicate that an invocation string is defined by a symbol.
// Normal invocation strings must be shorter than this length.
//

#define SYMBOL_INVOCATION_LENGTH    0x80000000

#define MARK_SYMBOL_INVOC(pInvoc)  ((pInvoc)->dwLength |= SYMBOL_INVOCATION_LENGTH)
#define CLEAR_SYMBOL_INVOC(pInvoc) ((pInvoc)->dwLength &= ~SYMBOL_INVOCATION_LENGTH)
#define IS_SYMBOL_INVOC(pInvoc)    ((pInvoc)->dwLength & SYMBOL_INVOCATION_LENGTH)

typedef struct _INVOCOBJ {

    DWORD   dwLength;   // length of invocation string
    PVOID   pvData;     // points to invocation string data

} INVOCOBJ, *PINVOCOBJ;

//
// Data structure for representing a data buffer
//

typedef struct _BUFOBJ {

    DWORD       dwMaxLen;
    DWORD       dwSize;
    PBYTE       pbuf;

} BUFOBJ, *PBUFOBJ;

//
// Always reserve one byte in a buffer so that we can append a zero byte at the end.
//

#define IS_BUFFER_FULL(pbo)        ((pbo)->dwSize + 1 >= (pbo)->dwMaxLen)
#define IS_BUFFER_EMPTY(pbo)       ((pbo)->dwSize == 0)
#define CLEAR_BUFFER(pbo)          { (pbo)->dwSize = 0; (pbo)->pbuf[0] = 0; }
#define ADD_CHAR_TO_BUFFER(pbo, c) (pbo)->pbuf[(pbo)->dwSize++] = (BYTE)(c)
#define SET_BUFFER(pbo, buf)       \
        { (pbo)->pbuf = (PBYTE) (buf); (pbo)->dwMaxLen = sizeof(buf); (pbo)->dwSize = 0; }

//
// Maximum length for keyword, option, and translation strings.
// NOTE: we are being very lenient here because these limits are arbitrary and
// there is nothing that prevents us from handling longer lengths.
//

#define MAX_KEYWORD_LEN     64
#define MAX_OPTION_LEN      64
#define MAX_XLATION_LEN     256

//
// Constants to indicate whether an input slot requires PageRegion invocation
//

#define REQRGN_UNKNOWN      0
#define REQRGN_TRUE         1
#define REQRGN_FALSE        2

//
// Data structure for representing a mapped file object
//

typedef struct _FILEOBJ {

    HFILEMAP    hFileMap;
    PBYTE       pubStart;
    PBYTE       pubEnd;
    PBYTE       pubNext;
    DWORD       dwFileSize;
    PTSTR       ptstrFileName;
    INT         iLineNumber;
    BOOL        bNewLine;

} FILEOBJ, *PFILEOBJ;

#define END_OF_FILE(pFile) ((pFile)->pubNext >= (pFile)->pubEnd)
#define END_OF_LINE(pFile) ((pFile)->bNewLine)

//
// Data structure for representing a singly-linked list
//

typedef struct _LISTOBJ {

    PVOID       pNext;          // pointer to next node
    PSTR        pstrName;       // item name

} LISTOBJ, *PLISTOBJ;

//
// Data structure for representing symbol information
//

typedef struct _SYMBOLOBJ {

    PVOID       pNext;          // pointer to the next symbol
    PSTR        pstrName;       // symbol name
    INVOCOBJ    Invocation;     // symbol data

} SYMBOLOBJ, *PSYMBOLOBJ;

//
// Data structure for representing job patch file information
//

typedef struct _PATCHFILEOBJ {

    PVOID       pNext;          // pointer to the next patch
    PSTR        pstrName;       // string of the patch number
    LONG        lPatchNo;       // number of the patch as set in the PPD file
    INVOCOBJ    Invocation;     // symbol data

} JOBPATCHFILEOBJ, *PJOBPATCHFILEOBJ;

//
// Data structure for representing a default font substitution entry
//

typedef struct _TTFONTSUB {

    PVOID       pNext;          // pointer to the next entry
    PSTR        pstrName;       // TT font family name
    INVOCOBJ    Translation;    // TT font family name translation
    INVOCOBJ    PSName;         // PS font family name

} TTFONTSUB, *PTTFONTSUB;

//
// Data structure for representing printer feature option information
//
//  Need to change translation string field to make it ready for Unicode encoding.
//

typedef struct _OPTIONOBJ {

    PVOID       pNext;          // pointer to the next option
    PSTR        pstrName;       // option name
    INVOCOBJ    Translation;    // translation string
    INVOCOBJ    Invocation;     // invocation string
    DWORD       dwConstraint;   // list of UIConstraints associated with this option

} OPTIONOBJ, *POPTIONOBJ;

//
// Data structure for representing paper size information
//

typedef struct _PAPEROBJ {

    OPTIONOBJ   Option;         // generic option information
    SIZE        szDimension;    // paper dimension
    RECT        rcImageArea;    // imageable area

} PAPEROBJ, *PPAPEROBJ;

//
// Default paper size when the information in the PPD file is invalid
//

#define DEFAULT_PAPER_WIDTH     215900  // 8.5 inch measured in microns
#define DEFAULT_PAPER_LENGTH    279400  // 11 inch measured in microns

//
// paper size values for Letter and A4
//

#define LETTER_PAPER_WIDTH      215900  // 8.5 inch measured in microns
#define LETTER_PAPER_LENGTH     279400  // 11 inch measured in microns

#define A4_PAPER_WIDTH          210058  // 8.27 inch measured in microns
#define A4_PAPER_LENGTH         296926  // 11.69 inch measured in microns

//
// Data structure for representing input slot information
//

typedef struct _TRAYOBJ {

    OPTIONOBJ   Option;         // generic option information
    DWORD       dwReqPageRgn;   // whether PageRegion invocation is required
    DWORD       dwTrayIndex;    // index used for DEVMODE.dmDefaultSource field

} TRAYOBJ, *PTRAYOBJ;

//
// Data structure for representing output bin information
//

typedef struct _BINOBJ {

    OPTIONOBJ   Option;         // generic option information
    BOOL        bReversePrint;  // first page comes out at bottom?

} BINOBJ, *PBINOBJ;

//
// Data structure for representing memory configuration information
//

typedef struct _MEMOBJ {

    OPTIONOBJ   Option;         // generic option information
    DWORD       dwFreeVM;       // amount of free VM
    DWORD       dwFontMem;      // size of font cache memory

} MEMOBJ, *PMEMOBJ;

//
// Data structure for representing memory configuration information
//

typedef struct _RESOBJ {

    OPTIONOBJ   Option;         // generic option information
    FIX_24_8    fxScreenAngle;  // suggested screen angle
    FIX_24_8    fxScreenFreq;   // suggested screen frequency

} RESOBJ, *PRESOBJ;

//
// Data structure for representing printer feature information
//

typedef struct _FEATUREOBJ {

    PVOID       pNext;              // pointer to next printer feature
    PSTR        pstrName;           // feature name
    INVOCOBJ    Translation;        // translation string
    PSTR        pstrDefault;        // default option name
    DWORD       dwFeatureID;        // predefined feature identifier
    BOOL        bInstallable;       // whether the feature is an installble option
    DWORD       dwUIType;           // type of feature option list
    INVOCOBJ    QueryInvoc;         // query invocation string
    DWORD       dwConstraint;       // list of UIConstraints associated with this feature
    DWORD       dwOptionSize;       // size of each option item
    POPTIONOBJ  pOptions;           // pointer to list of options

} FEATUREOBJ, *PFEATUREOBJ;

//
// Data structure for representing device font information
//
// NOTE: The first three fields of this structure must match the
// first three fields of OPTIONOBJ structure.
//

typedef struct {

    PVOID       pNext;              // pointer to next device font
    PSTR        pstrName;           // font name
    INVOCOBJ    Translation;        // translation string
    PSTR        pstrEncoding;       // font encoding information
    PSTR        pstrCharset;        // charsets supported
    PSTR        pstrVersion;        // version string
    DWORD       dwStatus;           // status

} FONTREC, *PFONTREC;

//
// Data structure for maintain information used by the parser
//

typedef struct _PARSERDATA {

    PVOID       pvStartSig;         // signature used for debugging
    HANDLE      hHeap;              // memory heap used by the parser
    PFILEOBJ    pFile;              // pointer to current file object
    PDWORD      pdwKeywordHashs;    // precomputed hash values for built-in keywords
    PBYTE       pubKeywordCounts;   // count the occurrence of built-in keywords
    BOOL        bErrorFlag;         // semantic error flag
    INT         iIncludeLevel;      // current include level
    PFEATUREOBJ pOpenFeature;       // pointer to the open feature
    BOOL        bJclFeature;        // whether we're inside JCLOpenUI/JCLCloseUI
    BOOL        bInstallableGroup;  // whether we're inside InstallableOptions group
    PLISTOBJ    pPpdFileNames;      // list of source PPD filenames

    INVOCOBJ    NickName;           // printer model name
    DWORD       dwChecksum32;       // 32-bit CRC checksum of ASCII text PPD file
    DWORD       dwPpdFilever;       // PPD file version
    DWORD       dwSpecVersion;      // PPD spec version number
    DWORD       dwPSVersion;        // PostScript interpreter version number
    INVOCOBJ    PSVersion;          // PSVersion string
    INVOCOBJ    Product;            // Product string

    PFEATUREOBJ pFeatures;          // List of printer features
    PLISTOBJ    pUIConstraints;     // List of UIConstraints
    PLISTOBJ    pOrderDep;          // List of OrderDependency
    PLISTOBJ    pQueryOrderDep;     // List of QueryOrderPendency
    PFONTREC    pFonts;             // List of device fonts
    PJOBPATCHFILEOBJ  pJobPatchFiles;     // List of JobPatchFile invocation strings
    PSYMBOLOBJ  pSymbols;           // List of symbol definitions
    PTTFONTSUB  pTTFontSubs;        // List of TT font substitution entries

    INVOCOBJ    Password;           // password invocation string
    INVOCOBJ    ExitServer;         // exitserver invocation string
    INVOCOBJ    PatchFile;          // PatchFile invocation string
    INVOCOBJ    JclBegin;           // PJL job start invocation string
    INVOCOBJ    JclEnterPS;         // PJL enter PS  invocation string
    INVOCOBJ    JclEnd;             // PJL job end invocation string
    INVOCOBJ    ManualFeedFalse;    // ManualFeed False invocation string

    DWORD       dwLangEncoding;     // language encoding
    UINT        uCodePage;          // code page corresponding to language encoding
    DWORD       dwLangLevel;        // PostScript language level
    DWORD       dwFreeMem;          // default amount of free VM
    DWORD       dwThroughput;       // throughput
    DWORD       dwJobTimeout;       // suggested job timeout value
    DWORD       dwWaitTimeout;      // suggested wait timeout value
    DWORD       dwColorDevice;      // whether the device supports color
    DWORD       dwProtocols;        // protocols supported by the device
    DWORD       dwTTRasterizer;     // TrueType rasterizer option
    DWORD       dwLSOrientation;    // default landscape orientation
    FIX_24_8    fxScreenFreq;       // default halftone screen frequency
    FIX_24_8    fxScreenAngle;      // default halftone screen angle

    BOOL        bDefReversePrint;   // DefaultOutputOrder
    BOOL        bDefOutputOrderSet; // TRUE if bDefReversePrint is set through PPD
    DWORD       dwExtensions;       // language extensions
    DWORD       dwSetResType;       // how to set resolution
    DWORD       dwReqPageRgn;       // RequiresPageRegion All: information
    DWORD       dwPpdFlags;         // misc. PPD flags
    PSTR        pstrDefaultFont;    // DefaultFont: information

    DWORD       dwCustomSizeFlags;  // custom page size flags and parameters
    CUSTOMSIZEPARAM CustomSizeParams[CUSTOMPARAM_MAX];

    BOOL        bEuroInformationSet;// the Euro keyword was found in the PPD
    BOOL        bHasEuro;           // printer device fonts have the Euro

    BOOL        bTrueGray;          // TrueGray shall be detected by default

    //
    // Use for mapping NT4 feature indices to NT5 feature indices
    //

    WORD        wNt4Checksum;
    INT         iManualFeedIndex;
    INT         iDefInstallMemIndex;
    INT         iReqPageRgnIndex;
    BYTE        aubOpenUIFeature[MAX_GID];

    //
    // Buffers used to hold the content of various fields in the current entry
    //

    BUFOBJ      Keyword;
    BUFOBJ      Option;
    BUFOBJ      Xlation;
    BUFOBJ      Value;
    DWORD       dwValueType;

    CHAR        achKeyword[MAX_KEYWORD_LEN];
    CHAR        achOption[MAX_OPTION_LEN];
    CHAR        achXlation[MAX_XLATION_LEN];
    PSTR        pstrValue;

    //
    // These are used for compacting parsed PPD information into
    // binary printer description data.
    //

    PBYTE       pubBufStart;
    DWORD       dwPageSize;
    DWORD       dwCommitSize;
    DWORD       dwBufSize;
    PINFOHEADER pInfoHdr;
    PUIINFO     pUIInfo;
    PPPDDATA    pPpdData;

    PVOID       pvEndSig;           // signature used for debugging

} PARSERDATA, *PPARSERDATA;

//
// Simple integrity check on the parser data structure
//

#define VALIDATE_PARSER_DATA(pParserData) \
        ASSERT((pParserData) != NULL && \
               (pParserData)->pvStartSig == pParserData && \
               (pParserData)->pvEndSig == pParserData)

//
// Parse a PPD file
//

PPDERROR
IParseFile(
    PPARSERDATA pParserData,
    PTSTR       ptstrFilename
    );

//
// Grow a buffer object when it becomes full
//

PPDERROR
IGrowValueBuffer(
    PBUFOBJ pBufObj
    );

//
// Parse one entry from a PPD file
//

PPDERROR
IParseEntry(
    PPARSERDATA pParserData
    );

//
// Interpret an entry parsed from a PPD file
//

PPDERROR
IInterpretEntry(
    PPARSERDATA pParserData
    );

//
// Build up data structures to speed up keyword lookup
//

BOOL
BInitKeywordLookup(
    PPARSERDATA pParserData
    );

//
// Find a named item from a linked-list
//

PVOID
PvFindListItem(
    PVOID   pvList,
    PCSTR   pstrName,
    PDWORD  pdwIndex
    );

//
// Convert embedded hexdecimal strings into binary data
//

BOOL
BConvertHexString(
    PBUFOBJ pBufObj
    );

//
// Search for a keyword from a string table
//

typedef struct _STRTABLE {

    PCSTR   pstrKeyword;    // keyword name
    DWORD   dwValue;        // corresponding value

} STRTABLE;

typedef const STRTABLE *PCSTRTABLE;

BOOL
BSearchStrTable(
    PCSTRTABLE  pTable,
    PSTR        pstrKeyword,
    DWORD      *pdwValue
    );

//
// Parse an unsigned floating-point number from a character string
//

BOOL
BGetFloatFromString(
    PSTR   *ppstr,
    PLONG   plValue,
    INT     iType
    );

#define FLTYPE_ERROR            (-1)
#define FLTYPE_POINT            0
#define FLTYPE_INT              1
#define FLTYPE_FIX              2
#define FLTYPE_POINT_ROUNDUP    3
#define FLTYPE_POINT_ROUNDDOWN  4

//
// Parse an unsigned decimal integer value from a character string
//

BOOL
BGetIntegerFromString(
    PSTR   *ppstr,
    LONG   *plValue
    );

//
// Strip off the keyword prefix character from the input string
//

PCSTR
PstrStripKeywordChar(
    PCSTR   pstrKeyword
    );

//
// Find the next word in a character string (Words are separated by spaces)
//

BOOL
BFindNextWord(
    PSTR   *ppstr,
    PSTR    pstrWord
    );

#define MAX_WORD_LEN    MAX_KEYWORD_LEN

//
// Create an input file object
//

PFILEOBJ
PCreateFileObj(
    PTSTR       ptstrFilename
    );

//
// Delete an input file object
//

VOID
VDeleteFileObj(
    PFILEOBJ    pFile
    );

//
// Read the next character from the input file
// Special character to indicate end-of-file condition
//

INT
IGetNextChar(
    PFILEOBJ    pFile
    );

#define EOF_CHAR    (-1)

//
// Return the last character read to the input file
//

VOID
VUngetChar(
    PFILEOBJ    pFile
    );

//
// Skip all characters until the next non-space character
//

VOID
VSkipSpace(
    PFILEOBJ    pFile
    );

//
// Skip the remaining characters on the current input line
//

VOID
VSkipLine(
    PFILEOBJ    pFile
    );

//
// Check if a character string only consists of printable 7-bit ASCII characters
//

BOOL
BIs7BitAscii(
    PSTR        pstr
    );

//
// Display a syntax error message
//

PPDERROR
ISyntaxErrorMessage(
    PFILEOBJ    pFile,
    PSTR        pstrMsg
    );

#if DBG
#define ISyntaxError(pFile, errmsg) ISyntaxErrorMessage(pFile, errmsg)
#else
#define ISyntaxError(pFile, errmsg) ISyntaxErrorMessage(pFile, NULL)
#endif

//
// Keyword string for various predefined features
//

extern const CHAR gstrDefault[];
extern const CHAR gstrPageSizeKwd[];
extern const CHAR gstrInputSlotKwd[];
extern const CHAR gstrManualFeedKwd[];
extern const CHAR gstrCustomSizeKwd[];
extern const CHAR gstrLetterSizeKwd[];
extern const CHAR gstrA4SizeKwd[];
extern const CHAR gstrLongKwd[];
extern const CHAR gstrShortKwd[];
extern const CHAR gstrTrueKwd[];
extern const CHAR gstrFalseKwd[];
extern const CHAR gstrOnKwd[];
extern const CHAR gstrOffKwd[];
extern const CHAR gstrNoneKwd[];
extern const CHAR gstrVMOptionKwd[];
extern const CHAR gstrInstallMemKwd[];
extern const CHAR gstrDuplexTumble[];
extern const CHAR gstrDuplexNoTumble[];

#endif  // !_PPDPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\makentf\cjkfonts.h ===
/*+

Copyright (c) 1996 Adobe Systems Incorporated
Copyright (c) 1996  Microsoft Corporation

Module Name:

    cjkfonts.h

Abstract:

    Convert CJK AFMs to NTMs.

Environment:

    Windows NT PostScript driver: makentf utility.

Revision History:

    1/13/96 -rkiesler-
        Wrote it.
-*/

//
// Various #defines.
//
#define NUM_CJK_CHAR_ORDERINGS   4

//
// Some defines to make stuff read nice.
//
#define H_CMAP 0                // Horizontal variant CMAP info
#define V_CMAP 1                // Index of Vertical variant CMAP info
#define NUM_VARIANTS    V_CMAP + 1  // Total number of variants

//
// CMap specific tokens
//
#define CMAP_NAME_TOK "/CMapName"
#define CID_RANGE_TOK "begincidrange"
#define DSC_EOF_TOK "%%EOF"

//
// CJK specific data structures.
//
typedef struct _CMAPRANGE
{
    ULONG   CIDStrt;
    USHORT  ChCodeStrt;
    USHORT  cChars;
} CMAPRANGE, *PCMAPRANGE;

typedef struct _CMAP
{
    ULONG   cRuns;
    ULONG   cChars;
    CMAPRANGE   CMapRange[1];
} CMAP, *PCMAP;

//
// Macros for parsing a Postscript CMap.
//
#define GET_NUM_CID_RANGES(pToken, numRanges)                   \
while (!IS_WHTSPACE(pToken))                                    \
{                                                               \
    pToken--;                                                   \
}                                                               \
while (IS_WHTSPACE(pToken))                                     \
{                                                               \
    pToken--;                                                   \
}                                                               \
while (!IS_WHTSPACE(pToken))                                    \
{                                                               \
    pToken--;                                                   \
}                                                               \
pToken++;                                                       \
numRanges = atoi(pToken)

ULONG
CreateCJKGlyphSets(
    PBYTE           *pColCMaps,
    PBYTE           *pUniCMaps,
    PGLYPHSETDATA   *pGlyphSets,
    PWINCODEPAGE    pWinCodePage,
    PULONG          *pUniPsTbl
    );

BOOLEAN
NumUV2CIDRuns(
    PBYTE   pCMapFile,
    PULONG  pcRuns,
    PULONG  pcChars
    );

BOOLEAN
BuildUV2CIDMap(
    PBYTE   pCMapFile,
    PCMAP   pCMap
    );

BOOLEAN
NumUV2CCRuns(
    PBYTE   pFile,
    PULONG  pcRuns,
    PULONG  pcChars
    );

BOOLEAN
BuildUV2CCMap(
    PBYTE   pFile,
    PCMAP   pCMap
    );

int __cdecl
CmpCMapRunsCID(
    const VOID *p1,
    const VOID *p2
    );

int __cdecl
CmpCMapRunsChCode(
    const VOID *p1,
    const VOID *p2
    );

int __cdecl
FindCIDRun(
    const VOID *p1,
    const VOID *p2
    );

int __cdecl
FindChCodeRun(
    const VOID *p1,
    const VOID *p2
    );

CHSETSUPPORT
IsCJKFont(
    PBYTE   pAFM
    );

BOOLEAN
IsVGlyphSet(
    PGLYPHSETDATA   pGlyphSetData
    );

BOOLEAN
BIsCloneFont(
    PBYTE pAFM
    );

BOOLEAN
IsCIDFont(
    PBYTE pAFM
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\makentf\makentf.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    makentf.c

Abstract:

    Utility to convert AFM file(s) to NTF file.

Environment:

    Windows NT PostScript driver.

Revision History:

    02/16/98 -ksuzuki-
        Added OCF font support.

    09/08/97 -ksuzuki-
        Added code to look for PSFAMILY.DAT file from the directory where
        makentf is invoked.

    09/16/96 -PPeng-
        Add the fucntion to write PS Encoding vectors out - for debugging and
        create PS Encoding Arrays as PScript resource files.

    09/16/96 -slam-
        Created.

    mm/dd/yy -author-
        description

--*/

#include <windows.h>

#include "lib.h"
#include "ppd.h"
#include "pslib.h"
#include "afm2ntm.h"
#include "cjkfonts.h"
#include "writentf.h"

//
// Globals
//
HINSTANCE   ghInstance;
PUPSCODEPT  UnicodetoPs;
PTBL        pFamilyTbl;
PSTR        pAFMCharacterSetString;
PSTR        Adobe_Japan1_0 = "Adobe-Japan1-0\n";
DWORD           dwLastErr;
PSTR        pAFMFileName = NULL;
BOOL        bVerbose = FALSE;
BOOL        bOptimize = FALSE;

// Number of auxiliary character set. Its cheif
// purpose is to support 83pv.
#define NUM_AUX_CS 1

// This macro is used to see whether the argument
// matches the differential between CS_SHIFTJIS
// and CS_WEST_MAX.
#define IS_CS_SHIFTJIS(delta) \
    ((delta) == (CS_SHIFTJIS - CS_WEST_MAX))

//
// Prototype
//
BOOL
WritePSEncodings(
    IN  PWSTR           pwszFileName,
    IN  WINCPTOPS       *CPtoPSList,
    IN  DWORD           dwPages
    );
BOOL NeedBuildMoreNTM(
    PBYTE pAFM
    );


void __cdecl
main(
    int     argc,
    char    **argv
    )

/*++

Routine Description:

    Makentf takes four steps to create a .NTF file.

    Step 1: Initialization.

    Step 2: Convert AFM(s) to NTM(s).

    Step 3: Write GLYPHSETDATA(s) and NTM(s) to a .NTF file.

    Step 4: Clean up.

Arguments:

    argc - The path of and arguments given to this program.
    argv - The number of elements pointed to by argc.

Return Value:

    None.

--*/

{
    WCHAR           wstrNTFFile[MAX_PATH];
    WCHAR           wstrAFMFile[MAX_PATH];
    WCHAR           wstrDATFile[MAX_PATH];
    WCHAR           DatFilePath[MAX_PATH];
    PNTM            *aPNTM;
    PNTM            pNTM;
    PGLYPHSETDATA   *aGlyphSets;
    PWINCODEPAGE    *aWinCodePages;
    PWINCODEPAGE    pAllWinCodePages[CS_MAX];
    PUPSCODEPT      pFontChars;
    CHSETSUPPORT    flCsupFont, flCsupGlyphSet, flCsupMatch, flCsupAll;
    ULONG           cNumNTM, cSizeNTM, ulLength, nUnicodeChars;
    PULONG          *aUniPsTbl;
    LONG            lMatch, lMatchAll;
    PBYTE           pAFM;
    FLONG           flCurCset, flLastCset;
    ULONG           cNumGlyphSets, cSizeGlyphSets;
    DWORD           ulFileSize;
    PBYTE           pFamDatFile;
    PBYTE           pCMaps[CMAPS_PER_COL];
    HANDLE          hmodule, hModCMaps[CMAPS_PER_COL];
    USHORT          cNTMCurFont;
    INT             nArgcOffset;
    LONG            c;
    ULONG           i, j;
    BOOL            bIs90mspFont;
    BOOL            bIsKSCmsHWFont;

    //////////////////////////////////////////////////////////////////////////
    //
    // Step 1: Initialization.
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Check if there are enough parameters.
    //
    if (argc == 1)
    {
        printf("MakeNTF usage:\n");
        printf("1. MakeNTF [-v] [-o] <NTF> <AFMs>\n");
        printf("       Create an NTF file from AFM files.\n");
        printf("       -v: verbose  (print various info)\n");
        printf("       -o: optimize (write glyphset only referenced)\n");
        printf("\n");
        printf("2. MakeNTF <PSEncodingNameList>\n");
        printf("       Generate PS encoding name list.\n");
        return;
    }

    wstrNTFFile[0] = 0;

    if (argc == 2)
    {
        ulLength = strlen(argv[1]) + 1;
        MULTIBYTETOUNICODE(wstrNTFFile,
                            ulLength*sizeof(WCHAR),
                            NULL,
                            argv[1],
                            ulLength);
        WritePSEncodings(wstrNTFFile, &aPStoCP[0], CS_MAX);
        return;
    }
    else
    {
        nArgcOffset = 0;

        for (i = 1; i <= 2; i++)
        {
            if (!strcmp(argv[i], "-v"))
            {
                bVerbose = TRUE;
                nArgcOffset++;
            }
            if (!strcmp(argv[i], "-o"))
            {
                bOptimize = TRUE;
                nArgcOffset++;
            }
        }
    }

    if (bVerbose) printf("%%%%[Begin MakeNTF]%%%%\n\n");

    //
    // Initiliaze variables that relate to memory allocation.
    //
    aPNTM = NULL;
    aGlyphSets = NULL;
    pFamilyTbl = NULL;
    UnicodetoPs = NULL;
    aUniPsTbl = NULL;
    aWinCodePages = NULL;
    cNumNTM = cSizeNTM = 0;
    cNumGlyphSets = cSizeGlyphSets = 0;

    //
    // Initialize Glyphset counter, list of all possible Windows charsets.
    //
    for (i =0; i < CS_MAX; i++)
    {
        pAllWinCodePages[i] = &aStdCPList[i];
    }

    //
    // Create a copy of the Unicode->PS char mapping table and sort it
    // in Unicode point order.
    //
    if ((UnicodetoPs =
            (PUPSCODEPT) MemAllocZ((size_t) sizeof(UPSCODEPT) * NUM_PS_CHARS))
                == NULL)
    {
                dwLastErr = GetLastError();
        ERR(("makentf - main: malloc for UnicodetoPs (%ld)\n", dwLastErr));
        return;
    }
    memcpy(UnicodetoPs, PstoUnicode, (size_t) sizeof(UPSCODEPT) * NUM_PS_CHARS);
    qsort(UnicodetoPs,
            (size_t) NUM_PS_CHARS,
            (size_t) sizeof(UPSCODEPT),
            CmpUniCodePts);

    //
    // Build complete path name for PS family DAT file.
    //
    GetCurrentDirectory(MAX_PATH, DatFilePath);
    StringCchCatW(DatFilePath, CCHOF(DatFilePath), DatFileName);

    //
    // Open PS font family .DAT file and build the font family table.
    //
    if (!(hmodule = MapFileIntoMemory(DatFilePath, &pFamDatFile, &ulFileSize)))
    {
        //
        // One more try: look for it from the directory where makentf is
        // invoked (or from the root directory).
        //
        DECLSPEC_IMPORT LPWSTR* APIENTRY CommandLineToArgvW(LPCWSTR, int*);
        LPWSTR p, pLast, *pCmdLine;
        int nArgc;

        pCmdLine = CommandLineToArgvW(GetCommandLineW(), &nArgc);
        if (pCmdLine == NULL)
        {
                        dwLastErr = GetLastError();
            ERR(("makentf - main: CommandLineToArgvW (%ld)\n", dwLastErr));
            UnmapFileFromMemory(hmodule);
            goto CLEAN_UP;
        }
        StringCchCopyW(DatFilePath, CCHOF(DatFilePath), pCmdLine[0]);
        GlobalFree(pCmdLine);

        p = pLast = DatFilePath;
        while ((p = wcsstr(p, L"\\")) != NULL)
                {
                        pLast = p;
                        p += 2;
                }
        StringCchCopyW(pLast, CCHOF(DatFilePath) - (pLast - DatFilePath), DatFileName);
        hmodule = MapFileIntoMemory(DatFilePath, &pFamDatFile, &ulFileSize);
        if (!hmodule)
        {
                        dwLastErr = GetLastError();
            ERR(("makentf - main: can't open PSFAMILY.DAT file (%ld)\n", dwLastErr));
            UnmapFileFromMemory(hmodule);
            goto CLEAN_UP;
        }
    }
    BuildPSFamilyTable(pFamDatFile, &pFamilyTbl, ulFileSize);
    UnmapFileFromMemory(hmodule);

    //
    // Allocate memory to store NTM pointers.
    //
    // We quadruple the number of the arguments of this program to get the
    // number of NTM pointer. This is because
    //
    // 1) we need four NTM pointers maximum (two for H and V plus two for J
    //    90ms and 83pv) for a CJK AFM, but,
    // 2) we don't know at this time that how many of CJK AFMs we are going
    //    to process.
    //
    // Since we're only allocating pointers here it's usually OK to quadruple
    // the number of the arguments and use it as the number of NTM pointers
    // we need. (Don't forget to subtract two - one for the name of this
    // program and the other for the target NTM file name - from the number
    // of the arguments prior to quadruple.)
    //

    // Add 90msp-RKSJ support. we need 2 more NTFs - H and V for 90msp.
    // So I change the estimation number from 4 to 6.  Jack 3/15/2000
    // aPNTM = MemAllocZ(((argc - 2 - nArgcOffset) * 4) * sizeof(PNTM));

    aPNTM = MemAllocZ(((argc - 2 - nArgcOffset) * 6) * sizeof(PNTM));
    if (aPNTM == NULL)
    {
                dwLastErr = GetLastError();
        ERR(("makentf - main: malloc for aPNTM (%ld)\n", dwLastErr));
        goto CLEAN_UP;
    }

    //
    // Allocate memory to store pointers to Glyphset related data. We don't
    // know how many Glyphsets we will need - but we know it will be at most
    // equal to the number of character sets we support, although this will
    // probably never occur. Since we're only allocating ptrs here we'll go
    // ahead and alloc the max. Don't forget an extra entry for the Unicode
    // GLYPHSET data.
    //

    i = CS_WEST_MAX + (CS_MAX - CS_WEST_MAX + NUM_AUX_CS) * 2;

    if ((aGlyphSets = MemAllocZ(i * sizeof(PGLYPHSETDATA))) == NULL)
    {
                dwLastErr = GetLastError();
        ERR(("makentf - main: malloc for aGlyphSets (%ld)\n", dwLastErr));
        goto CLEAN_UP;
    }
    if ((aUniPsTbl = MemAllocZ(i * sizeof(PULONG))) == NULL)
    {
                dwLastErr = GetLastError();
        ERR(("makentf - main: malloc for aUniPsTbl (%ld)\n", dwLastErr));
        goto CLEAN_UP;
    }
    if ((aWinCodePages = MemAllocZ(i * sizeof(PWINCODEPAGE))) == NULL)
    {
                dwLastErr = GetLastError();
        ERR(("makentf - main: malloc for aWinCodePages (%ld)\n", dwLastErr));
        goto CLEAN_UP;
    }

    //
    // Precreate Western GLYPHSETs.
    // Note that this for loop assumes that the enum numbers from CS_228 to
    // CS_WEST_MAX are in ascending order incrementally.
    //
    if (bVerbose && !bOptimize) printf("%%%%[Begin Precreate Western Glyphsets]%%%%\n\n");

    for (i = CS_228; i < CS_WEST_MAX; i++, cNumGlyphSets++)
    {
        aWinCodePages[cNumGlyphSets] = &aStdCPList[i];
        CreateGlyphSets(&aGlyphSets[cNumGlyphSets],
                            aWinCodePages[cNumGlyphSets],
                            &aUniPsTbl[cNumGlyphSets]);
        cSizeGlyphSets += aGlyphSets[cNumGlyphSets]->dwSize;
    }

    if (bVerbose && !bOptimize) printf("%%%%[End Precreate Western Glyphsets]%%%%\n\n");


    //////////////////////////////////////////////////////////////////////////
    //
    // Step 2: Convert AFM(s) to NTM(s).
    //
    //////////////////////////////////////////////////////////////////////////

    if (bVerbose) printf("%%%%[Begin Covert AFM to NTM]%%%%\n\n");

    for (i = 2 + nArgcOffset; i < (ULONG)argc; i++)
    {
        //
        // Get AFM filename.
        //
        ulLength = strlen(argv[i]) + 1;
        MULTIBYTETOUNICODE(wstrAFMFile,
                            ulLength*sizeof(WCHAR),
                            NULL,
                            argv[i],
                            ulLength);

        //
        // Map AFM file into memory.
        //
        if (!(hmodule = MapFileIntoMemory(wstrAFMFile, &pAFM, NULL)))
        {
                        dwLastErr = GetLastError();
            ERR(("makentf - main: MapFileIntoMemory (%ld)\n", dwLastErr));
            goto CLEAN_UP;
        }

        pAFMFileName = argv[i];

        bIs90mspFont = FALSE;
        bIsKSCmsHWFont = FALSE;

        //
        // Initialization of pAFMCharacterSet must be done here
        // *before* CREATE_OCF_DATA_FROM_CID_DATA tag. The cheif
        // purpose of the initialization here is to support
        // OCF/83pv font.
        //
        pAFMCharacterSetString = FindAFMToken(pAFM, PS_CHARSET_TOK);
CREATE_OCF_DATA_FROM_CID_DATA:

        //
        // Determine which charsets this font supports. To find that,
        // we use the following variables.
        //
        // flCsupFont:      Combination of charset of the target font
        // flCsupGlyphSet:  Charset of the target font's glyphset
        // lMatch:          Index corresponding to CHSETSUPPORT, or -1
        // flCsupMatch:     Combination of charset of a closest font, or 0
        //
        flCsupFont = GetAFMCharSetSupport(pAFM, &flCsupGlyphSet);

CREATE_90MSP_RKSJ_NTM:
CREATE_KSCMS_HW_NTM:
        lMatch = -1;
        flCsupMatch = 0;
        if (flCsupGlyphSet == CS_NOCHARSET)
        {
            //
            // Determine if the current font matches any of the codepages
            // we have created so far.
            //
            lMatch = FindClosestCodePage(aWinCodePages,
                                              cNumGlyphSets,
                                              flCsupFont,
                                              &flCsupMatch);
        }
        else
        {
            if (flCsupGlyphSet == CS_228)
                lMatch = 0;
            else if (flCsupGlyphSet == CS_314)
                lMatch = 1;
            flCsupMatch = flCsupFont;
        }

        if ((flCsupGlyphSet == CS_NOCHARSET)
                &&
            ((lMatch == -1) || ((flCsupMatch & flCsupFont) != flCsupFont)))
        {
            //
            // Either:
            // We haven't created a charset which could be used to represent
            // this font so far.
            //      -or-
            // We know this font supports at least 1 of the charsets we have
            // created, but there might be a better match in the list of all
            // possible charsets.
            //
            lMatchAll = FindClosestCodePage(pAllWinCodePages,
                                                CS_MAX,
                                                flCsupFont,
                                                &flCsupAll);
            if ((flCsupAll == flCsupFont)
                || (flCsupAll & flCsupFont) > (flCsupMatch & flCsupFont))
            {
                //
                // Found a better match in a codepage which has not yet
                // been created.
                //
                lMatch = lMatchAll;

                //
                // Create a GLYPHSETDATA struct for this codepage and add
                // it to the list of those we've created so far.
                //
                aWinCodePages[cNumGlyphSets] = &aStdCPList[lMatch];

                //
                // Determine if this is a CJK font.
                //
                if (lMatch < CS_WEST_MAX)
                {
                    //
                    // Western font.
                    //
                    CreateGlyphSets(&aGlyphSets[cNumGlyphSets],
                                        aWinCodePages[cNumGlyphSets],
                                        &aUniPsTbl[cNumGlyphSets]);

                    cSizeGlyphSets += aGlyphSets[cNumGlyphSets]->dwSize;

                    //
                    // Glyphset for this font is the one we just created.
                    //
                    lMatch = cNumGlyphSets;
                    cNumGlyphSets += 1;
                }
                else
                {
                    //
                    // CJK font.
                    //
                    // Map the CMap files on memory first.
                    //
                    j = (ULONG)lMatch - CS_WEST_MAX;

                    for (c = 0; c < CMAPS_PER_COL; c++)
                    {
                        hModCMaps[c] = MapFileIntoMemory(CjkFnameTbl[j][c],
                                                            &pCMaps[c], NULL);
                        if (hModCMaps[c] == NULL)
                        {
                            while (--c >= 0)
                            {
                                UnmapFileFromMemory(hModCMaps[c]);
                            }
                                                        dwLastErr = GetLastError();
                            ERR(("makentf - main: MapFileIntoMemory (%ld)\n", dwLastErr));
                            goto CLEAN_UP;
                        }
                    }

                    //
                    // Since we're creating 2 GLYPHSETs (H and V variants)
                    // Create 2 codepage entries which point to the same
                    // Win codepage.
                    //
                    aWinCodePages[cNumGlyphSets + 1] = &aStdCPList[lMatch];

                    //
                    // Use the CMap files to create the new GLYPHSETs.
                    //
                    CreateCJKGlyphSets(&pCMaps[0],
                                        &pCMaps[2],
                                        &aGlyphSets[cNumGlyphSets],
                                        aWinCodePages[cNumGlyphSets],
                                        &aUniPsTbl[cNumGlyphSets]);

                    //
                    // Unmap the CMap files.
                    //
                    for (c = 0; c < CMAPS_PER_COL; c++)
                    {
                        UnmapFileFromMemory(hModCMaps[c]);
                    }

                    //
                    // We've created both an H and V GLYPHSET.
                    //
                    cSizeGlyphSets += aGlyphSets[cNumGlyphSets]->dwSize;
                    cSizeGlyphSets += aGlyphSets[cNumGlyphSets + 1]->dwSize;

                    //
                    // Glyphsets for this font are the ones we just created.
                    //
                    lMatch = cNumGlyphSets;
                    cNumGlyphSets += 2;
                }
            }
        }

        //
        // Determine number of NTMs to be created for this font.
        //
        cNTMCurFont =
            (aWinCodePages[lMatch]->pCsetList[0] < CS_WEST_MAX) ? 1 : 2;

        do
        {
            //
            // Generate NTM from AFM.
            //
            aPNTM[cNumNTM] = AFMToNTM(pAFM,
                                        aGlyphSets[lMatch],
                                        aUniPsTbl[lMatch],
                                        ((flCsupGlyphSet != CS_NOCHARSET) ? &flCsupFont : NULL),
                                        ((flCsupFont & CS_CJK) ? TRUE : FALSE),
                                        bIs90mspFont | bIsKSCmsHWFont);

            if (aPNTM[cNumNTM] != NULL)
            {
                //
                // Put the NTMs into a data array for WriteNTF.
                //
                cSizeNTM += NTM_GET_SIZE(aPNTM[cNumNTM]);
                cNumNTM++;
            }
            else
            {
                ERR(("makentf - main: AFMToNTM failed to create NTM:%s\n", argv[i]));
            }

            cNTMCurFont--;
            lMatch++;
        } while (cNTMCurFont);

        //
        // 90msp font support. jjia 3/16/2000
        //
        if (flCsupFont == CSUP(CS_SHIFTJIS))
        {
            if (NeedBuildMoreNTM(pAFM))
            {
                flCsupFont = CSUP(CS_SHIFTJISP);
                bIs90mspFont = TRUE;
                goto CREATE_90MSP_RKSJ_NTM; // here we go again!
            }
        }
        bIs90mspFont = FALSE;

        if (flCsupFont == CSUP(CS_HANGEUL))
        {
            if (NeedBuildMoreNTM(pAFM))
            {
                flCsupFont = CSUP(CS_HANGEULHW);
                bIsKSCmsHWFont = TRUE;
                goto CREATE_KSCMS_HW_NTM;   // here we go again!
            }
        }
        bIsKSCmsHWFont = FALSE;

        //
        // OCF/83pv font support. Create OCF glyphset and NTM data from
        // CID AFM file.
        //
        if ((flCsupFont == CSUP(CS_SHIFTJIS)) ||
            (flCsupFont == CSUP(CS_SHIFTJISP)))
        {
            pAFMCharacterSetString = Adobe_Japan1_0;
            goto CREATE_OCF_DATA_FROM_CID_DATA; // here we go again!
        }

        UnmapFileFromMemory(hmodule);
    }

    if (bVerbose) printf("%%%%[End Convert AFM to NTM]%%%%\n\n");

    //
    // Create Unicode GLYPHSET. This glyphset is created here since we don't
    // want any NTMs to reference this glyphset.
    //
    if (bVerbose && !bOptimize) printf("%%%%[Begin Create Unicode glyphset]%%%%\n\n");

    CreateGlyphSets(&aGlyphSets[cNumGlyphSets],
                    &UnicodePage,
                    &aUniPsTbl[cNumGlyphSets]);
    cSizeGlyphSets += aGlyphSets[cNumGlyphSets]->dwSize;
    cNumGlyphSets++;

    if (bVerbose && !bOptimize) printf("%%%%[End Create Unicode glyphset]%%%%\n\n");


    //////////////////////////////////////////////////////////////////////////
    //
    // Step 3: Write GLYPHSETDATA(s) and NTM(s) to a .NTF file.
    //
    //////////////////////////////////////////////////////////////////////////

    if (bVerbose) printf("%%%%[Begin Write NTF]%%%%\n\n");

    ulLength = strlen(argv[1 + nArgcOffset]) + 1;
    MULTIBYTETOUNICODE(
        wstrNTFFile,
        ulLength*sizeof(WCHAR),
        NULL,
        argv[1 + nArgcOffset],
        ulLength);

    if (!WriteNTF(wstrNTFFile,
                    cNumGlyphSets,
                    cSizeGlyphSets,
                    aGlyphSets,
                    cNumNTM,
                    cSizeNTM,
                    aPNTM
                    ))
    {
        ERR(("makentf: main - Can't write .NTF file\n"));
    }

    if (bVerbose) printf("%%%%[End Write NTF]%%%%\n\n");


    //////////////////////////////////////////////////////////////////////////
    //
    // Step 4: Clean up.
    //
    //////////////////////////////////////////////////////////////////////////
CLEAN_UP:
    for (i = 0; i < cNumNTM; i++)
    {
        MemFree(aPNTM[i]);
    }
    for (i = 0; i < cNumGlyphSets; i++)
    {
        MemFree(aGlyphSets[i]);
        if (aUniPsTbl[i] != NULL)
        {
            //
            // Could have a null ptr if this is a Pi Font.
            //
            MemFree(aUniPsTbl[i]);
        }
    }

    MemFree(aPNTM ? aPNTM : NULL);
    MemFree(aGlyphSets ? aGlyphSets : NULL);
    MemFree(pFamilyTbl ? pFamilyTbl : NULL);
    MemFree(UnicodetoPs ? UnicodetoPs : NULL);
    MemFree(aUniPsTbl ? aUniPsTbl : NULL);
    MemFree(aWinCodePages ? aWinCodePages : NULL);

    if (bVerbose) printf("%%%%[End MakeNTF]%%%%\n\n");
}


//
// Formating functions - copied from PScript\Output.c
//
INT
OPVsprintf(
    OUT LPSTR   buf,
    IN  LPCSTR  fmtstr,
    IN  va_list arglist
    )

/*++

Routine Description:

    Takes a pointer to an argument list, then formats and writes
    the given data to the memory pointed to by buffer.

Arguments:

    buf     Storage location for output
    fmtstr  Format specification
    arglist Pointer to list of arguments

Return Value:

    Return the number of characters written, not including
    the terminating null character, or a negative value if
    an output error occurs.

[Note:]

    This is NOT a full implementation of "vsprintf" as found
    in the C runtime library. Specifically, the only form of
    format specification allowed is %type, where "type" can
    be one of the following characters:

    d   INT     signed decimal integer
    l   LONG    signed decimal integer
    u   ULONG   unsigned decimal integer
    s   CHAR*   character string
    c   CHAR    character
    x,X DWORD   hex number (emits at least two digits, uppercase)
    b   BOOL    boolean (true or false)
    f   LONG    24.8 fixed-pointed number
    o   CHAR    octal number

--*/

{
    LPSTR   ptr = buf;

    ASSERT(buf && fmtstr);

    while (*fmtstr != NUL) {

        if (*fmtstr != '%') {

            // Normal character

            *ptr++ = *fmtstr++;

        } else {

            // Format specification

            switch (*++fmtstr) {

            case 'd':       // signed decimal integer

                _ltoa((LONG) va_arg(arglist, INT), ptr, 10);
                ptr += strlen(ptr);
                break;

            case 'l':       // signed decimal integer

                _ltoa(va_arg(arglist, LONG), ptr, 10);
                ptr += strlen(ptr);
                break;

            case 'u':       // unsigned decimal integer

                _ultoa(va_arg(arglist, ULONG), ptr, 10);
                ptr += strlen(ptr);
                break;

            case 's':       // character string

                {   LPSTR   s = va_arg(arglist, LPSTR);

                    while (*s)
                        *ptr++ = *s++;
                }
                break;

            case 'c':       // character

                *ptr++ = va_arg(arglist, CHAR);
                break;

            case 'x':
            case 'X':       // hexdecimal number

                {   ULONG   ul = va_arg(arglist, ULONG);
                    INT     ndigits = 8;

                    while (ndigits > 2 && ((ul >> (ndigits-1)*4) & 0xf) == 0)
                        ndigits--;

                    while (ndigits-- > 0)
                        *ptr++ = HexDigit(ul >> ndigits*4);
                }
                break;

            case 'o':

                {   CHAR    ch = va_arg(arglist, CHAR);

                    *ptr++ = (char)((ch & 0xC0) >> 6) + (char)'0';
                    *ptr++ = (char)((ch & 0x38) >> 3) + (char)'0';
                    *ptr++ = (char)(ch & 0x07) + (char)'0';
                }
                break;

            case 'b':       // boolean

                StringCchCopyA(ptr, (size_t)((ptr - buf)/sizeof(CHAR)), (va_arg(arglist, BOOL)) ? "true" : "false");
                ptr += strlen(ptr);
                break;

            case 'f':       // 24.8 fixed-pointed number

                {
                    LONG    l = va_arg(arglist, LONG);
                    ULONG   ul, scale;

                    // sign character

                    if (l < 0) {
                        *ptr++ = '-';
                        ul = -l;
                    } else
                        ul = l;

                    // integer portion

                    _ultoa(ul >> 8, ptr, 10);
                    ptr += strlen(ptr);

                    // fraction

                    ul &= 0xff;
                    if (ul != 0) {

                        // We output a maximum of 3 digits after the
                        // decimal point, but we'll compute to the 5th
                        // decimal point and round it to 3rd.

                        ul = ((ul*100000 >> 8) + 50) / 100;
                        scale = 100;

                        *ptr++ = '.';

                        do {

                            *ptr++ = (CHAR) (ul/scale + '0');
                            ul %= scale;
                            scale /= 10;

                        } while (scale != 0 && ul != 0) ;
                    }
                }
                break;

            default:

                if (*fmtstr != NUL)
                    *ptr++ = *fmtstr;
                else {
                    ERR(("Invalid format specification\n"));
                    fmtstr--;
                }
                break;
            }

            // Skip the type characterr

            fmtstr++;
        }
    }

    *ptr = NUL;
    return (INT)(ptr - buf);
}



INT
OPSprintf(
    OUT LPSTR   buf,
    IN  LPCSTR  fmtstr,
    IN  ...
    )

{
    va_list arglist;
    INT     iRc;

    va_start(arglist, fmtstr);
    iRc = OPVsprintf(buf, fmtstr, arglist);
    va_end(arglist);

    return iRc;
}


int __cdecl compareWinCpt(const void *elem1, const void *elem2)
{
    PWINCPT  p1;
    PWINCPT  p2;

    p1 = (PWINCPT)elem1;
    p2 = (PWINCPT)elem2;

    if (p1->usWinCpt == p2->usWinCpt)
        return(0);
    else if (p1->usWinCpt < p2->usWinCpt)
        return(-1);
    else
        return(1);
}


VOID
SortWinCPT(
    IN OUT  WINCPT      *pSortedWinCpts,
    IN      WINCPTOPS   *pCPtoPS
)
{
    // pSortedWinCpts must point to a buffer big enough sizeof(WINCPT)* MAX_CSET_CHARS)

    memcpy(pSortedWinCpts, &(pCPtoPS->aWinCpts), sizeof(WINCPT)* MAX_CSET_CHARS);

    qsort(pSortedWinCpts, pCPtoPS->ulChCnt, sizeof(WINCPT), compareWinCpt);

}


//
// This function reads a list of CP to PS Name tables and writes an Text file
// with the corresponding PostScript Encoding arrays
// Need to run this whenever we changed the Mapping tables
//
// Format:
//          10        20        30        40
// 1234567890123456789012345678901234567890
//        CodePage = dddd (name)
// /name_up_to_32                   % XX
//

BOOL
WritePSEncodings(
    IN  PWSTR           pwszFileName,
    IN  WINCPTOPS       *CPtoPSList,
    IN  DWORD           dwPages
    )
{
    HANDLE              hFile;
    ULONG               i, j, k, l;
    WINCPTOPS           *pCPtoPS;
    WINCPT              sortedWinCpts[MAX_CSET_CHARS]; // maxiaml 255 chars
    char                buffer[256];
    DWORD               dwLen, ulByteWritten;


    hFile = CreateFile(pwszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                          CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        ERR(("WritePSEncodings:CreateFile\n"));
        return(FALSE);
    }


    for (i = 0; i < dwPages; i++)
    {
        pCPtoPS = CPtoPSList + i;

        dwLen = OPSprintf(buffer, "\n\n       CodePage = %d (%s)\n",
                pCPtoPS->usACP, pCPtoPS->pGSName);

        if (!WriteFile(hFile, buffer, dwLen, (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
            || ulByteWritten != dwLen)
        {
            ERR(("WritePSEncodings:WriteFile\n"));
            CloseHandle(hFile);
            return(FALSE);
        }

        SortWinCPT(&(sortedWinCpts[0]), pCPtoPS);

        k = sortedWinCpts[0].usWinCpt;
        for (j = 0; j < pCPtoPS->ulChCnt; j++, k++)
        {
            while (k < sortedWinCpts[j].usWinCpt)
            {
            dwLen = OPSprintf(buffer, "                                 %% %X\n", k);
                if (!WriteFile(hFile, buffer, dwLen, (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
                    || ulByteWritten != dwLen)
                {
                    ERR(("WritePSEncodings:WriteFile\n"));
                    CloseHandle(hFile);
                    return(FALSE);
                }
                k++;
            }

            dwLen = OPSprintf(buffer, "                                 %% %X\n", sortedWinCpts[j].usWinCpt);
            strncpy(buffer, "/", 1);
            l = strlen(sortedWinCpts[j].pPsName);
            strncpy(buffer + 1, sortedWinCpts[j].pPsName, l);
            if (!WriteFile(hFile, buffer, dwLen, (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
                || ulByteWritten != dwLen)
            {
                ERR(("WritePSEncodings:WriteFile\n"));
                CloseHandle(hFile);
                return(FALSE);
            }
        }
    }

    CloseHandle(hFile);
    return(TRUE);
}


//
// This causes the error message to show up in your command window
// instead of the kernel debugger window.
//

ULONG _cdecl
DbgPrint(
    PCSTR    pstrFormat,
    ...
    )

{
    va_list ap;

    va_start(ap, pstrFormat);
    vprintf(pstrFormat, ap);
    va_end(ap);

    return 0;
}


VOID
DbgBreakPoint(
    VOID
    )

{
    exit(-1);
}


BOOL NeedBuildMoreNTM(
     PBYTE pAFM
     )
{
    PPSFAMILYINFO   pFamilyInfo;
    PSZ             pszFontName;

    pFamilyInfo = NULL;
    pszFontName = FindAFMToken(pAFM, PS_FONT_NAME_TOK);

    if (NULL ==pszFontName) return FALSE;

    pFamilyInfo = (PPSFAMILYINFO) bsearch(pszFontName,
                                    (PBYTE) (((PPSFAMILYINFO) (pFamilyTbl->pTbl))[0].pFontName),
                                    pFamilyTbl->usNumEntries,
                                    sizeof(PSFAMILYINFO),
                                    StrCmp);
    if (pFamilyInfo)
    {
        if (pFamilyInfo->usPitch != DEFAULT_PITCH)
            return TRUE;
        if (pFamilyInfo > ((PPSFAMILYINFO) (pFamilyTbl->pTbl)))
        {
            pFamilyInfo = pFamilyInfo - 1;
            if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                (pFamilyInfo->usPitch != DEFAULT_PITCH))
                return TRUE;
        }
        pFamilyInfo = pFamilyInfo + 1;
        if (pFamilyInfo <
            (((PPSFAMILYINFO) (pFamilyTbl->pTbl)) + pFamilyTbl->usNumEntries))
        {
            pFamilyInfo = pFamilyInfo + 1;
            if (!StrCmp(pFamilyInfo->pFontName, pszFontName) &&
                (pFamilyInfo->usPitch != DEFAULT_PITCH))
                return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\makentf\unipstbl.c ===
/*++

Copyright (c) 1996  Adobe Systems Incorporated
Copyright (c) 1996  Microsoft Corporation

Module Name:
    UniPsTbl

Abstract:
    This module contains global data used to create NTM data from AFM files.

Author:
    Rob Kiesler (rkiesler@adobe.com) 10/24/1996

Environment:

Revision History:
    09/10/1997  ksuzuki
            Added WeightKeysCJK table.

    10/28/1996   rkiesler@adobe.com
           Created.

--*/

#include "lib.h"
#include "ppd.h"
#include "pslib.h"
#include "psglyph.h"
#include "afm2ntm.h"


//
// Name of family .DAT file.
//
PWCHAR DatFileName = L"\\psfamily.dat";

//
// Unicode -> PS Char name xlat table, sorted by PS char name.
//
UPSCODEPT PstoUnicode[NUM_PS_CHARS] =
{
    //
    // U+001f => '.notdef1f': this mapping guarantees that the very first
    // bit of the character defintion bitmap (pointed to by NTM.dwCharDefFlagOffset)
    // is clear to make the device glyph index zero a '.notdef' glyph.
    //
    { 0x001F, ".notdef1f", CS_ALL },

    { 0x0041, "A",  CS_ALL },
    { 0x00C6, "AE", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00C1, "Aacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0102, "Abreve", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x00C2, "Acircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00C4, "Adieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00C0, "Agrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0391, "Alpha", CSUP(CS_GREEK) },
    { 0x0386, "Alphatonos", CSUP(CS_GREEK) },
    { 0x0100, "Amacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0104, "Aogonek", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x00C5, "Aring", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00C3, "Atilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0042, "B", CS_ALL },
    { 0x0392, "Beta", CSUP(CS_GREEK) },
    { 0x0043, "C", CS_ALL },
    { 0x0106, "Cacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x010C, "Ccaron", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x00C7, "Ccedilla", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x03A7, "Chi", CSUP(CS_GREEK) },
    { 0x0044, "D", CS_ALL },
    { 0x010E, "Dcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0110, "Dcroat", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0394, "Delta", CSUP(CS_GREEK) | CSUP(CS_314) },
    { 0x0045, "E", CS_ALL },
    { 0x00C9, "Eacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x011A, "Ecaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x00CA, "Ecircumflex", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00CB, "Edieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0116, "Edotaccent", CSUP(CS_314) },
    { 0x0116, "Edot", CSUP(CS_BALTIC) },
    { 0x00C8, "Egrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0112, "Emacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0118, "Eogonek", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0395, "Epsilon", CSUP(CS_GREEK) },
    { 0x0388, "Epsilontonos", CSUP(CS_GREEK) },
    { 0x0397, "Eta", CSUP(CS_GREEK) },
    { 0x0389, "Etatonos", CSUP(CS_GREEK) },
    { 0x00D0, "Eth", CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x20AC, "Euro", CS_EURO },
    { 0x0046, "F", CS_ALL },
    { 0x0047, "G", CS_ALL },
    { 0x0393, "Gamma", CSUP(CS_GREEK) },
    { 0x011E, "Gbreve", CSUP(CS_TURKISH) | CSUP(CS_314) },
    { 0x0122, "Gcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0122, "Gcommaaccent", CSUP(CS_314) },
    { 0x0048, "H", CS_ALL },
    { 0x0049, "I", CS_ALL },
    { 0x00CD, "Iacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00CE, "Icircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00CF, "Idieresis", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0130, "Idotaccent", CSUP(CS_TURKISH) | CSUP(CS_314) },
    { 0x00CC, "Igrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x012A, "Imacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x012E, "Iogonek", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0399, "Iota", CSUP(CS_GREEK) },
    { 0x03AA, "Iotadieresis", CSUP(CS_GREEK) },
    { 0x038A, "Iotatonos", CSUP(CS_GREEK) },
    { 0x004A, "J", CS_ALL },
    { 0x004B, "K", CS_ALL },
    { 0x039A, "Kappa", CSUP(CS_GREEK) },
    { 0x0136, "Kcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0136, "Kcommaaccent", CSUP(CS_314) },
    { 0x004C, "L", CS_ALL },
    { 0x0139, "Lacute", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x039B, "Lambda", CSUP(CS_GREEK) },
    { 0x013D, "Lcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x013B, "Lcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x013B, "Lcommaaccent", CSUP(CS_314) },
    { 0x0141, "Lslash", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x004D, "M", CS_ALL },
    { 0x039C, "Mu", CSUP(CS_GREEK) },
    { 0x004E, "N", CS_ALL },
    { 0x0143, "Nacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0147, "Ncaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0145, "Ncedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0145, "Ncommaaccent", CSUP(CS_314) },
    { 0x00D1, "Ntilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x039D, "Nu", CSUP(CS_GREEK) },
    { 0x004F, "O", CS_ALL },
    { 0x0152, "OE", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00D3, "Oacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00D4, "Ocircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00D6, "Odieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00D2, "Ograve", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0150, "Ohungarumlaut", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x014C, "Omacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03A9, "Omega", CSUP(CS_GREEK) },
    { 0x038F, "Omegatonos", CSUP(CS_GREEK) },
    { 0x039F, "Omicron", CSUP(CS_GREEK) },
    { 0x038C, "Omicrontonos", CSUP(CS_GREEK) },
    { 0x00D8, "Oslash", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00D5, "Otilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0050, "P", CS_ALL },
    { 0x03A6, "Phi", CSUP(CS_GREEK) },
    { 0x03A0, "Pi", CSUP(CS_GREEK) },
    { 0x03A8, "Psi", CSUP(CS_GREEK) },
    { 0x0051, "Q", CS_ALL },
    { 0x0052, "R", CS_ALL },
    { 0x0154, "Racute", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0158, "Rcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0156, "Rcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0156, "Rcommaaccent", CSUP(CS_314) },
    { 0x03A1, "Rho", CSUP(CS_GREEK) },
    { 0x0053, "S", CS_ALL },
    { 0x015A, "Sacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0160, "Scaron", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0xF6C1, "Scedilla", CSUP(CS_314) },
    { 0x015E, "Scommaaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_TURKISH) | CSUP(CS_314) },
    { 0x03A3, "Sigma", CSUP(CS_GREEK) },
    { 0x0054, "T", CS_ALL },
    { 0x03A4, "Tau", CSUP(CS_GREEK) },
    { 0x0164, "Tcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0162, "Tcommaaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0398, "Theta", CSUP(CS_GREEK) },
    { 0x00DE, "Thorn", CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x0055, "U", CS_ALL },
    { 0x00DA, "Uacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00DB, "Ucircumflex", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00DC, "Udieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00D9, "Ugrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0170, "Uhungarumlaut", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x016A, "Umacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0172, "Uogonek", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03A5, "Upsilon", CSUP(CS_GREEK) },
    { 0x03AB, "Upsilondieresis", CSUP(CS_GREEK) },
    { 0x038E, "Upsilontonos", CSUP(CS_GREEK) },
    { 0x016E, "Uring", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0056, "V", CS_ALL },
    { 0x0057, "W", CS_ALL },
    { 0x0058, "X", CS_ALL },
    { 0x039E, "Xi", CSUP(CS_GREEK) },
    { 0x0059, "Y", CS_ALL },
    { 0x00DD, "Yacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x0178, "Ydieresis", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x005A, "Z", CS_ALL },
    { 0x0179, "Zacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x017D, "Zcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) | CSUP(CS_ANSI)},
    { 0x017B, "Zdotaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0396, "Zeta", CSUP(CS_GREEK) },
    { 0x0061, "a", CS_ALL },
    { 0x00E1, "aacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0103, "abreve", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x00E2, "acircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00B4, "acute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00E4, "adieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00E6, "ae", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x2015, "afii00208", CSUP(CS_GREEK) },
    { 0x0410, "afii10017", CSUP(CS_RUSSIAN) },
    { 0x0411, "afii10018", CSUP(CS_RUSSIAN) },
    { 0x0412, "afii10019", CSUP(CS_RUSSIAN) },
    { 0x0413, "afii10020", CSUP(CS_RUSSIAN) },
    { 0x0414, "afii10021", CSUP(CS_RUSSIAN) },
    { 0x0415, "afii10022", CSUP(CS_RUSSIAN) },
    { 0x0401, "afii10023", CSUP(CS_RUSSIAN) },
    { 0x0416, "afii10024", CSUP(CS_RUSSIAN) },
    { 0x0417, "afii10025", CSUP(CS_RUSSIAN) },
    { 0x0418, "afii10026", CSUP(CS_RUSSIAN) },
    { 0x0419, "afii10027", CSUP(CS_RUSSIAN) },
    { 0x041A, "afii10028", CSUP(CS_RUSSIAN) },
    { 0x041B, "afii10029", CSUP(CS_RUSSIAN) },
    { 0x041C, "afii10030", CSUP(CS_RUSSIAN) },
    { 0x041D, "afii10031", CSUP(CS_RUSSIAN) },
    { 0x041E, "afii10032", CSUP(CS_RUSSIAN) },
    { 0x041F, "afii10033", CSUP(CS_RUSSIAN) },
    { 0x0420, "afii10034", CSUP(CS_RUSSIAN) },
    { 0x0421, "afii10035", CSUP(CS_RUSSIAN) },
    { 0x0422, "afii10036", CSUP(CS_RUSSIAN) },
    { 0x0423, "afii10037", CSUP(CS_RUSSIAN) },
    { 0x0424, "afii10038", CSUP(CS_RUSSIAN) },
    { 0x0425, "afii10039", CSUP(CS_RUSSIAN) },
    { 0x0426, "afii10040", CSUP(CS_RUSSIAN) },
    { 0x0427, "afii10041", CSUP(CS_RUSSIAN) },
    { 0x0428, "afii10042", CSUP(CS_RUSSIAN) },
    { 0x0429, "afii10043", CSUP(CS_RUSSIAN) },
    { 0x042A, "afii10044", CSUP(CS_RUSSIAN) },
    { 0x042B, "afii10045", CSUP(CS_RUSSIAN) },
    { 0x042C, "afii10046", CSUP(CS_RUSSIAN) },
    { 0x042D, "afii10047", CSUP(CS_RUSSIAN) },
    { 0x042E, "afii10048", CSUP(CS_RUSSIAN) },
    { 0x042F, "afii10049", CSUP(CS_RUSSIAN) },
    { 0x0490, "afii10050", CSUP(CS_RUSSIAN) },
    { 0x0402, "afii10051", CSUP(CS_RUSSIAN) },
    { 0x0403, "afii10052", CSUP(CS_RUSSIAN) },
    { 0x0404, "afii10053", CSUP(CS_RUSSIAN) },
    { 0x0405, "afii10054", CSUP(CS_RUSSIAN) },
    { 0x0406, "afii10055", CSUP(CS_RUSSIAN) },
    { 0x0407, "afii10056", CSUP(CS_RUSSIAN) },
    { 0x0408, "afii10057", CSUP(CS_RUSSIAN) },
    { 0x0409, "afii10058", CSUP(CS_RUSSIAN) },
    { 0x040A, "afii10059", CSUP(CS_RUSSIAN) },
    { 0x040B, "afii10060", CSUP(CS_RUSSIAN) },
    { 0x040C, "afii10061", CSUP(CS_RUSSIAN) },
    { 0x040E, "afii10062", CSUP(CS_RUSSIAN) },
    { 0x0430, "afii10065", CSUP(CS_RUSSIAN) },
    { 0x0431, "afii10066", CSUP(CS_RUSSIAN) },
    { 0x0432, "afii10067", CSUP(CS_RUSSIAN) },
    { 0x0433, "afii10068", CSUP(CS_RUSSIAN) },
    { 0x0434, "afii10069", CSUP(CS_RUSSIAN) },
    { 0x0435, "afii10070", CSUP(CS_RUSSIAN) },
    { 0x0451, "afii10071", CSUP(CS_RUSSIAN) },
    { 0x0436, "afii10072", CSUP(CS_RUSSIAN) },
    { 0x0437, "afii10073", CSUP(CS_RUSSIAN) },
    { 0x0438, "afii10074", CSUP(CS_RUSSIAN) },
    { 0x0439, "afii10075", CSUP(CS_RUSSIAN) },
    { 0x043A, "afii10076", CSUP(CS_RUSSIAN) },
    { 0x043B, "afii10077", CSUP(CS_RUSSIAN) },
    { 0x043C, "afii10078", CSUP(CS_RUSSIAN) },
    { 0x043D, "afii10079", CSUP(CS_RUSSIAN) },
    { 0x043E, "afii10080", CSUP(CS_RUSSIAN) },
    { 0x043F, "afii10081", CSUP(CS_RUSSIAN) },
    { 0x0440, "afii10082", CSUP(CS_RUSSIAN) },
    { 0x0441, "afii10083", CSUP(CS_RUSSIAN) },
    { 0x0442, "afii10084", CSUP(CS_RUSSIAN) },
    { 0x0443, "afii10085", CSUP(CS_RUSSIAN) },
    { 0x0444, "afii10086", CSUP(CS_RUSSIAN) },
    { 0x0445, "afii10087", CSUP(CS_RUSSIAN) },
    { 0x0446, "afii10088", CSUP(CS_RUSSIAN) },
    { 0x0447, "afii10089", CSUP(CS_RUSSIAN) },
    { 0x0448, "afii10090", CSUP(CS_RUSSIAN) },
    { 0x0449, "afii10091", CSUP(CS_RUSSIAN) },
    { 0x044A, "afii10092", CSUP(CS_RUSSIAN) },
    { 0x044B, "afii10093", CSUP(CS_RUSSIAN) },
    { 0x044C, "afii10094", CSUP(CS_RUSSIAN) },
    { 0x044D, "afii10095", CSUP(CS_RUSSIAN) },
    { 0x044E, "afii10096", CSUP(CS_RUSSIAN) },
    { 0x044F, "afii10097", CSUP(CS_RUSSIAN) },
    { 0x0491, "afii10098", CSUP(CS_RUSSIAN) },
    { 0x0452, "afii10099", CSUP(CS_RUSSIAN) },
    { 0x0453, "afii10100", CSUP(CS_RUSSIAN) },
    { 0x0454, "afii10101", CSUP(CS_RUSSIAN) },
    { 0x0455, "afii10102", CSUP(CS_RUSSIAN) },
    { 0x0456, "afii10103", CSUP(CS_RUSSIAN) },
    { 0x0457, "afii10104", CSUP(CS_RUSSIAN) },
    { 0x0458, "afii10105", CSUP(CS_RUSSIAN) },
    { 0x0459, "afii10106", CSUP(CS_RUSSIAN) },
    { 0x045A, "afii10107", CSUP(CS_RUSSIAN) },
    { 0x045B, "afii10108", CSUP(CS_RUSSIAN) },
    { 0x045C, "afii10109", CSUP(CS_RUSSIAN) },
    { 0x045E, "afii10110", CSUP(CS_RUSSIAN) },
    { 0x040F, "afii10145", CSUP(CS_RUSSIAN) },
    { 0x045F, "afii10193", CSUP(CS_RUSSIAN) },
    { 0x060C, "afii57388", CSUP(CS_ARABIC) },
    { 0x061B, "afii57403", CSUP(CS_ARABIC) },
    { 0x061F, "afii57407", CSUP(CS_ARABIC) },
    { 0x0621, "afii57409", CSUP(CS_ARABIC) },
    { 0x0622, "afii57410", CSUP(CS_ARABIC) },
    { 0x0623, "afii57411", CSUP(CS_ARABIC) },
    { 0x0624, "afii57412", CSUP(CS_ARABIC) },
    { 0x0625, "afii57413", CSUP(CS_ARABIC) },
    { 0x0626, "afii57414", CSUP(CS_ARABIC) },
    { 0x0627, "afii57415", CSUP(CS_ARABIC) },
    { 0x0628, "afii57416", CSUP(CS_ARABIC) },
    { 0x0629, "afii57417", CSUP(CS_ARABIC) },
    { 0x062A, "afii57418", CSUP(CS_ARABIC) },
    { 0x062B, "afii57419", CSUP(CS_ARABIC) },
    { 0x062C, "afii57420", CSUP(CS_ARABIC) },
    { 0x062D, "afii57421", CSUP(CS_ARABIC) },
    { 0x062E, "afii57422", CSUP(CS_ARABIC) },
    { 0x062F, "afii57423", CSUP(CS_ARABIC) },
    { 0x0630, "afii57424", CSUP(CS_ARABIC) },
    { 0x0631, "afii57425", CSUP(CS_ARABIC) },
    { 0x0632, "afii57426", CSUP(CS_ARABIC) },
    { 0x0633, "afii57427", CSUP(CS_ARABIC) },
    { 0x0634, "afii57428", CSUP(CS_ARABIC) },
    { 0x0635, "afii57429", CSUP(CS_ARABIC) },
    { 0x0636, "afii57430", CSUP(CS_ARABIC) },
    { 0x0637, "afii57431", CSUP(CS_ARABIC) },
    { 0x0638, "afii57432", CSUP(CS_ARABIC) },
    { 0x0639, "afii57433", CSUP(CS_ARABIC) },
    { 0x063A, "afii57434", CSUP(CS_ARABIC) },
    { 0x0640, "afii57440", CSUP(CS_ARABIC) },
    { 0x0641, "afii57441", CSUP(CS_ARABIC) },
    { 0x0642, "afii57442", CSUP(CS_ARABIC) },
    { 0x0643, "afii57443", CSUP(CS_ARABIC) },
    { 0x0644, "afii57444", CSUP(CS_ARABIC) },
    { 0x0645, "afii57445", CSUP(CS_ARABIC) },
    { 0x0646, "afii57446", CSUP(CS_ARABIC) },
    { 0x0648, "afii57448", CSUP(CS_ARABIC) },
    { 0x0649, "afii57449", CSUP(CS_ARABIC) },
    { 0x064A, "afii57450", CSUP(CS_ARABIC) },
    { 0x064B, "afii57451", CSUP(CS_ARABIC) },
    { 0x064C, "afii57452", CSUP(CS_ARABIC) },
    { 0x064D, "afii57453", CSUP(CS_ARABIC) },
    { 0x064E, "afii57454", CSUP(CS_ARABIC) },
    { 0x064F, "afii57455", CSUP(CS_ARABIC) },
    { 0x0650, "afii57456", CSUP(CS_ARABIC) },
    { 0x0651, "afii57457", CSUP(CS_ARABIC) },
    { 0x0652, "afii57458", CSUP(CS_ARABIC) },
    { 0x0647, "afii57470", CSUP(CS_ARABIC) },
    { 0x067E, "afii57506", CSUP(CS_ARABIC) },
    { 0x0686, "afii57507", CSUP(CS_ARABIC) },
    { 0x0698, "afii57508", CSUP(CS_ARABIC) },
    { 0x06AF, "afii57509", CSUP(CS_ARABIC) },
    { 0x200E, "afii57596", CSUP(CS_HEBREW) | CSUP(CS_ARABIC) },
    { 0x200F, "afii57597", CSUP(CS_HEBREW) | CSUP(CS_ARABIC) },
    { 0x200D, "afii57598", CSUP(CS_ARABIC) },
    { 0x20AA, "afii57636", CSUP(CS_HEBREW) },
    { 0x05BE, "afii57645", CSUP(CS_HEBREW) },
    { 0x05C3, "afii57658", CSUP(CS_HEBREW) },
    { 0x05D0, "afii57664", CSUP(CS_HEBREW) },
    { 0x05D1, "afii57665", CSUP(CS_HEBREW) },
    { 0x05D2, "afii57666", CSUP(CS_HEBREW) },
    { 0x05D3, "afii57667", CSUP(CS_HEBREW) },
    { 0x05D4, "afii57668", CSUP(CS_HEBREW) },
    { 0x05D5, "afii57669", CSUP(CS_HEBREW) },
    { 0x05D6, "afii57670", CSUP(CS_HEBREW) },
    { 0x05D7, "afii57671", CSUP(CS_HEBREW) },
    { 0x05D8, "afii57672", CSUP(CS_HEBREW) },
    { 0x05D9, "afii57673", CSUP(CS_HEBREW) },
    { 0x05DA, "afii57674", CSUP(CS_HEBREW) },
    { 0x05DB, "afii57675", CSUP(CS_HEBREW) },
    { 0x05DC, "afii57676", CSUP(CS_HEBREW) },
    { 0x05DD, "afii57677", CSUP(CS_HEBREW) },
    { 0x05DE, "afii57678", CSUP(CS_HEBREW) },
    { 0x05DF, "afii57679", CSUP(CS_HEBREW) },
    { 0x05E0, "afii57680", CSUP(CS_HEBREW) },
    { 0x05E1, "afii57681", CSUP(CS_HEBREW) },
    { 0x05E2, "afii57682", CSUP(CS_HEBREW) },
    { 0x05E3, "afii57683", CSUP(CS_HEBREW) },
    { 0x05E4, "afii57684", CSUP(CS_HEBREW) },
    { 0x05E5, "afii57685", CSUP(CS_HEBREW) },
    { 0x05E6, "afii57686", CSUP(CS_HEBREW) },
    { 0x05E7, "afii57687", CSUP(CS_HEBREW) },
    { 0x05E8, "afii57688", CSUP(CS_HEBREW) },
    { 0x05E9, "afii57689", CSUP(CS_HEBREW) },
    { 0x05EA, "afii57690", CSUP(CS_HEBREW) },
    { 0x05F0, "afii57716", CSUP(CS_HEBREW) },
    { 0x05F1, "afii57717", CSUP(CS_HEBREW) },
    { 0x05F2, "afii57718", CSUP(CS_HEBREW) },
    { 0x05B4, "afii57793", CSUP(CS_HEBREW) },
    { 0x05B5, "afii57794", CSUP(CS_HEBREW) },
    { 0x05B6, "afii57795", CSUP(CS_HEBREW) },
    { 0x05BB, "afii57796", CSUP(CS_HEBREW) },
    { 0x05B8, "afii57797", CSUP(CS_HEBREW) },
    { 0x05B7, "afii57798", CSUP(CS_HEBREW) },
    { 0x05B0, "afii57799", CSUP(CS_HEBREW) },
    { 0x05B2, "afii57800", CSUP(CS_HEBREW) },
    { 0x05B1, "afii57801", CSUP(CS_HEBREW) },
    { 0x05B3, "afii57802", CSUP(CS_HEBREW) },
    { 0x05C2, "afii57803", CSUP(CS_HEBREW) },
    { 0x05C1, "afii57804", CSUP(CS_HEBREW) },
    { 0x05B9, "afii57806", CSUP(CS_HEBREW) },
    { 0x05BC, "afii57807", CSUP(CS_HEBREW) },
    { 0x05BD, "afii57839", CSUP(CS_HEBREW) },
    { 0x05BF, "afii57841", CSUP(CS_HEBREW) },
    { 0x05C0, "afii57842", CSUP(CS_HEBREW) },
    { 0x2116, "afii61352", CSUP(CS_RUSSIAN) },
    { 0x200C, "afii61664", CSUP(CS_ARABIC) },
    { 0x00E0, "agrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x03B1, "alpha", CSUP(CS_GREEK) },
    { 0x03AC, "alphatonos", CSUP(CS_GREEK) },
    { 0x0101, "amacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0026, "ampersand", CS_ALL },
    { 0x0105, "aogonek", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x00E5, "aring", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x005E, "asciicircum", CS_ALL },
    { 0x007E, "asciitilde", CS_ALL },
    { 0x002A, "asterisk", CS_ALL },
    { 0x0040, "at", CS_ALL },
    { 0x00E3, "atilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0062, "b", CS_ALL },
    { 0x005C, "backslash", CS_ALL },
    { 0x007C, "bar", CS_ALL },
    { 0x03B2, "beta", CSUP(CS_GREEK) },
    { 0x007B, "braceleft", CS_ALL },
    { 0x007D, "braceright", CS_ALL },
    { 0x005B, "bracketleft", CS_ALL },
    { 0x005D, "bracketright", CS_ALL },
    { 0x02D8, "breve", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00A6, "brokenbar", CS_ALL },
    { 0x2022, "bullet", CS_ALL },
    { 0x0063, "c", CS_ALL },
    { 0x0107, "cacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x02C7, "caron", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x010D, "ccaron", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x00E7, "ccedilla", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00B8, "cedilla", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00A2, "cent", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x03C7, "chi", CSUP(CS_GREEK) },
    { 0x02C6, "circumflex", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x003A, "colon", CS_ALL },
    { 0x002C, "comma", CS_ALL },
    { 0xF6C3, "commaaccent", CSUP(CS_314) },
    { 0x00A9, "copyright", CS_ALL },
    { 0x00A4, "currency", CSUP(CS_EASTEUROPE) | CSUP(CS_RUSSIAN) | CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0064, "d", CS_ALL },
    { 0x2020, "dagger", CS_ALL },
    { 0x2021, "daggerdbl", CS_ALL },
    { 0x010F, "dcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0111, "dcroat", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x00B0, "degree", CSUP(CS_EASTEUROPE) | CSUP(CS_RUSSIAN) | CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x03B4, "delta", CSUP(CS_GREEK) },
    { 0x00A8, "dieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0385, "dieresistonos", CSUP(CS_GREEK) },
    { 0x00F7, "divide", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0024, "dollar", CS_ALL },
    { 0x02D9, "dotaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0131, "dotlessi", CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0065, "e", CS_ALL },
    { 0x00E9, "eacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x011B, "ecaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x00EA, "ecircumflex", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00EB, "edieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x0117, "edot", CSUP(CS_BALTIC) }, // TODO
    { 0x0117, "edotaccent", CSUP(CS_314) },
    { 0x00E8, "egrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x0038, "eight", CS_ALL },
    { 0x2026, "ellipsis", CS_ALL },
    { 0x0113, "emacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x2014, "emdash", CS_ALL },
    { 0x2013, "endash", CS_ALL },
    { 0x0119, "eogonek", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03B5, "epsilon", CSUP(CS_GREEK) },
    { 0x03AD, "epsilontonos", CSUP(CS_GREEK) },
    { 0x003D, "equal", CS_ALL },
    { 0x03B7, "eta", CSUP(CS_GREEK) },
    { 0x03AE, "etatonos", CSUP(CS_GREEK) },
    { 0x00F0, "eth", CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x0021, "exclam", CS_ALL },
    { 0x00A1, "exclamdown", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0066, "f", CS_ALL },
    { 0xFB01, "fi", CSUP(CS_228) },
    { 0x0035, "five", CS_ALL },
    { 0xFB02, "fl", CSUP(CS_228) },
    { 0x0192, "florin", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x0034, "four", CS_ALL },
    { 0x2044, "fraction", CSUP(CS_228) },
    { 0x0067, "g", CS_ALL },
    { 0x03B3, "gamma", CSUP(CS_GREEK) },
    { 0x011F, "gbreve", CSUP(CS_TURKISH) | CSUP(CS_314) },
    { 0x0123, "gcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0123, "gcommaaccent", CSUP(CS_314) },
    { 0x00DF, "germandbls", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0060, "grave", CS_ALL },
    { 0x003E, "greater", CS_ALL },
    { 0x2265, "greaterequal", CSUP(CS_314) },
    { 0x00AB, "guillemotleft", CS_ALL },
    { 0x00BB, "guillemotright", CS_ALL },
    { 0x2039, "guilsinglleft", CS_ALL },
    { 0x203A, "guilsinglright", CS_ALL },
    { 0x0068, "h", CS_ALL },
    { 0x02DD, "hungarumlaut", CSUP(CS_EASTEUROPE) | CSUP(CS_228) },
    { 0x002D, "hyphen", CS_ALL },
    { 0x0069, "i", CS_ALL },
    { 0x00ED, "iacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00EE, "icircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00EF, "idieresis", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00EC, "igrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x012B, "imacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x012F, "iogonek", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03B9, "iota", CSUP(CS_GREEK) },
    { 0x0390, "iotadieresistonos", CSUP(CS_GREEK) },
    { 0x03CA, "iotadieresis", CSUP(CS_GREEK) },
    { 0x03AF, "iotatonos", CSUP(CS_GREEK) },
    { 0x006A, "j", CS_ALL },
    { 0x006B, "k", CS_ALL },
    { 0x03BA, "kappa", CSUP(CS_GREEK) },
    { 0x0137, "kcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0137, "kcommaaccent", CSUP(CS_314) },
    { 0x006C, "l", CS_ALL },
    { 0x013A, "lacute", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x03BB, "lambda", CSUP(CS_GREEK) },
    { 0x013E, "lcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x013C, "lcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x013C, "lcommaaccent", CSUP(CS_314) },
    { 0x003C, "less", CS_ALL },
    { 0x2264, "lessequal", CSUP(CS_314) },
    { 0x00AC, "logicalnot", CS_ALL },
    { 0x25CA, "lozenge", CSUP(CS_314) },
    { 0x0142, "lslash", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x006D, "m", CS_ALL },
    { 0x00AF, "macron", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x2212, "minus", CSUP(CS_228) },
    { 0x00B5, "mu", CS_ALL },
    { 0x03BC, "mu", CSUP(CS_GREEK) },
    { 0x00D7, "multiply", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x006E, "n", CS_ALL },
    { 0x0144, "nacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x00A0, "space", CS_ALL }, // 'nbspace'
    { 0x0148, "ncaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0146, "ncedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0146, "ncommaaccent", CSUP(CS_314) },
    { 0x0039, "nine", CS_ALL },
    { 0x2260, "notequal", CSUP(CS_314) },
    { 0x00F1, "ntilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x03BD, "nu", CSUP(CS_GREEK) },
    { 0x0023, "numbersign", CS_ALL },
    { 0x006F, "o", CS_ALL },
    { 0x00F3, "oacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00F4, "ocircumflex", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00F6, "odieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0153, "oe", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x02DB, "ogonek", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00F2, "ograve", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0151, "ohungarumlaut", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x014D, "omacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03C9, "omega", CSUP(CS_GREEK) },
    { 0x03CE, "omegatonos", CSUP(CS_GREEK) },
    { 0x03BF, "omicron", CSUP(CS_GREEK) },
    { 0x03CC, "omicrontonos", CSUP(CS_GREEK) },
    { 0x0031, "one", CS_ALL },
    { 0x00BD, "onehalf", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00BC, "onequarter", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00B9, "onesuperior", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00AA, "ordfeminine", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00BA, "ordmasculine", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00F8, "oslash", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00F5, "otilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0070, "p", CS_ALL },
    { 0x00B6, "paragraph", CS_ALL },
    { 0x0028, "parenleft", CS_ALL },
    { 0x0029, "parenright", CS_ALL },
    { 0x2202, "partialdiff", CSUP(CS_314) },
    { 0x0025, "percent", CS_ALL },
    { 0x002E, "period", CS_ALL },
    { 0x00B7, "periodcentered", CS_ALL },
    { 0x2030, "perthousand", CS_ALL },
    { 0x03C6, "phi", CSUP(CS_GREEK) },
    { 0x03C0, "pi", CSUP(CS_GREEK) },
    { 0x002B, "plus", CS_ALL },
    { 0x00B1, "plusminus", CS_ALL },
    { 0x03C8, "psi", CSUP(CS_GREEK) },
    { 0x0071, "q", CS_ALL },
    { 0x003F, "question", CS_ALL },
    { 0x00BF, "questiondown", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x0022, "quotedbl", CS_ALL },
    { 0x201E, "quotedblbase", CS_ALL },
    { 0x201C, "quotedblleft", CS_ALL },
    { 0x201D, "quotedblright", CS_ALL },
    { 0x2018, "quoteleft", CS_ALL },
    { 0x2019, "quoteright", CS_ALL },
    { 0x201A, "quotesinglbase", CS_ALL },
    { 0x0027, "quotesingle", CS_ALL },
    { 0x0072, "r", CS_ALL },
    { 0x0155, "racute", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x221A, "radical", CSUP(CS_314) },
    { 0x0159, "rcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0157, "rcedilla", CSUP(CS_BALTIC) }, // TODO
    { 0x0157, "rcommaaccent", CSUP(CS_314) },
    { 0x00AE, "registered", CS_ALL },
    { 0x03C1, "rho", CSUP(CS_GREEK) },
    { 0x02DA, "ring", CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x0073, "s", CS_ALL },
    { 0x015B, "sacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0161, "scaron", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0xF6C2, "scedilla", CSUP(CS_314) },
    { 0x015F, "scommaaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_TURKISH) | CSUP(CS_314) },
    { 0x00A7, "section", CS_ALL },
    { 0x003B, "semicolon", CS_ALL },
    { 0x0037, "seven", CS_ALL },
    { 0x00AD, "hyphen", CS_ALL }, // 'sfthyphen'
    { 0x03C3, "sigma", CSUP(CS_GREEK) },
    { 0x03C2, "sigma1", CSUP(CS_GREEK) },
    { 0x0036, "six", CS_ALL },
    { 0x002F, "slash", CS_ALL },
    { 0x0020, "space", CS_ALL },
    { 0x00A3, "sterling", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x2211, "summation", CSUP(CS_314) },
    { 0x0074, "t", CS_ALL },
    { 0x03C4, "tau", CSUP(CS_GREEK) },
    { 0x0165, "tcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0163, "tcommaaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x03B8, "theta", CSUP(CS_GREEK) },
    { 0x00FE, "thorn", CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x0033, "three", CS_ALL },
    { 0x00BE, "threequarters", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00B3, "threesuperior", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x02DC, "tilde", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_228) },
    { 0x0384, "tonos", CSUP(CS_GREEK) },
    { 0x2122, "trademark", CS_ALL },
    { 0x0032, "two", CS_ALL },
    { 0x00B2, "twosuperior", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x0075, "u", CS_ALL },
    { 0x00FA, "uacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00FB, "ucircumflex", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x00FC, "udieresis", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_BALTIC) | CSUP(CS_228) },
    { 0x00F9, "ugrave", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x0171, "uhungarumlaut", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x016B, "umacron", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x005F, "underscore", CS_ALL },
    { 0x0173, "uogonek", CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x03C5, "upsilon", CSUP(CS_GREEK) },
    { 0x03B0, "upsilon-dieresistonos", CSUP(CS_GREEK) },
    { 0x03CB, "upsilondieresis", CSUP(CS_GREEK) },
    { 0x03CD, "upsilontonos", CSUP(CS_GREEK) },
    { 0x016F, "uring", CSUP(CS_EASTEUROPE) | CSUP(CS_314) },
    { 0x0076, "v", CS_ALL },
    { 0x0077, "w", CS_ALL },
    { 0x0078, "x", CS_ALL },
    { 0x03BE, "xi", CSUP(CS_GREEK) },
    { 0x0079, "y", CS_ALL },
    { 0x00FD, "yacute", CSUP(CS_EASTEUROPE) | CSUP(CS_ANSI) | CSUP(CS_228) },
    { 0x00FF, "ydieresis", CSUP(CS_ANSI) | CSUP(CS_TURKISH) | CSUP(CS_228) },
    { 0x00A5, "yen", CSUP(CS_ANSI) | CSUP(CS_GREEK) | CSUP(CS_TURKISH) | CSUP(CS_HEBREW) | CSUP(CS_ARABIC) | CSUP(CS_228) },
    { 0x007A, "z", CS_ALL },
    { 0x017A, "zacute", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x017E, "zcaron", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_228) | CSUP(CS_ANSI)},
    { 0x017C, "zdotaccent", CSUP(CS_EASTEUROPE) | CSUP(CS_BALTIC) | CSUP(CS_314) },
    { 0x0030, "zero", CS_ALL },
    { 0x03B6, "zeta", CSUP(CS_GREEK) },
};

//
// List of standard codepages. These are codepages for which we store
// predefined GLYPHSETDATA structures. The order of WINCODEPAGE structs
// in this list MUST correspond to the order of codepages (charsets) defined
// in the CHSETSUPPORT enumerated type.
//
WINCODEPAGE aStdCPList[] =
{
    { 1, ADOBE228_GS_NAME,              { CS_228 } },
    { 2, ADOBE314_GS_NAME,              { CS_228, CS_314 } },
    { 1, EASTEUROPE_GS_NAME,            { CS_EASTEUROPE } },
    { 1, SYMBOL_GS_NAME,                { CS_SYMBOL } },
    { 1, CYRILLIC_GS_NAME,              { CS_RUSSIAN } },
    { 1, ANSI_GS_NAME,                  { CS_ANSI } },
    { 1, GREEK_GS_NAME,                 { CS_GREEK } },
    { 1, TURKISH_GS_NAME,               { CS_TURKISH } },
    { 1, HEBREW_GS_NAME,                { CS_HEBREW } },
    { 1, ARABIC_GS_NAME,                { CS_ARABIC } },
    { 1, BALTIC_GS_NAME,                { CS_BALTIC } },
    { 2, ANSI_CYR_GS_NAME,              { CS_ANSI, CS_RUSSIAN } },
    { 5, ANSI_CYR_EE_BAL_TURK_GS_NAME,  { CS_ANSI, CS_RUSSIAN, CS_EASTEUROPE, CS_BALTIC, CS_TURKISH } },

    { 1, CHN_BIG5_GS_NAME,              { CS_CHINESEBIG5 } },
    { 1, CHN_SMPL_GBK_GS_NAME,          { CS_GB2312 } },
    { 1, SHIFTJIS_GS_NAME,              { CS_SHIFTJIS } },
    { 1, SHIFTJIS_P_GS_NAME,            { CS_SHIFTJISP } },
    { 1, SHIFTJIS_83PV_GS_NAME,         { CS_SHIFTJIS83 } },
    { 1, KSCMS_UHC_GS_NAME,             { CS_HANGEUL } },
    { 1, KSCMS_UHC_HW_GS_NAME,          { CS_HANGEULHW } },
    { 1, KSC_JOHAB_GS_NAME,             { CS_JOHAB } }
};

//
// The Unicode CodePage. This is used primarily for support of .PFB fonts
// when we need to obtain CP/CC from a Unicode value. This code page is
// not placed in aStdCPList above since we don't actually want any NTMs
// to reference this GLYPHSET.
//
WINCODEPAGE UnicodePage =
{
    8, UNICODE_GS_NAME,
    {
        CS_ANSI,
        CS_EASTEUROPE,
        CS_RUSSIAN,
        CS_GREEK,
        CS_TURKISH,
        CS_HEBREW,
        CS_ARABIC,
        CS_BALTIC
    }
};

WINCPTOPS aPStoCP[CS_MAX] =
{
    //
    // Made up code page.
    //
    { 0xFFF1, ADOBE228_CHARSET, ADOBE228_GS_NAME, 229,
        {
        { "A", 0x0041 },
        { "AE", 0x00C6 },
        { "Aacute", 0x00C1 },
        { "Acircumflex", 0x00C2 },
        { "Adieresis", 0x00C4 },
        { "Agrave", 0x00C0 },
        { "Aring", 0x00C5 },
        { "Atilde", 0x00C3 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "Ccedilla", 0x00C7 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Eacute", 0x00C9 },
        { "Ecircumflex", 0x00CA },
        { "Edieresis", 0x00CB },
        { "Egrave", 0x00C8 },
        { "Eth", 0x00D0 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Iacute", 0x00CD },
        { "Icircumflex", 0x00CE },
        { "Idieresis", 0x00CF },
        { "Igrave", 0x00CC },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "Lslash", 0x0009 },
        { "M", 0x004D },
        { "N", 0x004E },
        { "Ntilde", 0x00D1 },
        { "O", 0x004F },
        { "OE", 0x008C },
        { "Oacute", 0x00D3 },
        { "Ocircumflex", 0x00D4 },
        { "Odieresis", 0x00D6 },
        { "Ograve", 0x00D2 },
        { "Oslash", 0x00D8 },
        { "Otilde", 0x00D5 },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "Scaron", 0x008A },
        { "T", 0x0054 },
        { "Thorn", 0x00DE },
        { "U", 0x0055 },
        { "Uacute", 0x00DA },
        { "Ucircumflex", 0x00DB },
        { "Udieresis", 0x00DC },
        { "Ugrave", 0x00D9 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Yacute", 0x00DD },
        { "Ydieresis", 0x009F },
        { "Z", 0x005A },
        { "Zcaron", 0x000E },
        { "a", 0x0061 },
        { "aacute", 0x00E1 },
        { "acircumflex", 0x00E2 },
        { "acute", 0x00B4 },
        { "adieresis", 0x00E4 },
        { "ae", 0x00E6 },
        { "agrave", 0x00E0 },
        { "ampersand", 0x0026 },
        { "aring", 0x00E5 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "atilde", 0x00E3 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "breve", 0x0001 },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "caron", 0x0002 },
        { "ccedilla", 0x00E7 },
        { "cedilla", 0x00B8 },
        { "cent", 0x00A2 },
        { "circumflex", 0x0088 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "dotaccent", 0x0003 },
        { "dotlessi", 0x0004 },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "ecircumflex", 0x00EA },
        { "edieresis", 0x00EB },
        { "egrave", 0x00E8 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "eth", 0x00F0 },
        { "exclam", 0x0021 },
        { "exclamdown", 0x00A1 },
        { "f", 0x0066 },
        { "fi", 0x0005 },
        { "five", 0x0035 },
        { "fl", 0x0006 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "fraction", 0x0007 },
        { "g", 0x0067 },
        { "germandbls", 0x00DF },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hungarumlaut", 0x0008 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "iacute", 0x00ED },
        { "icircumflex", 0x00EE },
        { "idieresis", 0x00EF },
        { "igrave", 0x00EC },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "lslash", 0x000A },
        { "m", 0x006D },
        { "macron", 0x00AF },
        { "minus", 0x000B },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nine", 0x0039 },
        { "ntilde", 0x00F1 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "oacute", 0x00F3 },
        { "ocircumflex", 0x00F4 },
        { "odieresis", 0x00F6 },
        { "oe", 0x009C },
        { "ogonek", 0x000C },
        { "ograve", 0x00F2 },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "ordfeminine", 0x00AA },
        { "ordmasculine", 0x00BA },
        { "oslash", 0x00F8 },
        { "otilde", 0x00F5 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "questiondown", 0x00BF },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "ring", 0x000D },
        { "s", 0x0073 },
        { "scaron", 0x009A },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "thorn", 0x00FE },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "tilde", 0x0098 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "uacute", 0x00FA },
        { "ucircumflex", 0x00FB },
        { "udieresis", 0x00FC },
        { "ugrave", 0x00F9 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "yacute", 0x00FD },
        { "ydieresis", 0x00FF },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zcaron", 0x000F },
        { "zero", 0x0030 },
        }
    },

    //
    // Made up code page.
    // remember to increase the count (follows ADOBE314_GS_NAME) when addin gnew chars to this Encoding
    //
    { 0xFFF2, ADOBE314_CHARSET, ADOBE314_GS_NAME, 0x0056,
        {
        { "Abreve", 0x0001 },
        { "Amacron", 0x0002 },
        { "Aogonek", 0x0003 },
        { "Cacute", 0x0004 },
        { "Ccaron", 0x0005 },
        { "Dcaron", 0x0006 },
        { "Dcroat", 0x0007 },
        { "Delta", 0x0008 },
        { "Ecaron", 0x0009 },
        { "Edotaccent", 0x000A },
        { "Emacron", 0x000B },
        { "Eogonek", 0x000C },
        { "Gbreve", 0x000D },
        { "Gcommaaccent", 0x000E },
        { "Idotaccent", 0x000F },
        { "Imacron", 0x0010 },
        { "Iogonek", 0x0011 },
        { "Kcommaaccent", 0x0012 },
        { "Lacute", 0x0013 },
        { "Lcaron", 0x0014 },
        { "Lcommaaccent", 0x0015 },
        { "Nacute", 0x0016 },
        { "Ncaron", 0x0017 },
        { "Ncommaaccent", 0x0018 },
        { "Ohungarumlaut", 0x0019 },
        { "Omacron", 0x001A },
        { "Racute", 0x001B },
        { "Rcaron", 0x001C },
        { "Rcommaaccent", 0x001D },
        { "Sacute", 0x001E },
        { "Scedilla", 0x001F },
        { "Scommaaccent", 0x0020 },
        { "Tcaron", 0x0021 },
        { "Tcommaaccent", 0x0022 },
        { "Uhungarumlaut", 0x0023 },
        { "Umacron", 0x0024 },
        { "Uogonek", 0x0025 },
        { "Uring", 0x0026 },
        { "Zacute", 0x0027 },
        { "Zdotaccent", 0x0028 },
        { "abreve", 0x0029 },
        { "amacron", 0x002A },
        { "aogonek", 0x002B },
        { "cacute", 0x002C },
        { "ccaron", 0x002D },
        { "commaaccent", 0x002E },
        { "dcaron", 0x002F },
        { "dcroat", 0x0030 },
        { "ecaron", 0x0031 },
        { "edotaccent", 0x0032 },
        { "emacron", 0x0033 },
        { "eogonek", 0x0034 },
        { "gbreve", 0x0035 },
        { "gcommaaccent", 0x0036 },
        { "greaterequal", 0x0037 },
        { "imacron", 0x0038 },
        { "iogonek", 0x0039 },
        { "kcommaaccent", 0x003A },
        { "lacute", 0x003B },
        { "lcaron", 0x003C },
        { "lcommaaccent", 0x003D },
        { "lessequal", 0x003E },
        { "lozenge", 0x003F },
        { "nacute", 0x0040 },
        { "ncaron", 0x0041 },
        { "ncommaaccent", 0x0042 },
        { "notequal", 0x0043 },
        { "ohungarumlaut", 0x0044 },
        { "omacron", 0x0045 },
        { "partialdiff", 0x0046 },
        { "racute", 0x0047 },
        { "radical", 0x0048 },
        { "rcaron", 0x0049 },
        { "rcommaaccent", 0x004A },
        { "sacute", 0x004B },
        { "scedilla", 0x004C },
        { "scommaaccent", 0x004D },
        { "summation", 0x004E },
        { "tcaron", 0x004F },
        { "tcommaaccent", 0x0050 },
        { "uhungarumlaut", 0x0051 },
        { "umacron", 0x0052 },
        { "uogonek", 0x0053 },
        { "uring", 0x0054 },
        { "zacute", 0x0055 },
        { "zdotaccent", 0x0056 },
        }
    },

    //
    // Code page 1250: Win 3.1 Eastern European
    //
    { 1250, EASTEUROPE_CHARSET, EASTEUROPE_GS_NAME, 218,
        {
        { "A", 0x0041 },
        { "Aacute", 0x00C1 },
        { "Abreve", 0x00C3 },
        { "Acircumflex", 0x00C2 },
        { "Adieresis", 0x00C4 },
        { "Aogonek", 0x00A5 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "Cacute", 0x00C6 },
        { "Ccaron", 0x00C8 },
        { "Ccedilla", 0x00C7 },
        { "D", 0x0044 },
        { "Dcaron", 0x00CF },
        { "Dcroat", 0x00D0 },
        { "E", 0x0045 },
        { "Eacute", 0x00C9 },
        { "Ecaron", 0x00CC },
        { "Edieresis", 0x00CB },
        { "Eogonek", 0x00CA },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Iacute", 0x00CD },
        { "Icircumflex", 0x00CE },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "Lacute", 0x00C5 },
        { "Lcaron", 0x00BC },
        { "Lslash", 0x00A3 },
        { "M", 0x004D },
        { "N", 0x004E },
        { "Nacute", 0x00D1 },
        { "Ncaron", 0x00D2 },
        { "O", 0x004F },
        { "Oacute", 0x00D3 },
        { "Ocircumflex", 0x00D4 },
        { "Odieresis", 0x00D6 },
        { "Ohungarumlaut", 0x00D5 },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "Racute", 0x00C0 },
        { "Rcaron", 0x00D8 },
        { "S", 0x0053 },
        { "Sacute", 0x008C },
        { "Scaron", 0x008A },
        { "Scommaaccent", 0x00AA },
        { "T", 0x0054 },
        { "Tcaron", 0x008D },
        { "Tcommaaccent", 0x00DE },
        { "U", 0x0055 },
        { "Uacute", 0x00DA },
        { "Udieresis", 0x00DC },
        { "Uhungarumlaut", 0x00DB },
        { "Uring", 0x00D9 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Yacute", 0x00DD },
        { "Z", 0x005A },
        { "Zacute", 0x008F },
        { "Zcaron", 0x008E },
        { "Zdotaccent", 0x00AF },
        { "a", 0x0061 },
        { "aacute", 0x00E1 },
        { "abreve", 0x00E3 },
        { "acircumflex", 0x00E2 },
        { "acute", 0x00B4 },
        { "adieresis", 0x00E4 },
        { "ampersand", 0x0026 },
        { "aogonek", 0x00B9 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "breve", 0x00A2 },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "cacute", 0x00E6 },
        { "caron", 0x00A1 },
        { "ccaron", 0x00E8 },
        { "ccedilla", 0x00E7 },
        { "cedilla", 0x00B8 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "dcaron", 0x00EF },
        { "dcroat", 0x00F0 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "dotaccent", 0x00FF },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "ecaron", 0x00EC },
        { "edieresis", 0x00EB },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "eogonek", 0x00EA },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "germandbls", 0x00DF },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hungarumlaut", 0x00BD },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "iacute", 0x00ED },
        { "icircumflex", 0x00EE },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "lacute", 0x00E5 },
        { "lcaron", 0x00BE },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "lslash", 0x00B3 },
        { "m", 0x006D },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nacute", 0x00F1 },
        { "nbspace", 0x00A0 },
        { "ncaron", 0x00F2 },
        { "nine", 0x0039 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "oacute", 0x00F3 },
        { "ocircumflex", 0x00F4 },
        { "odieresis", 0x00F6 },
        { "ogonek", 0x00B2 },
        { "ohungarumlaut", 0x00F5 },
        { "one", 0x0031 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "racute", 0x00E0 },
        { "rcaron", 0x00F8 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "sacute", 0x009C },
        { "scaron", 0x009A },
        { "scommaaccent", 0x00BA },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "t", 0x0074 },
        { "tcaron", 0x009D },
        { "tcommaaccent", 0x00FE },
        { "three", 0x0033 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "u", 0x0075 },
        { "uacute", 0x00FA },
        { "udieresis", 0x00FC },
        { "uhungarumlaut", 0x00FB },
        { "underscore", 0x005F },
        { "uring", 0x00F9 },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "yacute", 0x00FD },
        { "z", 0x007A },
        { "zacute", 0x009F },
        { "zcaron", 0x009E },
        { "zdotaccent", 0x00BF },
        { "zero", 0x0030 }
        }
    },

    //
    // !!SPECIAL!! Code page SYMBOL_CODEPAGE(4): Symbol
    //
    { SYMBOL_CODEPAGE, SYMBOL_CHARSET, SYMBOL_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 1251: Win 3.1 Cyrillic
    //
    { 1251, RUSSIAN_CHARSET, CYRILLIC_GS_NAME, 222,
        {
        { "A", 0x0041 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Euro", 0x0088 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "M", 0x004D },
        { "N", 0x004E },
        { "O", 0x004F },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "T", 0x0054 },
        { "U", 0x0055 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Z", 0x005A },
        { "a", 0x0061 },
        { "afii10017", 0x00C0 },
        { "afii10018", 0x00C1 },
        { "afii10019", 0x00C2 },
        { "afii10020", 0x00C3 },
        { "afii10021", 0x00C4 },
        { "afii10022", 0x00C5 },
        { "afii10023", 0x00A8 },
        { "afii10024", 0x00C6 },
        { "afii10025", 0x00C7 },
        { "afii10026", 0x00C8 },
        { "afii10027", 0x00C9 },
        { "afii10028", 0x00CA },
        { "afii10029", 0x00CB },
        { "afii10030", 0x00CC },
        { "afii10031", 0x00CD },
        { "afii10032", 0x00CE },
        { "afii10033", 0x00CF },
        { "afii10034", 0x00D0 },
        { "afii10035", 0x00D1 },
        { "afii10036", 0x00D2 },
        { "afii10037", 0x00D3 },
        { "afii10038", 0x00D4 },
        { "afii10039", 0x00D5 },
        { "afii10040", 0x00D6 },
        { "afii10041", 0x00D7 },
        { "afii10042", 0x00D8 },
        { "afii10043", 0x00D9 },
        { "afii10044", 0x00DA },
        { "afii10045", 0x00DB },
        { "afii10046", 0x00DC },
        { "afii10047", 0x00DD },
        { "afii10048", 0x00DE },
        { "afii10049", 0x00DF },
        { "afii10050", 0x00A5 },
        { "afii10051", 0x0080 },
        { "afii10052", 0x0081 },
        { "afii10053", 0x00AA },
        { "afii10054", 0x00BD },
        { "afii10055", 0x00B2 },
        { "afii10056", 0x00AF },
        { "afii10057", 0x00A3 },
        { "afii10058", 0x008A },
        { "afii10059", 0x008C },
        { "afii10060", 0x008E },
        { "afii10061", 0x008D },
        { "afii10062", 0x00A1 },
        { "afii10065", 0x00E0 },
        { "afii10066", 0x00E1 },
        { "afii10067", 0x00E2 },
        { "afii10068", 0x00E3 },
        { "afii10069", 0x00E4 },
        { "afii10070", 0x00E5 },
        { "afii10071", 0x00B8 },
        { "afii10072", 0x00E6 },
        { "afii10073", 0x00E7 },
        { "afii10074", 0x00E8 },
        { "afii10075", 0x00E9 },
        { "afii10076", 0x00EA },
        { "afii10077", 0x00EB },
        { "afii10078", 0x00EC },
        { "afii10079", 0x00ED },
        { "afii10080", 0x00EE },
        { "afii10081", 0x00EF },
        { "afii10082", 0x00F0 },
        { "afii10083", 0x00F1 },
        { "afii10084", 0x00F2 },
        { "afii10085", 0x00F3 },
        { "afii10086", 0x00F4 },
        { "afii10087", 0x00F5 },
        { "afii10088", 0x00F6 },
        { "afii10089", 0x00F7 },
        { "afii10090", 0x00F8 },
        { "afii10091", 0x00F9 },
        { "afii10092", 0x00FA },
        { "afii10093", 0x00FB },
        { "afii10094", 0x00FC },
        { "afii10095", 0x00FD },
        { "afii10096", 0x00FE },
        { "afii10097", 0x00FF },
        { "afii10098", 0x00B4 },
        { "afii10099", 0x0090 },
        { "afii10100", 0x0083 },
        { "afii10101", 0x00BA },
        { "afii10102", 0x00BE },
        { "afii10103", 0x00B3 },
        { "afii10104", 0x00BF },
        { "afii10105", 0x00BC },
        { "afii10106", 0x009A },
        { "afii10107", 0x009C },
        { "afii10108", 0x009E },
        { "afii10109", 0x009D },
        { "afii10110", 0x00A2 },
        { "afii10145", 0x008F },
        { "afii10193", 0x009F },
        { "afii61352", 0x00B9 },
        { "ampersand", 0x0026 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dollar", 0x0024 },
        { "e", 0x0065 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "mu", 0x00B5 },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "one", 0x0031 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "t", 0x0074 },
        { "three", 0x0033 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "u", 0x0075 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "z", 0x007A },
        { "zero", 0x0030 },
        }
    },

    //
    // Code page 1252: Win 3.1 US
    //
    { 1252, ANSI_CHARSET, ANSI_GS_NAME, 218,
        {
        { "A", 0x0041 },
        { "AE", 0x00C6 },
        { "Aacute", 0x00C1 },
        { "Acircumflex", 0x00C2 },
        { "Adieresis", 0x00C4 },
        { "Agrave", 0x00C0 },
        { "Aring", 0x00C5 },
        { "Atilde", 0x00C3 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "Ccedilla", 0x00C7 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Eacute", 0x00C9 },
        { "Ecircumflex", 0x00CA },
        { "Edieresis", 0x00CB },
        { "Egrave", 0x00C8 },
        { "Eth", 0x00D0 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Iacute", 0x00CD },
        { "Icircumflex", 0x00CE },
        { "Idieresis", 0x00CF },
        { "Igrave", 0x00CC },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "M", 0x004D },
        { "N", 0x004E },
        { "Ntilde", 0x00D1 },
        { "O", 0x004F },
        { "OE", 0x008C },
        { "Oacute", 0x00D3 },
        { "Ocircumflex", 0x00D4 },
        { "Odieresis", 0x00D6 },
        { "Ograve", 0x00D2 },
        { "Oslash", 0x00D8 },
        { "Otilde", 0x00D5 },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "Scaron", 0x008A },
        { "T", 0x0054 },
        { "Thorn", 0x00DE },
        { "U", 0x0055 },
        { "Uacute", 0x00DA },
        { "Ucircumflex", 0x00DB },
        { "Udieresis", 0x00DC },
        { "Ugrave", 0x00D9 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Yacute", 0x00DD },
        { "Ydieresis", 0x009F },
        { "Z", 0x005A },
        { "Zcaron", 0x008E },
        { "a", 0x0061 },
        { "aacute", 0x00E1 },
        { "acircumflex", 0x00E2 },
        { "acute", 0x00B4 },
        { "adieresis", 0x00E4 },
        { "ae", 0x00E6 },
        { "agrave", 0x00E0 },
        { "ampersand", 0x0026 },
        { "aring", 0x00E5 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "atilde", 0x00E3 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "ccedilla", 0x00E7 },
        { "cedilla", 0x00B8 },
        { "cent", 0x00A2 },
        { "circumflex", 0x0088 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "ecircumflex", 0x00EA },
        { "edieresis", 0x00EB },
        { "egrave", 0x00E8 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "eth", 0x00F0 },
        { "exclam", 0x0021 },
        { "exclamdown", 0x00A1 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "germandbls", 0x00DF },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "iacute", 0x00ED },
        { "icircumflex", 0x00EE },
        { "idieresis", 0x00EF },
        { "igrave", 0x00EC },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "macron", 0x00AF },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "ntilde", 0x00F1 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "oacute", 0x00F3 },
        { "ocircumflex", 0x00F4 },
        { "odieresis", 0x00F6 },
        { "oe", 0x009C },
        { "ograve", 0x00F2 },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "ordfeminine", 0x00AA },
        { "ordmasculine", 0x00BA },
        { "oslash", 0x00F8 },
        { "otilde", 0x00F5 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "questiondown", 0x00BF },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "scaron", 0x009A },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "thorn", 0x00FE },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "tilde", 0x0098 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "uacute", 0x00FA },
        { "ucircumflex", 0x00FB },
        { "udieresis", 0x00FC },
        { "ugrave", 0x00F9 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "yacute", 0x00FD },
        { "ydieresis", 0x00FF },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zcaron", 0x009E },
        { "zero", 0x0030 },
        }
    },

    //
    // Code page 1253: Win 3.1 Greek
    //
    { 1253, GREEK_CHARSET, GREEK_GS_NAME, 207,
        {
        { "A", 0x0041 },
        { "Alpha", 0x00C1 },
        { "Alphatonos", 0x00A2 },
        { "B", 0x0042 },
        { "Beta", 0x00C2 },
        { "C", 0x0043 },
        { "Chi", 0x00D7 },
        { "D", 0x0044 },
        { "Delta", 0x00C4 },
        { "E", 0x0045 },
        { "Epsilon", 0x00C5 },
        { "Epsilontonos", 0x00B8 },
        { "Eta", 0x00C7 },
        { "Etatonos", 0x00B9 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "Gamma", 0x00C3 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Iota", 0x00C9 },
        { "Iotadieresis", 0x00DA },
        { "Iotatonos", 0x00BA },
        { "J", 0x004A },
        { "K", 0x004B },
        { "Kappa", 0x00CA },
        { "L", 0x004C },
        { "Lambda", 0x00CB },
        { "M", 0x004D },
        { "Mu", 0x00CC },
        { "N", 0x004E },
        { "Nu", 0x00CD },
        { "O", 0x004F },
        { "Omega", 0x00D9 },
        { "Omegatonos", 0x00BF },
        { "Omicron", 0x00CF },
        { "Omicrontonos", 0x00BC },
        { "P", 0x0050 },
        { "Phi", 0x00D6 },
        { "Pi", 0x00D0 },
        { "Psi", 0x00D8 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "Rho", 0x00D1 },
        { "S", 0x0053 },
        { "Sigma", 0x00D3 },
        { "T", 0x0054 },
        { "Tau", 0x00D4 },
        { "Theta", 0x00C8 },
        { "U", 0x0055 },
        { "Upsilon", 0x00D5 },
        { "Upsilondieresis", 0x00DB },
        { "Upsilontonos", 0x00BE },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Xi", 0x00CE },
        { "Y", 0x0059 },
        { "Z", 0x005A },
        { "Zeta", 0x00C6 },
        { "a", 0x0061 },
        { "afii00208", 0x00AF },
        { "alpha", 0x00E1 },
        { "alphatonos", 0x00DC },
        { "ampersand", 0x0026 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "beta", 0x00E2 },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "chi", 0x00F7 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "delta", 0x00E4 },
        { "dieresis", 0x00A8 },
        { "dieresistonos", 0x00A1 },
        { "dollar", 0x0024 },
        { "e", 0x0065 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "epsilon", 0x00E5 },
        { "epsilontonos", 0x00DD },
        { "equal", 0x003D },
        { "eta", 0x00E7 },
        { "etatonos", 0x00DE },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "gamma", 0x00E3 },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "iota", 0x00E9 },
        { "iotadieresis", 0x00FA },
        { "iotadieresistonos", 0x00C0 },
        { "iotatonos", 0x00DF },
        { "j", 0x006A },
        { "k", 0x006B },
        { "kappa", 0x00EA },
        { "l", 0x006C },
        { "lambda", 0x00EB },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "mu", 0x00B5 },
        { "mu", 0x00EC },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "nu", 0x00ED },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "omega", 0x00F9 },
        { "omegatonos", 0x00FE },
        { "omicron", 0x00EF },
        { "omicrontonos", 0x00FC },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "ordfeminine", 0x00AA },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "phi", 0x00F6 },
        { "pi", 0x00F0 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "psi", 0x00F8 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "rho", 0x00F1 },
        { "s", 0x0073 },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "sigma", 0x00F3 },
        { "sigma1", 0x00F2 },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "tau", 0x00F4 },
        { "theta", 0x00E8 },
        { "three", 0x0033 },
        { "threesuperior", 0x00B3 },
        { "tonos", 0x00B4 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "underscore", 0x005F },
        { "upsilon", 0x00F5 },
        { "upsilon-dieresistonos", 0x00E0},
        { "upsilondieresis", 0x00FB },
        { "upsilontonos", 0x00FD },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "xi", 0x00EE },
        { "y", 0x0079 },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zero", 0x0030 },
        { "zeta", 0x00E6 },
        }
    },

    //
    // Code page 1254: Win 3.1 Turkish
    //
    { 1254, TURKISH_CHARSET, TURKISH_GS_NAME, 216,
        {
        { "A", 0x0041 },
        { "AE", 0x00C6 },
        { "Aacute", 0x00C1 },
        { "Acircumflex", 0x00C2 },
        { "Adieresis", 0x00C4 },
        { "Agrave", 0x00C0 },
        { "Aring", 0x00C5 },
        { "Atilde", 0x00C3 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "Ccedilla", 0x00C7 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Eacute", 0x00C9 },
        { "Ecircumflex", 0x00CA },
        { "Edieresis", 0x00CB },
        { "Egrave", 0x00C8 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "Gbreve", 0x00D0 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Iacute", 0x00CD },
        { "Icircumflex", 0x00CE },
        { "Idieresis", 0x00CF },
        { "Idotaccent", 0x00DD },
        { "Igrave", 0x00CC },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "M", 0x004D },
        { "N", 0x004E },
        { "Ntilde", 0x00D1 },
        { "O", 0x004F },
        { "OE", 0x008C },
        { "Oacute", 0x00D3 },
        { "Ocircumflex", 0x00D4 },
        { "Odieresis", 0x00D6 },
        { "Ograve", 0x00D2 },
        { "Oslash", 0x00D8 },
        { "Otilde", 0x00D5 },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "Scaron", 0x008A },
        { "Scommaaccent", 0x00DE },
        { "T", 0x0054 },
        { "U", 0x0055 },
        { "Uacute", 0x00DA },
        { "Ucircumflex", 0x00DB },
        { "Udieresis", 0x00DC },
        { "Ugrave", 0x00D9 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Ydieresis", 0x009F },
        { "Z", 0x005A },
        { "a", 0x0061 },
        { "aacute", 0x00E1 },
        { "acircumflex", 0x00E2 },
        { "acute", 0x00B4 },
        { "adieresis", 0x00E4 },
        { "ae", 0x00E6 },
        { "agrave", 0x00E0 },
        { "ampersand", 0x0026 },
        { "aring", 0x00E5 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "atilde", 0x00E3 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "ccedilla", 0x00E7 },
        { "cedilla", 0x00B8 },
        { "cent", 0x00A2 },
        { "circumflex", 0x0088 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "dotlessi", 0x00FD },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "ecircumflex", 0x00EA },
        { "edieresis", 0x00EB },
        { "egrave", 0x00E8 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "exclamdown", 0x00A1 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "gbreve", 0x00F0 },
        { "germandbls", 0x00DF },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "iacute", 0x00ED },
        { "icircumflex", 0x00EE },
        { "idieresis", 0x00EF },
        { "igrave", 0x00EC },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "macron", 0x00AF },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "ntilde", 0x00F1 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "oacute", 0x00F3 },
        { "ocircumflex", 0x00F4 },
        { "odieresis", 0x00F6 },
        { "oe", 0x009C },
        { "ograve", 0x00F2 },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "ordfeminine", 0x00AA },
        { "ordmasculine", 0x00BA },
        { "oslash", 0x00F8 },
        { "otilde", 0x00F5 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "questiondown", 0x00BF },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "scaron", 0x009A },
        { "scommaaccent", 0x00FE },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "tilde", 0x0098 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "uacute", 0x00FA },
        { "ucircumflex", 0x00FB },
        { "udieresis", 0x00FC },
        { "ugrave", 0x00F9 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "ydieresis", 0x00FF },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zero", 0x0030 },
        }
    },

    //
    // Code page 1255: Hebrew
    //
    { 1255, HEBREW_CHARSET, HEBREW_GS_NAME, 223,
        {
        { ".notdef", 0x0081 },
        { ".notdef", 0x008A },
        { ".notdef", 0x008C },
        { ".notdef", 0x008D },
        { ".notdef", 0x008E },
        { ".notdef", 0x008F },
        { ".notdef", 0x0090 },
        { ".notdef", 0x009A },
        { ".notdef", 0x009C },
        { ".notdef", 0x009D },
        { ".notdef", 0x009E },
        { ".notdef", 0x009F },
        { ".notdef", 0x00A1 },
        { ".notdef", 0x00AA },
        { ".notdef", 0x00B8 },
        { ".notdef", 0x00BA },
        { ".notdef", 0x00BF },
        { ".notdef", 0x00CA },
        { ".notdef", 0x00D7 },
        { ".notdef", 0x00D8 },
        { ".notdef", 0x00D9 },
        { ".notdef", 0x00DA },
        { ".notdef", 0x00DB },
        { ".notdef", 0x00DC },
        { ".notdef", 0x00DD },
        { ".notdef", 0x00DE },
        { ".notdef", 0x00DF },
        { ".notdef", 0x00FB },
        { ".notdef", 0x00FC },
        { ".notdef", 0x00FF },
        { "A", 0x0041 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "M", 0x004D },
        { "N", 0x004E },
        { "O", 0x004F },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "T", 0x0054 },
        { "U", 0x0055 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Z", 0x005A },
        { "a", 0x0061 },
        { "acute", 0x00B4 },
        { "afii299", 0x00FD },
        { "afii300", 0x00FE },
        { "afii57636", 0x00A4 },
        { "afii57645", 0x00CE },
        { "afii57658", 0x00D3 },
        { "afii57664", 0x00E0 },
        { "afii57665", 0x00E1 },
        { "afii57666", 0x00E2 },
        { "afii57667", 0x00E3 },
        { "afii57668", 0x00E4 },
        { "afii57669", 0x00E5 },
        { "afii57670", 0x00E6 },
        { "afii57671", 0x00E7 },
        { "afii57672", 0x00E8 },
        { "afii57673", 0x00E9 },
        { "afii57674", 0x00EA },
        { "afii57675", 0x00EB },
        { "afii57676", 0x00EC },
        { "afii57677", 0x00ED },
        { "afii57678", 0x00EE },
        { "afii57679", 0x00EF },
        { "afii57680", 0x00F0 },
        { "afii57681", 0x00F1 },
        { "afii57682", 0x00F2 },
        { "afii57683", 0x00F3 },
        { "afii57684", 0x00F4 },
        { "afii57685", 0x00F5 },
        { "afii57686", 0x00F6 },
        { "afii57687", 0x00F7 },
        { "afii57688", 0x00F8 },
        { "afii57689", 0x00F9 },
        { "afii57690", 0x00FA },
        { "afii57716", 0x00D4 },
        { "afii57717", 0x00D5 },
        { "afii57718", 0x00D6 },
        { "afii57793", 0x00C4 },
        { "afii57794", 0x00C5 },
        { "afii57795", 0x00C6 },
        { "afii57796", 0x00CB },
        { "afii57797", 0x00C8 },
        { "afii57798", 0x00C7 },
        { "afii57799", 0x00C0 },
        { "afii57800", 0x00C2 },
        { "afii57801", 0x00C1 },
        { "afii57802", 0x00C3 },
        { "afii57803", 0x00D2 },
        { "afii57804", 0x00D1 },
        { "afii57806", 0x00C9 },
        { "afii57807", 0x00CC },
        { "afii57839", 0x00CD },
        { "afii57841", 0x00CF },
        { "afii57842", 0x00D0 },
        { "ampersand", 0x0026 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "cent", 0x00A2 },
        { "circumflex", 0x0088 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "dollar", 0x0024 },
        { "e", 0x0065 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "macron", 0x00AF },
        { "mu", 0x00B5 },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "tilde", 0x0098 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zero", 0x0030 }
        }
    },

    //
    // Code page 1256: Arabic
    //
    { 1256, ARABIC_CHARSET, ARABIC_GS_NAME, 215,
        {
        { "A", 0x0041 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "J", 0x004A },
        { "K", 0x004B },
        { "L", 0x004C },
        { "M", 0x004D },
        { "N", 0x004E },
        { "O", 0x004F },
        { "OE", 0x008C },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "S", 0x0053 },
        { "T", 0x0054 },
        { "U", 0x0055 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Z", 0x005A },
        { "a", 0x0061 },
        { "acircumflex", 0x00E2 },
        { "acute", 0x00B4 },
        { "afii299", 0x00FD },
        { "afii300", 0x00FE },
        { "afii301", 0x009E },
        { "afii57388", 0x00A1 },
        { "afii57403", 0x00BA },
        { "afii57407", 0x00BF },
        { "afii57409", 0x00C1 },
        { "afii57410", 0x00C2 },
        { "afii57411", 0x00C3 },
        { "afii57412", 0x00C4 },
        { "afii57413", 0x00C5 },
        { "afii57414", 0x00C6 },
        { "afii57415", 0x00C7 },
        { "afii57416", 0x00C8 },
        { "afii57417", 0x00C9 },
        { "afii57418", 0x00CA },
        { "afii57419", 0x00CB },
        { "afii57420", 0x00CC },
        { "afii57421", 0x00CD },
        { "afii57422", 0x00CE },
        { "afii57423", 0x00CF },
        { "afii57424", 0x00D0 },
        { "afii57425", 0x00D1 },
        { "afii57426", 0x00D2 },
        { "afii57427", 0x00D3 },
        { "afii57428", 0x00D4 },
        { "afii57429", 0x00D5 },
        { "afii57430", 0x00D6 },
        { "afii57431", 0x00D8 },
        { "afii57432", 0x00D9 },
        { "afii57433", 0x00DA },
        { "afii57434", 0x00DB },
        { "afii57440", 0x00DC },
        { "afii57441", 0x00DD },
        { "afii57442", 0x00DE },
        { "afii57443", 0x00DF },
        { "afii57444", 0x00E1 },
        { "afii57445", 0x00E3 },
        { "afii57446", 0x00E4 },
        { "afii57448", 0x00E6 },
        { "afii57449", 0x00EC },
        { "afii57450", 0x00ED },
        { "afii57451", 0x00F0 },
        { "afii57452", 0x00F1 },
        { "afii57453", 0x00F2 },
        { "afii57454", 0x00F3 },
        { "afii57455", 0x00F5 },
        { "afii57456", 0x00F6 },
        { "afii57457", 0x00F8 },
        { "afii57458", 0x00FA },
        { "afii57470", 0x00E5 },
        { "afii57506", 0x0081 },
        { "afii57507", 0x008D },
        { "afii57508", 0x008E },
        { "afii57509", 0x0090 },
        { "afii61664", 0x009D },
        { "agrave", 0x00E0 },
        { "ampersand", 0x0026 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "ccedilla", 0x00E7 },
        { "cedilla", 0x00B8 },
        { "cent", 0x00A2 },
        { "circumflex", 0x0088 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "degree", 0x00B0 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "ecircumflex", 0x00EA },
        { "edieresis", 0x00EB },
        { "egrave", 0x00E8 },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "florin", 0x0083 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "icircumflex", 0x00EE },
        { "idieresis", 0x00EF },
        { "j", 0x006A },
        { "k", 0x006B },
        { "l", 0x006C },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "m", 0x006D },
        { "macron", 0x00AF },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nbspace", 0x00A0 },
        { "nine", 0x0039 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "ocircumflex", 0x00F4 },
        { "oe", 0x009C },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "registered", 0x00AE },
        { "s", 0x0073 },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "twosuperior", 0x00B2 },
        { "u", 0x0075 },
        { "ucircumflex", 0x00FB },
        { "udieresis", 0x00FC },
        { "ugrave", 0x00F9 },
        { "underscore", 0x005F },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "yen", 0x00A5 },
        { "z", 0x007A },
        { "zero", 0x0030 }
        }
    },

    //
    // Code page 1257: Baltic
    //
    { 1257, BALTIC_CHARSET, BALTIC_GS_NAME, 223,
        {
        { ".notdef", 0x0081 },
        { ".notdef", 0x0083 },
        { ".notdef", 0x0088 },
        { ".notdef", 0x008A },
        { ".notdef", 0x008C },
        { ".notdef", 0x008D },
        { ".notdef", 0x008E },
        { ".notdef", 0x008F },
        { ".notdef", 0x0090 },
        { ".notdef", 0x0098 },
        { ".notdef", 0x009A },
        { ".notdef", 0x009C },
        { ".notdef", 0x009D },
        { ".notdef", 0x009E },
        { ".notdef", 0x009F },
        { ".notdef", 0x00A5 },
        { "A", 0x0041 },
        { "AE", 0x00AF },
        { "Adieresis", 0x00C4 },
        { "Amacron", 0x00C2 },
        { "Aogonek", 0x00C0 },
        { "Aring", 0x00C5 },
        { "B", 0x0042 },
        { "C", 0x0043 },
        { "Cacute", 0x00C3 },
        { "Ccaron", 0x00C8 },
        { "D", 0x0044 },
        { "E", 0x0045 },
        { "Eacute", 0x00C9 },
        { "Edot", 0x00CB },
        { "Emacron", 0x00C7 },
        { "Eogonek", 0x00C6 },
        { "Euro", 0x0080 },
        { "F", 0x0046 },
        { "G", 0x0047 },
        { "Gcedilla", 0x00CC },
        { "H", 0x0048 },
        { "I", 0x0049 },
        { "Imacron", 0x00CE },
        { "Iogonek", 0x00C1 },
        { "J", 0x004A },
        { "K", 0x004B },
        { "Kcedilla", 0x00CD },
        { "L", 0x004C },
        { "Lcedilla", 0x00CF },
        { "Lslash", 0x00D9 },
        { "M", 0x004D },
        { "N", 0x004E },
        { "Nacute", 0x00D1 },
        { "Ncedilla", 0x00D2 },
        { "O", 0x004F },
        { "Oacute", 0x00D3 },
        { "Odieresis", 0x00D6 },
        { "Omacron", 0x00D4 },
        { "Otilde", 0x00D5 },
        { "P", 0x0050 },
        { "Q", 0x0051 },
        { "R", 0x0052 },
        { "Rcedilla", 0x00AA },
        { "S", 0x0053 },
        { "Sacute", 0x00DA },
        { "Scaron", 0x00D0 },
        { "T", 0x0054 },
        { "U", 0x0055 },
        { "Udieresis", 0x00DC },
        { "Umacron", 0x00DB },
        { "Uogonek", 0x00D8 },
        { "V", 0x0056 },
        { "W", 0x0057 },
        { "X", 0x0058 },
        { "Y", 0x0059 },
        { "Z", 0x005A },
        { "Zacute", 0x00CA },
        { "Zcaron", 0x00DE },
        { "Zdotaccent", 0x00DD },
        { "a", 0x0061 },
        { "acute", 0x00B4 },
        { "adieresis", 0x00E4 },
        { "ae", 0x00BF },
        { "amacron", 0x00E2 },
        { "ampersand", 0x0026 },
        { "aogonek", 0x00E0 },
        { "aring", 0x00E5 },
        { "asciicircum", 0x005E },
        { "asciitilde", 0x007E },
        { "asterisk", 0x002A },
        { "at", 0x0040 },
        { "b", 0x0062 },
        { "backslash", 0x005C },
        { "bar", 0x007C },
        { "braceleft", 0x007B },
        { "braceright", 0x007D },
        { "bracketleft", 0x005B },
        { "bracketright", 0x005D },
        { "breve", 0x00A2 },
        { "brokenbar", 0x00A6 },
        { "bullet", 0x0095 },
        { "c", 0x0063 },
        { "cacute", 0x00E3 },
        { "caron", 0x00A1 },
        { "ccaron", 0x00E8 },
        { "cedilla", 0x00B8 },
        { "colon", 0x003A },
        { "comma", 0x002C },
        { "copyright", 0x00A9 },
        { "currency", 0x00A4 },
        { "d", 0x0064 },
        { "dagger", 0x0086 },
        { "daggerdbl", 0x0087 },
        { "dieresis", 0x00A8 },
        { "divide", 0x00F7 },
        { "dollar", 0x0024 },
        { "dotaccent", 0x00FF },
        { "e", 0x0065 },
        { "eacute", 0x00E9 },
        { "edot", 0x00EB },
        { "eight", 0x0038 },
        { "ellipsis", 0x0085 },
        { "emacron", 0x00E7 },
        { "emdash", 0x0097 },
        { "endash", 0x0096 },
        { "eogonek", 0x00E6 },
        { "equal", 0x003D },
        { "exclam", 0x0021 },
        { "f", 0x0066 },
        { "five", 0x0035 },
        { "four", 0x0034 },
        { "g", 0x0067 },
        { "gcedilla", 0x00EC },
        { "germandbls", 0x00DF },
        { "grave", 0x0060 },
        { "greater", 0x003E },
        { "guillemotleft", 0x00AB },
        { "guillemotright", 0x00BB },
        { "guilsinglleft", 0x008B },
        { "guilsinglright", 0x009B },
        { "h", 0x0068 },
        { "hyphen", 0x002D },
        { "i", 0x0069 },
        { "imacron", 0x00EE },
        { "iogonek", 0x00E1 },
        { "j", 0x006A },
        { "k", 0x006B },
        { "kcedilla", 0x00ED },
        { "l", 0x006C },
        { "lcedilla", 0x00EF },
        { "less", 0x003C },
        { "logicalnot", 0x00AC },
        { "lslash", 0x00F9 },
        { "m", 0x006D },
        { "mu", 0x00B5 },
        { "multiply", 0x00D7 },
        { "n", 0x006E },
        { "nacute", 0x00F1 },
        { "nbspace", 0x00A0 },
        { "ncedilla", 0x00F2 },
        { "nine", 0x0039 },
        { "numbersign", 0x0023 },
        { "o", 0x006F },
        { "oacute", 0x00F3 },
        { "odieresis", 0x00F6 },
        { "ogonek", 0x00B2 },
        { "omacron", 0x00F4 },
        { "one", 0x0031 },
        { "onehalf", 0x00BD },
        { "onequarter", 0x00BC },
        { "onesuperior", 0x00B9 },
        { "otilde", 0x00F5 },
        { "p", 0x0070 },
        { "paragraph", 0x00B6 },
        { "parenleft", 0x0028 },
        { "parenright", 0x0029 },
        { "percent", 0x0025 },
        { "period", 0x002E },
        { "periodcentered", 0x00B7 },
        { "perthousand", 0x0089 },
        { "plus", 0x002B },
        { "plusminus", 0x00B1 },
        { "q", 0x0071 },
        { "question", 0x003F },
        { "quotedbl", 0x0022 },
        { "quotedblbase", 0x0084 },
        { "quotedblleft", 0x0093 },
        { "quotedblright", 0x0094 },
        { "quoteleft", 0x0091 },
        { "quoteright", 0x0092 },
        { "quotesinglbase", 0x0082 },
        { "quotesingle", 0x0027 },
        { "r", 0x0072 },
        { "rcedilla", 0x00BA },
        { "registered", 0x00AE },
        { "ring", 0x00B0 },
        { "s", 0x0073 },
        { "sacute", 0x00FA },
        { "scaron", 0x00F0 },
        { "section", 0x00A7 },
        { "semicolon", 0x003B },
        { "seven", 0x0037 },
        { "sfthyphen", 0x00AD },
        { "six", 0x0036 },
        { "slash", 0x002F },
        { "space", 0x0020 },
        { "sterling", 0x00A3 },
        { "t", 0x0074 },
        { "three", 0x0033 },
        { "threequarters", 0x00BE },
        { "threesuperior", 0x00B3 },
        { "trademark", 0x0099 },
        { "two", 0x0032 },
        { "u", 0x0075 },
        { "udieresis", 0x00FC },
        { "umacron", 0x00FB },
        { "underscore", 0x005F },
        { "uogonek", 0x00F8 },
        { "v", 0x0076 },
        { "w", 0x0077 },
        { "x", 0x0078 },
        { "y", 0x0079 },
        { "z", 0x007A },
        { "zacute", 0x00EA },
        { "zcaron", 0x00FE },
        { "zdotaccent", 0x00FD },
        { "zero", 0x0030 }
        }
    },

    //
    // (jWinCharset) Placeholder for Composite Charset: CS_ANSI_RUS
    //
    // We can remove following two charsets since the driver does not support them.
    // However, we should change some other structures such as aStdCPList and 
    // CHARSETSUPPORT. To make it safer, I would like to keep them unchanged. 
    // Jack Jia,  4/5/00
    //         
    //
    { 0, RUSSIAN_CHARSET, ANSI_CYR_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // (jWinCharset) Placeholder for Composite Charset: CS_ANSI_RUS_EE_BAL_TURK
    //
    { 0, RUSSIAN_CHARSET, ANSI_CYR_EE_BAL_TURK_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 950: Chinese Big5
    //
    { 950, CHINESEBIG5_CHARSET, CHN_BIG5_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 936: Simplified Chinese
    //
    { 936, GB2312_CHARSET, CHN_SMPL_GBK_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 932: Japanese (Shift JIS)
    //
    { 932, SHIFTJIS_CHARSET, SHIFTJIS_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 932: Japanese (Shift JIS) 90msp
    //

    { 932, SHIFTJIS_CHARSET, SHIFTJIS_P_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 932: Japanese (Shift JIS 1983 character collection)
    //
    { 932, SHIFTJIS_CHARSET, SHIFTJIS_83PV_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 949: Korean (Hangeul)
    //
    { 949, HANGEUL_CHARSET, KSCMS_UHC_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 949: Korean (Hangeul) HW
    //
    { 949, HANGEUL_CHARSET, KSCMS_UHC_HW_GS_NAME, 0,
        {
        {"", }
        }
    },

    //
    // Code page 1361: Korean (Johab)
    //
    { 1361, JOHAB_CHARSET, KSC_JOHAB_GS_NAME, 0,
        {
        {"", }
        }
    }
};

//
// Mapping from family names to Windows FF_ family types.
//
#define NUM_FONT_FAM_TYPES 5

KEY FontFamilies[NUM_FONT_FAM_TYPES] =
{
    { "Roman",      FF_ROMAN        },
    { "Swiss",      FF_SWISS        },
    { "Decorative", FF_DECORATIVE   },
    { "Modern",     FF_MODERN       },
    { "Script",     FF_SCRIPT       }
};

TBL FamilyKeyTbl = { NUM_FONT_FAM_TYPES, FontFamilies };

//
// Mapping from pitch names to Windows FF_ ptich types.
//
#define NUM_FONT_PITCH_TYPES 3

KEY FontPitch[NUM_FONT_PITCH_TYPES] =
{
    { "Default",        DEFAULT_PITCH },
    { "Fixed",          FIXED_PITCH   },
    { "Proportional",   VARIABLE_PITCH}
};

TBL PitchKeyTbl = { NUM_FONT_PITCH_TYPES, FontPitch };

//
// Mapping from AFM Weight Token values to Windows Weight values.
//
#define NUM_FONT_WEIGHT_TYPES 16

KEY WeightKeys[NUM_FONT_WEIGHT_TYPES] =
{
    { "Light",              FW_NORMAL   },
    { "LightCondensed",     FW_NORMAL   },
    { "Book",               FW_NORMAL   },
    { "Medium",             FW_NORMAL   },
    { "Roman",              FW_NORMAL   },
    { "Regular",            FW_NORMAL   },
    { "Italic",             FW_NORMAL   },
    { "MediumCondensed",    FW_NORMAL   },
    { "Bold",               FW_BOLD     },
    { "BoldItalic",         FW_BOLD     },
    { "Demi",               FW_BOLD     },
    { "Poster",             FW_BOLD     },
    { "Heavy",              FW_BOLD     },
    { "Black",              FW_BOLD     },
    { "BlackCondensed",     FW_BOLD     },
    { "BoldCondensed",      FW_BOLD     }
};

#define NUM_FONT_WEIGHT_TYPES_CJK 27
KEY WeightKeysCJK[NUM_FONT_WEIGHT_TYPES_CJK] =
{
    { "Light",              FW_NORMAL   },
    { "LightCondensed",     FW_NORMAL   },
    { "Book",               FW_NORMAL   },
    { "Roman",              FW_NORMAL   },
    { "Regular",            FW_NORMAL   },
    { "Italic",             FW_NORMAL   },
    { "Medium",             FW_NORMAL   },
    { "MediumCondensed",    FW_NORMAL   },
    { "Bold",               FW_BOLD     },
    { "BoldItalic",         FW_BOLD     },
    { "Demi",               FW_BOLD     },
    { "Poster",             FW_BOLD     },
    { "Heavy",              FW_BOLD     },
    { "Black",              FW_BOLD     },
    { "BlackCondensed",     FW_BOLD     },
    { "BoldCondensed",      FW_BOLD     },
    { "W3",                 FW_NORMAL   },
    { "W3H",                FW_NORMAL   },
    { "W4",                 FW_NORMAL   },
    { "W5",                 FW_NORMAL   },
    { "W7",                 FW_BOLD     },
    { "W9",                 FW_BOLD     },

    { "regular",            FW_NORMAL   },
    { "heavy",              FW_BOLD     },
    { "Ultra",              FW_BOLD     },
    { "MA31",               FW_BOLD     },
    { "MB31",               FW_BOLD     },
};

TBL WeightKeyTbl[] =
{
    NUM_FONT_WEIGHT_TYPES,     WeightKeys,
    NUM_FONT_WEIGHT_TYPES_CJK, WeightKeysCJK
};


//
// Alias Family Tables.
// The first element is the base name and is the one displayed on the font menu
// name list. The rest of the elements are its alias names.
// (Basicall these alias names are of PostScript only. All the TrueType names
// which were originally there are disabled to fix Adobe bug #259664.)
//
// Make sure to have the same lists in pfmtontm.c too.
//

char *TimesAlias[] =
{"Times",
    "Times Roman",
    "TimesRoman",
    "Tms Rmn",
    "TmsRmn",
    "Varitimes",
    "Dutch",
    "TimesNewRomanPS",
    // "Times New Roman",
    NULL
};

char *HelveticaAlias[] =
{"Helvetica",
    "Helv",
    "Swiss",
    // "Arial",
    NULL
};

/*
char *CourierAlias[] =
{"Courier",
    "Courier New",
    NULL
};
*/

char *HelveticaNarrowAlias[] =
{"Helvetica-Narrow",
    "Helvetica Narrow",
    // "Arial-Narrow",
    // "Arial Narrow",
    NULL
};

char *PalatinoAlias[] =
{"Palatino",
    "Zapf Calligraphic",
    "ZapfCalligraphic",
    // "Bookman Antiqua",
    // "Book Antiqua",
    NULL
};

char *BookmanAlias[] =
{"Bookman",
    "ITC Bookman",
    // "Bookman Old Style",
    NULL
};

char *NewCenturySBAlias[] =
{"NewCenturySchlbk",
    "New Century Schoolbook",
    "NewCenturySchoolBook",
    // "Century Schoolbook",
    // "CenturySchoolBook",
    NULL
};

char *AvantGardeAlias[] =
{"AvantGarde",
    "ITC Avant Garde Gothic",
    "ITC Avant Garde",
    // "Century Gothic",
    NULL
};

char *ZapfChanceryAlias[] =
{"ZapfChancery",
    "ITC Zapf Chancery",
    // "Monotype Corsiva",
    NULL
};

char *ZapfDingbatsAlias[] =
{"ZapfDingbats",
    "Zapf Dingbats",
    "ITC Zapf Dingbats",
    // "Monotype Sorts",
    NULL
};

//
// Table of char width biases for average width computation. In order
// from 'a' to 'z'.
//
ULONG CharWidthBias[] =
{
    //   a    b    c    d    e    f    g    h    i    j    k    l    m    n
        64,  14,  27,  35, 100,  20,  14,  42,  63,   3,   6,  35,  20,  56,
    //   o    p    q    r    s    t    u    v    w    x    y    z
        56,  17,   4,  49,  56,  71,  31,  10,  18,   3,  18,   2
};

//
//
// Mapping from Adobe CJK Char Collection names to Win Codepage values.
//
#define NUM_CJK_CHAR_COLS 8

KEY CjkCollections[NUM_CJK_CHAR_COLS] =
{
    { "Adobe-CNS1-0",   CS_CHINESEBIG5  },
    { "Adobe-GB1-1",    CS_GB2312       },

    { "Adobe-Japan1-0", CS_SHIFTJIS83   },
    { "Adobe-Japan1-1", CS_SHIFTJIS     },
    { "Adobe-Japan1-2", CS_SHIFTJIS     },
    { "Adobe-Japan2-0", CS_SHIFTJIS     },

    { "Adobe-Korea1-0", CS_HANGEUL      },
    { "Adobe-Korea1-1", CS_HANGEUL      }
};

TBL CjkColTbl = { NUM_CJK_CHAR_COLS, CjkCollections };

PWCHAR CjkFnameTbl[8][CMAPS_PER_COL] =
{
    // Caution: each line has to match a CS in the CHSETSUPPORT enum list.

    { L"ucs2bg5.map", L"ucs2bg5.map", L"Unicnsh.PS",  L"Unicnsv.PS"  }, // CS_CHINESEBIG5
    { L"ucs2gbk.map", L"ucs2gbk.map", L"Unigbh.PS",   L"Unigbv.PS"   }, // CS_GB2312

    { L"ucs2msj.map", L"ucs2msj.map", L"Unijish.PS",  L"Unijisv.PS"  }, // CS_SHIFTJIS
    { L"ucs2msj.map", L"ucs2msj.map", L"Unijish.PS",  L"Unijisv.PS"  }, // CS_SHIFTJISP
    { L"ucs283h.map", L"ucs283v.map", L"Uni83h.PS",   L"Uni83v.PS"   }, // CS_SHIFTJIS83

    { L"ucs2uhc.map", L"ucs2uhc.map", L"UniKSh.PS",   L"UniKSv.PS"   }, // CS_HANGEUL
    { L"ucs2uhc.map", L"ucs2uhc.map", L"UniKSh.PS",   L"UniKSv.PS"   }, // CS_HANGEULHW
    { L"ucs2jhb.map", L"ucs2jhb.map", L"UniKSh.PS",   L"UniKSv.PS"   }, // CS_JOHAB
};

//
// PropCjkGsNames: a list of GlyphSet names of which font is proportional.
// (The last element has to be NULL.)
//
char* PropCjkGsNames[] =
{
    KSCMS_UHC_GS_NAME,
    SHIFTJIS_P_GS_HNAME,
    SHIFTJIS_P_GS_VNAME,
    KSCMS_UHC_GS_HNAME,
    KSCMS_UHC_GS_VNAME,
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\makentf\writentf.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    writentf.c

Abstract:

    Write a NTF file.

Environment:

    Windows NT PostScript driver.

Revision History:

    07/08/98 -ksuzuki-
        Modified to support -v(verbose) and -o(optimize) options.

    11/21/96 -slam-
        Created.

    dd-mm-yy -author-
        description

--*/


#include "writentf.h"

extern bVerbose;
extern bOptimize;

int __cdecl compareGlyphSet(const void *elem1, const void *elem2)
{
    PGLYPHSETDATA   *p1;
    PGLYPHSETDATA   *p2;
    PGLYPHSETDATA   pGlyphSet1;
    PGLYPHSETDATA   pGlyphSet2;
    DWORD           hashValue1, hashValue2;

    p1 = (PGLYPHSETDATA*)elem1;
    p2 = (PGLYPHSETDATA*)elem2;

    pGlyphSet1 = *p1;
    pGlyphSet2 = *p2;

    hashValue1 = HashKeyword(MK_PTR(pGlyphSet1, dwGlyphSetNameOffset));
    hashValue2 = HashKeyword(MK_PTR(pGlyphSet2, dwGlyphSetNameOffset));

    if (hashValue1 == hashValue2)
        return(0);
    else if (hashValue1 < hashValue2)
        return(-1);
    else
        return(1);
}


int __cdecl compareFontMtx(const void *elem1, const void *elem2)
{
    PNTM    *p1;
    PNTM    *p2;
    PNTM    pNTM1;
    PNTM    pNTM2;
    DWORD   hashValue1, hashValue2;

    p1 = (PNTM*)elem1;
    p2 = (PNTM*)elem2;

    pNTM1 = *p1;
    pNTM2 = *p2;

    hashValue1 = HashKeyword(MK_PTR(pNTM1, dwFontNameOffset));
    hashValue2 = HashKeyword(MK_PTR(pNTM2, dwFontNameOffset));

    if (hashValue1 == hashValue2)
        return(0);
    else if (hashValue1 < hashValue2)
        return(-1);
    else
        return(1);
}


BOOL
WriteNTF(
    IN  PWSTR           pwszNTFFile,
    IN  DWORD           dwGlyphSetCount,
    IN  DWORD           dwGlyphSetTotalSize,
    IN  PGLYPHSETDATA   *pGlyphSetData,
    IN  DWORD           dwFontMtxCount,
    IN  DWORD           dwFontMtxTotalSize,
    IN  PNTM            *pNTM
    )
{
    HANDLE              hNTFFile;
    NTF_FILEHEADER      fileHeader;
    PNTF_GLYPHSETENTRY  pGlyphSetEntry;
    PNTF_FONTMTXENTRY   pFontMtxEntry;
    ULONG               ulGlyphSetEntrySize;
    ULONG               ulFontMtxEntrySize;
    ULONG               ulByteWritten;
    ULONG               i, j;
    DWORD               dwOffset;
    DWORD               dwGlyphSetCount2, dwGlyphSetTotalSize2;
    PGLYPHSETDATA       pgsd;
    DWORD               dwEofMark = NTF_EOF_MARK;


    dwGlyphSetCount2 = dwGlyphSetTotalSize2 = 0;

    //
    // Count the number of glyphsets necessary or referenced and their total
    // size. When optimization option is specified, don't count the glyphsets
    // without reference mark.
    //
    for (i = 0; i < dwGlyphSetCount; i++)
    {
        if (!bOptimize || pGlyphSetData[i]->dwReserved[0])
        {
            dwGlyphSetCount2++;
            dwGlyphSetTotalSize2 += pGlyphSetData[i]->dwSize;
        }
    }

    if (!bOptimize && (dwGlyphSetTotalSize != dwGlyphSetTotalSize2))
    {
        ERR(("WriteNTF:total size mismatch on optimization\n"));
        return FALSE;
    }

    if (bVerbose)
    {
        printf("Number of glyphset:%ld(total:%ld)\n",
                        dwGlyphSetCount, dwGlyphSetTotalSize);
        if (bOptimize)
        {
            printf("Number of glyphset referenced:%ld(total:%ld)\n",
                                dwGlyphSetCount2, dwGlyphSetTotalSize2);
        }

        printf("Number of font matrix:%ld(total:%ld)\n",
                        dwFontMtxCount, dwFontMtxTotalSize);

        printf("\n");
    }

    // Fill in NTF file header.

    fileHeader.dwSignature = NTF_FILE_MAGIC;
    fileHeader.dwDriverType = NTF_DRIVERTYPE_PS;
    fileHeader.dwVersion = NTF_VERSION_NUMBER;

    for (i = 0; i < 5; i++)
        fileHeader.dwReserved[i] = 0;

    fileHeader.dwGlyphSetCount = dwGlyphSetCount2;
    fileHeader.dwFontMtxCount = dwFontMtxCount;

    ulGlyphSetEntrySize = dwGlyphSetCount2 * sizeof(NTF_GLYPHSETENTRY);
    ulFontMtxEntrySize = dwFontMtxCount * sizeof(NTF_FONTMTXENTRY);

    fileHeader.dwGlyphSetOffset = sizeof(NTF_FILEHEADER);

    fileHeader.dwFontMtxOffset = fileHeader.dwGlyphSetOffset + ulGlyphSetEntrySize;

    // Fill in glyph set entries.

    qsort(pGlyphSetData, dwGlyphSetCount, sizeof(PGLYPHSETDATA), compareGlyphSet);

    pGlyphSetEntry = MemAllocZ(ulGlyphSetEntrySize);
    if (!pGlyphSetEntry)
    {
        ERR(("WriteNTF:MemAllocZ\n"));
        return(FALSE);
    }

    dwOffset = fileHeader.dwFontMtxOffset + ulFontMtxEntrySize;

    for (i = j = 0; i < dwGlyphSetCount; i++)
    {
        pgsd = pGlyphSetData[i];

        // If no refernce mark is set with optimization option, ignore this
        // glyphset data.
        if (bOptimize && !(pgsd->dwReserved[0]))
        {
            pgsd = NULL;
        }

        if (pgsd)
        {
            pGlyphSetEntry[j].dwNameOffset   = dwOffset + pgsd->dwGlyphSetNameOffset;
            pGlyphSetEntry[j].dwHashValue    = HashKeyword(MK_PTR(pgsd, dwGlyphSetNameOffset));
            pGlyphSetEntry[j].dwDataSize     = pgsd->dwSize;
            pGlyphSetEntry[j].dwDataOffset   = dwOffset;
            pGlyphSetEntry[j].dwGlyphSetType = 0;
            pGlyphSetEntry[j].dwFlags        = 0;
            pGlyphSetEntry[j].dwReserved[0]  = 0;
            pGlyphSetEntry[j].dwReserved[1]  = 0;

            dwOffset += pgsd->dwSize;
            j++;
        }
    }

    // Fill in font metrics entries.

    qsort(pNTM, dwFontMtxCount, sizeof(PNTM), compareFontMtx);

    pFontMtxEntry = MemAllocZ(ulFontMtxEntrySize);
    if (!pFontMtxEntry)
    {
        ERR(("WriteNTF:MemAllocZ\n"));
        MemFree(pGlyphSetEntry);
        return(FALSE);
    }

    if (dwOffset != (fileHeader.dwFontMtxOffset +
                     ulFontMtxEntrySize +
                     dwGlyphSetTotalSize2))
    {
        ERR(("WriteNTF:dwOffset\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        return(FALSE);
    }
    for (i = 0; i < dwFontMtxCount; i++)
    {
        pFontMtxEntry[i].dwFontNameOffset = dwOffset + pNTM[i]->dwFontNameOffset;
        pFontMtxEntry[i].dwHashValue      = HashKeyword(MK_PTR(pNTM[i], dwFontNameOffset));
        pFontMtxEntry[i].dwDataSize       = pNTM[i]->dwSize;
        pFontMtxEntry[i].dwDataOffset     = dwOffset;
        pFontMtxEntry[i].dwVersion        = 0;
        pFontMtxEntry[i].dwReserved[0]    = 0;
        pFontMtxEntry[i].dwReserved[1]    = 0;
        pFontMtxEntry[i].dwReserved[2]    = 0;

        dwOffset += pNTM[i]->dwSize;
    }


    //
    // Begin to write everything into the NTF file!
    //
    hNTFFile = CreateFile(pwszNTFFile, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                          CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hNTFFile == INVALID_HANDLE_VALUE)
    {
        ERR(("WriteNTF:CreateFile\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        return(FALSE);
    }

    if (!WriteFile(hNTFFile, (LPVOID)&fileHeader, sizeof(NTF_FILEHEADER),
                   (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
            || (ulByteWritten != sizeof(NTF_FILEHEADER)))
    {
        ERR(("WriteNTF:WriteFile\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        CloseHandle(hNTFFile);
        return(FALSE);
    }
    if (bVerbose)
    {
        char s[5];
        s[0] = (char)(fileHeader.dwSignature >> 24);
        s[1] = (char)(fileHeader.dwSignature >> 16);
        s[2] = (char)(fileHeader.dwSignature >>  8);
        s[3] = (char)(fileHeader.dwSignature      );
        s[4] = '\0';
        printf("NTF_FILEHEADER:dwSignature:%08X('%s')\n", fileHeader.dwSignature, s);
        s[0] = (char)(fileHeader.dwDriverType >> 24);
        s[1] = (char)(fileHeader.dwDriverType >> 16);
        s[2] = (char)(fileHeader.dwDriverType >>  8);
        s[3] = (char)(fileHeader.dwDriverType      );
        s[4] = '\0';
        printf("NTF_FILEHEADER:dwDriverType:%08X('%s')\n", fileHeader.dwDriverType, s);
        printf("NTF_FILEHEADER:dwVersion:%08X\n", fileHeader.dwVersion);
        printf("NTF_FILEHEADER:dwGlyphSetCount:%ld\n", fileHeader.dwGlyphSetCount);
        printf("NTF_FILEHEADER:dwFontMtxCount:%ld\n", fileHeader.dwFontMtxCount);
        printf("\n");
    }

    if (!WriteFile(hNTFFile, (LPVOID)pGlyphSetEntry, ulGlyphSetEntrySize,
                   (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
            || (ulByteWritten != ulGlyphSetEntrySize))
    {
        ERR(("WriteNTF:WriteFile\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        CloseHandle(hNTFFile);
        return(FALSE);
    }
    if (bVerbose)
    {
        for (i = 0; i < dwGlyphSetCount2; i++)
        {
            printf("NTF_GLYPHSETENTRY for GLYPHSETDATA #%d\n", i + 1);
            printf("NTF_GLYPHSETENTRY:dwHashValue:%08X\n", pGlyphSetEntry[i].dwHashValue);
            printf("NTF_GLYPHSETENTRY:dwDataSize:%ld\n", pGlyphSetEntry[i].dwDataSize);
            printf("\n");
        }
    }

    if (!WriteFile(hNTFFile, (LPVOID)pFontMtxEntry, ulFontMtxEntrySize,
                   (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
            || (ulByteWritten != ulFontMtxEntrySize))
    {
        ERR(("WriteNTF:WriteFile\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        CloseHandle(hNTFFile);
        return(FALSE);
    }
    if (bVerbose)
    {
        for (i = 0; i < dwFontMtxCount; i++)
        {
            printf("NTF_FONTMTXENTRY for NTM #%d\n", i + 1);
            printf("NTF_FONTMTXENTRY:dwHashValue:%08X\n", pFontMtxEntry[i].dwHashValue);
            printf("NTF_FONTMTXENTRY:dwDataSize:%ld\n", pFontMtxEntry[i].dwDataSize);
            printf("NTF_FONTMTXENTRY:dwVersion:%08X\n", pFontMtxEntry[i].dwVersion);
            printf("\n");
        }
    }

    for (i = j = 0; i < dwGlyphSetCount; i++)
    {
        pgsd = pGlyphSetData[i];

        // If no refernce mark is set with optimization option, ignore this
        // glyphset data.
        if (bOptimize && !(pgsd->dwReserved[0]))
        {
            pgsd = NULL;
        }

        if (pgsd)
        {
            LONG lBytes, lSize = pgsd->dwSize;
            PBYTE pTemp = (PBYTE)pgsd;

            pgsd->dwReserved[0] = 0; // Make sure it's cleared always.

            while (lSize > 0)
            {
                lBytes = (lSize > 20000) ? 20000 : lSize;
                if (!WriteFile(hNTFFile, (LPVOID)pTemp, lBytes,
                                (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
                        || (ulByteWritten != (ULONG)lBytes))
                {
                    ERR(("WriteNTF:WriteFile\n"));
                    MemFree(pGlyphSetEntry);
                    MemFree(pFontMtxEntry);
                    CloseHandle(hNTFFile);
                    return(FALSE);
                }
                lSize -= 20000;
                pTemp += 20000;
            }
        }

        if (bVerbose && pgsd)
        {
            printf("GLYPHSETDATA #%d\n", j++ + 1);
            printf("GLYPHSETDATA:dwSize:%ld\n", pgsd->dwSize);
            printf("GLYPHSETDATA:dwVersion:%08X\n", pgsd->dwVersion);
            printf("GLYPHSETDATA:dwFlags:%08X\n", pgsd->dwFlags);
            printf("GLYPHSETDATA:dwGlyphSetNameOffset:%s\n", (PSZ)MK_PTR(pgsd, dwGlyphSetNameOffset));
            printf("GLYPHSETDATA:dwGlyphCount:%ld\n", pgsd->dwGlyphCount);
            printf("GLYPHSETDATA:dwRunCount:%ld\n", pgsd->dwRunCount);
            printf("GLYPHSETDATA:dwCodePageCount:%ld\n", pgsd->dwCodePageCount);
            printf("\n");
        }
    }

    for (i = 0; i < dwFontMtxCount; i++)
    {
        if (!WriteFile(hNTFFile, (LPVOID)pNTM[i], pNTM[i]->dwSize,
                       (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
                || (ulByteWritten != pNTM[i]->dwSize))
        {
            ERR(("WriteNTF:WriteFile\n"));
            MemFree(pGlyphSetEntry);
            MemFree(pFontMtxEntry);
            CloseHandle(hNTFFile);
            return(FALSE);
        }

        if (bVerbose)
        {
            printf("NTM #%d\n", i + 1);
            printf("NTM:dwSize:%ld\n", pNTM[i]->dwSize);
            printf("NTM:dwVersion:%08X\n", pNTM[i]->dwVersion);
            printf("NTM:dwFlags:%08X\n", pNTM[i]->dwFlags);
            printf("NTM:dwFontNameOffset:%s\n", (PSZ)MK_PTR(pNTM[i], dwFontNameOffset));
            printf("NTM:dwDisplayNameOffset:%S\n", (PTSTR)MK_PTR(pNTM[i], dwDisplayNameOffset));
            printf("NTM:dwFontVersion:%08X\n", pNTM[i]->dwFontVersion);
            printf("NTM:dwGlyphSetNameOffset:%s\n", (PSZ)MK_PTR(pNTM[i], dwGlyphSetNameOffset));
            printf("NTM:dwGlyphCount:%ld\n", pNTM[i]->dwGlyphCount);
            printf("NTM:dwCharWidthCount:%ld\n", pNTM[i]->dwCharWidthCount);
            printf("NTM:dwDefaultCharWidth:%ld\n", pNTM[i]->dwDefaultCharWidth);
            printf("NTM:dwKernPairCount:%ld\n", pNTM[i]->dwKernPairCount);
            printf("NTM:dwCharSet:%ld\n", pNTM[i]->dwCharSet);
            printf("NTM:dwCodePage:%ld\n", pNTM[i]->dwCodePage);
            printf("\n");
        }
    }

    //
    // Write EOF marker
    //
    if (!WriteFile(hNTFFile, (LPVOID)&dwEofMark, sizeof (DWORD),
                   (LPDWORD)&ulByteWritten, (LPOVERLAPPED)NULL)
            || (ulByteWritten != sizeof (DWORD)))
    {
        ERR(("WriteNTF:WriteFile:EOF\n"));
        MemFree(pGlyphSetEntry);
        MemFree(pFontMtxEntry);
        CloseHandle(hNTFFile);
        return (FALSE);
    }

    MemFree(pGlyphSetEntry);
    MemFree(pFontMtxEntry);
    CloseHandle(hNTFFile);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\makentf\writentf.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    writentf.h

Abstract:

    Write a NTF file.

Environment:

    Windows NT PostScript driver.

Revision History:

	11/21/96 -slam-
		Created.

	dd-mm-yy -author-
		description

--*/


#ifndef _WRITENTF_H_
#define _WRITENTF_H_


#include "lib.h"
#include "ppd.h"
#include "pslib.h"


BOOL
WriteNTF(
    IN  PWSTR           pwszNTFFile,
    IN  DWORD           dwGlyphSetCount,
    IN  DWORD           dwGlyphSetTotalSize,
    IN  PGLYPHSETDATA   *pGlyphSetData,
    IN  DWORD           dwFontMtxCount,
    IN  DWORD           dwFontMtxTotalSize,
    IN  PNTM            *pNTM
    );


#endif	//!_WRITENTF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\pass2.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    pass2.h

Abstract:

    checks whether all referenced options in a file are actually defined

--*/

#ifndef _PASS2_H_
#define _PASS2_H_

#ifdef __cplusplus

extern "C" {

#endif

void CheckOptionIntegrity(PTSTR ptstrPpdFilename);

#ifdef __cplusplus

}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\ppdcheck.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ppdcheck.c

Abstract:

    PPD parser test program

Environment:

    PostScript driver, PPD parser, Check build only

Revision History:

    09/17/96 -davidx-
        Implement PpdDump.

    03/27/96 -davidx-
        Created it.

--*/

#include "lib.h"
#include "ppd.h"

#include "pass2.h"


INT giDebugLevel;


HINSTANCE       ghInstance;
PSTR            gstrProgName;
PRAWBINARYDATA  gpRawData;
PINFOHEADER     gpInfoHdr;
PUIINFO         gpUIInfo;
PPPDDATA        gpPpdData;
DWORD           gdwTotalSize, gdwNumFiles, gdwMaxFileSize;

extern const CHAR gstrFalseKwd[];
extern const CHAR gstrNoneKwd[];

#define DumpInt(label, n)       DbgPrint("%s: %d\n", label, n)
#define DumpHex(label, n)       DbgPrint("%s: 0x%x\n", label, n)
#define DumpStrW(label, offset) DbgPrint("%s: %ws\n", label, OFFSET_TO_POINTER(gpRawData, offset))
#define DumpStrA(label, offset) DbgPrint("%s: %s\n", label, OFFSET_TO_POINTER(gpRawData, offset))
#define DumpFix(label, n)       DbgPrint("%s: %f\n", label, (FLOAT) (n) / FIX_24_8_SCALE)
#define DumpInvo(label, p)      DbgPrint("%s: %d bytes\n", label, (p)->dwCount)
#define DumpSize(label, p)      DbgPrint("%s: %d x %d\n", label, (p)->cx, (p)->cy)
#define DumpRect(label, p)      DbgPrint("%s: (%d, %d) - (%d, %d)\n", label, \
                                         (p)->left, (p)->top, (p)->right, (p)->bottom)




VOID
PpdDump(
    VOID
    )

{
    DWORD           index, dwFeatures;
    PFEATURE        pFeature;
    POPTION         pOption;
    LPTSTR          ptstrTable;
    PUICONSTRAINT   pUIConstraint;
    PORDERDEPEND    pOrderDep;
    PFILEDATEINFO   pFileDateInfo;

    DbgPrint("\nRAWBINARYDATA:\n");
    DumpInt ("  dwFileSize", gpRawData->dwFileSize);
    DumpHex ("  dwParserSignature", gpRawData->dwParserSignature);
    DumpHex ("  dwParserVersion", gpRawData->dwParserVersion);
    DumpHex ("  dwChecksum32", gpRawData->dwChecksum32);
    DumpInt ("  dwDocumentFeatures", gpRawData->dwDocumentFeatures);
    DumpInt ("  dwPrinterFeatures", gpRawData->dwPrinterFeatures);
    DumpInt ("  Source PPD files", gpRawData->FileDateInfo.dwCount);

    pFileDateInfo = OFFSET_TO_POINTER(gpRawData, gpRawData->FileDateInfo.loOffset);

    ASSERT(gpRawData->FileDateInfo.dwCount == 0 || pFileDateInfo != NULL);

    for (index=0; index < gpRawData->FileDateInfo.dwCount; index++, pFileDateInfo++)
    {
        FILETIME    FileTime;
        SYSTEMTIME  SystemTime;
        TCHAR       TimeDateString[64];

        DumpStrW("    loFileName", pFileDateInfo->loFileName);

        FileTimeToLocalFileTime(&pFileDateInfo->FileTime, &FileTime);
        FileTimeToSystemTime(&FileTime, &SystemTime);

        GetDateFormat(LOCALE_USER_DEFAULT, 0, &SystemTime, NULL, TimeDateString, 64);
        DbgPrint("    FileTime: %ws ", TimeDateString);

        GetTimeFormat(LOCALE_USER_DEFAULT, 0, &SystemTime, NULL, TimeDateString, 64);
        DbgPrint("%ws\n", TimeDateString);
    }

    DbgPrint("\nUIINFO:\n");
    DumpInt ("  dwSize", gpUIInfo->dwSize);
    DumpStrW("  loNickName", gpUIInfo->loNickName);
    DumpHex ("  dwSpecVersion", gpUIInfo->dwSpecVersion);
    DumpHex ("  dwTechnology", gpUIInfo->dwTechnology);
    DumpInt ("  dwDocumentFeatures", gpUIInfo->dwDocumentFeatures);
    DumpInt ("  dwPrinterFeatures", gpUIInfo->dwPrinterFeatures);
    DumpInt ("  UIConstraints.dwCount", gpUIInfo->UIConstraints.dwCount);
    DumpInt ("  dwMaxCopies", gpUIInfo->dwMaxCopies);
    DumpInt ("  dwMinScale", gpUIInfo->dwMinScale);
    DumpInt ("  dwMaxScale", gpUIInfo->dwMaxScale);
    DumpInt ("  dwLangEncoding", gpUIInfo->dwLangEncoding);
    DumpInt ("  dwLangLevel", gpUIInfo->dwLangLevel);

    if (gpUIInfo->dwLangLevel >= 2 && gpPpdData->dwPSVersion < 2000)
        DbgPrint("  *** Level 2 clone\n");

    DumpInvo("  Password", &gpUIInfo->Password);
    DumpInvo("  ExitServer", &gpUIInfo->ExitServer);
    DumpHex ("  dwProtocols", gpUIInfo->dwProtocols);
    DumpInt ("  dwJobTimeout", gpUIInfo->dwJobTimeout);
    DumpInt ("  dwWaitTimeout", gpUIInfo->dwWaitTimeout);
    DumpInt ("  dwTTRasterizer", gpUIInfo->dwTTRasterizer);
    DumpInt ("  dwFreeMem", gpUIInfo->dwFreeMem);
    DumpInt ("  dwPrintRate", gpUIInfo->dwPrintRate);
    DumpInt ("  dwPrintRateUnit", gpUIInfo->dwPrintRateUnit);
    DumpFix ("  fxScreenAngle", gpUIInfo->fxScreenAngle);
    DumpFix ("  fxScreenFreq", gpUIInfo->fxScreenFreq);
    DumpHex ("  dwFlags", gpUIInfo->dwFlags);
    DumpInt ("  dwCustomSizeOptIndex", gpUIInfo->dwCustomSizeOptIndex);
    DumpInt ("  ptMasterUnits.x", gpUIInfo->ptMasterUnits.x);
    DumpInt ("  ptMasterUnits.y", gpUIInfo->ptMasterUnits.y);

    dwFeatures = gpUIInfo->dwDocumentFeatures + gpUIInfo->dwPrinterFeatures;
    pFeature = OFFSET_TO_POINTER(gpRawData, gpUIInfo->loFeatureList);
    pUIConstraint = OFFSET_TO_POINTER(gpRawData, gpUIInfo->UIConstraints.loOffset);

    DbgPrint("\n  FEATURES: count = %d\n", dwFeatures);

    for (index = 0; index < dwFeatures; index++, pFeature++)
    {
        DWORD       dwConstIndex, dwFeatureIndex, dwOptionIndex, dwOptionCount;
        PFEATURE    pConstFeature;
        POPTION     pConstOption;

        DumpStrA("\n  loKeywordName", pFeature->loKeywordName);
        DumpStrW("    loDisplayName", pFeature->loDisplayName);
        DumpHex ("    dwFlags", pFeature->dwFlags);
        DumpInt ("    dwDefaultOptIndex", pFeature->dwDefaultOptIndex);
        DumpInt ("    dwNoneFalseOptIndex", pFeature->dwNoneFalseOptIndex);
        DumpInt ("    dwFeatureID", pFeature->dwFeatureID);
        DumpInt ("    dwUIType", pFeature->dwUIType);
        DumpInt ("    dwPriority", pFeature->dwPriority);
        DumpInt ("    dwFeatureType", pFeature->dwFeatureType);
        DumpInt ("    dwOptionSize", pFeature->dwOptionSize);

        if (dwOptionCount = pFeature->Options.dwCount)
        {
            pOption = OFFSET_TO_POINTER(gpRawData, pFeature->Options.loOffset);
            DbgPrint("\n    OPTIONS: count = %d\n", dwOptionCount);

            while (dwOptionCount--)
            {
                DumpStrA("\n    loKeywordName", pOption->loKeywordName);
                DumpStrW("      loDisplayName", pOption->loDisplayName);
                DumpInvo("      Invocation", &pOption->Invocation);

                switch (pFeature->dwFeatureID)
                {
                case GID_PAGESIZE:

                    {   PPAGESIZE   pPaper = (PPAGESIZE) pOption;

                        DumpSize("      szPaperSize", &pPaper->szPaperSize);
                        DumpRect("      rcImgArea", &pPaper->rcImgArea);
                        DumpInt ("      dwPaperSizeID", pPaper->dwPaperSizeID);
                        DumpHex ("      dwFlags", pPaper->dwFlags);
                    }
                    break;

                case GID_RESOLUTION:

                    {   PRESOLUTION pRes = (PRESOLUTION) pOption;

                        DumpInt ("      iXdpi", pRes->iXdpi);
                        DumpInt ("      iYdpi", pRes->iYdpi);
                        DumpFix ("      fxScreenAngle", pRes->fxScreenAngle);
                        DumpFix ("      fxScreenFreq", pRes->fxScreenFreq);
                    }
                    break;

                case GID_DUPLEX:

                    DumpInt ("      dwDuplexID", ((PDUPLEX) pOption)->dwDuplexID);
                    break;

                case GID_COLLATE:

                    DumpInt ("      dwCollateID", ((PCOLLATE) pOption)->dwCollateID);
                    break;

                case GID_MEDIATYPE:

                    DumpInt ("      dwMediaTypeID", ((PMEDIATYPE) pOption)->dwMediaTypeID);
                    break;

                case GID_OUTPUTBIN:

                    DumpInt ("      bOutputOrderReversed", ((POUTPUTBIN) pOption)->bOutputOrderReversed);
                    break;

                case GID_INPUTSLOT:

                    {   PINPUTSLOT  pTray = (PINPUTSLOT) pOption;

                        DumpHex ("      dwFlags", pTray->dwFlags);
                        DumpInt ("      dwPaperSourceID", pTray->dwPaperSourceID);
                    }
                    break;

                case GID_MEMOPTION:

                    {   PMEMOPTION  pMemOption = (PMEMOPTION) pOption;

                        DumpInt ("      dwInstalledMem", pMemOption->dwInstalledMem);
                        DumpInt ("      dwFreeMem", pMemOption->dwFreeMem);
                        DumpInt ("      dwFreeFontMem", pMemOption->dwFreeFontMem);
                    }
                    break;
                }

                if ((dwConstIndex = pOption->dwUIConstraintList) != NULL_CONSTRAINT)
                {
                    ASSERT(pUIConstraint != NULL);
                    DbgPrint("\n      UICONSTRAINTS:\n");

                    while (dwConstIndex != NULL_CONSTRAINT)
                    {
                        ASSERT(dwConstIndex < gpUIInfo->UIConstraints.dwCount);

                        dwFeatureIndex = pUIConstraint[dwConstIndex].dwFeatureIndex;
                        dwOptionIndex = pUIConstraint[dwConstIndex].dwOptionIndex;
                        dwConstIndex = pUIConstraint[dwConstIndex].dwNextConstraint;

                        ASSERT(dwFeatureIndex < dwFeatures);
                        pConstFeature = PGetIndexedFeature(gpUIInfo, dwFeatureIndex);
                        DbgPrint("        %s", OFFSET_TO_POINTER(gpRawData, pConstFeature->loKeywordName));

                        if (dwOptionIndex != OPTION_INDEX_ANY)
                        {
                            ASSERT(dwOptionIndex < pConstFeature->Options.dwCount);
                            pConstOption = PGetIndexedOption(gpUIInfo, pConstFeature, dwOptionIndex);
                            DbgPrint(" %s", OFFSET_TO_POINTER(gpRawData, pConstOption->loKeywordName));
                        }

                        DbgPrint("\n");
                    }
                }

                pOption = (POPTION) ((PBYTE) pOption + pFeature->dwOptionSize);
            }
        }

        if ((dwConstIndex = pFeature->dwUIConstraintList) != NULL_CONSTRAINT)
        {
            ASSERT(pUIConstraint != NULL);
            DbgPrint("\n    UICONSTRAINTS:\n");

            while (dwConstIndex != NULL_CONSTRAINT)
            {
                ASSERT(dwConstIndex < gpUIInfo->UIConstraints.dwCount);

                dwFeatureIndex = pUIConstraint[dwConstIndex].dwFeatureIndex;
                dwOptionIndex = pUIConstraint[dwConstIndex].dwOptionIndex;
                dwConstIndex = pUIConstraint[dwConstIndex].dwNextConstraint;

                ASSERT(dwFeatureIndex < dwFeatures);
                pConstFeature = PGetIndexedFeature(gpUIInfo, dwFeatureIndex);
                DbgPrint("      %s", OFFSET_TO_POINTER(gpRawData, pConstFeature->loKeywordName));

                if (dwOptionIndex != OPTION_INDEX_ANY)
                {
                    ASSERT(dwOptionIndex < pConstFeature->Options.dwCount);
                    pConstOption = PGetIndexedOption(gpUIInfo, pConstFeature, dwOptionIndex);

                    DbgPrint(" %s", OFFSET_TO_POINTER(gpRawData, pConstOption->loKeywordName));
                }

                DbgPrint("\n");
            }
        }
    }

    DbgPrint("\n  PREDEFINED FEATURES:\n");

    for (index = 0; index < MAX_GID; index++)
    {
        if (pFeature = GET_PREDEFINED_FEATURE(gpUIInfo, index))
            DbgPrint("    %s\n", OFFSET_TO_POINTER(gpRawData, pFeature->loKeywordName));
    }

    DbgPrint("\n  DEFAULT FONT SUBSTITUTION TABLE: %d bytes\n", gpUIInfo->dwFontSubCount);

    ptstrTable = OFFSET_TO_POINTER(gpRawData, gpUIInfo->loFontSubstTable);

    if (ptstrTable) {

        while (*ptstrTable) {

            DbgPrint("    %ws => ", ptstrTable);
            ptstrTable += _tcslen(ptstrTable) + 1;
            DbgPrint("%ws\n", ptstrTable);
            ptstrTable += _tcslen(ptstrTable) + 1;
        }
    }

    DbgPrint("\nPPDDATA:\n");

    #ifndef WINNT_40
    DumpHex ("  GetUserDefaultUILanguage() returns", GetUserDefaultUILanguage());
    #endif

    DumpHex ("  dwUserDefUILangID", gpPpdData->dwUserDefUILangID);
    DumpHex ("  dwPpdFilever", gpPpdData->dwPpdFilever);
    DumpHex ("  dwFlags", gpPpdData->dwFlags);
    DumpHex ("  dwExtensions", gpPpdData->dwExtensions);
    DumpInt ("  dwSetResType", gpPpdData->dwSetResType);
    DumpInt ("  dwPSVersion", gpPpdData->dwPSVersion);
    DumpInvo("  PSVersion", &gpPpdData->PSVersion);
    DumpInvo("  Product", &gpPpdData->Product);

    DumpHex ("  dwOutputOrderIndex", gpPpdData->dwOutputOrderIndex);
    DumpHex ("  dwCustomSizeFlags", gpPpdData->dwCustomSizeFlags);
    DumpInt ("  dwLeadingEdgeLong", gpPpdData->dwLeadingEdgeLong);
    DumpInt ("  dwLeadingEdgeShort", gpPpdData->dwLeadingEdgeShort);
    DumpInt ("  dwUseHWMarginsTrue", gpPpdData->dwUseHWMarginsTrue);
    DumpInt ("  dwUseHWMarginsFalse", gpPpdData->dwUseHWMarginsFalse);

    for (index = 0; index < CUSTOMPARAM_MAX; index++)
    {
        DbgPrint("    param %d: dwOrder = %d, lMinVal = %d, lMaxVal = %d\n", index,
                 gpPpdData->CustomSizeParams[index].dwOrder,
                 gpPpdData->CustomSizeParams[index].lMinVal,
                 gpPpdData->CustomSizeParams[index].lMaxVal);
    }

    DumpInvo("  PatchFile", &gpPpdData->PatchFile);
    DumpInvo("  JclBegin", &gpPpdData->JclBegin);
    DumpInvo("  JclEnterPS", &gpPpdData->JclEnterPS);
    DumpInvo("  JclEnd", &gpPpdData->JclEnd);
    DumpInvo("  ManualFeedFalse", &gpPpdData->ManualFeedFalse);

    DumpHex ("  dwNt4Checksum", gpPpdData->dwNt4Checksum);
    DumpInt ("  dwNt4DocFeatures", gpPpdData->dwNt4DocFeatures);
    DumpInt ("  dwNt4PrnFeatures", gpPpdData->dwNt4PrnFeatures);

    if (gpPpdData->Nt4Mapping.dwCount)
    {
        PBYTE   pubNt4Mapping;

        pubNt4Mapping = OFFSET_TO_POINTER(gpRawData, gpPpdData->Nt4Mapping.loOffset);

        ASSERT(pubNt4Mapping != NULL);

        for (index=0; index < gpPpdData->Nt4Mapping.dwCount; index++)
            DbgPrint("    %2d => %d\n", index, pubNt4Mapping[index]);
    }

    if (gpPpdData->DeviceFonts.dwCount)
    {
        PDEVFONT    pDevFont;

        DbgPrint("\n  DEVICE FONTS:\n");

        if (pDevFont = OFFSET_TO_POINTER(gpRawData, gpPpdData->loDefaultFont))
            DumpStrA("    default", pDevFont->loFontName);

        pDevFont = OFFSET_TO_POINTER(gpRawData, gpPpdData->DeviceFonts.loOffset);

        for (index = 0; index < gpPpdData->DeviceFonts.dwCount; index++, pDevFont++)
        {
            DumpStrA("\n    loFontName", pDevFont->loFontName);
            DumpStrW("      loDisplayName", pDevFont->loDisplayName);
            DumpStrA("      loEncoding", pDevFont->loEncoding);
            DumpStrA("      loCharset", pDevFont->loCharset);
            DumpStrA("      loVersion", pDevFont->loVersion);
            DumpInt ("      dwStatus", pDevFont->dwStatus);
        }
    }

    if (gpPpdData->OrderDeps.dwCount)
    {
        pOrderDep = OFFSET_TO_POINTER(gpRawData, gpPpdData->OrderDeps.loOffset);
        ASSERT(pOrderDep != NULL);

        DbgPrint("\n  ORDER DEPENDENCIES:\n");

        for (index=0; index < gpPpdData->OrderDeps.dwCount; index++, pOrderDep++)
        {
            DbgPrint("    %d: order = %d section = 0x%x (in PPD: 0x%x) ",
                     index, pOrderDep->lOrder, pOrderDep->dwSection, pOrderDep->dwPPDSection);

            pFeature = PGetIndexedFeature(gpUIInfo, pOrderDep->dwFeatureIndex);
            ASSERT(pFeature != NULL);
            DbgPrint("%s", OFFSET_TO_POINTER(gpRawData, pFeature->loKeywordName));

            if (pOrderDep->dwOptionIndex != OPTION_INDEX_ANY)
            {
                pOption = PGetIndexedOption(gpUIInfo, pFeature, pOrderDep->dwOptionIndex);
                ASSERT(pOption != NULL);
                DbgPrint(" %s", OFFSET_TO_POINTER(gpRawData, pOption->loKeywordName));
            }

            DbgPrint(", next = %d\n", pOrderDep->dwNextOrderDep);
        }
    }

    if (gpPpdData->QueryOrderDeps.dwCount)
    {
        pOrderDep = OFFSET_TO_POINTER(gpRawData, gpPpdData->QueryOrderDeps.loOffset);
        ASSERT(pOrderDep != NULL);

        DbgPrint("\n  QUERY ORDER DEPENDENCIES:\n");

        for (index=0; index < gpPpdData->QueryOrderDeps.dwCount; index++, pOrderDep++)
        {
            DbgPrint("    %d: order = %d section = 0x%x (in PPD: 0x%x) ",
                     index, pOrderDep->lOrder, pOrderDep->dwSection, pOrderDep->dwPPDSection);

            pFeature = PGetIndexedFeature(gpUIInfo, pOrderDep->dwFeatureIndex);
            ASSERT(pFeature != NULL);
            DbgPrint("%s", OFFSET_TO_POINTER(gpRawData, pFeature->loKeywordName));

            if (pOrderDep->dwOptionIndex != OPTION_INDEX_ANY)
            {
                pOption = PGetIndexedOption(gpUIInfo, pFeature, pOrderDep->dwOptionIndex);
                ASSERT(pOption != NULL);
                DbgPrint(" %s", OFFSET_TO_POINTER(gpRawData, pOption->loKeywordName));
            }

            DbgPrint(", next = %d\n", pOrderDep->dwNextOrderDep);
        }
    }

    if (gpPpdData->JobPatchFiles.dwCount)
    {
        PJOBPATCHFILE pJobPatchFiles;

        pJobPatchFiles = OFFSET_TO_POINTER(gpRawData, gpPpdData->JobPatchFiles.loOffset);
        ASSERT(pJobPatchFiles);

        DbgPrint("\n  JOB PATCH FILES:\n");

        for (index = 0; index < gpPpdData->JobPatchFiles.dwCount; index++, pJobPatchFiles++)
        {
            DbgPrint("    %2d No %li", index, pJobPatchFiles->lJobPatchNo);
            DbgPrint(": '%s'\n", OFFSET_TO_POINTER(gpRawData, pJobPatchFiles->loOffset));
        }
    }
}



VOID
DumpNt4Mapping(
    VOID
    )

{
    PFEATURE    pFeatures;
    PBYTE       pubNt4Mapping;
    DWORD       iNt4, iNt5, cNt4, cNt5;
    PSTR        pName;

    DbgPrint("checksum: 0x%x\n", gpPpdData->dwNt4Checksum);
    DbgPrint("number of doc-sticky features: %d\n", gpPpdData->dwNt4DocFeatures);
    DbgPrint("number of printer-sticky features: %d\n", gpPpdData->dwNt4PrnFeatures);

    pubNt4Mapping = OFFSET_TO_POINTER(gpRawData, gpPpdData->Nt4Mapping.loOffset);
    pFeatures = OFFSET_TO_POINTER(gpRawData, gpUIInfo->loFeatureList);

    ASSERT(pubNt4Mapping != NULL);

    cNt4 = gpPpdData->dwNt4DocFeatures + gpPpdData->dwNt4PrnFeatures;
    cNt5 = gpPpdData->Nt4Mapping.dwCount;

    ASSERT(cNt5 == 0 || pFeatures != NULL);

    for (iNt4=0; iNt4 < cNt4; iNt4++)
    {
        for (iNt5=0; iNt5 < cNt5; iNt5++)
        {
            if (pubNt4Mapping[iNt5] == iNt4)
            {
                pName = OFFSET_TO_POINTER(gpRawData, pFeatures[iNt5].loKeywordName);

                ASSERT(pName != NULL);

                if (strcmp(pName, "JCLResolution") == EQUAL_STRING ||
                    strcmp(pName, "SetResolution") == EQUAL_STRING)
                {
                    pName = "Resolution";
                }

                DbgPrint("  %2d: %s\n", pubNt4Mapping[iNt5], pName);
                break;
            }
        }
    }
}



ULONG _cdecl
DbgPrint(
    PCSTR    pstrFormat,
    ...
    )

{
    va_list ap;

    va_start(ap, pstrFormat);
    vprintf(pstrFormat, ap);
    va_end(ap);

    return 0;
}

typedef enum {
    Free,
    InBracket,
    InHexDigitOdd,
    InHexDigitEven
} eInvState;

static void CheckInvocationValue(POPTION pOption, LPSTR pstrFeatureName)
{
    eInvState State = Free;
    DWORD i;
    LPSTR pInv = OFFSET_TO_POINTER(gpRawData, pOption->Invocation.loOffset);

    ASSERT(pOption->Invocation.dwCount == 0 || pInv != NULL);

    for (i=0; i< pOption->Invocation.dwCount; i++)
    {
        switch (State)
        {
        case Free:
            if (*(pInv + i) == '<')
                State = InBracket;
            break;
        case InBracket:
            if (isxdigit(*(pInv + i)))
                State = InHexDigitOdd;
            else
                State = Free;
            break;
        case InHexDigitOdd:
            if (isxdigit(*(pInv + i)))
                State = InHexDigitEven;
            else
                State = Free;
            break;
        case InHexDigitEven:
            if (isxdigit(*(pInv + i)))
                State = InHexDigitOdd;
            else if (*(pInv + i) == '>')
            {
                LPSTR pstrOptionName = OFFSET_TO_POINTER(gpRawData, pOption->loKeywordName);
                DbgPrint("Warning: invocation value of feature '%s', option '%s' contains hex digits\n   - possibly forgotten to use 'JCL' as start of keyword ?\n",
                          pstrFeatureName, pstrOptionName);
                return;
            }
            else
                State = Free;
            break;
        }
    }
}


VOID
PpdVerify(
    VOID
    )

{
    DWORD           index, dwFeatures;
    PFEATURE        pFeature;
    POPTION         pOption;
    PSTR            pstrFeatureName, pstrOptionName;
    BOOL            bNoneOption, bFalseOption;
    PUICONSTRAINT   pConstraint;
    DWORD           NoOfConstraints = gpUIInfo->UIConstraints.dwCount;


    dwFeatures = gpUIInfo->dwDocumentFeatures + gpUIInfo->dwPrinterFeatures;
    pFeature = OFFSET_TO_POINTER(gpRawData, gpUIInfo->loFeatureList);
    pConstraint = OFFSET_TO_POINTER(gpRawData, gpUIInfo->UIConstraints.loOffset);

    ASSERT(dwFeatures == 0 || pFeature != NULL);

    for (index = 0; index < dwFeatures; index++, pFeature++)
    {
        DWORD       dwOptionCount, dwOptionIndex = 0;

        pstrFeatureName = OFFSET_TO_POINTER(gpRawData, pFeature->loKeywordName);

        if (dwOptionCount = pFeature->Options.dwCount)
        {
            pOption = OFFSET_TO_POINTER(gpRawData, pFeature->Options.loOffset);
            bNoneOption = bFalseOption = FALSE;

            ASSERT(dwOptionCount == 0 || pOption != NULL);

            while (dwOptionCount--)
            {
                pstrOptionName = OFFSET_TO_POINTER(gpRawData, pOption->loKeywordName);

                ASSERT(pstrOptionName);

                if (!strcmp(pstrOptionName, gstrNoneKwd))
                    bNoneOption = TRUE;
                else if (!strcmp(pstrOptionName, gstrFalseKwd))
                    bFalseOption = TRUE;

                if (giDebugLevel <= 2)
                {
                    CheckInvocationValue(pOption, pstrFeatureName);

                    //
                    // check self constraining constraints
                    //
                    if (pOption->dwUIConstraintList != NULL_CONSTRAINT)
                    {
                        DWORD dwConstIndex = pOption->dwUIConstraintList;
                        do
                        {
                            if ((pConstraint[dwConstIndex].dwFeatureIndex == index) &&
                                ((pConstraint[dwConstIndex].dwOptionIndex == dwOptionIndex) ||
                                 (pConstraint[dwConstIndex].dwOptionIndex == OPTION_INDEX_ANY)))
                                DbgPrint("Warning : self constraining constraint found for feature '%s', Option '%s'\n", pstrFeatureName, pstrOptionName);
                            dwConstIndex = pConstraint[dwConstIndex].dwNextConstraint;
                        } while (dwConstIndex != NULL_CONSTRAINT);
                    }
                }
                pOption = (POPTION) ((PBYTE) pOption + pFeature->dwOptionSize);
                dwOptionIndex++;
            }

            if (bNoneOption && bFalseOption)
                DbgPrint("Error: Feature '%s' has both None and False options!\n",pstrFeatureName);

        }
    }

}



VOID
usage(
    VOID
    )

{
    DbgPrint("usage: %s [-options] filenames ...\n", gstrProgName);
    DbgPrint("where options are:\n");
    DbgPrint("  -b  attempt to read cached binary PPD data first\n");
    DbgPrint("  -k  keep the binary PPD data\n");
    DbgPrint("  -wN set warning level to N\n");
    DbgPrint("  -h  display help information\n");
    exit(-1);
}


INT _cdecl
main(
    INT     argc,
    CHAR    **argv
    )

{
    BOOL    bUseCache, bKeepBPD;
    DWORD   dwTime;

    //
    // Go through the command line arguments
    //

    ghInstance = GetModuleHandle(NULL);
    bUseCache = bKeepBPD = FALSE;
    giDebugLevel = DBG_TERSE;
    gdwTotalSize = gdwNumFiles = gdwMaxFileSize;

    gstrProgName = *argv++;
    argc--;

    if (argc == 0)
        usage();

    dwTime = GetTickCount();

    for ( ; argc--; argv++)
    {
        PSTR    pArg = *argv;

        if (*pArg == '-' || *pArg == '/')
        {
            //
            // The argument is an option flag
            //

            switch (*++pArg) {

            case 'b':
            case 'B':

                bUseCache = bKeepBPD = TRUE;
                break;

            case 'k':
            case 'K':

                bKeepBPD = TRUE;
                break;

            case 'w':
            case 'W':

                if (*++pArg >= '0' && *pArg <= '9')
                {
                    giDebugLevel = *pArg - '0';
                    break;
                }

            default:

                usage();
                break;
            }

        }
        else
        {
            WCHAR   wstrFilename[MAX_PATH];
            PTSTR   ptstrBpdFilename;

            //
            // Convert ANSI filename to Unicode filename
            //

            MultiByteToWideChar(CP_ACP, 0, pArg, -1, wstrFilename, MAX_PATH);

            TERSE(("\n*** %ws\n", wstrFilename));

            //
            // If -b option is given, try to read cached binary data first
            //

            if (bUseCache)
                gpRawData = PpdLoadCachedBinaryData(wstrFilename);
            else
            {
                gpRawData = PpdParseTextFile(wstrFilename);
                if (giDebugLevel <= 2)
                    CheckOptionIntegrity(wstrFilename);
            }

            if (gpRawData)
            {
                gpInfoHdr = (PINFOHEADER) gpRawData;
                gpUIInfo = (PUIINFO) ((PBYTE) gpInfoHdr + gpInfoHdr->loUIInfoOffset);
                gpPpdData = (PPPDDATA) ((PBYTE) gpInfoHdr + gpInfoHdr->loDriverOffset);
                gpUIInfo->pInfoHeader = gpInfoHdr;

                if (giDebugLevel == 8)
                {
                    DbgPrint("*** PPD file: %s\n", StripDirPrefixA(pArg));

                    DumpNt4Mapping();
                }
                else if (giDebugLevel == 9)
                    PpdDump();

                //
                // extra error checking
                //

                PpdVerify();

                gdwTotalSize += gpRawData->dwFileSize;
                gdwNumFiles++;

                if (gpRawData->dwFileSize > gdwMaxFileSize)
                    gdwMaxFileSize = gpRawData->dwFileSize;

                MemFree(gpRawData);

                //
                // If -k option is not given, get rid of the BPD file after we're done
                //

                if (! bKeepBPD && (ptstrBpdFilename = GenerateBpdFilename(wstrFilename)))
                {
                    DeleteFile(ptstrBpdFilename);
                    MemFree(ptstrBpdFilename);
                }
            }
        }
    }

    #ifdef COLLECT_STATS

    if (gdwNumFiles > 0)
    {
        dwTime = GetTickCount() - dwTime;

        TERSE(("Number of files parsed: %d\n", gdwNumFiles));
        TERSE(("Average binary file size: %d\n", gdwTotalSize / gdwNumFiles));
        TERSE(("Maximum binary file size: %d\n", gdwMaxFileSize));
        TERSE(("Average parsing time per file (ms): %d\n", dwTime / gdwNumFiles));
    }

    #endif // COLLECT_STATS

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\pass2.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pass2.cpp

Abstract:

    Functions for additional checking of a PPD file

Environment:

    PostScript driver, PPD parser

Revision History:

    09/15/98 -rorleth-
        Created it.

--*/

#include <lib.h>
#include <iostream.h>

#include "pass2.h"

enum FeatureId
{
    FID_PAGE_SIZE,
    FID_PAGE_REGION,
    FID_INPUT_SLOT,
    FID_SMOOTHING,
    FID_MEDIA_COLOR,
    FID_MEDIA_TYPE,
    FID_MEDIA_WEIGHT,
    FID_OUTPUT_MODE,
    FID_PAPER_DIMENSION,
    FID_IMAGE_AREA,
    FID_OUTPUT_ORDER,
    NO_OF_FEATURES
};

typedef struct _PPD_FEATURE
{
    FeatureId   eId;
    LPSTR       lpszName;
} PPD_FEATURE, *PPPD_FEATURE;

//
// features whose options we have to check
//

static PPD_FEATURE aCheckFeat[] =
{
    { FID_PAGE_SIZE,    "PageSize" },
    { FID_PAGE_REGION,  "PageRegion" },
    { FID_INPUT_SLOT,   "InputSlot" },
    { FID_SMOOTHING,    "Smoothing" },
    { FID_MEDIA_COLOR,  "MediaColor" },
    { FID_MEDIA_TYPE,   "MediaType" },
    { FID_MEDIA_WEIGHT, "MediaWeight" },
    { FID_OUTPUT_MODE,  "OutputMode" },
    { FID_PAPER_DIMENSION, "PaperDimension" },
    { FID_IMAGE_AREA,   "ImageableArea" },
    { FID_OUTPUT_ORDER, "OutputOrder" },
    { NO_OF_FEATURES, NULL}
};

typedef struct _PPD_OPTION
{
    FeatureId   eId;
    LPSTR       lpszName;
} PPD_OPTION, *PPPD_OPTION;

//
// keywords that require defined feature options
//
static PPD_OPTION gaCheckKeyword[] =
{
    { FID_INPUT_SLOT, "RequiresPageRegion"},
    { NO_OF_FEATURES, NULL }
};

//
// special option names
//
static PPD_OPTION gaSpecialOptions[] =
{
    { NO_OF_FEATURES,   "None" }, // NO_OF_FEATURES means valid for all features in that case
    { NO_OF_FEATURES,   "All" },
    { NO_OF_FEATURES,   "Unknown" },
    { FID_OUTPUT_ORDER, "Normal" }, // Normal and Reverse are predefined options for OutputOrder
    { FID_OUTPUT_ORDER, "Reverse" },
    { NO_OF_FEATURES, NULL},
};

//
//  keywords that have a length limitation for the UI
//
typedef struct _PPD_LENGTH_CHECK
{
    FeatureId   eId;
    size_t      iMaxLen;
} PPD_LENGTH_CHECK, *PPPD_LENGTH_CHECK;

static PPD_LENGTH_CHECK gaCheckLength[] =
{
    { FID_INPUT_SLOT, 23},
    { NO_OF_FEATURES, 0 }
};

const char *pDefaultKeyword = "Default";
const int MaxOptionNameLen = 40;
const int MaxTranslationNameLen = 128;

typedef struct _OPTION_LIST
{
    char        aName[MaxOptionNameLen+1];
    char        aTransName[MaxTranslationNameLen+1];
    _OPTION_LIST *pNext;
} OPTION_LIST, *POPTION_LIST;


static POPTION_LIST gaOptionList[NO_OF_FEATURES]; // stores all defined options


/*++

Routine Description:

    checks whether a references option is defined

Arguments:

    char        **ppString  : Pointer to pointer to option, is advanced by the option name length
    FeatureId   FeatId      : ID of the feature, which should have the option
    char        *pOptionName: pointer to buffer, where the option name shall be stored for error messages

Return Value:

    TRUE if the identified feature has that option, FALSE if not

--*/

static BOOL IsOptionDefined(char **ppString, FeatureId FeatId, char *pOptionName)
{
    char *pEndName, *pName = *ppString;

    while (isspace(*pName))
        pName++;

    pEndName = strpbrk(pName, "/: \t\n\r\0");

    *ppString = pEndName; // advance current pointer

    strncpy(pOptionName, pName, min((DWORD)(pEndName - pName), MaxOptionNameLen));
    pOptionName[pEndName-pName] = 0;

    //
    // check special cases that do not have to be defined
    //
    int i=0;

    while (gaSpecialOptions[i].lpszName != NULL)
    {
        if ((gaSpecialOptions[i].eId == NO_OF_FEATURES) ||
            (gaSpecialOptions[i].eId == FeatId))
        {
            if (!strcmp(gaSpecialOptions[i].lpszName, pOptionName))
                return TRUE;
        }
        i++;
    }

    POPTION_LIST pList = gaOptionList[FeatId], pNew;

    while (pList != NULL)
    {
        if (!strcmp(pList->aName, pOptionName))
            return TRUE;  // found it, it's defined

        pList = pList->pNext;
    }

    return FALSE;
}



/*++

Routine Description:

    checks a whole PPD-file, whether all referenced options are defined

Arguments:

      PTSTR FileName: Name of the PPD-file to check

--*/

extern "C" void CheckOptionIntegrity(PTSTR ptstrPpdFilename)
{

    ZeroMemory(gaOptionList, sizeof(gaOptionList)); // initialise the list header

    _flushall(); // to avoid sync problems with the DbgPrint output

    //
    // create the file mapping
    //
    HANDLE hFile = CreateFile(ptstrPpdFilename, GENERIC_READ, FILE_SHARE_READ,
                              NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    DWORD dwFileSize = GetFileSize(hFile, NULL);

    if (dwFileSize == 0xffffffff)
    {
        CloseHandle(hFile);
        return;
    }

    HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY,0, 0,NULL);

    if (hMap == NULL)
    {
        CloseHandle(hFile);
        return;
    }

    LPCVOID pView = MapViewOfFile(hMap, FILE_MAP_READ, 0,0,0);
    if (pView == NULL)
    {
        CloseHandle(hMap);
        CloseHandle(hFile);
        return;
    }

    //
    // copy the whole file into an allocated buffer just to get zero-termination
    //
    LPSTR  pFile, pFileStart;

    pFileStart = (LPSTR) VirtualAlloc(NULL, dwFileSize+1, MEM_COMMIT, PAGE_READWRITE);

    if (pFileStart != NULL)
    {
        CopyMemory(pFileStart, pView, dwFileSize);
        *(pFileStart + dwFileSize) = 0;
    }

    UnmapViewOfFile(pView);
    CloseHandle(hMap);
    CloseHandle(hFile);

    if (pFileStart == NULL)
    {
        cout << "ppdcheck.exe out of memory" << endl;
        return;
    }

    pFile = pFileStart;

    //
    // now the whole PPD-file is a giant string
    // extract all the features/options
    //
    char *pCurOption = (char *) pFileStart;
    char OptionName[MaxOptionNameLen+1];


    //
    // step 1 : extract all valid feature options
    //
    while ((pFile != NULL) &&
           (pCurOption = strchr(pFile, '*')) != NULL)
    {
        pCurOption++;

        char *pNextLine = strpbrk(pCurOption, "\n\r");
        pFile = pNextLine;

        if (*pCurOption == '%') // skip comments
            continue;

        //
        // scan whether this is one of the features to look for
        //
        int Index = 0;

        while (aCheckFeat[Index].eId != NO_OF_FEATURES)
        {
            if (strncmp(aCheckFeat[Index].lpszName, pCurOption, strlen(aCheckFeat[Index].lpszName)))
            {
                Index++;
                continue;
            }

            //
            // this is one of the monitored features: make entry in list
            //
            POPTION_LIST pList = gaOptionList[aCheckFeat[Index].eId], pNew;

            pNew = new OPTION_LIST;

            pNew->pNext = gaOptionList[aCheckFeat[Index].eId];
            gaOptionList[aCheckFeat[Index].eId] = pNew;

            char *pName = pCurOption + strlen(aCheckFeat[Index].lpszName), *pEndName;

            while (isspace(*pName))
                pName++;

            pEndName = strpbrk(pName, "/: \0");

            DWORD dwNameLen = min((DWORD)(pEndName - pName), MaxOptionNameLen);
            strncpy(pNew->aName, pName, dwNameLen);
            pNew->aName[dwNameLen] = 0;

            dwNameLen = 0;

            if (*pEndName == '/') // there is a translation string
            {
                pName = pEndName +1;
                pEndName = strpbrk(pName, ":\n\r\0");

                dwNameLen = min((DWORD) (pEndName - pName), MaxTranslationNameLen);
                strncpy(pNew->aTransName, pName, dwNameLen);
            }
            pNew->aTransName[dwNameLen] = 0;
            break;
        }

    }

    //
    // step 2: check whether all referenced options are featured
    //
    pFile = pFileStart;
    pCurOption = (char *) pFile;

    while ((pFile != NULL) &&
           (pCurOption = strchr(pFile, '*')) != NULL)
    {
        pCurOption++;

        char *pNextLine = strpbrk(pCurOption, "\n\r");
        pFile = pNextLine;

        //
        // skip comments
        //
        if (*pCurOption == '%')
            continue;

        //
        // check whether it starts with "Default", if yes, check that feature option
        //
        if (!strncmp(pDefaultKeyword, pCurOption, strlen(pDefaultKeyword)))
        {
            pCurOption += strlen(pDefaultKeyword);

            int Index = 0;

            while (aCheckFeat[Index].eId != NO_OF_FEATURES)
            {
                if (strncmp(aCheckFeat[Index].lpszName, pCurOption, strlen(aCheckFeat[Index].lpszName)))
                {
                    Index++;
                    continue;
                }

                //
                // it's one of the checked featurs
                //
                pCurOption += strlen(aCheckFeat[Index].lpszName);

                char *pOption = strpbrk(pCurOption, ":");

                if (pOption == NULL)
                {
                    cout << "Warning: default option for '" << aCheckFeat[Index].lpszName << "' is not completed !" << endl;
                    break;
                }
                pCurOption = pOption + 1;

                if (!IsOptionDefined(&pCurOption, aCheckFeat[Index].eId, OptionName))
                    cout << "Warning: default option '" << OptionName << "' for feature '*" << aCheckFeat[Index].lpszName <<"' is not defined!" << endl;
                break;
            }
        }
        else
        {
            //
            // scan whether this is one of the keywords to look for
            //
            int Index = 0;

            while (gaCheckKeyword[Index].eId != NO_OF_FEATURES)
            {
                if (strncmp(gaCheckKeyword[Index].lpszName, pCurOption, strlen(gaCheckKeyword[Index].lpszName)))
                {
                    Index++;
                    continue;
                }

                //
                // this is one of the monitored features: get the option it references
                //
                pCurOption += strlen(gaCheckKeyword[Index].lpszName);

                if (!IsOptionDefined(&pCurOption, gaCheckKeyword[Index].eId, OptionName))
                    cout << "Warning: option '" << OptionName << "' for keyword '*" << gaCheckKeyword[Index].lpszName <<"' is not defined!" << endl;
                break;
            }
            Index++;
        }
    }

    //
    // step 3: check that all option names are different and don't have trailing or leading spaces
    //
    for (int i = 0; i < NO_OF_FEATURES;i++)
    {
        POPTION_LIST pCheck = gaOptionList[i], pCur;

        while (pCheck != NULL)
        {
            pCur = pCheck->pNext;

            while (pCur != NULL)
            {
                if (strlen(pCheck->aName) &&
                    !strcmp(pCheck->aName, pCur->aName))
                    cout << "Warning: option name '" << pCheck->aName << "' used twice" << endl;
                if (strlen(pCheck->aTransName) &&
                    !strcmp(pCheck->aTransName, pCur->aTransName))
                    cout << "Warning: translation name '" << pCheck->aTransName << "' used twice" << endl;

                pCur = pCur->pNext;
            }
            size_t TransNameLen = strlen(pCheck->aTransName);

            if (isspace(pCheck->aTransName[0]))
                cout << "Warning: translation name '" << pCheck->aTransName << "' has leading whitespace" << endl;
            if ((TransNameLen > 1) &&
                isspace(pCheck->aTransName[TransNameLen-1]))
                cout << "Warning: translation name '" << pCheck->aTransName << "' has trailing whitespace" << endl;

            pCheck = pCheck->pNext;
        }
    }

    //
    // step 4: warn if the string that is used for the display is too long
    //
    i = 0;
    while (gaCheckLength[i].eId != NO_OF_FEATURES)
    {
        POPTION_LIST pCheck = gaOptionList[gaCheckLength[i].eId], pCur;
        while (pCheck != NULL)
        {
            size_t TransNameLen = strlen(pCheck->aTransName);

            if (TransNameLen > gaCheckLength[i].iMaxLen)
                cout << "Warning: translation name '" << pCheck->aTransName << "' will be truncated to "<< (unsigned int) gaCheckLength[i].iMaxLen << " characters"<< endl;
            else if ((TransNameLen == 0) && (strlen(pCheck->aName) > gaCheckLength[i].iMaxLen))
                cout << "Warning: option name '" << pCheck->aName << "' will be truncated to "<< (unsigned int) gaCheckLength[i].iMaxLen << " characters"<< endl;

            pCheck = pCheck->pNext;
        }
        i++;
    }


    //
    // clean up
    //
    for (i = 0; i < NO_OF_FEATURES;i++)
    {
        POPTION_LIST pTmp = gaOptionList[i], pCur;

        while (pTmp != NULL)
        {
            pCur = pTmp->pNext;
            delete pTmp;
            pTmp = pCur;
        }
        gaOptionList[i] = NULL;
    }

    _flushall(); // to avoid sync problems with the DbgPrint output

    VirtualFree((LPVOID) pFileStart, 0, MEM_RELEASE);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_char.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "ppdchar.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\pfbdump\pfbdump.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pfbdump.c

Abstract:

    dump out PFB files as ASCII text
    
Revision History:

	12/30/96 -davidx-
		Created it.

--*/


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <ctype.h>
#include <string.h>

char *progname;
char hexdigits[] = "0123456789ABCDEF";
PBYTE pOutputBuffer;

#define MAX_OUTPUT_SIZE 0x400000

PVOID
MapFileIntoMemory(
    PSTR    pFilename,
    PDWORD  pFileSize
    )

{
    HANDLE  hFile, hFileMap;
    PVOID   pData;

    // Open a handle to the specified file

    hFile = CreateFile(pFilename,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return NULL;

    // Obtain the file size if requested

    if (pFileSize != NULL)
    {
        *pFileSize = GetFileSize(hFile, NULL);

        if (*pFileSize == 0xFFFFFFFF)
        {
            CloseHandle(hFile);
            return NULL;
        }
    }

    // Map the file into memory

    hFileMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (hFileMap != NULL)
    {
        pData = MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0);
        CloseHandle(hFileMap);
    }
    else
        pData = NULL;

    // We can safely close both the file mapping object and the file object itself.

    CloseHandle(hFile);

    return pData;
}

BOOL
WriteOutputData(
    PSTR    pFilename,
    PBYTE   pData,
    DWORD   size
    )

{
    HANDLE  hFile;

    // open a handle to the specified file

    hFile = CreateFile(pFilename,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
{ fprintf(stderr, "last error = %d\n", GetLastError());
        return FALSE;
}

    // write data to file

    if (WriteFile(hFile, pData, size, &size, NULL))
    {
        CloseHandle(hFile);
        return TRUE;
    }
    else
    {
        CloseHandle(hFile);
        DeleteFile(pFilename);
        return FALSE;
    }
}

BOOL
DecodePFBData(
    PBYTE   pInput,
    DWORD   inputSize,
    PBYTE   pOutput,
    PDWORD  pOutputSize
    )

{
    PBYTE   pin, pend, pout;

    pin = pInput;
    pend = pInput + inputSize;
    pout = pOutput;

    while (pin < pend)
    {
        INT     seglen, index;
        BYTE    segtype;

        // each segment must start with 0x80

        if ((pend - pin) < 2 || *pin++ != 128)
            return FALSE;

        // check segment type

        segtype = *pin++;
        if (segtype == 3)       // EOF segment
            break;

        if ((pend - pin) < 4)
            return FALSE;
        
        seglen = ((DWORD) pin[0]      ) |
                 ((DWORD) pin[1] <<  8) |
                 ((DWORD) pin[2] << 16) |
                 ((DWORD) pin[3] << 24);

        pin += 4;
        if ((pend - pin) < seglen)
            return FALSE;

        if (segtype == 1)       // ASCII segment
        {
            // copy input data to output and
            // convert CR to CR/LF combination

            while (seglen--)
            {
                if ((*pout++ = *pin++) == '\r')
                    *pout++ = '\n';
            }
        }
        else if (segtype == 2)  // binary segment
        {
            // copy binary data to hex

            for (index=1; index <= seglen; index++)
            {
                *pout++ = hexdigits[*pin >> 4];
                *pout++ = hexdigits[*pin & 15];
                pin++;

                if (index%32 == 0 || index == seglen)
                {
                    *pout++ = '\r';
                    *pout++ = '\n';
                }
            }
        }
        else
            return FALSE;
    }

    *pOutputSize = (pout - pOutput);
    return TRUE;
}

BOOL
PFBDump(
    PSTR    pFilename
    )

{
    BOOL    result = FALSE;
    PBYTE   pInputData = NULL;
    CHAR    outputFilenameBuffer[MAX_PATH];
    PSTR    p, pEnd;
    DWORD   inputDataSize, outputDataSize;

    // make sure the input filename ends with .pfb extension

    if ((p = strrchr(pFilename, '.')) == NULL || _stricmp(p, ".pfb") != 0)
    {
        fprintf(stderr,
                "%s: file '%s' ignored because it doesn't have .PFB extension\n",
                progname,
                pFilename);

        return FALSE;
    }

    // map the input file into memory

    if (! (pInputData = MapFileIntoMemory(pFilename, &inputDataSize)))
    {
        fprintf(stderr,
                "%s: couldn't open input file '%s'\n",
                progname,
                pFilename);

        return FALSE;
    }

    // decode PFB data

    if (! DecodePFBData(pInputData, inputDataSize, pOutputBuffer, &outputDataSize))
    {
        fprintf(stderr,
                "%s: file '%s' doesn't seem to contain valid PFB data\n",
                progname,
                pFilename);

        goto exitdump;
    }

    if (outputDataSize > MAX_OUTPUT_SIZE)
    {
        fprintf(stderr,
                "%s: choked on '%s' because the output file is too big\n",
                progname,
                pFilename);

        exit(-1);
    }

    // name the output file with /FontName information in the PFB file
    // is there something similar to strstr() for searching a memory block?

    p = pOutputBuffer;
    pEnd = p + outputDataSize;

    while (p < pEnd)
    {
        if ((*p++ == '/') &&
            (pEnd - p) >= 8 &&
            memcmp(p, "FontName", 8) == 0)
        {
            p += 8;

            while (p < pEnd && isspace(*p))
                p++;
            
            if (p < pEnd && *p++ == '/')
            {
                PSTR s;
                INT  len;

                for (s=p; s < pEnd && !isspace(*s); s++)
                    ;

                len = s - p;

                if (len > 0 && len < MAX_PATH)
                {
                    CopyMemory(outputFilenameBuffer, p, len);
                    outputFilenameBuffer[len] = '\0';
                    break;
                }
            }

            p = pEnd;
        }
    }

    if (p == pEnd)
    {
        fprintf(stderr,
                "%s: couldn't find FontName in PFB file '%s'\n",
                progname,
                pFilename);

        goto exitdump;
    }

    // write data to output file

    if (! (result = WriteOutputData(outputFilenameBuffer, pOutputBuffer, outputDataSize)))
    {
        fprintf(stderr,
                "%s: couldn't write to output file '%s'\n",
                progname,
                outputFilenameBuffer);
    }

exitdump:

    UnmapViewOfFile(pInputData);
    return result;
}

int _cdecl
main(
    int argc,
    char **argv
    )

{
    progname = *argv++;
    argc--;

    if (argc == 0)
    {
        fprintf(stderr, "usage: %s filename ...\n", progname);
        return -1;
    }

    if (! (pOutputBuffer = malloc(MAX_OUTPUT_SIZE)))
    {
        fprintf(stderr, "%s: not enough memory\n");
        return -1;
    }

    while (argc--)
        PFBDump(*argv++);

    free(pOutputBuffer);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_csize.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "custsize.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_entry.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "ppdentry.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_kwd.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "ppdkwd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_parse.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "ppdparse.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\ps\ppdcheck\w_ppd.c ===
//
// Copyright (c) 1998 Microsoft Corporation
//
// This is just a wrapper file to allow a building the ppdcheck.exe
// in free builds without changes, since the output relies on the
// DBG define, which for ppdcheck is set in "sources"
//
#include "ppd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\ctt2gtt\cpinfo.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    cpinfo.c

Abstract:

    Copepage information handling.
    Extract codepage information from codepage text file.

Environment:

    Windows NT PostScript driver

Revision History:

--*/

#include        "precomp.h"

//
// Macros
//

#define IS_COMMENT(c)  ((c) == (BYTE)';')
#define EOL    '\n'

//
// Local function prototypes
//

PBYTE PubSkipComment( PBYTE );
INT IGetCommand(PBYTE, PBYTE);


//
// Main function
//

BOOL
BGetInfo(
    PBYTE pData,
    DWORD dwSize,
    DWORD *pdwCodePage,
    PBYTE pSelectCmd,
    PBYTE pUnSelectCmd)
{

    BYTE  aubType[32];
    PBYTE pstrType;
    PBYTE pTextData;
    INT   iRet;

    ASSERT(pData         != NULL && 
           pdwCodePage   != NULL &&
           pSelectCmd    != NULL &&
           pUnSelectCmd  != NULL );

    pstrType = aubType;
    pTextData = pData;


    do 
    {
        pTextData = PubSkipComment(pTextData);

        if (pTextData == NULL)
        {
            iRet = EOF;
            break;
        }

        iRet = sscanf( pTextData, "%s:", pstrType);

        if (iRet != 0 && iRet != EOF)
        {
            pTextData += strlen(pstrType);
        }

        pTextData = PubSkipComment(pTextData);

        switch(*pstrType) 
        {
        case 'c':
        case 'C':
            if(!_stricmp(pstrType, "codepage:"))
            {
                iRet = sscanf(pTextData, "%d", pdwCodePage);

                if (iRet != 0 && iRet != EOF)
                {
                    while (*pTextData != EOL)
                        pTextData ++;
                    pTextData ++;
                }

            }
            break;

        case 's':
        case 'S':
            if(!_stricmp(pstrType, "selectcmd:"))
            {
                iRet = IGetCommand(pTextData, pSelectCmd);

                if (iRet != 0 && iRet != EOF)
                {
                    while (*pTextData != EOL)
                        pTextData ++;
                    pTextData ++;
                }
            }
            break;
        case 'u':
        case 'U':
            if(!_stricmp(pstrType, "unselectcmd:"))
            {
                iRet = IGetCommand(pTextData, pUnSelectCmd);

                if (iRet != 0 && iRet != EOF)
                {
                    while (*pTextData != EOL)
                        pTextData ++;
                    pTextData ++;
                }
            }
            break;

        default:
            pTextData++;
        }
    }
    while(*pTextData != EOF && dwSize > (DWORD)(pTextData - pData));

    return TRUE;
}

PBYTE
PubSkipComment(
    PBYTE pData)
{
    ASSERT(pData != NULL);

    do
    {
        if (IS_COMMENT(*pData))
        {
            while (*pData != EOL)
                pData++;
            pData++;
        }
        else if (*pData == ' ')
        {
            pData++;
        }
        else if (*pData == 0x0d)
        {
            pData++;
        }
        else if (*pData == EOL)
        {
            pData++;
        }
        else if (*pData == EOF)
        {
            pData = NULL;
            break;
        }
        else
            break;

    } while (TRUE);

    return pData;
}

INT
IGetCommand(
    PBYTE pData,
    PBYTE pDestBuf)
{

    INT iCount;

    if (*pData == EOF)
    {
        return EOF;
    }

    if (*pData == '"')
    {
        pData ++;
    }
    else
    {
        return 0;
    }

    iCount = 0;

    while (*pData != '"')
    {
        *pDestBuf = *pData;
        pDestBuf ++;
        pData++;
        iCount++;
    }

    *pDestBuf = (BYTE)NULL;
    iCount++;

    return iCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\ctt2gtt\ctt2gtt.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    ctt2gtt.c

Abstract:


Environment:

    Windows NT PostScript driver

Revision History:

--*/

#include        "precomp.h"

//
// Macros
//

#define FILENAME_SIZE 256
#define CMD_SIZE      256

DWORD             gdwOutputFlags;

//
// flag definitions for gdwOutputFlags
//

#define OUTPUT_VERBOSE 0x00000001

//
// Local function prototypes
//

BOOL BiArgcheck(IN int, IN char**, IN OUT PWSTR, IN OUT PWSTR, IN OUT PWSTR);

//
// Globals
//

BYTE gcstrError1[] = "Usage:  ctt2gtt [-v] CP_file CTT_file GLY_file\n";
BYTE gcstrError2[] = "ctt2gtt: HeapCreate() failed\n.";
BYTE gcstrError3[] = "Cannot open file \"%ws\".\n";
BYTE gcstrError4[] = "Cannot create output file '%ws'.\n";
BYTE gcstrError5[] = "Failed to convert CTT to GlyphSetData.\n";
BYTE gcstrError6[] = "WriteFile fails: writes %ld bytes\n";
BYTE gcstrError7[] = "Failure of BGetInfo\n";


PSTR gcstrCTTType[] = { 
    "CTT_WTYPE_COMPOSE",
    "CTT_WTYPE_DIRECT",
    "CTT_WTYPE_PAIRED"};


INT  __cdecl
main(
    IN INT     iArgc,
    IN CHAR  **ppArgv)
/*++

Routine Description:

    main

Arguments:

    iArgc - Number of parameters in the following
    ppArgv - The parameters, starting with our name

Return Value:

    Return error code 

Note:


--*/
{

    HANDLE            hHeap;    // Acces to heap, to simulate driver environment
    HANDLE            hOutput;

    PWSTR             pwstrCTTName; // The file name being processed
    PWSTR             pwstrGlyName; // The output file 
    PWSTR             pwstrCPTName; // The Codepage info text

    WCHAR             awchCTTName[FILENAME_SIZE];  // The file name being processed
    WCHAR             awchGlyName[FILENAME_SIZE];  // The output file 
    WCHAR             awchCPTName[FILENAME_SIZE];  // The Codepage info text

    BYTE              aubSelectCmd[CMD_SIZE];
    BYTE              aubUnSelectCmd[CMD_SIZE];
    PBYTE             pubSelectCmd, pubUnSelectCmd;

    BYTE              aubFormatCmd[256];
    PBYTE             pCommand;
    WORD              wSize, wJ;

    PTRANSTAB         pCTTData;
    DWORD             dwCTTSize;
    PUNI_GLYPHSETDATA pGlyphSetData;
    DWORD             dwGlySize;
    DWORD             dwCodePage;

    PBYTE             pCPText;
    DWORD             dwCPTextSize;

    DWORD             dwWrittenSize; // Returned size from WriteFile
    HFILEMAP          hCTTFile, hCPText, hGlyphFile;

    pwstrCTTName = awchCTTName;
    pwstrGlyName = awchGlyName;
    pwstrCPTName = awchCPTName;

    if (!BiArgcheck(iArgc, ppArgv, pwstrCPTName, pwstrCTTName, pwstrGlyName))
    {
        fprintf( stderr, gcstrError1);
        return  -1;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {

        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("                      GlyphSetData\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("CODEPAGEINFO file\n");
        printf("Codepage info text file: %ws\n", pwstrCPTName);
        printf("CTT file               : %ws\n", pwstrCTTName);
        printf("Glyphset data          : %ws\n", pwstrGlyName);
    }

    hCPText = MapFileIntoMemory( (PWSTR)pwstrCPTName, 
                                 (PVOID)&pCPText,
                                 &dwCPTextSize );

    if (!hCPText)
    {
        fprintf( stderr, gcstrError3, pwstrCPTName);
        return  -2;
    }

    pubSelectCmd   = aubSelectCmd;
    pubUnSelectCmd = aubUnSelectCmd;

    if (!BGetInfo(pCPText,
                  dwCPTextSize,
                  &dwCodePage,
                  pubSelectCmd,
                  pubUnSelectCmd))
    {
        return -2;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("CODEPAGE\n");
        printf ("Codepage: %d\n        : %s\n        : %s\n",
                     dwCodePage,
                     pubSelectCmd,
                     pubUnSelectCmd);
    }

    if (*pubSelectCmd == (BYTE)NULL)
        pubSelectCmd = NULL;

    if (*pubUnSelectCmd == (BYTE)NULL)
        pubUnSelectCmd = NULL;

    UnmapFileFromMemory(hCPText);

    hHeap = HeapCreate( HEAP_NO_SERIALIZE, 0x10000, 0x100000 );

    if (!hHeap)
    {
        fprintf( stderr, gcstrError2);
        return  -2;
    }

    hCTTFile = MapFileIntoMemory( (PTSTR)pwstrCTTName,
                                  (PVOID)&pCTTData,
                                  &dwCTTSize );

    if (!pCTTData || dwCTTSize == 0)
    {
        fprintf( stderr, gcstrError3, pwstrCTTName);
        return  -2;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("CTT FILE INFORMATION\n");
        printf( "Type: %s\nFirst Char = 0x%x\nLast Char  = 0x%x\n",
                                      gcstrCTTType[ pCTTData->wType ],
                                      pCTTData->chFirstChar,
                                      pCTTData->chLastChar );
    }

    hGlyphFile = MapFileIntoMemory( (PTSTR)pwstrGlyName,
                                    (PVOID)&pGlyphSetData,
                                    &dwGlySize );

    if (!hGlyphFile)
    {
        pGlyphSetData = NULL;
        dwGlySize = 0;
    }

    if (!BConvertCTT2GTT( hHeap,
                          pCTTData,
                          dwCodePage,
                          0x20,
                          0xFF,
                          pubSelectCmd,
                          pubUnSelectCmd,
                          &pGlyphSetData,
                          dwGlySize))
    {
        fprintf( stderr,  gcstrError5);
        return  -3;
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        PUNI_CODEPAGEINFO pCodePageInfo;
        PGLYPHRUN         pGlyphRun;
        PMAPTABLE         pMapTable;
        TRANSDATA        *pTrans;
        DWORD             dwI;

        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("GLYPHSETDATA\n");
        printf ("GLYPHSETDATA.dwSize           : %d\n", pGlyphSetData->dwSize);
        printf ("             dwVersion        : %d\n", pGlyphSetData->dwVersion);
        printf ("             dwFlags          : %d\n", pGlyphSetData->dwFlags);
        printf ("             lPredefinedID    : %d\n", pGlyphSetData->lPredefinedID);
        printf ("             dwGlyphCount     : %d\n", pGlyphSetData->dwGlyphCount);
        printf ("             loRunOffset      : 0x%x\n", pGlyphSetData->loRunOffset);
        printf ("             dwRunCount       : %d\n", pGlyphSetData->dwRunCount);
        printf ("             dwCodePageCount  : 0x%d\n", pGlyphSetData->dwCodePageCount);
        printf ("             loCodePageOffset : 0x%x\n", pGlyphSetData->loCodePageOffset);
        printf ("             loMapTableOffset : 0x%x\n", pGlyphSetData->loMapTableOffset);
        printf("\n");

        pCodePageInfo = 
     (PUNI_CODEPAGEINFO)((PBYTE) pGlyphSetData + pGlyphSetData->loCodePageOffset);

        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("CODEPAGEINFO\n");
        for (dwI = 0; dwI < pGlyphSetData->dwCodePageCount; dwI ++)
        {
            printf ("UNI_CODEPAGEINFO[%d].dwCodePage                = %d\n",
                                                dwI, pCodePageInfo->dwCodePage);
            printf ("UNI_CODEPAGEINFO[%d].SelectSymbolSet.dwCount   = %d\n",
                                   dwI, pCodePageInfo->SelectSymbolSet.dwCount);
            printf ("UNI_CODEPAGEINFO[%d].SelectSymbolSet:Command   = %s\n",
             dwI, (PBYTE)pCodePageInfo+pCodePageInfo->SelectSymbolSet.loOffset);
            printf ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet.dwCount = %d\n",
                                 dwI, pCodePageInfo->UnSelectSymbolSet.dwCount);
            printf ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet:Command = %s\n",
           dwI, (PBYTE)pCodePageInfo+pCodePageInfo->UnSelectSymbolSet.loOffset);
            pCodePageInfo++;
        }

        pGlyphRun =
                (PGLYPHRUN) ((PBYTE)pGlyphSetData + pGlyphSetData->loRunOffset);

        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("GLYPHRUN\n");
        for (dwI = 0; dwI < pGlyphSetData->dwRunCount; dwI ++)
        {
             printf("GLYPHRUN[%2d].wcLow       = 0x%-4x\n", dwI, pGlyphRun->wcLow);
             printf("GLYPHRUN[%2d].wGlyphCount = %d\n", dwI, pGlyphRun->wGlyphCount);
             pGlyphRun++;
        }

        pMapTable = (PMAPTABLE) ((PBYTE)pGlyphSetData +
                                 pGlyphSetData->loMapTableOffset);
        pTrans = pMapTable->Trans;

        printf("\n");
        printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        printf("MAPTABLE\n");
        printf("MAPTABLE.dwSize     = %d\n", pMapTable->dwSize);
        printf("MAPTABLE.dwGlyphNum = %d\n", pMapTable->dwGlyphNum);

        for (dwI = 0; dwI < pMapTable->dwGlyphNum; dwI ++)
        {
            printf("MAPTABLE.pTrans[%5d].ubCodePageID = %d\n",
                dwI, pTrans[dwI].ubCodePageID);
            printf("MAPTABLE.pTrans[%5d].ubType       = %d\n",
                dwI, pTrans[dwI].ubType);

            switch(pTrans[dwI].ubType)
            {
            case MTYPE_DIRECT:
                printf("MAPTABLE.pTrans[%5d].ubCode       = %d\n",
                    dwI+1, pTrans[dwI].uCode.ubCode);
                break;
            case MTYPE_PAIRED:
                printf("MAPTABLE.pTrans[%5d].ubPairs[0]   = %d\n",
                    dwI+1, pTrans[dwI].uCode.ubPairs[0]);
                printf("MAPTABLE.pTrans[%5d].ubPairs[1]   = %d\n",
                    dwI+1, pTrans[dwI].uCode.ubPairs[1]);
                break;
            case MTYPE_COMPOSE:
                printf("MAPTABLE.pTrans[%5d].sCode        = %x\n",
                    dwI+1, pTrans[dwI].uCode.sCode);
                pCommand = (PBYTE)pMapTable + pTrans[dwI].uCode.sCode;
                wSize = *(WORD*)pCommand;
                pCommand += 2;
                printf("Size                              = 0x%d\n", wSize);
                printf("Command                           = 0x");
                for (wJ = 0; wJ < wSize; wJ ++)
                {
                    printf("%02x",pCommand[wJ]);
                }
                printf("\n");
                break;
            }
        }

    }

    UnmapFileFromMemory(hCTTFile);

    hOutput = CreateFile(pwstrGlyName,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );

    if( hOutput == INVALID_HANDLE_VALUE )
    {
        fprintf( stderr, gcstrError4,  pwstrGlyName);
        return -2;
    }

    WriteFile( hOutput,
               pGlyphSetData,
               pGlyphSetData->dwSize,
               &dwWrittenSize,
               NULL );

    if( dwWrittenSize != pGlyphSetData->dwSize)
    {
        fprintf( stderr, gcstrError6, dwWrittenSize);
        return  -4;
    }

    HeapDestroy(hHeap);

    return  0;

}


BOOL
BiArgcheck(
    IN     INT    iArgc,
    IN     CHAR **ppArgv,
    IN OUT PWSTR   pwstrCPTName,
    IN OUT PWSTR   pwstrCTTName,
    IN OUT PWSTR   pwstrGlyName)
/*++

Routine Description:

    iArgcheck

Arguments:

    iArgc - Number of parameters in the following
    ppArgv - The parameters, starting with our name
    pwstrCPTName -
    pwstrCTTName -
    pwstrGlyName -

Return Value:

    If TRUE, function succeeded. Othewise FALSE.

Note:


--*/
{
    INT iI;
    INT iRet;

    if (iArgc > 5 || iArgc < 4)
    {
        return  FALSE;
    }

    if (iArgc == 5)
    {
        gdwOutputFlags |= OUTPUT_VERBOSE;
        ppArgv++;
    }

    ppArgv++;
    iRet = MultiByteToWideChar(CP_ACP, 0, *ppArgv, strlen(*ppArgv), pwstrCPTName, FILENAME_SIZE);
    *(pwstrCPTName + iRet) = (WCHAR)NULL;
    ppArgv++;
    iRet = MultiByteToWideChar(CP_ACP, 0, *ppArgv, strlen(*ppArgv), pwstrCTTName, FILENAME_SIZE);
    *(pwstrCTTName + iRet) = (WCHAR)NULL;
    ppArgv++;
    iRet = MultiByteToWideChar(CP_ACP, 0, *ppArgv, strlen(*ppArgv), pwstrGlyName, FILENAME_SIZE);
    *(pwstrGlyName + iRet) = (WCHAR)NULL;




    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\ctt2gtt\cttconv.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    cttconv.c

Abstract:

    Convert Win 3.1 CTT format tables to NT's GTT spec.

Environment:

    Windows NT PostScript driver

Revision History:

--*/

#include        "precomp.h"

//
// Debug flags
//

#define SET_PRINT 0
#define SET_RIP   0

//
//   Some macro definitions.
//

#define BBITS      8                          /* Bits in a byte */
#define DWBITS     (BBITS * sizeof( DWORD ))  /* Bits in a DWORD */
#define DW_MASK    (DWBITS - 1)

//
// Local
//

BYTE ubGetAnsi(WCHAR, INT, PWCHAR, PBYTE);

//
// Conversion function
//

BOOL
BConvertCTT2GTT(
    IN     HANDLE             hHeap,
    IN     PTRANSTAB          pCTTData,
    IN     DWORD              dwCodePage,
    IN     WCHAR              wchFirst,
    IN     WCHAR              wchLast,
    IN     PBYTE              pCPSel,
    IN     PBYTE              pCPUnSel,
    IN OUT PUNI_GLYPHSETDATA *ppGlyphSetData,
    IN     DWORD              dwGlySize)
/*++

Routine Description:

    Conversion from CTT to GLYPHSETDATA

Arguments:

    hHeap - Heap handle
    pCTTData - Pointer to the 3.1 format translate table
    dwCodePage - additonal codepage
    pCPSel - symbol set selection command null terminate string.
    pCPUnsel - symbol set selection command null terminate string.
    ppGlyphSetData - Pointer to the GlyphSetData pointer

Return Value:

    If TRUE, function succeeded. Othewise FALSE.

Note:

    Allocates memory from the heap for this.

--*/
{
    UNI_CODEPAGEINFO  CodePageInfo; 
    UNI_GLYPHSETDATA  GlyphSetData;
    PGLYPHRUN         pOldGlyphRun, pOldGlyphFirst,
                      pNewGlyphRun, pNewGlyphFirst;
    PMAPTABLE         pOldMapTable, pNewMapTable;
    PUNI_CODEPAGEINFO pOldCodePageInfo;
    TRANSDATA        *pTrans;

    WCHAR             awchUnicode[ 256 ];   // Converted array of points
    WCHAR             wchMin;           /* Find the first unicode value */
    WCHAR             wchMax;           /* Find the last unicode value */
    WCHAR             wchChar;

    DWORD            *pdwBits;   /* For figuring out runs */
    DWORD             dwFlags;
    DWORD             dwOldCodePageCount;
    DWORD             dwOldCPCmdSize;
    DWORD             dwI;
    DWORD             dwcbBits;   /* Size of this area */
    DWORD             dwMapTableCommandOffset;

    WORD              wType;
    WORD              wcbData;
    WORD              wI;

    INT               iI, iJ;        // Loop index
    INT               iIndex;
    INT               iNumOfHandle;  // The number of handles we need
    INT               iNumOfHandleInCTT;  // The number of handles in CTT
    INT               iTotalOffsetCmd;
    INT               iTotalGlyphSetDataSize;
    INT               iTotalCommandSize;
    INT               iAdditionalGlyphRun;
    INT               iAdditionalMapTable;
    INT               iSizeOfSelUnsel;
    INT               iNumOfRuns;     /* Number of runs we create */

    BYTE              aubAnsi[ 256 ];
    BYTE             *pbBase;
    BYTE              ubCodePageID;
    BYTE             *pMapTableCommand;
    BYTE             *pubData;
    BYTE              ubAnsi;

    BOOL              bInRun;    /* For processing run accumulations */


#define DWFLAGS_NEWCREATION 0x00000001

    //
    // Assertion
    //

    ASSERT(hHeap != NULL && pCTTData != NULL);

    //
    // Check if this is additional CTT.
    //

    #if 0
    if (*ppGlyphSetData == 0 || dwGlySize == 0)
    {
        dwFlags = DWFLAGS_NEWCREATION;
    }
    else
    {
        dwFlags = 0;
    }
    #else
    dwFlags = DWFLAGS_NEWCREATION;
    #endif

    //
    // 1. Create UNI_GLYPHSETDATA header
    // 2. Count total size of command in CTT.
    // 3. Create Unicode table
    // 4. Get min and max Unicode value
    // 5. Create Unicode bits table from CTT.
    // 6. Count the number of run.
    // 7. Create GLYPHRUN. 
    // 8. Create UNI_CODEPAGEINFO.
    // 9. Calculate total size of this file.
    // 10. Allocate memory for header, GLYPYRUN, CODEPAGEINFO
    // 11. Create MAPTABLE
    // 

    //
    //
    // 1. Initialize basic members of GLYPHSETDATA if necessary
    //
    //
    #if SET_RIP
    RIP(("1. Initialize basic members of GLYPHSETDATA if necessary.\n"));
    #elif SET_PRINT
    printf("1. Initialize basic members of GLYPHSETDATA if necessary.\n");
    #endif

    if (dwFlags & DWFLAGS_NEWCREATION)
    {
        GlyphSetData.dwVersion        = UNI_GLYPHSETDATA_VERSION_1_0;
        GlyphSetData.dwFlags          = 0;
        GlyphSetData.lPredefinedID    = CC_NOPRECNV;
        GlyphSetData.dwGlyphCount     = 0;
        GlyphSetData.dwRunCount       = 0;
        GlyphSetData.dwCodePageCount  = 1;
        GlyphSetData.loCodePageOffset = (DWORD)0;
        GlyphSetData.loMapTableOffset = (DWORD)0;

    }
    else
    {
        GlyphSetData.dwVersion        = (*ppGlyphSetData)->dwVersion;
        GlyphSetData.dwFlags          = (*ppGlyphSetData)->dwFlags;
        GlyphSetData.lPredefinedID    = (*ppGlyphSetData)->lPredefinedID;
        GlyphSetData.dwGlyphCount     = (*ppGlyphSetData)->dwGlyphCount;
        GlyphSetData.dwRunCount       = (*ppGlyphSetData)->dwRunCount;
        GlyphSetData.dwCodePageCount  = (*ppGlyphSetData)->dwCodePageCount +
                                        1;
        GlyphSetData.loCodePageOffset = (DWORD)0;
        GlyphSetData.loMapTableOffset = (DWORD)0;

        dwOldCodePageCount = (*ppGlyphSetData)->dwCodePageCount;
        pOldGlyphFirst =
        pOldGlyphRun = (PGLYPHRUN)((PBYTE)*ppGlyphSetData+
                                 (*ppGlyphSetData)->loRunOffset);
        pOldCodePageInfo = (PUNI_CODEPAGEINFO)((PBYTE)*ppGlyphSetData+
                                 (*ppGlyphSetData)->loCodePageOffset);
        pOldMapTable = (PMAPTABLE)((PBYTE)*ppGlyphSetData + 
                                 (*ppGlyphSetData)->loMapTableOffset);
    }

    //
    // 2. Total size of WTYPE_OFFSET format command in CTT.
    //
    #if SET_RIP
    RIP(("2. Count total number of run in CTT.\n"));
    #elif SET_PRINT
    printf("2. Count total number of run in CTT.\n");
    #endif

    wchFirst = min(pCTTData->chFirstChar, wchFirst);
    wchLast  = max(pCTTData->chLastChar, wchLast);

    GlyphSetData.dwGlyphCount =
    iNumOfHandle      = wchLast - wchFirst + 1;
    iNumOfHandleInCTT =  pCTTData->chLastChar - pCTTData->chFirstChar + 1;

    switch (pCTTData->wType)
    {
    case CTT_WTYPE_COMPOSE:
        iTotalOffsetCmd = pCTTData->uCode.psCode[iNumOfHandleInCTT] -
                          pCTTData->uCode.psCode[0] +
                          iNumOfHandleInCTT * 2;
        break;
    case CTT_WTYPE_DIRECT:
        iTotalOffsetCmd = 0;
        break;

    case CTT_WTYPE_PAIRED:
        iTotalOffsetCmd = 0;
        break;
    }


    //
    //  3. Create Unicode table
    //  We need to figure out how many runs are required to describe
    //  this font.  First obtain the correct Unicode encoding of these
    //  values,  then examine them to find the number of runs, and
    //  hence much extra storage is required.
    //
    #if SET_RIP
    RIP(("3. Create Unicode table.\n"));
    #elif SET_PRINT
    printf("3. Create Unicode table.\n");
    #endif
    
    //
    // We know it is < 256
    //

    for( iI = 0; iI < iNumOfHandle; ++iI )
        aubAnsi[ iI ] = (BYTE)(iI + wchFirst);

#ifdef NTGDIKM

    if( -1 == EngMultiByteToWideChar(dwCodePage,
                                     awchUnicode,
                                     (ULONG)(iNumOfHandle * sizeof(WCHAR)),
                                     (PCH) aubAnsi,
                                     (ULONG) iNumOfHandle))
    {
        return FALSE;
    }

#else

    if( ! MultiByteToWideChar(dwCodePage,
                              0,
                              aubAnsi,
                              iNumOfHandle,
                              awchUnicode,
                              iNumOfHandle))
    {
        return FALSE;
    }

#endif

    //
    //  4. Get min and max Unicode value
    //  Find the largest Unicode value, then allocate storage to allow us
    //  to  create a bit array of valid unicode points.  Then we can
    //  examine this to determine the number of runs.
    //
    #if SET_RIP
    RIP(("4. Get min and max Unicode value.\n"));
    #elif SET_PRINT
    printf("4. Get min and max Unicode value.\n");
    #endif

    for( wchMax = 0, wchMin = 0xffff, iI = 0; iI < iNumOfHandle; ++iI )
    {
        if( awchUnicode[ iI ] > wchMax )
            wchMax = awchUnicode[ iI ];
        if( awchUnicode[ iI ] < wchMin )
            wchMin = awchUnicode[ iI ];
    }

    //
    //  5. Create Unicode bits table from CTT.
    //  Note that the expression 1 + wchMax IS correct.   This comes about
    //  from using these values as indices into the bit array,  and that
    //  this is essentially 1 based.
    //
    #if SET_RIP
    RIP(("5. Create Unicode bits table from CTT.\n"));
    #elif SET_PRINT
    printf("5. Create Unicode bits table from CTT.\n");
    #endif

    dwcbBits = (1 + wchMax + DWBITS - 1) / DWBITS * sizeof( DWORD );

    if( !(pdwBits = (DWORD *)HeapAlloc( hHeap, 0, dwcbBits )) )
    {
        return  FALSE;     /*  Nothing going */
    }

    ZeroMemory( pdwBits, dwcbBits );

    //
    //   Set bits in this array corresponding to Unicode code points
    //

    for( iI = 0; iI < iNumOfHandle; ++iI )
    {
        pdwBits[ awchUnicode[ iI ] / DWBITS ] 
                    |= (1 << (awchUnicode[ iI ] & DW_MASK));
    }

    //
    //
    // 6. Count the number of run.
    //
    //
    #if SET_RIP
    RIP(("6. Count the number of run.\n"));
    #elif SET_PRINT
    printf("6. Count the number of run.\n");
    #endif

    if (dwFlags & DWFLAGS_NEWCREATION)
    {
        //
        //  Now we can examine the number of runs required.  For starters,
        //  we stop a run whenever a hole is discovered in the array of 1
        //  bits we just created.  Later we MIGHT consider being a little
        //  less pedantic.
        //

        bInRun = FALSE;
        iNumOfRuns = 0;

        for( iI = 0; iI <= (INT)wchMax; ++iI )
        {
            if( pdwBits[ iI / DWBITS ] & (1 << (iI & DW_MASK)) )
            {
                /*   Not in a run: is this the end of one? */
                if( !bInRun )
                {
                    /*   It's time to start one */
                    bInRun = TRUE;
                    ++iNumOfRuns;

                }

            }
            else
            {
                if( bInRun )
                {
                    /*   Not any more!  */
                    bInRun = FALSE;
                }
            }
        }

        GlyphSetData.dwRunCount = iNumOfRuns;

    }
    else
    {
        //
        // CTT addition case
        //

        iNumOfRuns = (*ppGlyphSetData)->dwRunCount;

        //
        // Merge CTT and GlyphRun
        //

        for (iI = 0; iI < iNumOfRuns; iI ++)
        {
            for (iJ = 0; iJ < pOldGlyphRun->wGlyphCount; iJ ++)
            {
                INT iGlyph = iJ + pOldGlyphRun->wcLow;

                pdwBits[ iGlyph / DWBITS ] |= (1 << (iGlyph & DW_MASK));
            }

            pOldGlyphRun++;
        }

        bInRun = FALSE;
        iNumOfRuns = 0;
        iNumOfHandle = 0;

        for( iI = 0; iI <= (INT)wchMax; ++iI )
        {
            if( pdwBits[ iI / DWBITS ] & (1 << (iI & DW_MASK)) )
            {
                /*   Not in a run: is this the end of one? */
                if( !bInRun )
                {
                    /*   It's time to start one */
                    bInRun = TRUE;
                    ++iNumOfRuns;

                }
                iNumOfHandle ++;

            }
            else
            {
                if( bInRun )
                {
                    /*   Not any more!  */
                    bInRun = FALSE;
                }
            }
        }
    }

    //
    // 7. Create GLYPHRUN
    //
    #if SET_RIP
    RIP(("7. Create GLYPHRUN.\n"));
    #elif SET_PRINT
    printf("7. Create GLYPHRUN.\n");
    #endif

    if( !(pNewGlyphFirst = pNewGlyphRun = 
        (PGLYPHRUN)HeapAlloc( hHeap, 0, iNumOfRuns * sizeof(GLYPHRUN) )) )
    {
        return  FALSE;     /*  Nothing going */
    }

    bInRun = FALSE;

    for (wI = 0; wI <= wchMax; wI ++)
    {
        if (pdwBits[ wI / DWBITS ] & (1 << (wI  & DW_MASK)) )
        {
            if (!bInRun)
            {
                bInRun = TRUE;
                pNewGlyphRun->wcLow = wI ;
                pNewGlyphRun->wGlyphCount = 1;
            }
            else
            {
                pNewGlyphRun->wGlyphCount++;
            }
        }
        else
        {

            if (bInRun)
            {
                bInRun = FALSE;
                pNewGlyphRun++;
            }
        }
    }


    pNewGlyphRun = pNewGlyphFirst;

    //
    //
    // 8. Create UNI_CODEPAGEINFO.
    //
    //
    #if SET_RIP
    RIP(("8. Create UNI_CODEPAGEINFO.\n"));
    #elif SET_PRINT
    printf("8. Create UNI_CODEPAGEINFO.\n");
    #endif

    CodePageInfo.dwCodePage              = dwCodePage;

    if (pCPSel)
    {
        CodePageInfo.SelectSymbolSet.dwCount = strlen(pCPSel) + 1;
    }
    else
    {
        CodePageInfo.SelectSymbolSet.dwCount = 0;
    }

    if (pCPUnSel)
    {
        CodePageInfo.UnSelectSymbolSet.dwCount = strlen(pCPUnSel) + 1;
    }
    else
    {
        CodePageInfo.UnSelectSymbolSet.dwCount = 0;
    }

    if (dwFlags & DWFLAGS_NEWCREATION)
    {
        if (pCPSel)
        {
            CodePageInfo.SelectSymbolSet.loOffset = sizeof(UNI_CODEPAGEINFO);
        }
        else
        {
            CodePageInfo.SelectSymbolSet.loOffset = 0;
        }
        if (pCPUnSel)
        {
            CodePageInfo.UnSelectSymbolSet.loOffset = sizeof(UNI_CODEPAGEINFO) +
                                         CodePageInfo.SelectSymbolSet.dwCount;
        }
        else
        {
            CodePageInfo.UnSelectSymbolSet.loOffset = 0;
        }
    }
    else
    {

        dwOldCPCmdSize = 0;

        for (dwI = 0; dwI < dwOldCodePageCount; dwI++)
        {
            dwOldCPCmdSize += (pOldCodePageInfo+dwI)->SelectSymbolSet.dwCount +
                              (pOldCodePageInfo+dwI)->UnSelectSymbolSet.dwCount;
            (pOldCodePageInfo+dwI)->SelectSymbolSet.loOffset +=
                                                       sizeof(UNI_CODEPAGEINFO);
            (pOldCodePageInfo+dwI)->UnSelectSymbolSet.loOffset +=
                                                       sizeof(UNI_CODEPAGEINFO);
        }

        CodePageInfo.SelectSymbolSet.loOffset =
                                    sizeof(UNI_CODEPAGEINFO) +
                                    dwOldCPCmdSize;
        CodePageInfo.UnSelectSymbolSet.loOffset =
                                    sizeof(UNI_CODEPAGEINFO) +
                                    dwOldCPCmdSize +
                                    CodePageInfo.SelectSymbolSet.dwCount; 
    }

    //
    //
    // 9. Calculate total size of this file.
    //
    //
    #if SET_RIP
    RIP(("9. Calculate total size of this file.\n"));
    #elif SET_PRINT
    printf("9. Calculate total size of this file.\n");
    #endif

    iSizeOfSelUnsel = CodePageInfo.SelectSymbolSet.dwCount +
                      CodePageInfo.UnSelectSymbolSet.dwCount;

    if (dwFlags & DWFLAGS_NEWCREATION)
    {

        iTotalGlyphSetDataSize = sizeof(UNI_GLYPHSETDATA) +
                                 sizeof(UNI_CODEPAGEINFO) +
                                 iSizeOfSelUnsel +
                                 iNumOfRuns * sizeof( GLYPHRUN ) +
                                 sizeof(MAPTABLE) +
                                 (iNumOfHandle - 1) * sizeof(TRANSDATA) +
                                 iTotalOffsetCmd;
    }
    else
    {
        iTotalGlyphSetDataSize = sizeof(UNI_GLYPHSETDATA) +
                                 dwOldCodePageCount * sizeof(UNI_CODEPAGEINFO) +
                                 sizeof(UNI_CODEPAGEINFO) +
                                 dwOldCPCmdSize + 
                                 iSizeOfSelUnsel +
                                 iNumOfRuns * sizeof( GLYPHRUN ) +
                                 sizeof(MAPTABLE) +
                                 (iNumOfHandle - 1) * sizeof(TRANSDATA);
    }

    //
    //
    // 10. Allocate memory and set header, copy GLYPHRUN, CODEPAGEINFO
    //
    //
    #if SET_RIP
    RIP(("10. Allocate memory and set header, copy GLYPHRUN, CODEPAGEINFO.\n"));
    #elif SET_PRINT
    printf("10. Allocate memory and set header, copy GLYPHRUN, CODEPAGEINFO.\n");
    #endif

    if( !(pbBase = HeapAlloc( hHeap, 0, iTotalGlyphSetDataSize )) )
    {
        HeapFree( hHeap, 0, (LPSTR)pbBase );
        return  FALSE;
    }


    ZeroMemory( pbBase, iTotalGlyphSetDataSize );  //Safer if we miss something

    if (dwFlags & DWFLAGS_NEWCREATION)
    {
        GlyphSetData.dwSize           = iTotalGlyphSetDataSize;
        GlyphSetData.loRunOffset      = sizeof(UNI_GLYPHSETDATA);
        GlyphSetData.loCodePageOffset = sizeof(UNI_GLYPHSETDATA) +
                                        sizeof(GLYPHRUN) * iNumOfRuns;
        GlyphSetData.loMapTableOffset = sizeof(UNI_GLYPHSETDATA) +
                                        sizeof(GLYPHRUN) * iNumOfRuns +
                                        sizeof(UNI_CODEPAGEINFO) +
                                        CodePageInfo.SelectSymbolSet.dwCount +
                                        CodePageInfo.UnSelectSymbolSet.dwCount;
        CopyMemory(pbBase,
                   &GlyphSetData,
                   sizeof(UNI_GLYPHSETDATA));

        CopyMemory(pbBase+sizeof(UNI_GLYPHSETDATA),
                   pNewGlyphRun,
                   sizeof(GLYPHRUN) * iNumOfRuns);


        CopyMemory(pbBase +
                   GlyphSetData.loCodePageOffset,
                   &CodePageInfo,
                   sizeof(UNI_CODEPAGEINFO));

        if (pCPSel)
        {
            CopyMemory(pbBase +
                       GlyphSetData.loCodePageOffset +
                       sizeof(UNI_CODEPAGEINFO),
                       pCPSel,
                       CodePageInfo.SelectSymbolSet.dwCount);
        }

        if (pCPUnSel)
        {
            CopyMemory(pbBase +
                       GlyphSetData.loCodePageOffset +
                       sizeof(UNI_CODEPAGEINFO) +
                       CodePageInfo.SelectSymbolSet.dwCount,
                       pCPUnSel,
                   CodePageInfo.UnSelectSymbolSet.dwCount);
        }

        pNewMapTable = (PMAPTABLE)(pbBase + GlyphSetData.loMapTableOffset);
                                            
    }
    else
    {
        GlyphSetData.dwSize           = iTotalGlyphSetDataSize;
        GlyphSetData.loRunOffset      = sizeof(UNI_GLYPHSETDATA);
        GlyphSetData.loCodePageOffset = sizeof(UNI_GLYPHSETDATA) +
                                        sizeof(GLYPHRUN) * iNumOfRuns;
        GlyphSetData.loMapTableOffset = sizeof(UNI_GLYPHSETDATA) +
                                        sizeof(GLYPHRUN) * iNumOfRuns +
                                        sizeof(UNI_CODEPAGEINFO) *
                                        (dwOldCodePageCount + 1),
                                        dwOldCPCmdSize +
                                        CodePageInfo.SelectSymbolSet.dwCount +
                                        CodePageInfo.UnSelectSymbolSet.dwCount;

        CopyMemory(pbBase, &GlyphSetData, sizeof(UNI_GLYPHSETDATA));

        CopyMemory(pbBase + sizeof(UNI_GLYPHSETDATA),
                   pNewGlyphRun,
                   iNumOfRuns * sizeof (GLYPHRUN));

        CopyMemory(pbBase +
                   sizeof(UNI_GLYPHSETDATA) +
                   sizeof(GLYPHRUN) * iNumOfRuns,
                   pOldCodePageInfo,
                   sizeof(UNI_CODEPAGEINFO) * dwOldCodePageCount);

        CopyMemory(pbBase +
                   sizeof(UNI_GLYPHSETDATA) +
                   sizeof(GLYPHRUN) * iNumOfRuns +
                   sizeof(UNI_CODEPAGEINFO) * dwOldCodePageCount,
                   &CodePageInfo,
                   sizeof(UNI_CODEPAGEINFO));

        CopyMemory(pbBase +
                   sizeof(UNI_GLYPHSETDATA) +
                   sizeof(GLYPHRUN) * iNumOfRuns +
                   sizeof(UNI_CODEPAGEINFO) * (dwOldCodePageCount + 1),
                   (PBYTE)pOldCodePageInfo +
                   sizeof(UNI_CODEPAGEINFO) * dwOldCodePageCount,
                   dwOldCPCmdSize);

        if (pCPSel)
        {
            CopyMemory(pbBase +
                       sizeof(UNI_GLYPHSETDATA) +
                       sizeof(GLYPHRUN) * iNumOfRuns +
                       sizeof(UNI_CODEPAGEINFO) * (dwOldCodePageCount + 1) +
                       dwOldCPCmdSize,
                       pCPSel,
                       CodePageInfo.SelectSymbolSet.dwCount);
        }

        if (pCPUnSel)
        {
            CopyMemory(pbBase +
                       sizeof(UNI_GLYPHSETDATA) +
                       sizeof(GLYPHRUN)*iNumOfRuns +
                       sizeof(UNI_CODEPAGEINFO) * (dwOldCodePageCount + 1) +
                       dwOldCPCmdSize + CodePageInfo.SelectSymbolSet.dwCount,
                       pCPUnSel,
                       CodePageInfo.UnSelectSymbolSet.dwCount);
        }

        pNewMapTable = (PMAPTABLE)(pbBase + GlyphSetData.loMapTableOffset);
    }

    //
    //
    // 11. Now we create MAPTABLE.
    // size = MAPTABLE + (number of glyph - 1) x TRANSDATA
    //
    //
    #if SET_RIP
    RIP(("11. Now We create MAPTABLE.\n"));
    #elif SET_PRINT
    printf("11. Now We create MAPTABLE.\n");
    #endif

    pNewMapTable->dwSize = sizeof(MAPTABLE) +
                           (iNumOfHandle - 1) * sizeof(TRANSDATA) +
                           iTotalOffsetCmd;

    pNewMapTable->dwGlyphNum =  iNumOfHandle;

    pNewGlyphRun = pNewGlyphFirst;

    pTrans = pNewMapTable->Trans;

    if (dwFlags & DWFLAGS_NEWCREATION)
        ubCodePageID = 0;
    else
        ubCodePageID = (BYTE)((*ppGlyphSetData)->dwCodePageCount) - 1; 

    pMapTableCommand = (PBYTE)&(pNewMapTable->Trans[iNumOfHandle]);
    dwMapTableCommandOffset = sizeof(MAPTABLE) + 
                        (iNumOfHandle - 1) * sizeof(TRANSDATA);

    iTotalCommandSize = 0;
    iIndex = 0;

    for( iI = 0;  iI < iNumOfRuns; iI ++, pNewGlyphRun ++)
    {
        for( iJ = 0;  iJ < pNewGlyphRun->wGlyphCount; iJ ++)
        {
            wchChar = pNewGlyphRun->wcLow + iJ;

            ubAnsi = ubGetAnsi(wchChar, iNumOfHandle, awchUnicode, aubAnsi);
            
            if( ubAnsi >= pCTTData->chFirstChar &&
                ubAnsi <= pCTTData->chLastChar   )
            {
                BYTE   chTemp;

                chTemp = ubAnsi - pCTTData->chFirstChar;

                switch( pCTTData->wType )
                {
                case  CTT_WTYPE_DIRECT:
                    pTrans[iIndex].ubCodePageID = ubCodePageID;
                    pTrans[iIndex].ubType = MTYPE_DIRECT;
                    pTrans[iIndex].uCode.ubCode = 
                                      pCTTData->uCode.bCode[ chTemp ];
                    break;

                case  CTT_WTYPE_PAIRED:
                    pTrans[iIndex].ubCodePageID = ubCodePageID;
                    pTrans[iIndex].ubType = MTYPE_PAIRED;
                    pTrans[iIndex].uCode.ubPairs[0] = 
                                pCTTData->uCode.bPairs[ chTemp ][ 0 ];
                    pTrans[iIndex].uCode.ubPairs[1] = 
                                pCTTData->uCode.bPairs[ chTemp ][ 1 ];
                    break;

                case  CTT_WTYPE_COMPOSE:
                    wcbData = pCTTData->uCode.psCode[ chTemp + 1 ] -
                              pCTTData->uCode.psCode[ chTemp ];
                    pubData = (BYTE *)pCTTData +
                              pCTTData->uCode.psCode[chTemp];

                    pTrans[iIndex].ubCodePageID = ubCodePageID;
                    pTrans[iIndex].ubType       = MTYPE_COMPOSE;
                    pTrans[iIndex].uCode.sCode = (SHORT)dwMapTableCommandOffset;

                    #if SET_PRINT
                    {
                    DWORD dwK;

                    printf("ubAnsi  = 0x%x\n", ubAnsi);
                    printf("Offset  = 0x%x\n", dwMapTableCommandOffset);
                    printf("Size    = %d\n", wcbData);
                    printf("Command = ");
                    for (dwK = 0; dwK < wcbData; dwK ++)
                    {
                        printf("%02x", pubData[dwK]);
                    }
                    }
                    printf("\n");
                    #endif

                    *(WORD*)pMapTableCommand = (WORD)wcbData;
                    pMapTableCommand += 2;
                    CopyMemory(pMapTableCommand, pubData, wcbData);
                    pMapTableCommand += wcbData;
                    dwMapTableCommandOffset += 2 + wcbData;
                    iTotalCommandSize += wcbData + 2;
                    break;
                }
            }
            else
            {
                pTrans[iIndex].ubCodePageID = ubCodePageID;
                pTrans[iIndex].ubType = MTYPE_DIRECT;
                pTrans[iIndex].uCode.ubCode = ubAnsi;
            }

            iIndex++;
        }
    }

    //
    //
    // Set pointer.
    //
    //

    *ppGlyphSetData = (PUNI_GLYPHSETDATA)pbBase;

    return  TRUE;

}

BYTE
ubGetAnsi(
    WCHAR wchChar,
    INT   iNumOfHandle,
    PWCHAR pwchUnicode,
    PBYTE  pchAnsi)
{

    BYTE ubRet;
    INT iI;

    for (iI = 0; iI < iNumOfHandle; iI ++)
    {
        if (wchChar == pwchUnicode[iI])
        {
            ubRet =  pchAnsi[iI];
            break;
        }
    }

    return ubRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\ctt2gtt\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    CTT to UNI_GLYPHSETDATA conversion tool precompile header.
    All other header files should be included in this precompiled header.

Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>
#include        <win30def.h>
#include        <uni16gpc.h>
#include        <uni16res.h>
#include        <prntfont.h>
#include        <unilib.h>

#include        "local.h"
#include        "fmlib.h"

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\ctt2gtt\local.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    local.h

Abstract:


Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/

BOOL BGetInfo(PBYTE, DWORD, PDWORD, PBYTE, PBYTE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\gpc2gpd.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    gpc2gpd.c

Abstract:

    GPC-to-GPD conversion program

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

--*/

#include "gpc2gpd.h"

#if !defined(DEVSTUDIO) //  MDT only uses onre routine

VOID
VUsage(
    PSTR pstrProgName
    )

{
    printf("usage: gpc2gpd -I<GPC file>\r\n");
    printf("               -M<model index>\r\n");
    printf("               -R<resource DLL>\r\n");
    printf("               -O<GPD file>\r\n");
    printf("               -N<Model Name>\r\n");
    printf("               -S<0>      -- output display strings directly \r\n");
    printf("                 <1>      -- output display strings as value macros\r\n");
    printf("                             (see stdnames.gpd) \r\n");
    printf("                 <2>      -- output display strings as RC id's (see common.rc)\r\n");
    printf("               -P    -- if present, use spooler names for standard papersizes\r\n");
}

#endif  //!defined(DEVSTUDIO)

void
VOutputGlobalEntries(
    IN OUT PCONVINFO pci,
    IN PSTR pstrModelName,
    IN PSTR pstrResourceDLLName,
    IN PSTR pstrGPDFileName)
{
    VOut(pci, "*GPDSpecVersion: \"1.0\"\r\n");


    //
    // *CodePage should be defined in the included GPD file
    //
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "*Include: \"StdNames.gpd\"\r\n");
    else
        VOut(pci, "*CodePage: 1252\r\n");

    VOut(pci, "*GPDFileVersion: \"1.0\"\r\n");
    VOut(pci, "*GPDFileName: \"%s\"\r\n", pstrGPDFileName);

    VOut(pci, "*ModelName: \"%s\"\r\n", pstrModelName);
    VOut(pci, "*MasterUnits: PAIR(%d, %d)\r\n", pci->pdh->ptMaster.x, pci->pdh->ptMaster.y);
    VOut(pci, "*ResourceDLL: \"%s\"\r\n", pstrResourceDLLName);

    if (pci->pdh->fTechnology == GPC_TECH_TTY)
        VOut(pci, "*PrinterType: TTY\r\n");
    else if (pci->pmd->fGeneral & MD_SERIAL)
        VOut(pci, "*PrinterType: SERIAL\r\n");
    else
        VOut(pci, "*PrinterType: PAGE\r\n");

    if ((pci->pmd->fGeneral & MD_COPIES) && pci->ppc->sMaxCopyCount > 1)
        VOut(pci, "*MaxCopies: %d\r\n", pci->ppc->sMaxCopyCount);
    if (pci->pmd->sCartSlots > 0)
        VOut(pci, "*FontCartSlots: %d\r\n", pci->pmd->sCartSlots);

    if (pci->pmd->fGeneral & MD_CMD_CALLBACK)
        pci->dwErrorCode |= ERR_MD_CMD_CALLBACK;
}

#if !defined(DEVSTUDIO) //  MDT only uses the above code

void
VPrintErrors(
    IN HANDLE hLogFile,
    IN DWORD dwError)
{
    DWORD dwNumBytesWritten;
    DWORD i, len;

    for (i = 0; i < NUM_ERRS; i++)
    {
        if (dwError & gdwErrFlag[i])
        {
            len = strlen(gpstrErrMsg[i]);

            if (!WriteFile(hLogFile, gpstrErrMsg[i], len, &dwNumBytesWritten, NULL) ||
                dwNumBytesWritten != len)
                return;     // abort
        }
    }
}

INT _cdecl
main(
    INT     argc,
    CHAR   **argv
    )
/*++

Routine Desscription:

This routine parses the command line parameters, maps the GPC file into memory
and creates the output GPD file. It then starts converting GPC data by calling
various sub-routines. If any error occurs, it reports errors and tries to
continue if possible.

The following command line parameters are supported:
    -I<GPC_file> : the file name does not need double quotes. Ex. -Icanon330.gpc
    -M<model_id>: an integer, such as 1, which is the string resource id of the
                  the model name in the .rc file that comes with the given GPC
                  file.
    -N<model_name>: a string, such as "HP LaserJet 4L".
    -R<resource_dll>: the resource dll to be associated with the generated GPD
                      file. Ex. -Rcanon330.dll
    -O<GPD_file>: the output GPD file name. Ex. -Ohplj4l.gpd
    -S<style>: the string style used in generating the GPD file for standard names.
               -S0 means using the direct strings for *Name entries.
               -S1 means using string value macros for *Name entries. This is
                   mainly used for on-the-fly conversion. The value macros are
                   defined in printer5\inc\stdnames.gpd.
               -S2 means using RC string id's. These strings are defined in
                   printer5\inc\common.rc.
    -P         rcNameID: 0x7fffffff  for standard papersizes.

Arguments:
        argc - number of arguments
        **argv - pointer to an array of strings

Return value:
        0

--*/
{
    PSTR pstrProgName;
    PSTR pstrGPCFileName = NULL;
    WCHAR wstrGPCFile[MAX_PATH];
    PSTR pstrGPDFileName = NULL;
    WCHAR wstrGPDFile[MAX_PATH];
    PSTR pstrResourceDLLName = NULL;
    PSTR pstrModelName = NULL;
    HFILEMAP hGPCFileMap;
    CONVINFO    ci;     // structure to keep track conversion information
    DWORD   dwStrType = STR_MACRO; // default
    WORD wModelIndex;
    BOOL    bUseSystemPaperNames = FALSE;


    //
    // Go through the command line arguments
    //

    pstrProgName = *argv++;
    argc--;

    if (argc == 0)
        goto error_exit;

    for ( ; argc--; argv++)
    {
        PSTR    pArg = *argv;

        if (*pArg == '-' || *pArg == '/')
        {
            switch (*++pArg)
            {
            case 'I':
                pstrGPCFileName = ++pArg;
                break;

            case 'M':
                wModelIndex = (WORD)atoi(++pArg);
                break;

            case 'R':
                pstrResourceDLLName = ++pArg;
                break;

            case 'O':
                pstrGPDFileName = ++pArg;
                break;

            case 'N':
                pstrModelName = ++pArg;
                break;

            case 'S':
                dwStrType = atoi(++pArg);
                break;

            case 'P':
                bUseSystemPaperNames = TRUE;
                break;

            default:
                goto error_exit;
            }
        }
        else
            goto error_exit;
    }

    //
    // check if we have all the arguments needed
    //
    if (!pstrGPCFileName || !pstrGPDFileName || !pstrResourceDLLName ||
        !wModelIndex || !pstrModelName)
        goto error_exit;

    ZeroMemory((PVOID)&ci, sizeof(CONVINFO));

    //
    // Open the GPC file and map it into memory.
    //
    MultiByteToWideChar(CP_ACP, 0, pstrGPCFileName, -1, wstrGPCFile, MAX_PATH);
    hGPCFileMap = MapFileIntoMemory((LPCTSTR)wstrGPCFile, (PVOID *)&(ci.pdh), NULL);
    if (!hGPCFileMap)
    {
        ERR(("Couldn't open file: %ws\r\n", pstrGPCFileName));
        return (-1);
    }
    //
    // create the output GPD file. If the given file already exists,
    // overwrite it.
    //
    MultiByteToWideChar(CP_ACP, 0, pstrGPDFileName, -1, wstrGPDFile, MAX_PATH);
    ci.hGPDFile = CreateFile((PCTSTR)wstrGPDFile, GENERIC_WRITE, 0, NULL,
                          CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (ci.hGPDFile == INVALID_HANDLE_VALUE)
    {
        ERR(("Couldn't create file: %ws\r\n", pstrGPDFileName));
        UnmapFileFromMemory(hGPCFileMap);
        return (-1);
    }

    //
    // GPC file sanity check
    //
    if (ci.pdh->sMagic != 0x7F00 ||
        !(ci.pmd = (PMODELDATA)GetTableInfo(ci.pdh, HE_MODELDATA, wModelIndex-1)) ||
        !(ci.ppc = (PPAGECONTROL)GetTableInfo(ci.pdh, HE_PAGECONTROL,
                                            ci.pmd->rgi[MD_I_PAGECONTROL])))
    {
        ci.dwErrorCode |= ERR_BAD_GPCDATA;
        goto exit;
    }
    //
    // allocate dynamic buffers needed for conversion
    //
    if (!(ci.ppiSize=(PPAPERINFO)MemAllocZ(ci.pdh->rghe[HE_PAPERSIZE].sCount*sizeof(PAPERINFO))) ||
        !(ci.ppiSrc=(PPAPERINFO)MemAllocZ(ci.pdh->rghe[HE_PAPERSOURCE].sCount*sizeof(PAPERINFO))) ||
        !(ci.presinfo=(PRESINFO)MemAllocZ(ci.pdh->rghe[HE_RESOLUTION].sCount*sizeof(RESINFO))))
    {
        ci.dwErrorCode |= ERR_OUT_OF_MEMORY;
        goto exit;
    }

    ci.dwStrType = dwStrType;
    ci.bUseSystemPaperNames = bUseSystemPaperNames ;

    //
    // generate GPD data
    //
    VOutputGlobalEntries(&ci, pstrModelName, pstrResourceDLLName, pstrGPDFileName);
    VOutputUIEntries(&ci);
    VOutputPrintingEntries(&ci);

exit:
    UnmapFileFromMemory(hGPCFileMap);
    CloseHandle(ci.hGPDFile);
    if (ci.ppiSize)
        MemFree(ci.ppiSize);
    if (ci.ppiSrc)
        MemFree(ci.ppiSrc);
    if (ci.presinfo)
        MemFree(ci.presinfo);
    if (ci.dwErrorCode)
    {
        PWSTR   pwstrLogFileName;
        INT     i;
        HANDLE  hLogFile;

        //
        // Open the log file and print out errors/warnings.
        // Borrow the GPD file name buffer.
        //
        pwstrLogFileName = wstrGPDFile;
        i = _tcslen((PTSTR)pwstrLogFileName);
        if (_tcsrchr((PTSTR)pwstrLogFileName, TEXT('.')) != NULL)
            i = i - 4; // there is a .GPD extension
        StringCchCopyW((PTSTR)pwstrLogFileName + i, CCHOF(wstrGPDFile) - i, TEXT(".log"));

        hLogFile = CreateFile((PCTSTR)pwstrLogFileName, GENERIC_WRITE, 0, NULL,
                         CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hLogFile == INVALID_HANDLE_VALUE)
        {
            ERR(("Couldn't create the log file\r\n"));
            return (-1);
        }
        VPrintErrors(hLogFile, ci.dwErrorCode);
        CloseHandle(hLogFile);
    }

    return 0;

error_exit:
    VUsage(pstrProgName);
    return (-1);
}

#endif  //  !defined(DEVSTUDIO)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\utils.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    header file for utility functions

Environment:

    user-mode only

Revision History:

    10/17/96 -zhanw-
        Created it.

--*/

//
// define bit flags for command conversion mode
//
#define MODE_STRING 0x0001  // within double quotes  "...". Writing out the
                            // openning double quote causes this bit be set
                            // and the closing double quote causes it be reset.
#define MODE_HEX    0x0002  // within angle brackets <...>. Writing out the
                            // left angle bracket causes this bit be set and
                            // the right angle bracket causes it be reset.
                            // To set MODE_HEX, MODE_STRING must be set first.
#define MODE_PARAM  0x0004  // within a parameter segment. It's mutual
                            // exclusive with MODE_STRING and MODE_HEX.

#define IS_CHAR_READABLE(ch) ((ch) >= 0x20 && (ch) <= 0x7E)

extern BYTE gbHexChar[16];

#define CMD_LINE_LENGTH_MAX     63
#define EOR 0xFFFFFFFF

extern PSTR gpstrSVNames[SV_MAX];
extern DWORD gdwSVLists[];
extern WORD gawCmdtoSVOffset[MAXCMD+MAXECMD];

typedef enum _FEATUREID {
    FID_PAPERDEST,
    FID_IMAGECONTROL,
    FID_PRINTDENSITY,
    FID_MAX
} FEATUREID;

extern PSTR gpstrFeatureName[FID_MAX];
extern PSTR gpstrFeatureDisplayName[FID_MAX];
extern PSTR gpstrFeatureDisplayNameMacro[FID_MAX];
extern INT  gintFeatureDisplayNameID[FID_MAX];
extern WORD gwFeatureMDOI[FID_MAX];
extern WORD gwFeatureOCDWordOffset[FID_MAX];
extern WORD gwFeatureHE[FID_MAX];
extern WORD gwFeatureORD[FID_MAX];
extern WORD gwFeatureCMD[FID_MAX];

#define STD_PS_DISPLAY_NAME_ID_BASE 10000
#define STD_IB_DISPLAY_NAME_ID_BASE 10256
#define STD_MT_DISPLAY_NAME_ID_BASE 10512
#define STD_TQ_DISPLAY_NAME_ID_BASE 10768

//
// standard paper size id's. Copied from Win95 source
//
#define DMPAPER_FIRST               DMPAPER_LETTER
#define DMPAPER_LETTER              1   /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL         2   /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID             3   /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER              4   /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL               5   /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT           6   /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE           7   /* Executive 7 1/4 x 10 1/2 in        */
#define DMPAPER_A3                  8   /* A3 297 x 420 mm                    */
#define DMPAPER_A4                  9   /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL             10  /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5                  11  /* A5 148 x 210 mm                    */
#define DMPAPER_B4                  12  /* B4 (JIS) 257 x 364 mm              */
#define DMPAPER_B5                  13  /* B5 (JIS) 182 x 257 mm              */
#define DMPAPER_FOLIO               14  /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO              15  /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14               16  /* 10 x 14 in                         */
#define DMPAPER_11X17               17  /* 11 x 17 in                         */
#define DMPAPER_NOTE                18  /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9               19  /* Envelope #9 3 7/8 x 8 7/8 in       */
#define DMPAPER_ENV_10              20  /* Envelope #10 4 1/8 x 9 1/2 in      */
#define DMPAPER_ENV_11              21  /* Envelope #11 4 1/2 x 10 3/8 in     */
#define DMPAPER_ENV_12              22  /* Envelope #12 4 3/4 x 11 in         */
#define DMPAPER_ENV_14              23  /* Envelope #14 5 x 11 1/2 in         */
#define DMPAPER_CSHEET              24  /* C size sheet                       */
#define DMPAPER_DSHEET              25  /* D size sheet                       */
#define DMPAPER_ESHEET              26  /* E size sheet                       */
#define DMPAPER_ENV_DL              27  /* Envelope DL  110 x 220 mm          */
#define DMPAPER_ENV_C5              28  /* Envelope C5  162 x 229 mm          */
#define DMPAPER_ENV_C3              29  /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4              30  /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6              31  /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65             32  /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4              33  /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5              34  /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6              35  /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY           36  /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH         37  /* Envelope Monarch 3 7/8 x 7 1/2 in  */
#define DMPAPER_ENV_PERSONAL        38  /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US          39  /* US Standard Fanfold 14 7/8 x 11 in */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Standard Fanfold 8 1/2 x 12 in  */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */
/*
** the following sizes are new in Windows 95
*/
#define DMPAPER_ISO_B4              42  /* B4 (ISO) 250 x 353 mm              */
#define DMPAPER_JAPANESE_POSTCARD   43  /* Japanese Postcard 100 x 148 mm     */
#define DMPAPER_9X11                44  /* 9 x 11 in                          */
#define DMPAPER_10X11               45  /* 10 x 11 in                         */
#define DMPAPER_15X11               46  /* 15 x 11 in                         */
#define DMPAPER_ENV_INVITE          47  /* Envelope Invite 220 x 220 mm       */
#define DMPAPER_RESERVED_48         48  /* RESERVED--DO NOT USE               */
#define DMPAPER_RESERVED_49         49  /* RESERVED--DO NOT USE               */
/*
** the following sizes were used in Windows 3.1 WDL PostScript driver
** and are retained here for compatibility with the old driver.
** Tranverse is used as in the PostScript language, and indicates that
** the physical page is rotated, but that the logical page is not.
*/
#define DMPAPER_LETTER_EXTRA          50  /* Letter Extra 9 1/2 x 12 in         */
#define DMPAPER_LEGAL_EXTRA           51  /* Legal Extra 9 1/2 x 15 in          */
#define DMPAPER_TABLOID_EXTRA         52  /* Tabloid Extra 11.69 x 18 in        */
#define DMPAPER_A4_EXTRA              53  /* A4 Extra 9.27 x 12.69 in           */
#define DMPAPER_LETTER_TRANSVERSE     54  /* Letter Transverse 8 1/2 x 11 in    */
#define DMPAPER_A4_TRANSVERSE         55  /* A4 Transverse 210 x 297 mm         */
#define DMPAPER_LETTER_EXTRA_TRANSVERSE 56/* Letter Extra Transverse 9 1/2 x 12 in  */
#define DMPAPER_A_PLUS              57  /* SuperA/SuperA/A4 227 x 356 mm      */
#define DMPAPER_B_PLUS              58  /* SuperB/SuperB/A3 305 x 487 mm      */
#define DMPAPER_LETTER_PLUS         59  /* Letter Plus 8.5 x 12.69 in         */
#define DMPAPER_A4_PLUS             60  /* A4 Plus 210 x 330 mm               */
#define DMPAPER_A5_TRANSVERSE       61  /* A5 Transverse 148 x 210 mm         */
#define DMPAPER_B5_TRANSVERSE       62  /* B5 (JIS) Transverse 182 x 257 mm   */
#define DMPAPER_A3_EXTRA            63  /* A3 Extra 322 x 445 mm              */
#define DMPAPER_A5_EXTRA            64  /* A5 Extra 174 x 235 mm              */
#define DMPAPER_B5_EXTRA            65  /* B5 (ISO) Extra 201 x 276 mm        */
#define DMPAPER_A2                  66  /* A2 420 x 594 mm                    */
#define DMPAPER_A3_TRANSVERSE       67  /* A3 Transverse 297 x 420 mm         */
#define DMPAPER_A3_EXTRA_TRANSVERSE 68  /* A3 Extra Transverse 322 x 445 mm   */

/*
** the following sizes are reserved for the Far East version of Win95.
** Rotated papers rotate the physical page but not the logical page.
*/
#define DMPAPER_DBL_JAPANESE_POSTCARD 69/* Japanese Double Postcard 200 x 148 mm */
#define DMPAPER_A6                  70  /* A6 105 x 148 mm                 */
#define DMPAPER_JENV_KAKU2          71  /* Japanese Envelope Kaku #2       */
#define DMPAPER_JENV_KAKU3          72  /* Japanese Envelope Kaku #3       */
#define DMPAPER_JENV_CHOU3          73  /* Japanese Envelope Chou #3       */
#define DMPAPER_JENV_CHOU4          74  /* Japanese Envelope Chou #4       */
#define DMPAPER_LETTER_ROTATED      75  /* Letter Rotated 11 x 8 1/2 11 in */
#define DMPAPER_A3_ROTATED          76  /* A3 Rotated 420 x 297 mm         */
#define DMPAPER_A4_ROTATED          77  /* A4 Rotated 297 x 210 mm         */
#define DMPAPER_A5_ROTATED          78  /* A5 Rotated 210 x 148 mm         */
#define DMPAPER_B4_JIS_ROTATED      79  /* B4 (JIS) Rotated 364 x 257 mm   */
#define DMPAPER_B5_JIS_ROTATED      80  /* B5 (JIS) Rotated 257 x 182 mm   */
#define DMPAPER_JAPANESE_POSTCARD_ROTATED 81 /* Japanese Postcard Rotated 148 x 100 mm */
#define DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED 82 /* Double Japanese Postcard Rotated 148 x 200 mm */
#define DMPAPER_A6_ROTATED          83  /* A6 Rotated 148 x 105 mm         */
#define DMPAPER_JENV_KAKU2_ROTATED  84  /* Japanese Envelope Kaku #2 Rotated*/
#define DMPAPER_JENV_KAKU3_ROTATED  85  /* Japanese Envelope Kaku #3 Rotated*/
#define DMPAPER_JENV_CHOU3_ROTATED  86  /* Japanese Envelope Chou #3 Rotated*/
#define DMPAPER_JENV_CHOU4_ROTATED  87  /* Japanese Envelope Chou #4 Rotated*/
#define DMPAPER_B6_JIS              88  /* B6 (JIS) 128 x 182 mm           */
#define DMPAPER_B6_JIS_ROTATED      89  /* B6 (JIS) Rotated 182 x 128 mm   */
#define DMPAPER_12X11               90  /* 12 x 11 in                      */
#define DMPAPER_JENV_YOU4           91  /* Japanese Envelope You #4        */
#define DMPAPER_JENV_YOU4_ROTATED   92  /* Japanese Envelope You #4 Rotated*/
#define DMPAPER_P16K                93  /* PRC 16K 146 x 215 mm            */
#define DMPAPER_P32K                94  /* PRC 32K 97 x 151 mm             */
#define DMPAPER_P32KBIG             95  /* PRC 32K(Big) 97 x 151 mm        */
#define DMPAPER_PENV_1              96  /* PRC Envelope #1 102 x 165 mm    */
#define DMPAPER_PENV_2              97  /* PRC Envelope #2 102 x 176 mm    */
#define DMPAPER_PENV_3              98  /* PRC Envelope #3 125 x 176 mm    */
#define DMPAPER_PENV_4              99  /* PRC Envelope #4 110 x 208 mm    */
#define DMPAPER_PENV_5              100 /* PRC Envelope #5 110 x 220 mm    */
#define DMPAPER_PENV_6              101 /* PRC Envelope #6 120 x 230 mm    */
#define DMPAPER_PENV_7              102 /* PRC Envelope #7 160 x 230 mm    */
#define DMPAPER_PENV_8              103 /* PRC Envelope #8 120 x 309 mm    */
#define DMPAPER_PENV_9              104 /* PRC Envelope #9 229 x 324 mm    */
#define DMPAPER_PENV_10             105 /* PRC Envelope #10 324 x 458 mm   */
#define DMPAPER_P16K_ROTATED        106 /* PRC 16K Rotated                 */
#define DMPAPER_P32K_ROTATED        107 /* PRC 32K Rotated                 */
#define DMPAPER_P32KBIG_ROTATED     108 /* PRC 32K(Big) Rotated            */
#define DMPAPER_PENV_1_ROTATED      109 /* PRC Envelope #1 Rotated 165 x 102 mm*/
#define DMPAPER_PENV_2_ROTATED      110 /* PRC Envelope #2 Rotated 176 x 102 mm*/
#define DMPAPER_PENV_3_ROTATED      111 /* PRC Envelope #3 Rotated 176 x 125 mm*/
#define DMPAPER_PENV_4_ROTATED      112 /* PRC Envelope #4 Rotated 208 x 110 mm*/
#define DMPAPER_PENV_5_ROTATED      113 /* PRC Envelope #5 Rotated 220 x 110 mm*/
#define DMPAPER_PENV_6_ROTATED      114 /* PRC Envelope #6 Rotated 230 x 120 mm*/
#define DMPAPER_PENV_7_ROTATED      115 /* PRC Envelope #7 Rotated 230 x 160 mm*/
#define DMPAPER_PENV_8_ROTATED      116 /* PRC Envelope #8 Rotated 309 x 120 mm*/
#define DMPAPER_PENV_9_ROTATED      117 /* PRC Envelope #9 Rotated 324 x 229 mm*/
#define DMPAPER_PENV_10_ROTATED     118 /* PRC Envelope #10 Rotated 458 x 324 mm */
#define DMPAPER_COUNT               DMPAPER_PENV_10_ROTATED

#define DMPAPER_USER        256
//
// define the mapping between standard paper size id to the standard
// PaperSize option name
//
extern PSTR gpstrStdPSName[DMPAPER_COUNT];
extern PSTR gpstrStdPSDisplayName[DMPAPER_COUNT];
extern PSTR gpstrStdPSDisplayNameMacro[DMPAPER_COUNT];

//
// standard input bin id's. Copied from Win95 source
//
#define DMBIN_FIRST         DMBIN_UPPER
#define DMBIN_UPPER         1
#define DMBIN_ONLYONE       1
#define DMBIN_LOWER         2
#define DMBIN_MIDDLE        3
#define DMBIN_MANUAL        4
#define DMBIN_ENVELOPE      5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO          7
#define DMBIN_TRACTOR       8
#define DMBIN_SMALLFMT      9
#define DMBIN_LARGEFMT      10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_FORMSOURCE    15      /* not supported under windows 95  */
#define DMBIN_LAST          DMBIN_FORMSOURCE

#define DMBIN_USER          256     /* device specific bins start here */

extern PSTR gpstrStdIBName[DMBIN_LAST];
extern PSTR gpstrStdIBDisplayName[DMBIN_LAST];
extern PSTR gpstrStdIBDisplayNameMacro[DMBIN_LAST];

//
// standard MediaType id's. Copied from Win95 source.
//
#define DMMEDIA_STANDARD      1   /* Standard paper */
#define DMMEDIA_TRANSPARENCY  2   /* Transparency */
#define DMMEDIA_GLOSSY        3   /* Glossy paper */
#define DMMEDIA_LAST          DMMEDIA_GLOSSY

#define DMMEDIA_USER        256   /* Device-specific media start here */

extern PSTR gpstrStdMTName[DMMEDIA_LAST];
extern PSTR gpstrStdMTDisplayName[DMMEDIA_LAST];
extern PSTR gpstrStdMTDisplayNameMacro[DMMEDIA_LAST];

//
// standard TextQuality id's. Copies from minidriv.h
//
#define DMTEXT_LQ               1
#define DMTEXT_NLQ              2
#define DMTEXT_MEMO             3
#define DMTEXT_DRAFT    4
#define DMTEXT_TEXT             5
#define DMTEXT_LAST             DMTEXT_TEXT
#define DMTEXT_USER             256

extern PSTR gpstrStdTQName[DMTEXT_LAST];
extern PSTR gpstrStdTQDisplayName[DMTEXT_LAST];
extern PSTR gpstrStdTQDisplayNameMacro[DMTEXT_LAST];

typedef enum _BAPOS {
    NONE,
    CENTER,
    LEFT,
    RIGHT,
    BAPOS_MAX
} BAPOS;

typedef enum _FACEDIR {
    UP,
    DOWN,
    FD_MAX
} FACEDIR;

extern PSTR gpstrPositionName[BAPOS_MAX];
extern PSTR gpstrFaceDirName[FD_MAX];
extern PSTR gpstrColorName[8];
extern WORD gwColorPlaneCmdID[4];
extern PSTR gpstrColorPlaneCmdName[8];
extern PSTR gpstrSectionName[7];

//
// function prototypes
//
//

void *
GetTableInfo(
    IN PDH pdh,                 /* Base address of GPC data */
    IN int iResType,            /* Resource type - HE_... values */
    IN int iIndex);              /* Desired index for this entry */

void _cdecl
VOut(
    PCONVINFO,
    PSTR,
    ...);

BOOL
BBuildCmdStr(
    IN OUT PCONVINFO pci,
    IN  WORD    wCmdID,
    IN  WORD    ocd);

void
VOutputSelectionCmd(
    IN OUT PCONVINFO pci,// contain info about the cmd to output
    IN BOOL    bDocSetup,  // whether in DOC_SETUP or PAGE_SETUP section
    IN WORD    wOrder);     // order number within the section

void
VOutputConfigCmd(
    IN OUT PCONVINFO pci,// contain info about the cmd to output
    IN PSTR pstrCmdName, // command name
    IN SEQSECTION  ss,      // sequence section id
    IN WORD    wOrder);      // order number within the section

void
VOutputCmd(
    IN OUT PCONVINFO pci,   // contain info about the cmd to output
    IN PSTR    pstrCmdName);

void
VOutputExternCmd(
    IN OUT PCONVINFO pci,
    IN PSTR pstrCmdName);

void
VOutputCmd2(
    IN OUT PCONVINFO pci,
    IN PSTR pstrCmdName);

BOOL
BInDocSetup(
    IN PCONVINFO pci,
    IN WORD pc_ord,     // PC_ORD_xxx id
    OUT PWORD pwOrder); // to store the order number as in GPC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\gpc2gpd.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpc2gpd.h

Abstract:

    Declarations for GPC-to-GPD converter

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

--*/

#ifndef _GPC2GPD_H_
#define _GPC2GPD_H_

#include <lib.h>

// include GPC data structure definition.
#include <win30def.h>
#include <uni16gpc.h>
#include <uni16cid.h>

#include <gpd.h>

typedef const TCHAR *PCTSTR;

#define MAX_GPD_CMD_LINE_LENGTH  80
#define MAX_GPD_ENTRY_BUFFER_SIZE    512  // may be multiple lines in GPD
#define MAX_OPTION_NAME_LENGTH  64

//
// structure to track which PAPERSIZE or PAPERSOURCE structure has _EJECTFF
// flag set.
//
typedef struct _PAPERINFO {
    BYTE aubOptName[MAX_OPTION_NAME_LENGTH];
    BOOL bEjectFF;
    DWORD dwPaperType;  // GPC's PS_T_xxx bit flags
    DWORD dwTopMargin;  // used by PaperSource only
    DWORD dwBottomMargin; // same as above
} PAPERINFO, * PPAPERINFO;

typedef struct _RESINFO {
    BYTE    aubOptName[MAX_OPTION_NAME_LENGTH];
    DWORD   dwXScale;  // scale of this resolution, masterX/xdpi
    DWORD   dwYScale;
    BOOL    bColor;     // whether this resolution can print color

} RESINFO, * PRESINFO;

//
// Converter state tracking and info caching structure
//
typedef struct _CONVINFO {
    DWORD dwErrorCode;  // error bit flags
    DWORD dwMode;       // op mode flags. Used to pass info between routines
    DWORD dwStrType;    // how to output display strings: macro, string, id
    BOOL    bUseSystemPaperNames ;  //  emit  RCID_DMPAPER_SYSTEM_NAME
#if defined(__cplusplus)
    CStringArray    *pcsaGPD;   //  Pointer to GPD memory image as array of strings
#else
    HANDLE hGPDFile;    // handle to the output file
#endif
    PDH pdh;            // pointer to the GPC data header
    PMODELDATA pmd;     // pointer to MODELDATA structure of the given model
    PPAGECONTROL ppc;   // pointer to PAGECONTROL structure used by the model
    OCD ocdPPOn;        // OCD for PageProtection-On command
    OCD ocdPPOff;       // OCD for PageProtection-Off command
    //
    // follow 3 fields are used to compose GPD cmds.
    //
    BYTE aubCmdBuf[MAX_GPD_ENTRY_BUFFER_SIZE];     // buffer for building cmd str
    WORD wCmdLen;       // the cmd length, not including the terminating NUL
    WORD wCmdCallbackID;    // 0 if no callback
    //
    // following dynamic buffers are used to track EJECTFF flag which could
    // come from either PAPERSIZE or PAPERSOURCE structures
    //
    DWORD dwNumOfSize;
    PPAPERINFO ppiSize;      // track PAPERSIZE structures
    DWORD dwNumOfSrc;
    PPAPERINFO ppiSrc;       // track PAPERSOURCE structures

    DWORD dwNumOfRes;
    PRESINFO    presinfo;   // track RESOLUTION structures
    //
    // other working buffers
    //
    PCURSORMOVE pcm;    // the CURSORMOVE structure for the model
    PGPCRESOLUTION pres;// the current RESOLUTION structure being examined.
                        // Used when CM_YM_RES_DEPENDENT bit is set.
    POINTw  ptMoveScale;    // masterUnit/moveUnit
#if defined(__cplusplus)
    CMapWordToDWord *pcmw2dFonts;   //  Font mapping for PFM -> multiple UFM fix
#endif

} CONVINFO, * PCONVINFO;

//
// bit flags for dwErrorCode
//
#define ERR_BAD_GPCDATA                     0x0001
#define ERR_OUT_OF_MEMORY                   0x0002
#define ERR_WRITE_FILE                      0x0004
#define ERR_MD_CMD_CALLBACK                 0x0008
#define ERR_CM_GEN_FAV_XY                   0x0010
#define ERR_CM_XM_RESET_FONT                0x0020
#define ERR_CM_XM_ABS_NO_LEFT               0x0040
#define ERR_CM_YM_TRUNCATE                  0x0080
#define ERR_RF_MIN_IS_WHITE                 0x0100
#define ERR_INCONSISTENT_PAGEPROTECT        0x0200
#define ERR_NON_ZERO_FEED_MARGINS_ON_RT90_PRINTER   0x0400
#define ERR_BAD_GPC_CMD_STRING              0x0800
#define ERR_RES_BO_RESET_FONT               0x1000
#define ERR_RES_BO_OEMGRXFILTER             0x2000
#define ERR_CM_YM_RES_DEPENDENT             0x4000
#define ERR_MOVESCALE_NOT_FACTOR_OF_MASTERUNITS            0x8000
#define ERR_NO_CMD_CALLBACK_PARAMS          0x00010000
#define ERR_HAS_DUPLEX_ON_CMD               0x00020000
#define ERR_PSRC_MAN_PROMPT                 0x00040000
#define ERR_PS_SUGGEST_LNDSCP               0x00080000
#define ERR_HAS_SECOND_FONT_ID_CMDS         0x00100000
#define ERR_DLI_FMT_CAPSL                   0x00200000
#define ERR_DLI_FMT_PPDS                    0x00400000
#define ERR_DLI_GEN_DLPAGE                  0x00800000
#define ERR_DLI_GEN_7BIT_CHARSET            0x01000000
#define ERR_DC_SEND_PALETTE                 0x02000000
#define ERR_RES_BO_NO_ADJACENT              0x04000000
#define ERR_MD_NO_ADJACENT                  0x08000000
#define ERR_CURSOR_ORIGIN_ADJUSTED          0x10000000
#define ERR_PRINTABLE_ORIGIN_ADJUSTED       0x20000000
#define ERR_PRINTABLE_AREA_ADJUSTED         0x40000000
#define ERR_MOVESCALE_NOT_FACTOR_INTO_SOME_RESSCALE 0x80000000

#define NUM_ERRS  32 // increment this number when defining new ERR_xxx!!!

#if defined(__cplusplus)
extern "C" {
#endif

extern DWORD gdwErrFlag[NUM_ERRS];
extern PSTR gpstrErrMsg[NUM_ERRS];

#if defined(__cplusplus)
}
#endif

//
// bit flags for dwMode
//
#define FM_SYN_PAGEPROTECT                  0x0001
#define FM_VOUT_LIST                        0x0002
#define FM_RES_DM_GDI                       0x0004
#define FM_RES_DM_DOWNLOAD_OUTLINE          0x0008
#define FM_NO_RES_DM_DOWNLOAD_OUTLINE       0x0010
#define FM_MEMORY_FEATURE_EXIST             0x0020
#define FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS  0x0040
#define FM_HAVE_SAME_TOP_BOTTOM_MARGINS     0x0080
#define FM_SET_CURSOR_ORIGIN         0x0100

//
// values for dwStrType field
//
#define STR_DIRECT  0   // output display strings directly. The default.
#define STR_MACRO   1   // output display strings as value macros (see stdnames.gpd)
#define STR_RCID    2   // output display strings as RC id's (see common.rc)
#define STR_RCID_SYSTEM_PAPERNAMES    3   // output display strings as RC id's (see common.rc)
                                                                //  Except use spooler standard papernames

//
// macro definitions to hide differences between GPC2.0 and GPC3.0
//
#define GETEXTCD(pdh, pcd) (PEXTCD)((PBYTE)(pcd+1) + (pcd)->wLength +    \
                                    (((pdh)->wVersion >= GPC_VERSION3) ? \
                                    (((pcd)->wLength) & 1) : 0))

#define LETTER300X300MEM 1028 // page protection memory constant in GPC2

#define GETPAGEPROMEM(pdh, pps) (((pdh)->wVersion >= GPC_VERSION3) ? \
                                 pps->wPageProtMem : LETTER300X300MEM)

#define DHOFFSET(pdh, sHeapOffset) ((PSHORT)(((PBYTE)(pdh)) + (pdh)->loHeap + \
                                sHeapOffset))

// utility functions for accessing GPC data & file ops.
#if defined(__cplusplus)
extern "C" {
#endif

#if defined(DEVSTUDIO) && defined(__cplusplus)
#include    "..\GPC2GPD\Utils.H"
#else
#include "utils.h"
#endif

//
// function prototypes
//
DWORD
DwCalcMoveUnit(
    IN PCONVINFO pci,
    IN PCURSORMOVE pcm,
    IN WORD wMasterUnit,
    IN WORD wStartOCD,
    IN WORD wEndOCD);

WORD WGetDefaultIndex(IN PCONVINFO pci, IN WORD wMDOI);

void VOutputUIEntries(IN OUT PCONVINFO pci);

void VOutputPrintingEntries(IN OUT PCONVINFO pci);

#if defined(DEVSTUDIO)
void    vMapFontList(IN OUT PWORD pwFonts, IN DWORD dwcFonts, IN PCONVINFO pci);
#endif

#if defined(__cplusplus)
}
#endif
#endif // !_GPC2GPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\utils.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Utility functions used by the GPC-to-GPD converter

Environment:

    user-mode only.

Revision History:

    10/17/96 -zhanw-
        Created it.

--*/

#include "gpc2gpd.h"

//
// define global read-only variables
//

BYTE gbHexChar[16] = {'0','1','2','3','4','5','6','7','8','9',
                 'A','B','C','D','E','F'};

DWORD gdwErrFlag[NUM_ERRS] = {
    ERR_BAD_GPCDATA,
    ERR_OUT_OF_MEMORY,
    ERR_WRITE_FILE,
    ERR_MD_CMD_CALLBACK,
    ERR_CM_GEN_FAV_XY,
    ERR_CM_XM_RESET_FONT,
    ERR_CM_XM_ABS_NO_LEFT,
    ERR_CM_YM_TRUNCATE,
    ERR_RF_MIN_IS_WHITE,
    ERR_INCONSISTENT_PAGEPROTECT,
    ERR_NON_ZERO_FEED_MARGINS_ON_RT90_PRINTER,
    ERR_BAD_GPC_CMD_STRING,
    ERR_RES_BO_RESET_FONT,
    ERR_RES_BO_OEMGRXFILTER,
    ERR_CM_YM_RES_DEPENDENT,
    ERR_MOVESCALE_NOT_FACTOR_OF_MASTERUNITS,
    ERR_NO_CMD_CALLBACK_PARAMS,
    ERR_HAS_DUPLEX_ON_CMD,
    ERR_PSRC_MAN_PROMPT,
    ERR_PS_SUGGEST_LNDSCP,
    ERR_HAS_SECOND_FONT_ID_CMDS,
    ERR_DLI_FMT_CAPSL,
    ERR_DLI_FMT_PPDS,
    ERR_DLI_GEN_DLPAGE,
    ERR_DLI_GEN_7BIT_CHARSET,
    ERR_DC_SEND_PALETTE,
    ERR_RES_BO_NO_ADJACENT,
    ERR_MD_NO_ADJACENT,
    ERR_CURSOR_ORIGIN_ADJUSTED,
    ERR_PRINTABLE_ORIGIN_ADJUSTED,
    ERR_PRINTABLE_AREA_ADJUSTED,
    ERR_MOVESCALE_NOT_FACTOR_INTO_SOME_RESSCALE
};

PSTR gpstrErrMsg[NUM_ERRS] = {
    "Error: Bad GPC data.\r\n",
    "Error: Out of system memory.\r\n",
    "Error: Cannot write to the GPD file.\r\n",
    "Warning: MODELDATA.fGeneral MD_CMD_CALLBACK is set.\r\n",
    "Warning: CURSORMODE.fGeneral CM_GEN_FAV_XY is set.\r\n",
    "Warning: CURSORMOVE.fXMove CM_XM_RESET_FONT is set.\r\n",
    "Warning: CURSORMOVE.fXMove CM_XM_ABS_NO_LEFT is set.\r\n",
    "Warning: CURSORMOVE.fYMove CM_YM_TRUNCATE is set.\r\n",
    "Warning: RECTFILL.fGeneral RF_MIN_IS_WHITE is set.\r\n",
    "Error: Inconsistent GPC data: some PAPERSIZE have PageProtect On/Off cmds while others do not. PageProtect feature is not generated.\r\n",
    "Error: Some PAPERSOURCE have non-zero top/bottom margins on this RT90 printer. Check the GPD file for details.\r\n",
    "Error: Some GPC command strings are illegal. Search for !ERR! in the GPD file.\r\n",
    "Warning: Some RESOLUTION have RES_BO_RESET_FONT flag set. Check the GPD file for details.\r\n",
    "Error: Some RESOLUTION have RES_BO_OEMGRXFILTER flag set. Check the GPD file for details.\r\n",
    "Error: The generated *YMoveUnit value is wrong because Y move cmds have dependency on the resolution. Correct it manually.\r\n",
    "Error: The MoveUnits are not factors of the MasterUnits.  Correct the GPC using Unitool before converting.\r\n",
    "Error: At least one callback command is generated. Check the GPD file to see if you need any parameters.\r\n",
    "Warning: PAGECONTROL has non-NULL DUPLEX_ON command.\r\n",
    "Warning: Some PAPERSOURCE have PSRC_MAN_PROMPT flag set. Check the GPD file for details.\r\n",
    "Warning: Some PAPERSIZE have PS_SUGGEST_LNDSCP flag set. Check the GPD file for details.\r\n",
    "Warning: DOWNLOADINFO has non-NULL xxx_SECOND_FONT_ID_xxx commands.\r\n",
    "Error: DLI_FMT_CAPSL flag is set. Must supply custom code to support this font format.\r\n",
    "Error: DLI_FMT_PPDS flag is set. Must supply custom code to support this font format.\r\n",
    "Warning: DLI_GEN_DLPAGE flag is set.\r\n",
    "Warning: DLI_GEN_7BIT_CHARSET flag is set.\r\n",
    "Warning: DEVCOLOR.fGeneral DC_SEND_PALETTE flag is set.\r\n",
    "Warning: Some RESOLUTION have RES_BO_NO_ADJACENT flag set. Check the GPD file for details.\r\n",
    "Warning: MODELDATA.fGeneral MD_NO_ADJACENT is set.\r\n",
    "Warning: Some *CursorOrigin values have been adjusted. Check the GPD file for details.\r\n",
    "Warning: Some *PrintableOrigin values have been adjusted. Check the GPD file for details.\r\n",
    "Warning: Some *PrintableArea values have been adjusted. Check the GPD file for details.\r\n",
    "Warning: Please check that every *PrintableOrigin (X,Y) factor evenly into the move unit scale X/Y.\r\n"
};

//
// define standard variable name strings
//
PSTR gpstrSVNames[SV_MAX] = {
    "NumOfDataBytes",
    "RasterDataWidthInBytes",
    "RasterDataHeightInPixels",
    "NumOfCopies",
    "PrintDirInCCDegrees",
    "DestX",
    "DestY",
    "DestXRel",
    "DestYRel",
    "LinefeedSpacing",
    "RectXSize",
    "RectYSize",
    "GrayPercentage",
    "NextFontID",
    "NextGlyph",
    "PhysPaperLength",
    "PhysPaperWidth",
    "FontHeight",
    "FontWidth",
    "FontMaxWidth",
    "FontBold",
    "FontItalic",
    "FontUnderline",
    "FontStrikeThru",
    "CurrentFontID",
    "TextYRes",
    "TextXRes",
    "GraphicsYRes",
    "GraphicsXRes",
    "Rop3",
    "RedValue",
    "GreenValue",
    "BlueValue",
    "PaletteIndexToProgram",
    "CurrentPaletteIndex"

};
//
// define the standard variable id heap. It consists of a series of id runs.
// Each run is a sequence of standard variable id's (SV_xxx value, 0-based)
// ended by -1 (0xFFFFFFFF). The runs are constructed based on the need of
// GPC commands. Basically, one run corresponds to one GPC command that
// requires parameters. If more than one GPC command share the same set of
// parameters, then they can share the same run.
//
DWORD gdwSVLists[] = {
    EOR,        // place holder for all GPC commands that has no parameter
    SV_NUMDATABYTES,    // CMD_RES_SENDBLOCK can have 3 params
    SV_HEIGHTINPIXELS,
    SV_WIDTHINBYTES,
    EOR,
    SV_COPIES,          // offset 5. CMD_PC_MULT_COPIES
    EOR,
    SV_DESTX,           // offset 7
    EOR,
    SV_DESTY,           // offset 9
    EOR,
    SV_DESTXREL,        // offset 11
    EOR,
    SV_DESTYREL,        // offset 13
    EOR,
    SV_LINEFEEDSPACING, // offset 15
    EOR,
    SV_DESTXREL,        // offset 17
    SV_DESTYREL,
    EOR,
    SV_DESTX,           // offset 20
    SV_DESTY,
    EOR,
    SV_RECTXSIZE,       // offset 23
    EOR,
    SV_RECTYSIZE,       // offset 25
    EOR,
    SV_GRAYPERCENT,     // offset 27
    EOR,
    SV_NEXTFONTID,      // offset 29
    EOR,
    SV_CURRENTFONTID,   // offset 31
    EOR,
    SV_NEXTGLYPH,       // offset 33
    EOR,
    SV_PHYSPAPERLENGTH, // offset 35
    SV_PHYSPAPERWIDTH,
    EOR,
    SV_PRINTDIRECTION,  // offset 38
    EOR,
    SV_NUMDATABYTES,    // offset 40
    EOR,
    SV_REDVALUE,        // offset 42
    SV_GREENVALUE,
    SV_BLUEVALUE,
    SV_PALETTEINDEXTOPROGRAM,
    EOR,
    SV_CURRENTPALETTEINDEX, // offset 47
    EOR
};
//
// map CMD_xxx id to the corresponding DWORD offset to the standard variable
// id heap. That is, gdwSVLists[gawCmdtoSVOffset[CMD_RES_SELECTRES]] is the
// beginning of a parameter run for GPC's command CMD_RES_SELECTRES. If the
// first element in the run of EOR, that means the command takes no param.
//
WORD gawCmdtoSVOffset[MAXCMD+MAXECMD] = {
    0,  // CMD_RES_SELECTRES
    0,  // CMD_RES_BEGINGRAPHICS
    0,  // CMD_RES_ENDGRAPHICS
    1,  // CMD_RES_SENDBLOCK
    0,  // CMD_RES_ENDBLOCK

    0,  // CMD_CMP_NONE
    0,  // CMD_CMP_RLE
    0,  // CMD_CMP_TIFF
    0,  // CMD_CMP_DELTAROW
    0,  // CMD_CMP_BITREPEAT
    0,  // CMD_CMP_FE_RLE

    0,  // CMD_PC_BEGIN_DOC
    0,  // CMD_PC_BEGIN_PAGE
    0,  // CMD_PC_DUPLEX_ON
    0,  // CMD_PC_ENDDOC
    0,  // CMD_PC_ENDPAGE
    0,  // CMD_PC_DUPLEX_OFF
    0,  // CMD_PC_ABORT
    0,  // CMD_PC_PORTRAIT, CMD_PC_ORIENTATION
    0,  // CMD_PC_LANDSCAPE
    5,  // CMD_PC_MULT_COPIES
    0,  // CMD_PC_DUPLEX_VERT
    0,  // CMD_PC_DUPLEX_HORZ
    38, // CMD_PC_PRINT_DIR
    0,  // CMD_PC_JOB_SEPARATION

    7,  // CMD_CM_XM_ABS
    11, // CMD_CM_XM_REL
    11, // CMD_CM_XM_RELLEFT
    9,  // CMD_CM_YM_ABS
    13, // CMD_CM_YM_REL
    13, // CMD_CM_YM_RELUP
    15, // CMD_CM_YM_LINESPACING
    17, // CMD_CM_XY_REL
    20, // CMD_CM_XY_ABS
    0,  // CMD_CM_CR
    0,  // CMD_CM_LF
    0,  // CMD_CM_FF
    0,  // CMD_CM_BS
    0,  // CMD_CM_UNI_DIR
    0,  // CMD_CM_UNI_DIR_OFF
    0,  // CMD_CM_PUSH_POS
    0,  // CMD_CM_POP_POS

    0,  // CMD_FS_BOLD_ON
    0,  // CMD_FS_BOLD_OFF
    0,  // CMD_FS_ITALIC_ON
    0,  // CMD_FS_ITALIC_OFF
    0,  // CMD_FS_UNDERLINE_ON
    0,  // CMD_FS_UNDERLINE_OFF
    0,  // CMD_FS_DOUBLEUNDERLINE_ON
    0,  // CMD_FS_DOUBLEUNDERLINE_OFF
    0,  // CMD_FS_STRIKETHRU_ON
    0,  // CMD_FS_STRIKETHRU_OFF
    0,  // CMD_FS_WHITE_TEXT_ON
    0,  // CMD_FS_WHITE_TEXT_OFF
    0,  // CMD_FS_SINGLE_BYTE
    0,  // CMD_FS_DOUBLE_BYTE
    0,  // CMD_FS_VERT_ON
    0,  // CMD_FS_VERT_OFF

    0,  // CMD_DC_TC_BLACK
    0,  // CMD_DC_TC_RED
    0,  // CMD_DC_TC_GREEN
    0,  // CMD_DC_TC_YELLOW
    0,  // CMD_DC_TC_BLUE
    0,  // CMD_DC_TC_MAGENTA
    0,  // CMD_DC_TC_CYAN
    0,  // CMD_DC_TC_WHITE
    0,  // CMD_DC_GC_SETCOLORMODE
    0,  // CMD_DC_PC_START
    42, // CMD_DC_PC_ENTRY
    0,  // CMD_DC_PC_END
    47, // CMD_DC_PC_SELECTINDEX
    0,  // CMD_DC_SETMONOMODE

    40, // CMD_DC_GC_PLANE1
    40, // CMD_DC_GC_PLANE2
    40, // CMD_DC_GC_PLANE3
    40, // CMD_DC_GC_PLANE4

    23, // CMD_RF_X_SIZE
    25, // CMD_RF_Y_SIZE
    27, // CMD_RF_GRAY_FILL
    0,  // CMD_RF_WHITE_FILL

    0,  // Reserved
    0,  // CMD_BEGIN_DL_JOB
    0,  // CMD_BEGIN_FONT_DL
    29, // CMD_SET_FONT_ID
    0,  // CMD_SEND_FONT_DCPT --- this command is no longer used.
    31, // CMD_SELECT_FONT_ID
    33, // CMD_SET_CHAR_CODE
    0,  // CMD_SEND_CHAR_DCPT --- this command is no longer used.
    0,  // CMD_END_FONT_DL
    0,  // CMD_MAKE_PERM
    0,  // CMD_MAKE_TEMP
    0,  // CMD_END_DL_JOB
    0,  // CMD_DEL_FONT
    0,  // CMD_DEL_ALL_FONTS
    0,  // CMD_SET_SECOND_FONT_ID    --- used only by CAPSL. Obsolete.
    0,  // CMD_SELECT_SECOND_FONT_ID --- used only by CAPSL. Obsolete.

    0,  // CMD_TEXTQUALITY
    0,  // CMD_PAPERSOURCE
    0,  // CMD_PAPERQUALITY
    0,  // CMD_PAPERDEST
    35, // CMD_PAPERSIZE
    35, // CMD_PAPERSIZE_LAND
    0,  // CMD_PAGEPROTECT_ON
    0,  // CMD_PAGEPROTECT_OFF
    0,  // CMD_IMAGECONTROL
    0   // CMD_PRINTDENSITY
};

PSTR gpstrFeatureName[FID_MAX] = {
    "OutputBin",
    "ImageControl",
    "PrintDensity"
};

PSTR gpstrFeatureDisplayNameMacro[FID_MAX] = {   // reference value macro names
    "OUTPUTBIN_DISPLAY",
    "IMAGECONTROL_DISPLAY",
    "PRINTDENSITY_DISPLAY"
};

PSTR gpstrFeatureDisplayName[FID_MAX] = {   // reference names
    "Output Bin",
    "Image Control",
    "Print Density"
};

INT gintFeatureDisplayNameID[FID_MAX] = {   // reference string resource ids
    2111,   // these values must match definitions in printer5\inc\common.rc
    2112,
    2113
};

WORD gwFeatureMDOI[FID_MAX] = {
    MD_OI_PAPERDEST,
    MD_OI_IMAGECONTROL,
    MD_OI_PRINTDENSITY
};

WORD gwFeatureOCDWordOffset[FID_MAX] = {
    3,
    3,
    2
};

WORD gwFeatureHE[FID_MAX] = {
    HE_PAPERDEST,
    HE_IMAGECONTROL,
    HE_PRINTDENSITY
};

WORD gwFeatureORD[FID_MAX] = {
    PC_ORD_PAPER_DEST,
    PC_ORD_IMAGECONTROL,
    PC_ORD_PRINTDENSITY
};

WORD gwFeatureCMD[FID_MAX] = {
    CMD_PAPERDEST,
    CMD_IMAGECONTROL,
    CMD_PRINTDENSITY
};
//
// define the mapping between standard paper size id to the standard
// PaperSize option name
//
PSTR gpstrStdPSName[DMPAPER_COUNT] = {
    "LETTER",
    "LETTERSMALL",
    "TABLOID",
    "LEDGER",
    "LEGAL",
    "STATEMENT",
    "EXECUTIVE",
    "A3",
    "A4",
    "A4SMALL",
    "A5",
    "B4",
    "B5",
    "FOLIO",
    "QUARTO",
    "10X14",
    "11X17",
    "NOTE",
    "ENV_9",
    "ENV_10",
    "ENV_11",
    "ENV_12",
    "ENV_14",
    "CSHEET",
    "DSHEET",
    "ESHEET",
    "ENV_DL",
    "ENV_C5",
    "ENV_C3",
    "ENV_C4",
    "ENV_C6",
    "ENV_C65",
    "ENV_B4",
    "ENV_B5",
    "ENV_B6",
    "ENV_ITALY",
    "ENV_MONARCH",
    "ENV_PERSONAL",
    "FANFOLD_US",
    "FANFOLD_STD_GERMAN",
    "FANFOLD_LGL_GERMAN",
    "ISO_B4",
    "JAPANESE_POSTCARD",
    "9X11",
    "10X11",
    "15X11",
    "ENV_INVITE",
    "",     // RESERVED_48
    "",     // RESERVED_49
    "LETTER_EXTRA",
    "LEGAL_EXTRA",
    "TABLOID_EXTRA",
    "A4_EXTRA",
    "LETTER_TRANSVERSE",
    "A4_TRANSVERSE",
    "LETTER_EXTRA_TRANSVERSE",
    "A_PLUS",
    "B_PLUS",
    "LETTER_PLUS",
    "A4_PLUS",
    "A5_TRANSVERSE",
    "B5_TRANSVERSE",
    "A3_EXTRA",
    "A5_EXTRA",
    "B5_EXTRA",
    "A2",
    "A3_TRANSVERSE",
    "A3_EXTRA_TRANSVERSE",
    "DBL_JAPANESE_POSTCARD",
    "A6",
    "JENV_KAKU2",
    "JENV_KAKU3",
    "JENV_CHOU3",
    "JENV_CHOU4",
    "LETTER_ROTATED",
    "A3_ROTATED",
    "A4_ROTATED",
    "A5_ROTATED",
    "B4_JIS_ROTATED",
    "B5_JIS_ROTATED",
    "JAPANESE_POSTCARD_ROTATED",
    "DBL_JAPANESE_POSTCARD_ROTATED",
    "A6_ROTATED",
    "JENV_KAKU2_ROTATED",
    "JENV_KAKU3_ROTATED",
    "JENV_CHOU3_ROTATED",
    "JENV_CHOU4_ROTATED",
    "B6_JIS",
    "B6_JIS_ROTATED",
    "12X11",
    "JENV_YOU4",
    "JENV_YOU4_ROTATED",
    "P16K",
    "P32K",
    "P32KBIG",
    "PENV_1",
    "PENV_2",
    "PENV_3",
    "PENV_4",
    "PENV_5",
    "PENV_6",
    "PENV_7",
    "PENV_8",
    "PENV_9",
    "PENV_10",
    "P16K_ROTATED",
    "P32K_ROTATED",
    "P32KBIG_ROTATED",
    "PENV_1_ROTATED",
    "PENV_2_ROTATED",
    "PENV_3_ROTATED",
    "PENV_4_ROTATED",
    "PENV_5_ROTATED",
    "PENV_6_ROTATED",
    "PENV_7_ROTATED",
    "PENV_8_ROTATED",
    "PENV_9_ROTATED",
    "PENV_10_ROTATED"
};

PSTR gpstrStdPSDisplayNameMacro[DMPAPER_COUNT] = {
    "LETTER_DISPLAY",
    "LETTERSMALL_DISPLAY",
    "TABLOID_DISPLAY",
    "LEDGER_DISPLAY",
    "LEGAL_DISPLAY",
    "STATEMENT_DISPLAY",
    "EXECUTIVE_DISPLAY",
    "A3_DISPLAY",
    "A4_DISPLAY",
    "A4SMALL_DISPLAY",
    "A5_DISPLAY",
    "B4_DISPLAY",
    "B5_DISPLAY",
    "FOLIO_DISPLAY",
    "QUARTO",
    "10X14_DISPLAY",
    "11X17_DISPLAY",
    "NOTE_DISPLAY",
    "ENV_9_DISPLAY",
    "ENV_10_DISPLAY",
    "ENV_11_DISPLAY",
    "ENV_12_DISPLAY",
    "ENV_14_DISPLAY",
    "CSHEET_DISPLAY",
    "DSHEET_DISPLAY",
    "ESHEET_DISPLAY",
    "ENV_DL_DISPLAY",
    "ENV_C5_DISPLAY",
    "ENV_C3_DISPLAY",
    "ENV_C4_DISPLAY",
    "ENV_C6_DISPLAY",
    "ENV_C65_DISPLAY",
    "ENV_B4_DISPLAY",
    "ENV_B5_DISPLAY",
    "ENV_B6_DISPLAY",
    "ENV_ITALY_DISPLAY",
    "ENV_MONARCH_DISPLAY",
    "ENV_PERSONAL_DISPLAY",
    "FANFOLD_US_DISPLAY",
    "FANFOLD_STD_GERMAN_DISPLAY",
    "FANFOLD_LGL_GERMAN_DISPLAY",
    "ISO_B4_DISPLAY",
    "JAPANESE_POSTCARD_DISPLAY",
    "9X11_DISPLAY",
    "10X11_DISPLAY",
    "15X11_DISPLAY",
    "ENV_INVITE_DISPLAY",
    "",            // RESERVED--DO NOT USE
    "",            // RESERVED--DO NOT USE
    "LETTER_EXTRA_DISPLAY",
    "LEGAL_EXTRA_DISPLAY",
    "TABLOID_EXTRA_DISPLAY",
    "A4_EXTRA_DISPLAY",
    "LETTER_TRANSVERSE_DISPLAY",
    "A4_TRANSVERSE_DISPLAY",
    "LETTER_EXTRA_TRANSVERSE_DISPLAY",
    "A_PLUS_DISPLAY",
    "B_PLUS_DISPLAY",
    "LETTER_PLUS_DISPLAY",
    "A4_PLUS_DISPLAY",
    "A5_TRANSVERSE_DISPLAY",
    "B5_TRANSVERSE_DISPLAY",
    "A3_EXTRA_DISPLAY",
    "A5_EXTRA_DISPLAY",
    "B5_EXTRA_DISPLAY",
    "A2_DISPLAY",
    "A3_TRANSVERSE_DISPLAY",
    "A3_EXTRA_TRANSVERSE_DISPLAY",
    "DBL_JAPANESE_POSTCARD_DISPLAY",
    "A6_DISPLAY",
    "JENV_KAKU2_DISPLAY",
    "JENV_KAKU3_DISPLAY",
    "JENV_CHOU3_DISPLAY",
    "JENV_CHOU4_DISPLAY",
    "LETTER_ROTATED_DISPLAY",
    "A3_ROTATED_DISPLAY",
    "A4_ROTATED_DISPLAY",
    "A5_ROTATED_DISPLAY",
    "B4_JIS_ROTATED_DISPLAY",
    "B5_JIS_ROTATED_DISPLAY",
    "JAPANESE_POSTCARD_ROTATED_DISPLAY",
    "DBL_JAPANESE_POSTCARD_ROTATED_DISPLAY",
    "A6_ROTATED_DISPLAY",
    "JENV_KAKU2_ROTATED_DISPLAY",
    "JENV_KAKU3_ROTATED_DISPLAY",
    "JENV_CHOU3_ROTATED_DISPLAY",
    "JENV_CHOU4_ROTATED_DISPLAY",
    "B6_JIS_DISPLAY",
    "B6_JIS_ROTATED_DISPLAY",
    "12X11_DISPLAY",
    "JENV_YOU4_DISPLAY",
    "JENV_YOU4_ROTATED_DISPLAY",
    "P16K_DISPLAY",
    "P32K_DISPLAY",
    "P32KBIG_DISPLAY",
    "PENV_1_DISPLAY",
    "PENV_2_DISPLAY",
    "PENV_3_DISPLAY",
    "PENV_4_DISPLAY",
    "PENV_5_DISPLAY",
    "PENV_6_DISPLAY",
    "PENV_7_DISPLAY",
    "PENV_8_DISPLAY",
    "PENV_9_DISPLAY",
    "PENV_10_DISPLAY",
    "P16K_ROTATED_DISPLAY",
    "P32K_ROTATED_DISPLAY",
    "P32KBIG_ROTATED_DISPLAY",
    "PENV_1_ROTATED_DISPLAY",
    "PENV_2_ROTATED_DISPLAY",
    "PENV_3_ROTATED_DISPLAY",
    "PENV_4_ROTATED_DISPLAY",
    "PENV_5_ROTATED_DISPLAY",
    "PENV_6_ROTATED_DISPLAY",
    "PENV_7_ROTATED_DISPLAY",
    "PENV_8_ROTATED_DISPLAY",
    "PENV_9_ROTATED_DISPLAY",
    "PENV_10_ROTATED_DISPLAY",
};

PSTR gpstrStdPSDisplayName[DMPAPER_COUNT] = {
    "Letter",
    "Letter Small",
    "Tabloid",
    "Ledger",
    "Legal",
    "Statement",
    "Executive",
    "A3",
    "A4",
    "A4 Small",
    "A5",
    "B4 (JIS)",
    "B5 (JIS)",
    "Folio",
    "Quarto",
    "10x14",
    "11x17",
    "Note",
    "Envelope #9",
    "Envelope #10",
    "Envelope #11",
    "Envelope #12",
    "Envelope #14",
    "C size sheet",
    "D size sheet",
    "E size sheet",
    "Envelope DL",
    "Envelope C5",
    "Envelope C3",
    "Envelope C4",
    "Envelope C6",
    "Envelope C65",
    "Envelope B4",
    "Envelope B5",
    "Envelope B6",
    "Envelope",
    "Envelope Monarch",
    "6 3/4 Envelope",
    "US Std Fanfold",
    "German Std Fanfold",
    "German Legal Fanfold",
    "B4 (ISO)",
    "Japanese Postcard",
    "9x11",
    "10x11",
    "15x11",
    "Envelope Invite",
    "",
    "",
    "Letter Extra",
    "Legal Extra",
    "Tabloid Extra",
    "A4 Extra",
    "Letter Transverse",
    "A4 Transverse",
    "Letter Extra Transverse",
    "Super A",
    "Super B",
    "Letter Plus",
    "A4 Plus",
    "A5 Transverse",
    "B5 (JIS) Transverse",
    "A3 Extra",
    "A5 Extra",
    "B5 (ISO) Extra",
    "A2",
    "A3 Transverse",
    "A3 Extra Transverse",
    "Japanese Double Postcard",
    "A6",
    "Japanese Envelope Kaku #2",
    "Japanese Envelope Kaku #3",
    "Japanese Envelope Chou #3",
    "Japanese Envelope Chou #4",
    "Letter Rotated",
    "A3 Rotated",
    "A4 Rotated",
    "A5 Rotated",
    "B4 (JIS) Rotated",
    "B5 (JIS) Rotated",
    "Japanese Postcard Rotated",
    "Double Japanese Postcard Rotated",
    "A6 Rotated",
    "Japanese Envelope Kaku #2 Rotated",
    "Japanese Envelope Kaku #3 Rotated",
    "Japanese Envelope Chou #3 Rotated",
    "Japanese Envelope Chou #4 Rotated",
    "B6 (JIS)",
    "B6 (JIS) Rotated",
    "12x11",
    "Japanese Envelope You #4",
    "Japanese Envelope You #4 Rotated",
    "PRC 16K",
    "PRC 32K",
    "PRC 32K(Big)",
    "PRC Envelope #1",
    "PRC Envelope #2",
    "PRC Envelope #3",
    "PRC Envelope #4",
    "PRC Envelope #5",
    "PRC Envelope #6",
    "PRC Envelope #7",
    "PRC Envelope #8",
    "PRC Envelope #9",
    "PRC Envelope #10",
    "PRC 16K Rotated",
    "PRC 32K Rotated",
    "PRC 32K(Big) Rotated",
    "PRC Envelope #1 Rotated",
    "PRC Envelope #2 Rotated",
    "PRC Envelope #3 Rotated",
    "PRC Envelope #4 Rotated",
    "PRC Envelope #5 Rotated",
    "PRC Envelope #6 Rotated",
    "PRC Envelope #7 Rotated",
    "PRC Envelope #8 Rotated",
    "PRC Envelope #9 Rotated",
    "PRC Envelope #10 Rotated"
};


PSTR gpstrStdIBName[DMBIN_LAST] = {
    "UPPER",
    "LOWER",
    "MIDDLE",
    "MANUAL",
    "ENVFEED",
    "ENVMANUAL",
    "AUTO",
    "TRACTOR",
    "SMALLFMT",
    "LARGEFMT",
    "LARGECAPACITY",
    "",     // non-contiguous id's
    "",
    "CASSETTE",
    ""
};

PSTR gpstrStdIBDisplayNameMacro[DMBIN_LAST] = {
    "UPPER_TRAY_DISPLAY",
    "LOWER_TRAY_DISPLAY",
    "MIDDLE_TRAY_DISPLAY",
    "MANUAL_FEED_DISPLAY",
    "ENV_FEED_DISPLAY",
    "ENV_MANUAL_DISPLAY",
    "AUTO_DISPLAY",
    "TRACTOR_DISPLAY",
    "SMALL_FORMAT_DISPLAY",
    "LARGE_FORMAT_DISPLAY",
    "LARGE_CAP_DISPLAY",
    "",            // non-contiguous id's
    "",
    "CASSETTE_DISPLAY",
    ""
};

PSTR gpstrStdIBDisplayName[DMBIN_LAST] = {
    "Upper Paper tray",      // DMBIN_FIRST
    "Lower Paper tray",      // DMBIN_UPPER
    "Middle Paper tray",     // DMBIN_LOWER
    "Manual Paper feed",     // DMBIN_MANUAL
    "Envelope Feeder",       // DMBIN_ENVELOPE
    "Envelope, Manual Feed", // DMBIN_ENVMANUAL
    "Auto",                  // DMBIN_AUTO
    "Tractor feed",          // DMBIN_TRACTOR
    "Small Format",          // DMBIN_SMALLFMT
    "Large Format",          // DMBIN_LARGEFMT
    "Large Capacity"         // DMBIN_LARGECAPACITY(11)
    "",
    "",
    "Cassette",              // DMBIN_CASETTE(14)
    "Automatically Select"   // DMBIN_FORMSOURCE(15)
};


PSTR gpstrStdMTName[DMMEDIA_LAST] = {
    "STANDARD",
    "TRANSPARENCY",
    "GLOSSY"
};

PSTR gpstrStdMTDisplayNameMacro[DMMEDIA_LAST] = {
    "PLAIN_PAPER_DISPLAY",
    "TRANSPARENCY_DISPLAY",
    "GLOSSY_PAPER_DISPLAY"
};

PSTR gpstrStdMTDisplayName[DMMEDIA_LAST] = {
    "Plain Paper",
    "Transparency",
    "Glossy Paper"
};


PSTR gpstrStdTQName[DMTEXT_LAST] = {
    "LETTER_QUALITY",
    "NEAR_LETTER_QUALITY",
    "MEMO_QUALITY",
    "DRAFT_QUALITY",
    "TEXT_QUALITY"
};

PSTR gpstrStdTQDisplayNameMacro[DMTEXT_LAST] = {
    "LETTER_QUALITY_DISPLAY",
    "NEAR_LETTER_QUALITY_DISPLAY",
    "MEMO_QUALITY_DISPLAY",
    "DRAFT_QUALITY_DISPLAY",
    "TEXT_QUALITY_DISPLAY"
};

PSTR gpstrStdTQDisplayName[DMTEXT_LAST] = {
    "Letter Quality",
    "Near Letter Quality",
    "Memo Quality",
    "Draft",
    "Text Quality"
};


PSTR gpstrPositionName[BAPOS_MAX] = {
    "NONE",
    "CENTER",
    "LEFT",
    "RIGHT"
};

PSTR gpstrFaceDirName[FD_MAX] = {
    "FACEUP",
    "FACEDOWN"
};

PSTR gpstrColorName[8] = {
    "NONE",
    "RED",
    "GREEN",
    "BLUE",
    "CYAN",
    "MAGENTA",
    "YELLOW",
    "BLACK"
};

WORD gwColorPlaneCmdID[4] = {
    CMD_DC_GC_PLANE1,
    CMD_DC_GC_PLANE2,
    CMD_DC_GC_PLANE3,
    CMD_DC_GC_PLANE4
};

PSTR gpstrColorPlaneCmdName[8] = {
    "NONE",
    "CmdSendRedData",
    "CmdSendGreenData",
    "CmdSendBlueData",
    "CmdSendCyanData",
    "CmdSendMagentaData",
    "CmdSendYellowData",
    "CmdSendBlackData"
};

PSTR gpstrSectionName[7] = {
    "",             // SS_UNINITIALIZED
    "JOB_SETUP",    // SS_JOBSETUP
    "DOC_SETUP",    // SS_DOCSETUP
    "PAGE_SETUP",   // SS_PAGESETUP
    "PAGE_FINISH",  // SS_PAGEFINISH
    "DOC_FINISH",   // SS_DOCFINISH
    "JOB_FINISH"    // SS_JOBFINISH
};


void *
GetTableInfo(
    IN PDH pdh,                 /* Base address of GPC data */
    IN int iResType,            /* Resource type - HE_... values */
    IN int iIndex)              /* Desired index for this entry */
{
    int   iLimit;

    //
    // Returns NULL if the requested data is out of range.
    //
    if (iResType >= pdh->sMaxHE)
        return NULL;
    iLimit = pdh->rghe[iResType].sCount;

    if (iLimit <= 0 || iIndex < 0 || iIndex >= iLimit )
        return  NULL;

    return  (PBYTE)pdh + pdh->rghe[iResType].sOffset +
                         pdh->rghe[iResType].sLength * iIndex;
}

#if !defined(DEVSTUDIO) //  MDS has its own version of this
void _cdecl
VOut(
    PCONVINFO pci,
    PSTR pstrFormat,
    ...)
/*++
Routine Description:
    This function formats a sequence of bytes and writes to the GPD file.

Arguments:
    pci - conversionr related info
    pstrFormat - the formatting string
    ... - optional arguments needed by formatting

Return Value:
    None
--*/
{
    va_list ap;
    DWORD dwNumBytesWritten;
    BYTE aubBuf[MAX_GPD_ENTRY_BUFFER_SIZE];
    int iSize;

    va_start(ap, pstrFormat);
    StringCchPrintfA((PSTR)aubBuf, CCHOF(aubBuf), pstrFormat, ap);
    va_end(ap);
    iSize = strlen(aubBuf);

    if (pci->dwMode & FM_VOUT_LIST)
    {
        //
        // check for the extra comma before the closing bracket
        //
        if (aubBuf[iSize-4] == ',' && aubBuf[iSize-3] == ')')
        {
            aubBuf[iSize-4] = aubBuf[iSize-3];  // ')'
            aubBuf[iSize-3] = aubBuf[iSize-2];  // '\r'
            aubBuf[iSize-2] = aubBuf[iSize-1];  // '\n'
            iSize--;
        }
    }
    if (!WriteFile(pci->hGPDFile, aubBuf, iSize, &dwNumBytesWritten, NULL) ||
        dwNumBytesWritten != (DWORD)iSize)
        pci->dwErrorCode |= ERR_WRITE_FILE;
    // continue even if an error has occurred.
}

#endif  //  defined(DEVSTUDIO)

void
EnterStringMode(
    OUT    PBYTE    pBuf,
    IN OUT PINT     pIndex,
    IN OUT PWORD    pwCMode)
/*++
Routine Description:
    This function enters the STRING mode and emits necessary characters to
    the output buffer.

Arguments:
    pBuf: the output buffer
    pIndex: pBuf[*pIndex] is where the next character should be written.
            The index should be updated if any character is emitted.
    pwCMode: pointer to the current mode value. It's updated per request.

Return Value:
    None

--*/
{
    if (!(*pwCMode & MODE_STRING))
    {
        pBuf[(*pIndex)++] = '"';
        *pwCMode |= MODE_STRING;
    }
    //
    // if we are also in HEX mode, exit HEX mode.
    //
    else if (*pwCMode & MODE_HEX)
    {
        pBuf[(*pIndex)++] = '>';
        *pwCMode &= ~MODE_HEX;
    }
}

void
ExitStringMode(
    OUT    PBYTE    pBuf,
    IN OUT PINT     pIndex,
    IN OUT PWORD    pwCMode)
/*++
Routine Description:
    This function exits the STRING mode and emits necessary characters to
    the output buffer. Check to see if we need to exit HEX mode first.

Arguments:
    pBuf: the output buffer
    pIndex: pBuf[*pIndex] is where the next character should be written.
            The index should be updated if any character is emitted.
    pwCMode: pointer to the current mode value. It's updated per request.

Return Value:
    None

--*/
{
    if (*pwCMode & MODE_HEX)
    {
        pBuf[(*pIndex)++] = '>';
        *pwCMode &= ~MODE_HEX;
    }
    if (*pwCMode & MODE_STRING)
    {
        pBuf[(*pIndex)++] = '"';
        *pwCMode &= ~MODE_STRING;
    }

}

void
EnterHexMode(
    OUT    PBYTE    pBuf,
    IN OUT PINT     pIndex,
    IN OUT PWORD    pwCMode)
/*++
Routine Description:
    This function enters the HEX mode and emits necessary characters to
    the output buffer.

Arguments:
    pBuf: the output buffer
    pIndex: pBuf[*pIndex] is where the next character should be written.
            The index should be updated if any character is emitted.
    pwCMode: pointer to the current mode value. It's updated per request.

Return Value:
    None

--*/
{
    //
    // if we are not in STRING mode, enter STRING mode first.
    //
    if (!(*pwCMode & MODE_STRING))
    {
        pBuf[(*pIndex)++] = '"';
        *pwCMode |= MODE_STRING;
    }
    if (!(*pwCMode & MODE_HEX))
    {
        pBuf[(*pIndex)++] = '<';
        *pwCMode |= MODE_HEX;
    }
}

BOOL
BBuildCmdStr(
    IN OUT PCONVINFO pci,
    IN  WORD    wCmdID,
    IN  WORD    ocd)
/*++
Routine Description:
    This function builds the null-terminated GPD command string, including
    double quotes, stadard variable references, parameter format, newlines
    (except the ending newline), and continuation character "+" if
    applicable. If the GPC command contains a callback id, fill the id in
    pci->wCmdCallbackID. Otherwise, fill it with 0 and fill pci->wCmdLen with
    the command length. If there is no command (NOOCD), fill both with 0.

    This function handles the special case where CM_YM_RES_DEPENDENT bit
    is set. In that case, the parameter expression needs to add
    (ValueIn / ptTextScale.y) as the first thing before considering other
    fields in EXTCD structure. All values passed in by Unidrv5 are in the
    master units, no exception. For this case, pci->pcm is set to the model's
    CURSORMOVE structure, and pci->pres is set to the current resolution
    being considered.

    This function handles the special case where RES_DM_GDI is not set (i.e.
    V_BYTE style output) and wCmdID is CMD_RES_SENDBLOCK. In that case, we need
    to add artifical divider equal to (pci->pres->sPinsPerPass / 8).
    This is to match the hard-coded conversion from NumOfDataBytes to the number
    of columns (in both Win95 Unidrv and NT4 RASDD).

    This function handles the special case for compression commands --- it would
    generate the "" command string (length == 2) even if it's NOOCD because the
    driver relies on its existence to enable compression code.

Arguments:
    pci: the conversion related info
    wCmdID: GPC command id. It's unique for each command in GPC.
    ocd: offset to the GPC CD structure on the GPC heap. The offset is
         relative to the beginning of the heap (instead of beginning of
         GPC data).

Return Value:
    TRUE if there is a real command. Otherwise, return FALSE (i.e. NOOCD).

--*/
{
    PCD     pcd;        // pointer to GPC's CD structure
    PBYTE   pBuf;   // buffer to hold the composed GPD cmd
    INT     i = 0;  // the next byte to write in the buffer
    INT     iPrevLines = 0; // the total # of bytes written for previous lines

    pci->wCmdCallbackID = 0;
    pBuf = pci->aubCmdBuf;

    if (ocd != (WORD)NOOCD)
    {
        pcd = (PCD)((PBYTE)(pci->pdh) + (pci->pdh)->loHeap + ocd);
        if (pcd->bCmdCbId > 0)
        {
            //
            // Command callback case. For simplicity, we do not write out
            // any parameters since each command takes different parameters.
            // Instead, we give a warning and ask the minidriver developer
            // to fill in *Param entry. After all, he may need different
            // parameters than what GPC dictates.
            //
            pci->wCmdCallbackID = (WORD)pcd->bCmdCbId;
            pci->dwErrorCode |= ERR_NO_CMD_CALLBACK_PARAMS;
        }
        else
        {
            WORD   wCMode = 0;  // bit flags indicating the conversion mode
            WORD   wFmtLen;     // size of command string remaining
            PSTR   pFmt;        // pointer into command string
            PEXTCD pextcd;      // points at next parameter's EXTCD
            WORD   wCount;      // number of parameters
            WORD   wNextParam=0;   // index of the next actual param
            PDWORD pdwSVList;

            pFmt = (PSTR)(pcd + 1);
            wFmtLen = pcd->wLength;
            pextcd = GETEXTCD(pci->pdh, pcd);
            wCount = pcd->wCount;
            pdwSVList = &(gdwSVLists[gawCmdtoSVOffset[wCmdID]]);


            while (wFmtLen > 0)
            {
                if (*pFmt != CMD_MARKER)
                {
                    if (IS_CHAR_READABLE(*pFmt))
                    {
                        EnterStringMode(pBuf, &i, &wCMode);
                        //
                        // check if it's the special character: ", <.
                        // If so, add the escape letter '%'
                        //
                        if (*pFmt == '"' || *pFmt == '<' )
                            pBuf[i++] = '%';
                        pBuf[i++] = *(pFmt++);
                    }
                    else    // non-readable ASCII: write out hex strings.
                    {
                        EnterHexMode(pBuf, &i, &wCMode);
                        pBuf[i++] = gbHexChar[(*pFmt & 0xF0) >> 4];
                        pBuf[i++] = gbHexChar[*pFmt & 0x0F];
                        *(pFmt++);
                    }
                    wFmtLen --;
                }
                else if (wFmtLen > 1 && *(++pFmt) == CMD_MARKER)
                {
                    //
                    // We have 2 '%' character to write out.
                    //
                    EnterStringMode(pBuf, &i, &wCMode);
                    pBuf[i++] = *pFmt;
                    pBuf[i++] = *(pFmt++);
                    wFmtLen -= 2;
                }
                else if (wFmtLen > 1) // we have a parameter format string
                {
                    INT iParam;     // index of the actual param used
                    DWORD   dwSV;   // GPD standard variable id


                    wFmtLen--;  // to account for already eaten '%'
                    ExitStringMode(pBuf, &i, &wCMode);
                    //
                    // insert a white space before the param segment
                    //
                    pBuf[i++] = ' ';
                    pBuf[i++] = '%';
                    //
                    // first, the format string
                    //
                    while (wFmtLen > 0 && *pFmt >= '0' && *pFmt <= '9')
                    {
                        pBuf[i++] = *(pFmt++);
                        wFmtLen--;
                    }
                                        if (wFmtLen > 0)
                                        {
                                                pBuf[i++] = *(pFmt++);    // copy the format letter d,D,...
                                                wFmtLen--;
                                        }
                                        else
                                        {
                                                pci->dwErrorCode |= ERR_BAD_GPC_CMD_STRING;
                                                pBuf[i++] = '!';
                                                pBuf[i++] = 'E';
                                                pBuf[i++] = 'R';
                                                pBuf[i++] = 'R';
                                                pBuf[i++] = '!';
                                                break;  // exit the while (wFmtLen > 0) loop
                                        }
                    //
                    // second, the limits if applicable.
                    //
                    // 12/19/97 zhanw
                    // Note: Win95 Unidrv uses !XCD_GEN_NO_MAX and
                    // pextcd->sMax if it's greater than 0 (for the cases of
                    // CMD_XM_LINESPACING and CMD_GEN_MAY_REPEAT), and it
                    // does NOT use pextcd->sMin at all. NT4 RASDD uses
                    // !XCD_GEN_NO_MIN and pextcd->sMin (any value, no
                    // particular purpose), and it uses pextcd->sMax without
                    // checking !XCD_GEN_NO_MAX (hacky way to handle
                    // max-repeat for CMD_RES_SENDBLOCK). Also, Unitool
                    // defaults pextcd->sMin to 0.
                    // Given that NT4 and Win95 share the same GPC source,
                    // the following code should suit both drivers' behavior.
                    //
                    //
                    if (pcd->wCount > 0)
                    {
                        //
                        // in this case, a valid EXTCD may specify limits
                        //
                        if (!(pextcd->fGeneral & XCD_GEN_NO_MAX) &&
                            pextcd->sMax > 0)
                        {
                            StringCchPrintfA((PSTR)&(pBuf[i]),
                                             CCHOF(pci->aubCmdBuf) - i,
                                             "[%d,%d]",
                                         (pextcd->fGeneral & XCD_GEN_NO_MIN) ?
                                          0 : (WORD)pextcd->sMin,
                                          (WORD)pextcd->sMax);        
                            i += strlen(&(pBuf[i]));
                        }
                    }
        	    // PatRyan - add limits for CmdCopies
		    if (wCmdID == CMD_PC_MULT_COPIES)
                   StringCchPrintfA((PSTR)&(pBuf[i]), 
                                    CCHOF(pci->aubCmdBuf) - i,
                                    "[1,%d]",
                                    pci->ppc->sMaxCopyCount);
                   i += strlen(&(pBuf[i]));
                    //
                    // third, the value.
                    //
                    if (pcd->wCount == 0)
                    {
                        //
                        // For this case, each format string wants
                        // the next parameter without modification
                        //
                        dwSV = pdwSVList[wNextParam++];
                        if (wCmdID == CMD_RES_SENDBLOCK &&
                            !(pci->pres->fDump & RES_DM_GDI) &&
                            dwSV == SV_NUMDATABYTES &&
                            pci->pres->sPinsPerPass != 8)

                        {
                            StringCchPrintfA((PSTR)&(pBuf[i]),
                                          CCHOF(pci->aubCmdBuf) - i,
                                          "{%s / %d}",
                                          gpstrSVNames[dwSV],
                                          pci->pres->sPinsPerPass / 8);
                            i += strlen(&(pBuf[i]));
                        }
                        else
                        {
                            StringCchPrintfA((PSTR)&(pBuf[i]),
                                          CCHOF(pci->aubCmdBuf) - i,
                                          "{%s}",
                                          gpstrSVNames[dwSV]);
                            i += strlen(&(pBuf[i]));
                        }
                    }
                    else
                    {
                        short sSBDDiv = 1; // special case for CmdSendBlockData

                        if (pci->pdh->wVersion < GPC_VERSION3)
                            // For this case, each EXTCD wants the next parameter
                            iParam = wNextParam++;
                        else
                            // For this case, each EXTCD specifies the parameter
                            iParam = pextcd->wParam;

                        dwSV = pdwSVList[iParam];

                        if (wCmdID == CMD_RES_SENDBLOCK &&
                            !(pci->pres->fDump & RES_DM_GDI) &&
                            dwSV == SV_NUMDATABYTES)
                        {
                            //
                            // sPinsPerPass is always a multiplier of 8.
                            //
                            sSBDDiv = pci->pres->sPinsPerPass / 8;
                        }

                        pBuf[i++] = '{';
                        //
                        // check if max_repeat is needed.
                        // Special case for CMD_CM_YM_LINESPACING: never use
                        // "max_repeat" by definition.
                        //
                        if (!(pextcd->fGeneral & XCD_GEN_NO_MAX) &&
                            pextcd->sMax > 0 &&
                            (pcd->fGeneral & CMD_GEN_MAY_REPEAT) &&
                            wCmdID != CMD_CM_YM_LINESPACING)
                        {
                            StringCchPrintfA((PSTR)&(pBuf[i]),
                                          CCHOF(pci->aubCmdBuf) - i,
                                          "max_repeat(");
                            i += strlen(&(pBuf[i]));
                        }
                        //
                        // compose the expression.
                        // Optimize for special cases.
                        //
                        if (pextcd->sPreAdd != 0)
                            pBuf[i++] = '(';
                        if (pextcd->sUnitMult > 1)
                            pBuf[i++] = '(';
                        if (pextcd->sUnitDiv > 1 || sSBDDiv > 1)
                            pBuf[i++] = '(';
                        StringCchPrintfA((PSTR)&(pBuf[i]),
                                             CCHOF(pci->aubCmdBuf) - i,
                                             "%s ", gpstrSVNames[dwSV]);
                        i += strlen(&(pBuf[i]));
                        //
                        // special check for CM_YM_RES_DEPENDENT flag
                        //
                        if ((wCmdID == CMD_CM_YM_ABS ||
                             wCmdID == CMD_CM_YM_REL ||
                             wCmdID == CMD_CM_YM_RELUP ||
                             wCmdID == CMD_CM_YM_LINESPACING) &&
                            (pci->pcm->fYMove & CM_YM_RES_DEPENDENT) &&
                            pci->pres->ptTextScale.y != 1)
                        {
                            StringCchPrintfA((PSTR)&(pBuf[i]),
                                         CCHOF(pci->aubCmdBuf) - i,
                                         "/ %d ",
                                          pci->pres->ptTextScale.y);
                            i += strlen(&(pBuf[i]));
                        }
                        //
                        // continue with normal processing
                        //
                        if (pextcd->sPreAdd > 0)
                        {
                            StringCchPrintfA((PSTR)&(pBuf[i]),
                                                  CCHOF(pci->aubCmdBuf) - i,
                                                  "+ %d) ",
                                         pextcd->sPreAdd);
                            i += strlen(&(pBuf[i]));
                        }
                        else if (pextcd->sPreAdd < 0)
                        {
                            StringCchPrintfA((PSTR)&(pBuf[i]),
                                         CCHOF(pci->aubCmdBuf) - i,
                                         "- %d) ",
                                         -pextcd->sPreAdd);
                            i += strlen(&(pBuf[i]));
                        }
                        if (pextcd->sUnitMult > 1)
                        {
                            i += StringCchPrintfA((PSTR)&(pBuf[i]),
                                          CCHOF(pci->aubCmdBuf) - i,
                                          "* %d) ",
                                          pextcd->sUnitMult);
                            i += strlen(&(pBuf[i]));
                        }
                        if (pextcd->sUnitDiv > 1 || sSBDDiv > 1)
                        {
                            i += StringCchPrintfA((PSTR)&(pBuf[i]),
                                        CCHOF(pci->aubCmdBuf) - i,
                                        ((pextcd->fGeneral & XCD_GEN_MODULO) ?
                                        "MOD %d) " : "/ %d) "),
                                        ((pextcd->sUnitDiv) ? pextcd->sUnitDiv : 1) * sSBDDiv);
                            i += strlen(&(pBuf[i]));
                        }
                        if (pextcd->sUnitAdd > 0)
                        {
                            i += StringCchPrintfA((PSTR)&(pBuf[i]),
                                          CCHOF(pci->aubCmdBuf) - i, 
                                          "+ %d",
                                          pextcd->sUnitAdd);
                            i += strlen(&(pBuf[i]));
                        }
                        else if (pextcd->sUnitAdd < 0)
                        {
                            i += StringCchPrintfA((PSTR)&(pBuf[i]),
                                          CCHOF(pci->aubCmdBuf) - i,
                                          "- %d",
                                          pextcd->sUnitAdd);
                            i += strlen(&(pBuf[i]));
                        }
                        //
                        // check if need to close max_repeat
                        //
                        if (!(pextcd->fGeneral & XCD_GEN_NO_MAX) &&
                            pextcd->sMax > 0 &&
                            (pcd->fGeneral & CMD_GEN_MAY_REPEAT) &&
                            wCmdID != CMD_CM_YM_LINESPACING)
                            pBuf[i++] = ')';

                        pBuf[i++] = '}';    // close the value portion
                    }
                    pextcd++;   // advance to next EXTCD
                }  // end param case
                                else
                                {
                                        pci->dwErrorCode |= ERR_BAD_GPC_CMD_STRING;
                                        pBuf[i++] = '!';
                                        pBuf[i++] = 'E';
                                        pBuf[i++] = 'R';
                                        pBuf[i++] = 'R';
                                        pBuf[i++] = '!';

                                        break;  // exit the while (wFmtLen > 0) loop
                                }
                //
                // check if the string is already quite long. If so,
                // start a new line.
                //
                if ((i - iPrevLines) >= MAX_GPD_CMD_LINE_LENGTH)
                {
                    ExitStringMode(pBuf, &i, &wCMode);
                    pBuf[i++] = '\r';
                                        pBuf[i++] = '\n';
                    iPrevLines = i;
                    pBuf[i++] = '+';
                    pBuf[i++] = ' ';
                }
            } // while (wFmtLen > 0)
            //
            // finished processing the format string. Exit properly
            //
            ExitStringMode(pBuf, &i, &wCMode);
        }
    }    // !NOOCD case
    else if (wCmdID == CMD_CMP_TIFF || wCmdID == CMD_CMP_DELTAROW ||
             wCmdID == CMD_CMP_FE_RLE)
    {
        pBuf[i++] = '"';    // generate "" command string
        pBuf[i++] = '"';
    }
    pBuf[i] = 0;
    pci->wCmdLen = (WORD)i;
    return (i != 0 || pci->wCmdCallbackID != 0);
}

void
VOutputOrderedCmd(
    IN OUT PCONVINFO pci,// contain info about the cmd to output
    PSTR    pstrCmdName, // cmd name such as "CmdSelect"
    SEQSECTION  ss,     // sequence section id (ENUM type defined in GPD.H)
    WORD    wOrder,     // order number within the section
    BOOL    bIndent)    // whether to use 2-level indentation or not
{
    //
    // check for no-cmd case
    //
    if (wOrder > 0 && (pci->wCmdLen > 0 || pci->wCmdCallbackID > 0))
    {
        VOut(pci, "%s*Command: %s\r\n%s{\r\n",
                  bIndent? "        " : "",
                  pstrCmdName,
                  bIndent? "        " : "");
        VOut(pci, "%s*Order: %s.%d\r\n",
                  bIndent? "            " : "    ",
                  gpstrSectionName[ss],
                  wOrder);
        if (pci->wCmdCallbackID > 0)
        {
            VOut(pci, "%s*CallbackID: %d\r\n",
                      bIndent? "            " : "    ",
                      pci->wCmdCallbackID);
            VOut(pci, "*%% Error: you must check if this command callback requires any parameters!\r\n");
        }
        else
            VOut(pci, "%s*Cmd: %s\r\n",
                      bIndent? "            " : "    ",
                      pci->aubCmdBuf);
        VOut(pci, "%s}\r\n", bIndent? "        " : "");
    }
}

void
VOutputSelectionCmd(
    IN OUT PCONVINFO pci,// contain info about the cmd to output
    IN BOOL    bDocSetup,  // whether in DOC_SETUP or PAGE_SETUP section
    IN WORD    wOrder)     // order number within the section
//
// This function outputs an option selection command which uses level 2
// indentation.
//
{
    VOutputOrderedCmd(pci, "CmdSelect",
                      bDocSetup? SS_DOCSETUP : SS_PAGESETUP,
                      wOrder, TRUE);
}

void
VOutputConfigCmd(
    IN OUT PCONVINFO pci,// contain info about the cmd to output
    IN PSTR pstrCmdName, // command name
    IN SEQSECTION  ss,      // sequence section id
    IN WORD    wOrder)      // order number within the section
//
// This function outputs a printer configuration command at the root level.
//
{
    VOutputOrderedCmd(pci, pstrCmdName, ss, wOrder, FALSE);
}


void
VOutputCmdBase(
    IN OUT PCONVINFO pci,   // contain info about the cmd to output
    PSTR    pstrCmdName,    // cmd name such as "CmdXMoveAbsolute"
    BOOL    bExtern,        // whether to add EXTERN_GLOBAL prefix
    BOOL    bIndent)        // whter to use level 2 indentation
{
    if (pci->wCmdLen > 0)
        VOut(pci, "%s%s*Command: %s { *Cmd : %s }\r\n",
                  bIndent? "        " : "",
                  bExtern ? "EXTERN_GLOBAL: " : "",
                  pstrCmdName, pci->aubCmdBuf);
    else if (pci->wCmdCallbackID > 0)
        VOut(pci, "%s%s*Command: %s { *CallbackID: %d }\r\n",
                  bIndent? "        " : "",
                  bExtern ? "EXTERN_GLOBAL: " : "",
                  pstrCmdName,
                  pci->wCmdCallbackID);
}

void
VOutputCmd(
    IN OUT PCONVINFO pci,   // contain info about the cmd to output
    IN PSTR    pstrCmdName)
//
// This function outputs printing commands at the root level (i.e. no
// indentation). It uses the shortcut format: *Command: <name> : <cmd>
// unless the callback is used.
//
{
    VOutputCmdBase(pci, pstrCmdName, FALSE, FALSE);
}

void
VOutputExternCmd(
    IN OUT PCONVINFO pci,
    IN PSTR pstrCmdName)
//
// This function outputs the printing commands inside feature option
// construct, i.e. they should be prefixed with "EXTERN_GLOBAL" and use
// level 2 indentation.
//
{
    //
    // 1/7/97 ZhanW
    // According to PeterWo, constructs don't need EXTERN_GLOBAL prefix
    //
    VOutputCmdBase(pci, pstrCmdName, FALSE, TRUE);
}

void
VOutputCmd2(
    IN OUT PCONVINFO pci,
    IN PSTR pstrCmdName)
//
// This function outputs printing commands with one level dependency,
// i.e. they should use level 2 indentation.
//
{
    VOutputCmdBase(pci, pstrCmdName, FALSE, TRUE);
}

WORD gwDefaultCmdOrder[] = {
    PC_ORD_PAPER_SOURCE,
    PC_ORD_PAPER_DEST,
    PC_ORD_PAPER_SIZE,
    PC_ORD_RESOLUTION,
    PC_ORD_TEXTQUALITY,
    0,
};

BOOL
BInDocSetup(
    IN PCONVINFO pci,
    IN WORD ord,
    OUT PWORD pwOrder)
/*++
Routine Description:
    This function determines the section and the order number of the given
    command.

Arguments:
    pci: pointer to CONVINFO
    ord: PC_ORD_xxx id identifying the command.
    pwOrder: to store the order number as in GPC

Return:
    TRUE if the command should be in DOC_SETUP section.
    Note that for both NT RASDD and Win95 Unidrv:
    1. All commands before PC_ORD_BEGINPAGE (exclusive) are sent per
       job and per ResetDC. So they should be in DOC_SETUP section.
    2. All commands after PC_ORD_BEGINPAGE (inclusive) is sent at the
       beginning of each page. So they should be in PAGE_SETUP section.

--*/
{
    PWORD pOrds;
    BOOL bDocSetup = TRUE;
    WORD count;

    if (pci->ppc->orgwOrder == (WORD)NOT_USED)
        pOrds = gwDefaultCmdOrder;
    else
        pOrds = (PWORD)((PBYTE)pci->pdh + pci->pdh->loHeap +
                                                pci->ppc->orgwOrder);

    for (count = 1; *pOrds != 0 && *pOrds != ord; count++, pOrds++)
    {
        if (bDocSetup && *pOrds == PC_ORD_BEGINPAGE)
            bDocSetup = FALSE;
    }
    if (*pOrds == 0)
        *pwOrder = 0;   // didn't find the cmd in the sequence
    else // *pOrds == ord
    {
        *pwOrder = count;
        if (ord == PC_ORD_BEGINPAGE)
            bDocSetup = FALSE;
    }
    return bDocSetup;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\uientry.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    uientry.c

Abstract:

    This file implements functions that generate UI related GPD entries, such
    as *Feature, *Option, etc.

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

    04/16/97 -zhanw-
        Generated Halftone and palette ColorMode options.

--*/

#include "gpc2gpd.h"

//
// the following constant definitions must match "printer5\inc\common.rc".
//
#define RCID_ORIENTATION    11100
#define RCID_PAPERSIZE      11101
#define RCID_INPUTBIN       11102
#define RCID_RESOLUTION     11103
#define RCID_MEDIATYPE      11104
#define RCID_TEXTQUALITY    11105
#define RCID_COLORMODE      11106
#define RCID_MEMORY         11107
#define RCID_DUPLEX         11108
#define RCID_PAGEPROTECTION 11109
#define RCID_HALFTONE       11110

#define RCID_PORTRAIT       11025
#define RCID_LANDSCAPE      11026

#define RCID_MONO           11030
#define RCID_COLOR          11031
#define RCID_8BPP           11032
#define RCID_24BPP          11033

#define RCID_NONE               11040
#define RCID_FLIP_ON_LONG_EDGE  11041
#define RCID_FLIP_ON_SHORT_EDGE 11042

#define RCID_HT_AUTO_SELECT 11050
#define RCID_HT_SUPERCELL   11051
#define RCID_HT_DITHER6X6   11052
#define RCID_HT_DITHER8X8   11053

#define RCID_ON             11090
#define RCID_OFF            11091

#define RCID_DOTS_PER_INCH  11400

#define RCID_PAPER_SYSTEMNAME 0x7fffffff
    //  secret value that the UI code will understand
    //  to mean, do enumForms to determine the actual paper name


void
VOutputOrientation(
    IN OUT PCONVINFO pci)
{
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: Orientation\r\n");
    VOut(pci, "{\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =ORIENTATION_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Orientation\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_ORIENTATION);

    VOut(pci, "    *DefaultOption: PORTRAIT\r\n");
    VOut(pci, "    *Option: PORTRAIT\r\n");
    VOut(pci, "    {\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =PORTRAIT_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Portrait\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_PORTRAIT);

    //
    // check if there is orientation selection commands.
    //
    bDocSetup = BInDocSetup(pci, PC_ORD_ORIENTATION, &wOrder);
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PC_PORTRAIT, pci->ppc->rgocd[PC_OCD_PORTRAIT]))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");
    //
    // now compose Landscape option
    //
    if (pci->pmd->fGeneral & MD_LANDSCAPE_RT90)
        VOut(pci, "    *Option: LANDSCAPE_CC90\r\n");
    else
        VOut(pci, "    *Option: LANDSCAPE_CC270\r\n");

    VOut(pci, "    {\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =LANDSCAPE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Landscape\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_LANDSCAPE);

    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PC_LANDSCAPE, pci->ppc->rgocd[PC_OCD_LANDSCAPE]))
    {
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
        pci->dwMode |= FM_SET_CURSOR_ORIGIN;
    }
    VOut(pci, "    }\r\n");        // close Landscape option

    VOut(pci, "}\r\n");            // close Orientation feature
}

WORD
WGetDefaultIndex(
    IN PCONVINFO pci,
    IN WORD wMDOI)
{
    WORD wDefault;      // 1-based option index
    PWORD pwDefList;
    WORD wOffset;

    //
    // it's guaranteed that there is at least one element in the list
    //
    if (pci->pdh->wVersion >= GPC_VERSION3 && pci->pmd->orgoiDefaults)
    {
        pwDefList = (PWORD)((PBYTE)(pci->pdh) + pci->pdh->loHeap + pci->pmd->orgoiDefaults);
        if (wMDOI > MD_OI_MAX)
            wOffset = wMDOI - MD_I_MAX;     // skip over rgi[] array
        else
            wOffset = wMDOI;
        wDefault = pwDefList[wOffset];
    }
    else
        wDefault = 1;
    return wDefault;
}

void
VGetOptionName(
    OUT PSTR    pBuf,   // output buffer
    IN  short   sSize,  // size of output buffer
    IN  short   sID,    // paper size id
    IN  WORD    wIndex, // paper size option index (1-based)
    IN  PSTR    *pstrStdName,    // array of standard names indexed by id
    IN  BOOL    bUser)  // whether there is a special 256 id. Only
                        // PaperSize uses this option.
{
    if (sID < 256)
    {
        //
        // standard id
        //
        StringCchPrintfA(pBuf, sSize, "%s", pstrStdName[sID-1]);
    }
    else if (sID == 256)
    {
        //
        // custom paper size
        //
        StringCchPrintfA(pBuf, sSize, "%s", "CUSTOMSIZE");
    }
    else
    {
        //
        // driver defined paper size. Use the artificial name OptionX where
        // X is the 1-based index of this option. It's guaranteed not to
        // collide with other option names.
        //
        StringCchPrintfA(pBuf, sSize, "Option%d", wIndex);
    }
}

void
VOutputInputBin(
    IN OUT PCONVINFO pci,
    IN PSHORT psIndex)
{
    WORD wDefaultOption;
    PPAPERSOURCE    pps;
    WORD wCount;
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: InputBin\r\n");
    VOut(pci, "{\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =PAPER_SOURCE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Paper Source\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_INPUTBIN);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_PAPERSOURCE);
    pps = (PPAPERSOURCE)GetTableInfo(pci->pdh, HE_PAPERSOURCE,
                                *(psIndex + wDefaultOption - 1) - 1);
    //
    // steal pci->aubCmdBuf to hold the composed option name temporarily
    //
    VGetOptionName((PSTR)pci->aubCmdBuf,
                   CCHOF(pci->aubCmdBuf),
                   pps->sPaperSourceID, wDefaultOption,
                   gpstrStdIBName, FALSE);
    VOut(pci, "    *DefaultOption: %s\r\n", (PSTR)pci->aubCmdBuf);
    //
    // loop through index list to create one option for each element
    //
    wCount = 1;
    while (*psIndex)
    {
        pps = (PPAPERSOURCE)GetTableInfo(pci->pdh, HE_PAPERSOURCE, *psIndex - 1);
        VGetOptionName((PSTR)pci->aubCmdBuf,
                       CCHOF(pci->aubCmdBuf),
                       pps->sPaperSourceID, wCount,
                       gpstrStdIBName, FALSE);
        //
        // set up info needed later
        //
        CopyStringA(pci->ppiSrc[wCount-1].aubOptName, pci->aubCmdBuf,
                    MAX_OPTION_NAME_LENGTH);
        pci->ppiSrc[wCount-1].bEjectFF = pps->fGeneral & PSRC_EJECTFF;
        pci->ppiSrc[wCount-1].dwPaperType = (DWORD)pps->fPaperType;

        VOut(pci, "    *Option: %s\r\n", (PSTR)pci->aubCmdBuf);
        VOut(pci, "    {\r\n");
        //
        // for standard InputBin options, use *Name. Otherwise,
        // use *rcNameID.
        //
        if (pps->sPaperSourceID < DMBIN_USER)
        {
            if (pci->dwStrType == STR_MACRO)
                VOut(pci, "        *rcNameID: =%s\r\n",
                     gpstrStdIBDisplayNameMacro[pps->sPaperSourceID - 1]);
            else if (pci->dwStrType == STR_DIRECT)
                VOut(pci, "        *Name: \"%s\"\r\n",
                     gpstrStdIBDisplayName[pps->sPaperSourceID - 1]);
            else
                VOut(pci, "        *rcNameID: %d\r\n",
                     STD_IB_DISPLAY_NAME_ID_BASE + pps->sPaperSourceID - 1);
        }
        else    // must be driver defined media type
        {
            VOut(pci, "        *rcNameID: %d\r\n", pps->sPaperSourceID);
            if (pps->sPaperSourceID > DMBIN_USER)
                VOut(pci, "        *OptionID: %d\r\n", pps->sPaperSourceID);
        }

        //
        // check for fields not used by RASDD but used by Win95 Unidrv.
        //
        if (pps->fGeneral & PSRC_MAN_PROMPT)
        {
            pci->dwErrorCode |= ERR_PSRC_MAN_PROMPT;
            VOut(pci, "*%% Warning: this input bin has PSRC_MAN_PROMPT set in GPC, which is ignored by GPD.\r\n");

        }
#if 0   // move *FeedMargins into CUSTOMSIZE option

        //
        // check paper feed margins
        //
        if (pps->sTopMargin > 0 || pps->sBottomMargin > 0)
            VOut(pci, "        *FeedMargins: PAIR(%d, %d)\r\n",
                                                pps->sTopMargin > 0 ? pps->sTopMargin : 0,
                                                pps->sBottomMargin > 0 ? pps->sBottomMargin : 0);
#else
        if (pps->sTopMargin > 0 || pps->sBottomMargin > 0)
        {
            pci->dwMode |= FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS;
            if (pci->pmd->fGeneral & MD_LANDSCAPE_RT90)
                VOut(pci, "*%% Error: this input bin has non-zero top/bottom margins which are ignored by the converter.\r\n");
            pci->ppiSrc[wCount-1].dwTopMargin =
                            pps->sTopMargin > 0 ? (DWORD)pps->sTopMargin : 0;
            pci->ppiSrc[wCount-1].dwBottomMargin =
                            pps->sBottomMargin > 0 ? (DWORD)pps->sBottomMargin : 0;
        }
#endif

#if 0
        //
        // bin adjustment flags have never been used on NT. Remove them.
        //
        VOut(pci, "        *PaperFeed: %s_%s\r\n",
             gpstrPositionName[pps->sBinAdjust & 0x00FF],
             gpstrPositionName[pps->sBinAdjust & 0xFF00]);
#endif
        //
        // check selection command.
        //
        bDocSetup = BInDocSetup(pci, PC_ORD_PAPER_SOURCE, &wOrder);
        if (wOrder > 0 && BBuildCmdStr(pci, CMD_PAPERSOURCE, pps->ocdSelect))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);

        VOut(pci, "    }\r\n");    // close the option

        psIndex++;
        wCount++;
    }
    pci->dwNumOfSrc = wCount - 1;
    //
    // for optimization: check if all feed margins happen to be
    // the same. If so, don't need to create dependency on
    // InputBin feature later on.
    //
    {
        BOOL bSame = TRUE;
        DWORD i;

        for (i = 1; bSame && i < pci->dwNumOfSrc; i++)
            bSame = bSame &&
                    (pci->ppiSrc[i].dwTopMargin==pci->ppiSrc[0].dwTopMargin) &&
                    (pci->ppiSrc[i].dwBottomMargin==pci->ppiSrc[0].dwBottomMargin);
        if (bSame)
            pci->dwMode |= FM_HAVE_SAME_TOP_BOTTOM_MARGINS;
    }

    VOut(pci, "}\r\n"); // close InputBin feature
}

void
VOutputDummyInputBin(
    IN OUT PCONVINFO pci)
{
    VOut(pci, "*Feature: InputBin\r\n");
    VOut(pci, "{\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =PAPER_SOURCE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Paper Source\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_INPUTBIN);

    VOut(pci, "    *DefaultOption: AUTO\r\n");

    VOut(pci, "    *Option: AUTO\r\n");
    VOut(pci, "    {\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =%s\r\n",
             gpstrStdIBDisplayNameMacro[6]);
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"%s\"\r\n",
             gpstrStdIBDisplayName[6]);
    else
        VOut(pci, "        *rcNameID: 10262\r\n");

    VOut(pci, "    }\r\n");	// Close option

    VOut(pci, "}\r\n");		// Close feature

}
void
VOutputPSOthers(
    IN OUT PCONVINFO pci,
    IN POINTw * pptSize,
    IN BOOL     bRotateSize,
    IN RECTw  * prcMargins,
    IN POINTw * pptCursorOrig,
    IN OCD      ocd,
    IN BOOL     bL4Indentation)
/*++
Routine Description:
    This function outputs other left-over PAPERSIZE fields, i.e. printable area,
    printable origin, cursor origin, and selection command. The
    indentation is either 8 or 16 spaces if bL4Indentation is TRUE.

    Enforce that *PrintableArea and *PrintableOrigin are divisible by the scale
    of any resolution. If not, truncate *PrintableArea and/or round up
    *PrintableOrigin.

    Enforce that if the printer can rotate the logical coordinate, then
    *CursorOrigin are divisible by the scale of
    the move units. If not, round up *CursorOrigin.

Arguments:
    pci: conversion relatedi info
    pptSize: 2 short's describing the physical x/y dimensions in Portrait
    prcMargins: 4 short's describing the margins
    pptCursorOrig: 2 short's describing the cursor origin in Portrait
    ocd: the heap offset of the command
        bL4Indentation: whether to use Level 4 or Level 2 indentation

Return Value:
    None

--*/
{
    WORD x, y;  // temporary variables
    WORD xSize, ySize; // temporary variables
    POINTw  ptSize; // store printable area values
    WORD xScale, yScale;
    BOOL bOutputResDependency = FALSE;
    BOOL bOutputSwitch = TRUE;
    BOOL bDocSetup;
    WORD wOrder;
    WORD i;

    if (pptSize && prcMargins)
    {
        if (bRotateSize)
        {
            ptSize.x = pptSize->y - prcMargins->left - prcMargins->right;
            ptSize.y = pptSize->x - prcMargins->top - prcMargins->bottom;
        }
        else
        {
            ptSize.x = pptSize->x - prcMargins->left - prcMargins->right;
            ptSize.y = pptSize->y - prcMargins->top - prcMargins->bottom;
        }
        //
        // use the original value as the base. Generate the dependency on
        // Resolution only if there is at least one resolution that requires
        // adjustement.
        //
        VOut(pci, "%s        *PrintableArea: PAIR(%d, %d)\r\n",
                  bL4Indentation? "        " : "", ptSize.x, ptSize.y);
        VOut(pci, "%s        *PrintableOrigin: PAIR(%d, %d)\r\n",
                  bL4Indentation? "        " : "",
                  prcMargins->left, prcMargins->top);
        //
        // ensure that the printable area and origin are divisible by the
        // scale of any resolution. Truncate the printable area if needed.
        // Round up the printable origin if needed. Also, must ensure that
        // the new printable area is contained within the old printable area.
        //
        for (i = 0; i < (WORD)pci->dwNumOfRes; i++)
        {
            xScale = (WORD)pci->presinfo[i].dwXScale;
            yScale = (WORD)pci->presinfo[i].dwYScale;

            xSize = (ptSize.x / xScale) * xScale;
            ySize = (ptSize.y / yScale) * yScale;
            x = ((prcMargins->left + xScale - 1) / xScale) * xScale;
            y = ((prcMargins->top + yScale - 1) / yScale) * yScale;
            //
            // check if the new printable area is contained within the old
            // printable area. If not, truncate the printable width or
            // length further.
            //
            if (x + xSize > prcMargins->left + ptSize.x)
                xSize -= xScale;
            if (y + ySize > prcMargins->top + ptSize.y)
                ySize -= yScale;

            if (xSize == ptSize.x && ySize == ptSize.y &&
                x == prcMargins->left && y == prcMargins->top)
                continue;   // no adjustment needed for this resolution
            //
            // otherwise, some adjustment is needed.
            //
            bOutputResDependency = TRUE;
            if (bOutputSwitch)
            {
                VOut(pci, "%s        *switch: Resolution\r\n%s        {\r\n",
                          bL4Indentation? "        " : "",
                          bL4Indentation? "        " : "");
                bOutputSwitch = FALSE;
            }
            VOut(pci, "%s            *case: %s\r\n%s            {\r\n",
                          bL4Indentation? "        " : "",
                          pci->presinfo[i].aubOptName,
                          bL4Indentation? "        " : "");

            if (xSize != ptSize.x || ySize != ptSize.y)
            {
                pci->dwErrorCode |= ERR_PRINTABLE_AREA_ADJUSTED;
                if (xSize != ptSize.x)
                    VOut(pci,
                        "*%% Warning: the following printable width is adjusted (%d->%d) so it is divisible by the resolution X scale.\r\n",
                        ptSize.x, xSize);
                if (ySize != ptSize.y)
                    VOut(pci,
                        "*%% Warning: the following printable length is adjusted (%d->%d) so it is divisible by the resolution Y scale.\r\n",
                        ptSize.y, ySize);
                VOut(pci, "%s                *PrintableArea: PAIR(%d, %d)\r\n",
                          bL4Indentation? "        " : "",
                          xSize, ySize);
            }
            if (x != prcMargins->left || y != prcMargins->top)
            {
                pci->dwErrorCode |= ERR_PRINTABLE_ORIGIN_ADJUSTED;
                if (x != prcMargins->left)
                    VOut(pci,
                        "*%% Warning: the following printable origin X is adjusted (%d->%d) so it is divisible by the resolution X scale.\r\n",
                        prcMargins->left, x);
                if (y != prcMargins->top)
                    VOut(pci,
                        "*%% Warning: the following printable origin Y is adjusted (%d->%d) so it is divisible by the resolution Y scale.\r\n",
                        prcMargins->top, y);

                VOut(pci, "%s                *PrintableOrigin: PAIR(%d, %d)\r\n",
                      bL4Indentation? "        " : "", x, y);
            }
            //
            // close the *case construct
            //
            VOut(pci, "%s            }\r\n", bL4Indentation? "        " : "");
        }   // end for loop
        if (bOutputResDependency)
            //
            // close *switch construct
            //
            VOut(pci, "%s        }\r\n", bL4Indentation? "        " : "");

    }

    if (pptCursorOrig)  // should output *CursorOrigin entry
    {
        //
        // ensure that cursor origin are divisible by the scale of
        // move unit if the printer is not a dot-matrix printer. We are
        // assuming that for dot-matrix printers, the *CursorOrigin entry
        // is always missing. If it's not missing, then the printing offset
        // may be off a little. But we don't think the accuracy is so
        // important for dot-matrix printers.
        //
        // Round up if needed.
        //
        x = pptCursorOrig->x;
        y = pptCursorOrig->y;
        if (pci->dwMode & FM_RES_DM_GDI)
        {
            if (pci->ptMoveScale.x > 1)
            {
                x = ((x + pci->ptMoveScale.x - 1) / pci->ptMoveScale.x) *
                       pci->ptMoveScale.x;
                if (x != pptCursorOrig->x)
                {
                    pci->dwErrorCode |= ERR_CURSOR_ORIGIN_ADJUSTED;
                    VOut(pci,
                     "*%% Warning: the following *CursorOrigin X value is adjusted (%d->%d) so it is divisible by scale of X move unit.\r\n",
                     pptCursorOrig->x, x);
                }
            }
            if (pci->ptMoveScale.y > 1)
            {
                y = ((y + pci->ptMoveScale.y - 1) / pci->ptMoveScale.y) *
                    pci->ptMoveScale.y;
                if (y != pptCursorOrig->y)
                {
                    pci->dwErrorCode |= ERR_CURSOR_ORIGIN_ADJUSTED;
                    VOut(pci,
                     "*%% Warning: the following *CursorOrigin Y value is adjusted (%d->%d) so it is divisible by scale of Y move unit.\r\n",
                     pptCursorOrig->y, y);
                }
            }
        }
        VOut(pci, "%s        *CursorOrigin: PAIR(%d, %d)\r\n",
                                bL4Indentation? "        " : "",
                                x, y);
    }

    if (ocd != NOOCD)
    {
        bDocSetup = BInDocSetup(pci, PC_ORD_PAPER_SIZE, &wOrder);
        //
        // this selection command has 3-level indentation instead of 2. So
        // can't call VOutputSelectionCmd().
        //
        if (wOrder > 0 && BBuildCmdStr(pci, CMD_PAPERSIZE, ocd))
        {
            VOut(pci, "%s        *Command: CmdSelect\r\n%s        {\r\n",
                                        bL4Indentation? "        " : "",
                                        bL4Indentation? "        " : "");
            VOut(pci, "%s            *Order: %s.%d\r\n",
                                bL4Indentation? "        " : "",
                                bDocSetup? "DOC_SETUP" : "PAGE_SETUP",
                                wOrder);
            if (pci->wCmdCallbackID > 0)
                VOut(pci, "%s            *CallbackID: %d\r\n",
                                        bL4Indentation? "        " : "",
                                        pci->wCmdCallbackID);
            else
                VOut(pci, "%s            *Cmd: %s\r\n",
                                        bL4Indentation? "        " : "",
                                        pci->aubCmdBuf);
            VOut(pci, "%s        }\r\n",
                                bL4Indentation? "        " : "");
        }
    }
}

void
VAdjustHMargins(
    PCONVINFO   pci,
    PPAPERSIZE  pps,
    RECTw   *   prcInMargins,
    RECTw   *   prcOutMargins)
{
    DWORD   dwWidth, dwHMargin, dwLeftMargin, dwRightMargin;

    //
    // handle -1 case (treated the same as 0, no margin)
    //
    prcOutMargins->top = prcInMargins->top > 0 ? prcInMargins->top : 0;
    prcOutMargins->bottom = prcInMargins->bottom > 0 ? prcInMargins->bottom : 0;
    prcOutMargins->left = prcInMargins->left > 0 ? prcInMargins->left : 0;
    prcOutMargins->right = prcInMargins->right > 0 ? prcInMargins->right : 0;

    dwWidth = (DWORD)((pps->fGeneral & PS_ROTATE) ? pps->ptSize.y : pps->ptSize.x);
    if (dwWidth > (DWORD)pci->pmd->ptMax.x)
    {
        dwHMargin = dwWidth - (DWORD)pci->pmd->ptMax.x;
            VOut(pci, "*%% Warning: this paper size exceeds the MaxWidth, imageable width is truncated . \r\n");
    }
    else
        dwHMargin = 0;
    if (pps->fGeneral & PS_CENTER)
        dwLeftMargin = dwHMargin / 2;
        else
                dwLeftMargin = 0;
    if (dwLeftMargin < (DWORD)pci->pmd->sLeftMargin)
        dwLeftMargin = (DWORD)pci->pmd->sLeftMargin;

    if ((DWORD)prcOutMargins->left < dwLeftMargin)
        prcOutMargins->left = (WORD)dwLeftMargin;

    if (dwHMargin > (DWORD)prcOutMargins->left)
        dwRightMargin = dwHMargin - (DWORD)prcOutMargins->left;
    else
        dwRightMargin = 0;

    if ((DWORD)prcOutMargins->right < dwRightMargin)
        prcOutMargins->right = (WORD)dwRightMargin;
}

void
VAdjustHAndVMargins(
    PCONVINFO   pci,
    PPAPERSIZE  pps,
    RECTw   *   prcInMargins,
    DWORD       dwTopMargin,
    DWORD       dwBottomMargin,
    RECTw   *   prcOutMargins)
{
    VAdjustHMargins(pci, pps, prcInMargins, prcOutMargins);

    if ((DWORD)prcOutMargins->top < dwTopMargin)
        prcOutMargins->top = (WORD)dwTopMargin;

    if ((DWORD)prcOutMargins->bottom < dwBottomMargin)
        prcOutMargins->bottom = (WORD)dwBottomMargin;

}


void
VOutputPaperSize(
    IN OUT PCONVINFO pci,
    IN PSHORT psIndex)
{
    WORD wDefaultOption, wCount;
    PPAPERSIZE  pps;
    BOOL bGPC3 = pci->pdh->wVersion >= GPC_VERSION3;
    RECTw rcOutMargins;

    VOut(pci, "*Feature: PaperSize\r\n");
    VOut(pci, "{\r\n");

    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =PAPER_SIZE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Paper Size\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_PAPERSIZE);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_PAPERSIZE);
    pps = (PPAPERSIZE)GetTableInfo(pci->pdh, HE_PAPERSIZE,
                                   *(psIndex + wDefaultOption - 1) - 1);
    //
    // steal pci->aubCmdBuf to hold composed option name temporarily
    //
    VGetOptionName((PSTR)pci->aubCmdBuf,
                   CCHOF(pci->aubCmdBuf),
                   pps->sPaperSizeID, wDefaultOption,
                   gpstrStdPSName, TRUE);
    VOut(pci, "    *DefaultOption: %s\r\n", (PSTR)pci->aubCmdBuf);

    //
    // loop through index list to create one option for each element
    //
    wCount = 1;
    while (*psIndex)
    {
        pps = (PPAPERSIZE)GetTableInfo(pci->pdh, HE_PAPERSIZE, *psIndex - 1);
        VGetOptionName((PSTR)pci->aubCmdBuf,
                       CCHOF(pci->aubCmdBuf),
                       pps->sPaperSizeID, wCount,
                       gpstrStdPSName, TRUE);
        //
        // set up info needed later
        //
        CopyStringA(pci->ppiSize[wCount-1].aubOptName, pci->aubCmdBuf,
                    MAX_OPTION_NAME_LENGTH);
        pci->ppiSize[wCount-1].bEjectFF = pps->fGeneral & PS_EJECTFF;
        pci->ppiSize[wCount-1].dwPaperType = (DWORD)pps->fPaperType;

        VOut(pci, "    *Option: %s\r\n", (PSTR)pci->aubCmdBuf);
        VOut(pci, "    {\r\n");
        //
        // for standard PaperSize options, use *Name. Otherwise,
        // use *rcNameID.
        //
        if (pps->sPaperSizeID < DMPAPER_USER)
        {
            if (pci->bUseSystemPaperNames)
                VOut(pci, "        *rcNameID: =RCID_DMPAPER_SYSTEM_NAME\r\n");
            else if (pci->dwStrType == STR_MACRO)
                VOut(pci, "        *rcNameID: =%s\r\n",
                     gpstrStdPSDisplayNameMacro[pps->sPaperSizeID - 1]);
            else if (pci->dwStrType == STR_DIRECT)
                VOut(pci, "        *Name: \"%s\"\r\n",
                     gpstrStdPSDisplayName[pps->sPaperSizeID - 1]);
            else
                VOut(pci, "        *rcNameID: %d\r\n",
                     STD_PS_DISPLAY_NAME_ID_BASE + pps->sPaperSizeID - 1);

        }
        else if (pps->sPaperSizeID == DMPAPER_USER)
        {
            if (pci->dwStrType == STR_MACRO)
                VOut(pci, "        *rcNameID: =USER_DEFINED_SIZE_DISPLAY\r\n");
            else if (pci->dwStrType == STR_DIRECT)
                VOut(pci, "        *Name: \"User Defined Size\"\r\n");
            else
                VOut(pci, "        *rcNameID: %d\r\n",
                     STD_PS_DISPLAY_NAME_ID_BASE + DMPAPER_USER - 1);

            VOut(pci, "        *MinSize: PAIR(%d, %d)\r\n", pci->pmd->ptMin.x,
                                                     pci->pmd->ptMin.y);
            VOut(pci, "        *MaxSize: PAIR(%d, %d)\r\n", pci->pmd->sMaxPhysWidth,
                 (pci->pmd->ptMax.y == NOT_USED) ? 0x7FFF : pci->pmd->ptMax.y);

            VOut(pci, "        *MaxPrintableWidth: %d\r\n", (DWORD)pci->pmd->ptMax.x);
            VOut(pci, "        *MinLeftMargin: %d\r\n", pci->pmd->sLeftMargin);
            VOut(pci, "        *CenterPrintable?: %s\r\n",
                      (pps->fGeneral & PS_CENTER)? "TRUE" : "FALSE");
            if ((pci->dwMode & FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS) &&
                (pci->dwMode & FM_HAVE_SAME_TOP_BOTTOM_MARGINS))
            {
                VOut(pci, "        *TopMargin: %d\r\n", pci->ppiSrc[0].dwTopMargin);
                VOut(pci, "        *BottomMargin: %d\r\n", pci->ppiSrc[0].dwBottomMargin);
            }
            else if (pci->dwMode & FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS)
            {
                DWORD i;

                //
                // need to create dependency on InputBin.
                //
                VOut(pci, "        *switch: InputBin\r\n");
                VOut(pci, "        {\r\n");

                for (i = 0; i < pci->dwNumOfSrc; i++)
                {
                    VOut(pci, "            *case: %s\r\n", pci->ppiSrc[i].aubOptName);
                    VOut(pci, "            {\r\n");
                    VOut(pci, "                *TopMargin: %d\r\n", pci->ppiSrc[i].dwTopMargin);
                    VOut(pci, "                *BottomMargin: %d\r\n", pci->ppiSrc[i].dwBottomMargin);
                    VOut(pci, "            }\r\n");    // close *case
                }
                VOut(pci, "        }\r\n"); // close *switch
            }

        }
        else
        {
            VOut(pci, "        *rcNameID: %d\r\n", pps->sPaperSizeID);
            VOut(pci, "        *OptionID: %d\r\n", pps->sPaperSizeID);
            VOut(pci, "        *PageDimensions: PAIR(%d, %d)\r\n", pps->ptSize.x,
                                                            pps->ptSize.y);
        }
        if (pps->fGeneral & PS_ROTATE)
            VOut(pci, "        *RotateSize? : TRUE\r\n");
        if (pps->fGeneral & PS_SUGGEST_LNDSCP)
        {
            pci->dwErrorCode |= ERR_PS_SUGGEST_LNDSCP;
            VOut(pci, "*%% Warning: this paper size has PS_SUGGEST_LNDSCP set in GPC, which is ignored by GPD. \r\n");
        }
        if (pci->pmd->fGeneral & MD_PCL_PAGEPROTECT)
        {
            VOut(pci, "        *PageProtectMem: %d\r\n", GETPAGEPROMEM(pci->pdh, pps));
            //
            // check if we should synthesize a PageProtect feature later.
            // Note that we assume that all paper size options have the same
            // commands to turn on/off page protection feature. This is a bit
            // hacky, but it's really because GPC defined it in a awkward way.
            // All existing GPC minidrivers are consistent with the assumption.
            //
            if (bGPC3)
            {
                //
                // the first option establish the PP feature
                //
                if (wCount == 1)
                {
                    if ((pci->ocdPPOn = pps->rgocd[PSZ_OCD_PAGEPROTECT_ON])
                        != NOOCD &&
                        (pci->ocdPPOff = pps->rgocd[PSZ_OCD_PAGEPROTECT_OFF])
                        != NOOCD)
                        pci->dwMode |= FM_SYN_PAGEPROTECT;
                }
                //
                // make sure following options are consistent with the
                // first option. If not, report error and don't synthesize.
                //
                else if (pci->dwMode & FM_SYN_PAGEPROTECT)
                {
                    if (pps->rgocd[PSZ_OCD_PAGEPROTECT_ON] == NOOCD ||
                        pps->rgocd[PSZ_OCD_PAGEPROTECT_OFF] == NOOCD)
                    {
                        pci->dwMode &= ~FM_SYN_PAGEPROTECT;
                        pci->dwErrorCode |= ERR_INCONSISTENT_PAGEPROTECT;
                    }
                }
                else // wCount > 1 && !(pci->dwMode & FM_SYN_PAGEPROTECT)
                {
                    if (pps->rgocd[PSZ_OCD_PAGEPROTECT_ON] != NOOCD ||
                        pps->rgocd[PSZ_OCD_PAGEPROTECT_OFF] != NOOCD)
                        pci->dwErrorCode |= ERR_INCONSISTENT_PAGEPROTECT;
                }
            }
        } // end if (pci->pmd->fGeneral & MD_PCL_PAGEPROTECT)...
        //
        // Output margin related entries and selection cmd
        //
        //
        // check GPC version. If 3.0 or above, and if MD_LANDSCAPE_RT90 bit
        // if set (i.e. different margins and cursor origins might be used
        // for different orientations, and there are cmds to set the logical
        // orientation), then generate *switch/*case dependency on Orientation.
        // The dependency clause contains *PrintableArea, *PrintableOrigin,
        // *CursorOrigin and the selection command.
        //

        if (bGPC3 && (pci->pmd->fGeneral & MD_LANDSCAPE_RT90))
        {
            POINTw  ptCursor;
            BOOL    bUseCursorOrigin;

            bUseCursorOrigin = (pci->dwMode & FM_SET_CURSOR_ORIGIN) ||
                               (pci->pmd->fGeneral & MD_USE_CURSOR_ORIG);
            //
            // assume that in this case there is no margins resulted from
            // input slot. Verify that.
            //
            if (pci->dwMode & FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS)
                pci->dwErrorCode |= ERR_NON_ZERO_FEED_MARGINS_ON_RT90_PRINTER;

            VOut(pci, "        *switch: Orientation\r\n");
            VOut(pci, "        {\r\n");
            VOut(pci, "            *case: PORTRAIT\r\n");
            VOut(pci, "            {\r\n");
            //
            // take into account MODELDATA.sMinLeftMargin & MODELDATA.ptMax.x
            //
            if (pps->sPaperSizeID == DMPAPER_USER)
            {
                //
                // for use-defined size, we don't output *CursorOrigin
                // since it doesn't make sense.
                //
                VOutputPSOthers(pci, NULL, FALSE, NULL, NULL,
                                pps->rgocd[PSZ_OCD_SELECTPORTRAIT], TRUE);
            }
            else
            {
                VAdjustHMargins(pci, pps, &pps->rcMargins, &rcOutMargins);
                if (pci->pmd->fGeneral & MD_USE_CURSOR_ORIG)
                {
                    ptCursor.x = pps->ptCursorOrig.x;
                    ptCursor.y = pps->ptCursorOrig.y;
                }
                else if (pci->dwMode & FM_SET_CURSOR_ORIGIN)
                {
                    ptCursor.x = rcOutMargins.left;
                    ptCursor.y = rcOutMargins.top;
                }
                VOutputPSOthers(pci, &pps->ptSize, pps->fGeneral & PS_ROTATE,
                                &rcOutMargins,
                                bUseCursorOrigin ? &ptCursor : NULL,
                                pps->rgocd[PSZ_OCD_SELECTPORTRAIT], TRUE);
            }
            VOut(pci, "            }\r\n");    // close *case: Portrait

            VOut(pci, "            *case: LANDSCAPE_CC90\r\n");
            VOut(pci, "            {\r\n");
            if (pps->sPaperSizeID == DMPAPER_USER)
            {
                VOutputPSOthers(pci, NULL, FALSE, NULL, NULL,
                                pps->rgocd[PSZ_OCD_SELECTLANDSCAPE], TRUE);
            }
            else
            {
                VAdjustHMargins(pci, pps, &pps->rcLMargins, &rcOutMargins);
                //
                // convert ptLCursorOrig (in Landscape) to corresponding values
                // as in Portrait orientation.
                //
                if (pci->pmd->fGeneral & MD_USE_CURSOR_ORIG)
                {
                    ptCursor.x = pps->ptLCursorOrig.y;
                    ptCursor.y = ((pps->fGeneral & PS_ROTATE) ?
                                  pps->ptSize.x : pps->ptSize.y) -
                                 pps->ptLCursorOrig.x;
                }
                else if (pci->dwMode & FM_SET_CURSOR_ORIGIN)
                {
                    ptCursor.x = rcOutMargins.left;
                    ptCursor.y = ((pps->fGeneral & PS_ROTATE) ?
                                  pps->ptSize.x : pps->ptSize.y) -
                                 rcOutMargins.bottom;
                }
                VOutputPSOthers(pci, &pps->ptSize, pps->fGeneral & PS_ROTATE,
                                &rcOutMargins,
                                bUseCursorOrigin ? &ptCursor : NULL,
                                pps->rgocd[PSZ_OCD_SELECTLANDSCAPE], TRUE);
            }
            VOut(pci, "            }\r\n");    // close *case: Landscape
            VOut(pci, "        }\r\n"); // close *switch: Orientation
        }
        else if (pps->sPaperSizeID == DMPAPER_USER)
        {
            //
            // output CmdSelect, if any.
            //
            VOutputPSOthers(pci, NULL, FALSE, NULL, NULL,
                            pps->rgocd[PSZ_OCD_SELECTPORTRAIT], FALSE);
        }
        else
        {
            //
            // in this case, there is no separate commands to set
            // logical orientation.
            //
            BOOL bUseCO = pci->pmd->fGeneral & MD_USE_CURSOR_ORIG;

            if (pci->dwMode & FM_HAVE_SEEN_NON_ZERO_FEED_MARGINS)
            {
                DWORD i;

                if (pci->dwMode & FM_HAVE_SAME_TOP_BOTTOM_MARGINS)
                {
                    VAdjustHAndVMargins(pci, pps, &pps->rcMargins,
                                        pci->ppiSrc[0].dwTopMargin,
                                        pci->ppiSrc[0].dwBottomMargin,
                                        &rcOutMargins);
                    VOutputPSOthers(pci, &pps->ptSize, pps->fGeneral & PS_ROTATE,
                                    &rcOutMargins,
                                    bUseCO ? &pps->ptCursorOrig : NULL,
                                    pps->rgocd[PSZ_OCD_SELECTPORTRAIT], FALSE);
                }
                else
                {
                    //
                    // need to create dependency on InputBin. But leave
                    // *CursorOrigin and CmdSelect out of it.
                    //
                    VOutputPSOthers(pci, NULL, FALSE, NULL,
                                    bUseCO ? &pps->ptCursorOrig : NULL,
                                    pps->rgocd[PSZ_OCD_SELECTPORTRAIT], FALSE);

                    VOut(pci, "        *switch: InputBin\r\n");
                    VOut(pci, "        {\r\n");

                    for (i = 0; i < pci->dwNumOfSrc; i++)
                    {
                        VOut(pci, "            *case: %s\r\n", pci->ppiSrc[i].aubOptName);
                        VOut(pci, "            {\r\n");
                        VAdjustHAndVMargins(pci, pps, &pps->rcMargins,
                                                pci->ppiSrc[i].dwTopMargin,
                                                pci->ppiSrc[i].dwBottomMargin,
                                                &rcOutMargins);
                        VOutputPSOthers(pci, &pps->ptSize, pps->fGeneral & PS_ROTATE,
                                        &rcOutMargins, NULL, NOOCD, TRUE);
                        VOut(pci, "            }\r\n");    // close *case
                    }
                    VOut(pci, "        }\r\n");
                }
            }
            else
            {
                VAdjustHMargins(pci, pps, &pps->rcMargins, &rcOutMargins);
                VOutputPSOthers(pci, &pps->ptSize, pps->fGeneral & PS_ROTATE,
                                &rcOutMargins,
                                bUseCO ? &pps->ptCursorOrig : NULL,
                                pps->rgocd[PSZ_OCD_SELECTPORTRAIT], FALSE);
            }
        }

        VOut(pci, "    }\r\n");    // close the option

        psIndex++;
        wCount++;
    }
    pci->dwNumOfSize = wCount - 1;

    VOut(pci, "}\r\n");
}

void
VOutputResolution(
    IN OUT PCONVINFO pci,
    IN PSHORT  psIndex)
{
    PGPCRESOLUTION pres;
    WORD wCount;
    WORD wDefaultOption;
    BOOL bDocSetup;
    BOOL bColor;
    WORD wOrder;

    //
    // check if this is a color device
    //
    bColor = *((PSHORT)((PBYTE)pci->pdh + pci->pdh->loHeap +
                pci->pmd->rgoi[MD_OI_COLOR])) != 0;
    VOut(pci, "*Feature: Resolution\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =RESOLUTION_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Resolution\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_RESOLUTION);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_RESOLUTION);
    VOut(pci, "    *DefaultOption: Option%d\r\n", wDefaultOption);
    //
    // loop through index list to create one option for each element
    //
    wCount = 1;
    while (*psIndex)
    {
        WORD wXdpi, wYdpi;

        pres = (PGPCRESOLUTION)GetTableInfo(pci->pdh, HE_RESOLUTION, *psIndex - 1);
        //
        // set up pci->pres for CmdSendBlockData special case in BBuildCmdStr
        //
        pci->pres = pres;
        wXdpi = (WORD)pci->pdh->ptMaster.x / pres->ptTextScale.x;
        wYdpi = (WORD)pci->pdh->ptMaster.y / pres->ptTextScale.y;
        //
        // gather information for later use
        //
        StringCchPrintfA(pci->presinfo[wCount-1].aubOptName, CCHOF(pci->presinfo[wCount-1].aubOptName), "Option%d", wCount);
        pci->presinfo[wCount-1].dwXScale = pres->ptTextScale.x << pres->ptScaleFac.x;
        pci->presinfo[wCount-1].dwYScale = pres->ptTextScale.y << pres->ptScaleFac.y;
        pci->presinfo[wCount-1].bColor = pres->fDump & RES_DM_COLOR;

        //
        // assume all GPCRESOLUTION structures use the same dump format.
        //
        if (wCount == 1 && (pres->fDump & RES_DM_GDI))
            pci->dwMode |= FM_RES_DM_GDI;
        VOut(pci, "    *Option: Option%d\r\n", wCount);
        VOut(pci, "    {\r\n");
        //
        // have to compose the actual display name
        //
        if (pci->dwStrType == STR_MACRO)
            VOut(pci, "        *Name: \"%d x %d \" =DOTS_PER_INCH\r\n",
                 wXdpi >> pres->ptScaleFac.x, wYdpi >> pres->ptScaleFac.y);
        else
            VOut(pci, "        *Name: \"%d x %d dots per inch\"\r\n",
                 wXdpi >> pres->ptScaleFac.x, wYdpi >> pres->ptScaleFac.y);

        VOut(pci, "        *DPI: PAIR(%d, %d)\r\n",
                  wXdpi >> pres->ptScaleFac.x, wYdpi >> pres->ptScaleFac.y);
        VOut(pci, "        *TextDPI: PAIR(%d, %d)\r\n", wXdpi, wYdpi);
        if (pres->sNPins > 1)
            VOut(pci, "        *PinsPerLogPass: %d\r\n", pres->sNPins);
        if (pres->sPinsPerPass > 1)
            VOut(pci, "        *PinsPerPhysPass: %d\r\n", pres->sPinsPerPass);
        if (pres->sMinBlankSkip > 0)
            VOut(pci, "        *MinStripBlankPixels: %d\r\n",
                      pres->sMinBlankSkip);
        if (pres->fBlockOut & RES_BO_UNIDIR)
            VOut(pci, "        *RequireUniDir?: TRUE\r\n");

        //
        // Some printers (ex. LJ III) have different stripping flags for
        // different resolutions.
        //
        if (pres->fBlockOut &
            (RES_BO_LEADING_BLNKS | RES_BO_TRAILING_BLNKS | RES_BO_ENCLOSED_BLNKS))
        {
            pci->dwMode |= FM_VOUT_LIST;

            VOut(pci, "        EXTERN_GLOBAL: *StripBlanks: LIST(%s%s%s)\r\n",
                 (pres->fBlockOut & RES_BO_LEADING_BLNKS) ? "LEADING," : "",
                 (pres->fBlockOut & RES_BO_ENCLOSED_BLNKS) ? "ENCLOSED," : "",
                 (pres->fBlockOut & RES_BO_TRAILING_BLNKS) ? "TRAILING" : "");

            pci->dwMode &= ~FM_VOUT_LIST;
        }
        if (pres->fBlockOut & RES_BO_MULTIPLE_ROWS)
            VOut(pci, "        EXTERN_GLOBAL: *SendMultipleRows?: TRUE\r\n");

        //
        // RES_BO_RESET_FONT is used by Win95 Unidrv but not by RASDD.
        // Warn if this flag is set.
        //
        if (pres->fBlockOut & RES_BO_RESET_FONT)
        {
            pci->dwErrorCode |= ERR_RES_BO_RESET_FONT;
            //  set a flag to cause this to be output *ReselectFont in VoutputPrintingEntries
            VOut(pci, "*%% Warning: this resolution has RES_BO_RESET_FONT set in GPC.   *ReselectFont  added\r\n");
        }
        if (pres->fBlockOut & RES_BO_OEMGRXFILTER)
        {
            pci->dwErrorCode |= ERR_RES_BO_OEMGRXFILTER;
            VOut(pci, "*%% Error: this resolution has RES_BO_OEMGRXFILTER set in GPC. You must port over the custom code. \r\n");
        }
        if (pres->fBlockOut & RES_BO_NO_ADJACENT)
        {
            pci->dwErrorCode |= ERR_RES_BO_NO_ADJACENT;
            VOut(pci, "*%% Warning: this resolution has RES_BO_NO_ADJACENT set in GPC, which is ignored by GPD. Custom code is needed.\r\n");
        }
        if (pres->sTextYOffset != 0)
            VOut(pci, "        EXTERN_GLOBAL: *TextYOffset: %d\r\n",
                                  pres->sTextYOffset);

        VOut(pci, "        *SpotDiameter: %d\r\n", pres->sSpotDiameter);
        //
        // output printing commands that come from GPCRESOLUTION structure.
        //
        if (BBuildCmdStr(pci, CMD_RES_BEGINGRAPHICS, pres->rgocd[RES_OCD_BEGINGRAPHICS]))
            VOutputExternCmd(pci, "CmdBeginRaster");

        if (BBuildCmdStr(pci, CMD_RES_ENDGRAPHICS, pres->rgocd[RES_OCD_ENDGRAPHICS]))
            VOutputExternCmd(pci, "CmdEndRaster");

        if (BBuildCmdStr(pci, CMD_RES_SENDBLOCK, pres->rgocd[RES_OCD_SENDBLOCK]))
            VOutputExternCmd(pci, "CmdSendBlockData");

        if (BBuildCmdStr(pci, CMD_RES_ENDBLOCK, pres->rgocd[RES_OCD_ENDBLOCK]))
            VOutputExternCmd(pci, "CmdEndBlockData");

        //
        // check selection command.
        //
        bDocSetup = BInDocSetup(pci, PC_ORD_RESOLUTION,&wOrder);
        if (wOrder > 0 &&
            BBuildCmdStr(pci, CMD_RES_SELECTRES, pres->rgocd[RES_OCD_SELECTRES]))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);
        //
        // gather info for later use
        //
        if (pres->fDump & RES_DM_DOWNLOAD_OUTLINE)
            pci->dwMode |= FM_RES_DM_DOWNLOAD_OUTLINE;
        else
            pci->dwMode |= FM_NO_RES_DM_DOWNLOAD_OUTLINE;

        VOut(pci, "    }\r\n");    // close the option

        psIndex++;
        wCount++;
    }
    pci->dwNumOfRes = wCount - 1;
    VOut(pci, "}\r\n");
}

void
VOutputMediaType(
    IN OUT PCONVINFO pci,
    IN PSHORT psIndex)
{
    WORD wDefaultOption;
    PPAPERQUALITY   ppq;
    WORD wCount;
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: MediaType\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =MEDIA_TYPE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Media Type\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_MEDIATYPE);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_PAPERQUALITY);
    ppq = (PPAPERQUALITY)GetTableInfo(pci->pdh, HE_PAPERQUALITY,
                                *(psIndex + wDefaultOption - 1) - 1);
    //
    // steal pci->aubCmdBuf as temp buffer for option names
    //
    VGetOptionName((PSTR)pci->aubCmdBuf,
                   CCHOF(pci->aubCmdBuf),
                   ppq->sPaperQualID, wDefaultOption,
                   gpstrStdMTName, FALSE);
    VOut(pci, "    *DefaultOption: %s\r\n", (PSTR)pci->aubCmdBuf);
    //
    // loop through index list to create one option for each element
    //
    wCount = 1;
    while (*psIndex)
    {
        ppq = (PPAPERQUALITY)GetTableInfo(pci->pdh, HE_PAPERQUALITY, *psIndex - 1);
        VGetOptionName((PSTR)pci->aubCmdBuf,
                       CCHOF(pci->aubCmdBuf),
                       ppq->sPaperQualID, wCount,
                       gpstrStdMTName, FALSE);
        VOut(pci, "    *Option: %s\r\n", (PSTR)pci->aubCmdBuf);
        VOut(pci, "    {\r\n");
        //
        // for standard MediaType options, use *Name. Otherwise,
        // use *rcNameID.
        //
        if (ppq->sPaperQualID < DMMEDIA_USER)
        {
            if (pci->dwStrType == STR_MACRO)
                VOut(pci, "        *rcNameID: =%s\r\n",
                     gpstrStdMTDisplayNameMacro[ppq->sPaperQualID - 1]);
            else if (pci->dwStrType == STR_DIRECT)
                VOut(pci, "        *Name: \"%s\"\r\n",
                     gpstrStdMTDisplayName[ppq->sPaperQualID - 1]);
            else
                VOut(pci, "        *rcNameID: %d\r\n",
                     STD_MT_DISPLAY_NAME_ID_BASE + ppq->sPaperQualID - 1);
        }
        else    // must be driver defined media type
        {
            VOut(pci, "        *rcNameID: %d\r\n", ppq->sPaperQualID);
            if (ppq->sPaperQualID > DMMEDIA_USER)
                VOut(pci, "        *OptionID: %d\r\n", ppq->sPaperQualID);
        }
        //
        // check selection command.
        //
        bDocSetup = BInDocSetup(pci, PC_ORD_PAPER_QUALITY, &wOrder);
        if (wOrder > 0 &&
            BBuildCmdStr(pci, CMD_PAPERQUALITY, ppq->ocdSelect))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);
        VOut(pci, "    }\r\n");    // close the option

        psIndex++;
        wCount++;
    }
        VOut(pci, "}\r\n");
}

void
VOutputTextQuality(
    IN OUT PCONVINFO pci,
    IN PSHORT psIndex)
{
    WORD wDefaultOption;
    PTEXTQUALITY   ptq;
    WORD wCount;
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: PrintQuality\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =TEXT_QUALITY_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Print Quality\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_TEXTQUALITY);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_TEXTQUAL);
    ptq = (PTEXTQUALITY)GetTableInfo(pci->pdh, HE_TEXTQUAL,
                                *(psIndex + wDefaultOption - 1) - 1);
    //
    // steal pci->aubCmdBuf as temp buffer for option names
    //
    VGetOptionName((PSTR)pci->aubCmdBuf,
                   CCHOF(pci->aubCmdBuf),
                   ptq->sID, wDefaultOption,
                   gpstrStdTQName, FALSE);
    VOut(pci, "    *DefaultOption: %s\r\n", (PSTR)pci->aubCmdBuf);
    //
    // loop through index list to create one option for each element
    //
    wCount = 1;
    while (*psIndex)
    {
        ptq = (PTEXTQUALITY)GetTableInfo(pci->pdh, HE_TEXTQUAL, *psIndex - 1);
        VGetOptionName((PSTR)pci->aubCmdBuf, CCHOF(pci->aubCmdBuf), ptq->sID, wCount,
                       gpstrStdTQName, FALSE);
        VOut(pci, "    *Option: %s\r\n", (PSTR)pci->aubCmdBuf);
        VOut(pci, "    {\r\n");

        if (ptq->sID < DMTEXT_USER)
        {
            if (pci->dwStrType == STR_MACRO)
                VOut(pci, "        *rcNameID: =%s\r\n",
                          gpstrStdTQDisplayNameMacro[ptq->sID - 1]);
            else if (pci->dwStrType == STR_DIRECT)
                VOut(pci, "        *Name: \"%s\"\r\n",
                          gpstrStdTQDisplayName[ptq->sID - 1]);
            else
                VOut(pci, "        *rcNameID: %d\r\n",
                          STD_TQ_DISPLAY_NAME_ID_BASE + ptq->sID - 1);
        }
        else    // must be driver defined text quality
            VOut(pci, "        *rcNameID: %d\r\n", ptq->sID);
        //
        // check selection command.
        //
        bDocSetup = BInDocSetup(pci, PC_ORD_TEXTQUALITY, &wOrder);
        if (wOrder > 0 &&
            BBuildCmdStr(pci, CMD_TEXTQUALITY, ptq->ocdSelect))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);
        VOut(pci, "    }\r\n");    // close the option

        psIndex++;
        wCount++;
    }
        VOut(pci, "}\r\n");
}

void
VOutputFeature(
    IN OUT PCONVINFO pci,
    IN FEATUREID fid,
    IN PSHORT psIndex)
/*++
Routine Description:
    This function outputs a generic feature in GPC. A generic feature has
    only name and ocdCmdSelect for each option and there is no standard
    option, i.e. all "sID" referenced in the GPC structure are really
    string resource id's. The generated GPD options will be named "OptionX"
    where X is 1, 2, ..., <# of options>. The default option is derived
    from the GPC data. The option's display name comes from "sID".

Arguments:
    fid: identification of the specific feature
    psIndex: pointer to a list of structure indicies (1-based) each
             corresponding to one option.

Return Value:
    None

--*/
{
    WORD wDefaultOption;
    WORD wCount;
    PWORD pwStruct;
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: %s\r\n", gpstrFeatureName[fid]);
    VOut(pci, "{\r\n");
    //
    // display name references the corresponding value macro
    //
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =%s\r\n", gpstrFeatureDisplayNameMacro[fid]);
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"%s\"\r\n", gpstrFeatureDisplayName[fid]);
    else
        VOut(pci, "    *rcNameID: %d\r\n", gintFeatureDisplayNameID[fid]);

    wDefaultOption = WGetDefaultIndex(pci, gwFeatureMDOI[fid]);
    VOut(pci, "    *DefaultOption: Option%d\r\n", wDefaultOption);
    //
    // loop through each element and output option constructs. Each option
    // is named "OptionX", where X is 1, 2, ... <# of options>.
    //
    wCount = 1;
    while (*psIndex)
    {
        pwStruct = (PWORD)GetTableInfo(pci->pdh, gwFeatureHE[fid], *psIndex - 1);

        VOut(pci, "    *Option: Option%d\r\n", wCount);
        VOut(pci, "    {\r\n");
        //
        // it's guaranteed that the 2nd WORD in a GPC structure
        // is the RC string id for the name.
        //
        VOut(pci, "        *rcNameID: %d\r\n", *(pwStruct+1));
        //
        // check selection command.
        //
        bDocSetup = BInDocSetup(pci, gwFeatureORD[fid], &wOrder);
        if (wOrder > 0 &&
            BBuildCmdStr(pci, gwFeatureCMD[fid],
                               *(pwStruct + gwFeatureOCDWordOffset[fid])))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);
        VOut(pci, "    }\r\n");    // close the option
        //
        // continue on to process next option
        //
        psIndex++;
        wCount++;
    }
    VOut(pci, "}\r\n");            // close the feature
}

void
VOutputColorMode(
    IN OUT PCONVINFO pci,
    PSHORT psIndex)
/*++
Routine Description:
    This function output ColorMode options including the artifical Mono mode.
    The Color option is derived from GPC.

Arguments:
    psIndex: pointer to list of DEVCOLOR structure indicies (1-based).

Return Value:
    None
--*/
{
    PDEVCOLOR   pdc;
    BOOL bDocSetup;
    INT i;
    WORD wDefaultOption, wOrder;

    VOut(pci, "*Feature: ColorMode\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =COLOR_PRINTING_MODE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Color Printing Mode\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_COLORMODE);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_COLOR);
    pdc = (PDEVCOLOR)GetTableInfo(pci->pdh, HE_COLOR,
                                *(psIndex + wDefaultOption - 1) - 1);
    //
    // 3 possibilities: planar mode, 8bpp, 24bpp
    //
    VOut(pci, "    *DefaultOption: %s\r\n",
         (pdc->sPlanes > 1 ? "Color" :
            (pdc->sBitsPixel == 8 ? "8bpp" : "24bpp")));

    bDocSetup = BInDocSetup(pci, PC_ORD_SETCOLORMODE, &wOrder);

    //
    // synthesize the Mono option.
    //
    VOut(pci, "    *Option: Mono\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =MONO_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Monochrome\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_MONO);

    VOut(pci, "        *DevNumOfPlanes: 1\r\n");
    VOut(pci, "        *DevBPP: 1\r\n");
    VOut(pci, "        *Color? : FALSE\r\n");
    //
    // no selection command for MONO mode
    //
    VOut(pci, "    }\r\n");    // close Mono option

    //
    // output color options based on GPC data
    //
    while (*psIndex)
    {
        pdc = (PDEVCOLOR)GetTableInfo(pci->pdh, HE_COLOR, *psIndex - 1);
        if (!(pdc->sBitsPixel==1 && (pdc->sPlanes==3 || pdc->sPlanes==4)) &&
            !(pdc->sPlanes==1 && (pdc->sBitsPixel==8 || pdc->sBitsPixel==24)))
            continue;   // skip this un-supported color format

        VOut(pci, "    *Option: %s\r\n    {\r\n",
             (pdc->sPlanes > 1 ? "Color" :
                (pdc->sBitsPixel == 8 ? "8bpp" : "24bpp")));

        if (pci->dwStrType == STR_MACRO)
            VOut(pci, "        *rcNameID: =%s\r\n",
                 (pdc->sPlanes > 1 ? "COLOR_DISPLAY" :
                    (pdc->sBitsPixel == 8 ? "8BPP_DISPLAY" : "24BPP_DISPLAY")));
        else if (pci->dwStrType == STR_DIRECT)
            VOut(pci, "        *Name: \"%s\"\r\n",
                 (pdc->sPlanes > 1 ? "8 Color (Halftoned)" :
                    (pdc->sBitsPixel == 8 ? "256 Color (Halftoned)" : "True Color (24bpp)")));
        else
            VOut(pci, "        *rcNameID: %d\r\n",
                 (pdc->sPlanes > 1 ? RCID_COLOR :
                    (pdc->sBitsPixel == 8 ? RCID_8BPP : RCID_24BPP)));

        VOut(pci, "        *DevNumOfPlanes: %d\r\n", pdc->sPlanes);
        VOut(pci, "        *DevBPP: %d\r\n", pdc->sBitsPixel);
        VOut(pci, "        *DrvBPP: %d\r\n",
                (pdc->sPlanes > 1 ? max(pdc->sPlanes * pdc->sBitsPixel, 4) :
                                    pdc->sBitsPixel) );
        //
        // output color printing attributes
        //
        if ((pdc->fGeneral & DC_CF_SEND_CR) &&
            (pdc->fGeneral & DC_EXPLICIT_COLOR))
            VOut(pci, "        EXTERN_GLOBAL: *MoveToX0BeforeSetColor? : TRUE\r\n");
        if ((pdc->fGeneral & DC_SEND_ALL_PLANES) ||
            //
            // GPC2.x and older minidrivers assume sending all color
            // planes if using H_BYTE format dump. Ex. HP PaintJet.
            //
            (pci->pdh->wVersion < GPC_VERSION3 && (pci->dwMode & FM_RES_DM_GDI)))
            VOut(pci, "        EXTERN_GLOBAL: *RasterSendAllData? : TRUE\r\n");
        if ((pdc->fGeneral & DC_EXPLICIT_COLOR) ||
            //
            // GPC1.x and GPC2.x minidrivers don'thave DC_EXPLICIT_COLOR bit
            // the driver code assumes that if it's V_BYTE style dump.
            //
            (pci->pdh->wVersion < GPC_VERSION3 && !(pci->dwMode & FM_RES_DM_GDI)))
            VOut(pci, "        EXTERN_GLOBAL: *UseExpColorSelectCmd? : TRUE\r\n");
        //
        // warn flags that have no corresponding GPD entries
        //
        if (pdc->fGeneral & DC_SEND_PALETTE)
            pci->dwErrorCode |= ERR_DC_SEND_PALETTE;

        if (pdc->sPlanes > 1)
        {
            //
            // figure out the color plane order
            //
            BYTE aubOrder[4];
            OCD  aocdPlanes[4];
            POCD pocd;
            OCD  ocd;
            SHORT i;

            //if (!(pdc->fGeneral & DC_EXPLICIT_COLOR))
            {
                //
                // copy color plane data cmds. May need to swap their order
                //
                pocd = (POCD)((PBYTE)pci->pdh + pci->pdh->loHeap + pdc->orgocdPlanes);
                for (i = 0; i < pdc->sPlanes; i++)
                    aocdPlanes[i] = *pocd++;
            }

            if (pci->pdh->wVersion >= GPC_VERSION3)
                *((PDWORD)aubOrder) = *((PDWORD)(pdc->rgbOrder));
            else if (pdc->fGeneral & DC_PRIMARY_RGB)
                *((PDWORD)aubOrder) =
                        (DWORD)DC_PLANE_RED         |
                        (DWORD)DC_PLANE_GREEN << 8  |
                        (DWORD)DC_PLANE_BLUE  << 16 |
                        (DWORD)DC_PLANE_NONE  << 24  ;
            else if (pdc->fGeneral & DC_EXTRACT_BLK)
            {
                //
                // assume it's YMCK model (printing light color first).
                // There was no DC_EXTRACT_BLK support in RES_DM_GDI path.
                //
                *((PDWORD)aubOrder) =
                        (DWORD)DC_PLANE_YELLOW        |
                        (DWORD)DC_PLANE_MAGENTA << 8  |
                        (DWORD)DC_PLANE_CYAN << 16    |
                        (DWORD)DC_PLANE_BLACK << 24    ;
                //if (!(pdc->fGeneral & DC_EXPLICIT_COLOR))
                {
                    //
                    // swap cmds: 0 <-> 3; 1 <-> 3
                    //
                    ocd = aocdPlanes[0];
                    aocdPlanes[0] = aocdPlanes[3];
                    aocdPlanes[3] = ocd;

                    ocd = aocdPlanes[1];
                    aocdPlanes[1] = aocdPlanes[2];
                    aocdPlanes[2] = ocd;
                }
            }
            else // YMC cases
            {
                //
                // the data order was different for RES_DM_GDI and non RES_DM_GDI
                // dump paths.
                if (pci->dwMode & FM_RES_DM_GDI)
                    *((PDWORD)aubOrder) =
                            (DWORD)DC_PLANE_CYAN          |
                            (DWORD)DC_PLANE_MAGENTA << 8  |
                            (DWORD)DC_PLANE_YELLOW  << 16 |
                            (DWORD)DC_PLANE_NONE    << 24  ;
                else
                {
                    *((PDWORD)aubOrder) =
                            (DWORD)DC_PLANE_YELLOW        |
                            (DWORD)DC_PLANE_MAGENTA << 8  |
                            (DWORD)DC_PLANE_CYAN    << 16 |
                            (DWORD)DC_PLANE_NONE    << 24  ;

                    //if (!(pdc->fGeneral & DC_EXPLICIT_COLOR))
                    {
                        //
                        // swap cmds: 0 <-> 2
                        //
                        ocd = aocdPlanes[0];
                        aocdPlanes[0] = aocdPlanes[2];
                        aocdPlanes[2] = ocd;
                    }
                }
            }
            if (aubOrder[3] == DC_PLANE_NONE)
                VOut(pci, "        *ColorPlaneOrder: LIST(%s, %s, %s)\r\n",
                                             gpstrColorName[aubOrder[0]],
                                             gpstrColorName[aubOrder[1]],
                                             gpstrColorName[aubOrder[2]]);
            else
                VOut(pci, "        *ColorPlaneOrder: LIST(%s, %s, %s, %s)\r\n",
                                             gpstrColorName[aubOrder[0]],
                                             gpstrColorName[aubOrder[1]],
                                             gpstrColorName[aubOrder[2]],
                                             gpstrColorName[aubOrder[3]]);
            //
            // output send-color-plane-data cmds
            //
            //if (!(pdc->fGeneral & DC_EXPLICIT_COLOR))
            {
                for (i = 0; i < pdc->sPlanes; i++)
                    if (BBuildCmdStr(pci, gwColorPlaneCmdID[i], aocdPlanes[i]))
                        VOutputExternCmd(pci, gpstrColorPlaneCmdName[aubOrder[i]]);
            }
            //
            // output foreground (text) color selection commands
            //
            if (BBuildCmdStr(pci, CMD_DC_TC_BLACK, pdc->rgocd[DC_OCD_TC_BLACK]))
                VOutputExternCmd(pci, "CmdSelectBlackColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_RED, pdc->rgocd[DC_OCD_TC_RED]))
                VOutputExternCmd(pci, "CmdSelectRedColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_GREEN, pdc->rgocd[DC_OCD_TC_GREEN]))
                VOutputExternCmd(pci, "CmdSelectGreenColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_YELLOW, pdc->rgocd[DC_OCD_TC_YELLOW]))
                VOutputExternCmd(pci, "CmdSelectYellowColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_BLUE, pdc->rgocd[DC_OCD_TC_BLUE]))
                VOutputExternCmd(pci, "CmdSelectBlueColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_MAGENTA, pdc->rgocd[DC_OCD_TC_MAGENTA]))
                VOutputExternCmd(pci, "CmdSelectMagentaColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_CYAN, pdc->rgocd[DC_OCD_TC_CYAN]))
                VOutputExternCmd(pci, "CmdSelectCyanColor");
            if (BBuildCmdStr(pci, CMD_DC_TC_WHITE, pdc->rgocd[DC_OCD_TC_WHITE]))
                VOutputExternCmd(pci, "CmdSelectWhiteColor");

        }
        else // palette color
        {
            VOut(pci, "        *PaletteSize: 256\r\n");     // match RASDD behavior
            VOut(pci, "        *PaletteProgrammable? : TRUE\r\n");
            //
            // output palette commands
            //
            if (BBuildCmdStr(pci, CMD_DC_PC_START, pdc->rgocd[DC_OCD_PC_START]))
                VOutputExternCmd(pci, "CmdBeginPaletteDef");

            if (BBuildCmdStr(pci, CMD_DC_PC_END, pdc->rgocd[DC_OCD_PC_END]))
                VOutputExternCmd(pci, "CmdEndPaletteDef");

            if (BBuildCmdStr(pci, CMD_DC_PC_ENTRY, pdc->rgocd[DC_OCD_PC_ENTRY]))
                VOutputExternCmd(pci, "CmdDefinePaletteEntry");

            if (BBuildCmdStr(pci, CMD_DC_PC_SELECTINDEX, pdc->rgocd[DC_OCD_PC_SELECTINDEX]))
                VOutputExternCmd(pci, "CmdSelectPaletteEntry");

        }
        //
        // output the selection command
        //
        if (wOrder > 0 &&
            BBuildCmdStr(pci, CMD_DC_SETCOLORMODE, pdc->rgocd[DC_OCD_SETCOLORMODE]))
            VOutputSelectionCmd(pci, bDocSetup, wOrder);

        //
        // output any constraints w.r.t. Resolution
        //
        for (i = 0; i < (INT)pci->dwNumOfRes; i++)
        {
            if (!pci->presinfo[i].bColor)
                VOut(pci, "        *Constraints: Resolution.%s\r\n",
                        pci->presinfo[i].aubOptName);
        }
        VOut(pci, "    }\r\n");    // close Color option

        psIndex++;
    }

    VOut(pci, "}\r\n");    // close ColorMode feature
}

void
VOutputHalftone(
    IN OUT PCONVINFO pci)
{
    //
    // Generate 4 standard options: Auto, SuperCell, 6x6, 8x8
    //

    VOut(pci, "*Feature: Halftone\r\n{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =HALFTONING_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Halftoning\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_HALFTONE);

    VOut(pci, "    *DefaultOption: HT_PATSIZE_AUTO\r\n");

    VOut(pci, "    *Option: HT_PATSIZE_AUTO\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =HT_AUTO_SELECT_DISPLAY\r\n    }\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Auto Select\"\r\n    }\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n    }\r\n", RCID_HT_AUTO_SELECT);

    VOut(pci, "    *Option: HT_PATSIZE_SUPERCELL_M\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =HT_SUPERCELL_DISPLAY\r\n    }\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Super Cell\"\r\n    }\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n    }\r\n", RCID_HT_SUPERCELL);

    VOut(pci, "    *Option: HT_PATSIZE_6x6_M\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =HT_DITHER6X6_DISPLAY\r\n    }\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Dither 6x6\"\r\n    }\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n    }\r\n", RCID_HT_DITHER6X6);

    VOut(pci, "    *Option: HT_PATSIZE_8x8_M\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =HT_DITHER8X8_DISPLAY\r\n    }\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Dither 8x8\"\r\n    }\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n    }\r\n", RCID_HT_DITHER8X8);

    VOut(pci, "}\r\n");     // close Halftone feature
}

void
VOutputMemConfig(
    IN OUT PCONVINFO pci,
    PWORD pwMems)
{
    WORD    wDefaultOption;
    BOOL    bGPC3 = pci->pdh->wVersion >= GPC_VERSION3;

    VOut(pci, "*Feature: Memory\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =PRINTER_MEMORY_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Printer Memory\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_MEMORY);

    wDefaultOption = WGetDefaultIndex(pci, MD_OI_MEMCONFIG);
    VOut(pci, "    *DefaultOption: %dKB\r\n", bGPC3?
                              *(((PDWORD)pwMems)+ 2*(wDefaultOption-1)) :
                              *pwMems);
    //
    // loop through each index which maps to one *MemConfigKB entry
    //
    while (bGPC3? *((PDWORD)pwMems) : *pwMems)
    {
        DWORD dwInstalled, dwAvailable;

        dwInstalled = (bGPC3? *((PDWORD)pwMems)++ : (DWORD)*pwMems++);
        dwAvailable = (bGPC3? *((PDWORD)pwMems)++ : (DWORD)*pwMems++);
        //
        // have to use two temp variables. If we put the above two
        // expressions directly in the VOut call, the actual values
        // are reversed for some reason.
        //
        VOut(pci, "    *Option: %dKB\r\n    {\r\n", dwInstalled);
        if (dwInstalled % 1024 != 0)
            VOut(pci, "        *Name: \"%dKB\"\r\n", dwInstalled);
        else
            VOut(pci, "        *Name: \"%dMB\"\r\n", (dwInstalled >> 10));

        VOut(pci, "        *MemoryConfigKB: PAIR(%d, %d)\r\n", dwInstalled, dwAvailable);
        VOut(pci, "    }\r\n");
    }

    VOut(pci, "}\r\n");    // close Memory feature
}

void
VOutputDuplex(
    IN OUT PCONVINFO pci)
{
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: Duplex\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =TWO_SIDED_PRINTING_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Two Sided Printing\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_DUPLEX);

    VOut(pci, "    *DefaultOption: NONE\r\n");
    VOut(pci, "    *Option: NONE\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =NONE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"None\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_NONE);
    //
    // output the selection command
    //
    bDocSetup = BInDocSetup(pci, PC_ORD_DUPLEX, &wOrder);
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PC_DUPLEX_OFF, pci->ppc->rgocd[PC_OCD_DUPLEX_OFF]))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");    // close NONE option

    //
    // assume there is no PC_OCD_DUPLEX_ON command. True for PCL printers.
    //
    if (pci->ppc->rgocd[PC_OCD_DUPLEX_ON] != NOOCD)
        pci->dwErrorCode |= ERR_HAS_DUPLEX_ON_CMD;

    VOut(pci, "    *Option: VERTICAL\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =FLIP_ON_LONG_EDGE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Flip on long edge\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_FLIP_ON_LONG_EDGE);
    //
    // output the selection command
    //
    bDocSetup = BInDocSetup(pci, PC_ORD_DUPLEX_TYPE, &wOrder);
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PC_DUPLEX_VERT, pci->ppc->rgocd[PC_OCD_DUPLEX_VERT]))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");    // close VERTICAL option

    VOut(pci, "    *Option: HORIZONTAL\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =FLIP_ON_SHORT_EDGE_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Flip on short edge\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_FLIP_ON_SHORT_EDGE);
    //
    // output the selection command. Same order as VERTICAL case.
    //
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PC_DUPLEX_HORZ, pci->ppc->rgocd[PC_OCD_DUPLEX_HORZ]))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");    // close HORIZONTAL option

    VOut(pci, "}\r\n");        // close Duplex feature
}

void
VOutputPageProtect(
    IN OUT PCONVINFO pci)
{
    BOOL bDocSetup;
    WORD wOrder;

    VOut(pci, "*Feature: PageProtect\r\n");
    VOut(pci, "{\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "    *rcNameID: =PAGE_PROTECTION_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "    *Name: \"Page Protection\"\r\n");
    else
        VOut(pci, "    *rcNameID: %d\r\n", RCID_PAGEPROTECTION);

    VOut(pci, "    *DefaultOption: OFF\r\n");
    VOut(pci, "    *Option: ON\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =ON_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"On\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_ON);
    //
    // output the selection command
    //
    bDocSetup = BInDocSetup(pci, PC_ORD_PAGEPROTECT, &wOrder);
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PAGEPROTECT_ON, pci->ocdPPOn))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");    // close ON option

    VOut(pci, "    *Option: OFF\r\n    {\r\n");
    if (pci->dwStrType == STR_MACRO)
        VOut(pci, "        *rcNameID: =OFF_DISPLAY\r\n");
    else if (pci->dwStrType == STR_DIRECT)
        VOut(pci, "        *Name: \"Off\"\r\n");
    else
        VOut(pci, "        *rcNameID: %d\r\n", RCID_OFF);
    //
    // output the selection command
    //
    if (wOrder > 0 &&
        BBuildCmdStr(pci, CMD_PAGEPROTECT_OFF, pci->ocdPPOff))
        VOutputSelectionCmd(pci, bDocSetup, wOrder);
    VOut(pci, "    }\r\n");    // close OFF option

    VOut(pci, "}\r\n");        // close PageProtect feature
}

void
VOutputPaperConstraints(
    IN OUT PCONVINFO pci)
{
    DWORD i, j;

    for (i = 0; i < pci->dwNumOfSrc; i++)
    {
        for (j = 0; j < pci->dwNumOfSize; j++)
        {
            if (!(pci->ppiSrc[i].dwPaperType & pci->ppiSize[j].dwPaperType))
                VOut(pci, "*InvalidCombination: LIST(InputBin.%s, PaperSize.%s)\r\n",
                        pci->ppiSrc[i].aubOptName, pci->ppiSize[j].aubOptName);
        }
    }
}

void
VOutputUIEntries(
    IN OUT PCONVINFO pci)
{
    PSHORT  psIndex;
    BOOL    bGPC3 = pci->pdh->wVersion >= GPC_VERSION3;

    //
    // check if this is a TTY device. If so, do not generate the Orientation
    // feature.
    //
    if (pci->pdh->fTechnology != GPC_TECH_TTY)
        VOutputOrientation(pci);
    //
    // check input bins. This must come before VOutputPaperSize to gather
    // info about feed margins.
    //
    // patryan - if no PAPERSOURCE structure is found in GPC then output a dummy
    // feature, containing just one option. This is to satisfy GPD parser, which 
    // fail if GPD contains no InputBin feature.

    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_PAPERSOURCE])) != 0)
        VOutputInputBin(pci, psIndex);
    else
        VOutputDummyInputBin(pci);
  
    //
    // check Resolution
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_RESOLUTION])) != 0)
        VOutputResolution(pci, psIndex);
    //
    // set up pci->ptMoveScale for use in generating *PrintableOrigin
    // and *CursorOrigin.
    // Assume that all X-move cmds have the same units. Same for Y-move cmds.
    //
    {
        PCURSORMOVE pcm;
        DWORD   tmp;

        pcm = (PCURSORMOVE)GetTableInfo(pci->pdh, HE_CURSORMOVE,
                                        pci->pmd->rgi[MD_I_CURSORMOVE]);
        pci->ptMoveScale.x = pci->ptMoveScale.y = 1;
        if (pcm && !(pcm->fYMove & CM_YM_RES_DEPENDENT))
        {
            if (tmp = DwCalcMoveUnit(pci, pcm, pci->pdh->ptMaster.x,
                                     CM_OCD_XM_ABS, CM_OCD_XM_RELLEFT))
            {
                //  Verify move scale factor is not zero.  Otherwise an essential
                //  GPD assumption is violated.
                if(!(pci->pdh->ptMaster.x / (WORD)tmp)  ||  pci->pdh->ptMaster.x % (WORD)tmp)
                    pci->dwErrorCode |= ERR_MOVESCALE_NOT_FACTOR_OF_MASTERUNITS;
                else
                    pci->ptMoveScale.x = pci->pdh->ptMaster.x / (WORD)tmp;
            }
            if (tmp = DwCalcMoveUnit(pci, pcm, pci->pdh->ptMaster.y,
                                     CM_OCD_YM_ABS, CM_OCD_YM_RELUP))
            {
                if(!(pci->pdh->ptMaster.y / (WORD)tmp)  ||  pci->pdh->ptMaster.y % (WORD)tmp)
                    pci->dwErrorCode |= ERR_MOVESCALE_NOT_FACTOR_OF_MASTERUNITS;
                else
                    pci->ptMoveScale.y = pci->pdh->ptMaster.y / (WORD)tmp;
            }


            //
            // Verify that the move scale factor evenly into every resolution
            // scale if RES_DM_GDI is set. This is TRUE for most, if not all,
            // inkjet and page printers. With this assumption, we can simplify
            // checking the printable origin values later on.
            //
            if (pci->dwMode & FM_RES_DM_GDI)
                for (tmp = 0; tmp < pci->dwNumOfRes; tmp++)
                {
                    if ((pci->presinfo[tmp].dwXScale % pci->ptMoveScale.x != 0) ||
                        (pci->presinfo[tmp].dwYScale % pci->ptMoveScale.y != 0) )
                    {
                        pci->dwErrorCode |= ERR_MOVESCALE_NOT_FACTOR_INTO_SOME_RESSCALE;
                        break;
                    }
                }
        }
    }

    //
    // check PAPERSIZE.
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_PAPERSIZE])) != 0)
        VOutputPaperSize(pci, psIndex);
    //
    // output PaperSize & InputBin constraints, if any.
    // RES_DM_COLOR is handled in VOutputResolutions.
    // RES_DM_DOWNLOAD_OUTLINE is handled in VOutputPrintingEntries.
    //
    VOutputPaperConstraints(pci);

    //
    // check PaperQuality, a.k.a. MediaType
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_PAPERQUALITY])) != 0)
        VOutputMediaType(pci, psIndex);
    //
    // check TextQuality (ex. "Letter Quality")
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_TEXTQUAL])) != 0)
        VOutputTextQuality(pci, psIndex);
    //
    // check PaperDestination
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_PAPERDEST])) != 0)
        VOutputFeature(pci, FID_PAPERDEST, psIndex);
    //
    // check ImageControl
    //
    if (bGPC3 &&
        *(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi2[MD_OI2_IMAGECONTROL])) != 0)
        VOutputFeature(pci, FID_IMAGECONTROL, psIndex);
    //
    // check PrintDensity
    //
    if (bGPC3 &&
        *(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi2[MD_OI2_PRINTDENSITY])) != 0)
        VOutputFeature(pci, FID_PRINTDENSITY, psIndex);
    //
    // check DEVCOLOR
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_COLOR])) != 0)
        VOutputColorMode(pci, psIndex);
    //
    // synthesize Halftone feature
    //
    VOutputHalftone(pci);
    //
    // check MemConfig
    //
    if (*(psIndex = DHOFFSET(pci->pdh, pci->pmd->rgoi[MD_OI_MEMCONFIG])) != 0)
    {
        VOutputMemConfig(pci, (PWORD)psIndex);
        pci->dwMode |= FM_MEMORY_FEATURE_EXIST;
    }
    //
    // synthesize Duplex feature if necessary.
    //
    if (pci->pmd->fGeneral & MD_DUPLEX)
        VOutputDuplex(pci);
    //
    // synthesize PageProtect feature if necessary
    //
    if ((pci->pmd->fGeneral & MD_PCL_PAGEPROTECT) &&
        (pci->dwMode & FM_SYN_PAGEPROTECT))
        VOutputPageProtect(pci);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\gpc2gpd\prentry.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    prentry.c

Abstract:

    This file implements functions that generate printing related GPD entries.

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

--*/

#include "gpc2gpd.h"


DWORD
DwCalcMoveUnit(
    IN PCONVINFO pci,
    IN PCURSORMOVE pcm,
    IN WORD wMasterUnit,
    IN WORD wStartOCD,
    IN WORD wEndOCD)
/*++
Routine Description:
    This function calculates the unit used by movement commands in the
    given range.

Arguments:
    pci: conversion related info
    pcm: the current CURSORMOVE structure
        wMasterUnit: X or Y master unit depending on the OCD range
    wStartOCD: the starting OCD to scan
    wEndOCD: the ending OCD to scan

Return Value:
    the movement command unit. If there is no movement command, return 0.

--*/
{
    WORD    i;
    OCD     ocd;
    PCD     pcd;
    PEXTCD  pextcd = NULL;      // points the parameter's EXTCD.

    for (ocd = (WORD)NOOCD, i = wStartOCD; i <= wEndOCD; i++)
        if (pcm->rgocd[i] != NOOCD)
        {
            ocd = pcm->rgocd[i];
            break;
        }
    if (ocd != NOOCD)
    {
        pcd = (PCD)((PBYTE)(pci->pdh) + (pci->pdh)->loHeap + ocd);
        if (pcd->wCount != 0)
            pextcd = GETEXTCD(pci->pdh, pcd);
        if (pextcd)
        {
            short sMult, sDiv;

            if ((sMult = pextcd->sUnitMult) == 0)
                sMult = 1;
            if ((sDiv = pextcd->sUnitDiv) == 0)
                sDiv = 1;

            if (pextcd->fGeneral & XCD_GEN_MODULO)
                return (DWORD)((((wMasterUnit + pextcd->sPreAdd) * sMult) %
                                sDiv) + pextcd->sUnitAdd);
            else
                return (DWORD)((((wMasterUnit + pextcd->sPreAdd) * sMult) /
                                sDiv) + pextcd->sUnitAdd);
        }
        else // no modification needed
            return (DWORD)wMasterUnit;
    }
    else
        return 0;

}


void
VOutTextCaps(
    IN OUT PCONVINFO pci,
    WORD fText,
    BOOL bIndent)
{
    //
    // at most 15 text capability flags can be used. In reality,
    // only less than 5 are used. So we don't break into multiple lines
    // for simplicity.
    //
    pci->dwMode |= FM_VOUT_LIST; // special handling for erasing last comma
    VOut(pci, "%s*TextCaps: LIST(%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s)\r\n",
         bIndent ? "        " : "",
         (fText & TC_OP_CHARACTER) ? "TC_OP_CHARACTER," : "",
         (fText & TC_OP_STROKE) ? "TC_OP_STROKE," : "",
         (fText & TC_CP_STROKE) ? "TC_CP_STROKE," : "",
         (fText & TC_CR_90) ? "TC_CR_90," : "",
         (fText & TC_CR_ANY) ? "TC_CR_ANY," : "",
         (fText & TC_SF_X_YINDEP) ? "TC_SF_X_YINDEP," : "",
         (fText & TC_SA_DOUBLE) ? "TC_SA_DOUBLE," : "",
         (fText & TC_SA_INTEGER) ? "TC_SA_INTEGER," : "",
         (fText & TC_SA_CONTIN) ? "TC_SA_CONTIN," : "",
         (fText & TC_EA_DOUBLE) ? "TC_EA_DOUBLE," : "",
         (fText & TC_IA_ABLE) ? "TC_IA_ABLE," : "",
         (fText & TC_UA_ABLE) ? "TC_UA_ABLE," : "",
         (fText & TC_SO_ABLE) ? "TC_SO_ABLE," : "",
         (fText & TC_RA_ABLE) ? "TC_RA_ABLE," : "",
         (fText & TC_VA_ABLE) ? "TC_VA_ABLE" : "");
    pci->dwMode &= ~FM_VOUT_LIST;

}

//
// values for dwType param below.
//
#define FF_INPUTBIN     1
#define FF_PAPERSIZE    2
#define FF_BOTH         3

void
VCreateEjectFFDependency(
    PCONVINFO pci,
    DWORD dwType,           // type of dependency
    BOOL bIndentation)      // whether to add extra 2 levels of indentation
//
// Generate dependency on either InputBin or PaperSize options.
// Always use the 1st option to establish the base value.
//
{
    PPAPERINFO ppi;
    DWORD dwCount;
    DWORD i;

    if (dwType == FF_INPUTBIN)
    {
        ppi = pci->ppiSrc;
        dwCount = pci->dwNumOfSrc;
    }
    else // either FF_PAPERSIZE or FF_BOTH
    {
        ppi = pci->ppiSize;
        dwCount = pci->dwNumOfSize;
    }

    VOut(pci, "%s*EjectPageWithFF?: %s\r\n",
                bIndentation? "        " : "",
                (ppi[0].bEjectFF) ? "TRUE" : "FALSE");
    VOut(pci, "%s*switch: %s\r\n%s{\r\n",
                bIndentation? "        " : "",
                dwType == FF_INPUTBIN? "InputBin" : "PaperSize",
                bIndentation? "        " : "");
    //
    // loop through the rest of options. If it's different
    // than the first one, create a *case construct for it.
    //
    for (i = 1; i < dwCount; i++)
        if (ppi[i].bEjectFF != ppi[0].bEjectFF)
        {
            VOut(pci, "%s    *case: %s\r\n%s    {\r\n",
                        bIndentation? "        " : "",
                        ppi[i].aubOptName,
                        bIndentation? "        " : "");
            if (dwType == FF_BOTH)
                VCreateEjectFFDependency(pci, FF_INPUTBIN, TRUE);
            else
                VOut(pci, "%s        *EjectPageWithFF?: %s\r\n",
                        bIndentation? "        " : "",
                        ppi[0].bEjectFF ? "FALSE" : "TRUE");
            VOut(pci, "%s    }\r\n", bIndentation? "        " : "");

        }
    VOut(pci, "%s}\r\n", bIndentation? "        " : ""); // close *switch construct
}

DWORD
DwMergeFonts(
    PWORD pwBuf,
    DWORD dwStartIndex,
    PWORD pwList)
{
    DWORD i, count;
    WORD id;
    WORD low, high;

    if (!*pwList)
        return 0;
    low = *pwList;
    high = *(pwList + 1);

    for (count = 0, id = low; id <= high; id++)
    {
        for (i = 0; i < dwStartIndex; i++)
        {
            if (pwBuf[i] == id)
                break;
        }
        if (i == dwStartIndex)  // this is not a repeat
        {
            pwBuf[dwStartIndex + count] = id;
            count++;
        }
    }
    pwList += 2;    // skip the range numbers
    while (id = *pwList)
    {
        for (i = 0; i < dwStartIndex; i++)
        {
            if (pwBuf[i] == id)
                break;
        }
        if (i == dwStartIndex)  // this is not a repeat
        {
            pwBuf[dwStartIndex + count] = id;
            count++;
        }
        pwList++;
    }
    return count;
}
void
VOutputFontList(
    IN OUT PCONVINFO pci,
    IN PWORD pwPFonts,
    IN PWORD pwLFonts)
/*++
Routine Description:
    This function outputs the font id list: LIST( , , ...) which ends with a
    a newline character. If two font lists are given, merge them first and
    remove the repeated id's.

Arguments:
    pci: point to CONVINFO
    pwPFonts: point to list of font id's available in Portrait orientation.
              Note that as in GPC, the first two numbers represent the
              inclusive range of the font id's. Can be NULL.
    pwLFonts: Landscape font list. Can be NULL.

Return Value:
    NONE.
--*/
{

    DWORD i, count;
    WORD awFonts[1000] = {0}; // assume at most 1000 resident fonts per printer

    //
    // first, collect the list of fonts (unique id's)
    //
    count = 0;
    if (pwPFonts)
        count += DwMergeFonts(awFonts, count, pwPFonts);
    if (pwLFonts)
        count += DwMergeFonts(awFonts, count, pwLFonts);

    if (count == 0)
    {
        VOut(pci, "LIST()\r\n");
        return;
    }

#if defined(DEVSTUDIO)  //  Must map these lists to account for multi PFM-> UFM
    vMapFontList(awFonts, count, pci);
#endif

    VOut(pci, "LIST(");
    for (i = 0; i < count - 1; i++)
    {
        //
        // check if need to move to a new line. Estimate 16 fonts id's
        // per line.
        //
        if (i && i % 16 == 0)
            VOut(pci, "\r\n+                   ");
        VOut(pci, "%d,", awFonts[i]);
    }
    VOut(pci, "%d)\r\n", awFonts[i]);  // last one
}

void
VOutputPrintingEntries(
    IN OUT PCONVINFO pci)
{
    PDH pdh = pci->pdh;
    PMODELDATA pmd = pci->pmd;
    PCURSORMOVE pcm;
    PGPCRESOLUTION pres;
    PPAPERSIZE  pps;
    PSHORT      psIndex;
    WORD        wCount;

    pcm = (PCURSORMOVE)GetTableInfo(pdh, HE_CURSORMOVE,
                                    pmd->rgi[MD_I_CURSORMOVE]);
    if (*(psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_RESOLUTION])) == 0)
        pres = NULL;
    else
        pres = (PGPCRESOLUTION)GetTableInfo(pdh, HE_RESOLUTION,
               *(psIndex + WGetDefaultIndex(pci, MD_OI_RESOLUTION) - 1) - 1);
    if (*(psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_PAPERSIZE])) == 0)
        pps = NULL;
    else
        pps = (PPAPERSIZE)GetTableInfo(pdh, HE_PAPERSIZE,
              *(psIndex + WGetDefaultIndex(pci, MD_OI_PAPERSIZE) - 1) - 1);
    //
    // ASSUMPTIONS:
    // 1. all GPCRESOLUTION structs have same fCursor field value
    // 2. all PAPERSIZE structs have the same setting for PS_CENTER flag
    // 3. RES_DM_GDI and RES_DM_LEFT_BOUND bits are set consistently for
    //    all GPCRESOLUTION options.
    //

    //
    // Printer Configuration Commands
    //
    {
        BOOL bDocSetup;
        WORD wOrder;
        POCD pocd = (POCD)(pci->ppc->rgocd);

        //
        // Note that both in RASDD and Win95 Unidrv, the configuration
        // commands and selection commands are classified as follows:
        // 1. All commands before PC_OCD_BEGIN_PAGE (exclusive) are sent per
        //    job and per ResetDC. So they should be in DOC_SETUP section.
        // 2. All commands after PC_OCD_BEGIN_PAGE (inclusive) is sent at the
        //    beginning of each page. So they should be in PAGE_SETUP section.
        // 3. PC_OCD_ENDDOC is sent only once per job. So it should be in
        //    JOB_FINISH section.
        // 4. PC_OCD_ENDPAGE is sent only once at the end of each page. So
        //    it should be in PAGE_FINISH section.
        // 5. There is nothing in JOB_SETUP section when converting from GPC.
        // 6. There is nothing in DOC_FINISH section when converting from
        //    GPC.
        //
        bDocSetup = BInDocSetup(pci, PC_ORD_BEGINDOC, &wOrder);
        if (wOrder > 0 &&
            BBuildCmdStr(pci, CMD_PC_BEGIN_DOC, pocd[PC_OCD_BEGIN_DOC]))
            VOutputConfigCmd(pci, "CmdStartDoc",
                             bDocSetup? SS_DOCSETUP : SS_PAGESETUP, wOrder);

        if (BBuildCmdStr(pci, CMD_PC_BEGIN_PAGE, pocd[PC_OCD_BEGIN_PAGE]))
            VOutputConfigCmd(pci, "CmdStartPage", SS_PAGESETUP, 1);

        if (BBuildCmdStr(pci, CMD_PC_ENDDOC, pocd[PC_OCD_ENDDOC]))
            VOutputConfigCmd(pci, "CmdEndJob", SS_JOBFINISH, 1);

        if (BBuildCmdStr(pci, CMD_PC_ENDPAGE, pocd[PC_OCD_ENDPAGE]))
            VOutputConfigCmd(pci, "CmdEndPage", SS_PAGEFINISH, 1);

        bDocSetup = BInDocSetup(pci, PC_ORD_MULT_COPIES, &wOrder);
        if (wOrder > 0 && pci->ppc->sMaxCopyCount > 1 &&
            BBuildCmdStr(pci, CMD_PC_MULT_COPIES, pocd[PC_OCD_MULT_COPIES]))
            VOutputConfigCmd(pci, "CmdCopies",
                             bDocSetup? SS_DOCSETUP : SS_PAGESETUP, wOrder);
    }
    //
    // Printer Capabilities
    //
    VOut(pci, "*RotateCoordinate?: %s\r\n",
              (pmd->fGeneral & MD_LANDSCAPE_RT90) ? "TRUE" : "FALSE");
    VOut(pci, "*RotateRaster?: %s\r\n",
              (pmd->fGeneral & MD_LANDSCAPE_GRX_ABLE) ? "TRUE" : "FALSE");
    VOut(pci, "*RotateFont?: %s\r\n",
              (pmd->fGeneral & MD_ROTATE_FONT_ABLE) ? "TRUE" : "FALSE");
    if (pmd->fText || pmd->fLText)
    {
        if (pmd->fText == pmd->fLText)
            VOutTextCaps(pci, pmd->fText, FALSE);
        else
        {
            VOut(pci, "*switch: Orientation\r\n{\r\n");
            VOut(pci, "    *case: PORTRAIT\r\n    {\r\n");
            VOutTextCaps(pci, pmd->fText, TRUE);
            VOut(pci, "    }\r\n");
            if (pmd->fGeneral & MD_LANDSCAPE_RT90)
                VOut(pci, "    *case: LANDSCAPE_CC90\r\n    {\r\n");
            else
                VOut(pci, "    *case: LANDSCAPE_CC270\r\n    {\r\n");
            VOutTextCaps(pci, pmd->fLText, TRUE);
            VOut(pci, "    }\r\n}\r\n");
        }
    }
    if (pci->dwMode & FM_MEMORY_FEATURE_EXIST)
        VOut(pci, "*MemoryUsage: LIST(%s)\r\n",
             (pmd->fGeneral & MD_FONT_MEMCFG) ? "FONT" : "FONT, RASTER, VECTOR");

    //
    // Cursor Control
    //
    if (pres)
        VOut(pci, "*CursorXAfterCR: %s\r\n", (pres->fCursor & RES_CUR_CR_GRX_ORG)?
                              "AT_PRINTABLE_X_ORIGIN" : "AT_CURSOR_X_ORIGIN");
    if (pcm)
    {
        enum {Y_MOVE_NONE = 0, Y_MOVE_UP = 1, Y_MOVE_DOWN = 2, Y_MOVE_ABS = 4 }
            eCmdsPresent = Y_MOVE_NONE,
            eRelativeYCmds = /* Y_MOVE_UP | */   Y_MOVE_DOWN;    // use as bit field
            // for now just Y_MOVE_DOWN is sufficient for Relative Y move support.

        pci->pcm = pcm;
        //
        // check for flags that are ignored by NT4.0 RASDD but used by
        // Win95 Unidrv. When these flags are found, we expect minidriver
        // developers to double-check the generated GPD file to ensure
        // identical output under the new driver.
        //
        if (pcm->fGeneral & CM_GEN_FAV_XY)
            pci->dwErrorCode |= ERR_CM_GEN_FAV_XY;
        if (pcm->fXMove & CM_XM_RESET_FONT)
            pci->dwErrorCode |= ERR_CM_XM_RESET_FONT;

        if(pci->dwErrorCode & ERR_RES_BO_RESET_FONT)
            VOut(pci, "        *ReselectFont: LIST(%sAFTER_GRXDATA)\r\n",
            (pci->dwErrorCode & ERR_CM_XM_RESET_FONT)? "AFTER_XMOVE, ":"");
        else if(pci->dwErrorCode & ERR_CM_XM_RESET_FONT)
            VOut(pci, "        *ReselectFont: LIST(AFTER_XMOVE)\r\n");

        if (pcm->fXMove & CM_XM_ABS_NO_LEFT)
            pci->dwErrorCode |= ERR_CM_XM_ABS_NO_LEFT;
        if (pcm->fYMove & CM_YM_TRUNCATE)
            pci->dwErrorCode |= ERR_CM_YM_TRUNCATE;

        if ((pcm->fXMove & (CM_XM_NO_POR_GRX | CM_XM_NO_LAN_GRX)) ||
            (pcm->fYMove & (CM_YM_NO_POR_GRX | CM_YM_NO_LAN_GRX)))
        {
            pci->dwMode |= FM_VOUT_LIST;
            VOut(pci, "*BadCursorMoveInGrxMode: LIST(%s%s%s%s)\r\n",
                 (pcm->fXMove & CM_XM_NO_POR_GRX) ? "X_PORTRAIT," : "",
                 (pcm->fXMove & CM_XM_NO_LAN_GRX) ? "X_LANDSCAPE," : "",
                 (pcm->fYMove & CM_YM_NO_POR_GRX) ? "Y_PORTRAIT," : "",
                 (pcm->fYMove & CM_YM_NO_LAN_GRX) ? "Y_LANDSCAPE" : "");

            pci->dwMode &= ~FM_VOUT_LIST;
        }
        if ((pcm->fYMove & CM_YM_CR) ||
            ((pcm->fYMove & CM_YM_LINESPACING) &&
             pcm->rgocd[CM_OCD_YM_LINESPACING] != NOOCD) )
        {
            pci->dwMode |= FM_VOUT_LIST;

            VOut(pci, "*YMoveAttributes: LIST(%s%s)\r\n",
                 (pcm->fYMove & CM_YM_CR) ? "SEND_CR_FIRST," : "",
                 (pcm->fYMove & CM_YM_LINESPACING) ? "FAVOR_LF" : "");

            pci->dwMode &= ~FM_VOUT_LIST;
        }
        if (pcm->rgocd[CM_OCD_YM_LINESPACING] != NOOCD) // it takes 1 param.
        {
            PCD     pcd;
            PEXTCD  pextcd;      // points the parameter's EXTCD.

            pcd = (PCD)((PBYTE)(pdh) + pdh->loHeap +
                                      pcm->rgocd[CM_OCD_YM_LINESPACING]);
            pextcd = GETEXTCD(pdh, pcd);
            if (!(pextcd->fGeneral & XCD_GEN_NO_MAX))
                VOut(pci, "*MaxLineSpacing: %d\r\n",pextcd->sMax);
        }
        //
        // Three cases:
        // 1) if only absolute X-move command is specified,*XMoveThreshold
        //    should be 0, i.e. always use absolute cmd.
        // 2) if only relative X-move command is specified, *XMoveThreshold
        //    should be *, i.e always use relative cmds.
        // 3) if both are specified, both RASDD and Win95 Unidrv prefers
        //    absolute X-move cmd regardless of CM_XM_FAVOR_ABS bit. In that
        //    case, *XMoveThreshold should be 0, which is the default value.
        //
        if (pcm->rgocd[CM_OCD_XM_ABS] == NOOCD)
        {
            if (pcm->rgocd[CM_OCD_XM_REL] != NOOCD ||
                pcm->rgocd[CM_OCD_XM_RELLEFT] != NOOCD)
                VOut(pci, "*XMoveThreshold: *\r\n");
        }
        else
            VOut(pci, "*XMoveThreshold: 0\r\n");

        //
        // But CM_YM_FAV_ABS bit is honored by both drivers, except Win95 Unidrv
        // adds a hack: if the y-move is relative upward (i.e. genative diff)
        // with less than 10 pixels (in master Y unit), then always use
        // the relative Y movement. I don't see a strong reason to preserve
        // this hack.
        //
        if ((pcm->fYMove & CM_YM_FAV_ABS) && pcm->rgocd[CM_OCD_YM_ABS] != NOOCD)
            VOut(pci, "*YMoveThreshold: 0\r\n");
        else if (pcm->rgocd[CM_OCD_YM_REL] != NOOCD ||
                 pcm->rgocd[CM_OCD_YM_RELUP] != NOOCD)
            VOut(pci, "*YMoveThreshold: *\r\n");
        //
        // Figure out the X & Y movement units.
        // Assume that all X-move cmds have the same units. Same for Y-move cmds.
        //
        {
            DWORD    dwMoveUnit;

            if (dwMoveUnit = DwCalcMoveUnit(pci, pcm, pdh->ptMaster.x,
                                          CM_OCD_XM_ABS, CM_OCD_XM_RELLEFT))
                VOut(pci, "*XMoveUnit: %d\r\n", dwMoveUnit);
            if (dwMoveUnit = DwCalcMoveUnit(pci, pcm, pdh->ptMaster.y,
                                          CM_OCD_YM_ABS, CM_OCD_YM_RELUP))
                VOut(pci, "*YMoveUnit: %d\r\n", dwMoveUnit);
        }
        //
        // dump commands in CURSORMOVE structure
        //
        if (BBuildCmdStr(pci, CMD_CM_XM_ABS, pcm->rgocd[CM_OCD_XM_ABS]))
            VOutputCmd(pci, "CmdXMoveAbsolute");
        if (BBuildCmdStr(pci, CMD_CM_XM_REL, pcm->rgocd[CM_OCD_XM_REL]))
            VOutputCmd(pci, "CmdXMoveRelRight");
        if (BBuildCmdStr(pci, CMD_CM_XM_RELLEFT, pcm->rgocd[CM_OCD_XM_RELLEFT]))
            VOutputCmd(pci, "CmdXMoveRelLeft");
        if ((pcm->fYMove & CM_YM_RES_DEPENDENT) &&
            (pcm->rgocd[CM_OCD_YM_ABS] != NOOCD ||
             pcm->rgocd[CM_OCD_YM_REL] != NOOCD ||
             pcm->rgocd[CM_OCD_YM_RELUP] != NOOCD ||
             pcm->rgocd[CM_OCD_YM_LINESPACING] != NOOCD))
        {
            pci->dwErrorCode |= ERR_CM_YM_RES_DEPENDENT;
            VOut(pci, "*%% Error: the above *YMoveUnit value is wrong. It should be dependent on the resolution. Correct it manually.\r\n");
            //
            // Create dependency on Resolution options by
            // looping through each option and feed the multiplication
            // factor (ptTextScale.y) for building the command string.
            //
            VOut(pci, "*switch: Resolution\r\n{\r\n");
            psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_RESOLUTION]);
            wCount = 1;
            while (*psIndex)
            {
                pci->pres = (PGPCRESOLUTION)GetTableInfo(pdh, HE_RESOLUTION,
                                                      *psIndex - 1);
                VOut(pci, "    *case: Option%d\r\n    {\r\n", wCount);
                if (BBuildCmdStr(pci, CMD_CM_YM_ABS, pcm->rgocd[CM_OCD_YM_ABS]))
                    VOutputCmd2(pci, "CmdYMoveAbsolute"),
                    eCmdsPresent |= Y_MOVE_ABS;
                if (BBuildCmdStr(pci, CMD_CM_YM_REL, pcm->rgocd[CM_OCD_YM_REL]))
                    VOutputCmd2(pci, "CmdYMoveRelDown"),
                    eCmdsPresent |= Y_MOVE_DOWN;
                if (BBuildCmdStr(pci, CMD_CM_YM_RELUP, pcm->rgocd[CM_OCD_YM_RELUP]))
                    VOutputCmd2(pci, "CmdYMoveRelUp"),
                    eCmdsPresent |= Y_MOVE_UP;
                if (BBuildCmdStr(pci, CMD_CM_YM_LINESPACING, pcm->rgocd[CM_OCD_YM_LINESPACING]))
                    VOutputCmd2(pci, "CmdSetLineSpacing");
                VOut(pci, "    }\r\n"); // close *case construct
                psIndex++;
                wCount++;
            }
            VOut(pci, "}\r\n"); // close *switch construct
        }
        else
        {
            if (BBuildCmdStr(pci, CMD_CM_YM_ABS, pcm->rgocd[CM_OCD_YM_ABS]))
                VOutputCmd(pci, "CmdYMoveAbsolute"),
                eCmdsPresent |= Y_MOVE_ABS;
            if (BBuildCmdStr(pci, CMD_CM_YM_REL, pcm->rgocd[CM_OCD_YM_REL]))
                VOutputCmd(pci, "CmdYMoveRelDown"),
                eCmdsPresent |= Y_MOVE_DOWN;
            if (BBuildCmdStr(pci, CMD_CM_YM_RELUP, pcm->rgocd[CM_OCD_YM_RELUP]))
                VOutputCmd(pci, "CmdYMoveRelUp"),
                eCmdsPresent |= Y_MOVE_UP;
            if (BBuildCmdStr(pci, CMD_CM_YM_LINESPACING, pcm->rgocd[CM_OCD_YM_LINESPACING]))
                VOutputCmd(pci, "CmdSetLineSpacing");
        }
        if (BBuildCmdStr(pci, CMD_CM_CR, pcm->rgocd[CM_OCD_CR]))
            VOutputCmd(pci, "CmdCR");
        if (BBuildCmdStr(pci, CMD_CM_LF, pcm->rgocd[CM_OCD_LF]))
            VOutputCmd(pci, "CmdLF");
        if (BBuildCmdStr(pci, CMD_CM_FF, pcm->rgocd[CM_OCD_FF]))
            VOutputCmd(pci, "CmdFF");
        if (BBuildCmdStr(pci, CMD_CM_BS, pcm->rgocd[CM_OCD_BS]))
            VOutputCmd(pci, "CmdBackSpace");
        if (BBuildCmdStr(pci, CMD_CM_UNI_DIR, pcm->rgocd[CM_OCD_UNI_DIR]))
            VOutputCmd(pci, "CmdUniDirectionOn");
        if (BBuildCmdStr(pci, CMD_CM_UNI_DIR_OFF, pcm->rgocd[CM_OCD_UNI_DIR_OFF]))
            VOutputCmd(pci, "CmdUniDirectionOff");
        if (BBuildCmdStr(pci, CMD_CM_PUSH_POS, pcm->rgocd[CM_OCD_PUSH_POS]))
            VOutputCmd(pci, "CmdPushCursor");
        if (BBuildCmdStr(pci, CMD_CM_POP_POS, pcm->rgocd[CM_OCD_POP_POS]))
            VOutputCmd(pci, "CmdPopCursor");

        if(!(eCmdsPresent & Y_MOVE_ABS)  &&
            ((eCmdsPresent & eRelativeYCmds) != eRelativeYCmds))
        VOut(pci, "*%% Error: no Abs or Rel YMoveCommands found. Correct it manually.\r\n");
    }
    if ((pci->pmd->fText & TC_CR_90) &&
        BBuildCmdStr(pci, CMD_PC_PRINT_DIR, pci->ppc->rgocd[PC_OCD_PRN_DIRECTION]))
        VOutputCmd(pci, "CmdSetSimpleRotation");
    //
    // In GPC, information regarding *EjectPageWithFF is spread out
    // among PAPERSIZE and PAPERSOURCE structures. For almost all
    // printers, the real dependency is not so pervasive. For example,
    // on dot-matrix printers, only PAPERSOURCE really uses this bit.
    // On most page printers, FF is always used to eject page.
    // We check for the reality and generate *switch/*case constructs
    // only when really needed.
    //
    {
        DWORD   i;
        BOOL    bSizeSame, bSrcSame; // whether all options same

        bSizeSame = TRUE;
        for (i = 1; bSizeSame && i < pci->dwNumOfSize; i++)
            bSizeSame = bSizeSame &&
                        (pci->ppiSize[i].bEjectFF == pci->ppiSize[0].bEjectFF);
        bSrcSame = TRUE;
        for (i = 1; bSrcSame && i < pci->dwNumOfSrc; i++)
            bSrcSame = bSrcSame &&
                       (pci->ppiSrc[i].bEjectFF == pci->ppiSrc[0].bEjectFF);

        if ((bSizeSame && pci->ppiSize[0].bEjectFF) ||
            (bSrcSame && pci->ppiSrc[0].bEjectFF) )
            VOut(pci, "*EjectPageWithFF?: TRUE\r\n");
        else if ((bSizeSame && !pci->ppiSize[0].bEjectFF) &&
                 (bSrcSame && !pci->ppiSrc[0].bEjectFF))
            VOut(pci, "*EjectPageWithFF?: FALSE\r\n");
        else if (bSizeSame && !pci->ppiSize[0].bEjectFF)
            VCreateEjectFFDependency(pci, FF_INPUTBIN, FALSE);
        else if (bSrcSame && !pci->ppiSize[0].bEjectFF)
            VCreateEjectFFDependency(pci, FF_PAPERSIZE, FALSE);
        else
            //
            // Have dependency on both PaperSize and InputBin.
            // Is this any sensible reason for this case? Assume not
            // for now until we find a minidriver that does.
            //
            VCreateEjectFFDependency(pci, FF_BOTH, FALSE);
    }
    //
    // Color attributes and commands are output in ColorMode options.
    //
    //

    // Raster Printing
    // Source: MD_OI_COMPRESSION, GPCRESOLUTION (RES_DM_GDI, RES_DM_LEFT_BOUND)
    // GPCRESOLUTION.fBlockOut, GPCRESOLUTION.fCursor (all flags),
    //
    // Rater Printing --- Raster Data Compression
    //
    {
        PCOMPRESSMODE pcmode;
        BOOL bDisableCmdDone = FALSE;

        psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_COMPRESSION]);
        while (*psIndex != 0)
        {
            pcmode = (PCOMPRESSMODE)GetTableInfo(pdh, HE_COMPRESSION, *psIndex - 1);
            if (pcmode->iMode == CMP_ID_TIFF40 &&
                BBuildCmdStr(pci, CMD_CMP_TIFF, pcmode->rgocd[CMP_OCD_BEGIN]))
                VOutputCmd(pci, "CmdEnableTIFF4");
            else if (pcmode->iMode == CMP_ID_DELTAROW &&
                BBuildCmdStr(pci, CMD_CMP_DELTAROW, pcmode->rgocd[CMP_OCD_BEGIN]))
                VOutputCmd(pci, "CmdEnableDRC");
            else if (pcmode->iMode == CMP_ID_FE_RLE &&
                BBuildCmdStr(pci, CMD_CMP_FE_RLE, pcmode->rgocd[CMP_OCD_BEGIN]))
                VOutputCmd(pci, "CmdEnableFE_RLE");

            if (!bDisableCmdDone &&
                BBuildCmdStr(pci, CMD_CMP_NONE, pcmode->rgocd[CMP_OCD_END]))
            {
                VOutputCmd(pci, "CmdDisableCompression");
                bDisableCmdDone = TRUE;
            }
            psIndex++;
        }
    }

    //
    // Raster Printing --- Raster Data Emission
    //
    if (pres)
    {
        VOut(pci, "*OutputDataFormat: %s\r\n",
             (pres->fDump & RES_DM_GDI) ? "H_BYTE" : "V_BYTE");
        VOut(pci, "*OptimizeLeftBound?: %s\r\n",
             (pres->fDump & RES_DM_LEFT_BOUND) ? "TRUE" : "FALSE");

        VOut(pci, "*CursorXAfterSendBlockData: %s\r\n",
             (pres->fCursor & RES_CUR_X_POS_ORG)? "AT_GRXDATA_ORIGIN" :
             ((pres->fCursor & RES_CUR_X_POS_AT_0)? "AT_CURSOR_X_ORIGIN" :
                "AT_GRXDATA_END"));
        VOut(pci, "*CursorYAfterSendBlockData: %s\r\n",
             (pres->fCursor & RES_CUR_Y_POS_AUTO)? "AUTO_INCREMENT" : "NO_MOVE");

    }
    if (pmd->fGeneral & MD_NO_ADJACENT)
        pci->dwErrorCode |= ERR_MD_NO_ADJACENT;

    //
    // Device Fonts.
    // Source: MODELDATA, MD_OI_PORT_FONTS and MD_OI_LAND_FONTS.
    //
    if (pmd->sLookAhead > 0)
        VOut(pci, "*LookAheadRegion: %d\r\n", pmd->sLookAhead);

#if defined(DEVSTUDIO)  //  Must map this ID to account for multi PFM-> UFM
    vMapFontList(&pmd->sDefaultFontID, 1, pci);
#endif

    if (pmd->sDefaultFontID > 0)
        VOut(pci, "*DefaultFont: %d\r\n", pmd->sDefaultFontID);
    if (pmd->sDefaultCTT >= 0)
        VOut(pci, "*DefaultCTT: %d\r\n", pmd->sDefaultCTT);
    else
        VOut(pci, "*DefaultCTT: -%d\r\n", -pmd->sDefaultCTT);

    if (pmd->sMaxFontsPage > 0)
        VOut(pci, "*MaxFontUsePerPage: %d\r\n", pmd->sMaxFontsPage);
    if (pmd->fGeneral & MD_ALIGN_BASELINE)
        VOut(pci, "*CharPosition: BASELINE\r\n");
    {
        PWORD pwPFonts, pwLFonts;

        pwPFonts = (PWORD)((PBYTE)pdh + pdh->loHeap + pmd->rgoi[MD_OI_PORT_FONTS]);
        pwLFonts = (PWORD)((PBYTE)pdh + pdh->loHeap + pmd->rgoi[MD_OI_LAND_FONTS]);

        if (*pwPFonts || *pwLFonts)
        {
            if (pmd->fGeneral & MD_ROTATE_FONT_ABLE)
            {
                VOut(pci, "*DeviceFonts: ");
                VOutputFontList(pci, pwPFonts, pwLFonts);
            }
            else
            {
                VOut(pci, "*switch: Orientation\r\n{\r\n");
                VOut(pci, "    *case: PORTRAIT\r\n    {\r\n");
                VOut(pci, "        *DeviceFonts: ");
                VOutputFontList(pci, pwPFonts, NULL);
                VOut(pci, "    }\r\n");

                if (pmd->fGeneral & MD_LANDSCAPE_RT90)
                    VOut(pci, "    *case: LANDSCAPE_CC90\r\n    {\r\n");
                else
                    VOut(pci, "    *case: LANDSCAPE_CC270\r\n    {\r\n");
                VOut(pci, "        *DeviceFonts: ");
                VOutputFontList(pci, NULL, pwLFonts);
                VOut(pci, "    }\r\n}\r\n");
            }
        }
    }
    //
    // Built-in Font Cartridges.
    // Source: MD_OI_FONTCART
    //
    {
        PGPCFONTCART pfc;

        psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_FONTCART]);
        wCount = 1;
        while (*psIndex != 0)
        {
            pfc = (PGPCFONTCART)GetTableInfo(pdh, HE_FONTCART, *psIndex - 1);
            VOut(pci, "*FontCartridge: FC%d\r\n{\r\n", wCount);
            VOut(pci, "    *rcCartridgeNameID: %d\r\n", pfc->sCartNameID);
            if (pmd->fGeneral & MD_ROTATE_FONT_ABLE)
            {
                VOut(pci, "    *Fonts: ");
                VOutputFontList(pci,
                    (PWORD)((PBYTE)pdh + pdh->loHeap + pfc->orgwPFM[FC_ORGW_PORT]),
                    (PWORD)((PBYTE)pdh + pdh->loHeap + pfc->orgwPFM[FC_ORGW_LAND]));
            }
            else
            {
                VOut(pci, "    *PortraitFonts: ");
                VOutputFontList(pci,
                    (PWORD)((PBYTE)pdh + pdh->loHeap + pfc->orgwPFM[FC_ORGW_PORT]),
                    NULL);
                VOut(pci, "    *LandscapeFonts: ");
                VOutputFontList(pci,
                    NULL,
                    (PWORD)((PBYTE)pdh + pdh->loHeap + pfc->orgwPFM[FC_ORGW_LAND]));
            }
            VOut(pci, "}\r\n"); // close *FontCartridge
            psIndex++;
            wCount++;
        }
    }

    //
    // Font Downloading
    // Source: MODELDATA, DOWNLOADINFO.
    //
    if (pmd->rgi[MD_I_DOWNLOADINFO] != NOT_USED)
    {
        PDOWNLOADINFO pdi;

        pdi = (PDOWNLOADINFO)GetTableInfo(pdh, HE_DOWNLOADINFO,
                                               pmd->rgi[MD_I_DOWNLOADINFO]);
        VOut(pci, "*MinFontID: %d\r\n*MaxFontID: %d\r\n", pdi->wIDMin, pdi->wIDMax);
        if (pdi->sMaxFontCount != -1)
            VOut(pci, "*MaxNumDownFonts: %d\r\n", pdi->sMaxFontCount);
        if (pdi->rgocd[DLI_OCD_SET_SECOND_FONT_ID] != NOOCD ||
            pdi->rgocd[DLI_OCD_SELECT_SECOND_FONT_ID] != NOOCD)
            pci->dwErrorCode |= ERR_HAS_SECOND_FONT_ID_CMDS;
        if (pdi->fFormat & DLI_FMT_CAPSL)
            pci->dwErrorCode |= ERR_DLI_FMT_CAPSL;
        if (pdi->fFormat & DLI_FMT_PPDS)
            pci->dwErrorCode |= ERR_DLI_FMT_PPDS;
        if (pdi->fGeneral & DLI_GEN_DLPAGE)
            pci->dwErrorCode |= ERR_DLI_GEN_DLPAGE;
        if (pdi->fGeneral & DLI_GEN_7BIT_CHARSET)
            pci->dwErrorCode |= ERR_DLI_GEN_7BIT_CHARSET;

#if 0
    // delete this entry --- assume always TRUE since the driver
    // doesn't even have code to handle non-incremental case.

        VOut(pci, "*IncrementalDownload?: %s\r\n",
                (pdi->fFormat & DLI_FMT_INCREMENT)? "TRUE" : "FALSE");
#endif
        if (pdi->fFormat & DLI_FMT_CALLBACK)
            VOut(pci, "*FontFormat: OEM_CALLBACK\r\n");
        else
        {
            if (pdi->fFormat & DLI_FMT_OUTLINE)
            {
                //
                // check for potential Resolution dependency
                //
                if ((pci->dwMode & FM_RES_DM_DOWNLOAD_OUTLINE) &&
                    (pci->dwMode & FM_NO_RES_DM_DOWNLOAD_OUTLINE))
                {
                    VOut(pci, "*switch: Resolution\r\n{\r\n");
                    psIndex = DHOFFSET(pdh, pmd->rgoi[MD_OI_RESOLUTION]);
                    wCount = 1;
                    while (*psIndex)
                    {
                        pres = (PGPCRESOLUTION)GetTableInfo(pdh, HE_RESOLUTION,
                                                              *psIndex - 1);
                        VOut(pci, "    *case: Option%d\r\n    {\r\n", wCount);
                        VOut(pci, "        *FontFormat: %s\r\n",
                                (pres->fDump & RES_DM_DOWNLOAD_OUTLINE) ?
                                    "HPPCL_OUTLINE" : "HPPCL_RES");
                        VOut(pci, "    }\r\n"); // close *case construct
                        psIndex++;
                        wCount++;
                    }
                    VOut(pci, "}\r\n");
                }
                else if (pci->dwMode & FM_RES_DM_DOWNLOAD_OUTLINE)
                    VOut(pci, "*FontFormat: HPPCL_OUTLINE\r\n");
                else
                    //
                    // assume all HPPCL_OUTLINE capable printers support
                    // resolution specific bitmap download format.
                    //
                    VOut(pci, "*FontFormat: HPPCL_RES\r\n");
            }
            else if (pdi->fFormat & DLI_FMT_RES_SPECIFIED)
                VOut(pci, "*FontFormat: HPPCL_RES\r\n");
            else if (pdi->fFormat & DLI_FMT_PCL)
                VOut(pci, "*FontFormat: HPPCL\r\n");
        }


        if (BBuildCmdStr(pci, CMD_SET_FONT_ID, pdi->rgocd[DLI_OCD_SET_FONT_ID]))
            VOutputCmd(pci, "CmdSetFontID");
        if (BBuildCmdStr(pci, CMD_SELECT_FONT_ID, pdi->rgocd[DLI_OCD_SELECT_FONT_ID]))
            VOutputCmd(pci, "CmdSelectFontID");
        if (BBuildCmdStr(pci, CMD_SET_CHAR_CODE, pdi->rgocd[DLI_OCD_SET_CHAR_CODE]))
            VOutputCmd(pci, "CmdSetCharCode");

    }

    //
    // Font Simulation
    // Source: FONTSIMULATION.
    //
    if (pmd->rgi[MD_I_FONTSIM] != NOT_USED)
    {
        PFONTSIMULATION pfs;

        pfs = (PFONTSIMULATION)GetTableInfo(pdh, HE_FONTSIM, pmd->rgi[MD_I_FONTSIM]);
        if (pmd->fText & TC_EA_DOUBLE)
        {
            if (BBuildCmdStr(pci, CMD_FS_BOLD_ON, pfs->rgocd[FS_OCD_BOLD_ON]))
                VOutputCmd(pci, "CmdBoldOn");
            if (BBuildCmdStr(pci, CMD_FS_BOLD_OFF, pfs->rgocd[FS_OCD_BOLD_OFF]))
                VOutputCmd(pci, "CmdBoldOff");
        }
        if (pmd->fText & TC_IA_ABLE)
        {
            if (BBuildCmdStr(pci, CMD_FS_ITALIC_ON, pfs->rgocd[FS_OCD_ITALIC_ON]))
                VOutputCmd(pci, "CmdItalicOn");
            if (BBuildCmdStr(pci, CMD_FS_ITALIC_OFF, pfs->rgocd[FS_OCD_ITALIC_OFF]))
                VOutputCmd(pci, "CmdItalicOff");
        }
        if (pmd->fText & TC_UA_ABLE)
        {
            if (BBuildCmdStr(pci, CMD_FS_UNDERLINE_ON, pfs->rgocd[FS_OCD_UNDERLINE_ON]))
                VOutputCmd(pci, "CmdUnderlineOn");
            if (BBuildCmdStr(pci, CMD_FS_UNDERLINE_OFF, pfs->rgocd[FS_OCD_UNDERLINE_OFF]))
                VOutputCmd(pci, "CmdUnderlineOff");
        }
        if (pmd->fText & TC_SO_ABLE)
        {
            if (BBuildCmdStr(pci, CMD_FS_STRIKETHRU_ON, pfs->rgocd[FS_OCD_STRIKETHRU_ON]))
                VOutputCmd(pci, "CmdStrikeThruOn");
            if (BBuildCmdStr(pci, CMD_FS_STRIKETHRU_OFF, pfs->rgocd[FS_OCD_STRIKETHRU_OFF]))
                VOutputCmd(pci, "CmdStrikeThruOff");
        }
        if (pmd->fGeneral & MD_WHITE_TEXT)
        {
            if (BBuildCmdStr(pci, CMD_FS_WHITE_TEXT_ON, pfs->rgocd[FS_OCD_WHITE_TEXT_ON]))
                VOutputCmd(pci, "CmdWhiteTextOn");
            if (BBuildCmdStr(pci, CMD_FS_WHITE_TEXT_OFF, pfs->rgocd[FS_OCD_WHITE_TEXT_OFF]))
                VOutputCmd(pci, "CmdWhiteTextOff");
        }
        if (pfs->rgocd[FS_OCD_SINGLE_BYTE] != NOOCD &&
            pfs->rgocd[FS_OCD_DOUBLE_BYTE] != NOOCD)
        {
            if (BBuildCmdStr(pci, CMD_FS_SINGLE_BYTE, pfs->rgocd[FS_OCD_SINGLE_BYTE]))
                VOutputCmd(pci, "CmdSelectSingleByteMode");
            if (BBuildCmdStr(pci, CMD_FS_DOUBLE_BYTE, pfs->rgocd[FS_OCD_DOUBLE_BYTE]))
                VOutputCmd(pci, "CmdSelectDoubleByteMode");
        }
        if (pfs->rgocd[FS_OCD_VERT_ON] != NOOCD &&
            pfs->rgocd[FS_OCD_VERT_OFF] != NOOCD)
        {
            if (BBuildCmdStr(pci, CMD_FS_VERT_ON, pfs->rgocd[FS_OCD_VERT_ON]))
                VOutputCmd(pci, "CmdVerticalPrintingOn");
            if (BBuildCmdStr(pci, CMD_FS_VERT_OFF, pfs->rgocd[FS_OCD_VERT_OFF]))
                VOutputCmd(pci, "CmdVerticalPrintingOff");
        }
    }

    //
    // Rectangle Area Fill entries
    //
    if (pmd->rgi[MD_I_RECTFILL] != NOT_USED)
    {
        PRECTFILL prf;

        prf = (PRECTFILL)GetTableInfo(pdh, HE_RECTFILL, pmd->rgi[MD_I_RECTFILL]);

        if (prf->fGeneral & RF_MIN_IS_WHITE)
            pci->dwErrorCode |= ERR_RF_MIN_IS_WHITE;

        if (prf->fGeneral & RF_CUR_X_END)
            VOut(pci, "*CursorXAfterRectFill: AT_RECT_X_END\r\n");
        if (prf->fGeneral & RF_CUR_Y_END)
            VOut(pci, "*CursorYAfterRectFill: AT_RECT_Y_END\r\n");

        VOut(pci, "*MinGrayFill: %d\r\n", prf->wMinGray);
        VOut(pci, "*MaxGrayFill: %d\r\n", prf->wMaxGray);

        if (BBuildCmdStr(pci, CMD_RF_X_SIZE, prf->rgocd[RF_OCD_X_SIZE]))
            VOutputCmd(pci, "CmdSetRectWidth");
        if (BBuildCmdStr(pci, CMD_RF_Y_SIZE, prf->rgocd[RF_OCD_Y_SIZE]))
            VOutputCmd(pci, "CmdSetRectHeight");
        if (BBuildCmdStr(pci, CMD_RF_GRAY_FILL, prf->rgocd[RF_OCD_GRAY_FILL]))
            VOutputCmd(pci, "CmdRectGrayFill");
        if (BBuildCmdStr(pci, CMD_RF_WHITE_FILL, prf->rgocd[RF_OCD_WHITE_FILL]))
            VOutputCmd(pci, "CmdRectWhiteFill");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\lib\makefile.inc ===
#
#

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

cttconv.c: $(PRNROOT)\tools\uni\ctt2gtt\cttconv.c
    copy $(PRNROOT)\tools\uni\ctt2gtt\cttconv.c

pfmconv.c: $(PRNROOT)\tools\uni\pfm2ufm\pfmconv.c
    copy $(PRNROOT)\tools\uni\pfm2ufm\pfmconv.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\gpdchkr\gpdcheck.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    gpdcheck.c

Abstract:

    gpd parser test program

Environment:

    uni driver, gpd parser, Check build only

Revision History:


    03/27/97 -peterwo-
        Created it.

--*/

#include "lib.h"


PTSTR  pwstrGenerateGPDfilename(
    PTSTR   ptstrSrcFilename
    ) ;

BOOL   BcreateGPDbinary(
    PWSTR   pwstrFileName,  // root GPD file
    DWORD   dwVerbosity );


// ----  functions defined in treewalk.c ---- //
BOOL    GetGPDResourceIDs(
PDWORD pdwResArray,
DWORD   dwArraySize,    //  number of elements in array.
PDWORD   pdwNeeded,
BOOL bFontIDs,
PRAWBINARYDATA prbd) ;



#ifndef DBG

//
// Variable to control the amount of debug messages generated
//

INT giDebugLevel = DBG_WARNING;

PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}



#endif


HINSTANCE       ghInstance;
PSTR            gstrProgName;
PINFOHEADER     gpInfoHdr;
PUIINFO         gpUIInfo;
DWORD           gdwTotalSize, gdwNumFiles, gdwMaxFileSize;
FILE            *stream ;


#define DumpInt(label, n)       DbgPrint("%s: %d\n", label, n)
#define DumpHex(label, n)       DbgPrint("%s: 0x%x\n", label, n)
#define DumpStrW(label, offset) DbgPrint("%s: %ws\n", label, OFFSET_TO_POINTER(gpRawData, offset))
#define DumpStrA(label, offset) DbgPrint("%s: %s\n", label, OFFSET_TO_POINTER(gpRawData, offset))
#define DumpFix(label, n)       DbgPrint("%s: %f\n", label, (FLOAT) (n) / FIX_24_8_SCALE)
#define DumpInvo(label, p)      DbgPrint("%s: %d bytes\n", label, (p)->dwCount)
#define DumpSize(label, p)      DbgPrint("%s: %d x %d\n", label, (p)->cx, (p)->cy)
#define DumpRect(label, p)      DbgPrint("%s: (%d, %d) - (%d, %d)\n", label, \
                                         (p)->left, (p)->top, (p)->right, (p)->bottom)





ULONG _cdecl
DbgPrint(
    PCSTR    pstrFormat,
    ...
    )

{
    va_list ap;

    va_start(ap, pstrFormat);
    vfprintf(stream, pstrFormat, ap);
    va_end(ap);

    return 0;
}



VOID
usage(
    VOID
    )

{
    printf("usage: %s [-options] filenames ...\n", gstrProgName);
    printf("where options are:\n");
    printf("  -n  delete existing log file, instead of appending to it\n");
    printf("  -k  keep the binary GPD data\n");
    printf("  -x  perform additional semantics check\n") ;
    printf("  -s  suppress all console output\n") ;
    printf("  -v(0-4)  set verbosity level -v0 lowest, -v4 highest\n") ;
    printf("  -h  display help information\n");
    exit(-1);
}


INT _cdecl
main(
    INT     argc,
    CHAR    **argv
    )

{
    BOOL    bDeleteLog, bKeepBUD, bFirstFile, bSuppress, bSemantics;
    DWORD   dwTime;
    DWORD   dwVerbosity = 0;

    //
    // Go through the command line arguments
    //

    ghInstance = GetModuleHandle(NULL);
    bSuppress = bDeleteLog = bKeepBUD = bSemantics = FALSE;
    bFirstFile = TRUE ;
    giDebugLevel = DBG_TERSE;
    gdwTotalSize = gdwNumFiles = gdwMaxFileSize = 0 ;

    gstrProgName = *argv++;
    argc--;

    if (argc == 0)
        usage();

    dwTime = GetTickCount();

    for ( ; argc--; argv++)
    {
        PSTR    pArg = *argv;

        if (*pArg == '-' || *pArg == '/')
        {
            //
            // The argument is an option flag
            //

            switch (*++pArg) {

            case 'n':
            case 'N':

                bDeleteLog  = TRUE;
                break;

            case 'k':
            case 'K':

                bKeepBUD = TRUE;
                break;

            case 's':
            case 'S':

                bSuppress = TRUE;
                break;


            case 'x':
            case 'X':

                bSemantics = TRUE;
                break;


            case 'v':
            case 'V':

                if (*++pArg >= '0' && *pArg <= '4')
                {
                    dwVerbosity = *pArg - '0';
                }
                break;
            default:

                if(!bSuppress)
                    usage();
                break;
            }

        }
        else
        {
            WCHAR   wstrFilename[MAX_PATH];
            PTSTR   ptstrBudFilename;


            if(bFirstFile  &&   bDeleteLog)
            {   // truncate
                stream = fopen("gpdparse.log", "w") ;
            }
            else
                stream = fopen("gpdparse.log", "a+") ;

            if(!stream)
            {
                printf("unable to open gpdparse.log for write access.\n");
                exit(-1);
            }

            bFirstFile = FALSE ;


            //
            // Convert ANSI filename to Unicode filename
            //

            MultiByteToWideChar(CP_ACP, 0, pArg, -1, wstrFilename, MAX_PATH);

            fprintf(stream, "\n*** GPD parsing errors for %ws\n", wstrFilename);


            if (BcreateGPDbinary(wstrFilename, dwVerbosity))
            {

//                gdwTotalSize += gpRawData->dwFileSize;
                gdwNumFiles++;

//                if (gpRawData->dwFileSize > gdwMaxFileSize)
//                    gdwMaxFileSize = gpRawData->dwFileSize;

//                MemFree(gpRawData);

                if(bSemantics)
                {
                    PRAWBINARYDATA  pRawData ;
                    PINFOHEADER     pInfoHdr ;

                    fprintf(stream, "\n\tsnapshot and semantics errors: \n");

                    pRawData = LoadRawBinaryData(wstrFilename) ;

#if 0
//  this part to test treewalk.c functions
{
    BOOL    bStatus  ;
    PDWORD pdwResArray = NULL;
    DWORD   dwArraySize = 0;    //  number of elements in array.
    DWORD   dwNeeded = 0;
    BOOL bFontIDs ;


    bStatus =    GetGPDResourceIDs(
                            pdwResArray,
                            dwArraySize,    //  number of elements in array.
                            &dwNeeded,
                            bFontIDs = TRUE,
                            pRawData) ;
    if(bStatus)
    {
        pdwResArray = (PDWORD) VirtualAlloc(
          NULL, // address of region to reserve or commit
          dwNeeded * sizeof(DWORD),     // size of region
          MEM_COMMIT,
                            // type of allocation
          PAGE_READWRITE   // type of access protection
        );

    }
    if(pdwResArray)
    {
        dwArraySize = dwNeeded ;
        bStatus =    GetGPDResourceIDs(
                                pdwResArray,
                                dwArraySize,    //  number of elements in array.
                                &dwNeeded,
                                bFontIDs = TRUE,
                                pRawData) ;
    }
     VirtualFree(
      pdwResArray,  // address of region of committed pages
      0,      // size of region
      MEM_RELEASE   // type of free operation
    );
     pdwResArray = NULL ;

     bStatus =    GetGPDResourceIDs(
                             pdwResArray,
                             dwArraySize,    //  number of elements in array.
                             &dwNeeded,
                             bFontIDs = FALSE,
                             pRawData) ;
     if(bStatus)
     {
         pdwResArray = (PDWORD) VirtualAlloc(
           NULL, // address of region to reserve or commit
           dwNeeded * sizeof(DWORD),     // size of region
           MEM_COMMIT,
                             // type of allocation
           PAGE_READWRITE   // type of access protection
         );

     }
     if(pdwResArray)
     {
         dwArraySize = dwNeeded ;
         bStatus =    GetGPDResourceIDs(
                                 pdwResArray,
                                 dwArraySize,    //  number of elements in array.
                                 &dwNeeded,
                                 bFontIDs = FALSE,
                                 pRawData) ;
     }
      VirtualFree(
       pdwResArray,  // address of region of committed pages
       0,      // size of region
       MEM_RELEASE   // type of free operation
     );
      pdwResArray = NULL ;

}


//  end treewalk test
#endif


                    if(pRawData)
                        pInfoHdr = InitBinaryData(pRawData, NULL, NULL ) ;
                    if(pRawData  &&  pInfoHdr)
                        FreeBinaryData(pInfoHdr) ;
                    if(pRawData)
                        UnloadRawBinaryData(pRawData) ;
                }

                //
                // If -k option is not given, get rid of the Bud file after we're done
                //

                if (! bKeepBUD && (ptstrBudFilename = pwstrGenerateGPDfilename(wstrFilename)))
                {
                    DeleteFile(ptstrBudFilename);
                    MemFree(ptstrBudFilename);
                }
            }
            fclose(stream) ;
        }
    }


    if ((gdwNumFiles > 0)  &&  !bSuppress)
    {
        dwTime = GetTickCount() - dwTime;

        printf("Number of files parsed: %d\n", gdwNumFiles);
        printf("Average parsing time per file (ms): %d\n", dwTime / gdwNumFiles);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\lib\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compile header for Unidrv tool library

Environment:

    Windows NT printer drivers

Revision History:

    12/30/96 -eigos-
        Created it.
--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <lib.h>
#include <unilib.h>
#include <winddi.h>
#include <win30def.h>
#include <uni16res.h>
#include <uni16gpc.h>
#include <fmoldrle.h>
#include <fmnewfm.h>
#include <fmnewgly.h>
#include <fmoldfm.h>
#include <fmlib.h>


#endif // !_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\addcdpt.cpp ===
/******************************************************************************

  Source File:  Add Code Points.CPP

  This implements the CAddCodePoints class, which manages a dialog that allows
  the user to add additional code points to a glyph set.

  Copyright (c) 1997 by Microsoft Corporation.  All rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "MiniDev.H"
#include    "addcdpt.h"
#include    "codepage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static CCodePageInformation* pccpi = NULL ;

/******************************************************************************

  CAddCodePoints::CAddCodePoints

  The class constructor primarily initializes the base class and reference
  members.

******************************************************************************/

CAddCodePoints::CAddCodePoints(CWnd* pParent, CMapWordToDWord& cmw2d,
                               CDWordArray& cda, CString csItemName)
	: CDialog(CAddCodePoints::IDD, pParent), m_cmw2dPoints(cmw2d),
    m_cdaPages(cda) {
    m_csItem = csItemName;

	// Allocate a CCodePageInformation class if needed.

	if (pccpi == NULL)
		pccpi = new CCodePageInformation ;

    for (int i= 0; i < m_cdaPages.GetSize(); i++)
        m_csaNames.Add(pccpi->Name(m_cdaPages[i]));
    m_pos = 0;
    m_uTimer = 0;
	//{{AFX_DATA_INIT(CAddCodePoints)
	//}}AFX_DATA_INIT
}

/******************************************************************************

  CAddCodePoints::DoDataExchange

  DDX override for the dialog- I'm not sure I need to keep this around.

******************************************************************************/

void CAddCodePoints::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddCodePoints)
	DDX_Control(pDX, IDC_Banner, m_cpcBanner);
	DDX_Control(pDX, IDC_GlyphList, m_clbList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAddCodePoints, CDialog)
	//{{AFX_MSG_MAP(CAddCodePoints)
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************

  CAddCodePoints::OnInitDialog

  This is the primary dialog intialization member.  It uses the passed
  information to customize the title, then kicks off a timer so the UI appears
  while the list box is filled.

******************************************************************************/

BOOL CAddCodePoints::OnInitDialog() {
	CDialog::OnInitDialog();

    GetWindowText(m_csHolder);
    SetWindowText(m_csHolder + m_csItem);
	
	m_uTimer = (unsigned)SetTimer(IDD, 10, NULL);

    if  (!m_uTimer) {   //  No timer- fall back to filling the box slowly
        CWaitCursor cwc;
        OnTimer(m_uTimer);
    }
	
	return TRUE;  // No need to change the default focus
}

/******************************************************************************

  CAddCodePoints::OnOK

  This is called when the OK button is pressed.  We check the selection state
  of each item in the list.  If it is not selected, we remove it from the map.

  Thus, we return a map with only the desired entries to the caller.

******************************************************************************/

void CAddCodePoints::OnOK() {

    CWaitCursor cwc;    //  This could get slow

    for (unsigned u = 0; u < (unsigned) m_clbList.GetCount(); u++)
        if  (!m_clbList.GetSel(u))
            m_cmw2dPoints.RemoveKey((WORD) m_clbList.GetItemData(u));

	CDialog::OnOK();
}

/******************************************************************************

  CAddCodePoints::OnInitDialog

  This is invoked after the timer expires.  It uses the passed information to
  fill the code point list.

******************************************************************************/

void CAddCodePoints::OnTimer(UINT nIDEvent) {

    if  (nIDEvent != m_uTimer)	{
	    CDialog::OnTimer(nIDEvent);
        return;
    }
	
	WORD        wKey;
    DWORD       dwIndex;
    CString     csWork;

    if  (m_uTimer)
        ::KillTimer(m_hWnd, m_uTimer);

    if  (!m_pos) {
        m_cpcBanner.SetRange(0, (int)m_cmw2dPoints.GetCount() - 1);
        m_cpcBanner.SetStep(1);
        m_cpcBanner.SetPos(0);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        if  (m_uTimer)
            m_clbList.EnableWindow(FALSE);
        else {
            m_clbList.LockWindowUpdate();
            m_clbList.ResetContent();
        }

        m_pos = m_cmw2dPoints.GetStartPosition();
    }

    //  Put in just 100 items, unless the timer is off

    for (unsigned u = 0; m_pos && (!m_uTimer || u < 100); u++) {
        m_cmw2dPoints.GetNextAssoc(m_pos, wKey, dwIndex);

        csWork.Format(_TEXT("%4.4X: "), wKey);
        csWork += m_csaNames[dwIndex];

        int id = m_clbList.AddString(csWork);
        m_clbList.SetItemData(id, wKey);
    }

    if  (!m_pos) {
        if  (m_uTimer)
            m_clbList.EnableWindow(TRUE);
        else
            m_clbList.UnlockWindowUpdate();
        m_uTimer = 0;
        m_cpcBanner.SetPos(0);
        m_cpcBanner.ShowWindow(SW_HIDE);
        SetFocus();
    }

    if  (m_uTimer) {
        m_cpcBanner.OffsetPos(u);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        m_uTimer = (unsigned)SetTimer(IDD, 10, NULL);
        if  (!m_uTimer) {
            CWaitCursor cwc;    //  Might be a while...
            m_clbList.EnableWindow(TRUE);
            m_clbList.LockWindowUpdate();
            OnTimer(m_uTimer);
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\addcdpt.h ===
/******************************************************************************

  Header File:  Add Code Points.H

  This defines the CAddCodePoints class, which uses passed lists to present a 
  list of code points and their associated code pages for selection.  This
  class should be usable for both the glyph map and font structure editors.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "Utility.H"

class CAddCodePoints : public CDialog {

    CMapWordToDWord&    m_cmw2dPoints;
    CDWordArray&        m_cdaPages;
    CString             m_csItem;   //  Name of the item being edited
    CStringArray        m_csaNames; //  Names of the pages.
    unsigned            m_uTimer;   //  Timer ID
    POSITION            m_pos;      //  Position in input list
    CString             m_csHolder;
// Construction
public:
	CAddCodePoints(CWnd* pParent, CMapWordToDWord& cmw2d, CDWordArray& cda,
                   CString csItemName);

// Dialog Data
	//{{AFX_DATA(CAddCodePoints)
	enum { IDD = IDD_AddCodePoints };
	CProgressCtrl	m_cpcBanner;
	CListBox	m_clbList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddCodePoints)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddCodePoints)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\addcpt.h ===
/******************************************************************************

  Header File:  Add Code Points.H

  This defines the CAddCodePoints class, which uses passed lists to present a 
  list of code points and their associated code pages for selection.  This
  class should be usable for both the glyph map and font structure editors.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if defined(LONG_NAMES)
#include    <Utility Classes.H>
#else
#include    <Utility.H>
#endif

class CAddCodePoints : public CDialog {

    CMapWordToDWord&    m_cmw2dPoints;
    CDWordArray&        m_cdaPages;
    CString             m_csItem;   //  Name of the item being edited
// Construction
public:
	CAddCodePoints(CWnd* pParent, CMapWordToDWord& cmw2d, CDWordArray& cda,
                   CString csItemName);

// Dialog Data
	//{{AFX_DATA(CAddCodePoints)
	enum { IDD = IDD_AddCodePoints };
	CListBox	m_clbList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddCodePoints)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddCodePoints)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\codepage.h ===
/******************************************************************************

  Header File:  Code Page Knowledge Base.H

  This encapsulates a C++ class that will provide
  all of the basic information needed to manage and translate code pages for the 
  Minidriver Development Tool.

  Copyright (c) 1997 by Microsoft Corporation

******************************************************************************/

#ifndef	RICKS_FIND
#define	RICKS_FIND

class CCodePageInformation {
    DWORD   m_dwidMapped, m_dwidIn, m_dwidOut;  //  CP cached in each array
    CByteArray  m_cbaMap;                       //  Raw Map
    CWordArray  m_cwaIn, m_cwaOut;              //  Full MB2Uni and Uni2MB maps

    BOOL    Load(DWORD dwidMap);                //  Load the support page
    BOOL    Map(BOOL bUnicode);                 //  Map the requested direction
    BOOL    GenerateMap(DWORD dwidMap) const;   //  Create resource for RC file
                                                //  based on this code page

public:

    CCodePageInformation();

    //  Attributes

    const unsigned  InstalledCount() const;     //  Code pages in )S
    const unsigned  MappedCount() const;        //  Code pages in RC file
    const unsigned  SupportedCount() const;     //  Code pages supported by OS

    const DWORD     Installed(unsigned u) const;    //  Retrieve one
    const DWORD     Mapped(unsigned u) const;       //  Retrieve one
    void            Mapped(CDWordArray& cdwaReturn) const;  //  The IDs
    const DWORD     Supported(unsigned u) const;    //  Retrieve one

    CString         Name(DWORD dw) const;           //  Name of the code page
                                                    //  cf RC file
    BOOL            IsInstalled(DWORD dwPage) const;
    BOOL            HaveMap(DWORD dwPage) const;

    //  DBCS query- is page DBCS?  if so is this code point DBCS?

    BOOL            IsDBCS(DWORD dwidPage);
    BOOL            IsDBCS(DWORD dwidPage, WORD wCodePoint); 

    //  Operations
    unsigned        Convert(CByteArray& cbaMBCS, CWordArray& cbaWC, 
                            DWORD dwidPage);

    BOOL            GenerateAllMaps() const;        //  Gen resources for any 
                                                    //  installed & unsupported
    BOOL            Collect(DWORD dwidMap, CWordArray& cwaWhere, 
                            BOOL bUnicode = TRUE);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\childfrm.cpp ===
/******************************************************************************

  Source File:  Child Frame.CPP

  This implements the class for MDI child windows' frames in this application.
  Our primary change is that in most cases, the frame window is not sizable,
  since we use property sheets so extensively.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#if defined(LONG_NAMES)
#include    "MiniDriver Developer Studio.H"

#include    "Child Frame.H"
#else
#include    "MiniDev.H"
#include    "ChildFrm.H"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame() {
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame() {
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs) {
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
						     
	cs.style = WS_CHILD | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU
		| FWS_ADDTOTITLE ;//| WS_MINIMIZEBOX;	// Raid 8350

	
	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const {
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const {
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

/******************************************************************************

  CToolTipPage class implementation

  Derive from this class rather than CPropertyPage if you wish to use to use
  tool tips on your property page.

******************************************************************************/

CToolTipPage::CToolTipPage(int id) : CPropertyPage(id) {
	//{{AFX_DATA_INIT(CToolTipPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_uHelpID = 0 ;
}

CToolTipPage::~CToolTipPage() {
}

void CToolTipPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CToolTipPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CToolTipPage, CPropertyPage)
	//{{AFX_MSG_MAP(CToolTipPage)
	//}}AFX_MSG_MAP
    ON_NOTIFY(TTN_NEEDTEXT, 0, OnNeedText)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolTipPage message handlers

/******************************************************************************

  CToolTipPage::OnInitDialog

  This message handler is simple- it simply uses CWnd::EnableToolTips to turn
  on tool tips for this page.

******************************************************************************/

BOOL CToolTipPage::OnInitDialog() {
	CPropertyPage::OnInitDialog();
	
	EnableToolTips(TRUE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/******************************************************************************

  CToolTipPage::OnNeedText

  This handles the tool tip notification message that tip text is needed.  This
  notification is handled by using the control's ID as the key to the string 
  table.

******************************************************************************/

void    CToolTipPage::OnNeedText(LPNMHDR pnmh, LRESULT *plr) {
    TOOLTIPTEXT *pttt = (TOOLTIPTEXT *) pnmh;

    long    lid = ((long) (pttt -> uFlags & TTF_IDISHWND)) ? 
        (long)GetWindowLong((HWND) pnmh -> idFrom, GWL_ID) : (long)pnmh -> idFrom;

    m_csTip.LoadString(lid);
    m_csTip.TrimLeft();
    m_csTip.TrimRight();
    if  (m_csTip.IsEmpty())
        m_csTip.Format("Window ID is %X", lid);
    pttt -> lpszText = const_cast <LPTSTR> ((LPCTSTR) m_csTip);
}


/******************************************************************************

  CToolTipPage::PreTranslateMessage

  Looks for and process the context sensistive help key (F1) if it is found AND
  the class that uses CToolTipPage as a base class has set the help ID.

******************************************************************************/

BOOL CToolTipPage::PreTranslateMessage(MSG* pMsg) 
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1 && m_uHelpID != 0) {
		AfxGetApp()->WinHelp(m_uHelpID) ;
		return TRUE ;
	} ;
	
	return CPropertyPage::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\codepage.cpp ===
/******************************************************************************

  Source File:  Code Page Knowledge Base.CPP

  This implements the code page knowledge base.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-22-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
//#include    <AfxDllx.h>
#include    "Resource.H"
#if defined(LONG_NAMES)
#include    "Code Page Knowledge Base.H"
#else
#include    "CodePage.H"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***	Commented out because this code is no longer in a DLL.

static AFX_EXTENSION_MODULE CodePageKnowledgeBaseDLL = { NULL, NULL };
static HINSTANCE hi;

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
	if (dwReason == DLL_PROCESS_ATTACH) {
        hi = hInstance;
		TRACE0("Code Page Knowledge Base.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(CodePageKnowledgeBaseDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(CodePageKnowledgeBaseDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH) 	{
		TRACE0("Code Page Knowledge Base.DLL Terminating!\n");
	}
	return 1;   // ok
}
*/


static CDWordArray      cdaInstalled, cdaSupported, cdaMapped;

static BOOL CALLBACK    EnumProc(LPTSTR lpstrName) {
    cdaSupported.Add(atoi(lpstrName));
    return  TRUE;
}

/******************************************************************************

  CCodePageInformation::Load

  This loads the selected code page into the cache, if it isn't already there.

******************************************************************************/

BOOL    CCodePageInformation::Load(DWORD dwidPage) {

    if  (dwidPage == m_dwidMapped)
        return  TRUE;   //  Already done!

    if  (dwidPage > 65535)  //  We map words for code pages in civilized lands
        return  FALSE;

    HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE((WORD) dwidPage),
        MAKEINTRESOURCE(MAPPING_TABLE));
// raid 43537 
    if (!hrsrc)
		return FALSE;


    HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);

    if  (!hgMap)
        return  FALSE;  //  This should never happen!

    LPVOID lpv = LockResource(hgMap);

    if  (!lpv)
        return  FALSE;

    try {
        m_cbaMap.RemoveAll();
        m_cbaMap.SetSize(SizeofResource(AfxGetResourceHandle(), hrsrc));
        memcpy(m_cbaMap.GetData(), lpv, (size_t)m_cbaMap.GetSize());
    }

    catch   (CException * pce) {
        m_dwidMapped = 0;
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    m_dwidMapped = dwidPage;
    return  TRUE;
}

/******************************************************************************

  CCodePageInformation::Map

  This creates either the in or out of unicode translation table, as requested,
  using the loaded map.

******************************************************************************/

BOOL    CCodePageInformation::Map(BOOL bUnicode) {

    if  (!m_dwidMapped)
        return  FALSE;

    DWORD&  dwid = bUnicode ? m_dwidOut : m_dwidIn;

    if  (m_dwidMapped == dwid)
        return  TRUE;

    struct MB2WCMap {
        WORD    m_wMBCS;
        WORD    m_wWC;
    }   *psMap = (MB2WCMap *) m_cbaMap.GetData();

    if  (!psMap)
        return  0;

    DWORD   dwcEntries = (DWORD)m_cbaMap.GetSize() / sizeof *psMap;
    CWordArray&  cwaMap = bUnicode ? m_cwaOut : m_cwaIn;

    try {

        cwaMap.RemoveAll();
        cwaMap.InsertAt(0, 0xFFFF, 65536);  //  This is always an invalid value

        while   (dwcEntries--)
            if  (bUnicode)
                cwaMap[psMap[dwcEntries].m_wWC] = psMap[dwcEntries].m_wMBCS;
            else
                cwaMap[psMap[dwcEntries].m_wMBCS] = psMap[dwcEntries].m_wWC;
    }

    catch   (CException * pce) {
        dwid = 0;
        cwaMap.RemoveAll();
        pce -> ReportError();
        pce -> Delete();
        return  0;
    }

    dwid = m_dwidMapped;
    return  TRUE;
}

/******************************************************************************

  CCodePageInformation constructor

  If the statistics haven't been initialized, do it now.  Otherwise, this is
  trivial.

******************************************************************************/

CCodePageInformation::CCodePageInformation() {
    m_dwidMapped = m_dwidIn = m_dwidOut = 0;
    //  Initialize the statics if we need to.

    if  (cdaInstalled.GetSize())
        return;

    EnumSystemCodePages(&EnumProc, CP_INSTALLED);
    cdaInstalled.Copy(cdaSupported);
    cdaSupported.RemoveAll();
    EnumSystemCodePages(&EnumProc, CP_SUPPORTED);

    //  Build a list of mappable code pages

    for (DWORD  dw = 400; dw < 32767; dw++)
        if  (HaveMap(dw))
            cdaMapped.Add(dw);
}

const unsigned  CCodePageInformation::SupportedCount() const {
    return  (unsigned) cdaSupported.GetSize();
}

const unsigned  CCodePageInformation::InstalledCount() const {
    return  (unsigned) cdaInstalled.GetSize();
}

const unsigned  CCodePageInformation::MappedCount() const {
    return  (unsigned) cdaMapped.GetSize();
}

const DWORD CCodePageInformation::Supported(unsigned u) const {
    return  cdaSupported[u];
}

const DWORD CCodePageInformation::Installed(unsigned u) const {
    return  cdaInstalled[u];
}

const DWORD CCodePageInformation::Mapped(unsigned u) const {
    return  cdaMapped[u];
}

/******************************************************************************

  CCodePageInformation::Mapped(CDWordArray& cdaReturn)

  Fills the given array with all of the mapped code page IDs.

******************************************************************************/

void    CCodePageInformation::Mapped(CDWordArray& cdaReturn) const {
    cdaReturn.Copy(cdaMapped);
}

CString  CCodePageInformation::Name(DWORD dwidPage) const {

    CString csTemp;
    csTemp.LoadString(dwidPage);
    csTemp.TrimLeft();
    csTemp.TrimRight();

    if   (csTemp.IsEmpty())
        csTemp.Format(_TEXT("Code Page %d"), dwidPage);
    return  csTemp;
}

/******************************************************************************

  CCodePageInformation::IsInstalled

  Rturns true if the font is either installed in the OS or one of our
  resources.

******************************************************************************/

BOOL    CCodePageInformation::IsInstalled(DWORD dwidPage) const {
    for (unsigned u = 0; u < MappedCount(); u++)
        if  (Mapped(u) == dwidPage)
            return  TRUE;
    for (u = 0; u < InstalledCount(); u++)
        if  (Installed(u) == dwidPage)
            return  TRUE;

    return  FALSE;
}

/******************************************************************************

  CCodePageInformation::GenerateMap

  This private member generates a map representing the available one-to-one
  transformations in an installed code page, and writes it to a file using
  the code page id to form a unique name

******************************************************************************/

BOOL    CCodePageInformation::GenerateMap(DWORD dwidMap) const {

    //  If we can't get Code Page info for it, vanish

    CPINFO  cpi;

    if  (!GetCPInfo(dwidMap, &cpi))
        return  FALSE;

    CWordArray  cwaMap;

    for (unsigned u = 0; u < 65536; u++) {
        unsigned    uTo = 0;
        BOOL        bInvalid;

        int icTo = WideCharToMultiByte(dwidMap, 0, (PWSTR) &u, 1, (PSTR) &uTo,
            sizeof u, NULL, &bInvalid);

        if  (bInvalid)
            continue;   //  Character wasn't any good...

        _ASSERTE((unsigned) icTo <= cpi.MaxCharSize);

        //  OK, we mapped one- but, before we go on, make sure it also works
        //  in the other direction, since the U2M does some jiggering

        unsigned u3 = 0;

        MultiByteToWideChar(dwidMap, 0, (PSTR) &uTo, 2, (PWSTR) &u3, 2);

        if  (u3 != u)
            continue;   //  Not a one-for one? Not interested...

        cwaMap.Add((WORD)uTo);
        cwaMap.Add((WORD)u);
    }

    //  OK, we've got the down and dirty details- now, generate the file...

    try {
        CString csName;
        csName.Format(_TEXT("WPS%u.CTT"), dwidMap);

        CFile   cfOut(csName,
            CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive);

        //  Write the tranlated pairs

        cfOut.Write(cwaMap.GetData(), (unsigned)(cwaMap.GetSize() * sizeof(WORD)));
    }

    catch(CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}

/******************************************************************************

  CCodePageInformation::GenerateAllMaps

  This member will generate an MBCS -> Unicode one-to-one mapping table for all
  installed code pages in the user's system for which we do not now have maps.

******************************************************************************/

BOOL    CCodePageInformation::GenerateAllMaps() const {

    BOOL    bReturn = TRUE;

    for (unsigned u = InstalledCount(); u--; )
        if  (!HaveMap(Installed(u)) && !GenerateMap(Installed(u)))
            bReturn = FALSE;

    return  bReturn;
}

/******************************************************************************

  CCodePageInformation::HaveMap

  Reports that the map is one of our resources (or isn't, as the case may be).

******************************************************************************/

BOOL    CCodePageInformation::HaveMap(DWORD dwidMap) const {
    return  (dwidMap < 65536) ? !!FindResource(AfxGetResourceHandle(),
        MAKEINTRESOURCE((WORD) dwidMap), MAKEINTRESOURCE(MAPPING_TABLE)) :
        FALSE;
}

/******************************************************************************

  CCodePageInformation::IsDBCS(DWORD dwidPage)

  This is actually pretty simple- if the translation table is smaller than 1024
  bytes (256 encodings), it isn't DBCS.

******************************************************************************/

BOOL    CCodePageInformation::IsDBCS(DWORD dwidPage) {
    if  (!Load(dwidPage))
        return  FALSE;  //  May be optimistic, but we'll find out...

    return  m_cbaMap.GetSize() > 1024;
}

/******************************************************************************

  CCodePageInformation::IsDBCS(DWORD dwidPage, WORD wCodePoint)

  If the page isn't DBCS, we're done.  Otherwise, make sure the Unicode->MBCS
  map is loaded, and get the answer from there.

******************************************************************************/

BOOL    CCodePageInformation::IsDBCS(DWORD dwidPage, WORD wCodePoint) {
    if  (!IsDBCS(dwidPage))
        return  FALSE;

    if  (!Map(TRUE))
        return  FALSE;  //  Just say no, because the error's already been told

    //  0xFFFF is invalid, hence SBCS (default always must be)

    _ASSERTE(m_cwaOut[wCodePoint] != 0xFFFF);

    return ((WORD) (1 + m_cwaOut[wCodePoint])) > 0x100;
}

/******************************************************************************

  CCodePageInformation::Convert

  This is one of the workhorses- it loads the given code page, and maps the
  given character strings one way or the other, depending upon which is empty.

******************************************************************************/

unsigned    CCodePageInformation::Convert(CByteArray& cbaMBCS,
                                          CWordArray& cwaWC,
                                          DWORD dwidPage){

    if  (!cbaMBCS.GetSize() == !cwaWC.GetSize())    //  Must be clear which way
        return  0;

    if  (!Load(dwidPage) || !Map((int)cwaWC.GetSize()))
        return  0;

    CWordArray& cwaMap = cwaWC.GetSize() ? m_cwaOut : m_cwaIn;
    try {
        if  (cbaMBCS.GetSize()) {
            cwaWC.RemoveAll();
            for   (int i = 0; i < cbaMBCS.GetSize();) {
                WORD    wcThis = cbaMBCS[i];

                if  (cwaMap[wcThis] == 0xFFFF) {    //  No SBCS mapping
                    wcThis += cbaMBCS[i + 1] << 8;
                    if  (cwaMap[wcThis] == 0xFFFF) {    //  No DBCS, either?
                        _ASSERTE(FALSE);
                        return  0;  //  We have failed to convert!
                    }
                }
                cwaWC.Add(cwaMap[wcThis]);
                i += 1 + (wcThis > 0xFF);
            }
        }
        else {
            cbaMBCS.RemoveAll();
            for (int i = 0; i < cwaWC.GetSize(); i++) {
                if  (cwaMap[cwaWC[i]] == 0xFFFF) {
                    _ASSERTE(0);
                    return  0;
                }
                cbaMBCS.Add((BYTE) cwaMap[cwaWC[i]]);
                if  (0xFF < cwaMap[cwaWC[i]])
                    cbaMBCS.Add((BYTE)(cwaMap[cwaWC[i]] >> 8));
            }
        }
    }

    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        return  0;
    }

    return  (unsigned)cwaWC.GetSize();    //  Correct conversion count either way!
}

/******************************************************************************

  CCodePageInformation::Collect

  This member fills a passed CWordArray with either the domain or range of the
  mapping function.  In either case, the array is in ascending order.

******************************************************************************/

BOOL    CCodePageInformation::Collect(DWORD dwidPage, CWordArray& cwaCollect,
                                      BOOL bUnicode) {

    if  (!Load(dwidPage) || !Map(bUnicode))
        return  FALSE;

    CWordArray& cwaMap = bUnicode ? m_cwaOut : m_cwaIn;
    cwaCollect.RemoveAll();

    //  Code points < 0x20 always map, but aren't usable, so screen them out

    try {
        for (unsigned u = 0x20; u < (unsigned) cwaMap.GetSize(); u++)
            if  (~(int)(short)cwaMap[u])    //  0xFFFF means not mapped!
                cwaCollect.Add((WORD)u);
    }

    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\childfrm.h ===
/******************************************************************************

  Header File:  Child Frame.H

  This defines the CChildFrame class, which is the MFC CMDIChild with some
  minor wrapping around it.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net

******************************************************************************/

// Child Frame.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(CHILD_FRAME_CLASS)
#define CHILD_FRAME_CLASS

class CChildFrame : public CMDIChildWnd {
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/******************************************************************************

  CToolTipPage class

  This class implements a page that displays tool tips for its controls using
  strings from the string table matching the control IDs.  Derive from this
  class, and everything else works just as it ought to!

******************************************************************************/

class CToolTipPage : public CPropertyPage {

    CString m_csTip;    //  Can't use auto variables or you lose them!

// Construction
public:
	CToolTipPage(int id);
	~CToolTipPage();

// Dialog Data
	//{{AFX_DATA(CToolTipPage)
	enum { IDD = IDD_TIP };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CToolTipPage)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    afx_msg void    OnNeedText(LPNMHDR pnmh, LRESULT *plr);
	// Generated message map functions
	//{{AFX_MSG(CToolTipPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	unsigned	m_uHelpID ;		// Help ID if nonzero
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\comctrls.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	comctrls.h
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include    "FontInfo.H"

#ifndef		MDT_COMON_CONTROLS
#define		MDT_COMON_CONTROLS 1


/////////////////////////////////////////////////////////////////////////////
// The classes defined below (CEditControlEditBox, CEditControlListBox)	are
// used to implement a lighter weight, general purpose Edit control than the
// UFM Editor specific classes that are defined above.  (A normal Edit Box is
// part of this Edit Control, too.)

class CEditControlListBox ;		// Forward class declaration

/////////////////////////////////////////////////////////////////////////////
// CEditControlEditBox window

class CEditControlEditBox : public CEdit
{
	CEditControlListBox*	m_pceclb ;	// Pointer to related list box control

// Construction
public:
	CEditControlEditBox(CEditControlListBox* pceclb) ;

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditControlEditBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditControlEditBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditControlEditBox)
	afx_msg void OnKillfocus();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CEditControlListBox window

class CEditControlListBox : public CListBox
{
	CEdit*					m_pceName ;
	CEditControlEditBox*	m_pcecebValue ;
	bool					m_bReady ;			// True iff ready for operations
	int						m_nCurSelIdx ;		// Currently selected item's index

// Construction
public:
	CEditControlListBox(CEdit* pce, CEditControlEditBox* pceceb) ;
	
// Attributes
public:

// Operations
public:
	bool Init(CStringArray& csamodels, CStringArray& csafiles, int ntabstop) ;
	void SaveValue(void) ;
	bool GetGPDInfo(CStringArray& csavalues, CStringArray* pcsanames = NULL) ;
	void SelectLBEntry(int nidx, bool bsave = false) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditControlListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditControlListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditControlListBox)
	afx_msg void OnSelchange();
	afx_msg void OnDblclk();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// The classes defined below are for the CFullEditListCtrl and CFELCEditBox 
// classes.  Together, they support a List Control in Report View
// in which subitems can be edited too, complete rows can be selected, and
// the data can be sorted by numeric or text columns.  CFELCEditBox is a
// helper class that is only used by CFullEditListCtrl.
//

/////////////////////////////////////////////////////////////////////////////
// CFELCEditBox Class

class CFELCEditBox : public CEdit
{
// Construction
public:
	CFELCEditBox() ;

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFELCEditBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFELCEditBox() ;

	// Generated message map functions
protected:
	//{{AFX_MSG(CFELCEditBox)
	afx_msg void OnKillFocus(CWnd* pNewWnd) ;
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


// The following structure(s), enumeration(s), and definitions are used with 
// CFullEditListCtrl.

typedef enum {
	COLDATTYPE_INT = 0, COLDATTYPE_STRING, COLDATTYPE_FLOAT, COLDATTYPE_TOGGLE,
	COLDATTYPE_CUSTEDIT
} COLDATTYPE ;


typedef struct _COLINFO {		// Maintains info on each column
	int			nwidth ;		// The column width
	bool		beditable ;		// True iff the column is editable
	COLDATTYPE	cdttype ;		// The type of data in the column
	bool		bsortable ;		// True iff the rows can be sorted on this column
	bool		basc ;			// True iff the column has been sort ascended
	LPCTSTR		lpctstrtoggle ;	// If toggle type, pointer to toggle string
} COLINFO, *PCOLINFO ;


#define	COMPUTECOLWIDTH		-1
#define SETWIDTHTOREMAINDER	-2


// The following flags are used to indicate the toggle state of the list's
// columns.  These values are assigned to m_dwToggleFlags.

#define	TF_HASTOGGLECOLUMNS	1	// The list has toggle column(s)
#define TF_CLICKONROW		2	// Dbl-Clking on row toggles single column
#define TF_CLICKONCOLUMN	4	// Must dbl-clk on column (cell) to toggle it


// The following flags are used to indicate which one - if any - of the list's
// column's data may be modified via a custom edit routine in the class'
// owner.  These values are assigned to m_dwCustEditFlags.
								
#define	CEF_HASTOGGLECOLUMNS	1	// The list has a custom edit column
#define CEF_CLICKONROW			2	// Dbl-Clking on row activates single column
#define CEF_CLICKONCOLUMN		4	// Must dbl-clk on cell to activate dialog


// Miscellaneous flags used to control the behaviour of CFullEditListCtrl.
// These flags are passed to InitControl() in its dwmiscflags parameter.

#define MF_SENDCHANGEMESSAGE	1	// Send WM_LISTCELLCHANGED messages
#define MF_IGNOREINSERT			2	// Ignore INS key
#define MF_IGNOREDELETE			4	// Ignore DEL key
#define MF_IGNOREINSDEL			6	// Ignore INS and DEL key


// This message is sent - when requested - to a CFullEditListCtrl class 
// instance's owner whenever a list cell is changed after the list had been
// initialized.  (Yes, this really is better than having the owner handle
// LVN_ITEMCHANGED messages.)

#define WM_LISTCELLCHANGED		(WM_USER + 999)


// A function of this type is passed to	ExtraInit_CustEditCol() and called by
// CheckHandleCustEditColumn() when nonstandard editting is needed for a 
// specific cell.

typedef bool (CALLBACK* LPCELLEDITPROC) (CObject* pcoowner, int nrow, int ncol,
						 			     CString* pcscontents) ;


/////////////////////////////////////////////////////////////////////////////
// CFullEditListCtrl Class

class CFullEditListCtrl : public CListCtrl
{
// Constructor
public:
	CFullEditListCtrl();
	~CFullEditListCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFullEditListCtrl)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	CFELCEditBox m_edit;

// Message maps
	//{{AFX_MSG(CFullEditListCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	PCOLINFO	m_pciColInfo ;		// Ptr to array of structs with column info
	int			m_nNumColumns ;		// The number of columns in the list
	int			m_nSortColumn ;		// Number of column being sorted
	int			m_nNextItemData ;	// Next item data number to use
	int			m_nRow ;			// Row being edited
	int			m_nColumn ;			// Column being edited
	DWORD		m_dwToggleFlags ;	// Flags indicating toggle flag for list
	DWORD		m_dwMiscFlags ;		// Misc flags used to control list's actions
	CObject*  	m_pcoOwner ;		// Pointer to class that owns this one
	DWORD 		m_dwCustEditFlags ;	// Flags describing custom edit column
	CUIntArray	m_cuiaCustEditRows ;// Array indicating specific cust edit rows
	LPCELLEDITPROC	m_lpCellEditProc ;	// Ptr to custom cell editing proc

public:
	bool CheckHandleToggleColumns(int nrow, int ncol, PCOLINFO pci) ;
	void InitControl(DWORD dwaddlexstyles, int numrows, int numcols, 
					 DWORD dwtoggleflags = 0, int neditlen = 0, 
					 int dwmiscflags = 0) ;
	int  InitLoadColumn(int ncolnum, LPCSTR strlabel, int nwidth, int nwidthpad, 
						bool beditable, bool bsortable, COLDATTYPE cdtdatatype,
				        CObArray* pcoadata, LPCTSTR lpctstrtoggle = NULL) ;
	bool ExtraInit_CustEditCol(int ncolnum, CObject* pcoowner, 
							   DWORD dwcusteditflags, 
							   CUIntArray& cuiacusteditrows,
							   LPCELLEDITPROC lpcelleditproc) ;
	bool CheckHandleCustEditColumn(int nrow, int ncol, PCOLINFO pci) ;
	BOOL GetPointRowCol(LPPOINT lpPoint, int& iRow, int& iCol, CRect& rect) ;
	BOOL GetColCellRect(LPPOINT lpPoint, int& iRow, int& iCol, CRect& rect) ;
	bool SaveValue() ;
	void HideEditBox() ;
	bool GetColumnData(CObArray* pcoadata, int ncolnum) ;
	bool SetColumnData(CObArray* pcoadata, int ncolnum) ;
	static int CALLBACK SortListData(LPARAM lp1, LPARAM lp2, LPARAM lp3) ;
	bool SortControl(int nsortcolumn) ;
	void SingleSelect(int nitem) ;
	bool GetRowData(int nrow, CStringArray& csafields) ;
	int	 GetNumColumns() { return m_nNumColumns ; } 
	bool GetColSortOrder(int ncol) { 
		ASSERT(ncol >= 0 && ncol <= m_nNumColumns) ;
		return ((m_pciColInfo + ncol)->basc) ;
	} ;
	bool EndEditing(bool bsave) ;
	bool EditCurRowSpecCol(int ncolumn) ;
	int	 GetCurRow() { return m_nRow ; }
	void SetCurRow(int nrow) ;
	int	 GetCurCol() { return m_nColumn ; }
	void SendChangeNotification(int nrow, int ncol)	;
} ;


/////////////////////////////////////////////////////////////////////////////
// CFlagsListBox window

class CFlagsListBox : public CListBox
{
// Construction
public:
	CFlagsListBox();

// Attributes
public:
	bool		m_bReady ;				// True iff listbox has been initialized
	CUIntArray	m_cuiaFlagGroupings ;	// Flag groupings array
	int			m_nGrpCnt ;				// Number of flag groupings
	CString		m_csSetString ;			// String used to indicate a bit is set
	int			m_nNumFields ;			// Number of flag fields in list box
	bool		m_bNoClear ;			// True iff can't clear flags directly
	int			m_nNoClearGrp ;			// Group for which m_bNoClear applies

// Operations
public:
	bool Init(CStringArray& csafieldnames, DWORD dwsettings, 
			  CUIntArray& cuiaflaggroupings, int ngrpcnt, 
			  LPTSTR lptstrsetstring, int ntabstop, bool bnoclear = false,
			  int nocleargrp = -1) ;
	bool Init2(CStringArray& csafieldnames, CString* pcssettings, 
			  CUIntArray& cuiaflaggroupings, int ngrpcnt, 
			  LPTSTR lptstrsetstring, int ntabstop, bool bnoclear = false,
			  int nocleargrp = -1) ;
	DWORD GetNewFlagDWord()	;
	void GetNewFlagString(CString* pcsflags, bool badd0x = true) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFlagsListBox)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFlagsListBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CFlagsListBox)
	afx_msg void OnDblclk();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif	// #define MDT_COMON_CONTROLS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontedit.cpp ===
/******************************************************************************

  Source File:  Font Knowledge Base.CPP

  This handles the DLL initialization and termination code needed for the DLL
  to work as an AFX Extension DLL.  It was created by App Wizard, and probably
  will see little modification.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  Change History:
  03-07-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
//#include    <AfxDllx.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***	Commented out because this file is no longer part of a DLL.

static AFX_EXTENSION_MODULE FontKnowledgeBaseDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
	if (dwReason == DLL_PROCESS_ATTACH) 	{
		TRACE0("Font Knowledge Base.DLL Initializing!\n");
		
		// Extension DLL one-time initialization
		AfxInitExtensionModule(FontKnowledgeBaseDLL, hInstance);

		// Insert this DLL into the resource chain
		new CDynLinkLibrary(FontKnowledgeBaseDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH) 	{
		TRACE0("Font Knowledge Base.DLL Terminating!\n");
	}
	return 1;   // ok
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\convert.c ===
/******************************************************************************

  Source File:	Convert.C

  This is an NT Build hack.  It includes all of the "C" files used for the
  converter, because Build can't handle directories beyond ..

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved

  A Pretty Penny Enterprises Production

  Change History:

  06-20-1997	Bob_Kjelgaard@Prodigy.Net	Did the dirty deed

******************************************************************************/

#include	"..\GPC2GPD\PrEntry.C"
#include	"..\GPC2GPD\UiEntry.C"
#include	"..\GPC2GPD\Utils.C"
#include    "..\GPC2GPD\GPC2GPD.C"

VOID
CopyStringA(
    OUT PSTR    pstrDest,
    IN PCSTR    pstrSrc,
    IN INT      iDestSize
    )

/*++
 *
 * Routine Description:
 * 
 *     Copy ANSI string from source to destination
 *     
 * Arguments:
 *     
 *     pstrDest - Points to the destination buffer
 *     pstrSrc - Points to source string
 *     iDestSize - Size of destination buffer (in characters)
 *                 
 * Return Value:
 *                 
 *     NONE
 *                     
 * Note:
 *                     
 *     If the source string is shorter than the destination buffer,
 *     unused chars in the destination buffer is filled with NUL.
 *                             
 *
--*/

{
    PSTR    pstrEnd;

    ASSERT(pstrDest && pstrSrc && iDestSize > 0);
    pstrEnd = pstrDest + (iDestSize - 1);

    while ((pstrDest < pstrEnd) && (*pstrDest++ = *pstrSrc++) != NUL)
        NULL;

    while (pstrDest <= pstrEnd)
        *pstrDest++ = NUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\comctrls.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  comctrls.cpp
//
//
//	NOTES:		an FWORD is a short int
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <gpdparse.h>
#include "comctrls.H"
#include <stdlib.h>


/////////////////////////////////////////////////////////////////////////////
// The functions defined below for CEditControlEditBox and CEditControlListBox
// are used to implement a lighter weight, more general purpose Edit control
// than the UFM Editor specific classes that are defined above.  (A normal
// Edit Box is part of this Edit Control, too.)

/////////////////////////////////////////////////////////////////////////////
// CEditControlEditBox - Manages the Edit Box part of the Edit Control that
//						 is used to hold the field name.

CEditControlEditBox::CEditControlEditBox(CEditControlListBox* pceclb)
{
	// Save a pointer to the corresponding list box.

	m_pceclb = pceclb ;
}

CEditControlEditBox::~CEditControlEditBox()
{
}


BEGIN_MESSAGE_MAP(CEditControlEditBox, CEdit)
	//{{AFX_MSG_MAP(CEditControlEditBox)
	ON_CONTROL_REFLECT(EN_KILLFOCUS, OnKillfocus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditControlEditBox message handlers

void CEditControlEditBox::OnKillfocus()
{
	// Make sure the value is saved back into the list box.

	m_pceclb->SaveValue() ;	
}


/////////////////////////////////////////////////////////////////////////////
// CEditControlListBox

CEditControlListBox::CEditControlListBox(CEdit* pce,
										 CEditControlEditBox* pceceb)
{
	// Save pointers to the other 2 controls that make up the Edit Control

	m_pceName = pce ;
	m_pcecebValue = pceceb ;

	m_bReady = false ;			// Not ready for operations yet
	m_nCurSelIdx = -1 ;			// Nothing is selected yet
}


CEditControlListBox::~CEditControlListBox()
{
}


BEGIN_MESSAGE_MAP(CEditControlListBox, CListBox)
	//{{AFX_MSG_MAP(CEditControlListBox)
	ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelchange)
	ON_CONTROL_REFLECT(LBN_DBLCLK, OnDblclk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


bool CEditControlListBox::Init(CStringArray& csamodels, CStringArray& csafiles,
							   int ntabstop)
{
	int		n ;					// Loop counter and temp var

	// Make sure the list box is empty.

	ResetContent() ;

	// Set the position of the list box's tabstop.  This value is passed in
	// because it is a dialog box specific value.

	SetTabStops(1, &ntabstop) ;

	// Now combine the model names and file names and add them to the listbox.

	//csafiles[0] = "MMMMMMMM" ;
	CString cs ;
	int nummodels = (int)csamodels.GetSize() ;
	for (n = 0 ; n < nummodels ; n++) {
		cs = csamodels[n] + _T("\t") + csafiles[n] ;
		AddString(cs) ;
	} ;

	// Set the file name length limit.

	m_pcecebValue->SetLimitText(8) ;

	// Initialize (zap) the contents of the edit boxes

	m_pceName->SetWindowText(_T("")) ;
	m_pcecebValue->SetWindowText(_T("")) ;

	// Reset the currently selected entry index

	m_nCurSelIdx = -1 ;

	// Make sure the list box has the focus.

	SetFocus() ;

	// Everything is ready to go now

	m_bReady = true ;
	return TRUE ;
}


/******************************************************************************
	
  CEditControlListBox::GetGPDInfo

  Load the provided array(s) with the field values and, optionally, the field
  names.

******************************************************************************/

bool CEditControlListBox::GetGPDInfo(CStringArray& csavalues,
									 CStringArray* pcsanames /*= NULL*/)
{
	// First, make sure that the last value changed in the edit control
	// is saved.

	SaveValue() ;

	// Size the array(s) based on the number of entries in the list box.
	// Note: An empty list box is not an error.

	int numents = GetCount() ;
	if (numents <= 0)
		return true ;
	csavalues.SetSize(numents) ;
	if (pcsanames)
		pcsanames->SetSize(numents) ;

	// Loop through each entry in the list box, separate the entries into name
	// and value parts, and save the appropriate parts of the entry.

	CString csentry, csname, csvalue ;
	int npos ;
	for (int n = 0 ; n < numents ; n++) {
		GetText(n, csentry) ;
		npos = csentry.Find(_T('\t')) ;
		csvalue = csentry.Mid(npos + 1) ;
		csavalues[n] = csvalue ;
		if (pcsanames) {
			csname = (npos > 0) ? csentry.Left(npos) : _T("") ;
			pcsanames->SetAt(n, csname) ;
		} ;
	} ;
	
	return true ;
}

	
void CEditControlListBox::SelectLBEntry(int nidx, bool bsave /*=false*/)
{
	// Select the specified entry

	SetCurSel(nidx) ;

	// If the caller doesn't want to save the previous selection, clear the
	// current selection index.

	if (!bsave)
		m_nCurSelIdx = -1 ;
	
	// Update the edit control.

	OnSelchange() ;
} ;

	
void CEditControlListBox::SaveValue(void)
{
	// Do nothing if the edit control is not ready or nothing is loaded into
	// the edit boxes.

	if (!m_bReady || m_nCurSelIdx == -1)
		return ;

	// Get the string from the value edit box and from the selected entry in
	// the list box.

	CString csvalue, csentry ;
	m_pcecebValue->GetWindowText(csvalue) ;
	GetText(m_nCurSelIdx, csentry) ;

	// Replace the value in the entry with the value from the edit box and put
	// the new entry back into the list box.

	int npos = csentry.Find(_T('\t')) ;
	csentry = csentry.Left(npos + 1) + csvalue ;
	DeleteString(m_nCurSelIdx) ;
	InsertString(m_nCurSelIdx, csentry) ;
}


/////////////////////////////////////////////////////////////////////////////
// CEditControlListBox message handlers

void CEditControlListBox::OnSelchange()
{
	// Do nothing if the edit control isn't ready, yet.

	if (!m_bReady)
		return ;

	// Do nothing if the selection didn't really change

	int nidx = GetCurSel() ;
	if (nidx == m_nCurSelIdx)
		return ;

	// Save the current value

	SaveValue() ;

	// Get the index of the currently selected list box entry.  Return without
	// doing anything else if no entry is selected.

	if (nidx == LB_ERR)
		return ;

	// Get the listbox entry and split it into name and value components.

	CString csentry, csname, csvalue ;
	GetText(nidx, csentry) ;
	int npos = csentry.Find(_T('\t')) ;
	csname = (npos > 0) ? csentry.Left(npos) : _T("") ;
	csvalue = csentry.Mid(npos + 1) ;

	// Load the name into the name edit box and the value into the value edit
	// box.

	m_pceName->SetWindowText(csname) ;
	m_pcecebValue->SetWindowText(csvalue) ;

	// Save the index of the currently selected entry

	m_nCurSelIdx = nidx ;
}


void CEditControlListBox::OnDblclk()
{
	// Do nothing if the edit control isn't ready, yet.

	if (!m_bReady)
		return ;

	// Do nothing if no item is selected in the list box.

	if (GetCurSel() == LB_ERR)
		return ;

	// Load the edit boxes

	OnSelchange() ;

	// Set the focus to the value control
	
	m_pcecebValue->SetFocus() ;
}




/////////////////////////////////////////////////////////////////////////////
// The functions implement below the CFullEditListCtrl and CFELCEditBox
// classes.  Together, they implement support a List Control in Report View
// in which subitems can be editted too, complete rows can be selected, and
// the data can be sorted by numeric or text columns.  CFELCEditBox is a
// helper class that is only used by CFullEditListCtrl.
//

CFELCEditBox::CFELCEditBox()
{
}


CFELCEditBox::~CFELCEditBox()
{
}


BEGIN_MESSAGE_MAP(CFELCEditBox, CEdit)
	//{{AFX_MSG_MAP(CFELCEditBox)
	ON_WM_KILLFOCUS()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFELCEditBox message handlers

/******************************************************************************

  CFELCEditBox::OnKeyDown

  Handle the Escape (cancel) and Return (save) keys.

******************************************************************************/

void CFELCEditBox::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// Get a pointer to the owning list control

	CFullEditListCtrl* plist = (CFullEditListCtrl*) GetParent() ;
	ASSERT (plist);

	// Handle the interesting keys

	switch (nChar) {
		// End editing without saving

		case VK_ESCAPE:
			DefWindowProc(WM_KEYDOWN, 0, 0) ;	// Is this right???
			plist->EndEditing(false) ;
			break ;

		// Save contents and end editing

		case VK_RETURN:
			DefWindowProc(WM_KEYDOWN, 0, 0) ;	// Is this right???
			plist->EndEditing(true) ;
			break ;

		// Save contents, end editing, and begin editing next cell

		case VK_TAB:
			DefWindowProc (WM_KEYDOWN, 0, 0) ;	// Is this right???
			if (!(plist->EndEditing(true)))
				return ;
			plist->EditCurRowSpecCol(plist->GetCurCol() + 1) ;
			break ;

		// Process the key normally

		default:
			CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
	} ;
}


/******************************************************************************

  CFELCEditBox::OnKillFocus

  Just hide the edit box when it looses the focus.  The contents are "lost".

******************************************************************************/

void CFELCEditBox::OnKillFocus(CWnd* pNewWnd)
{
	// Save whatever is in the edit box first.

	CFullEditListCtrl* pList = (CFullEditListCtrl*)GetParent ();
	ASSERT (pList);
	pList->SaveValue() ;
	
	CEdit::OnKillFocus(pNewWnd);
	
	ShowWindow (SW_HIDE);
}


/////////////////////////////////////////////////////////////////////////////
// CFullEditListCtrl

/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CFullEditListCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CFullEditListCtrl)
	ON_WM_CREATE()
	ON_NOTIFY_REFLECT(NM_CLICK, OnClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_NOTIFY_REFLECT(LVN_KEYDOWN, OnKeydown)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
	ON_WM_VSCROLL()
	ON_WM_HSCROLL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFullEditListCtrl::CFullEditListCtrl - Constructor

CFullEditListCtrl::CFullEditListCtrl()
{
	// Initialize member variable(s)

	m_pciColInfo = NULL ;
	m_nRow = m_nColumn = m_nNumColumns = -1 ;
	m_nNextItemData = 1 ;
	m_pcoOwner = NULL ;		
	m_dwCustEditFlags = m_dwToggleFlags = m_dwMiscFlags = 0 ;
}


/////////////////////////////////////////////////////////////////////////////
// CFullEditListCtrl::~CFullEditListCtrl - Destructor

CFullEditListCtrl::~CFullEditListCtrl()
{
	// Free memory used

	if (m_pciColInfo != NULL)
		delete m_pciColInfo ;
}


/////////////////////////////////////////////////////////////////////////////
// CFullEditListCtrl message handlers

int CFullEditListCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	// I don't think anything else needs to be done here.

	return (CWnd::OnCreate(lpCreateStruct));
}

	
/******************************************************************************

  CFullEditListCtrl::InitControl

  Handles control "global" initialization for CFullEditListCtrl.

  Args:
	dwaddlexstyles	Extend styles for list control
	numrows			Number of rows of data that will be loaded into the control
	numcols			Number of columns of data that will be loaded into control
	dwtoggleflags	Flags describing if/how a column in the list can be toggled
					(See TF_XXXX definitions in comctrls.cpp.)
	neditlen		Optional max length of edittable column data strings
	dwmiscflags		Miscellaneous flags for controlling the list control
					(See MF_XXXX definitions in comctrls.cpp.)

  Note:
	  The two main initialization routines, InitControl() for global
	  initialization and InitLoadColumn() for column specific initialization,
	  require a lot of arguments already and I don't want to clutter them with
	  more.  Be that as it may, this control is still being enhanced so I have
	  added extra initialization routines when needed.  They are called
	  ExtraInit_XXXX().  Read the comment header for each routine to find out
	  what they do and when/if they should be called.  These routines may handle
	  a mixture of list global and/or per column initialization.

******************************************************************************/

void CFullEditListCtrl::InitControl(DWORD dwaddlexstyles, int numrows,
									int numcols, DWORD dwtoggleflags/*=0*/,
									int neditlen/*=0*/, int dwmiscflags /*=0*/)
{
	// Add any additional, extended styles to the list control.

	if (dwaddlexstyles != 0) {
		DWORD dwExStyle = (DWORD)SendMessage (LVM_GETEXTENDEDLISTVIEWSTYLE);
		dwExStyle |= dwaddlexstyles;
		SendMessage (LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dwExStyle);
	} ;

	// Set the number of rows in the list control.

	SetItemCount(numrows) ;

	// Allocate the structures used to track info on each column.

	if (m_pciColInfo != NULL)
		delete m_pciColInfo ;
	m_pciColInfo = new COLINFO[numcols] ;
	m_nNumColumns = numcols ;

	// Create and initialize the edit control used for subitem editing.

	VERIFY(m_edit.Create(ES_AUTOHSCROLL | WS_BORDER | WS_CHILD,
						 CRect(0,0,0,0), this, 2));
	m_edit.SetFont(GetFont()) ;
	if (neditlen > 0)
		m_edit.LimitText(neditlen) ;

	// Save the next item data number to use when and if new rows are inserted
	// after the columns are initially loaded.

	m_nNextItemData = numrows + 1 ;

	// Save the toggle amd miscellaneous flags

	m_dwToggleFlags = dwtoggleflags ;
	m_dwMiscFlags = dwmiscflags ;
}


/******************************************************************************

  CFullEditListCtrl::InitLoadColumn

  Initialize and load a specific CFullEditListCtrl column.

  Args:
	ncolnum			Column number to initialize/load
	strlabel		Column label
	nwidth			Width of column or flag specifying how to compute width
	nwidthpad		+ or - adjustment to column width
	beditable		True iff the column is editable
	bsortable		True iff the rows can be sorted on this column
	cdtdatatype		The type of data in the column
	pcoadata		Pointer to array containing the columns data
	lpctstrtoggle	If toggle-able column, the column's toggle string

  Note:
	  The two main initialization routines, InitControl() for global
	  initialization and InitLoadColumn() for column specific initialization,
	  require a lot of arguments already and I don't want to clutter them with
	  more.  Be that as it may, this control is still being enhanced so I have
	  added extra initialization routines when needed.  They are called
	  ExtraInit_XXXX().  Read the comment header for each routine to find out
	  what they do and when/if they should be called.  These routines may handle
	  a mixture of list global and/or per column initialization.

******************************************************************************/

int CFullEditListCtrl::InitLoadColumn(int ncolnum, LPCSTR strlabel, int nwidth,
								      int nwidthpad, bool beditable,
									  bool bsortable, COLDATTYPE cdtdatatype,
									  CObArray* pcoadata,
									  LPCTSTR lpctstrtoggle/*= NULL*/)
{
	// Insert the column.  Everything except numeric data is left justified.
	// Numeric data is right justified.
	
	int nfmt ;
	switch (cdtdatatype) {
		case COLDATTYPE_STRING:
		case COLDATTYPE_TOGGLE:
		case COLDATTYPE_CUSTEDIT:
			nfmt = LVCFMT_LEFT ;
			break ;
		case COLDATTYPE_INT:
		case COLDATTYPE_FLOAT:
			nfmt = LVCFMT_RIGHT ;
			break ;
		default:
			nfmt = LVCFMT_LEFT;	//raid 116584 prefix
			ASSERT(0) ;
	}
	VERIFY(InsertColumn(ncolnum, strlabel, nfmt, -1, ncolnum - 1) >= 0) ;

	// Set flags based on how the column width should be set and initialize it
	// when necessary.

	bool bcompwidth, bwidthremainder ;
	if (bcompwidth = (nwidth == COMPUTECOLWIDTH)) {
		nwidth = GetStringWidth(strlabel) + 4 ;		// Start with width of label
		bwidthremainder = false ;
	} else
		bwidthremainder = (nwidth == SETWIDTHTOREMAINDER) ;

	// Get the number (sub)items to be loaded into the column

	int numitems = (int)pcoadata->GetSize() ;

	// Load the data into the column.  If the data aren't strings, they are
	// converted into strings first.  If some of the data may be editted with
	// a custom edit routine, add elipses to those strings.  The width is
	// checked when necessary.

	CString csitem ;
	for (int n = 0 ; n < numitems ; n++) {
		// Get the string to load.

		switch (cdtdatatype) {
			case COLDATTYPE_INT:
				csitem.Format("%d", pcoadata->GetAt(n)) ;
				break ;
			case COLDATTYPE_STRING:
			case COLDATTYPE_TOGGLE:
				csitem = ((CStringArray*) pcoadata)->GetAt(n) ;
				break ;
			case COLDATTYPE_CUSTEDIT:
				csitem = ((CStringArray*) pcoadata)->GetAt(n) ;
				ASSERT(m_cuiaCustEditRows.GetSize()) ;
				if (m_cuiaCustEditRows[n])
					csitem += _T("  ...") ;
				break ;
			default:
				ASSERT(0) ;
		} ;

		// Save the width of the current item if it is the longest found so far
		// and the width needs to be computed.

		if (bcompwidth)
			if (nwidth < GetStringWidth(csitem))
				nwidth = GetStringWidth(csitem) ;

		// Load the item into the appropriate row and column

		if (ncolnum == 0) {
			VERIFY(InsertItem(n, csitem) != -1) ;
			SetItemData(n, n);
		} else
			VERIFY(SetItem(n, ncolnum, LVIF_TEXT,  csitem, -1, 0, 0, n)) ;
	} ;

	// Determine the column width when the remainder is required and then set it.

	if (bwidthremainder) {
		CRect cr ;
		GetWindowRect(cr) ;
		nwidth = cr.Width() - 4 ;
		for (n = 0 ; n < ncolnum ; n++)
			nwidth -= (m_pciColInfo + n)->nwidth ;
	} ;
	SetColumnWidth(ncolnum, nwidth + nwidthpad) ;

	// Save info about the column

	PCOLINFO pci = (m_pciColInfo + ncolnum) ;
	pci->nwidth = nwidth ;		
	pci->beditable = beditable ;
	pci->cdttype = cdtdatatype ;
	pci->bsortable = bsortable ;
	pci->basc = false ;
	pci->lpctstrtoggle = lpctstrtoggle ;

	// Return the width of the column

	return nwidth ;
}


/******************************************************************************

  CFullEditListCtrl::ExtraInit_CustEditCol

  This routine is called when *ONE* column in the list control contains some
  cells whose contents are editted by a custom edit routine.  When such a
  cell is selected, one of the list's owner's member functions is called to
  manage the work (show dlg, etc) needed to edit the cell's contents.  Some of
  the column's cells are editted normally.  The rest are edited via a
  custom edit routine.  Cuiacusteditrows contains data that indicates which
  cells are which.

  Args:
	ncolnum				Custom edit column number
	pcoowner			Pointer to this class instance's owner
	dwcusteditflags		Custom edit flags
	cuiacusteditrows	Rows in ncolnum that require custom editting

  Note:
	When needed, this routine should be called once; after InitControl() and
	before the InitLoadColumn() call for the custom edit column.

    InitLoadColumn() should be called for this column with COLDATTYPE_CUSTEDIT
	as one of its parameters.

******************************************************************************/

bool CFullEditListCtrl::ExtraInit_CustEditCol(int ncolnum, CObject* pcoowner,
											  DWORD dwcusteditflags,
											  CUIntArray& cuiacusteditrows,
											  LPCELLEDITPROC lpcelleditproc)
{
	// Fail if the column number is invalid

	if (ncolnum < 0 || ncolnum >= m_nNumColumns)
		return false ;

	// Save copies of the input parameters for later use.

	m_pcoOwner = pcoowner ;
	m_dwCustEditFlags = dwcusteditflags ;
	m_cuiaCustEditRows.Copy(cuiacusteditrows) ;
	m_lpCellEditProc = lpcelleditproc ;

	return true ;
}


BOOL CFullEditListCtrl::GetPointRowCol(LPPOINT lpPoint, int& iRow, int& iCol,
									   CRect& rect)
{
	BOOL bFound = FALSE;

	// Get row number

	iRow = HitTest (CPoint (*lpPoint));
	if (-1 == iRow)
		return bFound;

	// Get the column number and the cell dimensions

	return (GetColCellRect(lpPoint, iRow, iCol, rect)) ;
}
	
	
BOOL CFullEditListCtrl::GetColCellRect(LPPOINT lpPoint, int& iRow, int& iCol,
									   CRect& rect)
{
	BOOL bFound = FALSE ;

	// Get the dimensions for the entire row.

	VERIFY(GetItemRect(iRow, rect, LVIR_BOUNDS)) ;

	// Prepare to get the width of each column in the row.

	int iCntr = 0 ;
	LV_COLUMN lvc ;
	ZeroMemory(&lvc, sizeof (LV_COLUMN)) ;
	lvc.mask = LVCF_WIDTH ;

	// Get the dimensions of each column until the one containing the point is
	// found.

	while (GetColumn(iCntr, &lvc)) {
		rect.right = rect.left + lvc.cx ;
		if (rect.PtInRect (*lpPoint)) {
			bFound = TRUE ;
			iCol = iCntr ;
			break ;
		} ;
		rect.left = rect.right ;			
		iCntr++ ;
		ZeroMemory (&lvc, sizeof (LV_COLUMN)) ;
		lvc.mask = LVCF_WIDTH ;
	} ;

	// Return TRUE if the point is found in a cell.  Otherwise, FALSE.

	return bFound ;
}


void CFullEditListCtrl::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult)
{
	*pResult = 0 ;				// Result always 0

	// Find out what point on the list control was clicked

	CPoint point ;
	VERIFY (::GetCursorPos(&point)) ;
	//TRACE("***OnDblclk: GetCursorPos x = %d  y = %d", point.x, point.y) ;
	ScreenToClient(&point) ;
	//TRACE("  ---  ScreenToClient x = %d  y = %d\n", point.x, point.y) ;
	
	// Exit if the "click point" can't be mapped to a cell (item) on the list
	// control.

	int iRow = -1, iCol = -1 ;
	CRect rect ;
	if (!GetPointRowCol(&point, iRow, iCol, rect))
		return ;
	//TRACE("***OnDblclk: Passed GetPointRowCol() call.\n") ;

	// Exit if the cell cannot be made completely visible.  Then get the cell's
	// position and dimensions again because it might have moved.

	if (!EnsureVisible(iRow, false))
		return ;
	CRect rect2 ;
	VERIFY(GetItemRect(iRow, rect2, LVIR_BOUNDS)) ;
	rect.top = rect2.top ;
	rect.bottom = rect2.bottom ;

	// If the column is not editable (editability takes precedence), check for
	// and - when appropriate - handle togglability.  Then exit.

	PCOLINFO pci = m_pciColInfo + iCol ;
	if (!pci->beditable) {
		if (!CheckHandleToggleColumns(iRow, iCol, pci))
			CheckHandleCustEditColumn(iRow, iCol, pci) ;
		return ;
	} ;

	// If the row/column contains a "subordinate dialog" cell that can be
	// handled, do it and return.

	if (CheckHandleCustEditColumn(iRow, iCol, pci))
		return ;

	// It is ok to edit the cell normally so fire up, position, and load the
	// edit box.

	m_nRow = iRow ;
	m_nColumn = iCol ;
	CString strTemp = GetItemText(iRow, iCol) ;
	m_edit.SetWindowText(strTemp) ;
	m_edit.MoveWindow(rect) ;
	m_edit.SetSel(0, -1) ;
	m_edit.ShowWindow(SW_SHOW) ;
	m_edit.SetFocus() ;
}


void CFullEditListCtrl::OnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
	// Save any value that was being edited and hide the edit box to end
	// editing.

	SaveValue() ;
	m_edit.ShowWindow (SW_HIDE);
	
	*pResult = 0;				
}


BOOL CFullEditListCtrl::PreTranslateMessage(MSG* pMsg)
{
	switch (pMsg->message)
	{
		case WM_KEYDOWN:
		case WM_KEYUP:
			if (this == GetFocus())
			{
				switch (pMsg->wParam)
				{
					case VK_END:
					case VK_HOME:
					case VK_UP:
					case VK_DOWN:
					case VK_INSERT:
					case VK_RETURN:
						SendMessage (pMsg->message, pMsg->wParam, pMsg->lParam);
						return TRUE;
				}
			}
			else if (&m_edit == GetFocus ())
			{
				switch (pMsg->wParam)
				{
					case VK_END:
					case VK_HOME:
					case VK_LEFT:
					case VK_RIGHT:
					case VK_RETURN:
					case VK_ESCAPE:
					case VK_TAB:
						m_edit.SendMessage (pMsg->message, pMsg->wParam, pMsg->lParam);
			            return TRUE;
				}
			}
	}
	return CWnd::PreTranslateMessage(pMsg);
}


void CFullEditListCtrl::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult)
{
	// Prepare to check the key

	LV_KEYDOWN* pKeyDown = (LV_KEYDOWN*) pNMHDR ;
	*pResult = 0 ;
	CString strPrompt ;
	UINT iSelCount ;

	// Process the keys we're interested in.

	switch (pKeyDown->wVKey) {
		// Edit the first column of the first selected row.

		case VK_RETURN:
			EditCurRowSpecCol(0) ;
			break ;

		// Delete all of the selected rows.  (Don't do anything if the
		// MF_IGNOREDELETE miscellaneous flag is set.)

		case VK_DELETE:
			if (m_dwMiscFlags & MF_IGNOREDELETE)
				return ;
			iSelCount = GetSelectedCount ();
			if (0 == iSelCount)
				return;
			strPrompt.LoadString(IDS_Delete2ItemQuery) ;
			if (IDYES == MessageBox (strPrompt, NULL, MB_YESNO | MB_ICONQUESTION))
			{
				int	iSelIndex = GetNextItem (-1, LVNI_SELECTED);
				int nrow = iSelIndex ;
				while (iSelIndex != -1)
				{
					VERIFY (DeleteItem (iSelIndex));
					iSelIndex = GetNextItem (-1, LVNI_SELECTED);
				}
				if (nrow > -1)
					SendChangeNotification(nrow, 0) ;
			}
			SetFocus ();
			break ;

		// Insert a row and begin editing it.  (Don't do anything if the
		// MF_IGNOREINSERT miscellaneous flag is set.)

		case VK_INSERT:
			if (m_dwMiscFlags & MF_IGNOREINSERT)
				return ;
			// Add a new row above the selected row or at the bottom of the
			// list if nothing is selected.

			int iIndex = GetNextItem (-1, LVNI_SELECTED);
			if (-1 == iIndex)
				iIndex = GetItemCount ();
			ASSERT (-1 != iIndex);
			InsertItem (iIndex, "");
			SetItemData(iIndex, m_nNextItemData++) ;

			// Make sure that the new row is visible and the only one selected.

			SingleSelect(iIndex) ;
			
			// Get the size and position of column 0 in the new row.

			CRect rect;
			GetItemRect (iIndex, rect, LVIR_BOUNDS);
			rect.right = rect.left + GetColumnWidth (0);

			// Start editing column 0.

			m_nRow = iIndex ;
			m_nColumn = 0 ;
			m_edit.MoveWindow (rect);
			m_edit.SetWindowText ("");
			m_edit.ShowWindow (SW_SHOW);
			m_edit.SetFocus ();
			break ;
	} ;
}


bool CFullEditListCtrl::SaveValue()
{
	//TRACE("In SaveValue()\n") ;

	// Just return false if the edit box isn't visible/editing.

	if (!m_edit.IsWindowVisible()) {
		//TRACE("Leaving SaveValue() because edit box not visible.\n") ;
		return false ;
	} ;
	
	// Get the position and size of the edit box now that we know it is
	// visible.

	CRect rect ;
	m_edit.GetWindowRect(rect) ;
	ScreenToClient(rect) ;

	// Prepare to find out what row/column is being edited.

	POINT pt ;
	pt.x = rect.left ;
	pt.y = rect.top ;
	int iRow = -1, iCol = -1 ;

	// If the list box cell can be determined, save the edit box's contents in
	// that cell.

	if (GetPointRowCol(&pt, iRow, iCol, rect)) {
		CString strTemp ;
		m_edit.GetWindowText(strTemp) ;
		VERIFY(SetItemText(iRow, iCol, strTemp)) ;
		SendChangeNotification(iRow, iCol) ;
	} ;

	// The text in the edit box was saved in the appropriate list box cell
	// when it can be so return true to indicate this.

	return true ;
}


void CFullEditListCtrl::HideEditBox()
{
	m_edit.ShowWindow(SW_HIDE);
	SetFocus() ;
}


bool CFullEditListCtrl::GetColumnData(CObArray* pcoadata, int ncolnum)
{
	// Fail if the column number is bad.

	if (ncolnum < 0 || ncolnum >= m_nNumColumns)
		return false ;

	// Clear and then initialize the array

	pcoadata->RemoveAll() ;
	int numitems = GetItemCount() ;
	PCOLINFO pci = m_pciColInfo + ncolnum ;
	switch (pci->cdttype) {
		case COLDATTYPE_STRING:
		case COLDATTYPE_TOGGLE:
		case COLDATTYPE_CUSTEDIT:
			// Extra initialization needed for string arrays.
			((CStringArray*) pcoadata)->SetSize(numitems) ;
			break ;
		default:
			pcoadata->SetSize(numitems) ;
	} ;

	// Declare and initialize the Item structure

	LV_ITEM lvi ;
	char	acitemtext[4096] ;
	lvi.mask = LVIF_TEXT ;
	lvi.iSubItem = ncolnum ;
	lvi.pszText = acitemtext ;
	lvi.cchTextMax = 4095 ;
	int npos ;
	CString cscell ;

	// Load the column's data into the array in a way based on the data type.

	for (int n = 0 ; n < numitems ; n++) {
		lvi.iItem = n ;
		VERIFY(GetItem(&lvi)) ;
		switch ((m_pciColInfo + ncolnum)->cdttype) {
			case COLDATTYPE_INT:
				((CUIntArray*) pcoadata)->SetAt(n, atoi(acitemtext)) ;
				//TRACE("Set col %d sub %d to %d\n", ncolnum, n, ((CUIntArray*) pcoadata)->GetAt(n)) ;
				break ;
			case COLDATTYPE_STRING:
			case COLDATTYPE_TOGGLE:
				((CStringArray*) pcoadata)->SetAt(n, acitemtext) ;
				//TRACE("Set col %d sub %d to '%s'\n", ncolnum, n, ((CStringArray*) pcoadata)->GetAt(n)) ;
				break ;
			case COLDATTYPE_CUSTEDIT:
				cscell = acitemtext ;
				if ((npos = cscell.Find(_T("  ..."))) >= 0)
					cscell = cscell.Left(npos) ;
				((CStringArray*) pcoadata)->SetAt(n, cscell) ;
				//TRACE("Set col %d sub %d to '%s'\n", ncolnum, n, ((CStringArray*) pcoadata)->GetAt(n)) ;
				break ;
			default:
				ASSERT(0) ;
		} ;
	} ;

	// Return true because the columns data was saved.

	return true ;
}


bool CFullEditListCtrl::SetColumnData(CObArray* pcoadata, int ncolnum)
{
	// Get the number (sub)items to be loaded into the column.  If there are
	// more (sub)items than there are rows, add extra rows.

	int numitems = (int)pcoadata->GetSize() ;
	int noldnumitems = GetItemCount() ;
	if (numitems > noldnumitems) {
		SetItemCount(numitems) ;
		m_nNextItemData = numitems + 1 ;
	} ;

	// Load the data into the column.  If the data aren't strings, they are
	// converted into strings first.  The width is checked when necessary.

	CString csitem ;
	COLDATTYPE cdtdatatype = (m_pciColInfo + ncolnum)->cdttype ;
	for (int n = 0 ; n < numitems ; n++) {
		// Get the string to load.

		switch (cdtdatatype) {
			case COLDATTYPE_INT:
				csitem.Format("%d", pcoadata->GetAt(n)) ;
				break ;
			case COLDATTYPE_STRING:
			case COLDATTYPE_TOGGLE:
			case COLDATTYPE_CUSTEDIT:
				csitem = ((CStringArray*) pcoadata)->GetAt(n) ;
				break ;
			default:
				ASSERT(0) ;
		} ;

		// Load the item into the appropriate row and column

		if (n >= noldnumitems && ncolnum == 0) {
			VERIFY(InsertItem(n, csitem) != -1) ;
			SetItemData(n, n);
		} else
			VERIFY(SetItem(n, ncolnum, LVIF_TEXT,  csitem, -1, 0, 0, n)) ;
	} ;

	return true ;
}


void CFullEditListCtrl::SetCurRow(int nrow)
{
	// First remove the focus and selection from any rows that have it now.

	int nr = -1 ;
	for ( ; (nr = GetNextItem(nr, LVNI_SELECTED)) != -1 ; ) 
		SetItem(nr,0,LVIF_STATE,NULL,-1,LVIS_SELECTED,0,nr) ;

	// Now set the new row.

	SetItem(nrow, 0, LVIF_STATE, NULL, -1, LVIS_FOCUSED+LVIS_SELECTED,
		    LVIS_FOCUSED+LVIS_SELECTED, nrow) ;
	m_nRow = nrow ;
}


int CALLBACK CFullEditListCtrl::SortListData(LPARAM lp1, LPARAM lp2, LPARAM lp3)
{
	// Get pointer to associated class instance

	CFullEditListCtrl* pcfelc = (CFullEditListCtrl*) lp3 ;

	// Try to find the item indexes.  This should not fail.

	LV_FINDINFO lvfi ;
	lvfi.flags = LVFI_PARAM ;
	lvfi.lParam = lp1 ;
	int nitem1, nitem2 ;
	VERIFY((nitem1 = pcfelc->FindItem(&lvfi)) != -1) ;
	lvfi.lParam = lp2 ;
	VERIFY((nitem2 = pcfelc->FindItem(&lvfi)) != -1) ;

	// Now get the item data.  Again, this should not fail.

	LV_ITEM lvi1, lvi2 ;
	char	acitemtext1[4096], acitemtext2[4096] ;
	lvi1.mask = lvi2.mask = LVIF_TEXT ;
	lvi1.iItem = nitem1	;
	lvi2.iItem = nitem2 ;
	lvi1.iSubItem = lvi2.iSubItem = pcfelc->m_nSortColumn ;
	lvi1.pszText = acitemtext1 ;
	lvi2.pszText = acitemtext2 ;
	lvi1.cchTextMax = lvi2.cchTextMax = 4095 ;
	VERIFY(pcfelc->GetItem(&lvi1)) ;
	VERIFY(pcfelc->GetItem(&lvi2)) ;

	// Convert the item text when necessary and compare the items.

	int ncompresult, inum1, inum2 ;
	PCOLINFO pci = pcfelc->m_pciColInfo + pcfelc->m_nSortColumn ;
	switch (pci->cdttype) {
		case COLDATTYPE_INT:
			inum1 = atoi(acitemtext1) ;
			inum2 = atoi(acitemtext2) ;
			ncompresult = inum1 - inum2 ;
			break ;
		case COLDATTYPE_STRING:
		case COLDATTYPE_TOGGLE:
		case COLDATTYPE_CUSTEDIT:
			ncompresult = _stricmp(acitemtext1, acitemtext2) ;
			break ;
		default:
			ASSERT(0) ;
	} ;

	// Return the result of the comparison.  Reverse it before returning if
	// sorting in descending order.

	return ((pci->basc) ? ncompresult : 0 - ncompresult) ;
}


void CFullEditListCtrl::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult)
{
	// Save any in progress editing and shut it down before doing anything else.

	EndEditing(true) ;

	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
	// Get the sort column and send it to the sort control routine.

	SortControl(pNMListView->iSubItem) ;
	
	*pResult = 0;
}


bool CFullEditListCtrl::SortControl(int nsortcolumn)
{
    CWaitCursor cwc ;

	// Save any in progress editing and shut it down before doing anything else.

	EndEditing(true) ;

	// Get a pointer to the column info structure

	PCOLINFO pci = m_pciColInfo + nsortcolumn ;

	// If the column is not sortable, just return false.

	if (!pci->bsortable)
		return false ;

	// Save the sort column, reverse the sort flag, and then sort the data.

	m_nSortColumn = nsortcolumn ;
	pci->basc = !pci->basc ;
	SortItems(SortListData, (LPARAM) this) ;

	// Data should have been sorted so...

	return true ;
}


void CFullEditListCtrl::SingleSelect(int nitem)
{
	int		nselitem ;			// Selected item index

	// First, deselect all of the currently selected rows.

	nselitem = -1 ;
	while ((nselitem = GetNextItem(nselitem, LVNI_SELECTED)) != -1)
		SetItemState(nselitem, 0, LVIS_SELECTED | LVIS_FOCUSED) ;

	// Now select the requested row (item) and make it visible.

	SetItemState(nitem, LVIS_SELECTED | LVIS_FOCUSED,
				 LVIS_SELECTED | LVIS_FOCUSED) ;
	EnsureVisible(nitem, false) ;
}


bool CFullEditListCtrl::GetRowData(int nrow, CStringArray& csafields)
{
	// Fail if the requested row number is too large.

	if (nrow > GetItemCount())
		return false ;

	// Make sure that the string array is large enough to hold all of the
	// strings in a row.  IE, the row's item text and all of the subitems'
	// text.

	if (m_nNumColumns > csafields.GetSize())
		csafields.SetSize(m_nNumColumns) ;

	// Declare and initialize the Item structure

	LV_ITEM lvi ;
	char	acitemtext[4096] ;
	lvi.iItem = nrow ;
	lvi.mask = LVIF_TEXT ;
	lvi.pszText = acitemtext ;
	lvi.cchTextMax = 4095 ;

	// Get each field in the row and copy it into the fields array.

	for (int n = 0 ; n < m_nNumColumns ; n++) {
		lvi.iSubItem = n ;
		VERIFY(GetItem(&lvi)) ;
		csafields[n] = acitemtext ;
	} ;

	// All went well so...

	return true ;
}


bool CFullEditListCtrl::EndEditing(bool bsave)
{
	// Save the new value first if requested.  Return if there is nothing to
	// save or - when not saving - if nothing is being edited.

	if (bsave) {
		if (!SaveValue())
			return false ;
	} else
		if (!m_edit.IsWindowVisible())
			return false ;

	// Now hide the edit box and give the focus back to the list control.

	m_edit.ShowWindow(SW_HIDE) ;
	SetFocus() ;

	// Mission accomplished so...

	return true ;
}


bool CFullEditListCtrl::EditCurRowSpecCol(int ncolumn)
{
	// Save the specified column number.  If it is too big, reset it to 0.
	// If the column isn't editable, try the next one.  Return false if an
	// editable column can't be found.

	for (int n = 0 ; n < m_nNumColumns ; n++, ncolumn++) {
		if (ncolumn >= m_nNumColumns)
			ncolumn = 0 ;
 		if ((m_pciColInfo + ncolumn)->beditable)
			break ;
	} ;
	if (n < m_nNumColumns)
		m_nColumn = ncolumn ;
	else
		return false ;

	// Get the first currently selected row number.  Use row number 0 if no
	// row is selected.

	if ((m_nRow = GetNextItem(-1, LVNI_SELECTED)) == -1)
		m_nRow = 0 ;

	// Make the current row, the only selected row and make sure it is visible.

	SingleSelect(m_nRow) ;

	// Now determine the dimensions of the specified column.  Begin this by
	// getting the dimensions of the entire row...

	CRect	rect ;
	VERIFY(GetItemRect(m_nRow, rect, LVIR_BOUNDS)) ;

	// ...Finish by looping through all of the columns getting their dimensions
	// and using those dimensions to adjust the left side of the rectangle
	// until the current column is reached.  Then adjust the right side of the
	// rectangle.

	LV_COLUMN lvc ;
	for (int ncol = 0 ; ncol <= m_nColumn ; ncol++) {
		ZeroMemory(&lvc, sizeof(LV_COLUMN)) ;
		lvc.mask = LVCF_WIDTH ;
		GetColumn(ncol, &lvc) ;
		if (ncol < m_nColumn)
			rect.left += lvc.cx ;
	} ;
	rect.right = rect.left + lvc.cx ;

	// Load, position, size, and show the edit box.

	CString strTemp = GetItemText(m_nRow, m_nColumn) ;
	m_edit.SetWindowText(strTemp) ;
	m_edit.MoveWindow(rect) ;
	m_edit.SetSel(0, -1) ;
	m_edit.ShowWindow(SW_SHOW) ;
	m_edit.SetFocus() ;

	return true ;
}


void CFullEditListCtrl::OnVScroll(UINT nSBCode, UINT nPos,
								  CScrollBar* pScrollBar)
{
	// Things get screwy if the list control scrolls while an item is being
	// edited so end editing before allowing scrolling to take place.

	EndEditing(true) ;
	
	CListCtrl::OnVScroll(nSBCode, nPos, pScrollBar);
}


void CFullEditListCtrl::OnHScroll(UINT nSBCode, UINT nPos,
								  CScrollBar* pScrollBar)
{
	// Things get screwy if the list control scrolls while an item is being
	// edited so end editing before allowing scrolling to take place.

	EndEditing(true) ;
	
	CListCtrl::OnHScroll(nSBCode, nPos, pScrollBar);
}


/******************************************************************************

  CFullEditListCtrl::CheckHandleToggleColumns

  First check to see if the row or column has togglable.  If not, just return.
  If the row is togglable, find the togglable column (cell).  Then either set
  its contents if it is empty or clear it if it is not empty.

  Return true if a toggle-able column was found and toggled.  Otherwise, return
  false.

******************************************************************************/

bool CFullEditListCtrl::CheckHandleToggleColumns(int nrow, int ncol,
												 PCOLINFO pci)
{
	// Return if there is no togglable column in this list.

	if (!(m_dwToggleFlags & TF_HASTOGGLECOLUMNS))
		return false ;

	// If a specific togglable column must be clicked and that column was not
	// clicked, just return.

	if (m_dwToggleFlags & TF_CLICKONCOLUMN) {
		if (pci->cdttype != COLDATTYPE_TOGGLE)
			return false ;
	
	// If any part of the row can be double-clicked to toggle the togglable
	// column, find that column.  Return if there is no such column.

	} else {
		pci = m_pciColInfo ;
		for (ncol = 0 ; ncol < m_nNumColumns ; ncol++, pci++) {
			if (pci->cdttype == COLDATTYPE_TOGGLE)
				break ;
		} ;
		if (ncol >= m_nNumColumns)
			return false ;
	} ;

	// Get the contents of the specified cell.

	CString strcell = GetItemText(nrow, ncol) ;

	// If the cell is empty, load it with the toggle string.  If the cell is
	// not empty, clear its contents.

	if (strcell.IsEmpty())
		VERIFY(SetItemText(nrow, ncol, pci->lpctstrtoggle)) ;
	else
		VERIFY(SetItemText(nrow, ncol, _T(""))) ;
	SendChangeNotification(nrow, ncol) ;

	return true ;
}


/******************************************************************************

  CFullEditListCtrl::CheckHandleCustEditColumn

  First check to see if the row or column may contain a cell may be one that is
  only editable with a custom edit routine.  If not, just return.  Next,
  make sure that the cell not only might be of this type but actually is of this
  type.  If not, just return.

  Now, get the contents of the selected cell and remove the ellipses from the
  end of it.  (The ellipses will be replaced before the new string is put back
  into the cell.)

  Next, comes the tricky part.  Use the owner class pointer to call the routine
  in that class which will manage the work of editting the cell's contents.
  Although CFullEditListCtrl is supposed to be a generic class, this routine
  must know what the owner class is so that the management routine can be
  called.  This means that extra, owner class specific, code must be added to
  this routine each time a new owner class is added that uses this feature in
  CFullEditListCtrl.

  If the edit request was handled via a subordinate dialog box, return true.
  Otherwise, return false.

******************************************************************************/

bool CFullEditListCtrl::CheckHandleCustEditColumn(int nrow, int ncol,
											      PCOLINFO pci)
{
	// Return if there is no custom edit column in this list.

	if (!(m_dwCustEditFlags & CEF_HASTOGGLECOLUMNS))
		return false ;

	// Return if the selected row does not contain a custom edit cell.

	int n = (int)m_cuiaCustEditRows.GetSize() ;
	ASSERT(m_cuiaCustEditRows.GetSize()) ;
	if (nrow >= m_cuiaCustEditRows.GetSize() || m_cuiaCustEditRows[nrow] == 0)
		return false ;

	// If a specific custom edit column must be clicked and that column was not
	// clicked, just return.

	if (m_dwCustEditFlags & CEF_CLICKONCOLUMN) {
		if (pci->cdttype != COLDATTYPE_CUSTEDIT)
			return false ;
	
	// If any part of the row can be double-clicked to edit the custom edit
	// column, find that column.  Return if there is no such column.

	} else {
		pci = m_pciColInfo ;
		for (ncol = 0 ; ncol < m_nNumColumns ; ncol++, pci++) {
			if (pci->cdttype == COLDATTYPE_CUSTEDIT)
				break ;
		} ;
		if (ncol >= m_nNumColumns)
			return false ;
	} ;

	// Get the contents of the specified cell and remove the ellipses from the
	// end of it.

	CString strcell = GetItemText(nrow, ncol) ;
	int npos ;
	if ((npos = strcell.Find(_T("  ..."))) >= 0)
		strcell = strcell.Left(npos) ;

	// Find the class for the owner and use that information to call the
	// management routine.  If this routine "fails" or is cancelled, return
	// true without updating the cell.

	bool brc ;
	brc = (*m_lpCellEditProc)(m_pcoOwner, nrow, ncol, &strcell) ;
	if (!brc)
		return true ;

	// Add the ellipses back on to the cell's new contents and update the cell.

	strcell += _T("  ...") ;
	VERIFY(SetItemText(nrow, ncol, strcell)) ;
	SendChangeNotification(nrow, ncol) ;
	SetFocus() ;

	return true ;
}


void CFullEditListCtrl::SendChangeNotification(int nrow, int ncol)
{
	// Do nothing if the owner does not want to be notified of a change in one
	// of the cells in the list control.

	if (!(m_dwMiscFlags & MF_SENDCHANGEMESSAGE))
		return ;

	// Send the message

	::PostMessage(GetParent()->m_hWnd, WM_LISTCELLCHANGED, nrow, ncol) ;
}



/////////////////////////////////////////////////////////////////////////////
// CFlagsListBox

CFlagsListBox::CFlagsListBox()
{
	m_bReady = false ;
	m_nGrpCnt = 0 ;
}

CFlagsListBox::~CFlagsListBox()
{
}


BEGIN_MESSAGE_MAP(CFlagsListBox, CListBox)
	//{{AFX_MSG_MAP(CFlagsListBox)
	ON_CONTROL_REFLECT(LBN_DBLCLK, OnDblclk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/******************************************************************************

  CFlagsListBox::Init

  Save the parameters that are used to control the behaviour of the list box.
  Set the list box's tab stop.  Then build the list box items based on the
  flag names and settings and load them into the list box.

  Args:
	csafieldnames		Flag field names
	dwsettings			Current flag setting(s)
	cuiaflaggroupings	Indexes for related groups of flags
	ngrpcnt				Number of flag groups
	lptstrsetstring		String to display when a flag is set
	ntabstop			List box tab stop, sets column widths
	bnoclear			True iff dbl-clk doesn't clear a flag that is set
	nocleargrp			-1 or only 0-based group number that bnoclear applies to

  ***  IMPORTANT NOTE  ***
  See OnDblclk() to find out how the data in m_cuiaFlagGroupings and m_nGrpCnt
  are interpreted.

******************************************************************************/

bool CFlagsListBox::Init(CStringArray& csafieldnames, DWORD dwsettings,
						 CUIntArray& cuiaflaggroupings, int ngrpcnt,
						 LPTSTR lptstrsetstring, int ntabstop,
						 bool bnoclear /*=false*/, int nocleargrp /*=-1*/)
{
	// Check parameters

	ASSERT(csafieldnames.GetSize())	;
	ASSERT(cuiaflaggroupings.GetSize() >= (ngrpcnt * 2)) ;
	ASSERT(lptstrsetstring)	;
	ASSERT(ntabstop > 0) ;

	// Copy parameters needed later

	m_cuiaFlagGroupings.Copy(cuiaflaggroupings) ;	
	m_nGrpCnt = ngrpcnt ;				
	m_csSetString = lptstrsetstring ;			
	m_nNumFields = (int)csafieldnames.GetSize() ;
	m_bNoClear = bnoclear ;
	m_nNoClearGrp = nocleargrp ;

	// Make sure the list box is empty.

	ResetContent() ;

	// Set the position of the list box's tabstop.  This value is passed in
	// because it is a dialog box specific value.

	SetTabStops(1, &ntabstop) ;

	// Now combine the field names and settings and add them to the listbox.

	CString cs ;
	int nbit = 1 ;
	for (int n = 0 ; n < m_nNumFields ; n++, nbit <<= 1) {
		cs = (dwsettings & nbit) ? m_csSetString : _T("") ;
		cs = csafieldnames[n] + _T("\t") + cs ;
		AddString(cs) ;
	} ;

	// Make sure the list box has the focus.

	SetFocus() ;

	// All went well so...

	m_bReady = true ;
	return true ;
}


/******************************************************************************

  CFlagsListBox::Init2

  The flag settings in pcssettings are in the form of a hex number represented
  as a string that may begin with "0x".  For example, "0xA23" and "A23".  Turn
  this string into a DWORD and pass this DWORD plus the rest of the parameters
  to the other form of this function that takes the settings parameter as a
  DWORD.  It does the rest of the work.

  Args:
	csafieldnames		Flag field names
	pcssettings			Current flag setting(s)
	cuiaflaggroupings	Indexes for related groups of flags
	ngrpcnt				Number of flag groups
	lptstrsetstring		String to display when a flag is set
	ntabstop			List box tab stop, sets column widths
	bnoclear			True iff dbl-clk doesn't clear a flag that is set
	nocleargrp			-1 or only 0-based group number that bnoclear applies to

  ***  IMPORTANT NOTE  ***
  See OnDblclk() to find out how the data in m_cuiaFlagGroupings and m_nGrpCnt
  are interpreted.

******************************************************************************/

bool CFlagsListBox::Init2(CStringArray& csafieldnames, CString* pcssettings,
						  CUIntArray& cuiaflaggroupings, int ngrpcnt,
						  LPTSTR lptstrsetstring, int ntabstop,
						  bool bnoclear /*=false*/, int nocleargrp /*=-1*/)
{
	// Turn pcssettings into a dword.  (Skip passed "0x" if it is on the
	// beginning of the string.)

	LPTSTR lptstr, lptstr2 ;
	lptstr = pcssettings->GetBuffer(16) ;
	int n = pcssettings->GetLength() ;
	*(lptstr + n) = 0 ;
	if (*(lptstr + 1) == 'x')
		lptstr += 2 ;
	DWORD dwsettings = strtoul(lptstr, &lptstr2, 16) ;
	
	// The other Init() finishes the job.

	return (Init(csafieldnames, dwsettings, cuiaflaggroupings, ngrpcnt,
				 lptstrsetstring, ntabstop, bnoclear, nocleargrp)) ;
}


/******************************************************************************

  CFlagsListBox::GetNewFlagDWord()

  Read the settings of the flags in the list box to determine the new flag
  dword.  Then return it.

******************************************************************************/

DWORD CFlagsListBox::GetNewFlagDWord()
{
	DWORD dwflags = 0 ;			// Flag dword built here
	DWORD dwbit = 1 ;			// Used to set bits that are on

	// Loop through each flag in the list box

	CString csentry, csvalue ;
	int npos ;
	for (int n = 0 ; n < m_nNumFields ; n++, dwbit <<= 1) {
		// Get the current flag and isolate its setting.

		GetText(n, csentry) ;
		npos = csentry.Find(_T('\t')) ;
		csvalue = csentry.Mid(npos + 1) ;

		// If the current flag is set, turn on its bit in dwflags.

		if (csvalue.GetLength())
			dwflags |= dwbit ;
	} ;

	// Return the flag DWORD.

	return dwflags ;
}


/******************************************************************************

  CFlagsListBox::GetNewFlagString()

  Use the other version of this routine to get the DWORD version of the flags.
  Then convert it to a string a save it in csflags.  "0x" may or may not be
  prepended to the string.

******************************************************************************/

void CFlagsListBox::GetNewFlagString(CString* pcsflags, bool badd0x /*=true*/)
{
	// Get the DWORD version of the flag.

	DWORD dwflags = GetNewFlagDWord() ;

	// Format the flags as a string and prepend "0x" when requested.

	if (badd0x)
		pcsflags->Format("0x%x", dwflags) ;
	else
		pcsflags->Format("%x", dwflags) ;
}


/////////////////////////////////////////////////////////////////////////////
// CFlagsListBox message handlers

/******************************************************************************

  CFlagsListBox::OnDblclk()

  First, toggle the setting of the selected item.  At least, that is what is
  usually done first.  If m_bNoClear is set and the user has asked to clear a
  flag, don't do this or anything else.  Just return.  Use m_bNoClear when at
  least one flag must always be set.  See #4 for more information on m_bNoClear.

  Next, process the rest of the flags in the items flag group.  The following
  things can happen based on the group:
	1.	If the item is not in a group, do nothing else.  This is useful when
		any combination of flags can be set.  The most efficient way to do this
		is by setting m_nGrpCnt to 0.
	2.	The item indexes in m_cuiaFlagGroupings that contain the selected item
		are positive.  Only one of the specified flags can be set.  If the
		selected item was set, clear the rest of the flags in the group.
	3.	The item indexes in m_cuiaFlagGroupings that contain the selected item
		are negative.  (The absolute value of the indexes is used for tests.)
		Change the state of the other flags in the group, too.  Generally, this
		only makes sense in a two flag group where one and only one of the flags
		MUST be selected.
	4.  If m_bNoClear is set and m_nNoClearGrp = -1, m_bNoClear affects all
		flags.  If m_nNoClearGrp is >= 0, it refers to the single group that
		m_bNoClear affects.

******************************************************************************/

void CFlagsListBox::OnDblclk()
{
	// Do nothing if the edit control isn't ready, yet.

	if (!m_bReady)
		return ;

	// Do nothing if no item is selected in the list box.

	int nselitem ;
	if ((nselitem = GetCurSel()) == LB_ERR)
		return ;

	// Get the listbox entry and split it into name and value components.

	CString csentry, csname, csvalue ;
	GetText(nselitem, csentry) ;
	int npos = csentry.Find(_T('\t')) ;
	csname = (npos > 0) ? csentry.Left(npos) : _T("") ;
	csvalue = csentry.Mid(npos + 1) ;

	// Find the flag grouping for the selected flag.

	int n, nidx ;
	for (n = nidx = 0 ; n < m_nGrpCnt ; n++, nidx += 2)
		if (abs(m_cuiaFlagGroupings[nidx]) <= nselitem
		 && abs(m_cuiaFlagGroupings[nidx+1]) >= nselitem)
			break ;

	// Determine the flags current state.  If it is set and m_bNoClear == true,
	// don't do anything based on the value of m_nNoClearGrp.  Just return.

	bool boldstate = !csvalue.IsEmpty() ;
	if (m_bNoClear && boldstate && (m_nNoClearGrp == -1 || m_nNoClearGrp == n))
		return ;

	// Change the state of the selected flag.

	csvalue = (boldstate) ? _T("") : m_csSetString ;
	csentry = csname + _T('\t') + csvalue ;
	DeleteString(nselitem) ;
	InsertString(nselitem, csentry) ;
	
	// Do nothing else if the selected flag is not in a flag grouping.

	if (n >= m_nGrpCnt)	{
		SetCurSel(nselitem) ;
		return ;
	} ;

	// Find out if this group has to have a flag set.  If it doesn't and the
	// selected flag was cleared, there is nothing left to do.

	bool bmustset = ((int) m_cuiaFlagGroupings[nidx+1]) < 0 ;
	if (!bmustset && boldstate)	{
		SetCurSel(nselitem) ;
		return ;
	} ;

	// Loop through all of the flags in the current group.  Change the setting
	// of all flags in the group -- EXCEPT the selected flag -- to the old value
	// of the selected flag.

	n = abs(m_cuiaFlagGroupings[nidx+1]) ;
	csvalue = (boldstate) ? m_csSetString : _T("") ;
	for (nidx = abs(m_cuiaFlagGroupings[nidx]) ; nidx <= n ; nidx++) {
		if (nidx == nselitem)
			continue ;
		GetText(nidx, csentry) ;
		npos = csentry.Find(_T('\t')) ;
		csname = (npos > 0) ? csentry.Left(npos + 1) : _T("") ;
		csentry = csname + csvalue ;
		DeleteString(nidx) ;
		InsertString(nidx, csentry) ;
	} ;

	// Make sure that the flag selected by the user is still selected and
	// return.

	SetCurSel(nselitem) ;
	return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontinfo.cpp ===
/******************************************************************************

  Source File:  Generic Font Information.CPP

  This implements the CFontInfo and all related classes, which describe printer
  fonts in all the detail necessary to satisfy all these different operating
  systems.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-03-1997    Bob_Kjelgaard@Prodigy.Net   Began work on this monster
  02-01-1998    norzilla@asccessone.com aka Rick Mallonee  rewrote nearly the whole thing.

******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include	"utility.h"
#include    "FontInfo.H"
#include    "ChildFrm.H"     //  Definition of Tool Tips Property Page class
#include	"comctrls.h"
#include    "FontView.H"
#include	<uni16res.h>
#include	"rcfile.h"
#include    "ProjRec.H"

static const double gdConvertRadToDegree = 900.0 / atan2(1.0, 0.0);		//  A handy constant for converting radians to 10's of a degree
static CCodePageInformation* pccpi = NULL ;								//  Use a static CCodePageInformation to derive more benefit from caching

/******************************************************************************

  CKern

  This class encapsulates the kerning pair structure.  It's pretty trivial.
  The CFontInfo class maintains an array of these.
%
******************************************************************************/

class CKern : public CObject
{
    FD_KERNINGPAIR  m_fdkp;
public:
    CKern() { m_fdkp.wcFirst = m_fdkp.wcSecond = m_fdkp.fwdKern = 0; }
    CKern(FD_KERNINGPAIR& fdkp) { m_fdkp = fdkp; }
    CKern(WCHAR wcf, WCHAR wcs, short sa) {
				m_fdkp.wcFirst = wcf ;
				m_fdkp.wcSecond = wcs ;
				m_fdkp.fwdKern = sa ;
	}

    WCHAR   First() const { return m_fdkp.wcFirst; }
    WCHAR   Second() const { return m_fdkp.wcSecond; }
    short   Amount() const { return m_fdkp.fwdKern; }

    void    SetAmount(short sNew) { m_fdkp.fwdKern = sNew; }
    void    SetAll(WCHAR wcf, WCHAR wcs, short sa) {
				m_fdkp.wcFirst = wcf ;
				m_fdkp.wcSecond = wcs ;
				m_fdkp.fwdKern = sa ;
	}

    void    Store(CFile& cf) { cf.Write(&m_fdkp, sizeof m_fdkp); }
};

/******************************************************************************

  CFontDifference class

  This class handles the requisite information content for the Font Difference
  structure involved with Font Simulation.

******************************************************************************/
CFontDifference::CFontDifference(PBYTE pb, CBasicNode *pcbn)
{
    FONTDIFF    *pfd = (FONTDIFF *) pb;
    m_pcbnOwner = pcbn;

    m_cwaMetrics.Add(pfd -> usWinWeight);
    m_cwaMetrics.Add(pfd -> fwdMaxCharInc);
    m_cwaMetrics.Add(pfd -> fwdAveCharWidth);

	// NOTE:	The conversion done in this statement is reversed in a statement
	//			in the CFontDifference::Store() routine.  For whatever reason,
	//			this two steps can repeatedly reduce the user supplied value by
	//			1.  To prevent this, 1 is added back in the following statement.
	
    m_cwaMetrics.Add((WORD) (gdConvertRadToDegree *
        atan2((double) pfd -> ptlCaret.x, (double) pfd -> ptlCaret.y)) + 1);
}

/******************************************************************************

  CFontDifference::SetMetric

  This function will modify one of the four metrics, if it is new, and it meets
  our criteria (Max >= Average, 0 <= Angle < 900, Weight <= 1000).  Errors are
  reported via a public enum return code.

******************************************************************************/
WORD    CFontDifference::SetMetric(unsigned u, WORD wNew)
{
    if  (wNew == m_cwaMetrics[u]) return  OK;

	/* Verification isn't needed and removing it solves other problems in the
	   UFM Editor.

    switch  (u)
		{
		case Max:     if  (wNew < m_cwaMetrics[Average]) return  Reversed;
				      break;

		case Average: if  (wNew > m_cwaMetrics[Max])     return  Reversed;
					  break;

		case Weight:  if  (wNew > 1000)  return  TooBig;
					  break;

		default:      if  (wNew > 899)   return  TooBig;					//  Angle
		}
	*/
	gdConvertRadToDegree;
    m_cwaMetrics[u] = wNew;
    m_pcbnOwner -> Changed();
    return  OK;
}

/******************************************************************************

  CFontDifference::Store(CFile& cf)

  This member creates a FONTDIFF structure, fills it, and writes it to the
  given file.  The big calculation is the x and y components for the italic
  angle, if there is one.

******************************************************************************/

void    CFontDifference::Store(CFile& cf, WORD wfSelection)
{
    FONTDIFF    fd = {0, 0, 0, 0, m_cwaMetrics[Weight], wfSelection,
					  m_cwaMetrics[Average], m_cwaMetrics[Max]};

    fd.bWeight = (m_cwaMetrics[Weight] >= FW_BOLD) ? PAN_WEIGHT_BOLD :
				 (m_cwaMetrics[Weight] > FW_EXTRALIGHT) ?
				 PAN_WEIGHT_MEDIUM : PAN_WEIGHT_LIGHT;

	if(gdConvertRadToDegree)				// raid 116588 Prefix :: constant value;
		fd.ptlCaret.x = !m_cwaMetrics[Angle] ? 0 :
			(long) (10000.0 * tan(((double) m_cwaMetrics[Angle]) / gdConvertRadToDegree));

    fd.ptlCaret.y = m_cwaMetrics[Angle] ? 10000 : 1;

    cf.Write(&fd, sizeof fd);
}

/******************************************************************************
	And now, for the hardest working class in show business (and a personal friend
	of mine):

  CFontInfo class

  This class encapsulates all of the font knowledge this application needs.

******************************************************************************/

IMPLEMENT_SERIAL(CFontInfo, CProjectNode, 0)

/******************************************************************************

  CFontInfo::MapPFM

  This loads a PFM format file, if it isn't already loaded.

******************************************************************************/

BOOL    CFontInfo::MapPFM() {

    if  (m_cbaPFM.GetSize())
        return  TRUE;   //  Already has been loaded!

    try {
        CFile   cfLoad(m_csSource, CFile::modeRead | CFile::shareDenyWrite);
        m_cbaPFM.SetSize(cfLoad.GetLength());
        cfLoad.Read(m_cbaPFM.GetData(), cfLoad.GetLength());
    }

    catch   (CException   *pce) {
        pce -> ReportError();
        pce -> Delete();
        m_cbaPFM.RemoveAll();
        return  FALSE;
    }

    return  TRUE;
}

/******************************************************************************

  CFontInfo::GetTranslation

  This loads a PFM format file and gets the default CTT ID from it.  Nothing
  else is done.

******************************************************************************/

extern "C"  int ICttID2GttID(long lPredefinedCTTID);

int     CFontInfo::GetTranslation(CSafeObArray& csoagtts)
{
    //  PFM file structures- these are declared at this level to keep them off
    //  the master class list for the project.

#pragma pack(1) //  The following is byte-aligned

    struct sPFMHeader {
        WORD    m_wType, m_wPoints, m_wVertRes, m_wHorizRes, m_wAscent,
                m_wInternalLeading, m_wExternalLeading;
        BYTE    m_bfItalic, m_bfUnderline, m_bfStrikeOut;
        WORD    m_wWeight;
        BYTE    m_bCharSet;
        WORD    m_wPixWidth, m_wPixHeight;
        BYTE    m_bfPitchAndFamily;
        WORD    m_wAvgWidth, m_wMaxWidth;
        BYTE    m_bFirstChar, m_bLastChar, m_bDefaultChar, m_bBreakChar;
        WORD    m_wcbWidth;
        DWORD   m_dwDevice, m_dwFace, m_dwBitsPointer, m_dwofBits;
        BYTE    m_bReserved;
    };

    struct sPFMExtension {
        WORD    m_wcbRemaining; //  From this point on
        DWORD   m_dwofExtMetrics, m_dwofExtentTable, m_dwofOriginTable,
                m_dwofPairKernTable, m_dwofTrackKernTable, m_dwofDriverInfo,
                m_dwReserved;
    };

#pragma pack (2)    //  Everything else has word alignment

    struct sOldKernPair {
        union {
            BYTE m_abEach[2];
            WORD m_wBoth;
        };
        short m_sAmount;
    };

    struct sKernTrack {
        short m_sDegree, m_sMinSize, m_sMinAmount, m_sMaxSize, m_sMaxAmount;
    };

    struct sPFMDriverInfo {
        enum {CurrentVersion = 0x200};
        enum {CannotItalicize = 1, CannotUnderline, SendCRAfterUsing = 4,
                CannotMakeBold = 8, CannotDoubleUnderline = 0x10,
                CannotStrikeThru = 0x20, BackspaceForPairs = 0x40};
        WORD    m_wcbThis, m_wVersion, m_wfCapabilities, m_widThis, m_wAdjustY,
                m_wYMovement, m_widCTT, m_wUnderlinePosition,
                m_wDoubleUnderlinePosition, m_wStrikeThruPosition;
        DWORD   m_dwofSelect, m_dwofDeselect;
        WORD    m_wPrivateData;   /* Used in DeskJet driver for font enumerations */
        short   m_sShiftFromCenter;
        enum {HPIntelliFont, TrueType, PPDSScalable, CapsL, OEMType1, OEMType2};
        WORD    m_wFontType;
    };

#pragma pack()  //  We now return control to you

    if  (!MapPFM())
        return  -IDS_FileReadError ;

    //  Now, map out the rest of the pieces of the structure.

    union {
            BYTE        *pbPFM; //  Base of the file for offsets!
            sPFMHeader  *pspfmh;
    };

    pbPFM = m_cbaPFM.GetData();

    //  Screen out evil files- part 1: is length sufficient?

    unsigned    uSize = sizeof (sPFMHeader) + sizeof (sPFMExtension) +
         sizeof (sPFMDriverInfo);
    if  ((unsigned) m_cbaPFM.GetSize() < uSize)
         return -IDS_PFMTooSmall ;

    //  YA Sanity check

    if  (pspfmh -> m_bLastChar < pspfmh -> m_bFirstChar)
         return -IDS_PFMCharError ;

    //  Width table, if there is one.

    WORD    *pwWidth = pspfmh -> m_wPixWidth ? NULL : (PWORD) (pspfmh + 1);
    uSize += !!pwWidth * sizeof (WORD) *
        (2 + pspfmh -> m_bLastChar - pspfmh -> m_bFirstChar);

    //  Screen out evil files- part 2: is length still sufficient?

    if  ((unsigned) m_cbaPFM.GetSize() < uSize)
         return -IDS_PFMTooSmall ;

    //  PFMExtension follows width table, otherwise the header

    sPFMExtension   *pspfme = pwWidth ? (sPFMExtension *)
        (pwWidth + 2 + pspfmh -> m_bLastChar - pspfmh -> m_bFirstChar) :
        (sPFMExtension *) (pspfmh + 1);

    //  Penultimate sanity check- is the driver info offset real?

    if  ((unsigned) m_cbaPFM.GetSize() <
         pspfme -> m_dwofDriverInfo + sizeof (sPFMDriverInfo))
        return  -IDS_BadPFMInfoOffset ;

    //  Text Metrics, DriverInfo and others are pointed at by PFM
    //  Extension.

    sPFMDriverInfo  *pspfmdi =
        (sPFMDriverInfo *) (pbPFM + pspfme -> m_dwofDriverInfo);

    //  Final sanity check- is the driver info version real?

    if  (pspfmdi -> m_wVersion > sPFMDriverInfo::CurrentVersion)
        return  -IDS_BadPFMInfoVersion ;

	// See if the original CTT ID needs to be converted to a new codepage
	// number.  If not, leave it alone.  In any case, set the font's GTT ID.

	//TRACE("GetTrans: UFM = %s   CTT ID = %d    GTT ID = %d\n", Name(), pspfmdi -> m_widCTT, ICttID2GttID((long) (short) pspfmdi -> m_widCTT)) ;
	//    m_widTranslation = (WORD) ICttID2GttID((long) (short) pspfmdi -> m_widCTT);				// rm ori
    m_lGlyphSetDataRCID = (WORD) ICttID2GttID((long) (short) pspfmdi -> m_widCTT);			// rm new
	
	
	if (!m_lGlyphSetDataRCID)  {	// Raid 135623

		switch (pspfmh ->m_bCharSet) {
			case  SHIFTJIS_CHARSET:
					m_lGlyphSetDataRCID = -17;
					break;
			case GB2312_CHARSET:
					m_lGlyphSetDataRCID = -16;
					break;
			case HANGEUL_CHARSET:
			case JOHAB_CHARSET:
					m_lGlyphSetDataRCID = -18;
					break;
			case CHINESEBIG5_CHARSET:
					m_lGlyphSetDataRCID = -10;
					break;
		} ;
	} ;
	// GTTs will be renumbered when the new, W2K RC file is written.  Because of
	// this, the GTT ID set above needs to be translated to the new number.  This
	// number corresponds to the GTT's position in GlyphTable.  NOTE: The ID is
	// not changed if it is <= 0.  (The IDs in the GlyphMaps will be changed in
	// CDriverResources::LoadFontData().)

	if (m_lGlyphSetDataRCID > 0 && m_lGlyphSetDataRCID == pspfmdi->m_widCTT) {
        for (unsigned uGTT = 0; uGTT < csoagtts.GetSize(); uGTT++)
            if (m_lGlyphSetDataRCID 
			 == ((LONG) ((CGlyphMap *) csoagtts[uGTT])->nGetRCID()))
                m_lGlyphSetDataRCID = uGTT + 1 ;
	} ;
	
	Changed();
    return  0 ;
}

/******************************************************************************

  CFontInfo::CalculateWidths()

  This member function is needed whenever a change is made to a variable pitch
  font's width table, or equally well, whenever an arbitrary table is picked up
  by a formerly fixed pitch font.  It calculates the width using the approved
  algorithm (average means average of 26 lower-case plus the space, unless they
  don't exist, in which case it is of all non-zero widths).

******************************************************************************/

void    CFontInfo::CalculateWidths()
{
//    m_wMaximumIncrement = 0;												//  Assume max width is 0, then prove otherwise.  Also collect the
																			//  raw information needed to correctly calculate the average width.

    unsigned    uPointsToAverage = 0, uOverallWidth = 0, uAverageWidth = 0,
				uZeroPoints = 0;

    for (unsigned u = 0; u < (unsigned) m_cpaGlyphs.GetSize(); u++)
		{
        WORD    wWidth = m_cwaWidth[u];;
		m_IFIMETRICS.fwdMaxCharInc = max(m_IFIMETRICS.fwdMaxCharInc, wWidth);					// rm new
//        m_wMaximumIncrement = max(m_wMaximumIncrement, wWidth);				// rm ori

        uOverallWidth += wWidth;
        if  (!wWidth)   uZeroPoints++;
//        if  (Glyph(u).CodePoint() == m_cwaSignificant[Break] ||				// rm ori
        if  (Glyph(u).CodePoint() == m_IFIMETRICS.wcBreakChar ||					// rm new
             (Glyph(u).CodePoint() >= (WORD) 'a' &&
             Glyph(u).CodePoint() <= (WORD) 'z'))
			{
            uAverageWidth += wWidth;
            uPointsToAverage++;
			}
		}

    //  If we averaged 27 points, then this is the correct width.  Otherwise,
    //  We average all of the widths.   cf the IFIMETRICS description in DDK


    m_IFIMETRICS.fwdAveCharWidth = (uPointsToAverage == 27) ?							// rm new

//    m_wAverageWidth = (uPointsToAverage == 27) ?										// rm ori
        (WORD) (0.5 + ((double) uAverageWidth) / 27.0) :
        (WORD) (0.5 + (((double) uOverallWidth) / (double) (u - uZeroPoints)));
}

/******************************************************************************

  CFontInfo::CFontInfo()

  This class constructor has a lot of work to do.  Not only does it have to
  initialize 5 zillion fields, it has to build the context menu list, and a few
  other glorious items of that ilk.

******************************************************************************/

CFontInfo::CFontInfo()
 {

	m_fEXTTEXTMETRIC = FALSE;		// rm new

    m_pcmdt = NULL;
    m_pcgmTranslation = NULL;
    m_pcfdBold = m_pcfdItalic = m_pcfdBoth = NULL;
    m_cfn.SetExtension(_T(".UFM"));
	m_ulDefaultCodepage = 0 ;
	m_bRCIDChanged = 0 ;	// raid 0003

//    m_bCharacterSet = m_bPitchAndFamily = 0;										// rm   no longer needed

//    m_wMaximumIncrement = m_wfStyle = m_wWeight =  m_wAverageWidth  =				// rm ori
//        m_wHeight = m_widTranslation = 0;											// rm ori
    m_wHeight = 0;
	m_lGlyphSetDataRCID = 0;										// rm new

//    m_bLocation = m_bTechnology = m_bfGeneral = 0;								// rm ori
//    m_wType = m_fCaps = 0;														// rm   no longer needed
//    m_bScalable = FALSE;															// rm   no longer needed

//    m_wXResolution =  m_wYResolution = m_wPrivateData = 0;						// rm ori
//    m_sPreAdjustY =  m_sPostAdjustY =  m_sCenterAdjustment = 0;					// rm ori

//    m_wXRes = m_wYRes = m_wPrivateData = 0;										// rm   no longer needed
//    m_sYAdjust =  m_sYMoved = m_sCenterAdjustment = 0;							// rm   no longer needed

    m_wMaxScale = m_wMinScale = m_wScaleDevice = 0;
//    m_bfScaleOrientation = 0;

    m_cwaSpecial.InsertAt(0, 0, 1 + InternalLeading);    //  Initialize this array.

    //  Build the context menu control
    m_cwaMenuID.Add(ID_OpenItem);
    m_cwaMenuID.Add(ID_CopyItem);
    m_cwaMenuID.Add(ID_RenameItem);
    m_cwaMenuID.Add(ID_DeleteItem);
    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);

	// Allocate a CCodePageInformation class if needed.

	if (pccpi == NULL)
		pccpi = new CCodePageInformation ;

	// Assume the font is NOT being loaded from a workspace.

	m_bLoadedByWorkspace = false ;

	// Assume that a GTT/CP will be found for the UFM.

	m_bWSLoadButNoGTTCP = false ;

	// Another method is used for now.
	//
	// // Assume there is no width table offset and that the font not variable
	// // pitch.  These variables are both used to determine if this is a variable
	// // pitch font.
	//
	// m_loWidthTable = 0 ;
	// m_IFIMETRICS.jWinPitchAndFamily = 0 ;

	m_ctReloadWidthsTimeStamp = (time_t) 0 ;	// Widths never reloaded
}

/******************************************************************************

  CFontInfo::CFontInfo(const CFontInfo& cfiRef, WORD widCTT)

  This class constructor duplicates an existing font, but changes the CTT ID,
  and generates a new name and file name accordingly

******************************************************************************/

CFontInfo::CFontInfo(const CFontInfo& cfiRef, WORD widCTT) // r31
{

	m_fEXTTEXTMETRIC = FALSE;		// rm new

    m_pcmdt = cfiRef.m_pcmdt;
    m_pcfdBold = m_pcfdItalic = m_pcfdBoth = NULL;
    m_pcgmTranslation = NULL;
    m_cfn.SetExtension(_T(".UFM"));
    CString csWork;

    //  Generate what will hopefully be a unique file name for the UFM
	
	ReTitle(cfiRef.Name()) ;
	m_cfn.UniqueName(true, true, cfiRef.m_cfn.Path()) ;
    //m_cfn.Rename(cfiRef.m_cfn.Path() + cfiRef.Name() + csWork);

    // Generate a new display name for the UFM using the CTT number

	csWork.Format(_T("(CTT %d)"), (long)(short)widCTT); // r 31
    m_csSource = cfiRef.m_csSource;
    Rename(cfiRef.Name() + csWork);

//    m_bCharacterSet = m_bPitchAndFamily = 0;										// rm   no longer needed

//    m_wMaximumIncrement = m_wfStyle = m_wWeight =  m_wAverageWidth =				// rm ori
        m_wHeight = 0;

//    m_bLocation = m_bTechnology = m_bfGeneral = 0;								// rm ori
//    m_wType = m_fCaps = 0;														// rm no longer needed
//    m_bScalable = FALSE;															// rm   no longer needed

//    m_wXResolution =  m_wYResolution = m_wPrivateData = 0;						// rm ori
//    m_sPreAdjustY =  m_sPostAdjustY =  m_sCenterAdjustment = 0;					// rm ori

//    m_wXRes = m_wYRes = m_wPrivateData = 0;										// rm   no longer needed
//    m_sYAdjust =  m_sYMoved = m_sCenterAdjustment = 0;							// rm   no longer needed

    m_wMaxScale = m_wMinScale = m_wScaleDevice = 0;
//    m_bfScaleOrientation = 0;

    m_cwaSpecial.InsertAt(0, 0, 1 + InternalLeading);    //  Initialize this array.

//    m_widTranslation = widCTT;														// rm ori
	m_lGlyphSetDataRCID = widCTT;														// rm new
    //  Build the context menu control
    m_cwaMenuID.Copy(cfiRef.m_cwaMenuID);

	// Allocate a CCodePageInformation class if needed.

	if (pccpi == NULL)
		pccpi = new CCodePageInformation ;

	// Assume the font is NOT being loaded from a workspace.

	m_bLoadedByWorkspace = false ;

	// Assume that a GTT/CP will be found for the UFM.

	m_bWSLoadButNoGTTCP = false ;

	m_ctReloadWidthsTimeStamp = (time_t) 0 ;	// Widths never reloaded
}

CFontInfo::~CFontInfo()
{
    if  (m_pcfdBold)    delete  m_pcfdBold;
    if  (m_pcfdItalic)  delete  m_pcfdItalic;
    if  (m_pcfdBoth)    delete  m_pcfdBoth;
}

/******************************************************************************

  CFontInfo::GTTDescription

  This returns a CString naming the GTT associated with this font.  It will
  come from the workspace if the font is a resource, or the string table, if it
  is predefined.

******************************************************************************/

CString CFontInfo::GTTDescription() const {
    if  (m_pcgmTranslation)
        return  m_pcgmTranslation -> Name();

    CString csName;


//  if  ((short) m_widTranslation <= 0)											// rm ori
    if  ((short) m_lGlyphSetDataRCID <= 0)	// r31  re visit					// rm new
//      csName.LoadString(IDS_DefaultPage + (short) m_widTranslation);			// rm ori
        csName.LoadString(IDS_DefaultPage + (short) m_lGlyphSetDataRCID);		// rm new

    if  (!csName.GetLength())
//      csName.Format(IDS_ResourceID, (short) m_widTranslation);				// rm ori
        csName.Format(IDS_ResourceID, (short) m_lGlyphSetDataRCID);				// rm new

    return  csName;
}

/******************************************************************************

  CFontInfo::InterceptItalic

  This calculates where a line drawn at the italic slant angle would intercept
  a rectangle the height of the ascender, and twice the maximum width of the
  font.  It is used to help draw the image of this line in the font editor.

******************************************************************************/
/*
void    CFontInfo::InterceptItalic(CPoint& cpt) const {
    if  (!m _cwaSpecial[ItalicAngle]) {  //  Nothing
        cpt.x = 5;
        cpt.y = 0;
        return;
    }

    //  First, assume we will hit the top- it's almost always true.

    cpt.x = 5 + (long) (0.5 + tan(((double) m _cwaSpecial[ItalicAngle]) /
        gdConvertRadToDegree) * ((double) m_IFIMETRICS.fwdWinAscender);							// rm new
//        gdConvertRadToDegree) * ((double) m _cwaSpecial[Baseline]));							rm ori

    if  (cpt.x <= -5 + 2 * m_wMaximumIncrement) {
        cpt.y = 0;
        return;
    }

    //  OK, assume the opposite

    cpt.y = (long) (0.5 + tan(((double) (900 - m _cwaSpecial[ItalicAngle])) /
        gdConvertRadToDegree) * ((double) (-10 + 2 * m_wMaximumIncrement)));
    cpt.x = -5 + 2 * m_wMaximumIncrement;
}
*/

/******************************************************************************

  CFontInfo::CompareWidths

  This compares the character widths for two indices, and returns, Less, More,
  or Equal, as need be.  It is not const, because Glyph() is not, and I've
  already got a bazillion member functions.

******************************************************************************/

unsigned    CFontInfo::CompareWidths(unsigned u1, unsigned u2) {

    _ASSERT(IsVariableWidth() && u1 < (unsigned) m_cpaGlyphs.GetSize() &&
        u2 < (unsigned) m_cpaGlyphs.GetSize());

    return  (m_cwaWidth[u1] < m_cwaWidth[u2]) ? Less :
        (m_cwaWidth[u1] > m_cwaWidth[u2]) ? More : Equal;
}

/******************************************************************************

  CFontInfo::MapKerning

  This maps out the available code points, and the kern pairs in both
  directions, into a CWordArray and a pair of CSafeMapWordToObs (where the
  underlying CObjects are CMapWordToDWords), respectively.  This allows the
  Add Kerning Pair dialog to screen out already defined pairs, and invalid code
  points.

******************************************************************************/

void    CFontInfo::MapKerning(CSafeMapWordToOb& csmw2o1,
                              CSafeMapWordToOb& csmw2o2,
                              CWordArray& cwaPoints) {

    //  If this isn't variable width, then we'll need to suck up some glyph
    //  data, temporarily.

    BOOL    bDispose = !IsVariableWidth();

    if  (bDispose)
        m_pcgmTranslation -> Collect(m_cpaGlyphs);

	unsigned rm =  m_pcgmTranslation->Glyphs();			// rm

    for (unsigned u = 0; u < m_pcgmTranslation -> Glyphs(); u++)
        if  (!DBCSFont() || Glyph(u).CodePoint() < 0x80)
            cwaPoints.Add(Glyph(u).CodePoint());
        else
            break;

    if  (bDispose)
        m_cpaGlyphs.RemoveAll();

    for (u = 0; u < m_csoaKern.GetSize(); u++) {
        CKern&  ck = *(CKern *) m_csoaKern[u];

        union {
            CObject         *pco;
            CMapWordToDWord *pcmw2d;
        };

        //  Map first word to second

        if  (csmw2o1.Lookup(ck.First(), pco)) {
            _ASSERT(!pcmw2d -> operator[](ck.Second()));
            pcmw2d -> operator[](ck.Second()) = (DWORD) ck.Amount();
        }
        else {
            CMapWordToDWord *pcmw2d = new CMapWordToDWord;
            pcmw2d -> operator[](ck.Second()) = (DWORD) ck.Amount();
            csmw2o1[ck.First()] = pcmw2d;
        }

        //  Now the other direction

        if  (csmw2o2.Lookup(ck.Second(), pco)) {
            _ASSERT(!pcmw2d -> operator[](ck.First()));
            pcmw2d -> operator[](ck.First()) = (DWORD) ck.Amount();
        }
        else {
            CMapWordToDWord *pcmw2d = new CMapWordToDWord;
            pcmw2d -> operator[](ck.First()) = (DWORD) ck.Amount();
            csmw2o2[ck.Second()] = pcmw2d;
        }
    }
}

/******************************************************************************

  CFontInfo::CompareKernAmount

    This is an editor sort helper- it tells how two kern amounts compare by
    index.

******************************************************************************/

unsigned    CFontInfo::CompareKernAmount(unsigned u1, unsigned u2) const {
    CKern   &ck1 = *(CKern *) m_csoaKern[u1], &ck2 = *(CKern *) m_csoaKern[u2];

    return  (ck1.Amount() < ck2.Amount()) ? Less :
    (ck1.Amount() > ck2.Amount()) ? More : Equal;
}

/******************************************************************************

  CFontInfo::CompareKernFirst

    This is an editor sort helper- it tells how two kern first characters
    compare by index.

******************************************************************************/

unsigned    CFontInfo::CompareKernFirst(unsigned u1, unsigned u2) const {
    CKern   &ck1 = *(CKern *) m_csoaKern[u1], &ck2 = *(CKern *) m_csoaKern[u2];

    return  (ck1.First() < ck2.First()) ? Less :
    (ck1.First() > ck2.First()) ? More : Equal;
}

/******************************************************************************

  CFontInfo::CompareKernSecond

    This is an editor sort helper- it tells how two kern second characters
    compare by index.

******************************************************************************/

unsigned    CFontInfo::CompareKernSecond(unsigned u1, unsigned u2) const {
    CKern   &ck1 = *(CKern *) m_csoaKern[u1], &ck2 = *(CKern *) m_csoaKern[u2];

    return  (ck1.Second() < ck2.Second()) ? Less :
    (ck1.Second() > ck2.Second()) ? More : Equal;
}


/******************************************************************************
		
	CFontInfo::GetKernFirst

    Return the kerning pairs' first character.

******************************************************************************/

WCHAR CFontInfo::GetKernFirst(unsigned u) const
{
    CKern   &ck = *(CKern *) m_csoaKern[u] ;

    return (ck.First()) ;
}


/******************************************************************************

	CFontInfo::GetKernSecond

    Return the kerning pairs' second character.

******************************************************************************/

WCHAR CFontInfo::GetKernSecond(unsigned u) const
{
    CKern   &ck = *(CKern *) m_csoaKern[u] ;
    return (ck.Second()) ;
}


/******************************************************************************

	CFontInfo::GetKernAmount

    Return the kerning pairs' kerning amount.

******************************************************************************/

short CFontInfo::GetKernAmount(unsigned u) const
{
    CKern   &ck = *(CKern *) m_csoaKern[u] ;
    return (ck.Amount()) ;
}


/******************************************************************************

  CFontInfo::SetSourceName

  This takes and stores the source file name so we can load and convert later.
  This takes and stores the name for the project node for this UFM.  It begins
  with the PFM file name.  If the extension is PFM, it is used.  Otherwise, the
  dot in the file name is changed to an underscore and the whole thing is used.

******************************************************************************/

void    CFontInfo::SetSourceName(LPCTSTR lpstrNew) {

    m_csSource = lpstrNew;

    m_csName = m_csSource.Mid(m_csSource.ReverseFind(_T('\\')) + 1);

    if  (m_csName.Find(_T('.')) >= 0)
        if  (m_csName.Right(4).CompareNoCase(_T(".PFM"))) {
            m_csName.SetAt(m_csName.Find(_T('.')), _T('_'));
            CProjectNode::Rename(m_csName);
        }
        else
            CProjectNode::Rename(m_csName.Left(m_csName.Find(_T('.'))));
    else
        CProjectNode::Rename(m_csName);
}


/******************************************************************************

  CFontInfo::SetFileName

  This sets the new file name.  It is done differently than in SetSourceName()
  because the base file name must not be more than 8 characters long.  (The
  extra info is left in the node name by SetSourceName() because it is useful
  there and it has no length limit.)

******************************************************************************/

BOOL CFontInfo::SetFileName(LPCTSTR lpstrNew)
{
	CString		csnew ;			// CString version of input parameter

	csnew = lpstrNew ;

	// If the input filespec contains an extension, remove it and pass the
	// resulting string to the file node's rename routine.  Otherwise, just
	// pass the original string to the rename routine.
	//
	// This check is complicated by the fact that one of the path components
	// might have a dot in it too.  We need to check for the last dot and make
	// sure it comes before a path separator.

    if  (csnew.ReverseFind(_T('.')) > csnew.ReverseFind(_T('\\')))
		return m_cfn.Rename(csnew.Left(csnew.ReverseFind(_T('.')))) ;
	else
		return m_cfn.Rename(csnew) ;
}


/******************************************************************************

  CFontInfo::Generate

  This member generates the font information in one of the supported forms.  I
  determine the desired form from the file's extension.

******************************************************************************/

BOOL ConvertPFMToIFI(LPCTSTR lpstrPFM, LPCTSTR lpstrIFI, LPCTSTR lpstrUniq);

extern "C" {

    BOOL    BConvertPFM(LPBYTE lpbPFM, DWORD dwCodePage, LPBYTE lpbGTT,
                        PWSTR pwstrUnique, LPCTSTR lpstrUFM, int iGTTID);
    DWORD   DwGetCodePageFromGTTID(LONG lPredefinedCTTId);
}

int    CFontInfo::Generate(CString csPath)
{
    CString csExtension = csPath.Right(4);
    csExtension.MakeUpper();
    
    if  (csExtension == _T(".IFI"))
        return  ConvertPFMToIFI(m_csSource, csPath, m_csUnique);
    if  (csExtension == _T(".UFM")) {
        if  (!m_pcgmTranslation) {
            //CString csWork;

//            csWork.Format(IDS_BadCTTID, (LPCTSTR) m_csSource, (long) (short) m_widTranslation);			// rm ori
            //csWork.Format(IDS_BadCTTID, (LPCTSTR) m_csSource, (long) (short) m_lGlyphSetDataRCID);			// rm new


            //AfxMessageBox(csWork);
            return  IDS_BadCTTID;
        }

        //  Determine whether a GTT file or code page is to be used
//        DWORD   dwCodePage = DwGetCodePageFromCTTID((LONG) - (short) m_widTranslation);							// rm ori
        DWORD   dwCodePage = DwGetCodePageFromGTTID((LONG) - (short) m_lGlyphSetDataRCID);	 // r 31						// rm new

        //  Load the GTT file, if we need to.  This handles predefined, as well

        CByteArray  cbaMap;

        m_pcgmTranslation -> Load(cbaMap);

        if  (!cbaMap.GetSize())
            return  IDS_UFMGenError ;

        //  Load the PFM file into memory (should already be there)

        if  (!MapPFM())
            return  IDS_UFMGenError ;  //  Couldn't load PFM- impossible at this point!

        //  Convert the unique name string to Unicode

        CByteArray  cbaIn;
        CWordArray  cwaOut;

        cbaIn.SetSize(1 + m_csUnique.GetLength());
        if (!SUCCEEDED(StringCchCopyA((LPSTR) cbaIn.GetData(), cbaIn.GetSize(), (LPCTSTR) m_csUnique)))
        {
            return IDS_UFMGenError;
        }

        pccpi->Convert(cbaIn, cwaOut, GetACP());

        //  DO IT!

		//TRACE("%s UFM has CP = %d and RCID = %d\n", Name(), dwCodePage, m_lGlyphSetDataRCID) ;

		// If both the code page and GTT ID are 0, set the code page to 1252.

		if (dwCodePage == 0 && m_lGlyphSetDataRCID == 0)
			dwCodePage = 1252 ;

		//TRACE("*** GTT Pointer = %d\n", cbaMap.GetData()) ;
		ASSERT(cbaMap.GetData()) ;
        BOOL brc = BConvertPFM(m_cbaPFM.GetData(), dwCodePage, cbaMap.GetData(),
//            cwaOut.GetData(), FileName(), (short) m_widTranslation);										// rm ori
            cwaOut.GetData(), FileName(), (short) m_lGlyphSetDataRCID);	//r 31 short -> INT									// rm new
		return ((brc) ? 0 : IDS_UFMGenError) ;

//        return  BConvertPFM(m_cbaPFM.GetData(), dwCodePage, cbaMap.GetData(),
////            cwaOut.GetData(), FileName(), (short) m_widTranslation);										// rm ori
//            cwaOut.GetData(), FileName(), (short) m_lGlyphSetDataRCID);										// rm new
    }
    return  0 ;
}

/******************************************************************************

  CFontInfo::AddFamily

  This searches for the given name in the list of families, and adds it if it
  is not there.  It returns TRUE if it succeeded.

******************************************************************************/

BOOL    CFontInfo::AddFamily(LPCTSTR lpstrNew) {

    for (unsigned u = 0; u < Families(); u++)
        if  (!Family(u).CompareNoCase(lpstrNew))
            break;

    if  (u < Families())
        return  FALSE;  //  Already have it!

    try {
        m_csaFamily.Add(lpstrNew);
    }

    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    Changed();
    return  TRUE;
}

/******************************************************************************

  CFontInfo::RemoveFamily

  This function removes the given family name from the list of aliases.  This
  code is more robust than it needs to be- it'll remove duplicates, even though
  the add code won't allow them to be added.  No telling what the input data
  looks like, though, is there?

******************************************************************************/

void    CFontInfo::RemoveFamily(LPCTSTR lpstrDead) {

    for (unsigned u = 0; u < Families(); u ++)
        if  (!Family(u).CompareNoCase(lpstrDead)) {
            m_csaFamily.RemoveAt(u--);  //  Decrement so we don't miss one
            Changed();
        }
}

/*****************************************************************************

  CFontInfo::ChangePitch

  We exploit the fact that the widths are maintained in the CGlyphMap
  (actually the CGlyphHandle) class.  All this method need do for a variable
  font flipping to fixed is to toss out the m_cpaGlyphs member's content.  To
  flip to variable, collect the handles, then check the first one's width- if
  it's non-zero, then a previous transition from variable to fixed is being
  undone, and we can recycle the old values, thus keeping any edits that may
  have been lost.  Otherwise, the trick code comes- the initial values get
  filled- what's tricky is that for a DBCS character set, only the SBCS values
  less than 0x80 can be variable.

******************************************************************************/

void    CFontInfo::ChangePitch(BOOL bFixed)
{

    if  (bFixed == !IsVariableWidth())
        return; //  Nothing to change!

    if  (bFixed)
		{
        m_cpaGlyphs.RemoveAll();    //  CPtrArray doesn't delete anything

        m_IFIMETRICS.fwdAveCharWidth = DBCSFont() ? (1 + m_IFIMETRICS.fwdMaxCharInc) >> 1 : m_IFIMETRICS.fwdMaxCharInc;		// rm new

//       m_wAverageWidth = DBCSFont() ? (1 + m_IFIMETRICS.fwdMaxCharInc) >> 1 : m_IFIMETRICS.fwdMaxCharInc;					// rm ori
//        m_wAverageWidth = DBCSFont() ? (1 + m_wMaximumIncrement) >> 1 : m_wMaximumIncrement;
        Changed();
        return;
		}

    if  (!m_pcgmTranslation)    return; //  Can't do this with no GTT available

    m_pcgmTranslation -> Collect(m_cpaGlyphs);
    if  (!m_cwaWidth.GetSize())
        m_cwaWidth.InsertAt(0, 0, m_cpaGlyphs.GetSize());
    Changed();  //  It sure has...

    if  (!m_cpaGlyphs.GetSize() || m_cwaWidth[0])
		{  //  Update the maximum and average width if this is not DBCS
        if  (!DBCSFont())
            CalculateWidths();
        return; //  We did all that needed to be done
		}

    if  (!DBCSFont()) {

        for (int i = 0; i < m_cpaGlyphs.GetSize(); i++)
            m_cwaWidth[i] = m_IFIMETRICS.fwdMaxCharInc;  //m_wMaximumIncrement;			// rm ori, rm new

        return;
    }

    for (int i = 0; i < m_cpaGlyphs.GetSize() && Glyph(i).CodePoint() < 0x80;)
            m_cwaWidth[i++] = m_IFIMETRICS.fwdAveCharWidth;					//m_wAverageWidth; 		// rm ori, rm new  //  In DBCS, this is always it
}

/*****************************************************************************

  CFontInfo::SetScalability

  This is called to turn scalability on or off.  All that really needs to be
  done is to establish values for the maximum and minimum scale, the font ->
  device units mapping members, and the lowercase ascender /descender, if this
  is the first time this information has changed.

******************************************************************************/

/*void    CFontInfo::SetScalability(BOOL bOn) {

    if  (IsScalable() == !!bOn)
        return; //  Nothing to change

    if  (!bOn) {
        m_bScalable = FALSE;
        Changed();
        return;
    }

    m_bScalable = TRUE;
    Changed();

    if  (m_wMaxScale && m_wMinScale && m_wMaxScale != m_wMinScale)
        return; //  We've already got data.

    m_wMaxScale = m_wMinScale = m_wScaleDevice = m_wHeight - m_InternalLeading
//        m_wHeight - m _cwaSpecial[InternalLeading];

    //  Flaky, but set the initial max and min to +- 1 point from nominal

    m_wMaxScale += m_wYResolution / 72;
    m_wMinScale -= m_wYResolution / 72;

    //  Finally, set the lowercase ascender and descender to simple defaults

    m_Lowerd = m_IFIMETRICS.fwdWinAscender - m_InternalLeading;
    m_Lowerp = m_wHeight - m_IFIMETRICS.fwdWinAscender;
}
*/


/*****************************************************************************

  CFontInfo::SetSpecial

  This adjusts anything that may need adjusting if a special metric is
  altered.

******************************************************************************/

void    CFontInfo::SetSpecial(unsigned ufMetric, short sSpecial)
{
    if  (m_cwaSpecial[ufMetric] == (WORD) sSpecial)  return; //  Nothing changed

    m_cwaSpecial[ufMetric] = (WORD) sSpecial;

    switch  (ufMetric)
		{
		case    InternalLeading:

			//  Adjust the scaling factors if need be
			if  (m_wScaleDevice > m_wHeight - sSpecial) m_wScaleDevice = m_wHeight - sSpecial;

			if  (m_wMinScale > m_wHeight - sSpecial)    m_wMinScale = m_wHeight - sSpecial;
		}

    Changed();
}



/*****************************************************************************

  CFontInfo::SetMaxWidth

  This is not as simple as it might seem.  If the font is variable, don't do
  it.  If it is not, then if it is DBCS, set the average width to 1/2 the new
  maximum.  Otherwise, set it also to the maximum.

******************************************************************************/

void    CFontInfo::SetMaxWidth(WORD wWidth)
{
    if  (IsVariableWidth()) return;

    if  (wWidth == m_IFIMETRICS.fwdMaxCharInc) return; //  Nothing to do!
//    if  (wWidth == m_wMaximumIncrement) return; //  Nothing to do!

	m_IFIMETRICS.fwdMaxCharInc = wWidth;										// rm new

//    m_wMaximumIncrement = wWidth;												// rm ori

	
    m_IFIMETRICS.fwdAveCharWidth = DBCSFont() ? (wWidth + 1) >> 1 : wWidth;		// rm new

//    m_wAverageWidth = DBCSFont() ? (wWidth + 1) >> 1 : wWidth;				// rm old

    Changed();
}

/*****************************************************************************

  CFontInfo::SetHeight

  This member checks to see if the new height is non-zero and new.  If so, it
  uses it for the new height, then adjusts all of the possibly affected
  special metrics so they continue to meet the constraints.

******************************************************************************/

BOOL    CFontInfo::SetHeight(WORD wHeight)
{
    if  (!wHeight || wHeight == m_wHeight) return  FALSE;

    m_wHeight = wHeight;


//    short   sBaseline = (short) (min(wHeight, m _cwaSpecial[Baseline]));		// rm ori
    short   sBaseline = (short) (min(wHeight, m_IFIMETRICS.fwdWinAscender));

    for (unsigned u = 0; u <= InternalLeading; u++)
		{
        switch  (u)
			{
			case    InterlineGap:
					if  (m_cwaSpecial[u] > 2 * wHeight)  m_cwaSpecial[u] = 2 * wHeight;
					continue;

			case    UnderOffset:
			case    SubMoveY:
			case    Lowerd:

					if  ((short) m_cwaSpecial[u] < sBaseline - wHeight)
						m_cwaSpecial[u] = sBaseline - wHeight;
					continue;

			case    UnderSize:

					if  (m_cwaSpecial[u] > wHeight - (unsigned) sBaseline)
						 m_cwaSpecial[u] = wHeight = (unsigned) sBaseline;

					if  (!m_cwaSpecial[u]) m_cwaSpecial[u] = 1;
					continue;

			case    SuperSizeX:
			case    SubSizeX:
			case    SuperMoveX:
			case    SubMoveX:
			case    ItalicAngle:
					continue;   //  These aren't affected

			default:
					if  (m_cwaSpecial[u] > (unsigned) sBaseline)
					m_cwaSpecial[u] = sBaseline;
			}
		}

    //  Adjust the scaling factors if need be
    if  (m_wScaleDevice > m_wHeight - m_InternalLeading)  //m _cwaSpecial[InternalLeading])
        m_wScaleDevice = m_wHeight - m_InternalLeading;  //m _cwaSpecial[InternalLeading];
    if  (m_wMinScale > m_wHeight - m_InternalLeading)		//m _cwaSpecial[InternalLeading])
        m_wMinScale = m_wHeight - m_InternalLeading;		//m _cwaSpecial[InternalLeading];

    Changed();

    return  TRUE;
}

/*****************************************************************************

  CFontInfo::SetCharacterSet

  This one is a bit tricky- the new character set must be compatible with the
  GTT file associated with this font.  So we need to check it before we pass
  on it.

  ASSUMPTIONS:
  (1)  Things are bulletproof enough that the existing character set will
  already pass this test.

******************************************************************************/

BOOL    CFontInfo::SetCharacterSet(BYTE bNew) {
    unsigned u;

    switch  (bNew) {
    case    SHIFTJIS_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 932)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    case    HANGEUL_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 949)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    case    CHINESEBIG5_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 950)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    case    GB2312_CHARSET:
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            if  (m_pcgmTranslation -> PageID(u) == 936)
                break;  //  We're OK

        if  (u == m_pcgmTranslation -> CodePages())
            return  FALSE;
        break;

    default:
        //  Don't accept any DBCS codepages
        for (u = 0; u < m_pcgmTranslation -> CodePages(); u++)
            switch  (m_pcgmTranslation -> PageID(u)) {
            case    932:
            case    936:
            case    949:
            case    950:
            case    1361:   //  Johab- but it isn't in the converter!
                return  FALSE;
        }
    }

//    if  (m_bCharacterSet != bNew) {											// rm - need to replace this functionality
//        m_bCharacterSet = bNew;
        Changed();
//    }

    return  TRUE;
}

/******************************************************************************

  CFontInfo::SetSignificant

  This member is called to change the value of one of the significant code
  points (break character or default) encoded in the font.  Doing this
  correctly means getting the ANSI and UNICODE versions of the code point, and
  discarding any out-of-range values.

  This function returns an encoded value indicating success or cause of
  failure.

******************************************************************************/

WORD    CFontInfo::SetSignificant(WORD wItem, WORD wChar, BOOL bUnicode)
{
//    _ASSERT(wItem > Last && wItem <= Break);										// rm no longer needed

    if  (!bUnicode && wChar > 255) return  DoubleByte;

    CWaitCursor cwc;    //  Unfortunately, if not Unicode, this is slow

    CPtrArray               cpaGlyphs;
    CWordArray              cwa;
    CByteArray              cba;
    CDWordArray             cdaPage;

    m_pcgmTranslation -> Collect(cpaGlyphs);
    m_pcgmTranslation -> CodePages(cdaPage);

    for (int i = 0; i < cpaGlyphs.GetSize(); i++)
		{
        CGlyphHandle& cgh = *(CGlyphHandle *) cpaGlyphs[i];

        if  (bUnicode)
			{
            if  (cgh.CodePoint() == wChar)
				{
                cwa.Add(wChar);
                pccpi->Convert(cba, cwa, cdaPage[cgh.CodePage()]);
                break;
				}
			}
        else
			{
            if  (i)
                cwa.SetAt(0, cgh.CodePoint());
            else
                cwa.Add(cgh.CodePoint());

            pccpi->Convert(cba, cwa, cdaPage[cgh.CodePage()]);

            if  (cba.GetSize() == 1 && cba[0] == (BYTE) wChar)
                break;
            cba.RemoveAll();    //  So we can try again
			}
		}

    if  (i == cpaGlyphs.GetSize())	return  InvalidChar;
    if  (cba.GetSize() != 1)		return  DoubleByte;

    //  OK, we passed all of the hurdles

//	if (m_cwaSignificant[wItem] == cwa[0])  return  OK; //  Nothing changed!!!!			// rm ori - no longer needed, incorporated below


	if (wItem == Default)
		{
		if (m_IFIMETRICS.wcDefaultChar == cwa[0])  return  OK;						//  Nothing changed!!!!
		m_IFIMETRICS.wcDefaultChar = cwa[0];
		m_IFIMETRICS.chDefaultChar = cba[0];
		}
	else
		{
		m_IFIMETRICS.wcBreakChar = cwa[0];
		m_IFIMETRICS.chBreakChar = cba[0];
		}

//    m_cwaSignificant[wItem] = cwa[0];													// rm ori no longer needed
//    m_cbaSignificant[wItem] = cba[0];													// rm ori no longer needed
    Changed();
    return  OK;
}

/******************************************************************************

  CFontInfo::SetScaleLimit

  This member receives a proposed new maximum or minimum font size in device
  units.  First, it is compared to the existing size, for a quick exit.  Then
  we check to see that the ordering of the limits and the nominal size is
  preserved.  If it is not, we describe the problem and leave.  Otherwise, we
  update the value, and note that the font information has changed.

******************************************************************************/

WORD    CFontInfo::SetScaleLimit(BOOL bMax, WORD wNew) {

    if  (wNew == (bMax ? m_wMaxScale : m_wMinScale))
        return  ScaleOK;

    if  (bMax ? wNew <= m_wMinScale : wNew >= m_wMaxScale)
        return  Reversed;

    if  (bMax ? wNew < m_wScaleDevice : wNew > m_wScaleDevice)
        return  NotWindowed;

    if  (bMax)
        m_wMaxScale = wNew;
    else
        m_wMinScale = wNew;

    Changed();
    return  ScaleOK;
}

/******************************************************************************

  CFontInfo::SetDeviceEmHeight

  This member sets the units used for determing the conversion from font units
  (in which all metrics are given) to device units.  The checking is similar to
  that above, except here, we need to make sure that the font units are always
  of equal or greater resolution than the device units.

******************************************************************************/

WORD    CFontInfo::SetDeviceEmHeight(WORD wNew)
{

    if  (wNew == m_wScaleDevice)
        return  ScaleOK;

    if  (wNew > m_wHeight - m_InternalLeading)				//m _cwaSpecial[InternalLeading])
        return  Reversed;

    if  (wNew < m_wMinScale || wNew > m_wMaxScale)
        return  NotWindowed;

    m_wScaleDevice = wNew;

    Changed();
    return  ScaleOK;
}


/******************************************************************************

  CFontInfo::Load

  This member function loads the UFM file, finally initializing all of the
  tons of individual values we're trying to pretend we know how to manage
  here.

  IA64 : 1. conversion change loXXX in UNIFI_HDR to 8 byte aligned
         2. this part also changed accordingly
		 3. what if we load 32 bit UFM(not conversion in new source) in IA64?
			->1. Need to new converstion tool from UFM32 to UFM64
			->2. this tool Can't be embedded in MDT because this take some time 
					(loading ->checking -> storing after that structure on every loXXX)


******************************************************************************/

BOOL    CFontInfo::Load(bool bloadedbyworkspace /*= false*/)
{
	// Save the load location flag.

	m_bLoadedByWorkspace = bloadedbyworkspace ;

	// Prepare to open the file.

    CFile   cfUFM;
	char pszFullName[128] = "";
	if (!SUCCEEDED(StringCchCopyA(pszFullName, CCHOF(pszFullName), (const char *) m_cfn.FullName())))
	{
	    throw;
	}

	// Open the UFM file

    if  (!cfUFM.Open(m_cfn.FullName(), CFile::modeRead | CFile::shareDenyWrite)) {
		CString csMessage;
		csMessage.Format(IDS_LoadFailure, (LPCTSTR) m_cfn.FullName());
		AfxMessageBox(csMessage);
		return  FALSE;
	}

    // Get the length of the UFM file.  If it is too short to be correctly
	// formed, complain and return FALSE; ie, load failure.

	int i = cfUFM.GetLength() ;
	if (i < sizeof(UNIFM_HDR)) {
		CString csmsg ;
		csmsg.Format(IDS_UFMTooSmallError, m_cfn.NameExt()) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return FALSE ;
	} ;
	
	CByteArray  cbaUFM;			// Loaded with file's contents

	//  Try to load the file- proclaim defeat on any exception.

    try	{																			
        cbaUFM.SetSize(i);
        cfUFM.Read(cbaUFM.GetData(), (unsigned)cbaUFM.GetSize());
	}
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        CString csMessage;
        csMessage.Format(IDS_LoadFailure, (LPCTSTR) m_cfn.FullName());
        AfxMessageBox(csMessage);
        return  FALSE;
	}

//------------------------------------------------------------------------------------------------------------------------------------------
    PUNIFM_HDR  pufmh = (PUNIFM_HDR) cbaUFM.GetData();								//  UNIFM_HDR

	m_ulDefaultCodepage = (WORD) pufmh -> ulDefaultCodepage;		
    m_lGlyphSetDataRCID = (WORD) pufmh -> lGlyphSetDataRCID;							//  Store the GTT ID

//------------------------------------------------------------------------------------------------------------------------------------------
	union {		//raid 154639	
		  PBYTE       pbudi;
		  PUNIDRVINFO pudi;
		  };    
	pudi = (PUNIDRVINFO) (cbaUFM.GetData() + pufmh->loUnidrvInfo);		//  UNIDRVINFO
	if (!pudi -> dwSize || !pudi -> wXRes || !pudi -> wYRes)  //raid 154639	
		pbudi +=4;   // normally converion from 32 bit OS.
	memcpy((void *) &m_UNIDRVINFO, pudi, sizeof(UNIDRVINFO));							//	Bulk copy everything

    if  (pudi -> SelectFont.loOffset)    										//   Fill in the two invocation strings - why it is
        m_ciSelect.Init((PBYTE) pudi + pudi->SelectFont.loOffset,					//     the offset is NULL and the count is garbage
            pudi->SelectFont.dwCount);												//     when there is none is beyond me, but so be it.

    if  (pudi->UnSelectFont.loOffset)
        m_ciDeselect.Init((PBYTE) pudi + pudi->UnSelectFont.loOffset,
            pudi->UnSelectFont.dwCount);
 //------------------------------------------------------------------------------------------------------------------------------------------
																					//  IFIMETRICS																		
	union {
		  PBYTE       pbIFI;
		  PIFIMETRICS pIFI;
		  };

    pbIFI = cbaUFM.GetData() + pufmh->loIFIMetrics; 								//  Assign byte pointer to file IFIMETRICS data
	if (!pIFI -> cjThis || !pIFI ->chLastChar)  //raid 154639	
		pbIFI +=4;
	
	memcpy((void *) &m_IFIMETRICS, pIFI, sizeof(IFIMETRICS) );							//	Bulk copy everything

	if (     !(m_IFIMETRICS.fsSelection & FM_SEL_REGULAR)								//  If font isn't defined as regular, or bold,
		 &&  !(m_IFIMETRICS.fsSelection & FM_SEL_BOLD)  )								//   then just set it to regular.
		m_IFIMETRICS.fsSelection |= FM_SEL_REGULAR;

																						//-----------------------------------------------------
    m_csUnique = (PWSTR) (pbIFI + pIFI->dpwszUniqueName);								//  dpwszUniqueName
    m_csStyle  = (PWSTR) (pbIFI + pIFI->dpwszStyleName);								//  dpwszStyleName
    m_csFace   = (PWSTR) (pbIFI + pIFI->dpwszFaceName);									//  dpwszFaceName
																						//-----------------------------------------------------									
    m_csaFamily.RemoveAll();															//  Just in case it isn't clean

    PWSTR   pwstrFamily = (PWSTR) (pbIFI + pIFI->dpwszFamilyName);						//  dpwszFamilyName
    CString csWork(pwstrFamily);														//  Let CString handle the Unicode conversions for us,	
    m_csaFamily.Add(csWork);
    pwstrFamily += 1 + wcslen(pwstrFamily);

    if  (pIFI->flInfo & FM_INFO_FAMILY_EQUIV)
        while   (*pwstrFamily)
			{
            csWork = pwstrFamily;
            m_csaFamily.Add(csWork);
            pwstrFamily += 1 + wcslen(pwstrFamily);
			}
																						//-----------------------------------------------------
	m_ItalicAngle	  = (WORD) (gdConvertRadToDegree *									//  m_ItalicAngle
					    atan2((double) pIFI->ptlCaret.x, (double) pIFI->ptlCaret.y));

    m_wHeight		  = m_IFIMETRICS.fwdWinAscender	 + m_IFIMETRICS.fwdWinDescender;	//  m_wHeight		// rm new
	m_InternalLeading = m_wHeight - m_IFIMETRICS.fwdUnitsPerEm;							//  fwdUnitsPerEm	// rm new

 //------------------------------------------------------------------------------------------------------------------------------------------
	
	// Try to find and load the GTT referenced by this UFM iff this UFM is being
	// loaded directly.

	if (!m_bLoadedByWorkspace)
		if (!FindAndLoadGTT()) {
			CString csmsg;
			csmsg.Format(IDS_NoGTTForUFMFatalError, m_cfn.NameExt()) ;
			AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
			return FALSE ;
		} ;

	// DEAD_BUG:	This is a good place to add code to find and associate the UFM
	//			with its GTT so that the UFM doesn't have to be loaded twice
	//			when the UFM is loaded as part of a workspace load.
    //
	//  best solution is just skipping EXTTEXTMETRIC, but almost no influence.
 //------------------------------------------------------------------------------------------------------------------------------------------
	if ( !m_pcgmTranslation && m_bLoadedByWorkspace )
		return FALSE;
		//  EXTTEXTMETRIC

	for (i = 0; i < 26; i++)														// Preload zeroes into the m_EXTTEXTMETRIC structure.
		*(SHORT *)((SHORT *)&m_EXTTEXTMETRIC + i) = 0;

//raid 154639	
	union {
		  PBYTE           pbetm;
		  PEXTTEXTMETRIC  petm;
		  };

    petm = (PEXTTEXTMETRIC) (pufmh->loExtTextMetric ?					//  Get pointer - if EXTTEXTMETRIC data exists
                           (cbaUFM.GetData() + pufmh->loExtTextMetric) : NULL);
    if  (petm)
		{
		if (!petm -> emSize || !petm -> emPointSize)
			pbetm += 4;

		m_fSave_EXT = TRUE;

		m_fEXTTEXTMETRIC = TRUE;

		memcpy((void *) &m_EXTTEXTMETRIC, petm, sizeof(EXTTEXTMETRIC) );				// Bulk copy everything

        m_wMinScale   = m_EXTTEXTMETRIC.emMinScale;
        m_wMaxScale   = m_EXTTEXTMETRIC.emMaxScale;
        m_Lowerd	  = m_EXTTEXTMETRIC.emLowerCaseAscent;
        m_Lowerp	  = m_EXTTEXTMETRIC.emLowerCaseDescent;
		m_ItalicAngle = m_EXTTEXTMETRIC.emSlant;
//        m_bfScaleOrientation = (BYTE) m_EXTTEXTMETRIC.emOrientation;
        m_wScaleDevice = m_EXTTEXTMETRIC.emMasterHeight;
		}

//------------------------------------------------------------------------------------------------------------------------------------------

	if  (pIFI->dpFontSim)																//  FONTSIM, if any.
    	{
        union {
              PBYTE   pbfs;
              FONTSIM *pfs;
			  };

        pbfs = pbIFI + pIFI -> dpFontSim;

		if (m_pcfdBold) 	delete  m_pcfdBold;														//  If we're reloading, clean these up!			
        if (m_pcfdItalic)	delete  m_pcfdItalic;
        if (m_pcfdBoth)		delete  m_pcfdBoth;

        if (pfs->dpBold)        m_pcfdBold   = new CFontDifference(pbfs + pfs->dpBold, this);		//  Bold simulation
        if (pfs->dpItalic)	    m_pcfdItalic = new CFontDifference(pbfs + pfs->dpItalic, this);		//  Italic Simulation
        if (pfs->dpBoldItalic)	m_pcfdBoth   = new CFontDifference(pbfs + pfs->dpBoldItalic, this);	//  Bold Italic Simulation
		}

//------------------------------------------------------------------------------------------------------------------------------------------
																						
    //if  (m_pcgmTranslation && (m_loWidthTable = pufmh -> loWidthTable))					//  WIDTH TABLE, but only if there is an associated GTT.
    
	if  (m_pcgmTranslation && pufmh->loWidthTable ) //pufmh->loWidthTable)											//  WIDTH TABLE, but only if there is an associated GTT.
		{
        union {
              PBYTE       pbwt;
              PWIDTHTABLE pwt;
			  };

        pbwt = cbaUFM.GetData() + pufmh -> loWidthTable;
// dwSize has problem ; there are case: dwAdd_ in pfm2ifi has not 4 byte, so dwSize has number in some case
// data before wGlyphCount is dwRunNum: impossible to beyond ff ff 00 00 (65536), as long as dwAdd is 4,2 not 1 & dwRun > 256 		
// nicer solution is required : BUG_BUG.
		if( !pwt ->dwSize || !pwt ->WidthRun ->wGlyphCount)  
			pbwt += 4;

        m_pcgmTranslation -> Collect(m_cpaGlyphs);											//  Collect all the handles
				m_pcgmTranslation -> Collect(m_cpaOldGlyphs);  //244123	
		//244123	// when delete glyph, memory is occupied with dddd, so we have to save original data in here
		m_cwaOldGlyphs.SetSize(m_cpaOldGlyphs.GetSize()) ;
		for (  i = 0 ; i < m_cpaOldGlyphs.GetSize() ; i ++ ) { 
			CGlyphHandle&  cghThis = *(CGlyphHandle *) m_cpaOldGlyphs[i];
			m_cwaOldGlyphs.SetAt(i,cghThis.CodePoint() ) ;
		}

        m_cwaWidth.RemoveAll();
        if (m_cpaGlyphs.GetSize() > 0)
			m_cwaWidth.InsertAt(0, 0, m_cpaGlyphs.GetSize());


		unsigned uWidth = (unsigned)m_cwaWidth.GetSize();												// rm fix VC compiler problem?
		unsigned uWidthIdx ;

        for (unsigned u = 0; u < pwt->dwRunNum; u++)
			{
            PWORD   pwWidth = (PWORD) (pbwt + pwt->WidthRun[u].loCharWidthOffset);

            for (unsigned   uGlyph = 0; uGlyph < pwt->WidthRun[u].wGlyphCount; uGlyph++)
				{
				// For whatever reason, there are times when the index value is
				// < 0 or > uWidth.  An AV would occur if m_cwaWidth were allowed
				// to be indexed by such a value.  Just keep this from happening
				// for now.  A better fix is needed.  BUG_BUG : won't fix

				uWidthIdx = uGlyph + -1 + pwt->WidthRun[u].wStartGlyph ;					//  Glyph handles start at 1, not 0!
				if ((int) uWidthIdx < 0) {
					//AfxMessageBox("Negative width table index") ;
					//TRACE("***Negative width table index (%d) found in %s.  Table size=%d  uGlyph=%d  wGlyphCount=%d  wStartGlyph=%d  u=%d  dwRunNum=%d\n", uWidthIdx, Name(), uWidth, uGlyph, pwt->WidthRun[u].wGlyphCount, pwt->WidthRun[u].wStartGlyph, u, pwt->dwRunNum) ;
					continue ;
				} else if (uWidthIdx >= uWidth) {
					//AfxMessageBox("Width table index (%d) > table size") ;
					//TRACE("***Width table index (%d) > table size (%d) found in %s.  Table size=%d  uGlyph=%d  wGlyphCount=%d  wStartGlyph=%d  u=%d  dwRunNum=%d\n", uWidthIdx, uWidth, Name(), uWidth, uGlyph, pwt->WidthRun[u].wGlyphCount, pwt->WidthRun[u].wStartGlyph, u, pwt->dwRunNum) ;
					break ;												//  rm fix VC IDE compiler problem?
				} ;

                //m_cwaWidth[uGlyph + -1 + pwt->WidthRun[u].wStartGlyph] = *pwWidth++;		//  Glyph handles start at 1, not 0!
                m_cwaWidth[uWidthIdx] = *pwWidth++;											
				}
			}
		}

//------------------------------------------------------------------------------------------------------------------------------------------
    m_csoaKern.RemoveAll();																//  KERNING TABLE, if any
 
    if  (pufmh -> loKernPair)
		{
		union {
              PBYTE       pbkd;
              PKERNDATA   pkd;
			  };

        pkd = (PKERNDATA) (cbaUFM.GetData() + pufmh -> loKernPair);
		if (!pkd ->dwSize || !pkd->KernPair ->wcSecond || !pkd->KernPair ->wcFirst)
			pbkd += 4;

		unsigned rm = pkd->dwKernPairNum;													// rm - debugging
        for (unsigned u = 0; u < pkd -> dwKernPairNum; u++)
            m_csoaKern.Add(new CKern(pkd -> KernPair[u]));
		}
//------------------------------------------------------------------------------------------------------------------------------------------

    return  TRUE;																		//  Return triumphant to whoever deigned to need this service.
}


/*****************************************************************************

  CFontInfo::FindAndLoadGTT

  This function is called when a UFM is being loaded directly.  Its job is to
  find the associated GTT, load it, and set the UFM's pointer to this GTT.  If
  this fails, the user is told that no changes to this UFM can be saved if he
  decides to continue loading it.

  True is returned if a GTT was found and loaded.  Return false if the GTT
  wasn't loaded and the user doesn't want to continue to load the UFM.

******************************************************************************/

bool CFontInfo::FindAndLoadGTT()
{
	// Load a predefined GTT/codepage if that is what is referenced by the UFM.

	CGlyphMap* pcgm ;
	pcgm = CGlyphMap::Public((WORD)Translation(), (WORD) m_ulDefaultCodepage, 0,
							 GetFirst(), GetLast()) ;
    if (pcgm) {
        SetTranslation(pcgm) ;
		m_pcgmTranslation->NoteOwner(*m_pcdOwner) ;	// Is this right/necessary?
		m_bLoadedByWorkspace = true ;
		return true ;
	} ;

	// Looks like no easy way out.  Now I need to try to find and read the
	// corresponding RC file so that it can be read to find a filespec for this
	// UFM's GTT.  First, build a file spec for the RC file.  Assume it is in
	// the directory above the one containing this UFM.

	CString csrcfspec(FilePath()) ;
	if (csrcfspec.GetLength() > 3)
		csrcfspec = csrcfspec.Left(csrcfspec.GetLength() - 1) ;
	csrcfspec = csrcfspec.Left(csrcfspec.ReverseFind(_T('\\')) + 1) ;
	CString csrcpath(csrcfspec.Left(csrcfspec.GetLength() - 1)) ;
	csrcfspec += _T("*.rc") ;

	// I don't know the name of the RC file so look for it in the specified
	// directory.  Assume that the file is the first RC file in the directory
	// that is NOT called "common.rc".

	CFileFind cff ;
	CString cstmp ;
	BOOL bfound = cff.FindFile(csrcfspec) ;
	bool breallyfound = false ;
	while (bfound) {
		bfound = cff.FindNextFile() ;
		cstmp = cff.GetFileTitle() ;
		cstmp.MakeLower() ;
		if (cstmp != _T("common")) {
			csrcfspec = cff.GetFilePath() ;
			breallyfound = true ;
			break ;
		} ;
	} ;

	// Prepare to ask the user what to do if any of the next few steps fail.

	CString csnext ;
	csnext.Format(IDS_StandAloneFontLoad, m_cfn.NameExt()) ;

	// If the RC file is not found, ...
	
	if (!breallyfound) {
		// ...Ask the user if he wants to tell us where it is.  If he says no,
		// ask if he want to stop or open it restricted.

		cstmp.Format(IDS_RCForUFMPrompt, m_cfn.NameExt()) ;
		if (AfxMessageBox(cstmp, MB_YESNO+MB_ICONQUESTION) == IDNO)
			return (AfxMessageBox(csnext, MB_YESNO+MB_ICONQUESTION) == IDYES) ;

		// Prompt the use for the path to the RC file.  If he cancels, ask if
		// he want to stop or open it restricted.

		// Prompt the user for a new RC file.  If the operation is canceled,
		// ask if he wants to stop or open it restricted.

		cstmp.LoadString(IDS_CommonRCFile) ;
		CFileDialog cfd(TRUE, _T(".RC"), NULL,
						OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, cstmp) ;
		cfd.m_ofn.lpstrInitialDir = csrcpath ;
		if (cfd.DoModal() != IDOK)
			return (AfxMessageBox(csnext, MB_YESNO+MB_ICONQUESTION) == IDYES) ;

		// Prepare to check the new filespec

		csrcfspec = cfd.GetPathName() ;
		csrcpath = csrcfspec.Left(csrcfspec.ReverseFind(_T('\\'))) ;
	} ;

	// I've got an RC filespec now so try to open it and read its contents.
	// If the operation fails, ask if he wants to stop or open it restricted.

    CStringArray csarclines ;
    if  (!LoadFile(csrcfspec, csarclines))
		return (AfxMessageBox(csnext, MB_YESNO+MB_ICONQUESTION) == IDYES) ;

	// Now try to find the line in the RC file that contains the ID for this
	// UFM's GTT.  If the operation fails, ask if he wants to stop or open it
	// restricted.

	for (int n = 0 ; n < csarclines.GetSize() ; n++) {
		if (csarclines[n].Find(_T("RC_GTT")) == -1)
			continue ;
		if (atoi(csarclines[n]) == Translation())
			break ;
	} ;
	if (n >= csarclines.GetSize())
		return (AfxMessageBox(csnext, MB_YESNO+MB_ICONQUESTION) == IDYES) ;

	// The GTT filespec in the RC file should be relative to the location of
	// the RC file.  So, combine the filespec with the RC file path to get
	// the complete filespec for the GTT file.

	CString csgttfspec ;
	int nloc = csarclines[n].ReverseFind(_T(' ')) ;
	csgttfspec = csarclines[n].Right(csarclines[n].GetLength() - nloc - 1) ;
	csgttfspec = csrcpath + _T("\\") + csgttfspec ;

	// Allocate a new Glyph class instance, initialize it, and load it.  If the
	// operations fails, ask if the user wants to stop or open it restricted.

	pcgm = new CGlyphMap ;
	pcgm->nSetRCID((int) Translation()) ;
	pcgm->NoteOwner(*m_pcdOwner) ;	// Is this right/necessary?
	if (!pcgm->Load(csgttfspec))
		return (AfxMessageBox(csnext, MB_YESNO+MB_ICONQUESTION) == IDYES) ;

	// The GTT has been loaded so set the UFM's GTT pointer variable, set
	// m_bLoadedByWorkspace since everything has been fixed up as if it had
	// been loaded from a workspace, and return true to indicate success.

	SetTranslation(pcgm) ;
	m_bLoadedByWorkspace = true ;
	return true ;
}


/*****************************************************************************

  CUniString class

  This is a little helper class that will convert a CString to a UNICODE
  string, and take care of cleanup, etc., so the font storage code doesn't get
  any messier than it already will be.

******************************************************************************/

class CUniString : public CWordArray
{
public:
    CUniString(LPCSTR lpstrInit);
    operator PCWSTR() const { return GetData(); }
    unsigned    GetSize() const { return sizeof (WCHAR) * (unsigned) CWordArray::GetSize(); }

    void    Write(CFile& cf)  { cf.Write(GetData(), GetSize()); }
};

CUniString::CUniString(LPCSTR lpstrInit)
{
    SetSize(MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpstrInit, -1, NULL, 0));
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpstrInit, -1, GetData(), GetSize());
}





/*****************************************************************************

  CFontInfo::Store

  This member function stores the UFM format information in the specified file
  by assembling it from the information we have cached in this class.

//	typedef struct _UNIDRVINFO
//	{
//	    DWORD   dwSize;			// Size of this structure
//	    DWORD   flGenFlags;		// General flags
//	    WORD    wType;			// Type of the font like CAPSL
//	    WORD    fCaps;			// Font Capability flags
//	    WORD    wXRes;			// Horizontal resolution of the font
//	    WORD    wYRes;			// Vertical Resolution of the font
//	    short   sYAdjust;		// Vertical Cursor position Adjustment
//	    short   sYMoved;		// Adjustment to Y position after printing
//	    WORD    wPrivateData; 	// For backward compatibility, don't show in UI.
//	    short   sShift; 		// For backward compatibility, don't show in UI.	
//	    INVOCATION SelectFont;
//	    INVOCATION UnSelectFont;
//	    WORD    wReserved[4];
//	}  UNIDRVINFO, *PUNIDRVINFO;
//
//
//  And now, ladies and gentlemen, direct from the pages of WINDDI.H,
//  I present to you:
//
//  "rather than adding the fields of IFIEXTRA  to IFIMETRICS itself
//   we add them as a separate structure. This structure, if present at all,
//   lies below IFIMETRICS in memory.
//   If IFIEXTRA is present at all, ifi.cjIfiExtra (formerly ulVersion)
//   will contain size of IFIEXTRA including any reserved fields.
//   That way ulVersion = 0 (NT 3.51 or less) printer minidrivers
//   will work with NT 4.0."
//
//	typedef struct _IFIEXTRA
//	{
//	    ULONG    ulIdentifier;   // used for Type 1 fonts only
//	    PTRDIFF  dpFontSig;      // nontrivial for tt only, at least for now.
//	    ULONG    cig;            // maxp->numGlyphs, # of distinct glyph indicies
//	    PTRDIFF  dpDesignVector; // offset to design vector for mm instances
//	    PTRDIFF  dpAxesInfoW;    // offset to full axes info for base mm font
//	    ULONG    aulReserved[1]; // in case we need even more stuff in the future
//	} IFIEXTRA, *PIFIEXTRA;
//	
******************************************************************************/

BOOL    CFontInfo::Store(LPCTSTR lpstrFile, BOOL bStoreFormWokspace)
{
	// Fonts loaded standalone cannot be saved because m_pcgmTranslation is not
	// set.  Tell the user and exit.  TRUE is returned to keep this from
	// happening again.

	if (!m_bLoadedByWorkspace) {
		CString csmsg ;
		csmsg.LoadString(IDS_CantStoreStandAlone) ;
		AfxMessageBox(csmsg) ;
		return TRUE ;
	} ;
    
	DWORD dwAdd_UniDrv = 0;
	DWORD dwAdd_IFI = 0;
	DWORD dwAdd_ExtTextM = 0;
	DWORD dwAdd_WidthTable = 0;
	DWORD dwAdd_KerPair = 0;

//	DWORD dwAdd_SelectedFont;
//	DWORD dwAdd_UnSelectedFont;

	static const BYTE InsertZero[8] = {0,0,0,0,0,0,0,0};

	const short OS_BYTE = 0x08;
	// If a UFM loaded from a workspace can't be saved normally because it did
	// not have a valid GTT/CP, call another routine to handle this case and
	// return whatever it returns.

	if (m_bWSLoadButNoGTTCP)
		return StoreGTTCPOnly(lpstrFile) ;

    try {																		//  Any exxceptions, we'll just fail gracelessly

        CFile   cfUFM(lpstrFile,												//  Create/open the output file.
            CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive);
//------------------------------------------------------------------------------------------------------------------------------------------
																				// UNIFM_HDR
        UNIFM_HDR  ufmh = {sizeof ufmh, UNIFM_VERSION_1_0, 0,										// Create the output UNIFM_HDR
            (short) m_lGlyphSetDataRCID, sizeof ufmh};												// rm new
																		

//		int q = m_pcgmTranslation -> m_csoaCodePage.GetSize();										// rm test
//		int r = m_pcgmTranslation -> CodePages();													// rm test

//        ufmh.ulDefaultCodepage = m_pcgmTranslation -> CodePage(0).Page();							// rm test

		// Previously, the default code page in the UFM's GTT was always saved.
		// This ignored the user's changes in the UFM editor.  Now, the user's
		// choice is saved if it is valid (other checking done in other places).
		// Otherwise, the GTT's default code page is used when there is a GTT
		// associated with the UFM.  If not, assert.

		if (m_ulDefaultCodepage > 0)
			ufmh.ulDefaultCodepage = m_ulDefaultCodepage ;
		else if (m_pcgmTranslation)
			ufmh.ulDefaultCodepage = m_pcgmTranslation->DefaultCodePage() ;
		else
			ASSERT(0) ;
        //ufmh.ulDefaultCodepage = m_pcgmTranslation -> DefaultCodePage();							// Use Glyph Map default code page if at all possible.

		memset((PBYTE) ufmh.dwReserved, 0, sizeof ufmh.dwReserved);									// Zero fill reserved bytes.

//------------------------------------------------------------------------------------------------------------------------------------------
		ufmh.loUnidrvInfo = ufmh.dwSize;														// UNIDRVINFO
		if (dwAdd_UniDrv = ufmh.loUnidrvInfo & 0x07) {
			dwAdd_UniDrv = OS_BYTE - dwAdd_UniDrv;
			ufmh.loUnidrvInfo += dwAdd_UniDrv;
		}

        m_UNIDRVINFO.dwSize = sizeof (UNIDRVINFO);

        m_UNIDRVINFO.SelectFont.loOffset = m_ciSelect.Length() ? m_UNIDRVINFO.dwSize : 0;		// Invocation Strings affect the size,
/*			if (dwAdd_SelectedFont = m_UNIDRVINFO.SelectFont.loOffset & 0x07) {
			dwAdd_SelectedFont += OS_BYTE - dwAdd_SelectedFont;
			m_UNIDRVINFO.SelectFont.loOffset += dwAdd_SelectedFont;
		} */
		m_UNIDRVINFO.dwSize += m_UNIDRVINFO.SelectFont.dwCount = m_ciSelect.Length();			//  so get their specifics and
        
		m_UNIDRVINFO.UnSelectFont.loOffset = m_ciDeselect.Length() ? m_UNIDRVINFO.dwSize : 0;	//  store them, updating the affected
/*			if (dwAdd_UnSelectedFont = m_UNIDRVINFO.UnSelectFont.loOffset & 0x07) {
			dwAdd_UnSelectedFont += OS_BYTE - dwAdd_UnSelectedFont;
			ufmh.loUnidrvInfo += dwAdd_UnSelectedFont;
		} */
		m_UNIDRVINFO.dwSize += m_UNIDRVINFO.UnSelectFont.dwCount = m_ciDeselect.Length();		//  size fields as we go.

        unsigned    uAdjustUDI = (4 - (m_UNIDRVINFO.dwSize % 4)) % 4;	// you can delte this							// Pad this to keep everything
																									//  DWORD aligned in the file image!
        ufmh.loIFIMetrics = ufmh.dwSize += m_UNIDRVINFO.dwSize += uAdjustUDI + dwAdd_UniDrv;						//  Store IFIMETRICS offset
		
		if (dwAdd_IFI = ufmh.loIFIMetrics & 0x07) {
			dwAdd_IFI = OS_BYTE - dwAdd_IFI;
			ufmh.loIFIMetrics += dwAdd_IFI;
        }
		memset((PSTR) m_UNIDRVINFO.wReserved, 0, sizeof m_UNIDRVINFO.wReserved);					//  zero out reserved section.

//------------------------------------------------------------------------------------------------------------------------------------------

        IFIEXTRA    ifie = {0, 0, m_pcgmTranslation->Glyphs(), 0, 0, 0};		// Create the IFIEXTRA structure.
//------------------------------------------------------------------------------------------------------------------------------------------
																				// IFIMETRICS

        IFIMETRICS ifi = {sizeof ifi + sizeof ifie, sizeof ifie};				// Create the output IFIMETRICS structure, being sure to add
																				//  in the size of the IFIMETRICS structure, as well as the
																				//  size of the IFIEXTRA structure.

//	int iSizeOf_IFIMETRICS = sizeof(IFIMETRICS);

//	memcpy((void *) &ifi, (void *) &m_IFIMETRICS, iSizeOf_IFIMETRICS );			// IFIMETRICS structure

																				// Store the IFIMETRICS data

        ifi.lEmbedId = ifi.lItalicAngle = ifi.lCharBias = 0;					//

		ifi.dpCharSets = 0;														//  dpCharSets = 0 for now

        ifi.jWinCharSet			  = m_IFIMETRICS.jWinCharSet;					//  jWinCharSet				// rm new
        ifi.jWinPitchAndFamily	  = m_IFIMETRICS.jWinPitchAndFamily;			//  jWinPitchAndFamily		// rm new
        ifi.usWinWeight			  = m_IFIMETRICS.usWinWeight;					//  usWinWeight				// rm new
		ifi.flInfo			 	  = m_IFIMETRICS.flInfo;						//  flInfo					// rm new
        ifi.fsSelection			  = m_IFIMETRICS.fsSelection;					//  fsSelection				// rm new
        ifi.fsType				  = FM_NO_EMBEDDING;							//  fsType					// rm new

        ifi.fwdUnitsPerEm		  = m_IFIMETRICS.fwdUnitsPerEm;					//  fwdUnitsPerEm			// rm new
        ifi.fwdLowestPPEm		  = m_IFIMETRICS.fwdLowestPPEm;					//  fwdLowestPPEm			// rm new

		ifi.fwdWinAscender		  = m_IFIMETRICS.fwdWinAscender;				//  fwdWinAscender			// rm new
		ifi.fwdWinDescender		  = m_IFIMETRICS.fwdWinDescender;				//  fwdWinDescender			// rm new

		ifi.fwdMacAscender		  = m_IFIMETRICS.fwdWinAscender;				//  fwdMacAscender			// rm replaced
		ifi.fwdMacDescender		  = m_IFIMETRICS.fwdWinAscender - m_wHeight;	//  fwdMacDescender			// rm replaced

		ifi.fwdMacLineGap		  = m_IFIMETRICS.fwdMacLineGap;					//  fwdMacLineGap

        ifi.fwdTypoAscender		  = m_IFIMETRICS.fwdWinAscender;				//  fwdTypoAscender			// rm replaced
        ifi.fwdTypoDescender	  = m_IFIMETRICS.fwdWinAscender - m_wHeight;	//  fwdTypoDescender		// rm replaced

        ifi.fwdTypoLineGap		  = m_IFIMETRICS.fwdMacLineGap;					//  fwdTypoLineGap

        ifi.fwdAveCharWidth		  = m_IFIMETRICS.fwdAveCharWidth;				//  fwdAveCharWidth			// rm new
        ifi.fwdMaxCharInc		  = m_IFIMETRICS.fwdMaxCharInc;					//  fwdMaxCharInc			// rm new


        ifi.fwdCapHeight		  = m_IFIMETRICS.fwdCapHeight;					//  fwdCapHeight			// rm new
        ifi.fwdXHeight			  = m_IFIMETRICS.fwdXHeight;					//  fwdXHeight				// rm new
        ifi.fwdSubscriptXSize     = m_IFIMETRICS.fwdSubscriptXSize;				//  fwdSubscriptXSize		// rm new
        ifi.fwdSubscriptYSize	  = m_IFIMETRICS.fwdSubscriptYSize;				//  fwdSubscriptYSize		// rm new
        ifi.fwdSubscriptXOffset   = m_IFIMETRICS.fwdSubscriptXOffset;			//  fwdSubscriptXOffset		// rm new
        ifi.fwdSubscriptYOffset   = m_IFIMETRICS.fwdSubscriptYOffset;			//  fwdSuperscriptYOffset	// rm new
        ifi.fwdSuperscriptXSize   = m_IFIMETRICS.fwdSuperscriptXSize;			//  fwdSuperscriptXSize		// rm new
        ifi.fwdSuperscriptYSize   = m_IFIMETRICS.fwdSuperscriptYSize;			//  fwdSubscriptYOffset		// rm new
        ifi.fwdSuperscriptXOffset = m_IFIMETRICS.fwdSuperscriptXOffset;			//  fwdSuperscriptXOffset	// rm new
        ifi.fwdSuperscriptYOffset = m_IFIMETRICS.fwdSuperscriptYOffset;			//  fwdSuperscriptYOffset	// rm new


        ifi.fwdUnderscoreSize	  = m_IFIMETRICS.fwdUnderscoreSize;				//	fwdUnderscoreSize		// rm new
        ifi.fwdUnderscorePosition = m_IFIMETRICS.fwdUnderscorePosition;			//	fwdUnderscorePosition	// rm new
        ifi.fwdStrikeoutSize	  = m_IFIMETRICS.fwdStrikeoutSize;				//  fwdStrikeoutSize		// rm new
        ifi.fwdStrikeoutPosition  = m_IFIMETRICS.fwdStrikeoutPosition;			//  fwdStrikeoutPosition	// rm new
//------------------------------------------------------------------------------------------------------------------------------------------

        ifi.chFirstChar			  = m_IFIMETRICS.chFirstChar;					//  chFirstChar				// rm new
        ifi.chLastChar			  = m_IFIMETRICS.chLastChar;					//  chLastChar				// rm new
        ifi.chDefaultChar		  = m_IFIMETRICS.chDefaultChar;					//  chDefaultChar			// rm new
        ifi.chBreakChar			  = m_IFIMETRICS.chBreakChar;					//  chBreakChar				// rm new

        ifi.wcFirstChar			  = m_IFIMETRICS.wcFirstChar;					//  wcFirstChar				// rm new
        ifi.wcLastChar			  = m_IFIMETRICS.wcLastChar;					//  wcLastChar				// rm new
        ifi.wcDefaultChar		  = m_IFIMETRICS.wcDefaultChar;					//  wcDefaultChar			// rm new
        ifi.wcBreakChar			  = m_IFIMETRICS.wcBreakChar;					//  wcBreakChar				// rm new

        ifi.ptlBaseline.x		  = m_IFIMETRICS.ptlBaseline.x;					//  ptlBaseline.x
        ifi.ptlBaseline.y		  = m_IFIMETRICS.ptlBaseline.y;					//  ptlBaseline.y

        ifi.ptlAspect.x			  = m_IFIMETRICS.ptlAspect.x;					//  ptlAspect.x				// rm new
        ifi.ptlAspect.y			  = m_IFIMETRICS.ptlAspect.y;					//  ptlAspect.y				// rm new

//------------------------------------------------------------------------------------------------------------------------------------------
//      ifi.ptlBaseline.x		  = 1;											//  ptlBaseline.x
//      ifi.ptlBaseline.y		  = 0;											//  ptlBaseline.y
//
//      ifi.ptlAspect.x			  = m_UNIDRVINFO.wXRes;							//  ptlAspect.x				// rm new
//      ifi.ptlAspect.y			  = m_UNIDRVINFO.wYRes;							//  ptlAspect.y				// rm new
//------------------------------------------------------------------------------------------------------------------------------------------

        ifi.ptlCaret.x			  = m_IFIMETRICS.ptlCaret.x;					//  ptlCaret.x				// rm new
        ifi.ptlCaret.y			  = m_IFIMETRICS.ptlCaret.y;					//  ptlCaret.y				// rm new
		

//        ifi.ptlCaret.x		  = m_ItalicAngle ? (long) ((double) 10000.0 * 							//  ptlCaret.x			// rm ori
//											tan(((double) m_ItalicAngle) / gdConvertRadToDegree)) : 0;
//        ifi.ptlCaret.y		  = m_ItalicAngle ? 10000 : 1;											//  ptlCaret.y			// rm ori

//------------------------------------------------------------------------------------------------------------------------------------------
        memcpy(ifi.achVendId, "Unkn", 4);										//  achVendId				// rm ori
//------------------------------------------------------------------------------------------------------------------------------------------

        ifi.cKerningPairs		  = m_csoaKern.GetSize();						//  cKerningPairs			// rm ori

//------------------------------------------------------------------------------------------------------------------------------------------
        ifi.rclFontBox.left		  = m_IFIMETRICS.rclFontBox.left;				//  rclFontBox.left			// rm new
        ifi.rclFontBox.top		  = m_IFIMETRICS.rclFontBox.top;				//  rclFontBox.top			// rm new
        ifi.rclFontBox.right	  = m_IFIMETRICS.rclFontBox.right;				//  rclFontBox.right		// rm new
        ifi.rclFontBox.bottom	  = m_IFIMETRICS.rclFontBox.bottom;				//  rclFontBox.bottom		// rm new

//------------------------------------------------------------------------------------------------------------------------------------------
        ifi.ulPanoseCulture		  = FM_PANOSE_CULTURE_LATIN;					//  ulPanoseCulture			// rm ori
//------------------------------------------------------------------------------------------------------------------------------------------

																				//  panose .bWeight			// rm ori
        ifi.panose.bWeight	      = (m_IFIMETRICS.usWinWeight >= FW_BOLD) ? PAN_WEIGHT_BOLD :
                                    (m_IFIMETRICS.usWinWeight > FW_EXTRALIGHT) ? PAN_WEIGHT_MEDIUM : PAN_WEIGHT_LIGHT;

        ifi.panose.bFamilyType	    = m_IFIMETRICS.panose.bFamilyType;			//  panose	// rm new
		ifi.panose.bSerifStyle      = m_IFIMETRICS.panose.bSerifStyle;
        ifi.panose.bProportion      = m_IFIMETRICS.panose.bProportion;
		ifi.panose.bContrast        = m_IFIMETRICS.panose.bContrast;
        ifi.panose.bStrokeVariation = m_IFIMETRICS.panose.bStrokeVariation;
		ifi.panose.bArmStyle		= m_IFIMETRICS.panose.bArmStyle;
        ifi.panose.bLetterform		= m_IFIMETRICS.panose.bLetterform;
		ifi.panose.bMidline			= m_IFIMETRICS.panose.bMidline;
        ifi.panose.bXHeight			= m_IFIMETRICS.panose.bXHeight;


//        ifi.panose.bFamilyType = ifi.panose.bSerifStyle = 					//  panose	// rm ori
//            ifi.panose.bProportion = ifi.panose.bContrast =
//            ifi.panose.bStrokeVariation = ifi.panose.bArmStyle =
//            ifi.panose.bLetterform = ifi.panose.bMidline =
//            ifi.panose.bXHeight = PAN_ANY;

//------------------------------------------------------------------------------------------------------------------------------------------
																				//  Convert and "place" the various name strings
        CUniString  cusUnique(m_csUnique), cusStyle(m_csStyle),
            cusFace(m_csFace), cusFamily(m_csaFamily[0]);

        ifi.dpwszFamilyName = ifi.cjThis;
        for (int i = 1; i < m_csaFamily.GetSize(); i++)
			{
			CUniString cusWork(m_csaFamily[i]);
			cusFamily.Append(cusWork);
			}

        if  (m_csaFamily.GetSize() > 1)
			{
            cusFamily.Add(0);
            ifi.flInfo |= FM_INFO_FAMILY_EQUIV;
			}

        ifi.cjThis += cusFamily.GetSize();

        ifi.dpwszFaceName = ifi.cjThis;
        ifi.cjThis += cusFace.GetSize();
        ifi.dpwszUniqueName = ifi.cjThis;
        ifi.cjThis += cusUnique.GetSize();
        ifi.dpwszStyleName = ifi.cjThis;
        ifi.cjThis += cusStyle.GetSize();
//------------------------------------------------------------------------------------------------------------------------------------------
																			    //  The next field must be DWORD aligned, so see what padding
																			    //  is needed.

        unsigned    uAdjustIFI = (sizeof ifi.cjThis -
            (ifi.cjThis % sizeof ifi.cjThis)) % sizeof ifi.cjThis;

        ifi.cjThis += uAdjustIFI;

        unsigned    uSim = !!m_pcfdBold + !!m_pcfdItalic + !!m_pcfdBoth;		//  Finally, Allow for the size of any Font Difference structures.

        ifi.dpFontSim = uSim ? ifi.cjThis : 0;
        ufmh.dwSize += ifi.cjThis += uSim * sizeof(FONTDIFF) + !!uSim * sizeof(FONTSIM) + dwAdd_IFI;


//------------------------------------------------------------------------------------------------------------------------------------------
																				// EXTTEXTMETRIC

		ufmh.loExtTextMetric = 0;													// Preset ufm exttextmetric offset to 0.

		if(m_fSave_EXT)																// If user wants to save the EXTTEXTMETRIC data
			{
			ufmh.loExtTextMetric = ufmh.dwSize;										// Set ufm exttextmetric offset. Note, this
																			//  offset just happens to be the current ufmh.dwSize.
			if(dwAdd_ExtTextM = ufmh.loExtTextMetric & 0x07){
				dwAdd_ExtTextM = OS_BYTE - dwAdd_ExtTextM;
				ufmh.loExtTextMetric += dwAdd_ExtTextM;
			}
			
			ufmh.dwSize += m_EXTTEXTMETRIC.emSize = sizeof(EXTTEXTMETRIC);			// Increase size of ufmh.dwSize to accomodate
																					//  exttextmetric structure.
			ufmh.dwSize +=dwAdd_ExtTextM;
		}
//------------------------------------------------------------------------------------------------------------------------------------------
																				// CHARACTER WIDTHS DATA

																					// Calculate size of width table (if there is one)														
//raid 154639					
        ufmh.loWidthTable = IsVariableWidth() * ufmh.dwSize;						//   set ufm width table offset. Note, this

		if(dwAdd_WidthTable = ufmh.loWidthTable & 0x07){                  	//   offset just happens to be the current ufmh.dwSize.
			dwAdd_WidthTable = OS_BYTE - dwAdd_WidthTable;
			ufmh.loWidthTable += dwAdd_WidthTable;
		}
			
        if  (IsVariableWidth())														//  Width table, but only if there is an associated GTT.
			{																		//  For now, we just need to calculate the size of the table
            unsigned    uRuns = 0, uGlyphs = 0;

            if  (DBCSFont())														//  DBCS
				{
                unsigned u = (unsigned) m_cpaGlyphs.GetSize();						//  Determine the number of runs needed
                do
					{
                    while   (u-- && !m_cwaWidth[u]);								//  DBCS has 0 width
                    if  (u == (unsigned) -1) break;									//  We're done!

                    uRuns++, uGlyphs++;
                    while   (u-- && m_cwaWidth[u])
                        uGlyphs++;
					}
					while   (u != (unsigned) -1);
				}
            else
				{
                uRuns++;
                uGlyphs = (unsigned)m_cwaWidth.GetSize();
				}

            ufmh.dwSize += sizeof (WIDTHTABLE) + --uRuns * sizeof (WIDTHRUN) +
                uGlyphs * sizeof (WORD) + dwAdd_WidthTable;
			}
 
//------------------------------------------------------------------------------------------------------------------------------------------
																				// KERNING PAIRS DATA

																					// Calculate size of Kerning table (if there is one)														
        ufmh.loKernPair = CanKern() ? ufmh.dwSize : 0;								//   set ufm Kerning table offset. Note, this
																					//   offset just happens to be the current ufmh.dwSize.

        																					// A "secret" kern pair of all 0's must end this,
																					//  so this size is in fact correct.  Also note that
																					//   padding screws up the size of the KERNDATA structure.
        if  (CanKern()){
			if(dwAdd_KerPair = ufmh.loKernPair & 0x07) {                 	//   offset just happens to be the current ufmh.dwSize.
				dwAdd_KerPair = OS_BYTE - dwAdd_KerPair;
				ufmh.loKernPair += dwAdd_KerPair;
			}
            ufmh.dwSize +=
            ((sizeof (KERNDATA) - sizeof (FD_KERNINGPAIR)) & 0xFFFC) +
            ((1 + m_csoaKern.GetSize()) * sizeof (FD_KERNINGPAIR)) + dwAdd_KerPair;
		}
//------------------------------------------------------------------------------------------------------------------------------------------
																				//  All sizes have been calculated, and the important structures have
																				//  been initialized.  Time to start writing all this great stuff!
//------------------------------------------------------------------------------------------------------------------------------------------
		
        cfUFM.Write(&ufmh, sizeof ufmh);										//  write UNIFM_HDR Header

//------------------------------------------------------------------------------------------------------------------------------------------
		if (dwAdd_UniDrv)
			cfUFM.Write(InsertZero, dwAdd_UniDrv);

		cfUFM.Write(&m_UNIDRVINFO, sizeof m_UNIDRVINFO);						//  write UNIDRVINFO	// rm new
/*		if (dwAdd_SelectedFont)
			cfUFM.Write (InsertZero,dwAdd_SelectedFont); */
		m_ciSelect.WriteEncoding(cfUFM);
		
/*		if (dwAdd_UnSelectedFont)
			cfUFM.Write (InsertZero,dwAdd_UnSelectedFont); */
        m_ciDeselect.WriteEncoding(cfUFM);

        cfUFM.Write(ufmh.dwReserved, uAdjustUDI);								//  write Padding

//------------------------------------------------------------------------------------------------------------------------------------------
        if (dwAdd_IFI)
			cfUFM.Write(InsertZero, dwAdd_IFI);

		cfUFM.Write(&ifi, sizeof ifi);											//  write IFIMETRICS
        cfUFM.Write(&ifie, sizeof ifie);										//  write IFIEXTRA
        cusFamily.Write(cfUFM);													//  write "Family"
        cusFace.Write(cfUFM);													//  write "Face"
        cusUnique.Write(cfUFM);													//  write "Unique name"
        cusStyle.Write(cfUFM);													//  write "Style"
        cfUFM.Write(ufmh.dwReserved, uAdjustIFI);								//  write Padding

//------------------------------------------------------------------------------------------------------------------------------------------
        if  (m_pcfdBold || m_pcfdItalic || m_pcfdBoth)							//  Any Font difference structures
			{
            FONTSIM fs;
            unsigned    uWhere = sizeof fs;

            fs.dpBold = m_pcfdBold ? uWhere : 0;
            uWhere += !!m_pcfdBold * sizeof (FONTDIFF);
            fs.dpItalic = m_pcfdItalic ? uWhere : 0;
            uWhere += !!m_pcfdItalic * sizeof (FONTDIFF);
			//TRACE("Italic metrics = %d, %d %d %d\n", m_pcfdItalic->Metric(0), m_pcfdItalic->Metric(1), m_pcfdItalic->Metric(2), m_pcfdItalic->Metric(3)) ;
            fs.dpBoldItalic = m_pcfdBoth ? uWhere : 0;

            cfUFM.Write(&fs, sizeof fs);


            if  (m_pcfdBold)   m_pcfdBold->Store(cfUFM, m_IFIMETRICS.fsSelection | FM_SEL_BOLD);							// rm new
            if  (m_pcfdItalic) m_pcfdItalic->Store(cfUFM, m_IFIMETRICS.fsSelection | FM_SEL_ITALIC);
            if  (m_pcfdBoth)   m_pcfdBoth->Store(cfUFM, m_IFIMETRICS.fsSelection | FM_SEL_BOLD| FM_SEL_ITALIC);

		
//            if  (m_pcfdBold)   m_pcfdBold->Store(cfUFM, m_wfStyle | FM_SEL_BOLD);							// rm ori
//            if  (m_pcfdItalic) m_pcfdItalic->Store(cfUFM, m_wfStyle | FM_SEL_ITALIC);
//            if  (m_pcfdBoth)   m_pcfdBoth->Store(cfUFM, m_wfStyle | FM_SEL_BOLD| FM_SEL_ITALIC);
			}

//------------------------------------------------------------------------------------------------------------------------------------------
		if (m_fSave_EXT)														// write EXTTEXTMETRIC
			if (dwAdd_ExtTextM)
			cfUFM.Write(InsertZero, dwAdd_ExtTextM);
			cfUFM.Write(&m_EXTTEXTMETRIC, sizeof(EXTTEXTMETRIC) );
//------------------------------------------------------------------------------------------------------------------------------------------
																				//  Width table

        if  (IsVariableWidth())
            if  (!DBCSFont())														//  Not DBCS - easy!  (Handles always start at 1
				{

                WIDTHTABLE  wdt = { sizeof wdt, 1,
                        {1, (WORD)m_cpaGlyphs.GetSize(), sizeof wdt}};
				if(dwAdd_WidthTable)  // 154639
					cfUFM.Write(InsertZero, dwAdd_WidthTable);
                cfUFM.Write(&wdt, sizeof wdt);

                cfUFM.Write(m_cwaWidth.GetData(),
						(unsigned)(m_cwaWidth.GetSize() * sizeof (WORD)));
				}
            else																	//  DBCS - This case is a bit nastier
				{
                CByteArray  cbaTable;
                CWordArray  cwaSize;

                cbaTable.SetSize(sizeof(WIDTHTABLE) - sizeof(WIDTHRUN));
                PWIDTHTABLE pwdt = (PWIDTHTABLE) cbaTable.GetData();
                pwdt -> dwRunNum = 0;

																					//  Calculate and fill in the WIDTHRUN structures and the
																					//  Size array
                unsigned u = 0, uMax = (unsigned) m_cpaGlyphs.GetSize();
                do
					{
                    while   (u < uMax && !m_cwaWidth[u++]);
                    if  (u == uMax)  break;											//  We're done!

																					//  We've found a run- lots of work to do

                    cbaTable.InsertAt(cbaTable.GetSize(), 0,						//  Add a run to the table
                        sizeof (WIDTHRUN));
                    pwdt = (PWIDTHTABLE) cbaTable.GetData();						//  Remember the glyph handle is 1-based.
                    pwdt->WidthRun[pwdt->dwRunNum].wStartGlyph = --u + 1;
                    pwdt->WidthRun[pwdt->dwRunNum].wGlyphCount = 0;
                    pwdt->WidthRun[pwdt->dwRunNum].loCharWidthOffset =
									(DWORD)(cwaSize.GetSize() * sizeof (WORD));
                    do
						{
                        cwaSize.Add(m_cwaWidth[u]);
                        pwdt -> WidthRun[pwdt->dwRunNum].wGlyphCount++;
						}
						while   (++u < uMax && m_cwaWidth[u]);
                    pwdt->dwRunNum++;												//  End of the run!
					}
					while   (u < uMax);
																					//  OK, now we have to add the total size of the WIDTHTABLE
																					//  to the various offsets, but we are otherwise ready to rock
																					//  and roll.

                pwdt->dwSize = (DWORD)cbaTable.GetSize();
                for (u = 0; u < pwdt->dwRunNum; u++)
                    pwdt->WidthRun[u].loCharWidthOffset += pwdt->dwSize;
				
				if(dwAdd_WidthTable)  // 154639
					cfUFM.Write(InsertZero, dwAdd_WidthTable);
																
                cfUFM.Write(pwdt, pwdt -> dwSize);									//  write width table
                for (u = 0; u < pwdt -> dwRunNum; u++)
                    cfUFM.Write(cwaSize.GetData() +
                    pwdt -> WidthRun[u].wStartGlyph - 1,
                    pwdt -> WidthRun[u].wGlyphCount * sizeof (WORD));
				}

//------------------------------------------------------------------------------------------------------------------------------------------
        if  (CanKern())															//  Kern Pairs
			{	
            //  KERNDATA is DWORD-packed, but FD_KERNINGPAIR is WORD-packed
            //  the following trick code allows for any slop.
            KERNDATA    kd = {0xFFFC & (sizeof kd - sizeof kd.KernPair),
							  m_csoaKern.GetSize()};
            kd.dwSize += (1 + kd.dwKernPairNum) * sizeof kd.KernPair;

			if(dwAdd_KerPair)  // 154639
				cfUFM.Write(InsertZero, dwAdd_KerPair);

            cfUFM.Write(&kd, 0xFFFC & (sizeof kd - sizeof kd.KernPair));

            for (unsigned u = 0; u < m_csoaKern.GetSize(); u++)	{
                CKern *pck = (CKern *) m_csoaKern[u] ;
				WCHAR wcf = pck->First()  ;
				WCHAR wcs = pck->Second() ;
				short sa  = pck->Amount() ;
                ((CKern *) m_csoaKern[u]) -> Store(cfUFM);
			} ;

            //  Now for the "secret" sentinel-
            CKern   ck; //  Just happens to 0-init!
            ck.Store(cfUFM);
			}
    }

//------------------------------------------------------------------------------------------------------------------------------------------
    catch   (CException *pce)
		{
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
		}
	if(!bStoreFormWokspace)	//raid 244123
		Changed(FALSE);
    return  TRUE;																//  Return triumphant to whoever deigned to need this service.
}


/*****************************************************************************

  CFontInfo::StoreGTTCPOnly

  When a UFM is loaded during a workspace load and the UFM does not have a 
  valid GTT or CP, the UFM cannot be saved normally because there are several
  parts of the UFM that were not loaded correctly or at all because of the
  missing data.  

  When this situation is detected, this routine is called so the - supposedly -
  good info in the disk file is not overwritten by bad data.  In addition,
  Store() will blow when it tries to use nonexistent UFM data.

  This routine will just save the what we hope is corrected GTT and/or CP data.
  This is done without changing any of the other data in the file.  Next, the
  UFM is reloaded.  If all goes well, the UFM is correctly loaded so that
  normal editting and saving can be performed from this point on.

  TRUE is returned if the GTT and CP are successfully saved.  Otherwise, FALSE
  is returned.

******************************************************************************/

BOOL    CFontInfo::StoreGTTCPOnly(LPCTSTR lpstrFile)
{
	// Remind the user about what is going to happen.

	AfxMessageBox(IDS_GTTCPOnlySaved, MB_ICONINFORMATION) ;

	// Perform the steps required to update the GTT/CP in the UFM file.

    try {
		// Begin by opening the file in a way that will not truncate existing
		// files.

		UINT nopenflags = CFile::modeNoTruncate | CFile::modeCreate  ;
		nopenflags |= CFile::modeWrite | CFile::shareExclusive  ;
        CFile cfufm(lpstrFile, nopenflags) ;

		// Seek to the file positon that we want change.

        UNIFM_HDR ufmh ;
		DWORD dwseekpos ;
		dwseekpos = (DWORD)PtrToUlong(&ufmh.ulDefaultCodepage) - (DWORD)PtrToUlong(&ufmh) ;
		cfufm.Seek(dwseekpos, CFile::begin) ;

		// Load the fields in the UFM header that we want to save and write
		// them out.

		ufmh.ulDefaultCodepage = m_ulDefaultCodepage ;
		ufmh.lGlyphSetDataRCID = m_lGlyphSetDataRCID ;
		UINT nwritebytes = sizeof(ufmh.ulDefaultCodepage) 
						   + sizeof(ufmh.lGlyphSetDataRCID) ;
		cfufm.Write((void*) &ufmh.ulDefaultCodepage, nwritebytes) ;

		// Move the file pointer to the end of the file and close it.

		cfufm.SeekToEnd() ;
		cfufm.Close() ;
	}
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return FALSE ;
	} ;
    Changed(FALSE) ;

	// If the UFM was loaded from a workspace, try to use the workspace data to
	// find and load a pointer to the new GTT and finish loading the font.

	m_pcgmTranslation = NULL ;
	if (m_bLoadedByWorkspace) {
	    CDriverResources* pcdr = (CDriverResources*) GetWorkspace() ;
		if (pcdr)
			pcdr->LinkAndLoadFont(*this, false) ;
		else
			Load(false) ;

	// If the UFM was loaded stand alone the first time, reload it the same way
	// and let the load routine handle finding the GTT info.

	} else
		Load(false) ;

	// If reloading the UFM successfully associated a GTT or CP with the UFM,
	// clear the m_bWSLoadButNoGTTCP flag.  Then tell the user that the UFM
	// can be editted normally now.

	if (m_pcgmTranslation) {
		SetNoGTTCP(false) ;
		CString csmsg ;
		csmsg.Format(IDS_UFMOKNow, Name()) ;
		AfxMessageBox(csmsg, MB_ICONINFORMATION) ;
	} ;

	// All went well so...

	return TRUE ;
}


/*****************************************************************************

  CFontInfo::CreateEditor

  This member function launches an editing view for the font.

******************************************************************************/

CMDIChildWnd*   CFontInfo::CreateEditor()
{
    CFontInfoContainer* pcficMe= new CFontInfoContainer(this, FileName());

    pcficMe -> SetTitle(m_pcbnWorkspace -> Name() + _TEXT(": ") + Name());	//  Make up a cool title

    CMDIChildWnd    *pcmcwNew;
	pcmcwNew = (CMDIChildWnd *) m_pcmdt->CreateNewFrame(pcficMe, NULL);

    if  (pcmcwNew)
		{
        m_pcmdt -> InitialUpdateFrame(pcmcwNew, pcficMe, TRUE);
        m_pcmdt -> AddDocument(pcficMe);
		}
	
    return  pcmcwNew;
}

/******************************************************************************

  CFontInfo::Serialize

  This is responsible for storing and restoring the entire maze of data in
  persistent object storage.

******************************************************************************/

void    CFontInfo::Serialize(CArchive& car) {
    //  We only serialize what's needed to use the UFM file in the editor,
    //  i.e., the glue needed to hold us in the driver workspace.

    CProjectNode::Serialize(car);
}


/*****************************************************************************

  CFontInfo::GetFontSimDataPtr

  Return a pointer to the requested font simulation data.

******************************************************************************/

CWordArray* CFontInfo::GetFontSimDataPtr(int nid)
{
	switch (nid) {
		case ItalicDiff:
			if (m_pcfdItalic == NULL)
				ASSERT(0) ;
			return m_pcfdItalic->GetFontSimDataPtr() ;
		case BoldDiff:
			if (m_pcfdBold == NULL)
				ASSERT(0) ;
			return m_pcfdBold->GetFontSimDataPtr() ;
		case BothDiff:
			if (m_pcfdBoth == NULL)
				ASSERT(0) ;
			return m_pcfdBoth->GetFontSimDataPtr() ;
		default:
			ASSERT(0) ;
	} ;

	// This point should never be reached.

	return NULL ;
}


/******************************************************************************

  CFontInfo::EnableSim

  This method is called to turn simulation on or off for the specified item.
  It receives a reference to the editor's pointer for the same item.

******************************************************************************/

void    CFontInfo::EnableSim(unsigned uSim, BOOL bOn, CFontDifference*& pcfd)
{

    CFontDifference*&   pcfdTarget = uSim ? (uSim == BothDiff) ? m_pcfdBoth : m_pcfdBold : m_pcfdItalic;

    if  (bOn == !!pcfd && pcfdTarget == pcfd)  return;		//  Clear out any irrelevant calls

    if  (bOn && pcfdTarget)									//  If this call is just to init pcfd, do it and leave
		{
        pcfd = pcfdTarget;
        return;
		}



    if  (bOn)
//        pcfd = pcfdTarget = pcfd ? pcfd : new CFontDifference(m_wWeight, m_wMaximumIncrement, m_wAverageWidth,			// rm ori
//															  uSim == BoldDiff ? m _cwaSpecial[ItalicAngle] : 175, this);

        pcfd = pcfdTarget = pcfd ? pcfd : new CFontDifference(m_IFIMETRICS.usWinWeight, m_IFIMETRICS.fwdMaxCharInc, m_IFIMETRICS.fwdAveCharWidth,
															  uSim == BoldDiff ? m_ItalicAngle : 175, this);
    else
        pcfdTarget = NULL;  //  pcfd will already have been set correctly

    Changed();
}


/******************************************************************************

  CFontInfo::FillKern

  This preps the passed CListCtrl, if necessary, and fills it with the kerning
  information.

******************************************************************************/

void    CFontInfo::FillKern(CListCtrl& clcView)
{
    for (unsigned u = 0; u < m_csoaKern.GetSize(); u++)
		{
        CString csWork;
        CKern&  ckThis = *(CKern *) m_csoaKern[u];

        csWork.Format("%d", ckThis.Amount());
        int idItem = clcView.InsertItem(u, csWork);
        clcView.SetItemData(idItem, u);

        csWork.Format("0x%X", ckThis.First());
        clcView.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u);

        csWork.Format("0x%X", ckThis.Second());
        clcView.SetItem(idItem, 2, LVIF_TEXT, csWork, -1, 0, 0, u);
		}
}


/******************************************************************************

  CFontInfo::LoadBadKerningInfo

  Check the kerning pairs to see if they reference code points that are not in
  the UFM's GTT.  If any are found, load them into the specified list control.
  Return true if any bad kerning pairs were found.  Otherwise, return false.

******************************************************************************/

bool CFontInfo::LoadBadKerningInfo(CListCtrl& clcbaddata)
{
	// Declare the variables needed to check for bad kerning data

	unsigned unumkerns = m_csoaKern.GetSize() ;
    CString cs ;
	bool bfoundbad = false ;

	// Loop through each kerning class and check it.

    for (unsigned u = 0 ; u < unumkerns ; u++) {
        CKern& ckThis = *(CKern *) m_csoaKern[u] ;

		// If each code point in this kerning pair is still a valid code point
		// for the GTT, skip this kerning pair.

		if (CodePointInGTT(ckThis.First()) && CodePointInGTT(ckThis.Second()))
			continue ;

		// Add this kerning pair's data to the list of bad data.

        cs.Format("%d", ckThis.Amount()) ;
        int idItem = clcbaddata.InsertItem(u, cs) ;
        clcbaddata.SetItemData(idItem, u) ;

        cs.Format("0x%X", ckThis.First()) ;
        clcbaddata.SetItem(idItem, 1, LVIF_TEXT, cs, -1, 0, 0, u) ;

        cs.Format("0x%X", ckThis.Second()) ;
        clcbaddata.SetItem(idItem, 2, LVIF_TEXT, cs, -1, 0, 0, u) ;

		bfoundbad = true ;
	} ;

	return bfoundbad ;
}


/******************************************************************************

  CFontInfo::CodePointInGTT

  Return true if the specified code point is in the GTT.  Otherwise, return
  false.

******************************************************************************/

bool CFontInfo::CodePointInGTT(WORD wcodepoint)
{
	int nelts = (int)m_cpaGlyphs.GetSize() ;// Number of elements in glyphs array
	int nleft, nright, ncheck ;				// Variables needed to search array
	WORD wgttcp ;

	// Try to find the codepoint in the GTT

	for (nleft = 0, nright = nelts - 1 ; nleft <= nright ; ) {
		ncheck = (nleft + nright) >> 1 ;
		
		wgttcp = ((CGlyphHandle *) m_cpaGlyphs[ncheck])->CodePoint() ;
		//TRACE("Key[%d] = '0x%x', CP = '0x%x'\n", ncheck, wgttcp, wcodepoint) ;
		
		if (wgttcp > wcodepoint)
			nright = ncheck - 1 ;
		else if (wgttcp < wcodepoint)
			nleft = ncheck + 1 ;
		else
			return true ;	//*** Return true here if match found.
	} ;							

	// Return false here because no match found.

	return false	;
}


/******************************************************************************

  CFontInfo::AddKern

  This method adds an additional kerning pair into the array. and also inserts
  it into the list view.

******************************************************************************/

void    CFontInfo::AddKern(WORD wFirst, WORD wSecond, short sAmount,
                           CListCtrl& clcView) {
    for (unsigned u = 0; u < KernCount(); u ++) {
        CKern&  ckThis = *(CKern *) m_csoaKern[u];
        if  (ckThis.Second() < wSecond)
            continue;
        if  (ckThis.Second() > wSecond)
            break;
        _ASSERT(ckThis.First() != wFirst);
        if  (ckThis.First() < wFirst)
            continue;
        break;
    }

    FD_KERNINGPAIR  fdkp = { wFirst, wSecond, sAmount };
    m_csoaKern.InsertAt(u, new CKern(fdkp));

    CString csWork;
    csWork.Format("%d", sAmount);
    int idItem = clcView.InsertItem(u, csWork);
    clcView.SetItemData(idItem, u);

    csWork.Format("0x%X", wFirst);
    clcView.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u);

    csWork.Format("0x%X", wSecond);
    clcView.SetItem(idItem, 2, LVIF_TEXT, csWork, -1, 0, 0, u);
    Changed();
}

/******************************************************************************

  CFontInfo::SetKernAmount

  This will change the kern amount entry for the specified item.

******************************************************************************/

void    CFontInfo::SetKernAmount(unsigned u, short sAmount) {
    if  (u >= KernCount())  return;

    CKern   &ckThis = *(CKern *) m_csoaKern[u];

    if  (sAmount == ckThis.Amount())    return;

    ckThis.SetAmount(sAmount);
    Changed();
}


/******************************************************************************

  CFontInfo::MakeKernCopy

  Make a copy of the kerning pairs table.

******************************************************************************/

void CFontInfo::MakeKernCopy()
{
	// Find out how many entries are in the kerning pairs table.

	int numkerns = m_csoaKern.GetSize() ;

	// Get rid of any entries already in the kerning copy table and set it to
	// the correct size.

	m_csoaKernCopy.RemoveAll() ;
	m_csoaKernCopy.SetSize(numkerns) ;

	// Copy the kerning pairs table entries one at a time so that a new	CKern
	// class instance can be allocated, initialized, and saved.

	CKern* pck ;
	for (int n = 0 ; n < numkerns ; n++) {
		pck = new CKern(((CKern*) m_csoaKern[n])->First(),
						((CKern*) m_csoaKern[n])->Second(),
						((CKern*) m_csoaKern[n])->Amount()) ;
		m_csoaKernCopy.SetAt(n, pck) ;
	} ;
}


/******************************************************************************

  CFontInfo::FillWidths

  This preps the passed CListCtrl, if necessary, and fills it with the
  character width information.

******************************************************************************/

void    CFontInfo::FillWidths(CListCtrl& clcView)
{
    CWaitCursor cwc;
    clcView.SetItemCount((int)m_cpaGlyphs.GetSize());
    for (int u = 0; u < m_cpaGlyphs.GetSize(); u++) {
        if  (DBCSFont() && !m_cwaWidth[u])
            continue;   //  Don't display these code points.
        CString csWork;
        CGlyphHandle&  cghThis = *(CGlyphHandle *) m_cpaGlyphs[u];

        csWork.Format("%d", m_cwaWidth[u]);
        int idItem = clcView.InsertItem(u, csWork);
        clcView.SetItemData(idItem, u);

        csWork.Format("0x%04X", cghThis.CodePoint());
        clcView.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u);
    }
}


/******************************************************************************

  CFontInfo::WidthsTableIsOK

  Perform the only consistency check on the widths table that I can think of:
  Make sure that there aren't more widths in the UFM than there are Glyphs in
  the GTT.  Return true if the table appears to be ok.  Otherwise, return false.

******************************************************************************/

bool CFontInfo::WidthsTableIsOK()
{
	return (m_cwaWidth.GetSize() <=	m_cpaGlyphs.GetSize()) ;
}


/******************************************************************************

  CFontInfo::SetWidth

  This member sets the width of a glyph.  It also updates the Maximum and
  Average width information if the font is not a DBCS font and the user
  requests it.

******************************************************************************/

void    CFontInfo::SetWidth(unsigned uGlyph, WORD wWidth, bool bcalc /*=true*/)
{
    m_cwaWidth[uGlyph] = wWidth;

    if (bcalc && !DBCSFont())
        CalculateWidths();
}


/******************************************************************************

  CFontInfo::CompareGlyphsEx(WORD wOld, WORD wNew, CLinkedList* pcll)

to Do ; check the old glyph table and new, then change the old linked list 
		according to the new glyph table.

parameter : wOld, wNew ; code point index of new, old glyph table
			CLinkedList* pcll ; linked node containing the codepoint data

return : new linked list of new gtt.

******************************************************************************/

CLinkedList* CFontInfo::CompareGlyphsEx(WORD wOld, WORD wNew, CLinkedList* pcll)
{	// pcll
	static UINT_PTR  dwLinked ;
	static CLinkedList* pcllpre = NULL ;
	static CLinkedList* pclltmp = NULL ;
	static int ncOldGlyphs ; 
	static int ncNewGlyphs ; 
	
	if (wOld == 0 && wNew == 0 ) {
		dwLinked = (UINT_PTR)pcll ;
		ncNewGlyphs  = (int)m_cwaNewGlyphs.GetSize() ;
		ncOldGlyphs  = (int)m_cwaOldGlyphs.GetSize() ;
	
		}
	if (wNew >= ncNewGlyphs && wOld >= ncOldGlyphs ) {
		pcllpre = NULL ;
		return (CLinkedList*) dwLinked;
	}

	// delete at the end of the glyphs tree
	if (wOld < ncOldGlyphs && wNew >= ncNewGlyphs ) {
		pcllpre = pcll->Next ;
		delete pcll ;
		return CompareGlyphsEx(++wOld,wNew,pcllpre) ;
	}

	// add at the end of the glyphs tree
	// BUG_BUG :: this is called at the second end of the code points.
	// added coded is located between seconde end and first end.  // almost fixed. 
	if (wNew < ncNewGlyphs && wOld >= ncOldGlyphs - 1 && m_cwaOldGlyphs[wOld] <= m_cwaNewGlyphs[wNew] ) {
		
		CLinkedList* pcllnew = new CLinkedList ;
		if (!pcllnew) {
			CString csError ; 
			csError.LoadString(IDS_ResourceError) ;
			AfxMessageBox(csError,MB_ICONEXCLAMATION) ;
			return (CLinkedList*) dwLinked;		
		}
		pcllnew->data = 0 ;
		pcll->Next = pcllnew ;
		return CompareGlyphsEx(wOld,++wNew,pcll->Next) ;

	}
	
	// Delete
	if (m_cwaOldGlyphs[wOld] < m_cwaNewGlyphs[wNew] ) {
		
		if (!pcllpre || (pcllpre == pcll) ) {
			pcllpre = pcll->Next ;
			dwLinked = (UINT_PTR)pcllpre ;
			delete pcll ;	 
			return CompareGlyphsEx(++wOld, wNew,pcllpre) ;
			
		}
		else{
			if (pclltmp && pclltmp->Next == pcllpre->Next ) 
				pcllpre = pclltmp ;
			pcllpre->Next = pcll->Next ;
			delete pcll ; 
			return CompareGlyphsEx(++wOld, wNew,pcllpre->Next ) ;
		}	
	}// Add
	else if (m_cwaOldGlyphs[wOld] > m_cwaNewGlyphs[wNew] ) {
		CLinkedList * pcllnew = new CLinkedList ;

		pcllnew->data = 0 ;
		if (!pcllpre)  {
			dwLinked = (UINT_PTR) pcllnew ; 
			pcllpre = pcllnew ;
			pcllnew ->Next = pcll ;
		}
		else {  // problem when pcllnew->next == pcll
			if (pclltmp && pclltmp == pcllpre->Next ) 
				pcllpre = pclltmp ;
			pcllnew ->Next = pcllpre->Next ;

			pcllpre->Next = pcllnew ;
			pclltmp = pcllnew ;
			
		}
		return CompareGlyphsEx(wOld, ++wNew,pcllnew ->Next) ;
	} // no change
	else {
		pcllpre = pcll ;
		return CompareGlyphsEx(++wOld,++wNew,pcll->Next ) ;

	}
}





/******************************************************************************

  CFontInfo::CheckReloadWidths

  It is possible that the code points in the UFM's GTT have changed.  If that
  is the case, reload the widths info so that they can use the new code point
  info.

  Return true if the widths were reloaded.  Otherwise, return false.

  NOTE: This function uses several pieces of CFontInfo::Load().  If changes
  are made to those pieces of code, similar changes may need be made in Load()
  too.
  
  sunggch : Modify the code in order to synchronize the Widthtable with 
				GTT change (add or delete code point)
			Get m_cwaWidth from the CompareGlyphsEx instead of UFM load table
******************************************************************************/

DWORD CLinkedList::m_dwSize ;
#define MAX_CODE_COUNT 1000 
bool CFontInfo::CheckReloadWidths()
{
	// Do nothing if this class was loaded standalone or it has no GTT pointer.

	if (!m_bLoadedByWorkspace || m_pcgmTranslation == NULL)
		return false ;

	// Do nothing if the GTT has not changes since the last time the UFM's
	// widths were reloaded.

	if (m_pcgmTranslation->m_ctSaveTimeStamp <= m_ctReloadWidthsTimeStamp && !IsRCIDChanged())
		return false ;

	// Open the UFM file

    CFile cfUFM ;
    if  (!cfUFM.Open(m_cfn.FullName(), CFile::modeRead | CFile::shareDenyWrite))
		return false ;

	//  Try to load the file- proclaim defeat on any exception.

	CByteArray cbaUFM ;			// Loaded with file's contents
    try	{																			
        cbaUFM.SetSize(cfUFM.GetLength()) ;
        cfUFM.Read(cbaUFM.GetData(), (unsigned)cbaUFM.GetSize()) ;
	}
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return false ;
	} ;				

    PUNIFM_HDR  pufmh = (PUNIFM_HDR) cbaUFM.GetData() ;		// UNIFM_HDR

	// Do nothing if there is no width table except update the timestamp so that
	// this code isn't executed again.

    if (pufmh->loWidthTable == NULL) {
		m_ctReloadWidthsTimeStamp = CTime::GetCurrentTime() ;
        return false ;
	} ;

    union {
		PBYTE       pbwt ;
        PWIDTHTABLE pwt ;
	} ;
	
	pbwt = cbaUFM.GetData() + pufmh->loWidthTable ;
	
	// Synchronization of UFM width and Gtt is only supported in the SBCS.
	// BUG_BUG : the interupt happend in the DBCS gtt.
	int oldGlyphs = PtrToInt((PVOID)m_cpaGlyphs.GetSize());
	m_pcgmTranslation->Collect(m_cpaGlyphs) ;		
	
	m_cwaNewGlyphs.SetSize(m_cpaGlyphs.GetSize()) ;
	
	if (!DBCSFont() && m_cpaGlyphs.GetSize() < MAX_CODE_COUNT && oldGlyphs < MAX_CODE_COUNT && m_cwaOldGlyphs.GetSize()) {
	
		for (int i = 0 ; i < m_cpaGlyphs.GetSize() ; i ++ ) {
		CGlyphHandle&  cghThis = *(CGlyphHandle *) m_cpaGlyphs[i];
		m_cwaNewGlyphs.SetAt(i,cghThis.CodePoint() ) ;
		}
		CLinkedList* pcll = new CLinkedList ;
		CLinkedList* pcll_pre  = NULL ;
		UINT_PTR dwLinked = (UINT_PTR) pcll ;

		// convert WordArray into LinkedList 
		for( i = 0 ; i < m_cwaWidth.GetSize() ; i ++ ) {
			pcll->data = m_cwaWidth[i];
			pcll->Next = new CLinkedList ;  // at the end of array, it create redundant one more CLinkedList;
			pcll = pcll->Next ;
		}
	
		dwLinked = (UINT_PTR)CompareGlyphsEx(0,0,(CLinkedList* )dwLinked) ;

		int size = CLinkedList::Size() ;
		
		m_cwaWidth.RemoveAll() ;
		m_cwaWidth.SetSize(m_cwaNewGlyphs.GetSize()) ;
		ASSERT(size >= m_cwaNewGlyphs.GetSize() ) ;

		CLinkedList* pgarbage = NULL ;
		for ( pcll =(CLinkedList*) dwLinked, i = 0 ; i < m_cwaNewGlyphs.GetSize() ; i++ ,pgarbage=pcll, pcll = pcll->Next ) {
			m_cwaWidth[i] = pcll->data ;
			delete pgarbage;
		}
		
		
		m_cwaOldGlyphs.RemoveAll();
		m_cwaOldGlyphs.Copy(m_cwaNewGlyphs) ;

	}
	else {

		// Collect all the handles
		
		m_pcgmTranslation->Collect(m_cpaGlyphs) ;		
		m_cwaWidth.RemoveAll() ;

		if (m_cpaGlyphs.GetSize() > 0)
			m_cwaWidth.InsertAt(0, 0, m_cpaGlyphs.GetSize()) ;

		unsigned uWidth = (unsigned)m_cwaWidth.GetSize();												
		unsigned uWidthIdx ;

		// Build the widths table.

		for (unsigned u = 0; u < pwt->dwRunNum; u++) {
			PWORD   pwWidth = (PWORD) (pbwt + pwt->WidthRun[u].loCharWidthOffset) ;

			unsigned uGlyph = 0 ;
			for ( ; uGlyph < pwt->WidthRun[u].wGlyphCount ; uGlyph++) {
				// For whatever reason, there are times when the index value is
				// < 0 or > uWidth.  An AV would occur if m_cwaWidth were allowed
				// to be indexed by such a value.  Just keep this from happening
				// for now.  A better fix is needed.  BUG_BUG : won't fix

				//  Glyph handles start at 1, not 0!

				uWidthIdx = uGlyph + -1 + pwt->WidthRun[u].wStartGlyph ;					
				if ((int) uWidthIdx < 0) {
					//AfxMessageBox("Negative width table index") ;
					//TRACE("***Negative width table index (%d) found in %s.  Table size=%d  uGlyph=%d  wGlyphCount=%d  wStartGlyph=%d  u=%d  dwRunNum=%d\n", uWidthIdx, Name(), uWidth, uGlyph, pwt->WidthRun[u].wGlyphCount, pwt->WidthRun[u].wStartGlyph, u, pwt->dwRunNum) ;
					continue ;
				} else if (uWidthIdx >= uWidth) {
					//AfxMessageBox("Width table index (%d) > table size") ;
					//TRACE("***Width table index (%d) > table size (%d) found in %s.  Table size=%d  uGlyph=%d  wGlyphCount=%d  wStartGlyph=%d  u=%d  dwRunNum=%d\n", uWidthIdx, uWidth, Name(), uWidth, uGlyph, pwt->WidthRun[u].wGlyphCount, pwt->WidthRun[u].wStartGlyph, u, pwt->dwRunNum) ;
					break ;												//  rm fix VC IDE compiler problem?
				} ;

				//m_cwaWidth[uGlyph + -1 + pwt->WidthRun[u].wStartGlyph] = *pwWidth++;		//  Glyph handles start at 1, not 0!
				m_cwaWidth[uWidthIdx] = *pwWidth++;											
			} ;
		} ;

}
	// The widths were successfully reloaded so update the reload time and
	// return true.

	m_ctReloadWidthsTimeStamp = CTime::GetCurrentTime() ;
	return true ;
}


/******************************************************************************

  CFontInfo::GetFirstPFM
  CFontInfo::GetLastPFM

******************************************************************************/

WORD CFontInfo::GetFirstPFM()
{
	res_PFMHEADER    *pPFM ;
	pPFM = (res_PFMHEADER *) m_cbaPFM.GetData() ;
	return ((WORD) pPFM->dfFirstChar) ;
	//return ((WORD) ((res_PFMHEADER *) m_cbaPFM.GetData())->dfFirstChar) ;
}

WORD CFontInfo::GetLastPFM()
{
	res_PFMHEADER    *pPFM ;
	pPFM = (res_PFMHEADER *) m_cbaPFM.GetData() ;
	return ((WORD) pPFM->dfLastChar) ;
	//return ((WORD) ((res_PFMHEADER *) m_cbaPFM.GetData())->dfLastChar) ;
}




/******************************************************************************

  CFontInfoContainer class

  This class encapsulates one CFontInfo structure, and is used as a document
  class so we can leverage the MFC document/view architecture for editing this
  information both within the contet of the driver, and as a stand-alone file.

******************************************************************************/

IMPLEMENT_DYNCREATE(CFontInfoContainer, CDocument)

/******************************************************************************

  CFontInfoContainer::CFontInfoContainer()

  This constructor is used when the document is dynamically created- this will
  be when the user opens an existing font file, or creates a new one.

******************************************************************************/

CFontInfoContainer::CFontInfoContainer() {
    m_bEmbedded = FALSE;
    m_pcfi = new CFontInfo;
    m_pcfi -> NoteOwner(*this);
}

/******************************************************************************

  CFontInfoContainer::CFontInfoContainer(CFontInfo *pcfi, CString csPath) {

  This constructor is called when we invoke an editing view from the driver
  editor.  It gives us the font information to view and the name of the file
  to generate if the user decies to save the data from this view.

******************************************************************************/

CFontInfoContainer::CFontInfoContainer(CFontInfo *pcfi, CString csPath) {
    m_pcfi = pcfi;
    m_bEmbedded = TRUE;
    SetPathName(csPath, FALSE);
    m_pcfi -> NoteOwner(*this); //  Even when embedded, we're editing a file.
}

/******************************************************************************

  CFontInfoContainer::OnNewDocument

  This is an override- it is called when we are asked to create new font
  information from scratch.  For now, this will just fail.

******************************************************************************/

BOOL CFontInfoContainer::OnNewDocument() {
//	AfxMessageBox(IDS_Unimplemented);		 // raid 104822 temp
//  return  FALSE;

	return  m_pcfi && CDocument::OnNewDocument();// raid 104822  temp
}

/******************************************************************************

  CFontInfoContainer::~CFontInfoContainer

  Our erstwhile destructor must destroy the font info if this wasn't an
  embedded view; ie, the UFM was loaded standalone.  
  
  It should also destroy the font's GTT iff the UFM was loaded standalone and
  the GTT was based on a real, file-based GTT; not a code page loaded as a GTT 
  and not one of the predefined, built-in GTTs.  (In the latter case, the
  predefined GTTs are freed when the program exits.)

******************************************************************************/

CFontInfoContainer::~CFontInfoContainer()
{
	if  (!m_bEmbedded && m_pcfi) {
		int ngttid = (int) (short) m_pcfi->m_lGlyphSetDataRCID ;

		if (m_pcfi->m_pcgmTranslation && ngttid != 0)
			if ((ngttid < CGlyphMap::Wansung || ngttid > CGlyphMap::Big5) 
			 && (ngttid < CGlyphMap::CodePage863 || ngttid > CGlyphMap::CodePage437)
			 && ngttid != -IDR_CP1252)
				delete m_pcfi->m_pcgmTranslation ;
        delete  m_pcfi ;
	} ;
}


BEGIN_MESSAGE_MAP(CFontInfoContainer, CDocument)
	//{{AFX_MSG_MAP(CFontInfoContainer)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontInfoContainer diagnostics

#ifdef _DEBUG
void CFontInfoContainer::AssertValid() const {
	CDocument::AssertValid();
}

void CFontInfoContainer::Dump(CDumpContext& dc) const {
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFontInfoContainer serialization

void CFontInfoContainer::Serialize(CArchive& ar) {
	if (ar.IsStoring()) 	{
		// TODO: add storing code here
	}
	else 	{
		// TODO: add loading code here
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFontInfoContainer commands

/******************************************************************************

  CFontInfoContainer::SaveModified
	
  o If the file is saved, get rid of the copy of the kerning pairs table.
	Otherwise, restore the saved copy of the original kerning pairs table.

******************************************************************************/

BOOL CFontInfoContainer::SaveModified()
{
	m_UFMSaved = false ;		// No save attempt made yet.

	// If the file needs to be saved prompt the user about it and do it if the
	// user concurs.  Save the result so I can tell if the document is going
	// to close.

	BOOL bclose = CDocument::SaveModified() ;

	// If the doc is not closing, just return bclose without doing anything
	// else.

	if (!bclose)
		return bclose ;

	// If the file was saved, the kerning table copy is no longer needed so zap
	// it in a way that will free all associated memory.

	if (m_UFMSaved)
		m_pcfi->m_csoaKernCopy.RemoveAll() ;

	// Otherwise, the user wants to revert back to the original kern copy.  So,
	// zap the kerning table and replace it with the copy.

	else {
		m_pcfi->m_csoaKern.RemoveAll() ;	// This frees ALL associated memory
		m_pcfi->m_csoaKern.Copy(m_pcfi->m_csoaKernCopy) ;

		// Now clear the copy in a way that will not delete the class instances
		// referenced by it because copies of those pointers are in m_csoaKern
		// now.

		CObArray* pcoacopy = m_pcfi->m_csoaKernCopy.GetCOA() ;
		pcoacopy->RemoveAll() ;
	} ;

	// Return whatever CDocument::SaveModified() returned.
	
	return bclose ;
}


/******************************************************************************

  CFontInfoContainer::PublicSaveModified

  The Class Wizard made SaveModified() a protected class and I didn't want to
  change that.  Instead, I added this routine so that outsiders can call it.

******************************************************************************/

BOOL CFontInfoContainer::PublicSaveModified()
{
	return (SaveModified()) ;
}


/******************************************************************************

  CFontInfoContainer::OnSaveDocument

  This is called in response to a Save or Save As.  We pass it directly to the
  CFontInfo for processing, rather than using the base class implementation,
  which would serialize the document.  (Actually saving the UFM is the last --
  ie, final -- thing this routine does.)

  Before the document is actually saved, validate the contents of the UFM.  If
  the UFM passes all of the checks or the user doesn't want to fix the problems,
  continue processing.  Otherwise, return FALSE to make sure the document is
  left open.

  Once the UFM has been validated, copy the data in the UFM Editor's controls
  back into the CFontInfo class instance.  New data is maintain in the editor
  until this point so that the CFontInfo class instance is not updated
  unnecessarily.  That would be a problem since the UFMs are always kept
  loaded in CFontInfo class instances.  That means that even unsaved data that
  the user wanted to discard would still be displayed the next time the UFM
  is loaded into the editor.  Keeping unsaved data in the editor allows it to
  be discarded without affecting the CFontInfo class so the problem is avoided.

******************************************************************************/

BOOL CFontInfoContainer::OnSaveDocument(LPCTSTR lpszPathName)
{
	// Get a pointer to the associate view class instance.

	POSITION pos = GetFirstViewPosition() ;
	ASSERT(pos != NULL) ;
	CFontViewer* pcfv = (CFontViewer*) GetNextView(pos) ;
	
	// Call the view class to validate the UFM's contents.  If one of the
	// checks fails and the user wants to fix it, do not close the document.
	
	// if rcid changed, upgraded the Widthtable.
	if (m_pcfi->IsRCIDChanged() && m_bEmbedded) 
		pcfv->HandleCPGTTChange(true) ;

	// validate the value of the UFMs	
	if (pcfv != NULL && pcfv->ValidateSelectedUFMDataFields())
		return FALSE ;


	// Update the UFM's fields with the new data in the editor.

	if (pcfv != NULL && pcfv->SaveEditorDataInUFM())
		return FALSE ;

	m_UFMSaved = true ;			// Indicate that an attempt to save will be made

    return m_pcfi -> Store(lpszPathName);
}


/******************************************************************************

  CFontInfoContainer::OnOpenDocument

******************************************************************************/

BOOL CFontInfoContainer::OnOpenDocument(LPCTSTR lpstrFile)
{
	// SetFileName() is just called to set a few variables.  (Since the file
	// exists, we don't need to do a creation check.)

	m_pcfi->m_cfn.EnableCreationCheck(FALSE) ;
	m_pcfi->SetFileName(lpstrFile) ;

	// Load the UFM and mark it as a file that cannot be saved.  That is the
	// case when a UFM is loaded standalone because its associated GTT is not
	// loaded too.  (Some data that is saved in the UFM comes from the GTT.)

    return m_pcfi->Load(false) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontinst.h ===
/******************************** MODULE HEADER *****************************
 * fontinst.h
 *      Structures used to determine the file layout of files generated
 *      by any font installers, and then read by us.
 *
 * HISTORY:
 *  15:53 on Mon 02 Mar 1992    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 * Copyright (C) 1992   Microsoft Corporation.
 *
 ****************************************************************************/


/*
 *   Define the structure that heads each record in the font installer
 * files.  Basically it contains selection information and offsets
 * to the remaining data in this record.
 *   This structure is actually written to the file.  It is also the header
 * employed in the font resources in minidrivers - each font has one of these
 * at the beginning.
 */


//Reduced from 4 to three as WFontType is added.
//Reducde from three to two when dwETM was added
#define EXP_SIZE        2       /* DWORDS allowed for future expansion */

typedef struct
{
    WORD     cjThis;            /* Our size,  for consistency checking */
    WORD     wFlags;            /* Miscellaneous information */

    DWORD    dwSelBits;         /* Font availability information */

    DWORD    dwIFIMet;          /* Offset to the IFIMETRICS for this font */
    DWORD    dwCDSelect;        /* How to select/deselect this font */
    DWORD    dwCDDeselect;
    DWORD    dwWidthTab;        /* Width vector (proportional font) else 0 */
    DWORD    dwIdentStr;        /* Identification string */

    union
    {
        short    sCTTid;        /* Index into CTT data */
        DWORD    dwCTT;         /* Offset here to mapping data of some sort */
    } u;

    WORD     wXRes;             /* Resolution used for font metrics numbers */
    WORD     wYRes;             /* Ditto for the y coordinates */

    short    sYAdjust;          /* Adjust Y position before output - for  */
                                /* double height characters on dot matrix */
    short    sYMoved;           /* Cursor has shifted after printing font */

    short    fCaps;             /* Capabilities flags */

    WORD     wPrivateData;      /* Special purpose: e.g. DeskJet permutations */

    WORD     wFontType;         /* Type of Device font */

    WORD     wReserved;      	/* reserved for future use */

    DWORD    dwETM;             /* offset to ETM for this font 0 if there are none*/

    DWORD    dwMBZ[ EXP_SIZE ]; /* Must Be Zero: in case we need space */
	
} FI_DATA_HEADER;

/*
 *  The version ID.
 */

#define FDH_VER 0x100           /* 1.00 in BCD */

/*
 *  Flags bits.
 */
#define FDH_SOFT        0x0001  /* Softfont, thus needs downloading */
#define FDH_CART        0x0002  /* This is a cartridge font */
#define FDH_CART_MAIN   0x0004  /* Main (first) entry for this cartridge */

/*
 *  Selection criteria bits:  dwSelBits.  These bits are used as
 * follows.  During font installation,  the installer set the following
 * values as appropriate.  During initialisation,  the driver sets
 * up a mask of these bits,  depending upon the printer's abilities.
 * For example,  the FDH_SCALABLE bit is set only if the printer can
 * handle scalable fonts.   When the fonts are examined to see if
 * they are usable,  the following test is applied:
 *
 *      (font.dwSelBits & printer.dwSelBits) == font.dwSelBits
 *
 * If true,  the font is usable.
 */

#define FDH_LANDSCAPE   0x00000001      /* Font is landscape orientation */
#define FDH_PORTRAIT    0x00000002      /* Font is portrait */
#define FDH_OR_REVERSE  0x00000004      /* 180 degree rotation of above */
#define FDH_BITMAP      0x00000008      /* Bitmap font */
#define FDH_COMPRESSED  0x00000010      /* Data is compressed bitmap */
#define FDH_SCALABLE    0x00000020      /* Font is scalable */
#define FDH_CONTOUR     0x00000040      /* Intellifont contour */

#define FDH_ERROR       0x80000000      /* Set if some error condition */


/*
 *  The following structure should be returned from the specific
 * minidriver to the common font installer code.  It is used by
 * the common font installer code to generate the above structure
 * which is then placed in the font file.
 */

typedef  struct
{
    void  *pvData;      /* Address of data of importance */
    int    cBytes;      /* Number of bytes in the above */
}  DATA_SUM;

typedef  struct
{
    DATA_SUM   dsIFIMet;        /* IFIMETRICS */
    DATA_SUM   dsSel;           /* Selection string/whatever */
    DATA_SUM   dsDesel;         /* Deselection string */
    DATA_SUM   dsWidthTab;      /* Width tables (proportional font) */
    DATA_SUM   dsCTT;           /* Translation data */
    DATA_SUM   dsIdentStr;      /* Identification string (Dialog box etc) */
    DATA_SUM   dsETM;           /* EXTENDED TEXT METRICS */

    DWORD      dwSelBits;       /* Font availability information */

    WORD       wVersion;        /* Version ID */
    WORD       wFlags;          /* Miscellaneous information */

    WORD       wXRes;           /* X resolution of font */
    WORD       wYRes;           /* Y resolution */

    short      sYAdjust;        /* Adjust Y position before output - for  */
                                /* double height characters on dot matrix */
    short      sYMoved;         /* Cursor has shifted after printing font */


    WORD       fCaps;           /* Font/device caps */
    WORD       wFontType;         /* Type of Device font */
    WORD       wPrivateData;    /* Pad to DWORD multiple */
} FI_DATA;

/*
 *   RELATED FUNCTION PROTOTYPES.
 */


/*
 *   The function used to take an FI_DATA structure and write its contents
 * to the file whose handle is passed in.  The data is written out as
 * an FI_DATA_HEADER structure.
 */

int   iWriteFDH( HANDLE, FI_DATA * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontinfo.h ===
/******************************************************************************

  Header File:  Generic Font Information.H

  This file contains a set of classes intended to incorporate the information
  currently stored in the various font metric and related structures.  These
  classes are serializable, and will be capable of being loaded from and fed to
  the various other formats.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-02-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(GENERIC_FONT_INFORMATION)
#define GENERIC_FONT_INFORMATION

#include    "GTT.H"
#include    "CodePage.H"
#include    "resource.h"
#include    "Llist.h"

/*
//  These are used to glue in UFM-specific stuff

struct INVOCATION {
    DWORD   dwcbCommand;    //  Byte size of string
    DWORD   dwofCommand;    //  Offset in the file to the string
};
*/

//  `Yes, this is a bit sleazy, but DirectDraw has nothing now or ever to
//  do with this tool, so why waste time tracking down more files?

/*
#define __DD_INCLUDED__
typedef DWORD   PDD_DIRECTDRAW_GLOBAL, PDD_SURFACE_LOCAL, DESIGNVECTOR,
                DD_CALLBACKS, DD_HALINFO,
                DD_SURFACECALLBACKS, DD_PALETTECALLBACKS, VIDEOMEMORY;
*/

//#define INVOCATION   int
#define DESIGNVECTOR int											// We need lots of stuff from winddi.h and fmnewfm.h,
																	//  but the compiler whines, so I will cheat and provide a bogus
#include    "winddi.h"												//  definition for DESIGNVECTOR, which we never use anyway, so it's
#include    "fmnewfm.h"												//  okay, right?  What a hack!
#include    <math.h>



/******************************************************************************

  CFontDifference

  This class handles the information content analogous to the FONTDIFF
  structure.

******************************************************************************/

class CFontDifference
{
    CWordArray  m_cwaMetrics;
    CBasicNode  *m_pcbnOwner;

public:
    CFontDifference(WORD wWeight, WORD wMax, WORD wAverage, WORD wAngle, CBasicNode *pcbn)
		{
        m_cwaMetrics.Add(wWeight);
        m_cwaMetrics.Add(wMax);
        m_cwaMetrics.Add(wAverage);
        m_cwaMetrics.Add(wAngle);
        m_pcbnOwner = pcbn;
		}

    CFontDifference(PBYTE pb, CBasicNode *pcbn);    //  Init from memory image

    //  Attributes

    enum {Weight, Max, Average, Angle};

    WORD    Metric(unsigned u)
			{
			int bob = 5;
			return m_cwaMetrics[u];
			}

    //  operations
    enum {OK, TooBig, Reversed};    //  Returns from SetMetric

    WORD		SetMetric(unsigned u, WORD wNew);
    void		Store(CFile& cfStore, WORD wfSelection);
	CWordArray* GetFontSimDataPtr() { return &m_cwaMetrics ; }
};

/******************************************************************************

  CFontInfo class

  This primarily encapsulates the UFM file, but it also has to handle some PFM
  and IF stuff, so it truly is generic.

******************************************************************************/

class CFontInfo : public CProjectNode
{
	// True iff the font was loaded by the workspace OR the font was loaded
	// directly AND its GTT/CP was found and loaded.

	bool	m_bLoadedByWorkspace ;
	
	// The flag above has many uses now so another flag is needed.  This flag
	// is only set when the UFM is being loaded by a workspace and no GTT/CP
	// could be loaded for it.

	bool	m_bWSLoadButNoGTTCP ;

	//DWORD   m_loWidthTable ;			// Width table offset from UFM file.  Used as
										// part of variable font determination.

public:

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			//  UNIFM_HDR

ULONG			m_ulDefaultCodepage;	
WORD			m_lGlyphSetDataRCID;										//  Translation table ID			// rm new

	const WORD      Translation() const		{ return m_lGlyphSetDataRCID; }										// rm new
	void			SetTranslation(WORD w)	{ m_lGlyphSetDataRCID = w; }										// rm new


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UNIDRVINFO		m_UNIDRVINFO;												//  UNIDRVINFO						// rm new

BOOL			m_fScalable;

CInvocation     m_ciSelect, m_ciDeselect;																	// rm moved from below

CInvocation&    Selector(BOOL bSelect = TRUE)
					{ return bSelect ? m_ciSelect : m_ciDeselect; }												// rm moved from below

CString GTTDescription() const;

//	IFIMETRICS  //////////////////////////////////////////////// ////////////
private:
    CString&  Family(unsigned u) { return m_csaFamily[u]; }
public:
	IFIMETRICS		m_IFIMETRICS;																// rm new

    WORD    SetSignificant(WORD wItem, WORD wChar, BOOL bUnicode);

enum    {Default, Break};													// Used to set the wcDefaultChar, wcBreakChar,
																			//  chDefaultChar, and chBreakChar.
enum {OK, InvalidChar, DoubleByte};											// Return values for SetSignificant(WORD wItem, WORD wChar, BOOL bUnicode)


WORD m_InternalLeading;
WORD m_Lowerd;
WORD m_Lowerp;
WORD m_ItalicAngle;

CStringArray    m_csaFamily;
CString         m_csStyle, m_csFace, m_csUnique;							//  Various names

CWordArray      m_cwaSpecial;												//  Special, little-used metrics
//BYTE            m_bCharacterSet, m_bPitchAndFamily;						// rm no longer needede
WORD            m_wWeight, m_wHeight;

//WORD            m_wAverageWidth,  m_wMaximumIncrement, m_wfStyle;		// rm no longer needede

//CByteArray      m_cbaSignificant;											//  Significant char codes (e.g., break)
//CWordArray      m_cwaSignificant;																		// rm absorbed into m_IFIMETRICS


//    const CString&  StyleName() const			{ return m_csStyle; }
//    const CString&  FaceName() const			{ return m_csFace; }
//    const CString&  UniqueName() const			{ return m_csUnique; }
    unsigned        Families() const			{ return (unsigned) m_csaFamily.GetSize(); }

//    void    SetStyleName(LPCTSTR lpstrNew)	{ m_csStyle = lpstrNew;		Changed(); }
//    void    SetFaceName(LPCTSTR lpstrNew)	{ m_csFace = lpstrNew;		Changed(); }
    void    SetUniqueName(LPCTSTR lpstrNew) { m_csUnique = lpstrNew;	Changed(); }				// used by rcfile.cpp
    BOOL    AddFamily(LPCTSTR lpstrNew);
    void    RemoveFamily(LPCTSTR lpstrDead);


//    WORD    Family() const						{ return m_bPitchAndFamily & 0xF0; }			// rm no longer needed
//    WORD    CharSet() const						{ return m_bCharacterSet; }						// rm no longer needed
//    WORD    Weight() const						{ return m_wWeight; }								// rm no longer needed
    WORD    Height() const						{ return m_wHeight; }

//    WORD    MaxWidth() const					{ return m_wMaximumIncrement; }							// rm no longer needed
//    WORD    AverageWidth() const				{ return m_wAverageWidth; }								// rm no longer needed

//    enum    {Old_First, Last, Default, Break};
//    WORD    SignificantChar(WORD wid, BOOL bUnicode = TRUE) const										// rm no longer needed
//				{ return bUnicode ? m_cwaSignificant[wid] : m_cbaSignificant[wid];  }

//    void    InterceptItalic(CPoint& cpt) const;														// rm no longer needed


//    void    SetFamily(BYTE bNew)	{ m_bPitchAndFamily &= 0xF;	m_bPitchAndFamily |= (bNew & 0xF0);		// rm no longer needed
//									 Changed();	}
    BOOL    SetCharacterSet(BYTE bNew);
//    void    SetWeight(WORD wWeight) { m_wWeight = wWeight; Changed(); }								// rm no longer needed
    BOOL    SetHeight(WORD wHeight);
    void    SetMaxWidth(WORD wWidth);

    void    SetSpecial(unsigned ufMetric, short sSpecial);




    enum {Italic = 1, Underscore, StrikeOut = 0x10};



    void    ChangePitch(BOOL bFixed = FALSE);


    enum {	CapH, LowerX, SuperSizeX, SuperSizeY,			//
			SubSizeX, SubSizeY, SuperMoveX, SuperMoveY,
			SubMoveX, SubMoveY, ItalicAngle, UnderSize,
			UnderOffset, StrikeSize, StrikeOffset,
			oldBaseline,
			/*Baseline, */  InterlineGap, Lowerp, Lowerd,
			InternalLeading};

    const short     SpecialMetric(unsigned uIndex) const	{ return (short) m_cwaSpecial[uIndex]; }


	BOOL    DBCSFont() const															// rm new
		{ return  m_IFIMETRICS.jWinCharSet > 127 && m_IFIMETRICS.jWinCharSet < 145; }	//  This looks right, but no OFFICIAL way seems to exist


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			// FONT SIMULATIONS

CFontDifference *m_pcfdBold, *m_pcfdItalic, *m_pcfdBoth;					//  Simulations

enum {ItalicDiff, BoldDiff, BothDiff};

//    CFontDifference *Diff(unsigned u) {	return u ? u == BothDiff ? m_pcfdBoth : m_pcfdBold : m_pcfdItalic;	}

    CFontDifference *  Diff(unsigned u)
		{
		CFontDifference * FontDiff = m_pcfdBold;							// preset return value

		if (!u)				FontDiff = m_pcfdItalic;
		if (u == BothDiff)  FontDiff = m_pcfdBoth;
		return FontDiff;	
		}

    void    EnableSim(unsigned uSim, BOOL bOn, CFontDifference * & pcfd);
	CWordArray* GetFontSimDataPtr(int nid) ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EXTTEXTMETRIC	m_EXTTEXTMETRIC;											//	EXTTEXTMETRIC structure
BOOL			m_fEXTTEXTMETRIC;													// rm new
BOOL			m_fSave_EXT;

WORD    m_wMaxScale, m_wMinScale, m_wScaleDevice;
//BYTE    m_bfScaleOrientation;


//	BYTE  ScaleOrientation() const
//		  { return m_bfScaleOrientation & 3; }
	WORD  ScaleUnits(BOOL bDevice = TRUE) const
		  { return bDevice ? m_wScaleDevice : m_wHeight - m_InternalLeading; }		// m _cwaSpecial[InternalLeading];

	WORD  ScaleLimit(BOOL bMaximum = TRUE) const
		  { return  bMaximum ? m_wMaxScale : m_wMinScale; }


	enum {ScaleOK, Reversed, NotWindowed};

	WORD    SetScaleLimit(BOOL bMax, WORD wNew);
	WORD    SetDeviceEmHeight(WORD wNew);


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			//  FRAMEWORK OPERATIONS

CString         m_csSource;													//  The original PFM file name
CByteArray      m_cbaPFM;													//  Loaded image of the PFM file


	BOOL    MapPFM();														//  Assure the PFM file is loaded

DECLARE_SERIAL(CFontInfo)

public:
	void SetRCIDChanged(bool bFlags) { m_bRCIDChanged = bFlags ; } ;
	bool IsRCIDChanged() {return m_bRCIDChanged ; } ; 
	
	CLinkedList* CompareGlyphsEx(WORD wOld, WORD wNew, CLinkedList* pcll);

	
    CFontInfo();
    CFontInfo(const CFontInfo& cfiRef, WORD widCTT);						//  For cloning of UFMs
    ~CFontInfo();


    BOOL    Load(bool bloadedbyworkspace = false);							//  Load the UFM file so it can be edited
    BOOL    Store(LPCTSTR lpstrFileName, BOOL bStoreFromWorkspace = FALSE);	// raid 244123								//  Save as the specified UFM file
    BOOL    StoreGTTCPOnly(LPCTSTR lpstrFileName);							//  Save the UFM's GTT and CP fields

    virtual CMDIChildWnd*   CreateEditor();
    virtual void    Serialize(CArchive& car);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			//  ATTRIBUTES - CONVERSION SUPPORT

    const CString&  SourceName() const			{ return m_csSource; }

    void    SetSourceName(LPCTSTR lpstrNew);
    BOOL    SetFileName(LPCTSTR lpstrNew) ;
    int     GetTranslation(CSafeObArray& csoagtts);
    //int     GetTranslation();
    int     Generate(CString csPath);
//    void    SetTranslation(WORD w) { m_widTranslation = w; }					// rm ori - moved to new section
    void    SetTranslation(CGlyphMap* pcgm) { m_pcgmTranslation = pcgm; }

	// The following functions return the character range for the mapping table
	// in the UFM's corresponding GTT.  These are needed when a GTT needs to be
	// built for the UFM.

	WORD	GetFirst() { return ((WORD) m_IFIMETRICS.chFirstChar) ; }
	WORD	GetLast() { return ((WORD) m_IFIMETRICS.chLastChar) ; }
	WORD	GetFirstPFM() ;
	WORD	GetLastPFM() ;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			// CHARACTER WIDTHS PAGE

CGlyphMap*      m_pcgmTranslation;

CPtrArray       m_cpaGlyphs;
CPtrArray       m_cpaOldGlyphs;
CWordArray		m_cwaOldGlyphs ;
CWordArray		m_cwaNewGlyphs ;

CWordArray      m_cwaWidth;

	CTime	m_ctReloadWidthsTimeStamp ;	// The last time width info was reloaded

	CGlyphHandle&   Glyph(unsigned uid)
					{return *(CGlyphHandle *) m_cpaGlyphs[uid];}

    //BOOL IsVariableWidth() const
	//	{ return (m_loWidthTable || (m_IFIMETRICS.jWinPitchAndFamily & 2)) ; }
    BOOL            IsVariableWidth() const
						{ return !!m_cpaGlyphs.GetSize(); }					//  When variable widths change...
	
	void    CalculateWidths();								
	bool	CheckReloadWidths() ;	

enum    {Less, More, Equal};
    unsigned    CompareWidths(unsigned u1, unsigned u2);

    void    FillWidths(CListCtrl& clcView);									// Fill the control
    void    SetWidth(unsigned uGlyph, WORD wWidth, bool bcalc = true);
	bool	WidthsTableIsOK() ;

	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
																			// KERNING PAGE
	// Kerning structure- CSafeObArray which contains the kerning pairs.  Also,
	// a copy of m_csoaKern used during editing to make sure m_csoaKern isn't
	// permanently changed without user ok.

	CSafeObArray    m_csoaKern ;
	CSafeObArray    m_csoaKernCopy ;

    BOOL        CanKern() const	    { return !!m_csoaKern.GetSize(); }

    void        MapKerning(CSafeMapWordToOb& csmw2o1,
			               CSafeMapWordToOb& csmw2o2,
						   CWordArray& cwaPoints);

    unsigned    KernCount() const	{ return (unsigned) m_csoaKern.GetSize(); }

    unsigned    CompareKernAmount(unsigned u1, unsigned u2) const;
    unsigned    CompareKernFirst (unsigned u1, unsigned u2) const;
    unsigned    CompareKernSecond(unsigned u1, unsigned u2) const;
	WCHAR		GetKernFirst(unsigned u) const ;
	WCHAR		GetKernSecond(unsigned u) const ;
	short		GetKernAmount(unsigned u) const ;


    void    FillKern(CListCtrl& clcView);					//  Fill the control
    void    AddKern(WORD wFirst, WORD wSecond, short sAmount, CListCtrl& clcView);
    void    RemoveKern(unsigned u) { m_csoaKern.RemoveAt(u); Changed(); }
    void    SetKernAmount(unsigned u, short sAmount);
	void	MakeKernCopy() ;
	bool	LoadBadKerningInfo(CListCtrl& clcbaddata) ;
	bool	CodePointInGTT(WORD wcodepoint) ;
	void	SetNoGTTCP(bool bval) { m_bWSLoadButNoGTTCP = bval ; }

private:
	bool m_bRCIDChanged;
	bool FindAndLoadGTT();
};



/******************************************************************************

  CFontInfoContainer class

  This CDocument-derived class contains one CFontInfo structure- it allows to
  edit the font information either from the driver, os from an individual file.

******************************************************************************/

class CFontInfoContainer : public CDocument
{
    CFontInfo   *m_pcfi;
	bool		m_UFMSaved ;	// True iff an attempt to save the associated
								// UFM was just made.
protected:
	CFontInfoContainer();      // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFontInfoContainer)

// Attributes
public:
    BOOL        m_bEmbedded;	// UFM loaded from workspace
    CFontInfo   *Font() { return m_pcfi; }
// Operations
public:

    //  First a constructor for launching a view from the driver view.
    CFontInfoContainer(CFontInfo *pcfi, CString csPath);
	BOOL PublicSaveModified();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFontInfoContainer)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFontInfoContainer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CFontInfoContainer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\freeze.cpp ===
/******************************************************************************

  Source File:  Freeze.CPP

  This file implements the REC freezing and unfreezing routines.

******************************************************************************/

#include    "StdAfx.H"
#include    "MiniDev.H"
#include	<tom.h>


#ifdef	DEFINE_GUID
#undef	DEFINE_GUID
#endif
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

DEFINE_GUID(IID_ITextDocument,0x8CC497C0L,0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D);


/******************************************************************************

  InitFreeze

  Get the COM pointers needed to freeze and unfreeze a Rich Edit Control.

******************************************************************************/

void InitFreeze(HWND hedit, void** ppunk, void** ppdoc, long* plcount)
{
	::SendMessage(hedit, EM_GETOLEINTERFACE, 0, (LPARAM) ppunk) ;
	ASSERT(*ppunk != NULL) ;

	((IUnknown *) *ppunk)->QueryInterface(IID_ITextDocument, ppdoc) ;
	ASSERT(*ppdoc != NULL) ;
	
	*plcount = 0 ;

	TRACE("FRZ:  punk = %x\tpdoc = %x\n", *ppunk, *ppdoc) ;
}


/******************************************************************************

  Freeze

  Freeze a Rich Edit Control.

******************************************************************************/

void Freeze(void* pdoc, long* plcount)
{
	ASSERT(pdoc != NULL) ;
	((ITextDocument *) pdoc)->Freeze(plcount) ;
}


/******************************************************************************

  Unfreeze

  Unfreeze a Rich Edit Control.

******************************************************************************/

void Unfreeze(void* pdoc, long* plcount)
{
	ASSERT(pdoc != NULL) ;
	((ITextDocument *) pdoc)->Unfreeze(plcount) ;
}


/******************************************************************************

  ReleaseFreeze

  Release the COM pointers used to freeze and unfreeze a Rich Edit Control.

******************************************************************************/

void ReleaseFreeze(void** ppunk, void** ppdoc) 
{
	if (*ppdoc)
		((ITextDocument *) *ppdoc)->Release() ;
	if (*ppunk)
		((IUnknown *) *ppunk)->Release() ;
	*ppdoc = *ppunk = NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\freeze.h ===
void InitFreeze(HWND hedit, void** ppunk, void** ppdoc, long* plcount) ;
void Freeze(void* pdoc, long* plcount) ;
void Unfreeze(void* pdoc, long* plcount) ;
void ReleaseFreeze(void** ppunk, void** ppdoc) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontview.h ===
/******************************************************************************

  Header File:  Font Viewer.H

  This defines the classes used in viewing and editing font information for the
  studio.  The view consists of a property sheet with three pages to allow
  viewing and editing of the large quantity of data that describes the font.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-05-1997    Bob_Kjelgaard@Prodigy.Net   Created it.
  12-30-1997    Richard Mallonee			rewrote it totally

******************************************************************************/

#if !defined(AFX_FONTVIEW_H__D9456262_745B_11D2_AEDD_00C04FA30E4A__INCLUDED_)
#define AFX_FONTVIEW_H__D9456262_745B_11D2_AEDD_00C04FA30E4A__INCLUDED_


// Constants useful to the UFM Editor code.

const CString csField(_T("Field")) ;
const CString csValue(_T("Value")) ;


/******************************************************************************

  CFontWidthsPage class

  This class implements the character widths page for the font editor

******************************************************************************/

class CFontWidthsPage : public CToolTipPage
{
    CFontInfo   *m_pcfi;
    BYTE        m_bSortDescending;
    int         m_iSortColumn;

    static int CALLBACK Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis);

    int Sort(UINT_PTR id1, UINT_PTR id2);

// Construction
public:
	CFontWidthsPage();
	~CFontWidthsPage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }
	void	InitMemberVars() ;
	bool	ValidateUFMFields() ;
	bool	SavePageData() ;

	bool	m_bInitDone ;

// Dialog Data
	//{{AFX_DATA(CFontWidthsPage)
	enum { IDD = IDD_CharWidths };
	CListCtrl	m_clcView;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontWidthsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontWidthsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnEndlabeleditCharacterWidths(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickCharacterWidths(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownCharacterWidths(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CFontKerningPage class

  This class handles the Font Kerning structures, if there are any to be had.

******************************************************************************/

class CFontKerningPage : public CToolTipPage
{
    CFontInfo   *m_pcfi;
    int         m_idSelected;   //  Tracks selected item 
    unsigned    m_ufDescending; //  Sort order flags by column- 0 = Ascending;
    unsigned    m_uPrecedence[3];   //  Sort precedence, by column

    static int CALLBACK Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis);

    int Sort(unsigned u1, unsigned u2);

    enum    {Amount, First, Second};    //  Internal enum to control sorting

// Construction
public:
	CFontKerningPage();
	~CFontKerningPage();

    void    Init(CFontInfo *pcfi) { m_pcfi = pcfi; }
	void	InitMemberVars() ;
	bool	ValidateUFMFields() ;
	bool	SavePageData() ;

	bool	m_bInitDone ;

// Dialog Data
	//{{AFX_DATA(CFontKerningPage)
	enum { IDD = IDD_KerningPairs };
	CListCtrl	m_clcView;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontKerningPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontKerningPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnKeydownKerningTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndlabeleditKerningTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickKerningTree(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
    afx_msg void OnAddItem();
    afx_msg void OnDeleteItem();
    afx_msg void OnChangeAmount();
	DECLARE_MESSAGE_MAP()

};


class CFontViewer ;


/////////////////////////////////////////////////////////////////////////////
// CFontHeaderPage dialog

class CFontHeaderPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CFontHeaderPage)

// Attributes
public:
    CFontInfo*		m_pcfi ;		// UFM to display and edit
	CFontInfoContainer*	m_pcfic ;	// Parent document class
	bool			m_bInitDone ;	// True iff the page has been initialized
	CFontViewer*	m_pcfv ;		// Ptr to grandparent view class

// Construction
public:
	CFontHeaderPage();
	~CFontHeaderPage();

// Dialog Data
	//{{AFX_DATA(CFontHeaderPage)
	enum { IDD = IDD_UFM1_Header };
	CFullEditListCtrl	m_cfelcUniDrv;
	CString	m_csDefaultCodePage;
	CString	m_csRCID;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontHeaderPage)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontHeaderPage)
	afx_msg void OnChangeDefaultCodepageBox();
	afx_msg void OnChangeGlyphSetDataRCIDBox();
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusDefaultCodepageBox();
	afx_msg void OnKillfocusGlyphSetDataRCIDBox();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()

	void CheckHandleCPGTTChange(CString& csfieldstr, UINT ustrid) ;

public:

    void Init(CFontInfo *pcfi, CFontInfoContainer* pcfic, CFontViewer* pcfv) {
		m_pcfi = pcfi ;
		m_pcfic = pcfic ;
		m_pcfv = pcfv ;
	}
	bool ValidateUFMFields() ;
	bool SavePageData() ;
};


/////////////////////////////////////////////////////////////////////////////
// CFontIFIMetricsPage dialog

class CFontIFIMetricsPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CFontIFIMetricsPage)

// Attributes
public:
    CFontInfo		*m_pcfi ;			// UFM to display and edit
	bool			m_bInitDone ;		// True iff the page is initialized
	CStringArray	m_csaFamilyNames ;	// New UFM family names
    CWordArray		m_cwaBold ;			// New font simulation data
    CWordArray		m_cwaItalic ;		// New font simulation data
    CWordArray		m_cwaBoth ;			// New font simulation data
	CUIntArray		m_cuiaFontSimStates;// Is each font sim enabled?
	CUIntArray		m_cuiaSimTouched ;  // Has a font sim changed in any way?

// Construction
public:
	CFontIFIMetricsPage();
	~CFontIFIMetricsPage();

// Dialog Data
	//{{AFX_DATA(CFontIFIMetricsPage)
	enum { IDD = IDD_UFM2_IFIMetrics };
	CFullEditListCtrl	m_cfelcIFIMetrics;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontIFIMetricsPage)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontIFIMetricsPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()

	void IFILoadNamesData(CStringArray& csacoldata) ;
	void IFILoadValuesData(CStringArray& csacoldata) ;
	
public:
    void Init(CFontInfo *pcfi) { m_pcfi = pcfi ; }
	CWordArray* GetFontSimDataPtr(int nid) ;
	bool ValidateUFMFields() ;
	bool SavePageData() ;
	void SaveFontSimulations() ;
};


/////////////////////////////////////////////////////////////////////////////
// CFontExtMetricPage dialog

class CFontExtMetricPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CFontExtMetricPage)

// Attributes
public:
    CFontInfo   *m_pcfi ;
	bool		m_bInitDone ;	// True iff the page has been initialized

// Construction
public:
	CFontExtMetricPage();
	~CFontExtMetricPage();

// Dialog Data
	//{{AFX_DATA(CFontExtMetricPage)
	enum { IDD = IDD_UFM3_ExtMetrics };
	CFullEditListCtrl	m_cfelcExtMetrics;
	BOOL	m_bSaveOnClose;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFontExtMetricPage)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFontExtMetricPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSaveCloseChk();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()

	void EXTLoadNamesData(CStringArray& csacoldata) ;

public:
    void Init(CFontInfo *pcfi) { m_pcfi = pcfi ; }
	bool ValidateUFMFields() ;
	bool SavePageData() ;
};


/////////////////////////////////////////////////////////////////////////////
// CWidthKernCheckResults dialog

class CWidthKernCheckResults : public CDialog
{
// Construction
public:
	CWidthKernCheckResults(CWnd* pParent = NULL);   // standard constructor
	CWidthKernCheckResults(CFontInfo* pcfi, CWnd* pParent = NULL);   

// Dialog Data
	//{{AFX_DATA(CWidthKernCheckResults)
	enum { IDD = IDD_WidthKernCheckResults };
	CListCtrl	m_clcBadKernPairs;
	CString	m_csKernChkResults;
	CString	m_csWidthChkResults;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWidthKernCheckResults)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Atrributes
public:
	CFontInfo*	m_pcfi ;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWidthKernCheckResults)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  CFontViewer class
//
//  This is the CView-derived class which implements the font viewer.  It 
//  actually uses CPropertySheet and the preceding property page classes to do
//  most of its work.
//    
//    CFontHeaderPage	  m_cfhp 
//    CFontIFIMetricsPage m_cfimp 
//	  CFontExtMetricPage  m_cfemp 
//    CFontWidthsPage     m_cfwp 
//    CFontKerningPage    m_cfkp 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CFontViewer : public CView
{
    CPropertySheet      m_cps ;

	// Pages that make up the property sheet

    CFontHeaderPage		m_cfhp ; 
	CFontIFIMetricsPage m_cfimp ;
	CFontExtMetricPage  m_cfemp ;
    CFontWidthsPage     m_cfwp ;
    CFontKerningPage    m_cfkp ;


protected:
	CFontViewer();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFontViewer)

// Attributes
public:
    CFontInfoContainer  *GetDocument() { return (CFontInfoContainer *) m_pDocument;   }

// Operations
public:
	bool ValidateSelectedUFMDataFields() ;
	bool SaveEditorDataInUFM() ;
	void HandleCPGTTChange(bool bgttidchanged) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFontViewer)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFontViewer();

	// Generated message map functions
protected:
	//{{AFX_MSG(CFontViewer)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


// This string is used by a lot of the UFM Editor's subordinate dialog boxes.

const LPTSTR lptstrSet = _T("Set") ;


/////////////////////////////////////////////////////////////////////////////
// CGenFlags dialog

class CGenFlags : public CDialog
{
// Construction
public:
	CGenFlags(CWnd* pParent = NULL);   // standard constructor
	CGenFlags(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of GenFlags

// Dialog Data
	//{{AFX_DATA(CGenFlags)
	enum { IDD = IDD_UFM1S_GenFlags };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGenFlags)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGenFlags)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CHdrTypes dialog

class CHdrTypes : public CDialog
{
// Construction
public:
	CHdrTypes(CWnd* pParent = NULL);   // standard constructor
	CHdrTypes(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of wTypes

// Dialog Data
	//{{AFX_DATA(CHdrTypes)
	enum { IDD = IDD_UFM1S_Types };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHdrTypes)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHdrTypes)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CHdrCaps dialog

class CHdrCaps : public CDialog
{
// Construction
public:
	CHdrCaps(CWnd* pParent = NULL);   // standard constructor
	CHdrCaps(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of fCaps

// Dialog Data
	//{{AFX_DATA(CHdrCaps)
	enum { IDD = IDD_UFM1S_Caps };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHdrCaps)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CHdrCaps)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIFamilyNames dialog

class CFIFIFamilyNames : public CDialog
{
// Attributes
public:
	bool		m_bInitDone ;	// True iff the page has been initialized
	bool		m_bChanged ;	// True iff the names list changed
	CFontIFIMetricsPage*	m_pcfimp ;	// Ptr to IFIMetrics page
	CString*	m_pcsFirstName ;// First family name displayed in IFI page
	
// Construction
public:
	CFIFIFamilyNames(CWnd* pParent = NULL);   // standard constructor
	CFIFIFamilyNames(CString* pcsfirstname, CFontIFIMetricsPage* pcfimp, 
					 CWnd* pParent = NULL) ;

// Dialog Data
	//{{AFX_DATA(CFIFIFamilyNames)
	enum { IDD = IDD_UFM2S_Family };
	CFullEditListCtrl	m_cfelcFamilyNames;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIFamilyNames)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIFamilyNames)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIFontSims dialog

class CFIFIFontSims : public CDialog
{
// Attributes
public:
	CFontIFIMetricsPage*	m_pcfimp ;	// Ptr to IFIMetrics page
	CString*	m_pcsFontSimData ;		// 1st family name displayed in IFI page
	bool		m_bChanged ;			// True iff amy font sim info changed
	bool		m_bInitDone ;			// True iff the page has been init'ed
	CUIntArray	m_cuiaFontSimGrpLoaded ;// When font sim groups have been loaded

// Construction
public:
	CFIFIFontSims(CWnd* pParent = NULL);   // standard constructor
	CFIFIFontSims(CString* pcsfontsimdata, CFontIFIMetricsPage* pcfimp, 
	 			  CWnd* pParent = NULL) ;

// Dialog Data
	//{{AFX_DATA(CFIFIFontSims)
	enum { IDD = IDD_UFM2S_FontSims };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIFontSims)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIFontSims)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
    afx_msg void OnSetAnySimState(unsigned ucontrolid) ;
    afx_msg void OnChangeAnyNumber(unsigned ucontrolid) ;
	DECLARE_MESSAGE_MAP()

	void InitSetCheckBox(int ncontrolid) ;
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinCharSet dialog

class CFIFIWinCharSet : public CDialog
{
// Construction
public:
	CFIFIWinCharSet(CWnd* pParent = NULL);   // standard constructor
	CFIFIWinCharSet(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of wTypes

// Dialog Data
	//{{AFX_DATA(CFIFIWinCharSet)
	enum { IDD = IDD_UFM2S_WinCharSet };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIWinCharSet)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIWinCharSet)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinPitchFamily dialog

class CFIFIWinPitchFamily : public CDialog
{
// Construction
public:
	CFIFIWinPitchFamily(CWnd* pParent = NULL);   // standard constructor
	CFIFIWinPitchFamily(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of wTypes

// Dialog Data
	//{{AFX_DATA(CFIFIWinPitchFamily)
	enum { IDD = IDD_UFM2S_WinPitchFamily };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIWinPitchFamily)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIWinPitchFamily)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIInfo dialog

class CFIFIInfo : public CDialog
{
// Construction
public:
	CFIFIInfo(CWnd* pParent = NULL);   // standard constructor
	CFIFIInfo(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of wTypes

// Dialog Data
	//{{AFX_DATA(CFIFIInfo)
	enum { IDD = IDD_UFM2S_Info };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIInfo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIInfo)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void InfoLoadNamesData(CStringArray& csafieldnames) ;
} ;


/////////////////////////////////////////////////////////////////////////////
// CFIFISelection dialog

class CFIFISelection : public CDialog
{
// Construction
public:
	CFIFISelection(CWnd* pParent = NULL);   // standard constructor
	CFIFISelection(CString* pcsflags, CWnd* pParent = NULL);   

	CString*	m_pcsFlags ;	// String version of wTypes

// Dialog Data
	//{{AFX_DATA(CFIFISelection)
	enum { IDD = IDD_UFM2S_Selection };
	CFlagsListBox	m_cflbFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFISelection)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFISelection)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIPoint dialog

class CFIFIPoint : public CDialog
{
// Attributes
public:
	bool		m_bInitDone ;	// True iff the dlg has been initialized
	bool		m_bChanged ;	// True iff the point list changed
	CString*	m_pcsPoint ;	// Point info to/from IFI page

// Construction
public:
	CFIFIPoint(CWnd* pParent = NULL);   // standard constructor
	CFIFIPoint(CString* pcspoint, CWnd* pParent = NULL) ;

// Dialog Data
	//{{AFX_DATA(CFIFIPoint)
	enum { IDD = IDD_UFM2S_Point };
	CFullEditListCtrl	m_cfelcPointLst;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIPoint)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIPoint)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIRectangle dialog

class CFIFIRectangle : public CDialog
{
// Attributes
public:
	bool		m_bInitDone ;	// True iff the dlg has been initialized
	bool		m_bChanged ;	// True iff the point list changed
	CString*	m_pcsRect ;		// Rectangle info to/from IFI page

// Construction
public:
	CFIFIRectangle(CWnd* pParent = NULL);   // standard constructor
	CFIFIRectangle(CString* pcsrect, CWnd* pParent = NULL) ;

// Dialog Data
	//{{AFX_DATA(CFIFIRectangle)
	enum { IDD = IDD_UFM2S_Rect };
	CFullEditListCtrl	m_cfelcSidesLst;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIRectangle)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIRectangle)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFIFIPanose dialog

class CFIFIPanose : public CDialog
{
// Attributes
public:
	bool		m_bInitDone ;	// True iff the dlg has been initialized
	bool		m_bChanged ;	// True iff the point list changed
	CString*	m_pcsPanose ;	// Panose info to/from IFI page

// Construction
public:
	CFIFIPanose(CWnd* pParent = NULL);   // standard constructor
	CFIFIPanose(CString* pcspanose, CWnd* pParent = NULL) ;

// Dialog Data
	//{{AFX_DATA(CFIFIPanose)
	enum { IDD = IDD_UFM2S_Panose };
	CFullEditListCtrl	m_cfelcPanoseLst;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFIFIPanose)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFIFIPanose)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	afx_msg LRESULT OnListCellChanged(WPARAM wParam, LPARAM lParam) ;
	DECLARE_MESSAGE_MAP()
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FONTVIEW_H__D9456262_745B_11D2_AEDD_00C04FA30E4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\glue.cpp ===
/******************************************************************************

  Source File:  Glue.CPP

  This file contains the functions needed to make the GPD parser code work on
  both platforms, as well as stubs to support function I do not need to supply.

  Copyright (c) 1997 by Microsoft Corporation,  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03/28/1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "ProjNode.H"
#include    "Resource.H"
#include    "GPDFile.H"

//  I'll use a class to guarantee memory never leaks from here.

class   CMaps {
    CObArray    m_coaMaps;

public:
    CMaps() { m_coaMaps.Add(NULL); }
    ~CMaps() {
        for (int i = 0; i < m_coaMaps.GetSize(); i++)
            if  (m_coaMaps[i])
                delete  m_coaMaps[i];
    }
    unsigned    Count() { return (unsigned)m_coaMaps.GetSize(); }
    unsigned    HandleFor(CByteArray* cba) {
        for (unsigned u = 1; u < Count(); u++) {
            if  (!m_coaMaps[u]) {
                m_coaMaps[u] = cba;
                return  u;
            }
        }
        m_coaMaps.Add(cba);
        return  Count();
    }

    void    Free(unsigned u) {
        if  (!u || u >= Count() || !m_coaMaps[u])
            return;

        delete  m_coaMaps[u];
        m_coaMaps[u] = NULL;
    }
};

static CMaps    scmAll;

extern "C" unsigned MapFileIntoMemory(LPCWSTR pstrFile, PVOID *ppvData,
                                      PDWORD pdwSize) {

    if  (!pstrFile || !ppvData || !pdwSize)
        return  0;

    CFile   cfMap;
    CByteArray* pcbaMap = new CByteArray;
    CString csFile(pstrFile);

    if  (!pcbaMap)
        return  0;

    if  (!cfMap.Open(csFile, CFile::modeRead | CFile::shareDenyWrite))
        return  0;

    try {
        pcbaMap -> SetSize(*pdwSize = cfMap.GetLength());
        cfMap.Read(pcbaMap -> GetData(), cfMap.GetLength());
        *ppvData = pcbaMap -> GetData();
        return  scmAll.HandleFor(pcbaMap);
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
    }

    return  0;
}

extern "C" void UnmapFileFromMemory(unsigned uFile) {
    scmAll.Free(uFile);
}

//  This one is just a stub to make the whole thing work for us- we don't use
//  the checksum- it's there for the end product to tell if a GPD file has
//  been altered since it was converted lase.

extern "C" DWORD    ComputeCrc32Checksum(PBYTE pbuf,DWORD dwCount,
                                         DWORD dwChecksum) {
    return  dwCount ^ dwChecksum ^ (PtrToUlong(pbuf));
}

// The next two variables are used to control how and when GPD parsing/conversion
// log messages are saved.
//		pcsaLog				Ptr to string array to load with messages
//		bEnableLogging		True iff logging is enabled

static CStringArray*    pcsaLog = NULL ;
static bool			    bEnableLogging = false ;


/******************************************************************************

  CModelData::SetLog

  Prepare to log parse/conversion error and warning messages.

******************************************************************************/

void CModelData::SetLog()
{
    m_csaConvertLog.RemoveAll() ;
    pcsaLog = &m_csaConvertLog ;
	bEnableLogging = true ;
}


/******************************************************************************

  CModelData::EndLog

  Turn off parse/conversion error and warning message logging.

******************************************************************************/

void CModelData::EndLog()
{
    pcsaLog = NULL ;
	bEnableLogging = false ;
}


/******************************************************************************

  DebugPrint

  This routine is called to log the parsing/conversion error and warning
  messages.

******************************************************************************/

extern "C" void DebugPrint(LPCTSTR pstrFormat, ...)
{
    CString csOutput;
    va_list ap;

	// Don't do anything if logging is not enabled.

	if (!bEnableLogging)
		return ;

    va_start(ap, pstrFormat);
    vsprintf(csOutput.GetBuffer(1000), pstrFormat, ap);
    va_end(ap);
    csOutput.ReleaseBuffer();
    csOutput.TrimLeft();
    CStringArray&   csaError = *pcsaLog;

	// If this routine is being called when we're NOT recording problems with a
	// GPD, display the message when debugging.

	if (pcsaLog == NULL) {
		CString csmsg ;
		csmsg.LoadString(IDS_XXXUnexpectedCPError) ;
		csmsg += csOutput ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
//#ifdef _DEBUG
//		afxDump << csOutput ;
//		if (csOutput.Right(1) != _T("\n"))
//			afxDump << _T("\n") ;
//#endif
		return ;
	} ;

    if  (!csaError.GetSize()) {
        csaError.Add(csOutput);
        return;
    }

    if  (csaError[-1 + csaError.GetSize()].Find(_T('\n')) >= 0) {
        csaError[-1 + csaError.GetSize()].TrimRight();
        pcsaLog -> Add(csOutput);
    }
    else
        csaError[-1 + csaError.GetSize()] += csOutput;
}

/******************************************************************************

  MDSCreateFileW

  I implement a version of this API here which calls the ANSI API, so I can
  compile the parser code with UNICODE on, but still run the resulting binary
  on Win95.

******************************************************************************/

extern "C" HANDLE MDSCreateFileW(LPCWSTR lpstrFile, DWORD dwDesiredAccess,
                                 DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpsa,
                                 DWORD dwCreateFlags, DWORD dwfAttributes,
                                 HANDLE hTemplateFile) {
    CString csFile(lpstrFile);  //  Let CString conversions do the hard work!

    return  CreateFile(csFile, dwDesiredAccess, dwShareMode, lpsa,
        dwCreateFlags, dwfAttributes, hTemplateFile);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\fontview.cpp ===
/******************************************************************************

  Source File:  Font Viewer.CPP

  This implements the various classes that make up the font editor for the
  studio.  The editor is basically a property sheet with a sizable collection
  of pages.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  03-05-1997    Bob_Kjelgaard@Prodigy.Net



	NOTES:		an FWORD is a short int

	The PANOSE structure describes the PANOSE font-classification values for a TrueType font.
	These characteristics are then used to associate the font with other fonts of similar appearance but different names.

	typedef struct tagPANOSE { // pnse
		BYTE bFamilyType;
		BYTE bSerifStyle;
		BYTE bWeight;
		BYTE bProportion;
		BYTE bContrast;
		BYTE bStrokeVariation;
		BYTE bArmStyle;
		BYTE bLetterform;
		BYTE bMidline;
		BYTE bXHeight;
	} PANOSE


******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "ChildFrm.H"    //  Definition of Tool Tips Property Page class
#include    "comctrls.h"
#include	<stdlib.h>
#include    "FontView.H"	//  FontView.H also includes comctrls.h
#include	"rcfile.h"


/******************************************************************************

  CFontViewer class- this is the guy who owns the overall control of the view,
  although he wisely delegates the work to the MFC Property Sheet class and the
  other view classes.  I should be so wise.

******************************************************************************/

IMPLEMENT_DYNCREATE(CFontViewer, CView)

CFontViewer::CFontViewer() {
}

CFontViewer::~CFontViewer() {
}


BEGIN_MESSAGE_MAP(CFontViewer, CView)
	//{{AFX_MSG_MAP(CFontViewer)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontViewer drawing

void CFontViewer::OnDraw(CDC* pDC) {	CDocument* pDoc = GetDocument();}

CFontInfo   * gpCFontInfo;

/******************************************************************************

  CFontViewer::OnInitialUpdate

  This handles the initial update of the view, meaning all of the background
  noise of creation is essentially complete.

  I initialize the property pages by pointing each to the underlying CFontInfo,
  add them to the property sheet as needed, then create the sheet, position it
  so it aligns with the view, then adjust the owning frame's size and style so
  that everything looks like it really belongs where it is.

******************************************************************************/

void CFontViewer::OnInitialUpdate()
{
	CFontInfo   *pcfi = GetDocument()->Font();

	gpCFontInfo = pcfi;

    if  (pcfi->Name().IsEmpty())
		{
        pcfi->Rename(GetDocument()->GetTitle());
        GetDocument()->SetModifiedFlag(FALSE);			//  Rename sets it
		}

    m_cps.Construct(IDR_MAINFRAME, this);

    // Each property page needs a pointer to the fontinfo class

    m_cfhp.Init(pcfi, (CFontInfoContainer*) GetDocument(), this);
    m_cfimp.Init(pcfi);
    m_cfemp.Init(pcfi);
    m_cfwp.Init(pcfi);
    m_cfkp.Init(pcfi);

	// Add each property page to the property sheet
    m_cps.AddPage(&m_cfhp);
    m_cps.AddPage(&m_cfimp);
    m_cps.AddPage(&m_cfemp);
    m_cps.AddPage(&m_cfwp);
    m_cps.AddPage(&m_cfkp);

	//  Create the property sheet

    m_cps.Create(this, WS_CHILD, WS_EX_CLIENTEDGE);

    //  Get the bounding rectangle, and use it to set the frame size,
    //  after first using it to align the origin with this view.

    CRect   crPropertySheet;
    m_cps.GetWindowRect(crPropertySheet);

	// Position property sheet within the child frame

	crPropertySheet -= crPropertySheet.TopLeft();
    m_cps.MoveWindow(crPropertySheet, FALSE);								
																			
    GetParentFrame()->CalcWindowRect(crPropertySheet);
    GetParentFrame()->SetWindowPos(NULL, 0, 0, crPropertySheet.Width(),
        crPropertySheet.Height(),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE);
	CView::OnInitialUpdate();
    m_cps.ShowWindow(SW_SHOWNA);
  //  GetParentFrame() -> ShowWindow(SW_SHOW);
}


/******************************************************************************

  CFontViewer::OnActivateView

  For some reason, the property sheet does not get the focus when the frame is
  activated (probably the view class takes it away from us).  This little gem
  makes sure keyboard users don't get miffed by this.

******************************************************************************/

void    CFontViewer::OnActivateView(BOOL bActivate, CView* pcvActivate,CView* pcvDeactivate)
{
    //  In case the base class does anything else of value, pass it on...

	CView::OnActivateView(bActivate, pcvActivate, pcvDeactivate);

    if  (bActivate)
        m_cps.SetFocus();
}


/******************************************************************************

  CFontViewer::OnDestroy

  This override is used to inform the embedded font that we are being
  destroyed.  If we were created by the font, then it will NULL its pointer
  to us, and won't try to destroy us when it is destroyed.

******************************************************************************/

void CFontViewer::OnDestroy()
{
	CView::OnDestroy();
	
	if  (GetDocument() -> Font())
        GetDocument() -> Font() -> OnEditorDestroyed();
}


/******************************************************************************

  CFontViewer::ValidateUFM

  This routine manages UFM field validation.  The data to be validated is in
  the controls on the property pages and in various other member variables
  because this is the data the user has just modified.  It is the most up to
  data.  Data is not saved back into the CFontInfo class until the user closes
  the document (essentially, the UFM Editor) and says to save its contents.

  Each page function is called to perform the validation on the fields diplayed
  on its page.  If a check fails and the user wants to fix the problem, true
  is returned.  Otherwise, false is returned.

  Note:
	Not every field in the UFM is validated.  Only those specified by Ganesh
	Pandey, MS Printer Driver Development team, are checked.  The fields are
	listed in the Minidriver Development Tool Work List revision 5.  See the
	ValidateUFMFields() routines in each page clase for more details.

******************************************************************************/
				
bool CFontViewer::ValidateSelectedUFMDataFields()
{
	// Validate data on the headers page.

	if (m_cfhp.ValidateUFMFields()) {
		m_cps.SetActivePage(&m_cfhp) ;
		m_cfhp.m_cfelcUniDrv.SetFocus() ;
		return true ;
	} ;

	// Validate data on the IFIMetrics page.

	if (m_cfimp.ValidateUFMFields()) {
		m_cps.SetActivePage(&m_cfimp) ;
		return true ;
	} ;

	// Validate data on the ExtMetrics page.

	if (m_cfemp.ValidateUFMFields()) {
		m_cps.SetActivePage(&m_cfemp) ;
		m_cfemp.m_cfelcExtMetrics.SetFocus() ;
		return true ;
	} ;

	// Validate data on the widths page.

	if (m_cfwp.ValidateUFMFields()) {
		m_cps.SetActivePage(&m_cfwp) ;
		return true ;
	} ;

	// Validate data on the kerning pairs page.

	if (m_cfkp.ValidateUFMFields()) {
		m_cps.SetActivePage(&m_cfkp) ;
		return true ;
	} ;

	// All checks passed or the user doesn't want to fix the problems...

	return false ;
}


/******************************************************************************

  CFontViewer::SaveEditorDataInUFM

  Manage saving all editor data.  By "save", I mean copy all of the data
  collected in the UFM Editor's controls back into the correct variables and
  structures in the CFontInfo class instance associated with this instance of
  the UFM Editor.  See CFontInfoContainer::OnSaveDocument() for	more info.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/
				
bool CFontViewer::SaveEditorDataInUFM()
{
	// Save data on the headers page.

	if (m_cfhp.SavePageData())
		return true ;

	// Save data on the IFIMetrics page.

	if (m_cfimp.SavePageData())
		return true ;

	// Save data on the ExtMetrics page.

	if (m_cfemp.SavePageData())
		return true ;

	// Save data on the widths page.

	if (m_cfwp.SavePageData())
		return true ;

	// Save data on the kerning pairs page.

	if (m_cfkp.SavePageData())
		return true ;

	// All went well so...

	return false ;
}


/******************************************************************************

  CFontViewer::HandleCPGTTChange


******************************************************************************/

void CFontViewer::HandleCPGTTChange(bool bgttidchanged)
{
	// Get a ptr to the doc class and a pointer to the font class.

	CFontInfoContainer* pcfic = GetDocument() ;
	CFontInfo *pcfi = pcfic->Font();

	// Save the UFM.  Bail if this doesn't work for some reason.

	// If the UFM was loaded stand alone and there is a GTT to free, do it.
	// (Code pages loaded as GTTs are not freed here.  That is done at program
	// exit.)  Always clear the GTT pointer.

    if  (!pcfic->m_bEmbedded && pcfi) {
		if (pcfi->m_pcgmTranslation && pcfi->m_lGlyphSetDataRCID != 0)
			delete pcfi->m_pcgmTranslation ;
	} ;
	pcfi->m_pcgmTranslation = NULL ;

	// If the UFM was loaded from a workspace, try to use the workspace data to
	// find and load a pointer to the new GTT and finish loading the font.

	if (pcfic->m_bEmbedded) {
	    CDriverResources* pcdr = (CDriverResources*) pcfi->GetWorkspace() ;
		pcdr->LinkAndLoadFont(*pcfi, false, true ) ; // raid 0003

	// If the UFM was loaded stand alone the first time, reload it the same way
	// and let the load routine handle finding the GTT info.

	} else
		pcfi->Load(false) ;

	// If the widths page has been initialized already, reload the widths list
	// control with the updated data and reset the associated member variables.
	pcfi->CheckReloadWidths() ;
	pcfi->SetRCIDChanged(false) ;
	// check the widthtable existence instead initializ of the  m_clcView
//	if (m_cfwp.m_bInitDone) {	raid 0003
	if (m_cfwp.m_bInitDone) {
		m_cfwp.InitMemberVars() ;
		m_cfwp.m_clcView.DeleteAllItems() ;
		pcfi->FillWidths(m_cfwp.m_clcView) ;
		m_cfwp.m_clcView.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED,
									   LVIS_SELECTED | LVIS_FOCUSED) ;
	} ;

	// If the kerning page has been initialized already, reload the kerning list
	// control with the updated data and reset the associated member variables.

	if (m_cfkp.m_bInitDone) {
		m_cfkp.InitMemberVars() ;
		m_cfkp.m_clcView.DeleteAllItems() ;
		pcfi->FillKern(m_cfkp.m_clcView) ;
		pcfi->MakeKernCopy() ;
	} ;

	// Check the state of the widths and kerning tables.  Then display the
	// results.

	CWidthKernCheckResults cwkcr(pcfi) ;
	cwkcr.DoModal() ;
}


/******************************************************************************

  CheckUFMString, CheckUFMGrter0, CheckUFMNotEq0, CheckUFMBool

  These 4 routines are used to optimize UFM validation checks.  Each one does
  a different kind of check.  If the check fails, an error message is displayed.
  If the user wants to fix the problem, the routine will select the appropriate
  field and return true.  Otherwise, they return false.

  CheckUFMBool is different in one respect.  The comparison is maded in the
  calling function and the result is passed to CheckUFMBool as a parameter.

******************************************************************************/

bool CheckUFMString(CString& csdata, CString& cspage, LPTSTR pstrfieldname,
					int nfld, CFullEditListCtrl& cfelc)
{
	csdata.TrimLeft() ;
	csdata.TrimRight() ;

	if (csdata.GetLength() == 0) {
		CString csmsg ;
		csmsg.Format(IDS_EmptyStrError, cspage, pstrfieldname) ;
		if (AfxMessageBox(csmsg, MB_YESNO+MB_ICONEXCLAMATION) == IDYES) {
			cfelc.SingleSelect(nfld) ;
			cfelc.SetFocus() ;
			return true ;
		} ;
	} ;

	return false ;
}

		
bool CheckUFMGrter0(CString& csdata, CString& cspage, LPTSTR pstrfieldname,
					int nfld, CFullEditListCtrl& cfelc)
{
	if (atoi(csdata) <= 0) {
		CString csmsg ;
		csmsg.Format(IDS_LessEqZeroError, cspage, pstrfieldname) ;
		if (AfxMessageBox(csmsg, MB_YESNO+MB_ICONEXCLAMATION) == IDYES) {
			cfelc.SingleSelect(nfld) ;
			cfelc.SetFocus() ;
			return true ;
		} ;
	} ;

	return false ;
}

	
bool CheckUFMNotEq0(int ndata, CString& cspage, LPTSTR pstrfieldname,
					int nfld, CFullEditListCtrl& cfelc)
{
	if (ndata == 0) {
		CString csmsg ;
		csmsg.Format(IDS_EqualsZeroError, cspage, pstrfieldname) ;
		if (AfxMessageBox(csmsg, MB_YESNO+MB_ICONEXCLAMATION) == IDYES) {
			cfelc.SingleSelect(nfld) ;
			cfelc.SetFocus() ;
			return true ;
		} ;
	} ;

	return false ;
}

	
bool CheckUFMBool(bool bcompres, CString& cspage, LPTSTR pstrfieldname,
				  int nfld, CFullEditListCtrl& cfelc, int nerrorid)
{
	if (bcompres) {
		CString csmsg ;
		csmsg.Format(nerrorid, cspage, pstrfieldname) ;
		if (AfxMessageBox(csmsg, MB_YESNO+MB_ICONEXCLAMATION) == IDYES) {
			cfelc.SingleSelect(nfld) ;
			cfelc.SetFocus() ;
			return true ;
		} ;
	} ;

	return false ;
}

	
/******************************************************************************

  CFontWidthsPage property page class

  This class handles the UFM editor Character Widths page.  It is derived from
  the Tool Tip Page class.  The page consists of a list view control in which
  the code points and their associated widths are displayed.

******************************************************************************/

/******************************************************************************

  CFontWidthsPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lp3)

  This is a private static member function- a callback for sorting the list.
  The first two parameters are the LPARAM members of two list view items- in
  this case, the indices of two code points.  The final one is supplied by the
  caller of the sort routine.  In this case, it is a pointer to the caller.

  Handling it is trivial- dereference the this pointer, and let the private
  member function for sorting handle it.

******************************************************************************/

int CALLBACK    CFontWidthsPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lp3) {
    CFontWidthsPage *pcfwp = (CFontWidthsPage *) lp3;
    _ASSERT(pcfwp);

    return  pcfwp -> Sort(lp1, lp2);
}

/******************************************************************************

  CFontWidthsPage::Sort(unsigned id1, unsigned id2)

  This is a private member function which compares the two glyph handles at the
  two indices given by the established sort criteria.

  It returns negative for 1 < 2, positive for 1 > 2, and 0 for 1 = 2- pretty
  standard stuff.

  The sort column member determines the order of precedence in which the
  sorting is to be done, while the SortDescending member is a bitfield showing
  the sort direction in each column.

*******************************************************************************/

int CFontWidthsPage::Sort(UINT_PTR id1, UINT_PTR id2) {

    //  If the Primnary sort is by widths- weed it out first.

    if  (!m_iSortColumn)
        switch  (m_pcfi -> CompareWidths((unsigned)id1, (unsigned)id2)) {
        case    CFontInfo::More:
            return  (m_bSortDescending & 1) ? -1 : 1;
        case    CFontInfo::Less:
            return  (m_bSortDescending & 1) ? 1 : -1;
        }

    //  Sort is by Unicode point- this is always well-ordered
    //  Furthermore, the glyph handles are always in ascending order, making
    //  This test trivial.

    return  (!(m_bSortDescending & 2) ^ (id1 < id2)) ? 1 : -1;
}


CFontWidthsPage::CFontWidthsPage() : CToolTipPage(CFontWidthsPage::IDD)
{
	//{{AFX_DATA_INIT(CFontWidthsPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = false;
	m_uHelpID = HID_BASE_RESOURCE + IDR_FONT_VIEWER ;
    InitMemberVars() ;
}


/******************************************************************************

  CFontWidthsPage::InitMemberVars

  Initialize the member variables that must be initialized both during
  construction and when the UFM is reloaded because of a GTT or CP change.

******************************************************************************/

void CFontWidthsPage::InitMemberVars()
{
    m_bSortDescending = 0;
    m_iSortColumn = 1;
}


CFontWidthsPage::~CFontWidthsPage() {
}


void CFontWidthsPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontWidthsPage)
	DDX_Control(pDX, IDC_CharacterWidths, m_clcView);
	//}}AFX_DATA_MAP
}


/******************************************************************************

  CFontWidthsPage::OnSetActive

  This member will be called by the framework when the page is made active.
  The base class gets this first, and it will initialize everything the first
  time.

  This is here to update the view on subsequent activations, so we can
  seamlessly handle changes from fixed to variable pitch and back.

******************************************************************************/

BOOL    CFontWidthsPage::OnSetActive() {
    if  (!CToolTipPage::OnSetActive())
        return  FALSE;

    //  IsVariableWidth is either 0 or 1, so == is safe, here
	
    if  (m_pcfi -> IsVariableWidth() == !!m_clcView.GetItemCount())
        return  TRUE;   //  Everything is copacetic
	
    if  (m_clcView.GetItemCount())
        m_clcView.DeleteAllItems();
    else
        m_pcfi -> FillWidths(m_clcView);

    m_clcView.EnableWindow(m_pcfi -> IsVariableWidth());

    return  TRUE;
}

BEGIN_MESSAGE_MAP(CFontWidthsPage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontWidthsPage)
	ON_NOTIFY(LVN_ENDLABELEDIT, IDC_CharacterWidths, OnEndlabeleditCharacterWidths)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_CharacterWidths, OnColumnclickCharacterWidths)
	ON_NOTIFY(LVN_KEYDOWN, IDC_CharacterWidths, OnKeydownCharacterWidths)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFontWidthsPage message handlers

/******************************************************************************

  CFontWidthsPage::OnInitDialog

  This member function initializes the list view and fills it with the font
  width information.  Before doing this, check to see if the font's width info
  should be reloaded.  (See CFontInfo::CheckReloadWidths() for more info.)

******************************************************************************/

BOOL CFontWidthsPage::OnInitDialog()
{
	CToolTipPage::OnInitDialog();
	
	m_pcfi->CheckReloadWidths()  ;	// Update font width info when necessary

    CString csWork;
    csWork.LoadString(IDS_WidthColumn0);

    m_clcView.InsertColumn(0, csWork, LVCFMT_CENTER,
        m_clcView.GetStringWidth(csWork) << 1, 0);

    csWork.LoadString(IDS_WidthColumn1);

    m_clcView.InsertColumn(1, csWork, LVCFMT_CENTER,
        m_clcView.GetStringWidth(csWork) << 1, 1);
	
    m_pcfi -> FillWidths(m_clcView);
    m_clcView.SetItemState(0, LVIS_SELECTED | LVIS_FOCUSED,
        LVIS_SELECTED | LVIS_FOCUSED);
	
	m_bInitDone = true ;
	return TRUE;
}



/******************************************************************************

  CFontWidthsPage::OnEndlabeleditCharacterWidths

  This is where we find out the user actually wanted to change the width of a
  character.  So, not too surprisingly, we do just that (and also update the
  maximum and average widths if this isn't a DBCS font).

******************************************************************************/

void CFontWidthsPage::OnEndlabeleditCharacterWidths(NMHDR* pnmh, LRESULT* plr)
{
	LV_DISPINFO* plvdi = (LV_DISPINFO*) pnmh;
	
	*plr = 0;   //  Assume failure

    if  (!plvdi -> item.pszText) //  Editing canceled?
        return;

	// Get and trim the new width string.

    CString csNew(plvdi -> item.pszText);
    csNew.TrimRight();
    csNew.TrimLeft();

	// Complain if the new width contains invalid characters.

    if  (csNew.SpanIncluding("1234567890").GetLength() != csNew.GetLength()) {
        AfxMessageBox(IDS_InvalidNumberFormat);
        return;
    }

	// Do not update the CFontInfo class now anymore.  This should be done
	// later.  We should mark the class as having changed so that we are
	// prompted to save this data later.

    //m_pcfi -> SetWidth(plvdi -> item.iItem, (WORD) atoi(csNew));
	m_pcfi -> Changed() ;
    *plr = TRUE;
}


/******************************************************************************

  CFontWidthsPage::OnColumnClickCharacterWidths

  This little ditty tells us one of the column headers was clicked.  We
  obligingly either change sort direction or precednce to match, and then sort
  the list.

******************************************************************************/

void CFontWidthsPage::OnColumnclickCharacterWidths(NMHDR* pnmh, LRESULT* plr) {
	NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;

    if  (m_iSortColumn == pnmlv -> iSubItem)
        m_bSortDescending ^= 1 << m_iSortColumn;    //  Flip sort direction
    else
        m_iSortColumn = pnmlv -> iSubItem;

    m_clcView.SortItems(Sort, (LPARAM) this);    //  Sort the list!
	
	*plr = 0;
}

/******************************************************************************

  CFontWidthsPage::OnKeydownCharacterWidths

  I'd hoped to do thiw when ENTER was pressed, but finding out which class is
  eating the keystroke took too long.  Here, we look for F2 as the key to
  signal the need to edit the width of interest.

  Pretty straightforward- find out who has the focus and is selected, and edit
  their label.

******************************************************************************/

void    CFontWidthsPage::OnKeydownCharacterWidths(NMHDR* pnmh, LRESULT* plr) {
	LV_KEYDOWN * plvkd = (LV_KEYDOWN *) pnmh;

	*plr = 0;

    if  (plvkd -> wVKey != VK_F2)
        return;

    int idItem = m_clcView.GetNextItem(-1, LVIS_FOCUSED | LVIS_SELECTED);

    if  (idItem == -1)
        return;

    CEdit   *pce = m_clcView.EditLabel(idItem);

    if  (pce)
        pce -> ModifyStyle(0, ES_NUMBER);
}


/******************************************************************************

  CFontWidthsPage::ValidateUFMFields

  Validate all specified fields managed by this page.  Return true if the user
  wants to leave the UFM Editor open so that he can fix any problem.  Otherwise,
  return true.

******************************************************************************/

bool CFontWidthsPage::ValidateUFMFields()
{
	// If the page was never initialize, its contents could not have changed
	// so no validation is needed in this case.

	if (!m_bInitDone)
		return false ;

	// Only verify widths if this is a variable pitch font.

	if (!m_pcfi->IsVariableWidth())
		return false ;

	// If there are no widths, there is nothing to validate.

	int numitems = m_clcView.GetItemCount() ;
	if (numitems == 0)
		return false ;

	// Loop through each width

	LV_ITEM lvi ;
	lvi.mask = LVIF_TEXT ;
	lvi.iSubItem = 0 ;
	char acitemtext[16] ;
	lvi.pszText = acitemtext ;
	lvi.cchTextMax = 15 ;
	CString csmsg ;
	for (int n = 0 ; n < numitems ; n++) {
		// Get info about the item

		lvi.iItem = n ;
		m_clcView.GetItem(&lvi) ;

		// Make sure each width is > 0.

		if (atoi(lvi.pszText) <= 0) {
			csmsg.Format(IDS_BadWidth, n) ;
			if (AfxMessageBox(csmsg, MB_YESNO+MB_ICONEXCLAMATION) == IDYES) {
				m_clcView.SetItemState(n, LVIS_SELECTED | LVIS_FOCUSED,
									   LVIS_SELECTED | LVIS_FOCUSED) ;
				m_clcView.EnsureVisible(n, false) ;
				m_clcView.SetFocus() ;
				return true ;
			} ;
		} ;
	} ;

	// All tests passed or the user doesn't want to fix them so...

	return false ;
}


/******************************************************************************

  CFontWidthsPage::SavePageData

  Save the data in the widths page back into the CFontInfo class instance that
  was used to load this page.  See CFontInfoContainer::OnSaveDocument() for
  more info.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/

bool CFontWidthsPage::SavePageData()
{
	// If the page was not initialized, nothing code have changed so do nothing.

	if (!m_bInitDone)
		return false ;

	// If there are no widths, there is nothing to save.

	int numitems = m_clcView.GetItemCount() ;

	if (numitems == 0)
		return false ;

	// Prepare to save the widths

	LV_ITEM lvi ;
	lvi.mask = LVIF_TEXT ;
	lvi.iSubItem = 0 ;
	char acitemtext[16] ;
	lvi.pszText = acitemtext ;
	lvi.cchTextMax = 15 ;
	numitems-- ;

	// Loop through each width
	
	for (int n = 0 ; n <= numitems ; n++) {
		// Get info about the item

		lvi.iItem = n ;
		m_clcView.GetItem(&lvi) ;

		// Save the current width.  When the last width is saved, make sure that
		// the new average width is calculated.

		m_pcfi->SetWidth(n, (WORD) atoi(lvi.pszText), (n == numitems)) ;
	} ;

	// All went well so...

	return false ;
}


/******************************************************************************

  CAddKernPair dialog class

  This class handles the dialog displayed when the user wishes to add a kern
  pair to the kern pair array.

  This class is used by the CFontKerningPage class

******************************************************************************/

class CAddKernPair : public CDialog {
    CSafeMapWordToOb    &m_csmw2oFirst, &m_csmw2oSecond;
    CWordArray          &m_cwaPoints;
    WORD                m_wFirst, m_wSecond;

// Construction
public:
	CAddKernPair(CSafeMapWordToOb& cmsw2o1, CSafeMapWordToOb& cmsw2o2,
        CWordArray& cwaPoints, CWnd* pParent);

    WORD    First() const { return m_wFirst; }
    WORD    Second() const { return m_wSecond; }

// Dialog Data
	//{{AFX_DATA(CAddKernPair)
	enum { IDD = IDD_AddKernPair };
	CButton	m_cbOK;
	CComboBox	m_ccbSecond;
	CComboBox	m_ccbFirst;
	short     	m_sAmount;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddKernPair)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddKernPair)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeKernFirst();
	afx_msg void OnSelchangeKernSecond();
	afx_msg void OnChangeKernAmount();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAddKernPair::CAddKernPair(CSafeMapWordToOb& csmw2o1,
                           CSafeMapWordToOb& csmw2o2, CWordArray& cwaPoints,
                           CWnd* pParent)
	: CDialog(CAddKernPair::IDD, pParent), m_csmw2oFirst(csmw2o1),
    m_csmw2oSecond(csmw2o2), m_cwaPoints(cwaPoints) {
	//{{AFX_DATA_INIT(CAddKernPair)
	m_sAmount = 0;
	//}}AFX_DATA_INIT
    m_wFirst = m_wSecond = 0;
}

void CAddKernPair::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddKernPair)
	DDX_Control(pDX, IDOK, m_cbOK);
	DDX_Control(pDX, IDC_KernSecond, m_ccbSecond);
	DDX_Control(pDX, IDC_KernFirst, m_ccbFirst);
	DDX_Text(pDX, IDC_KernAmount, m_sAmount);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAddKernPair, CDialog)
	//{{AFX_MSG_MAP(CAddKernPair)
	ON_CBN_SELCHANGE(IDC_KernFirst, OnSelchangeKernFirst)
	ON_CBN_SELCHANGE(IDC_KernSecond, OnSelchangeKernSecond)
	ON_EN_CHANGE(IDC_KernAmount, OnChangeKernAmount)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddKernPair message handlers

/******************************************************************************

  CAddKernPair::OnInitDialog

  This member function initializes the dialog box, by filling both combo boxes,
  and disabling the OK button.

******************************************************************************/

BOOL    CAddKernPair::OnInitDialog() {
    CDialog::OnInitDialog();    //  Initialize everything

    //  Fill in the first combo box

    CString csWork;
	int rm = (int)m_cwaPoints.GetSize();	// rm
    for (int i = 0; i < m_cwaPoints.GetSize(); i++) {
        csWork.Format("%4.4X", m_cwaPoints[i]);
        int id = m_ccbFirst.AddString(csWork);
        m_ccbFirst.SetItemData(id, m_cwaPoints[i]);
    }

    m_ccbFirst.SetCurSel(0);
    OnSelchangeKernFirst(); //  Fill the second box with this code.

    m_cbOK.EnableWindow(FALSE);

	return  TRUE;
}

/******************************************************************************

  CAddKernPair::OnSelchangeKernFirst

  This member is called whenever the selection changes in the first character
  combo box.  It screens out any already paired characters from the second
  character combo box, while preserving the currently selected character (if
  possible).

******************************************************************************/

void    CAddKernPair::OnSelchangeKernFirst() {
	int id = m_ccbFirst.GetCurSel();

    if  (id < 0)
        return;

    m_wFirst = (WORD) m_ccbFirst.GetItemData(id);

    //  See which character is selected in the second box, so we can keep it
    //  if it is still valid.

    id = m_ccbSecond.GetCurSel();

    m_wSecond = (id > -1) ? (WORD) m_ccbSecond.GetItemData(id) : 0;
    m_ccbSecond.ResetContent();
    CString csWork;

    for (id = 0; id < m_cwaPoints.GetSize(); id++) {

        union {
            CObject *pco;
            CMapWordToDWord *pcmw2dFirst;
        };

        DWORD   dwIgnore;

        if  (m_csmw2oFirst.Lookup(m_wFirst, pco) &&
            pcmw2dFirst -> Lookup(m_cwaPoints[id], dwIgnore)) {
            //  There is already a kern pair for this second point
            //  Don't include it in the list, and drop it if it is
            //  the currently selected second point.
            if  (m_wSecond == m_cwaPoints[id])
                m_wSecond = 0;
            continue;
        }

        csWork.Format("%4.4X", m_cwaPoints[id]);

        int id2 = m_ccbSecond.AddString(csWork);
        m_ccbSecond.SetItemData(id2, m_cwaPoints[id]);
        if  (m_wSecond == m_cwaPoints[id])
            m_ccbSecond.SetCurSel(id2);
    }

    if  (!m_wSecond) {
        m_ccbSecond.SetCurSel(0);
        m_wSecond = (WORD) m_ccbSecond.GetItemData(0);
    }
}

/******************************************************************************

  CAddKernPair::OnSelchangeKernSecond

  This member is called whenever the selection changes in the second character
  combo box.  It screens out any already paired characters from the first
  character combo box, while preserving the currently selected character (if
  possible).

******************************************************************************/

void    CAddKernPair::OnSelchangeKernSecond() {
	int id = m_ccbSecond.GetCurSel();

    if  (id < 0)
        return;

    m_wSecond = (WORD) m_ccbSecond.GetItemData(id);

    //  See which character is selected in the first box, so we can keep it
    //  if it is still valid.

    id = m_ccbFirst.GetCurSel();

    m_wFirst = (id > -1) ? (WORD) m_ccbFirst.GetItemData(id) : 0;
    m_ccbFirst.ResetContent();

    CString csWork;

    for (id = 0; id < m_cwaPoints.GetSize(); id++) {

        union {
            CObject *pco;
            CMapWordToDWord *pcmw2dSecond;
        };

        DWORD   dwIgnore;

        if  (m_csmw2oSecond.Lookup(m_wSecond, pco) &&
            pcmw2dSecond -> Lookup(m_cwaPoints[id], dwIgnore)) {
            //  There is already a kern pair for this first point
            //  Don't include it in the list, and drop it if it is
            //  the currently selected first point.
            if  (m_wFirst == m_cwaPoints[id])
                m_wFirst = 0;
            continue;
        }

        csWork.Format("%4.4X", m_cwaPoints[id]);

        int id2 = m_ccbFirst.AddString(csWork);
        m_ccbFirst.SetItemData(id2, m_cwaPoints[id]);
        if  (m_wFirst == m_cwaPoints[id])
            m_ccbFirst.SetCurSel(id2);
    }

    if  (!m_wFirst) {
        m_ccbFirst.SetCurSel(0);
        m_wFirst = (WORD) m_ccbFirst.GetItemData(0);
    }
}

/******************************************************************************

  CAddKernPair::OnChangeKernAmount

  This member gets called when a change is made to the amount edit box.  It
  enables the OK button if a non-zero amount seems to be there.  The DDX/DDV
  functions called from OnOK (by default) will handle any garbage that may
  have been entered, so this needn't be a complete screen.

******************************************************************************/

void    CAddKernPair::OnChangeKernAmount() {

    //  Don't use DDX/DDV, as it will complain if the user's just typed a
    //  minus sign. All we care about is the amount is non-zero, so we can
    //  enable/disable the OK button, as needed.
	// raid 27265
	INT iValue = (INT) GetDlgItemInt(IDC_KernAmount);
	if (iValue < -32767 || iValue > 32767 )
		iValue = 0;					// end raid
    m_cbOK.EnableWindow(!! iValue );// GetDlgItemInt(IDC_KernAmount));
}

/******************************************************************************

  CFontKerningPage class

  This class handles the font kerning page- the UI here consists of a list view
  showing the pairs- the view can be sorted several ways, and pairs can be
  added or deleted.

******************************************************************************/

/******************************************************************************

  CFontKerningPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis)

  This is a static private function used to interface the listview's sort
  callback requirements (to which this adheres) to the classes sort routine,
  which follows.

******************************************************************************/

int CALLBACK    CFontKerningPage::Sort(LPARAM lp1, LPARAM lp2, LPARAM lpThis) {
    CFontKerningPage    *pcfkp = (CFontKerningPage *) lpThis;

    return  pcfkp -> Sort((unsigned)lp1, (unsigned)lp2);
}

/******************************************************************************

  CFontKerningPage::Sort(unsigned u1, unsigned u2)

  This member returns -1, 0, 0r 1 to indiciate if the kern pair at index u1 is
  less than, equal to, or greater than the pair at u2, respectively.  The sort
  criteria are based on the internal control members.

******************************************************************************/

int CFontKerningPage::Sort(unsigned u1, unsigned u2) {
    for (unsigned u = 0; u < 3; u++) {
        switch  (m_uPrecedence[u]) {
        case    Amount:
            switch  (m_pcfi -> CompareKernAmount(u1, u2)) {
            case    CFontInfo::Less:
                return  (m_ufDescending & 1) ? 1 : -1;
            case    CFontInfo::More:
                return  (m_ufDescending & 1) ? -1 : 1;
            }
            continue;   //  If they are equal

        case    First:
            switch  (m_pcfi -> CompareKernFirst(u1, u2)) {
            case    CFontInfo::Less:
                return  (m_ufDescending & 2) ? 1 : -1;
            case    CFontInfo::More:
                return  (m_ufDescending & 2) ? -1 : 1;
            }
            continue;   //  If they are equal

        default:    //  Assume this is always second
            switch  (m_pcfi -> CompareKernSecond(u1, u2)) {
            case    CFontInfo::Less:
                return  (m_ufDescending & 4) ? 1 : -1;
            case    CFontInfo::More:
                return  (m_ufDescending & 4) ? -1 : 1;
            }
            continue;   //  If they are equal
        }
    }

	// Tell the user that there is something wrong with the kerning table
	// instead of asserting.

    //_ASSERT(FALSE);
	CString csmsg ;
	csmsg.Format(IDS_BadKernPairError, u1, m_pcfi->GetKernAmount(u1),
				 m_pcfi->GetKernFirst(u1), m_pcfi->GetKernSecond(u1)) ;
	AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;

    return  0;  //  This should never happen- two items should never be equal
}


/******************************************************************************

  CFontKerningPage Constructor, destructor, message map, and DDX/DDV.

  Except for some trivial construction, all of this is pretty standard MFC
  wizard-maintained stuff.

******************************************************************************/

CFontKerningPage::CFontKerningPage() : CToolTipPage(CFontKerningPage::IDD)
{
	//{{AFX_DATA_INIT(CFontKerningPage)
	//}}AFX_DATA_INIT

	m_bInitDone = false;
	m_uHelpID = HID_BASE_RESOURCE + IDR_FONT_VIEWER ;
    InitMemberVars() ;
}


/******************************************************************************

  CFontKerningPage::InitMemberVars

  Initialize the member variables that must be initialized both during
  construction and when the UFM is reloaded because of a GTT or CP change.

******************************************************************************/

void CFontKerningPage::InitMemberVars()
{
    m_idSelected = -1;
    m_ufDescending = 0;
    m_uPrecedence[0] = Second;  //  This is the default precedence in UFM
    m_uPrecedence[1] = First;
    m_uPrecedence[2] = Amount;
}


CFontKerningPage::~CFontKerningPage() {
}


void CFontKerningPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontKerningPage)
	DDX_Control(pDX, IDC_KerningTree, m_clcView);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontKerningPage, CToolTipPage)
	//{{AFX_MSG_MAP(CFontKerningPage)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(LVN_KEYDOWN, IDC_KerningTree, OnKeydownKerningTree)
	ON_NOTIFY(LVN_ENDLABELEDIT, IDC_KerningTree, OnEndlabeleditKerningTree)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_KerningTree, OnColumnclickKerningTree)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_AddItem, OnAddItem)
    ON_COMMAND(ID_DeleteItem, OnDeleteItem)
    ON_COMMAND(ID_ChangeAmount, OnChangeAmount)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontKerningPage message handlers

/******************************************************************************

  CFontKerningPage::OnSetActive

  Kerning only makes sense for variable pitch fonts, so if this font has
  changed, we will enable/disable, and change what we display accordingly.

******************************************************************************/

BOOL    CFontKerningPage::OnSetActive()
{
    if  (!CToolTipPage::OnSetActive())
        return  FALSE ;

	int rm1 = m_pcfi->IsVariableWidth() ;									// rm debugging only
	int rm2 = m_clcView.GetItemCount() ;									// rm debugging only

	// Reworked code to fix Raid Bug 163816...
	// Enable the list control based on whether or not this is a variable
	// pitched font.

    m_clcView.EnableWindow(m_pcfi->IsVariableWidth()) ;

	// First time in this routine.  Make sure the list is empty.  Then load
	// it with this font's kerning info if the font has variable pitch.

    m_clcView.DeleteAllItems();
    if  (m_pcfi->IsVariableWidth())	{
        m_pcfi -> FillKern(m_clcView) ;
        m_clcView.SortItems(Sort, (LPARAM) this) ;
	} ;

    return  TRUE ;

	/*	Rick's original code
    if  (m_pcfi->IsVariableWidth() == !!m_clcView.GetItemCount())			//  IsVariableWidth is either 0 or 1, so == is safe, here
        return  TRUE;														//  Everything is copacetic

    m_clcView.EnableWindow(m_pcfi -> IsVariableWidth());

    if  (m_clcView.GetItemCount())
        m_clcView.DeleteAllItems();
    else
		{
        m_pcfi -> FillKern(m_clcView);
        m_clcView.SortItems(Sort, (LPARAM) this);
		}

    return  TRUE;
	*/
}


/******************************************************************************

  CFontKerningPage::OnInitDialog

  This member handles initialization of the dialog.  In this case, we format
  and fill in the kerning tree, if there is one to fill in.  In addition, a
  copy is made of the kerning pairs table so that changes can be discarded
  when necessary.

******************************************************************************/

BOOL CFontKerningPage::OnInitDialog()
{
	CToolTipPage::OnInitDialog();

    CString csWork;

    csWork.LoadString(IDS_KernColumn0);

    m_clcView.InsertColumn(0, csWork, LVCFMT_CENTER,
        (3 * m_clcView.GetStringWidth(csWork)) >>
        1, 0);

    csWork.LoadString(IDS_KernColumn1);

    m_clcView.InsertColumn(1, csWork, LVCFMT_CENTER,
        m_clcView.GetStringWidth(csWork) << 1, 1);

    csWork.LoadString(IDS_KernColumn2);

    m_clcView.InsertColumn(2, csWork, LVCFMT_CENTER,
        m_clcView.GetStringWidth(csWork) << 1, 2);
	
    m_pcfi -> FillKern(m_clcView);
    m_pcfi -> MakeKernCopy();
	
	m_bInitDone = true ;
	return TRUE;
}


/******************************************************************************

  CFontKerningPage::OnContextMenu

  This member function is called whenever the user right-clicks the mouse
  anywhere within the dialog.  If it turns out not to have been within the list
  control, we ignore it.  Otherwise, we put up an appropriate context menu.

******************************************************************************/

void    CFontKerningPage::OnContextMenu(CWnd* pcwnd, CPoint cpt)
{

    if  (pcwnd -> m_hWnd != m_clcView.m_hWnd)						//  Clicked with in the list?
		{															//  Note, will also fail if list is disabled
        CToolTipPage::OnContextMenu(pcwnd, cpt);
        return;
		}

    CPoint  cptThis(cpt);   //  For hit test purposes, we will adjust this.
    m_clcView.ScreenToClient(&cptThis);

    cptThis.x = 5;  //  An arbitrary point sure to be within the label.

    m_idSelected = m_clcView.HitTest(cptThis);
    if  (m_idSelected == -1) {   //  Nothing selected, allow the "Add" item
        CMenu   cmThis;
        CString csWork;

        cmThis.CreatePopupMenu();
        csWork.LoadString(ID_AddItem);
        cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
        cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y,
            this);

        return;
    }

    //  We'll draw our own selection rectangle covering the entire item
    CRect   crItem;

    m_clcView.GetItemRect(m_idSelected, crItem, LVIR_BOUNDS);

    CDC *pcdc = m_clcView.GetDC();

    pcdc -> InvertRect(crItem);
    m_clcView.ReleaseDC(pcdc);

    CMenu   cmThis;
    CString csWork;

    cmThis.CreatePopupMenu();
    csWork.LoadString(ID_ChangeAmount);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_ChangeAmount, csWork);
    cmThis.AppendMenu(MF_SEPARATOR);
    csWork.LoadString(ID_AddItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
    csWork.LoadString(ID_DeleteItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_DeleteItem,
        csWork);
    cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y,
        this);

    //  Undo the selection rectangle

    pcdc = m_clcView.GetDC();

    pcdc -> InvertRect(crItem);
    m_clcView.ReleaseDC(pcdc);
}

/******************************************************************************

  CFontKerningPage::OnAddItem

  This member will be called whenever the user asks to add an additional
  kerning pair to the list.

******************************************************************************/

void    CFontKerningPage::OnAddItem() {
    CSafeMapWordToOb    csmw2oFirst, csmw2oSecond;
    CWordArray  cwaPoints;

    m_pcfi -> MapKerning(csmw2oFirst, csmw2oSecond, cwaPoints);
    CAddKernPair    cakp(csmw2oFirst, csmw2oSecond, cwaPoints, this);

    if  (cakp.DoModal() == IDOK) {
        m_pcfi -> AddKern(cakp.First(), cakp.Second(), cakp.m_sAmount,
            m_clcView);
    }
}

/******************************************************************************

  CFontKerningPage::OnDeleteItem

  This will be called if we try to delete an item from the context menu.

******************************************************************************/

void    CFontKerningPage::OnDeleteItem() {
    if  (m_idSelected < 0)
        return; //  Nothing to delete?

    m_pcfi -> RemoveKern((unsigned)m_clcView.GetItemData(m_idSelected));
    m_clcView.DeleteItem(m_idSelected);
    m_idSelected = -1;
}

/******************************************************************************

  CFontKerningPage::OnChangeAmount

  This is called when the user selects the menu item stating they wish to
  change the kerning amount.  It just needs to initiate a label edit.

******************************************************************************/

void    CFontKerningPage::OnChangeAmount() {
    if  (m_idSelected < 0)
        return;

    m_clcView.EditLabel(m_idSelected);
    m_idSelected = -1;
}

/******************************************************************************

  CFontKerningPage::OnKeydownKerningTree

  This is called most of the time when a key is pressed while the list control
  has the keyboard focus.  Unfortunately, the enter key is one of those we do
  not get to see.

  Currently, the F2, F10, and delete keys get special processing.  F2 opens
  an edit label on the current item, while F10 displays the context menu, and
  the delete key deletes it.

******************************************************************************/

void    CFontKerningPage::OnKeydownKerningTree(NMHDR* pnmh, LRESULT* plr) {
	LV_KEYDOWN  *plvkd = (LV_KEYDOWN *) pnmh;
	*plr = 0;

    m_idSelected = m_clcView.GetNextItem(-1, LVIS_FOCUSED | LVIS_SELECTED);
    if  (m_idSelected < 0) {
        if  (plvkd -> wVKey == VK_F10)  //  Do an add item, in this case.
            OnAddItem();
        return;
    }
	
    switch  (plvkd -> wVKey) {
    case    VK_F2:
        m_clcView.EditLabel(m_idSelected);
        break;

    case    VK_DELETE:
        OnDeleteItem();
        break;

    case    VK_F10:
        {
            CRect   crItem;

            m_clcView.GetItemRect(m_idSelected, crItem, LVIR_LABEL);
            m_clcView.ClientToScreen(crItem);
            OnContextMenu(&m_clcView, crItem.CenterPoint());
            break;
        }
    }
}

/******************************************************************************

  CFontKerningPage::OnEndLabelEdit

  This method gets called when the user finishes editing a kern amount, either
  by canceling it or pressing the enter key.

******************************************************************************/

void    CFontKerningPage::OnEndlabeleditKerningTree(NMHDR* pnmh, LRESULT* plr){
	LV_DISPINFO *plvdi = (LV_DISPINFO*) pnmh;	
	*plr = 0;   //  Assume failure

    if  (!plvdi -> item.pszText) //  Editing canceled?
        return;

    CString csNew(plvdi -> item.pszText);

    csNew.TrimRight();
    csNew.TrimLeft();

	// A negative kerning amount is OK so csTemp is not needed.  Use csNew in
	// the following if statement instead of csTemp.
	//
    //CString csTemp = (csNew[1] == _T('-')) ? csNew.Mid(1) : csNew;

    if (csNew.SpanIncluding("-1234567890").GetLength() != csNew.GetLength()) {
        AfxMessageBox(IDS_InvalidNumberFormat);
        return;
    }

    m_pcfi -> SetKernAmount((unsigned)plvdi -> item.lParam, (WORD) atoi(csNew));
    *plr = TRUE;
}

/******************************************************************************

  CFontKerningPage::OnColumnclikKerningTree

  This member gets called whn one of the sort headers is clicked.  If it is
  already the primary column, we revers the sort order fot that column.
  Otherwise, we retain the current order, and make this column the primary
  column, moving the other columns down in precedence.

******************************************************************************/

void    CFontKerningPage::OnColumnclickKerningTree(NMHDR* pnmh, LRESULT* plr) {
	NM_LISTVIEW *pnmlv = (NM_LISTVIEW*) pnmh;
	*plr = 0;

    if  (m_uPrecedence[0] == (unsigned) pnmlv -> iSubItem)
        m_ufDescending ^= (1 << pnmlv -> iSubItem);
    else {
        if  (m_uPrecedence[2] == (unsigned) pnmlv -> iSubItem)
            m_uPrecedence[2] = m_uPrecedence[1];
        m_uPrecedence[1] = m_uPrecedence[0];
        m_uPrecedence[0] = pnmlv -> iSubItem;
    }

    m_clcView.SortItems(Sort, (LPARAM) this);
}


/******************************************************************************

  CFontKerningPage::ValidateUFMFields

  Validate all specified fields managed by this page.  Return true if the user
  wants to leave the UFM Editor open so that he can fix any problem.  Otherwise,
  return true.

******************************************************************************/

bool CFontKerningPage::ValidateUFMFields()
{
	// All tests passed or the user doesn't want to fix them so...

	return false ;
}


/******************************************************************************

  CFontKerningPage::SavePageData

  Save the data in the kerning page back into the CFontInfo class instance that
  was used to load this page.  See CFontInfoContainer::OnSaveDocument() for
  more info.

  In this particular case, no work needs to be done.  Kerning pairs are kept in
  CFontInfo in a more complex collection of classes and arrays than any of the
  other data.  Because of this, a backup copy of the kerning data is made so
  that the editor can continue to update the main copy of the data.  If the
  user chooses not to save his changes, the backup is restored.  See
  CFontInfoContainer::SaveModified() for more information.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/

bool CFontKerningPage::SavePageData()
{
	// All went well so...

	return false ;
}


// Below are globals, definitions, and constants that are useful in
// CFontHeaderPage.  They are put here so that others who include fontview.h
// don't get copies of them.

LPTSTR apstrUniWTypes[] = {
	_T("DF_TYPE_HPINTELLIFONT"), _T("DF_TYPE_TRUETYPE"), _T("DF_TYPE_PST1"),
	_T("DF_TYPE_CAPSL"), _T("DF_TYPE_OEM1"), _T("DF_TYPE_OEM2"), _T("UNDEFINED")
} ;
const int nNumValidWTypes = 6 ;


const CString csHex = _T("0x%x") ;	// Format strings
const CString csDec = _T("%d") ;
const CString csPnt = _T("{%d, %d}") ;


#define HDR_GENFLAGS	0		// These definitions are used in the code and
#define HDR_TYPE		1		// data structures that refer to the 3 UFM
#define HDR_CAPS		2		// Header fields edited with sub dialog boxes.


static bool CALLBACK CHP_SubOrdDlgManager(CObject* pcoowner, int nrow, int ncol,
						 				  CString* pcscontents)
{
	CDialog* pdlg =NULL;				// Loaded with ptr to dialog box class to call

	// Use the row number to determine the dialog box to invoke.

	switch (nrow) {
		case HDR_GENFLAGS:
			pdlg = new CGenFlags(pcscontents) ;
			break ;
		case HDR_TYPE:
			pdlg = new CHdrTypes(pcscontents) ;
			break ;
		case HDR_CAPS:
			pdlg = new CHdrCaps(pcscontents) ;
			break ;
		default:
			ASSERT(0) ;
	} ;
//RAID 43540) Prefix

	if(pdlg==NULL){
		AfxMessageBox(IDS_ResourceError);
		return false;
	  
	};
// END RAID

	// Invoke the dialog box.  The dlg will update scontents.  Return true if
	// the dlg returns true.  Otherwise, return false.

	if (pdlg->DoModal() == IDOK)
		return true ;
	else
		return false ;
}


/////////////////////////////////////////////////////////////////////////////
// CFontHeaderPage property page

IMPLEMENT_DYNCREATE(CFontHeaderPage, CPropertyPage)

CFontHeaderPage::CFontHeaderPage() : CPropertyPage(CFontHeaderPage::IDD)
{
	//{{AFX_DATA_INIT(CFontHeaderPage)
	m_csDefaultCodePage = _T("");
	m_csRCID = _T("");
	//}}AFX_DATA_INIT

	m_bInitDone = false ;
}


CFontHeaderPage::~CFontHeaderPage()
{
}


void CFontHeaderPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontHeaderPage)
	DDX_Control(pDX, IDC_UniDrvLst, m_cfelcUniDrv);
	DDX_Text(pDX, IDC_DefaultCodepageBox, m_csDefaultCodePage);
	DDV_MaxChars(pDX, m_csDefaultCodePage, 6);
	DDX_Text(pDX, IDC_GlyphSetDataRCIDBox, m_csRCID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontHeaderPage, CPropertyPage)
	//{{AFX_MSG_MAP(CFontHeaderPage)
	ON_EN_CHANGE(IDC_DefaultCodepageBox, OnChangeDefaultCodepageBox)
	ON_EN_CHANGE(IDC_GlyphSetDataRCIDBox, OnChangeGlyphSetDataRCIDBox)
	ON_EN_KILLFOCUS(IDC_DefaultCodepageBox, OnKillfocusDefaultCodepageBox)
	ON_EN_KILLFOCUS(IDC_GlyphSetDataRCIDBox, OnKillfocusGlyphSetDataRCIDBox)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFontHeaderPage message handlers

/******************************************************************************

  CFontHeaderPage::OnInitDialog

  Initialize this page of the editor's property sheet.  This means loading UFM
  header/UNIDRV info from the FontInfo class into the controls and configuring
  the list control so that it will properly display and edit the data in it.
  The list control is also told that the first 3 fields in the UNIDRV
  structure are edited by subordinate dialog boxes.

******************************************************************************/

BOOL CFontHeaderPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog() ;

	// Load the code page and RC ID boxes with data from the FontInfo class

	m_csDefaultCodePage.Format(csDec, m_pcfi->m_ulDefaultCodepage) ;
	m_csRCID.Format(csDec, (int) (short) m_pcfi->m_lGlyphSetDataRCID) ; //raid 135627
//	m_sRCID = (short) m_pcfi->m_lGlyphSetDataRCID ;
	UpdateData(FALSE) ;

	// Initialize the list control.  We want full row select.  There are 9 rows
	// and 2 columns.  Nothing is togglable and the max length of an entry is
	// 256 characters.  Send change notifications and ignore insert/delete
	// characters.

	const int numfields = 9 ;
	m_cfelcUniDrv.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 256,
							 MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Init and load the field names column; col 0.  Start by loading an array
	// with the field names.

	CStringArray csacoldata	;	// Holds column data for list control
	csacoldata.SetSize(numfields) ;
	csacoldata[HDR_GENFLAGS] = _T("flGenFlags") ;
	csacoldata[HDR_TYPE] = _T("wType") ;
	csacoldata[HDR_CAPS] = _T("fCaps") ;
	csacoldata[3] = _T("wXRes") ;
	csacoldata[4] = _T("wYRes") ;
	csacoldata[5] = _T("sYAdjust") ;
	csacoldata[6] = _T("sYMoved") ;
	csacoldata[7] = _T("SelectFont") ;
	csacoldata[8] = _T("UnSelectFont") ;
	m_cfelcUniDrv.InitLoadColumn(0, csField, COMPUTECOLWIDTH, 10, false, false,
								COLDATTYPE_STRING, (CObArray*) &csacoldata) ;

	// Tell the list control that some of the values must be editted with
	// a subordinate dialog box; fields 0, 1, & 2.

	CUIntArray cuia ;
	cuia.SetSize(numfields) ;
	cuia[HDR_GENFLAGS] = cuia[HDR_TYPE] = cuia[HDR_CAPS] = 1 ;
	//cuia[3] = cuia[4] = cuia[5] = cuia[6] = cuia[7] = cuia[8] = 0 ;
	m_cfelcUniDrv.ExtraInit_CustEditCol(1, this,
									   CEF_HASTOGGLECOLUMNS+CEF_CLICKONROW,
									   cuia, CHP_SubOrdDlgManager) ;

	// Init and load the values column.  The data must be pulled out of the
	// FontInfo class and converted to strings so that they can be loaded
	// into the list control.

	int n ;
	csacoldata[0].Format(csHex, m_pcfi->m_UNIDRVINFO.flGenFlags) ;
	n = m_pcfi->m_UNIDRVINFO.wType ;
	csacoldata[1] = (n < nNumValidWTypes) ?
		apstrUniWTypes[n] : apstrUniWTypes[nNumValidWTypes] ;
	csacoldata[2].Format(csHex, m_pcfi->m_UNIDRVINFO.fCaps) ;
	csacoldata[3].Format(csDec, m_pcfi->m_UNIDRVINFO.wXRes) ;
	csacoldata[4].Format(csDec, m_pcfi->m_UNIDRVINFO.wYRes) ;
	csacoldata[5].Format(csDec, m_pcfi->m_UNIDRVINFO.sYAdjust) ;
	csacoldata[6].Format(csDec, m_pcfi->m_UNIDRVINFO.sYMoved) ;
    m_pcfi->Selector().GetInvocation(csacoldata[7]) ;
    m_pcfi->Selector(FALSE).GetInvocation(csacoldata[8]) ;
	m_cfelcUniDrv.InitLoadColumn(1, csValue, SETWIDTHTOREMAINDER, -11, true,
								false, COLDATTYPE_CUSTEDIT,
								(CObArray*) &csacoldata) ;

	m_bInitDone = true ;	// Initialization is done now
	return TRUE;			// return TRUE unless you set the focus to a control
							// EXCEPTION: OCX Property Pages should return FALSE
}


void CFontHeaderPage::OnChangeDefaultCodepageBox()
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return ;

	// Mark the UFM as being dirty.

	m_pcfi->Changed() ;
}


void CFontHeaderPage::OnChangeGlyphSetDataRCIDBox()
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return ;

	// Mark the UFM as being dirty.
	
	m_pcfi->Changed() ;

	// raid 0003 ; handle the load the width table when change the gttRCID
	
	CString csRCID =  m_csRCID ;
	UpdateData() ;
	if (csRCID != m_csRCID ) {
		m_pcfi->SetRCIDChanged(true) ;
		m_pcfi->SetTranslation((WORD)atoi(m_csRCID)) ;
	}
	
}


LRESULT CFontHeaderPage::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Mark the UFM as being dirty.

	m_pcfi->Changed() ;

	return TRUE ;
}


void CFontHeaderPage::OnKillfocusDefaultCodepageBox()
{
	// Don't worry about a new cp if there is a GTT ID.

	if (m_pcfi->m_lGlyphSetDataRCID != 0)
		return ;

	CheckHandleCPGTTChange(m_csDefaultCodePage, IDS_CPID) ;
}

// this method need to be changed ; just checke the RCID validity: is it 
// exist or not ? don't do anything.
void CFontHeaderPage::OnKillfocusGlyphSetDataRCIDBox()
{
	CString csRCID;
//	csRCID.Format("%d",m_csRCID);	// raid 135627 , raid 0003

	CheckHandleCPGTTChange(m_csRCID, IDS_GTTID) ;
}


/******************************************************************************

  CFontHeaderPage::CheckHandleCPGTTChange

  Determine if the fonts code page / GTT RC ID has changed.  If it has, ask
  the user if he wants to update the data based on the change.  If he does,
  call the UFM Editor's view class instance to manage UFM saving, reloading,
  and kerning/widths table checking.

******************************************************************************/

void CFontHeaderPage::CheckHandleCPGTTChange(CString& csfieldstr, UINT ustrid)
{
	// There is nothing to do if the UFM hasn't changed.

	if (!m_pcfic->IsModified())
		return ;

	// Do nothing if the UFM does not describe a variable width font.  (In this
	// case, there is no valid kerning or width data.)

	if (!m_pcfi->IsVariableWidth())
		return ;

	// Do nothing if the cp/gtt has not really changed.

	CString cs(csfieldstr) ;
	UpdateData() ;
	if (cs == csfieldstr)
		return ;

	// Tell the user that some or all of the data in the widths and kerning
	// tables may have been invalidated by the CP/GTT ID change.  Ask them if
	// they want the tables updated.

	CString csmsg ;
	cs.LoadString(ustrid) ;
	csmsg.Format(IDS_GTTCPChangedMsg, cs) ;
	if (AfxMessageBox(csmsg, MB_ICONINFORMATION+MB_YESNO) == IDNO)
		return ;

	// Call the view class to manage the table updating.

	m_pcfv->HandleCPGTTChange(ustrid == IDS_GTTID) ;
}
	

/******************************************************************************

  CFontHeaderPage::ValidateUFMFields

  Validate all specified fields managed by this page.  Return true if the user
  wants to leave the UFM Editor open so that he can fix any problem.  Otherwise,
  return true.

  DEAD_BUG
  The UFM Field Validation doc says that the codepage and GTT ID should be
  validated.  I have not done this for two reason.  First, these checks are
  made by the workspace consistency checking code.  Second, the information
  needed to validate these fields are not currently available to this class and
  it would take a lot of work to make the information available.

******************************************************************************/

bool CFontHeaderPage::ValidateUFMFields()
{
	// If the page was never initialize, its contents could not have changed
	// so no validation is needed in this case.

	if (!m_bInitDone)
		return false ;

	// Get the column of data that contains the fields we need to validate.

	CStringArray csadata ;
	m_cfelcUniDrv.GetColumnData((CObArray*) &csadata, 1) ;

	CString csmsg ;				// Holds error messages
	CString cspage(_T("UNIDRVINFO")) ;

	// wXRes must be > 0

	if (CheckUFMGrter0(csadata[3], cspage, _T("wXRes"), 3, m_cfelcUniDrv))
		return true ;

	// wYRes must be > 0

	if (CheckUFMGrter0(csadata[4], cspage, _T("wYRes"), 4, m_cfelcUniDrv))
		return true ;

	// SelectFont cannot be blank/empty.

	if (CheckUFMString(csadata[7], cspage, _T("SelectFont"), 7, m_cfelcUniDrv))
		return true ;

	// All tests passed or the user doesn't want to fix them so...

	return false ;
}


/******************************************************************************

  CFontHeaderPage::SavePageData

  Save the data in the header page back into the CFontInfo class instance that
  was used to load this page.  See CFontInfoContainer::OnSaveDocument() for
  more info.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/

bool CFontHeaderPage::SavePageData()
{
	// If the page was not initialized, nothing code have changed so do nothing.

	if (!m_bInitDone)
		return false ;

	// Save the default CP and GTT RCID.

	UpdateData() ;
	m_pcfi->m_ulDefaultCodepage = (ULONG) atol(m_csDefaultCodePage) ;
	m_pcfi->m_lGlyphSetDataRCID = (WORD) atoi(m_csRCID) ;	// raid 135627
//	m_pcfi->m_lGlyphSetDataRCID = (WORD) m_sRCID;

	// Get the rest of the data out of the list control.

	CStringArray csadata ;
	m_cfelcUniDrv.GetColumnData((CObArray*) &csadata, 1) ;

	// Save the UNIDRVINFO data.

	UNIDRVINFO* pudi = &m_pcfi->m_UNIDRVINFO ;
	LPTSTR pstr2 ;
	pudi->flGenFlags = strtoul(csadata[0].Mid(2), &pstr2, 16) ;

	CString cs = csadata[1] ;
	for (int n = 0 ; n < nNumValidWTypes ; n++) {
		if (apstrUniWTypes[n] == csadata[1])
			pudi->wType = (WORD) n ;
	} ;

	pudi->fCaps = (WORD) strtoul(csadata[2].Mid(2), &pstr2, 16) ;

	pudi->wXRes = (WORD) atoi(csadata[3]) ;
	pudi->wYRes = (WORD) atoi(csadata[4]) ;
	pudi->sYAdjust = (SHORT)  atoi(csadata[5]) ;
	pudi->sYMoved = (SHORT)  atoi(csadata[6]) ;
	
    m_pcfi->Selector().SetInvocation(csadata[7]) ;
    m_pcfi->Selector(FALSE).SetInvocation(csadata[8]) ;

	// All went well so...

	return false ;
}


/******************************************************************************

  CFontHeaderPage::PreTranslateMessage

  Looks for and process the context sensistive help key (F1).

******************************************************************************/

BOOL CFontHeaderPage::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1) {
		AfxGetApp()->WinHelp(HID_BASE_RESOURCE + IDR_FONT_VIEWER) ;
		return TRUE ;
	} ;
	
	return CPropertyPage::PreTranslateMessage(pMsg);
}


// Below are globals, definitions, and constants that are useful in
// CFontIFIMetricsPage.  They are put here so that others who include fontview.h
// don't get copies of them.

#define IFI_FAMILYNAME	0		// These definitions are used in the code and
#define IFI_FONTSIM		4		// data structures that refer to the 12 UFM
#define IFI_WINCHARSET	5		// IFIMetrics fields edited with subordinate
#define IFI_WINPITCHFAM	6		// dialog boxes.                            
#define IFI_INFO		8		
#define IFI_SELECTION	9
#define IFI_BASELINE	38
#define IFI_ASPECT		39
#define IFI_CARET		40
#define IFI_FONTBOX		41
#define IFI_PANOSE		44

// RAID       : add extra charset (from johab_charset), change symbo-charset as 2.
LPTSTR apstrWinCharSet[] = {
	_T("ANSI_CHARSET"),   _T("SYMBOL_CHARSET"),     _T("SHIFTJIS_CHARSET"),
	_T("HANGEUL_CHARSET"),_T("CHINESEBIG5_CHARSET"),_T("GB2312_CHARSET"),
	_T("OEM_CHARSET"), 	  _T("JOHAB_CHARSET"),      _T("HEBREW_CHARSET"),    
	_T("ARABIC_CHARSET"), 	_T("GREEK_CHARSET"),    _T("TURKISH_CHARSET"),
    _T("VIETNAMESE_CHARSET"),_T("THAI_CHARSET"), _T("EASTEUROPE_CHARSET"),
	_T("RUSSIAN_CHARSET"), 	_T("BALTIC_CHARSET"), _T("UNDEFINED")
} ;
int anWinCharSetVals[] = {0, 2, 128, 129, 136,134,255,130,177,178,161,
							162,163,222,238,204,186,1} ;
const int nWinCharSet = 18 ;


// The first array contains the base control IDs for each of the groups of edit
// controls that contain font simulation data.  The second array indicates the
// number of edit boxes in each group.

static unsigned auBaseFontSimCtrlID[] =
	{IDC_ItalicWeight, IDC_BoldWeight, IDC_BIWeight} ;
static unsigned auNumFontSimCtrls[] = {4, 3, 4} ;


/******************************************************************************

  ParseCompoundNumberString

  There are several IFIMetrics fields that are displayed as strings in the form
  "{x, y, ...z}".  This routine parses out the individual numbers (in string
  form) and saves them in a string array.

  Args:
	csaindvnums		The individual numeric strings
	pcscompnumstr	Pointer to the compound number string that is parsed
	ncount			The number of numbers to parse out of pcscompnumstr

******************************************************************************/

void ParseCompoundNumberString(CStringArray& csaindvnums,
							   CString* pcscompnumstr, int ncount)
{
	// Make sure the string array has the right number of entries in it.

	csaindvnums.SetSize(ncount) ;

	// Make a copy of pcscompnumstr that can be torn apart.  (Do no include
	// the first curly brace in the string.

	CString cs(pcscompnumstr->Mid(1)) ;

	// Get the first ncount - 1 number strings.

	int n, npos ;
	for (n = 0 ; n < ncount - 1 ; n++) {
		npos = cs.Find(_T(',')) ;
		csaindvnums[n] = cs.Left(npos) ;
		cs = cs.Mid(npos + 2) ;
	} ;

	// Save the last number in the compound string.

	csaindvnums[n] = cs.Left(cs.Find(_T('}'))) ;
}


static bool CALLBACK CIP_SubOrdDlgManager(CObject* pcoowner, int nrow, int ncol,
						 				  CString* pcscontents)
{
	CDialog* pdlg = NULL ;				// Loaded with ptr to dialog box class to call

	// Use the row number to determine the dialog box to invoke.

	switch (nrow) {
		case IFI_FAMILYNAME:
			pdlg = new CFIFIFamilyNames(pcscontents,
										(CFontIFIMetricsPage*) pcoowner) ;
			break ;
		case IFI_FONTSIM:	
			pdlg = new CFIFIFontSims(pcscontents,
									 (CFontIFIMetricsPage*) pcoowner) ;
			break ;
		case IFI_WINCHARSET:
			pdlg = new CFIFIWinCharSet(pcscontents) ;
			break ;
		case IFI_WINPITCHFAM:
			pdlg = new CFIFIWinPitchFamily(pcscontents) ;
			break ;
		case IFI_INFO:	
			pdlg = new CFIFIInfo(pcscontents) ;
			break ;
		case IFI_SELECTION:	
			pdlg = new CFIFISelection(pcscontents) ;
			break ;
		case IFI_BASELINE:
		case IFI_ASPECT:
		case IFI_CARET:
			pdlg = new CFIFIPoint(pcscontents) ;
			break ;
		case IFI_FONTBOX:
			pdlg = new CFIFIRectangle(pcscontents) ;
			break ;
		case IFI_PANOSE:
			pdlg = new CFIFIPanose(pcscontents) ;
			break ;
		default:
			ASSERT(0) ;
	} ;
// raid 43541 Prefix

	if(pdlg == NULL){
		AfxMessageBox(IDS_ResourceError);
		return false;
	}

	// Invoke the dialog box.  The dlg will update pscontents.  Return true if
	// the dlg returns IDOK.  Otherwise, return false.

	if (pdlg->DoModal() == IDOK)
		return true ;
	else
		return false ;
}


/////////////////////////////////////////////////////////////////////////////
// CFontIFIMetricsPage property page

IMPLEMENT_DYNCREATE(CFontIFIMetricsPage, CPropertyPage)

CFontIFIMetricsPage::CFontIFIMetricsPage() : CPropertyPage(CFontIFIMetricsPage::IDD)
{
	//{{AFX_DATA_INIT(CFontIFIMetricsPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = false ;

	// Initialize as no enabled font simulations

	m_cuiaFontSimStates.SetSize(3) ;
	m_cuiaSimTouched.SetSize(3) ;
	for (int n = 0 ; n < 3 ; n++)
		m_cuiaFontSimStates[n] = m_cuiaSimTouched[n] = 0 ;
}

CFontIFIMetricsPage::~CFontIFIMetricsPage()
{
}

void CFontIFIMetricsPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontIFIMetricsPage)
	DDX_Control(pDX, IDC_IFIMetricsLst, m_cfelcIFIMetrics);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontIFIMetricsPage, CPropertyPage)
	//{{AFX_MSG_MAP(CFontIFIMetricsPage)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFontIFIMetricsPage message handlers

BOOL CFontIFIMetricsPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();
	
	// Initialize the list control.  We want full row select.  There are 45 rows
	// and 2 columns.  Nothing is togglable and the max length of an entry is
	// 256 characters.  Send change notifications and ignore insert/delete
	// characters.

	const int numfields = 45 ;
	m_cfelcIFIMetrics.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 256,
								 MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Init and load the field names column; col 0.  Start by loading an array
	// with the field names.

	CStringArray csacoldata	;	// Holds column data for list control
	csacoldata.SetSize(numfields) ;
	IFILoadNamesData(csacoldata) ;
	m_cfelcIFIMetrics.InitLoadColumn(0, csField, COMPUTECOLWIDTH, 20, false,
									false, COLDATTYPE_STRING,
									(CObArray*) &csacoldata) ;

	// Tell the list control that some of the values must be editted with
	// a subordinate dialog box.

	CUIntArray cuia ;
	cuia.SetSize(numfields) ;
	cuia[IFI_FAMILYNAME] = cuia[IFI_FONTSIM] = 1 ;
	cuia[IFI_WINCHARSET] = cuia[IFI_WINPITCHFAM] = cuia[IFI_INFO] = 1 ;
	cuia[IFI_SELECTION] = cuia[IFI_BASELINE] = cuia[IFI_ASPECT] = 1 ;
	cuia[IFI_CARET] = cuia[IFI_FONTBOX] = cuia[IFI_PANOSE] = 1 ;
	m_cfelcIFIMetrics.ExtraInit_CustEditCol(1, this,
									       CEF_HASTOGGLECOLUMNS+CEF_CLICKONROW,
										   cuia, CIP_SubOrdDlgManager) ;

	// Init and load the values column.  The data must be pulled out of the
	// FontInfo class / IFIMETRICS structure and converted to strings so that
	// they can be loaded into the list control.

	IFILoadValuesData(csacoldata) ;
	m_cfelcIFIMetrics.InitLoadColumn(1, csValue, SETWIDTHTOREMAINDER, -37, true,
								    false, COLDATTYPE_CUSTEDIT,
								    (CObArray*) &csacoldata) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFontIFIMetricsPage::IFILoadNamesData(CStringArray& csacoldata)
{
	csacoldata[IFI_FAMILYNAME]  = _T("dpwszFamilyName") ;
	csacoldata[1]  = _T("dpwszStyleName") ;
	csacoldata[2]  = _T("dpwszFaceName") ;
	csacoldata[3]  = _T("dpwszUniqueName") ;
	csacoldata[IFI_FONTSIM]  = _T("dpFontSim") ;
	csacoldata[IFI_WINCHARSET]  = _T("jWinCharSet") ;
	csacoldata[IFI_WINPITCHFAM]  = _T("jWinPitchAndFamily") ;
	csacoldata[7]  = _T("usWinWeight") ;
	csacoldata[IFI_INFO]  = _T("flInfo") ;
	csacoldata[IFI_SELECTION] = _T("fsSelection") ;
	csacoldata[10] = _T("fwdUnitsPerEm") ;
	csacoldata[11] = _T("fwdLowestPPEm") ;					 
	csacoldata[12] = _T("fwdWinAscender") ;					 
	csacoldata[13] = _T("fwdWinDescender") ;					 
	csacoldata[14] = _T("fwdAveCharWidth") ;					 
	csacoldata[15] = _T("fwdMaxCharInc") ;					 
	csacoldata[16] = _T("fwdCapHeight") ;						 
	csacoldata[17] = _T("fwdXHeight") ;						 
	csacoldata[18] = _T("fwdSubscriptXSize") ;				 
	csacoldata[19] = _T("fwdSubscriptYSize") ;				 
	csacoldata[20] = _T("fwdSubscriptXOffset") ;				 
	csacoldata[21] = _T("fwdSubscriptYOffset") ;				 
	csacoldata[22] = _T("fwdSuperscriptXSize") ;				 
	csacoldata[23] = _T("fwdSuperscriptYSize") ;				 
	csacoldata[24] = _T("fwdSuperscriptXOffset") ;			 
	csacoldata[25] = _T("fwdSuperscriptYOffset") ;			 
	csacoldata[26] = _T("fwdUnderscoreSize") ;				 
	csacoldata[27] = _T("fwdUnderscorePosition") ;			 
	csacoldata[28] = _T("fwdStrikeoutSize") ;					 
	csacoldata[29] = _T("fwdStrikeoutPosition") ;				 
	csacoldata[30] = _T("chFirstChar") ;						 
	csacoldata[31] = _T("chLastChar") ;						 
	csacoldata[32] = _T("chDefaultChar") ;					 
	csacoldata[33] = _T("chBreakChar") ;						 
	csacoldata[34] = _T("wcFirstChar") ;						 
	csacoldata[35] = _T("wcLastChar") ;						 
	csacoldata[36] = _T("wcDefaultChar") ;					 
	csacoldata[37] = _T("wcBreakChar") ;						 
	csacoldata[IFI_BASELINE] = _T("ptlBaseline") ;
	csacoldata[IFI_ASPECT] = _T("ptlAspect") ;
	csacoldata[IFI_CARET] = _T("ptlCaret") ;
	csacoldata[IFI_FONTBOX] = _T("rclFontBox { L T R B }") ;
	csacoldata[42] = _T("achVendId") ;
	csacoldata[43] = _T("ulPanoseCulture") ;
	csacoldata[IFI_PANOSE] = _T("panose") ;
}


void CFontIFIMetricsPage::IFILoadValuesData(CStringArray& csacoldata)
{
	// Only the first family name is displayed on the IFI page
	//raid 104822
	if (m_pcfi->m_csaFamily.GetSize())
	csacoldata[IFI_FAMILYNAME] = m_pcfi->m_csaFamily.GetAt(0) ;	
	
	csacoldata[1] = m_pcfi->m_csStyle ;
	csacoldata[2] = m_pcfi->m_csFace ;
	csacoldata[3] = m_pcfi->m_csUnique ;
	
	// There is too much fontsim data to display on the IFI page so just
	// describe it.  A subordinate dialog box is used to display/edit the data.

	csacoldata[IFI_FONTSIM] = _T("Font Simulation Dialog") ;
	
	IFIMETRICS*	pifi = &m_pcfi->m_IFIMETRICS ;	// Minor optimization

	// Translate jWinCharSet into a descriptive string that can be displayed.

	csacoldata[IFI_WINCHARSET] = apstrWinCharSet[nWinCharSet - 1] ;
	for (int n = 0 ; n < (nWinCharSet - 1) ; n++)
		if (pifi->jWinCharSet == anWinCharSetVals[n]) {
			csacoldata[IFI_WINCHARSET] = apstrWinCharSet[n] ;
			break ;
		} ;

	// Before saving the WinPitch value, make sure that at least one of the FF
	// flags is set.  Use FF_DONTCARE (4) when none are set.

	n = pifi->jWinPitchAndFamily ;
//raid 32675 : kill 2 lines
//	if (n < 4)
//		n |= 4 ;
	csacoldata[IFI_WINPITCHFAM].Format(csHex, n) ;
	
	csacoldata[7].Format("%hu",  pifi->usWinWeight) ;
	csacoldata[IFI_INFO].Format(csHex, pifi->flInfo) ;
	csacoldata[IFI_SELECTION].Format(csHex, pifi->fsSelection) ;

	// Format and save fwdUnitsPerEm, fwdLowestPPEm, fwdWinAscender,
	// fwdWinDescender.

	short* ps = &pifi->fwdUnitsPerEm ;
	for (n = 0 ; n < 4 ; n++)											
		csacoldata[10+n].Format(csDec, *ps++) ;

	ps = &pifi->fwdAveCharWidth;									
	for (n = 0 ; n < 16 ; n++)
		csacoldata[14+n].Format(csDec, *ps++) ;

	BYTE* pb = (BYTE*) &pifi->chFirstChar ;
	for (n = 0 ; n < 4 ; n++)
		csacoldata[30+n].Format(csDec, *pb++) ;
	
	unsigned short* pus = (unsigned short*) &pifi->wcFirstChar ;
	for (n = 0 ; n < 4 ; n++)
		csacoldata[34+n].Format(csHex, *pus++) ;

	// Format and save the points

	csacoldata[IFI_BASELINE].Format(csPnt,
		pifi->ptlBaseline.x, pifi->ptlBaseline.y) ;
	csacoldata[IFI_ASPECT].Format(csPnt, pifi->ptlAspect.x, pifi->ptlAspect.y) ;
	csacoldata[IFI_CARET].Format(csPnt, pifi->ptlCaret.x, pifi->ptlCaret.y) ;
		
	csacoldata[IFI_FONTBOX].Format("{%d, %d, %d, %d}", pifi->rclFontBox.left,
		pifi->rclFontBox.top, pifi->rclFontBox.right, pifi->rclFontBox.bottom) ;
					
	csacoldata[42].Format("%c%c%c%c", pifi->achVendId[0], pifi->achVendId[1],
						  pifi->achVendId[2], pifi->achVendId[3]) ;

	csacoldata[43].Format("%lu", pifi->ulPanoseCulture) ;

	csacoldata[IFI_PANOSE].Format("{%d, %d, %d, %d, %d, %d, %d, %d, %d, %d}",
					  pifi->panose.bFamilyType, pifi->panose.bSerifStyle,
					  pifi->panose.bWeight,   pifi->panose.bProportion,
					  pifi->panose.bContrast, pifi->panose.bStrokeVariation,
					  pifi->panose.bArmStyle, pifi->panose.bLetterform,
					  pifi->panose.bMidline,  pifi->panose.bXHeight) ;
}


LRESULT CFontIFIMetricsPage::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Mark the UFM as being dirty.

	m_pcfi->Changed() ;

	return TRUE ;
}


CWordArray* CFontIFIMetricsPage::GetFontSimDataPtr(int nid)
{
	// Return a pointer to the requested font simulation data.

	switch (nid) {
		case CFontInfo::ItalicDiff:
			return &m_cwaBold ;
		case CFontInfo::BoldDiff:
			return &m_cwaItalic ;
		case CFontInfo::BothDiff:
			return &m_cwaBoth ;
		default:
			ASSERT(0) ;
	} ;

	// This point should never be reached.

	return &m_cwaBold ;
}


/******************************************************************************

  CFontIFIMetricsPage::ValidateUFMFields

  Validate all specified fields managed by this page.  Return true if the user
  wants to leave the UFM Editor open so that he can fix any problem.  Otherwise,
  return false.

******************************************************************************/

bool CFontIFIMetricsPage::ValidateUFMFields()
{
	// If the page was never initialize, its contents could not have changed
	// so no validation is needed in this case.

	if (!m_bInitDone)
		return false ;

	// Get the column of data that contains the fields we need to validate.

	CStringArray csadata ;
	m_cfelcIFIMetrics.GetColumnData((CObArray*) &csadata, 1) ;

	CString csmsg ;				// Holds error messages
	CString cspage(_T("IFIMETRICS")) ;

	LPTSTR apstrsflds[] = {		// These string fields are checked below
		_T("dpwszFamilyName"), _T("dpwszStyleName"), _T("dpwszFaceName"),
		_T("dpwszUniqueName")
	} ;

	// Check to see if any of the string entries are blank/empty.

	for (int n = 0 ; n < 4 ; n++) {
		if (CheckUFMString(csadata[n],cspage,apstrsflds[n],n,m_cfelcIFIMetrics))
			return true ;
	} ;

	// If this UFM describes a variable pitch font, make sure that
	// fwdUnitsPerEm > 0.

	if (m_pcfi->IsVariableWidth())
		if (CheckUFMGrter0(csadata[10], cspage, _T("fwdUnitsPerEm"), 10,
						   m_cfelcIFIMetrics))
			return true ;

	LPTSTR apstrgflds[] = {		// These fields are checked below
		_T("fwdWinAscender"), _T("fwdWinDescender"), _T("fwdAveCharWidth"),
		_T("fwdMaxCharInc"), _T("fwdUnderscoreSize"), _T("fwdStrikeoutSize")
	} ;
	int angfidxs[] = {12, 13, 14, 15, 26, 28} ;

	// All of the following fields must be > 0.

	LPTSTR pstr, pstr2 ;
	for (int n2 = 0 ; n2 < 6 ; n2++) {
		n = angfidxs[n2] ;
		pstr = apstrgflds[n2] ;
		if (CheckUFMGrter0(csadata[n], cspage, pstr, n, m_cfelcIFIMetrics))
			return true ;
	} ;

	// fwdUnderscorePosition must be < 0

	bool bres = atoi(csadata[27]) >= 0 ;
	if (CheckUFMBool(bres, cspage, _T("fwdUnderscorePosition"), 27,
					 m_cfelcIFIMetrics, IDS_GrterEqZeroError))
		return true ;

	// fwdStrikeoutPosition must be >= 0

	bres = atoi(csadata[29]) < 0 ;
	if (CheckUFMBool(bres, cspage, _T("fwdStrikeoutPosition"), 29,
					 m_cfelcIFIMetrics, IDS_LessZeroError))
		return true ;

	LPTSTR apstrnzflds[] = {	// These fields are checked below
		_T("chFirstChar"), _T("chLastChar"), _T("chDefaultChar"),
		_T("chBreakChar"), _T("wcFirstChar"), _T("wcLastChar"),
		_T("wcDefaultChar"), _T("wcBreakChar")
	} ;

	// All of the following fields must be != 0.

	int nfval ;
	for (n = 30, n2 = 0 ; n <= 37 ; n++, n2++) {
		pstr = csadata[n].GetBuffer(16) ;
		if (*(pstr+1) != _T('x'))
			nfval = atoi(pstr) ;
		else
			nfval = strtoul((pstr+2), &pstr2, 16) ;
		pstr = apstrnzflds[n2] ;
		if (CheckUFMNotEq0(nfval, cspage, pstr, n, m_cfelcIFIMetrics))
			return true ;
	} ;

	// All tests passed or the user doesn't want to fix them so...

	return false ;
}


/******************************************************************************

  CFontIFIMetricsPage::SavePageData

  Save the data in the IFIMETRICS page back into the CFontInfo class instance
  that was used to load this page.  See CFontInfoContainer::OnSaveDocument()
  for more info.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/

bool CFontIFIMetricsPage::SavePageData()
{
	// If the page was not initialized, nothing code have changed so do nothing.

	if (!m_bInitDone)
		return false ;

	// Save the family name(s) if there are new ones.

	int n, numents = (int)m_csaFamilyNames.GetSize() ;
	if (numents > 0) {
		m_pcfi->m_csaFamily.RemoveAll() ;
		for (n = 0 ; n < numents ; n++)
			m_pcfi->AddFamily(m_csaFamilyNames[n]) ;
	} ;

	// Get the contents of the values contents.  This isn't needed for all
	// fields but most of it will be needed.

	CStringArray csadata ;
	m_cfelcIFIMetrics.GetColumnData((CObArray*) &csadata, 1) ;

	m_pcfi->m_csStyle = csadata[1] ;
	m_pcfi->m_csFace = csadata[2] ;
	m_pcfi->m_csUnique = csadata[3] ;

	SaveFontSimulations() ;		// Do just that

	IFIMETRICS*	pifi = &m_pcfi->m_IFIMETRICS ;	// Minor optimization
	LPTSTR pstr ;

	// For the time being, dpCharSets should always be 0.

	pifi->dpCharSets = 0 ;

	// Set jWinCharSet.  Don't change it if the setting is unknown.

	for (n = 0 ; n < (nWinCharSet - 1) ; n++)
		if (csadata[IFI_WINCHARSET] == apstrWinCharSet[n]) {
			pifi->jWinCharSet = (BYTE)anWinCharSetVals[n] ;
			break ;
		} ;
	
	pifi->jWinPitchAndFamily = (UCHAR) strtoul(csadata[IFI_WINPITCHFAM].Mid(2), &pstr, 16) ;
	pifi->usWinWeight = (USHORT)atoi(csadata[7]) ;
	pifi->flInfo = strtoul(csadata[IFI_INFO].Mid(2), &pstr, 16) ;
	pifi->fsSelection = (USHORT) strtoul(csadata[IFI_SELECTION].Mid(2), &pstr, 16) ;

	short* ps = &pifi->fwdUnitsPerEm ;
	for (n = 0 ; n < 4 ; n++)											
		*ps++ = (SHORT)atoi(csadata[10+n]) ;

	ps = &pifi->fwdAveCharWidth;									
	for (n = 0 ; n < 16 ; n++)
		*ps++ = (SHORT)atoi(csadata[14+n]) ;

	BYTE* pb = (BYTE*) &pifi->chFirstChar ;
	for (n = 0 ; n < 4 ; n++)
		*pb++ = (BYTE)atoi(csadata[30+n]) ;
	
	unsigned short* pus = (unsigned short*) &pifi->wcFirstChar ;
	for (n = 0 ; n < 4 ; n++)
		*pus++ = (USHORT) strtoul(csadata[34+n].Mid(2), &pstr, 16) ;

	// Format and save the points

	CStringArray csa ;
	POINTL* ppl = &pifi->ptlBaseline ;
	for (n = 0 ; n < 3 ; n++, ppl++) {
		ParseCompoundNumberString(csa, &csadata[IFI_BASELINE+n], 2) ;
		ppl->x = atoi(csa[0]) ;
		ppl->y = atoi(csa[1]) ;
	} ;
		
	ParseCompoundNumberString(csa, &csadata[IFI_FONTBOX], 4) ;
	pifi->rclFontBox.left = atoi(csa[0]) ;
	pifi->rclFontBox.top = atoi(csa[1]) ;
	pifi->rclFontBox.right = atoi(csa[2]) ;
	pifi->rclFontBox.bottom = atoi(csa[3]) ;
					
	for (n = 0 ; n < 4 ; n++)
		pifi->achVendId[n] = csadata[42].GetAt(n) ;

	pifi->ulPanoseCulture = atoi(csadata[43]) ;

	ParseCompoundNumberString(csa, &csadata[IFI_PANOSE], 10) ;
	pb = (BYTE*) &pifi->panose ;
	for (n = 0 ; n < 10 ; n++)
		*pb++ = (BYTE)atoi(csa[n]) ;

	// All went well so...

	return false ;
}


void CFontIFIMetricsPage::SaveFontSimulations()
{
	unsigned udataidx, unumdata, u2 ;	// Each var defined below
	CWordArray* pcwasimdata ;
	CFontDifference* pcfdxx ;
	CFontDifference*& pcfd = pcfdxx ;

	// Loop through each simulation in the dialog box.

	for (unsigned u = IDC_EnableItalicSim ; u <= IDC_EnableBISim ; u++) {
		// Turn the control id into a data index that can be used to reference
		// font simulation data in this and other class instances.

		udataidx = u - IDC_EnableItalicSim ;
		ASSERT(udataidx <= CFontInfo::BothDiff) ;

		// If this simulation was not touched, it does not need to change.

		//u2 = m_cuiaSimTouched[udataidx] ;
		if (!m_cuiaSimTouched[udataidx])
			continue ;

		// Get a pointer to the current simulation in the CFontInfo class
		// instance.

		pcfd = NULL ;
		m_pcfi->EnableSim(udataidx, TRUE, pcfd) ;

		// If the simulation is enabled, make sure the CFontInfo class
		// instance's simulation is loaded with the most up to date data.
	
		if (m_cuiaFontSimStates[udataidx]) {
			unumdata = auNumFontSimCtrls[udataidx] ;
			pcwasimdata = GetFontSimDataPtr(udataidx) ;
			for (u2 = 0 ; u2 < unumdata ; u2++)
				pcfd->SetMetric(u2, (*pcwasimdata)[u2]) ;
		
		// If the simulation is disabled, make sure the CFontInfo class instance
		// gets rid of its pointer to this simulation and then free the memory
		// allocated for it.

		} else {
			m_pcfi->EnableSim(udataidx, FALSE, pcfd) ;
			delete pcfd ;
		} ;
	} ;
}


/////////////////////////////////////////////////////////////////////////////
// CFontExtMetricPage property page

IMPLEMENT_DYNCREATE(CFontExtMetricPage, CPropertyPage)

CFontExtMetricPage::CFontExtMetricPage() : CPropertyPage(CFontExtMetricPage::IDD)
{
	//{{AFX_DATA_INIT(CFontExtMetricPage)
	m_bSaveOnClose = FALSE;
	//}}AFX_DATA_INIT

	m_bInitDone = false ;
}

CFontExtMetricPage::~CFontExtMetricPage()
{
}

void CFontExtMetricPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontExtMetricPage)
	DDX_Control(pDX, IDC_ExtMetricsLst, m_cfelcExtMetrics);
	DDX_Check(pDX, IDC_SaveCloseChk, m_bSaveOnClose);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontExtMetricPage, CPropertyPage)
	//{{AFX_MSG_MAP(CFontExtMetricPage)
	ON_BN_CLICKED(IDC_SaveCloseChk, OnSaveCloseChk)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFontExtMetricPage message handlers

BOOL CFontExtMetricPage::OnInitDialog()
{
	CPropertyPage::OnInitDialog();
	
	// Initialize the list control.  We want full row select.  There are 24 rows
	// and 2 columns.  Nothing is togglable and the max length of an entry is
	// 256 characters.  Send change notifications and ignore insert/delete
	// characters.

	const int numfields = 24 ;
	m_cfelcExtMetrics.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 256,
								 MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Init and load the field names column; col 0.  Start by loading an array
	// with the field names.

	CStringArray csacoldata	;	// Holds column data for list control
	csacoldata.SetSize(numfields) ;
	EXTLoadNamesData(csacoldata) ;
	m_cfelcExtMetrics.InitLoadColumn(0, csField, COMPUTECOLWIDTH, 10, false,
									false, COLDATTYPE_STRING,
									(CObArray*) &csacoldata) ;

	// Init and load the values column.  The data must be pulled out of the
	// FontInfo class / EXTMETRICS structure so that they can be loaded into
	// the list control.
	//
	// The first (emSize) and last (emKernTracks) EXTMETRICS fields are not
	// displayed.  EmSize is not user editable and emKernTracks is not
	// supported under NT.

	CUIntArray cuiacoldata ;
	cuiacoldata.SetSize(numfields) ;
	PSHORT ps = &m_pcfi->m_EXTTEXTMETRIC.emPointSize ;
	for (int n = 0 ; n < numfields ; n++, ps++)
		cuiacoldata[n] = (unsigned) (int) *ps ;
	m_cfelcExtMetrics.InitLoadColumn(1, csValue, SETWIDTHTOREMAINDER, -28, true,
								    false, COLDATTYPE_INT,
								    (CObArray*) &cuiacoldata) ;

	// Determine if the ExtTextMetrics data is valid.  Use this info to set or
	// clear the "Save On Close" checkbox and also use it enable or disable the
	// data list box.

	m_bSaveOnClose = (m_pcfi->m_fEXTTEXTMETRIC != 0) ;
	UpdateData(false) ;
	m_cfelcExtMetrics.EnableWindow(m_bSaveOnClose) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFontExtMetricPage::EXTLoadNamesData(CStringArray& csacoldata)
{
	csacoldata[0]  = _T("emPointSize") ;
	csacoldata[1]  = _T("emOrientation") ;
	csacoldata[2]  = _T("emMasterHeight") ;
	csacoldata[3]  = _T("emMinScale") ;
	csacoldata[4]  = _T("emMaxScale") ;
	csacoldata[5]  = _T("emMasterUnits") ;
	csacoldata[6]  = _T("emCapHeight") ;
	csacoldata[7]  = _T("emXHeight") ;
	csacoldata[8]  = _T("emLowerCaseAscent") ;
	csacoldata[9]  = _T("emLowerCaseDescent") ;
	csacoldata[10] = _T("emSlant") ;
	csacoldata[11] = _T("emSuperScript") ;
	csacoldata[12] = _T("emSubScript") ;
	csacoldata[13] = _T("emSuperScriptSize") ;
	csacoldata[14] = _T("emSubScriptSize") ;
	csacoldata[15] = _T("emUnderlineOffset") ;
	csacoldata[16] = _T("emUnderlineWidth") ;
	csacoldata[17] = _T("emDoubleUpperUnderlineOffset") ;
	csacoldata[18] = _T("emDoubleLowerUnderlineOffset") ;
	csacoldata[19] = _T("emDoubleUpperUnderlineWidth") ;
	csacoldata[20] = _T("emDoubleLowerUnderlineWidth") ;
	csacoldata[21] = _T("emStrikeOutOffset") ;
	csacoldata[22] = _T("emStrikeOutWidth") ;
	csacoldata[23] = _T("emKernPairs") ;
}


void CFontExtMetricPage::OnSaveCloseChk()
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return ;

	// Get the new state of the check box and use it to enable/disable the data
	// list control.

	UpdateData() ;
	m_cfelcExtMetrics.EnableWindow(m_bSaveOnClose) ;
	
	// Mark the UFM as being dirty.

	m_pcfi->Changed() ;
}


LRESULT CFontExtMetricPage::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Mark the UFM as being dirty.

	m_pcfi->Changed() ;

	return TRUE ;
}


/******************************************************************************

  CFontExtMetricPage::ValidateUFMFields

  Validate all specified fields managed by this page.  Return true if the user
  wants to leave the UFM Editor open so that he can fix any problem.  Otherwise,
  return true.

******************************************************************************/

bool CFontExtMetricPage::ValidateUFMFields()
{
	// If the page was never initialize, its contents could not have changed
	// so no validation is needed in this case.

	if (!m_bInitDone)
		return false ;

	// There is nothing that needs to be checked if the data on this page will
	// not be saved.

	UpdateData() ;
	if (!m_bSaveOnClose)
		return false ;

	// Get the column of data that contains the fields we need to validate.

	CUIntArray cuiadata ;
	m_cfelcExtMetrics.GetColumnData((CObArray*) &cuiadata, 1) ;

	CString csmsg ;				// Holds error messages
	CString cspage(_T("EXTMETRICS")) ;

	// There are three fields that should only be validated if this is a
	// variable pitch font.

	if (m_pcfi->IsVariableWidth()) {
		LPTSTR apstrsnzflds[] = {
			_T("emMinScale"), _T("emMaxScale"), _T("emMasterUnits")
		} ;

		// Make sure that emMinScale != emMaxScale.

		bool bres = ((int) cuiadata[3]) == ((int) cuiadata[4]) ;
		CString cs = cspage + _T(" ") ;
		cs += apstrsnzflds[0] ;
		if (CheckUFMBool(bres, cs, apstrsnzflds[1], 3, m_cfelcExtMetrics,
						 IDS_EqFieldsError))
			return true ;

		// Now make sure that the apstrsnzflds fields are nonzero.

		int n, n2 ;
		for (n = 3, n2 = 0 ; n <= 5 ; n++, n2++) {
			if (CheckUFMNotEq0(cuiadata[n], cspage, apstrsnzflds[n2], n,
							   m_cfelcExtMetrics))
				return true ;
		} ;
	} ;

	// emUnderLineOffset must be < 0

	bool bres = ((int) cuiadata[15]) >= 0 ;
	if (CheckUFMBool(bres, cspage, _T("emUnderLineOffset"), 15,
					 m_cfelcExtMetrics, IDS_GrterEqZeroError))
		return true ;

	// emUnderLineOffset must be nonzero

	int ndata = (int) cuiadata[16] ;
	if (CheckUFMNotEq0(ndata, cspage, _T("emUnderlineWidth"), 16,
					   m_cfelcExtMetrics))
		return true ;

	// emStrikeOutOffset must be > 0

	CString cs ;
	cs.Format("%d", (int) cuiadata[21]) ;
	if (CheckUFMGrter0(cs, cspage, _T("emStrikeOutOffset"), 21,
					   m_cfelcExtMetrics))
		return true ;

	// emStrikeOutWidth must be > 0

	cs.Format("%d", (int) cuiadata[22]) ;
	if (CheckUFMGrter0(cs, cspage, _T("emStrikeOutWidth"), 22,
					   m_cfelcExtMetrics))
		return true ;

	// All tests passed or the user doesn't want to fix them so...

	return false ;
}


/******************************************************************************

  CFontExtMetricPage::SavePageData

  Save the data in the EXTMETRICS page back into the CFontInfo class instance
  that was used to load this page.  See CFontInfoContainer::OnSaveDocument()
  for more info.

  Return true if there was a problem saving the data.  Otherwise, return false.

******************************************************************************/

bool CFontExtMetricPage::SavePageData()
{
	// If the page was not initialized, nothing code have changed so do nothing.

	if (!m_bInitDone)
		return false ;

	// Get the data out of the control and save it into the 24, editable
	// EXTMETRICS fields.

	CUIntArray cuiadata ;
	m_cfelcExtMetrics.GetColumnData((CObArray*) &cuiadata, 1) ;
	PSHORT ps = &m_pcfi->m_EXTTEXTMETRIC.emPointSize ;
	for (int n = 0 ; n < 24 ; n++, ps++)
		*ps = (short) cuiadata[n] ;

	// All went well so...

	return false ;
}


/******************************************************************************

  CFontExtMetricPage::PreTranslateMessage

  Looks for and process the context sensistive help key (F1).

******************************************************************************/

BOOL CFontExtMetricPage::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1) {
		AfxGetApp()->WinHelp(HID_BASE_RESOURCE + IDR_FONT_VIEWER) ;
		return TRUE ;
	} ;
	
	return CPropertyPage::PreTranslateMessage(pMsg);
}


/////////////////////////////////////////////////////////////////////////////
// CGenFlags dialog


CGenFlags::CGenFlags(CWnd* pParent /*=NULL*/)
	: CDialog(CGenFlags::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CGenFlags::CGenFlags(CString* pcsflags, CWnd* pParent /*= NULL*/)
	: CDialog(CGenFlags::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGenFlags)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CGenFlags::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGenFlags)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGenFlags, CDialog)
	//{{AFX_MSG_MAP(CGenFlags)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGenFlags message handlers

BOOL CGenFlags::OnInitDialog()
{
	CDialog::OnInitDialog() ;

	// Allocate and load the field names array

	CStringArray csafieldnames ;
	csafieldnames.SetSize(3) ;
	csafieldnames[0] = _T("UFM_SOFT") ;
	csafieldnames[1] = _T("UFM_CART") ;
	csafieldnames[2] = _T("UFM_SCALABLE") ;
	
	// Allocate and fill the flag groupings array.  There are 2 flag groups in
	// this flag dword.

	CUIntArray cuiaflaggroupings ;
	cuiaflaggroupings.SetSize(4) ;
	cuiaflaggroupings[0] = 0 ;
	cuiaflaggroupings[1] = 1 ;
	cuiaflaggroupings[2] = 2 ;
	cuiaflaggroupings[3] = 2 ;

	// Initialize and load the flags list.

	m_cflbFlags.Init2(csafieldnames, m_pcsFlags, cuiaflaggroupings, 2,
					  lptstrSet, 105, false) ;
	
	return TRUE ; // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CGenFlags::OnOK()
{
	// Update the flag string.

	m_cflbFlags.GetNewFlagString(m_pcsFlags) ;
	
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CHdrTypes dialog


CHdrTypes::CHdrTypes(CWnd* pParent /*=NULL*/)
	: CDialog(CHdrTypes::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CHdrTypes::CHdrTypes(CString* pcsflags, CWnd* pParent /*=NULL*/)
	: CDialog(CHdrTypes::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHdrTypes)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CHdrTypes::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHdrTypes)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHdrTypes, CDialog)
	//{{AFX_MSG_MAP(CHdrTypes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CHdrTypes message handlers

BOOL CHdrTypes::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Allocate and load the field names array.  While doing this, determine the
	// current (single) flag setting.

	CStringArray csafieldnames ;
	csafieldnames.SetSize(nNumValidWTypes) ;
	DWORD dwsettings, dwbit = 1 ;
	for (int n = 0 ; n < nNumValidWTypes ; n++, dwbit <<= 1) {
		csafieldnames[n] = apstrUniWTypes[n] ;
		if (csafieldnames[n] == *m_pcsFlags)
			dwsettings = dwbit ;
	} ;

	// Allocate and fill the flag groupings array.  There is only one flag
	// group.

	CUIntArray cuiaflaggroupings ;
	cuiaflaggroupings.SetSize(2) ;
	cuiaflaggroupings[0] = 0 ;
	cuiaflaggroupings[1] = nNumValidWTypes - 1 ;

	// Initialize the flags list.

	m_cflbFlags.Init(csafieldnames, dwsettings, cuiaflaggroupings, 1, lptstrSet,
					 110, true) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CHdrTypes::OnOK()
{
	// Get the value of the single flag that was selected.

	DWORD dwflag = m_cflbFlags.GetNewFlagDWord() ;
	
	// Use the selected flag to determine the new flag name to display.

	DWORD dwbit = 1 ;
	for (int n = 0 ; n < nNumValidWTypes ; n++, dwbit <<= 1) {
		if (dwbit == dwflag) {
			*m_pcsFlags = apstrUniWTypes[n] ;
			break ;
		} ;
	} ;

	// Blow if a matching flag was not found.  This should never happen.

	ASSERT(n < nNumValidWTypes) ;

	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CHdrCaps dialog


CHdrCaps::CHdrCaps(CWnd* pParent /*=NULL*/)
	: CDialog(CHdrCaps::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CHdrCaps::CHdrCaps(CString* pcsflags, CWnd* pParent /*=NULL*/)
	: CDialog(CHdrCaps::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHdrCaps)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CHdrCaps::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHdrCaps)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHdrCaps, CDialog)
	//{{AFX_MSG_MAP(CHdrCaps)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CHdrCaps message handlers

BOOL CHdrCaps::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Allocate and load the field names array

	CStringArray csafieldnames ;
	csafieldnames.SetSize(7) ;
	csafieldnames[0] = _T("DF_NOITALIC") ;
	csafieldnames[1] = _T("DF_NOUNDER") ;
	csafieldnames[2] = _T("DF_XM_CR") ;
	csafieldnames[3] = _T("DF_NO_BOLD") ;
	csafieldnames[4] = _T("DF_NO_DOUBLE_UNDERLINE") ;
	csafieldnames[5] = _T("DF_NO_STRIKETHRU") ;
	csafieldnames[6] = _T("DF_BKSP_OK") ;
	
	// Allocate flag groupings array.  Don't put anything in it because any
	// combination of flags can be set.

	CUIntArray cuiaflaggroupings ;

	// Initialize and load the flags list.

	m_cflbFlags.Init2(csafieldnames, m_pcsFlags, cuiaflaggroupings, 0,
					  lptstrSet, 123, false) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CHdrCaps::OnOK()
{
	// Update the flag string.

	m_cflbFlags.GetNewFlagString(m_pcsFlags) ;
	
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIFamilyNames dialog

CFIFIFamilyNames::CFIFIFamilyNames(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIFamilyNames::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIFamilyNames::CFIFIFamilyNames(CString* pcsfirstname,
								   CFontIFIMetricsPage* pcfimp,
								   CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIFamilyNames::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIFamilyNames)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = m_bChanged = false ;
	m_pcsFirstName = pcsfirstname ;
	m_pcfimp = pcfimp ;
}


void CFIFIFamilyNames::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIFamilyNames)
	DDX_Control(pDX, IDC_NamesLst, m_cfelcFamilyNames);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIFamilyNames, CDialog)
	//{{AFX_MSG_MAP(CFIFIFamilyNames)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIFamilyNames message handlers

BOOL CFIFIFamilyNames::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Get the current list of family names.  If the names have been changed
	// before in this editting session, the names will be in this dialog's
	// parent page.  If not, the names are in the associated UFM.

	CStringArray	csadata, *pcsadata ;
	if (m_pcfimp->m_csaFamilyNames.GetSize())
		pcsadata = &m_pcfimp->m_csaFamilyNames ;
	else
		pcsadata = &m_pcfimp->m_pcfi->m_csaFamily ;
	int numfields = (int)pcsadata->GetSize() ;

	// Initialize the list control.  We want full row select.  Nothing is
	// togglable and the max length of an entry is 256 characters.

	m_cfelcFamilyNames.InitControl(LVS_EX_FULLROWSELECT, numfields, 1, 0, 256,
								  MF_SENDCHANGEMESSAGE) ;

	// Init and load the family names column.

	m_cfelcFamilyNames.InitLoadColumn(0, _T("Name"), SETWIDTHTOREMAINDER, 0,
									  true, true, COLDATTYPE_STRING,
									  (CObArray*) pcsadata) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIFamilyNames::OnOK()
{
	// If nothing changed, just shut down the dialog box.

	if (!m_bChanged)
		CDialog::OnOK() ;

	// Get the new names out of the list control and delete any empty entries.
	
	CStringArray csa ;
	m_cfelcFamilyNames.GetColumnData((CObArray*) &csa, 0) ;
	for (int n = (int)csa.GetSize() - 1 ; n >= 0 ; n--)
		if (csa[n].IsEmpty())
			csa.RemoveAt(n) ;

	// If there are no names left in the list, complain, and return without
	// closing the dialog.

	if (csa.GetSize() == 0) {
		AfxMessageBox(IDS_NoFamilyNamesError, MB_ICONEXCLAMATION) ;
		return ;
	} ;

	// Save the new array of family names into the IFI page's member variable.
	// (The new data is saved there instead of in the UFM because the user may
	// decide later that he doesn't want to save his UFM changes.)  Then update
	// the string containing the first family name so that it can be displayed
	// on the IFI page.

	m_pcfimp->m_csaFamilyNames.RemoveAll() ;
	m_pcfimp->m_csaFamilyNames.Copy(csa) ;
	*m_pcsFirstName = csa[0] ;

	// Mark the UFM dirty and wrap things up.

	m_pcfimp->m_pcfi->Changed() ;
	CDialog::OnOK();
}


LRESULT CFIFIFamilyNames::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the page is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Note that the family names list has changed.

	m_bChanged = true ;

	return TRUE ;
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIFontSims dialog


CFIFIFontSims::CFIFIFontSims(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIFontSims::IDD, pParent)
{
	ASSERT(0) ;
}


CFIFIFontSims::CFIFIFontSims(CString* pcsfontsimdata,
							 CFontIFIMetricsPage* pcfimp,
							 CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIFontSims::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIFontSims)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pcsFontSimData = pcsfontsimdata ;
	m_pcfimp = pcfimp ;
	m_bInitDone = m_bChanged = false ;

	// Initialze the "font sim groups have been loaded" flags array.

	int numgrps = CFontInfo::BothDiff - CFontInfo::ItalicDiff + 1 ;
	m_cuiaFontSimGrpLoaded.SetSize(numgrps) ;
	for (int n = 0 ; n < numgrps ; n++)
		m_cuiaFontSimGrpLoaded[n] = 0 ;
}


void CFIFIFontSims::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIFontSims)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIFontSims, CDialog)
	//{{AFX_MSG_MAP(CFIFIFontSims)
	//}}AFX_MSG_MAP
    ON_CONTROL_RANGE(BN_CLICKED, IDC_EnableItalicSim, IDC_EnableBISim, OnSetAnySimState)
    ON_CONTROL_RANGE(EN_CHANGE, IDC_ItalicWeight, IDC_BoldItalicSlant, OnChangeAnyNumber)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIFontSims message handlers

BOOL CFIFIFontSims::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Loop through each set of font simulation controls to enable/disable
	// them and load them from the appropriate source when necessary.

	for (int n = IDC_EnableItalicSim ; n <= IDC_EnableBISim ; n++) {
		InitSetCheckBox(n) ;
		OnSetAnySimState(n) ;	// DEAD_BUG - May not be necessary.
	}
	
	m_bInitDone = true ;		// Initialization done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIFontSims::OnOK()
{
	unsigned udataidx, ufirstdataid, unumdata, u2 ;	// Each var defined below
	CWordArray* pcwasimdata ;

	// If nothing changed, call OnCancel() to close just the dialog box so 
	// that the program doesn't think that any of the font simulations changed.
	// This will keep the programming from prompting the user to save the UFM
	// even though nothing has actually changed.

	if (!m_bChanged) {
		CDialog::OnCancel() ;
		return ;
	} ;

	// Loop through each simulation in the dialog box.

	for (unsigned u = IDC_EnableItalicSim ; u <= IDC_EnableBISim ; u++) {
		// Turn the control id into a data index that can be used to reference
		// font simulation data in this and other class instances.

		udataidx = u - IDC_EnableItalicSim ;
		ASSERT(udataidx <= CFontInfo::BothDiff) ;

		// Save the state of this simulation but don't save any of its data if
		// it is disabled.
	
		m_pcfimp->m_cuiaFontSimStates[udataidx] = IsDlgButtonChecked(u) ;
		if (m_pcfimp->m_cuiaFontSimStates[udataidx] == 0)
			continue ;

		// Get the ID of the first edit box in the simulation and the number of
		// pieces of data (ie, edit boxes) in this simulation.

		ufirstdataid = auBaseFontSimCtrlID[udataidx] ;
		unumdata = auNumFontSimCtrls[udataidx] ;

		// The data is saved in the class' parent so that the CFontInfo data is
		// not changed before the user has agreed that the new data should be
		// saved.  Get a pointer to the appropriate array and make sure it is
		// sized correctly.

		pcwasimdata = m_pcfimp->GetFontSimDataPtr(udataidx) ;
		pcwasimdata->SetSize(unumdata) ;

		// Get the data in this font simulation group.

		for (u2 = 0 ; u2 < unumdata ; u2++)
			(*pcwasimdata)[u2] = (USHORT)GetDlgItemInt(ufirstdataid + u2, NULL, false) ;
	} ;

	CDialog::OnOK() ;
}


/******************************************************************************

  CFIFIFontSims::OnSetAnySimState

  Called when any simulation is enabled or disabled.  Updates the UI
  appropriately.  Decode which simulation it is, and init any values we
  ought to.

******************************************************************************/

void CFIFIFontSims::OnSetAnySimState(unsigned ucontrolid)
{
	// Get the state of the check box.	

    unsigned ucheckboxstate = IsDlgButtonChecked(ucontrolid) ;

	// Turn the control id into a data index that can be used to reference font
	// simulation data in this and other class instances.

	unsigned udataidx = ucontrolid - IDC_EnableItalicSim ;
	ASSERT(udataidx <= CFontInfo::BothDiff) ;

	// Get the ID of the first edit box in the simulation whose state has
	// changed and the number of pieces of data (ie, edit boxes) in this
	// simulation.

	unsigned ufirstdataid = auBaseFontSimCtrlID[udataidx] ;
	unsigned unumdata = auNumFontSimCtrls[udataidx] ;

	// Set the state of the corresponding edit boxes to that of their check
	// box.

	for (unsigned u = 0 ; u < unumdata ; u++)
        GetDlgItem(ufirstdataid + u)->EnableWindow(ucheckboxstate) ;

	// If this dialog box has been initialized, set the changed flag and set the
	// touched flag for this simulation.

	if (m_bInitDone) {
		m_bChanged = true ;
		m_pcfimp->m_cuiaSimTouched[udataidx] = 1 ;
	} ;

	// Nothing else needs to be done in one of two cases.  First, if the
	// controls were just disabled.  Second, if the controls have already
	// been loaded.  Return if either is the case.

	if (ucheckboxstate == 0 || m_cuiaFontSimGrpLoaded[udataidx] != 0)
		return ;

	// Note that the font sim group is about to be loaded so that it won't
	// happen again.

	m_cuiaFontSimGrpLoaded[udataidx] = 1 ;

	// Determine where to get the data for this font sim group. The data in this
	// class' parent class (CFontIFIMetricsPage) always takes precedence if it
	// is there because it will be the most up to date.  It is possible that
	// there is no data to load.  In this case, load the sim group with default
	// data from the IFIMETRICS structure and then return.

	CWordArray* pcwasimdata = m_pcfimp->GetFontSimDataPtr(udataidx) ;
	if (pcwasimdata->GetSize() == 0) {
		if (m_pcfimp->m_pcfi->Diff(udataidx) == NULL) {
			IFIMETRICS*	pim = &m_pcfimp->m_pcfi->m_IFIMETRICS ;			
			SetDlgItemInt(ufirstdataid + 0, pim->usWinWeight) ;
			SetDlgItemInt(ufirstdataid + 1, pim->fwdMaxCharInc) ;
			SetDlgItemInt(ufirstdataid + 2, pim->fwdAveCharWidth) ;
			if (ucontrolid != IDC_EnableBoldSim)
				SetDlgItemInt(ufirstdataid + 3, 175) ;
			return ;
		} ;
		pcwasimdata = m_pcfimp->m_pcfi->GetFontSimDataPtr(udataidx) ;
	} ;

	// Load the controls that will display the font sim group's data with
	// the existing font sim data.
//RAID 43542) PREFIX 

	if(pcwasimdata == NULL ){
		AfxMessageBox(IDS_ResourceError);
		return ;
	}
// END RAID
	for (u = 0 ; u < unumdata ; u++)
        SetDlgItemInt(ufirstdataid + u, (*pcwasimdata)[u]) ;

	// We're done now so...

	return ;
}


void CFIFIFontSims::OnChangeAnyNumber(unsigned ucontrolid)
{
	// Do nothing if this dialog box has not been initialized.

	if (!m_bInitDone)
		return ;

	// Set the changed flag.

	m_bChanged = true ;

	// Determine which simulation was just changed and set its touched flag.

	int n = 0 ;
	if (ucontrolid >= auBaseFontSimCtrlID[1])
		n++ ;
	if (ucontrolid >= auBaseFontSimCtrlID[2])
		n++ ;
	m_pcfimp->m_cuiaSimTouched[n] = 1 ;
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIFontSims implementation

void CFIFIFontSims::InitSetCheckBox(int ncontrolid)
{		
	// Turn the control id into a data index that can be used to reference font
	// simulation data in this and other class instances.

	int ndataidx = ncontrolid - IDC_EnableItalicSim ;

	// Determine what data to use to set/clear this check box.  The data in this
	// class' parent class (CFontIFIMetricsPage) always takes precedence if it
	// is there because it will be the most up to date.

	int ncheckboxstate ;
	CWordArray* pcwasimdata = m_pcfimp->GetFontSimDataPtr(ndataidx) ;
	if (pcwasimdata->GetSize() > 0)
		ncheckboxstate = (int) m_pcfimp->m_cuiaFontSimStates[ndataidx] ;
	else
		ncheckboxstate = m_pcfimp->m_pcfi->Diff(ndataidx) != NULL ;

	// Now that the check box's state is known, set it.

    CheckDlgButton(ncontrolid, ncheckboxstate) ;
}


/******************************************************************************

  CFontIFIMetricsPage::PreTranslateMessage

  Looks for and process the context sensistive help key (F1).

******************************************************************************/

BOOL CFontIFIMetricsPage::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1) {
		AfxGetApp()->WinHelp(HID_BASE_RESOURCE + IDR_FONT_VIEWER) ;
		return TRUE ;
	} ;
	
	return CPropertyPage::PreTranslateMessage(pMsg);
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinCharSet dialog


CFIFIWinCharSet::CFIFIWinCharSet(CWnd* pParent /*=NULL*/)
	: CDialog(CHdrTypes::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIWinCharSet::CFIFIWinCharSet(CString* pcsflags, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIWinCharSet::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIWinCharSet)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CFIFIWinCharSet::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIWinCharSet)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIWinCharSet, CDialog)
	//{{AFX_MSG_MAP(CFIFIWinCharSet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinCharSet message handlers

BOOL CFIFIWinCharSet::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Don't display the unknown field name.  Compute a new count to make this
	// happen.

	int numfields = nWinCharSet - 1 ;

	// Allocate and load the field names array.  While doing this, determine the
	// current (single) flag setting.

	CStringArray csafieldnames ;
	csafieldnames.SetSize(numfields) ;
	DWORD dwsettings, dwbit = 1 ;
	bool bmatchfound = false ;
	for (int n = 0 ; n < numfields ; n++, dwbit <<= 1) {
		csafieldnames[n] = apstrWinCharSet[n] ;
		if (csafieldnames[n] == *m_pcsFlags) {
			dwsettings = dwbit ;
			bmatchfound = true ;
		} ;
	} ;

	// Assert if no matching setting was found.

	ASSERT(bmatchfound) ;	//delte the line : raid 104822

	// Allocate and fill the flag groupings array.  There is only one flag
	// group.

	CUIntArray cuiaflaggroupings ;
	cuiaflaggroupings.SetSize(2) ;
	cuiaflaggroupings[0] = 0 ;
	cuiaflaggroupings[1] = numfields - 1 ;

	// Initialize the flags list.

	m_cflbFlags.Init(csafieldnames, dwsettings, cuiaflaggroupings, 1, lptstrSet,
					 109, true) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIWinCharSet::OnOK()
{
	// Get the value of the single flag that was selected.

	DWORD dwflag = m_cflbFlags.GetNewFlagDWord() ;
	
	// Use the selected flag to determine the new flag name to display.

	DWORD dwbit = 1 ;
	for (int n = 0 ; n < nWinCharSet ; n++, dwbit <<= 1) {
		if (dwbit == dwflag) {
			*m_pcsFlags = apstrWinCharSet[n] ;
			break ;
		} ;
	} ;

	// Blow if a matching flag was not found.  This should never happen.

	ASSERT(n < nWinCharSet) ;

	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinPitchFamily dialog


CFIFIWinPitchFamily::CFIFIWinPitchFamily(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIWinPitchFamily::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIWinPitchFamily::CFIFIWinPitchFamily(CString* pcsflags,
										 CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIWinPitchFamily::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIWinPitchFamily)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CFIFIWinPitchFamily::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIWinPitchFamily)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIWinPitchFamily, CDialog)
	//{{AFX_MSG_MAP(CFIFIWinPitchFamily)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIWinPitchFamily message handlers

BOOL CFIFIWinPitchFamily::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Allocate and load the field names array

	CStringArray csafieldnames ;
	csafieldnames.SetSize(8) ;
	csafieldnames[0] = _T("FIXED_PITCH") ;
	csafieldnames[1] = _T("VARIABLE_PITCH") ;
	csafieldnames[2] = _T("FF_DONTCARE") ;
	csafieldnames[3] = _T("FF_ROMAN") ;
	csafieldnames[4] = _T("FF_SWISS") ;
	csafieldnames[5] = _T("FF_MODERN") ;
	csafieldnames[6] = _T("FF_SCRIPT") ;
	csafieldnames[7] = _T("FF_DECORATIVE") ;
	
	// Allocate flag groupings array.  Allocate space for and initialize the
	// two flag groups.

	CUIntArray cuiaflaggroupings ;
	cuiaflaggroupings.SetSize(4) ;
	cuiaflaggroupings[0] = 0 ;
	cuiaflaggroupings[1] = -1 ;
	cuiaflaggroupings[2] = 2 ;
	cuiaflaggroupings[3] = 7 ;

	// The FlagsListBox used to display and edit values is not exactly right
	// for this field because the high half of jWinPitchAndFamily contains a
	// value; NOT a single bit flag.  So, the value sent to m_cflbFlags.Init2()
	// must be converted into a flag that the function can display correctly.
	// (This is easier than writing a new class that understands value fields
	// instead of flag fields.)

	DWORD dwv1, dwv2 ;
	LPTSTR lptstr, lptstr2 ;
	lptstr = m_pcsFlags->GetBuffer(16) ;
	int n = m_pcsFlags->GetLength() ;
	*(lptstr + n) = 0 ;
	if (*(lptstr + 1) == 'x')
		lptstr += 2 ;
	dwv2 = strtoul(lptstr, &lptstr2, 16) ;
	dwv1 = dwv2 & 3 ;
	dwv2 -= dwv1 ;
	dwv2 >>= 4 ;
	dwv2++ ;
	//dwv2 += 2 ;
	dwv2 = (2 << dwv2) + dwv1 ;
		
	// Initialize and load the flags list.

	m_cflbFlags.Init(csafieldnames, dwv2, cuiaflaggroupings, 2,
					 lptstrSet, 108, true, 1) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIWinPitchFamily::OnOK()
{
	// The FlagsListBox used to display and edit values is not exactly right
	// for this field because the high half of jWinPitchAndFamily contains a
	// value; NOT a single bit flag.  So, the value returned by 
	// m_cflbFlags.GetNewFlagDWord() is not right for this field.  Isolate the
	// Family bit and turn it into the correct Family value.

	DWORD dwv, dwv1, dwv2 ;
	dwv = m_cflbFlags.GetNewFlagDWord() ;
	dwv1 = dwv & 3 ;
	dwv >>= 3 ;
	dwv2 = 0 ;
	if (dwv >= 1) {
		for (dwv2 = 1 ; dwv > 1 ; dwv2++)
			dwv >>= 1 ;
	} ;
	dwv = dwv1 + (dwv2 << 4) ;
	m_pcsFlags->Format("0x%02x", dwv) ;
	
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIInfo dialog


CFIFIInfo::CFIFIInfo(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIInfo::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIInfo::CFIFIInfo(CString* pcsflags, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIInfo::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIInfo)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CFIFIInfo::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIInfo)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIInfo, CDialog)
	//{{AFX_MSG_MAP(CFIFIInfo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIInfo message handlers

BOOL CFIFIInfo::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Allocate and load the field names array

	CStringArray csafieldnames ;
	InfoLoadNamesData(csafieldnames) ;
	
	// Allocate flag groupings array.  Don't put anything in it because any
	// combination of flags can be set.

	CUIntArray cuiaflaggroupings ;

	// Initialize and load the flags list.

	m_cflbFlags.Init2(csafieldnames, m_pcsFlags, cuiaflaggroupings, 0,
					  lptstrSet, 168, false) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIInfo::OnOK()
{
	// Update the flag string.

	m_cflbFlags.GetNewFlagString(m_pcsFlags) ;
	
	CDialog::OnOK();
}


void CFIFIInfo::InfoLoadNamesData(CStringArray& csafieldnames)
{
	csafieldnames.SetSize(32) ;
	csafieldnames[0]  = _T("FM_INFO_TECH_TRUETYPE") ;
	csafieldnames[1]  = _T("FM_INFO_TECH_BITMAP") ;
	csafieldnames[2]  = _T("FM_INFO_TECH_STROKE") ;
	csafieldnames[3]  = _T("FM_INFO_TECH_OUTLINE_NOT_TRUETYPE") ;
	csafieldnames[4]  = _T("FM_INFO_ARB_XFORMS") ;
	csafieldnames[5]  = _T("FM_INFO_1BPP") ;
	csafieldnames[6]  = _T("FM_INFO_4BPP") ;
	csafieldnames[7]  = _T("FM_INFO_8BPP") ;
	csafieldnames[8]  = _T("FM_INFO_16BPP") ;
	csafieldnames[9]  = _T("FM_INFO_24BPP") ;
	csafieldnames[10] = _T("FM_INFO_32BPP") ;
	csafieldnames[11] = _T("FM_INFO_INTEGER_WIDTH") ;
	csafieldnames[12] = _T("FM_INFO_CONSTANT_WIDTH") ;
	csafieldnames[13] = _T("FM_INFO_NOT_CONTIGUOUS") ;
	csafieldnames[14] = _T("FM_INFO_TECH_MM") ;
	csafieldnames[15] = _T("FM_INFO_RETURNS_OUTLINES") ;
	csafieldnames[16] = _T("FM_INFO_RETURNS_STROKES") ;
	csafieldnames[17] = _T("FM_INFO_RETURNS_BITMAPS") ;
	csafieldnames[18] = _T("FM_INFO_DSIG") ;
	csafieldnames[19] = _T("FM_INFO_RIGHT_HANDED") ;
	csafieldnames[20] = _T("FM_INFO_INTEGRAL_SCALING") ;
	csafieldnames[21] = _T("FM_INFO_90DEGREE_ROTATIONS") ;
	csafieldnames[22] = _T("FM_INFO_OPTICALLY_FIXED_PITCH") ;
	csafieldnames[23] = _T("FM_INFO_DO_NOT_ENUMERATE") ;
	csafieldnames[24] = _T("FM_INFO_ISOTROPIC_SCALING_ONLY") ;
	csafieldnames[25] = _T("FM_INFO_ANISOTROPIC_SCALING_ONLY") ;
	csafieldnames[26] = _T("FM_INFO_MM_INSTANCE") ;
	csafieldnames[27] = _T("FM_INFO_FAMILY_EQUIV") ;
	csafieldnames[28] = _T("FM_INFO_DBCS_FIXED_PITCH") ;
	csafieldnames[29] = _T("FM_INFO_NONNEGATIVE_AC") ;
	csafieldnames[30] = _T("FM_INFO_IGNORE_TC_RA_ABLE") ;
	csafieldnames[31] = _T("FM_INFO_TECH_TYPE1") ;
}


/////////////////////////////////////////////////////////////////////////////
// CFIFISelection dialog


CFIFISelection::CFIFISelection(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFISelection::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFISelection::CFIFISelection(CString* pcsflags, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFISelection::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFISelection)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Save the flags string pointer

	m_pcsFlags = pcsflags ;
}


void CFIFISelection::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFISelection)
	DDX_Control(pDX, IDC_FlagsLst, m_cflbFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFISelection, CDialog)
	//{{AFX_MSG_MAP(CFIFISelection)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFISelection message handlers

BOOL CFIFISelection::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Allocate and load the field names array

	CStringArray csafieldnames ;
	csafieldnames.SetSize(7) ;
	csafieldnames[0] = _T("FM_SEL_ITALIC") ;
	csafieldnames[1] = _T("FM_SEL_UNDERSCORE") ;
	csafieldnames[2] = _T("FM_SEL_NEGATIVE") ;
	csafieldnames[3] = _T("FM_SEL_OUTLINED") ;
	csafieldnames[4] = _T("FM_SEL_STRIKEOUT") ;
	csafieldnames[5] = _T("FM_SEL_BOLD") ;
	csafieldnames[6] = _T("FM_SEL_REGULAR") ;
	
	// Allocate flag groupings array.  Put info on one group in it; the last two
	// flags.  The first five can be ignored in the groupings array because any
	// combination of them can be set.

	CUIntArray cuiaflaggroupings ;
	cuiaflaggroupings.SetSize(2) ;
	cuiaflaggroupings[0] = -5 ;
	cuiaflaggroupings[1] = -6 ;

	// Initialize and load the flags list.

	m_cflbFlags.Init2(csafieldnames, m_pcsFlags, cuiaflaggroupings, 1,
					  lptstrSet, 109, false) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFISelection::OnOK()
{
	// Update the flag string.

	m_cflbFlags.GetNewFlagString(m_pcsFlags) ;
	
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIPoint dialog


CFIFIPoint::CFIFIPoint(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIPoint::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIPoint::CFIFIPoint(CString* pcspoint, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIPoint::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIPoint)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = m_bChanged = false ;
	m_pcsPoint = pcspoint ;
}


void CFIFIPoint::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIPoint)
	DDX_Control(pDX, IDC_PointsLst, m_cfelcPointLst);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIPoint, CDialog)
	//{{AFX_MSG_MAP(CFIFIPoint)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIPoint message handlers

BOOL CFIFIPoint::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	const int numfields = 2 ;

	// Initialize the list control.  We want full row select.  Nothing is
	// togglable and the max length of an entry is 16 characters.  We also
	// want change notification and to suppress acting on INS/DEL keys.

	m_cfelcPointLst.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 16,
							   MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Load the point field names into an array and use them to initialize the
	// first column.

	CStringArray csadata ;
	csadata.SetSize(numfields) ;
	csadata[0] = _T("X") ;
	csadata[1] = _T("Y") ;
	m_cfelcPointLst.InitLoadColumn(0, _T("Point"), COMPUTECOLWIDTH, 20, false,
								  false, COLDATTYPE_STRING,
								  (CObArray*) &csadata) ;

	// Parse the X and Y values out of the string from the IFI page.

	ParseCompoundNumberString(csadata, m_pcsPoint, numfields) ;
	
	// Init and load the point values column.

	m_cfelcPointLst.InitLoadColumn(1, csValue, SETWIDTHTOREMAINDER, -20, true,
								  false, COLDATTYPE_STRING,
								  (CObArray*) &csadata) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIPoint::OnOK()
{
	// If nothing changed, just shut down the dialog box.

	if (!m_bChanged)
		CDialog::OnOK() ;

	// Get the new point values out of the list control.
	
	CStringArray csadata ;
	m_cfelcPointLst.GetColumnData((CObArray*) &csadata, 1) ;

	// If either value is blank, complain and return without closing the
	// dialog.

	if (csadata[0].GetLength() == 0 || csadata[1].GetLength() == 0) {
		AfxMessageBox(IDS_MissingFieldError, MB_ICONEXCLAMATION) ;
		return ;
	} ;

	// Format the new point values for display.

	m_pcsPoint->Format("{%s, %s}", csadata[0], csadata[1]) ;

	// Wrap things up.

	CDialog::OnOK();
}


LRESULT CFIFIPoint::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the dialog box is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Note that the a point value has changed.

	m_bChanged = true ;

	return TRUE ;
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIRectangle dialog


CFIFIRectangle::CFIFIRectangle(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIRectangle::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIRectangle::CFIFIRectangle(CString* pcsrect, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIRectangle::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIRectangle)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = m_bChanged = false ;
	m_pcsRect = pcsrect ;
}


void CFIFIRectangle::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIRectangle)
	DDX_Control(pDX, IDC_RectLst, m_cfelcSidesLst);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIRectangle, CDialog)
	//{{AFX_MSG_MAP(CFIFIRectangle)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_LISTCELLCHANGED, OnListCellChanged)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIRectangle message handlers

BOOL CFIFIRectangle::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	const int numfields = 4 ;

	// Initialize the list control.  We want full row select.  Nothing is
	// togglable and the max length of an entry is 16 characters.  We also
	// want change notification and to suppress acting on INS/DEL keys.

	m_cfelcSidesLst.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 16,
							   MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Load the point field names into an array and use them to initialize the
	// first column.

	CStringArray csadata ;
	csadata.SetSize(numfields) ;
	csadata[0] = _T("Left") ;
	csadata[1] = _T("Top") ;
	csadata[2] = _T("Right") ;
	csadata[3] = _T("Bottom") ;
	m_cfelcSidesLst.InitLoadColumn(0, _T("Side"), COMPUTECOLWIDTH, 20, false,
								  false, COLDATTYPE_STRING,
								  (CObArray*) &csadata) ;

	// Parse the side values out of the string from the IFI page.

	ParseCompoundNumberString(csadata, m_pcsRect, numfields) ;
	
	// Init and load the side values column.

	m_cfelcSidesLst.InitLoadColumn(1, csValue, SETWIDTHTOREMAINDER, -20, true,
								  false, COLDATTYPE_STRING,
								  (CObArray*) &csadata) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIRectangle::OnOK()
{
	// If nothing changed, just shut down the dialog box.

	if (!m_bChanged)
		CDialog::OnOK() ;

	// Get the new rectangle values out of the list control.
	
	CStringArray csadata ;
	m_cfelcSidesLst.GetColumnData((CObArray*) &csadata, 1) ;

	// If any value is blank, complain and return without closing the
	// dialog.

	int numentries = (int)csadata.GetSize() ;
	for (int n = 0 ; n < numentries ; n++) {
		if (csadata[n].GetLength() == 0) {
			AfxMessageBox(IDS_MissingFieldError, MB_ICONEXCLAMATION) ;
			return ;
		} ;
	} ;

	// Format the new point values for display.

	m_pcsRect->Format("{%s, %s, %s, %s}", csadata[0], csadata[1], csadata[2],
					  csadata[3]) ;

	// Wrap things up.

	CDialog::OnOK();
}


LRESULT CFIFIRectangle::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the dialog box is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Note that the a rectange value has changed.

	m_bChanged = true ;

	return TRUE ;
}


/////////////////////////////////////////////////////////////////////////////
// CFIFIPanose dialog


CFIFIPanose::CFIFIPanose(CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIPanose::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CFIFIPanose::CFIFIPanose(CString* pcspanose, CWnd* pParent /*=NULL*/)
	: CDialog(CFIFIPanose::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFIFIPanose)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitDone = m_bChanged = false ;
	m_pcsPanose = pcspanose ;
}


void CFIFIPanose::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFIFIPanose)
	DDX_Control(pDX, IDC_PanoseLst, m_cfelcPanoseLst);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFIFIPanose, CDialog)
	//{{AFX_MSG_MAP(CFIFIPanose)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFIFIPanose message handlers

BOOL CFIFIPanose::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	const int numfields = 10 ;

	// Initialize the list control.  We want full row select.  Nothing is
	// togglable and the max length of an entry is 3 characters.  We also
	// want change notification and to suppress acting on INS/DEL keys.

	m_cfelcPanoseLst.InitControl(LVS_EX_FULLROWSELECT, numfields, 2, 0, 3,
							    MF_SENDCHANGEMESSAGE+MF_IGNOREINSDEL) ;

	// Load the point field names into an array and use them to initialize the
	// first column.

	CStringArray csadata ;
	csadata.SetSize(numfields) ;
	csadata[0] = _T("bFamilyType") ;
	csadata[1] = _T("bSerifStyle") ;
	csadata[2] = _T("bWeight") ;
	csadata[3] = _T("bProportion") ;
	csadata[4] = _T("bContrast") ;
	csadata[5] = _T("bStrokeVariation") ;
	csadata[6] = _T("bArmStyle") ;
	csadata[7] = _T("bLetterform") ;
	csadata[8] = _T("bMidline") ;
	csadata[9] = _T("bXHeight") ;
	m_cfelcPanoseLst.InitLoadColumn(0, csField, COMPUTECOLWIDTH, 15, false,
								   false, COLDATTYPE_STRING,
								   (CObArray*) &csadata) ;

	// Parse the panose values out of the string from the IFI page.

	ParseCompoundNumberString(csadata, m_pcsPanose, numfields) ;
	
	// Init and load the side values column.

	m_cfelcPanoseLst.InitLoadColumn(1, _T("Value (0 - 255)"),
								   SETWIDTHTOREMAINDER, -16, true, false,
								   COLDATTYPE_STRING, (CObArray*) &csadata) ;

	m_bInitDone = true ;		// Initialization is done now
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CFIFIPanose::OnOK()
{
	// If nothing changed, just shut down the dialog box.

	if (!m_bChanged)
		CDialog::OnOK() ;

	// Get the new panose values out of the list control.
	
	CStringArray csadata ;
	m_cfelcPanoseLst.GetColumnData((CObArray*) &csadata, 1) ;

	// If any value is blank, complain and return without closing the
	// dialog.

	int numentries = (int)csadata.GetSize() ;
	for (int n = 0 ; n < numentries ; n++) {
		if (csadata[n].GetLength() == 0) {
			AfxMessageBox(IDS_MissingFieldError, MB_ICONEXCLAMATION) ;
			return ;
		} ;
	} ;

	// Format the new panose values for display.

	m_pcsPanose->Format("{%s, %s, %s, %s, %s, %s, %s, %s, %s, %s}", csadata[0],
						csadata[1], csadata[2], csadata[3], csadata[4],
						csadata[5], csadata[6], csadata[7], csadata[8],
						csadata[9]) ;

	// Wrap things up.

	CDialog::OnOK();
}


LRESULT CFIFIPanose::OnListCellChanged(WPARAM wParam, LPARAM lParam)
{
	// Do nothing if the dialog box is not initialized yet.

	if (!m_bInitDone)
		return TRUE ;

	// Note that the a panose value has changed.

	m_bChanged = true ;

	return TRUE ;
}




/////////////////////////////////////////////////////////////////////////////
// CWidthKernCheckResults dialog


CWidthKernCheckResults::CWidthKernCheckResults(CWnd* pParent /*=NULL*/)
	: CDialog(CWidthKernCheckResults::IDD, pParent)
{
	ASSERT(0) ;					// This routine should not be called
}


CWidthKernCheckResults::CWidthKernCheckResults(CFontInfo* pcfi,
											   CWnd* pParent /*=NULL*/)
	: CDialog(CWidthKernCheckResults::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWidthKernCheckResults)
	m_csKernChkResults = _T("");
	m_csWidthChkResults = _T("");
	//}}AFX_DATA_INIT

	// Save the pointer to the font info class

	m_pcfi = pcfi ;
}


void CWidthKernCheckResults::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWidthKernCheckResults)
	DDX_Control(pDX, IDC_BadKerningPairs, m_clcBadKernPairs);
	DDX_Text(pDX, IDC_KernTblResults, m_csKernChkResults);
	DDX_Text(pDX, IDC_WidthTblResults, m_csWidthChkResults);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWidthKernCheckResults, CDialog)
	//{{AFX_MSG_MAP(CWidthKernCheckResults)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWidthKernCheckResults message handlers

/******************************************************************************

  CWidthKernCheckResults::OnInitDialog

  Perform what consistency checks there are that can easily be done on the
  widths and kerning tables.  Then display the results in this dialog box.

******************************************************************************/

BOOL CWidthKernCheckResults::OnInitDialog()
{
	CDialog::OnInitDialog() ;
	
	// Load the appropriate message depending on the state of the widths table.

	if (m_pcfi->WidthsTableIsOK())
		m_csWidthChkResults.LoadString(IDS_WidthsTableOK) ;
	else
		m_csWidthChkResults.LoadString(IDS_WidthsTableTooBig) ;

	// Initialize the bad kerning info list control.

    CString csWork ;
    csWork.LoadString(IDS_KernColumn0) ;
    m_clcBadKernPairs.InsertColumn(0, csWork, LVCFMT_CENTER,
        (3 * m_clcBadKernPairs.GetStringWidth(csWork)) >> 1, 0) ;
    csWork.LoadString(IDS_KernColumn1) ;
    m_clcBadKernPairs.InsertColumn(1, csWork, LVCFMT_CENTER,
        m_clcBadKernPairs.GetStringWidth(csWork) << 1, 1) ;
    csWork.LoadString(IDS_KernColumn2) ;
    m_clcBadKernPairs.InsertColumn(2, csWork, LVCFMT_CENTER,
        m_clcBadKernPairs.GetStringWidth(csWork) << 1, 2) ;

	// Load any bad kerning info in the list control for display and use the
	// existence of this data to determine the appropriate message to display.

	if (m_pcfi->LoadBadKerningInfo(m_clcBadKernPairs))
		m_csKernChkResults.LoadString(IDS_KerningTableBadEnts) ;
	else
		m_csKernChkResults.LoadString(IDS_KerningTableOK) ;

	UpdateData(FALSE) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gpdfile.cpp ===
/******************************************************************************

  Source File:  Model Data.CPP

  Implementation of the code for handling GPC format data

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Resreved.

  A Pretty Penny Enterprises Production

  Change History:
  02-19-97  Bob_Kjelgaard@Prodgy.Net    Created it

******************************************************************************/

#include    "StdAfx.h"
#include    "ProjNode.H"
#include	"CodePage.H"
#include    "Resource.H"
#include    "GPDFile.H"
#include    "utility.H"
#include	"minidev.h"		


/******************************************************************************

  COldMiniDriverData class

  This class is tasked with representing the GPC data.  It will begin life as
  a stub, although it could become more functional, later.

******************************************************************************/

/******************************************************************************

  ExtractList

  This is a private worker function.  It takes a pointer to a null-terminated
  list of WORD font IDs, with the nasty complication that the first two
  elements of the list represent the endpoints of a range.  It mashes these
  into a passed word map (of which we only use the indices).

******************************************************************************/

static void ExtractList(PWORD pw, CMapWordToDWord& cmw2d) {
    for (WORD w = *pw++; w && w < *pw; w++)
        cmw2d[w] = 0;

    if  (!w)
        return; //  The whole list was empty

    while   (*pw)   //  We start at the endpoint (which we haven't mapped yet)
        cmw2d[*pw++] = 0;
}


COldMiniDriverData::~COldMiniDriverData()
{
	// The m_csoaFonts array has some duplicate entries in it because of GPC
	// entries that reference multiple printer models.  We must zap those
	// duplicate entries so the data won't be deleted twice in the CSafeObArray
	// destructor.  That would cause an AV.

	for (unsigned u = 0 ; u < m_csoaFonts.GetSize() ; u++) {
		if (GetSplitCode(u) != NoSplit)
			m_csoaFonts.SetAt(u, NULL) ;
	} ;
}


/******************************************************************************

  ColdMiniDriverData::Load

  This member function loads the mini-driver's GPC file, and extracts the
  number of models, the CTT IDs, and the model name IDs.

******************************************************************************/

BOOL    COldMiniDriverData::Load(CFile& cfImage) {

    struct sGPCHeaderEntry {
        WORD    m_wOffset, m_wcbItem, m_wcItems;
    };

    struct sMaster {
        WORD    m_wX, m_wY;
    };

    struct sPrinterModelData {
        WORD    m_wcbSize;
        WORD    m_widName;  //  Stringtable id for model name.
        WORD    m_wfGeneral;    //  TODO:   Define enums
        WORD    m_wfCurves;     //  TODO:   Define enums
        WORD    m_wfLines;      //  TODO:   Define enums
        WORD    m_wfPolygons;   //  TODO:   Define enums
        WORD    m_wfText;       //  TODO:   Define enums
        WORD    m_wfClipping;   //  TODO:   Define enums
        WORD    m_wfRaster;;    //  TODO:   Define enums
        WORD    m_wfLandscapeText;  //  TODO:   Define enums
        WORD    m_wLeftMargin;  //  Left-hand unprintable area
        WORD    m_wMaximumWidth;    //  Of physica page
        sMaster m_smMaximum, m_smMinimum;   //  Max min page sizes
        WORD    m_widDefaultFont;
        WORD    m_wLookAhead;
        WORD    m_wMaxFontsPerPage;
        WORD    m_wcCartridges;
        WORD    m_widDefaultCTT;
        enum {PortraitFonts, LandscapeFonts, Resolution, PaperSize,
            PaperQuality, PaperSource, PaperDestination, TextQuality,
            Compression, FontCartridge, Color, MemoryConfiguration};
        WORD    m_awofIndexLists[12];   //  Uses the preceding enum
        WORD    m_awIndices[16];        //  Ditto
        WORD    m_awVer3IndexLists[5];  //  Ditto
        WORD    m_wofDefaults;          //  List of defaults for index lists
        WORD    m_wReserved;
        DWORD   m_dwidICMManufactirer, m_dwidICMModel;
        DWORD   m_adwReserved[8];
    };

    struct sGPCFileHeader {
        WORD    m_widGPC;   //  0x7F00 or it isn't valid.
        WORD    m_wVersion; //  Final version is 3, there was a V2
        sMaster m_smMasterdpi;
        DWORD   m_dwoHeap;  //  The GPC data is maintained in one
        DWORD   m_dwcbFile; //  Total GPC Image size, heap and all
        enum {Default, PCL4, CAPSL, PPDS, TTY, DBCS};
        WORD    m_wTechnology;  //  Use the preceding enum
        enum {PrivateHelp = 1, OneDraftFont};
        WORD    m_wfGeneral;    //  Again, use the preceding enum
        char    m_acReserved[10];
        WORD    m_wcHeaderItems;    //  Number of valid header entries
        enum {ModelData, Resolution, PaperSize, PaperQuality, PaperSource,
                PaperDestination, TextQuality, Compression, FontCartridge,
                PageControl, CursorMovement, FontSimulation, DeviceColor,
                RectangleFill, DownloadInfo, VectorPage, Carousel, PenInfo,
                LineInfo, BrushInfo, VectorOutput, PolyVectorOutput,
                VectorSupport, ImageControl, PrintDensity, ColorTracking,
                MaximumDefined = 30};
        sGPCHeaderEntry m_asgpche[MaximumDefined];
    };

    struct sFontCartridge {
        WORD    m_wSize;    //  = 12
        WORD    m_widCartridge; //  In the string table
        WORD    m_wofPortraitList;
        WORD    m_wofLandscapeList;
        WORD    m_wfGeneral;
        WORD    m_wReserved;
    };

    //  In case we get called more than once, dump any old info...

    m_cbaImage.RemoveAll();
    m_csoaFonts.RemoveAll();
    m_cwaidCTT.RemoveAll();
    m_cwaidModel.RemoveAll();

    m_cbaImage.SetSize(cfImage.GetLength());

    cfImage.Read(m_cbaImage.GetData(), cfImage.GetLength());

    sGPCFileHeader  *psgfh = (sGPCFileHeader *) Image();

    if  (psgfh -> m_widGPC != 0x7F00 || psgfh -> m_wVersion > 0x3ff)
        return  FALSE;

    //  Suck out the printer model data we care about- eventually, this may
    //  be all of it

    for (unsigned u = 0;
         u < psgfh -> m_asgpche[sGPCFileHeader::ModelData].m_wcItems;
         u++) {
        sPrinterModelData&  spmd = *(sPrinterModelData *) (Image() +
        psgfh -> m_asgpche[sGPCFileHeader::ModelData].m_wOffset +
            psgfh -> m_asgpche[sGPCFileHeader::ModelData].m_wcbItem * u);
        m_cwaidModel.Add(spmd.m_widName);
        m_cwaidCTT.Add(spmd.m_widDefaultCTT);
        //  Build the font list- I use a CMapWordToOb to handle the duplicate
        //  screening

        CMapWordToDWord&   cmw2dThis = * (new CMapWordToDWord);
        //  Extract the portrait resident fonts
        if  (spmd.m_awofIndexLists[sPrinterModelData::PortraitFonts])
            ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                spmd.m_awofIndexLists[sPrinterModelData::PortraitFonts]),
                cmw2dThis);
        //  Extract the landscape resident fonts
        if  (spmd.m_awofIndexLists[sPrinterModelData::LandscapeFonts])
            ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                spmd.m_awofIndexLists[sPrinterModelData::LandscapeFonts]),
                cmw2dThis);
        //  Extract the cartridge fonts
        if  (spmd.m_awofIndexLists[sPrinterModelData::FontCartridge]) {
            PWORD   pw = (PWORD) (Image() + psgfh -> m_dwoHeap +
                spmd.m_awofIndexLists[sPrinterModelData::FontCartridge]);

            //  RAID    102890- Cartridge font index is 1-based, not 0-based

            while   (*pw) {
                sFontCartridge* psfc = (sFontCartridge *) (Image() + psgfh ->
                    m_asgpche[sGPCFileHeader::FontCartridge].m_wOffset +
                    psgfh ->
                    m_asgpche[sGPCFileHeader::FontCartridge].m_wcbItem *
                    (-1 + *pw++));

                //  END RAID 102890

                //  Portrait

                if  (psfc -> m_wofPortraitList)
                    ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                        psfc -> m_wofPortraitList), cmw2dThis);

                //  Landscape

                if  (psfc -> m_wofLandscapeList)
                    ExtractList((PWORD) (Image() + psgfh -> m_dwoHeap +
                        psfc -> m_wofLandscapeList), cmw2dThis);
            }
        }

        //  Save the map in the font structure
        m_csoaFonts.Add(&cmw2dThis);
    }

    return  TRUE;
}


/******************************************************************************

  COldMiniDriverData::SplitMultiGPCs

  The Load() function has loaded information about each GPC entry into this
  class' member variables.  The problem is that there are some GPC entries
  that are used to manage multiple models.  This routine is used to "split"
  the data for these entries into single model "sections".  Actually, what
  happens is that new member variables entries are allocated for each model
  and the GPC entry's data is copied into them.  Next, a flag is set to
  mark this copy.

******************************************************************************/

bool COldMiniDriverData::SplitMultiGPCs(CStringTable& cstdriversstrings)
{
	// Make sure the data arrays are the same size.

	ASSERT(m_cwaidModel.GetSize() == m_cwaidCTT.GetSize()) ;
	ASSERT(m_cwaidModel.GetSize() == (int) m_csoaFonts.GetSize()) ;

	// Size the split codes array and split models names array to the current
	// number of GPC entries.

	m_cuaSplitCodes.SetSize(m_cwaidModel.GetSize()) ;
	m_csaSplitNames.SetSize(m_cwaidModel.GetSize()) ;
				
	// Declare the variables needed for the processing in the following loops.

	unsigned u, u2 ;			// Looping/indexing variables
	int nloc ;					// Location of "%" in model name
	CString csentryname ;	
	int nlen ;					// Length of csentryname/csmodelname

	// Loop through each GPC entry...

    for (u = 0 ; u < ModelCount(); u++) {

		// If the GPC entry's model name contains no percent signs, the entry
		// only references one model.  Note this and continue.

		csentryname = cstdriversstrings[ModelName(u)] ;
		if ((nloc = csentryname.Find(_T('%'))) == -1) {
			SetSplitCode(u, NoSplit) ;
			continue ;
		} ;

		// The entry references multiple models.  Mark the entry as the first
		// one and save its correct single model name.

		SetSplitCode(u, FirstSplit) ;
		m_csaSplitNames[u] = csentryname.Left(nloc) ;

		// Copy the entry's data into new elements of the data arrays.  One
		// new set of data elements are allocated for each additional model
		// referenced by the entry.

		nlen = csentryname.GetLength() ;
		for (u2 = u + 1 ; nloc != -1 ; u2++, u++) {
			m_cwaidModel.InsertAt(u2, m_cwaidModel[u]) ;
			m_cwaidCTT.InsertAt(u2, m_cwaidCTT[u]) ;
			m_csoaFonts.InsertAt(u2, m_csoaFonts[u]) ;
			InsertSplitCode(u2, OtherSplit) ;

			// Look for the next percent sign in the entry's name.  (Make sure
			// we don't reference passed the end of the string while doing
			// this.)

			if (nloc + 2 < nlen) {
				csentryname = csentryname.Mid(nloc + 1) ;
				nlen = csentryname.GetLength() ;
				nloc = csentryname.Find(_T('%')) ;
			} else
				break ;

			// Save the model name for the new entry.

			if (nloc == -1)
				m_csaSplitNames.InsertAt(u2, csentryname) ;
			else
				m_csaSplitNames[u] = csentryname.Left(nloc) ;
		} ;
	} ;

	// All went well so...

	return true ;
}


/******************************************************************************

  COldMiniDriverData::FontMap(unsigned u)

  This member returns the map which shows which fonts are used by the given
  model.

******************************************************************************/

CMapWordToDWord&   COldMiniDriverData::FontMap(unsigned u) const {
    return  *(CMapWordToDWord *) m_csoaFonts[u];
}

/******************************************************************************

  COldMiniDriverData::NoteTranslation

  This records the fact that model nn must translate instances of font ID xxx
  to font ID y.
******************************************************************************/

void    COldMiniDriverData::NoteTranslation(unsigned uModel, unsigned uidOld,
                                            unsigned uidNew) {
    FontMap(uModel)[(WORD)uidOld] = uidNew;
}

/******************************************************************************

  CModelData class

  This class encapsulates the GPD file.  It will start life as a big
  CStringArray, but as the editor gets more sophisticated, it may gain
  additional members to speed processing and/or manipulation of the data.

******************************************************************************/

IMPLEMENT_SERIAL(CModelData, CProjectNode, 0)


/******************************************************************************

  CModelData::FillViewer

  This static member function is a callback for the rich edit control.  It
  receives a pointer to the CModelData in question, and calls its Fill from
  buffer member function.

  Args:
	DWORD	dwthis		Pointer to the CModelData in question
	LPBYTE	lpb			Pointer to the buffer to fill
	LONG	lcb			Number of bytes to read
	LONG   *plcb		Number of bytes actually read is saved here

  Returns:
    TRUE (failure) if class instance pointer is NULL.  Otherwise, whatever
	Fill() returns.

******************************************************************************/

DWORD CALLBACK  CModelData::FillViewer(DWORD_PTR dwthis, LPBYTE lpb, LONG lcb,
                                       LONG *plcb) {
    if  (!dwthis)
        return  TRUE;

    CModelData* pcmd = (CModelData *) dwthis;

    return pcmd -> Fill(lpb, lcb, plcb);
}


/******************************************************************************

  CModelData::FromViewer

  This is a stream callback for moving data from the edit control to the GPD
  class.  It receives a pointer to the CModelData being updated, and calls its
  UpdateFrom buffer member function to do the rest of the work

******************************************************************************/

DWORD CALLBACK  CModelData::FromViewer(DWORD_PTR dwthis, LPBYTE lpb, LONG lcb,
                                       LONG *plcb) {
    if  (!dwthis)
        return  TRUE;   //  Stop the madness

    CModelData* pcmd = (CModelData *) dwthis;

    return  pcmd -> UpdateFrom(lpb, lcb, plcb);
}


/******************************************************************************

  CModelData::Fill(LPBYTE lpb, LONG lcb, LONG *plcb)

  This private method fills a buffer from the GPD contents in CString form.
  An internal buffer is used to handle partially moved strings.

******************************************************************************/

DWORD CModelData::Fill(LPBYTE lpb, LONG lcb, LONG *plcb) {

    int iTotalLines = (int)m_csaGPD.GetSize();	// Get the # of lines in the GPD

	// If the temp buffer is empty and the next line to read is greater than
	// the number of lines in the GPD, the REC has been loaded.  We're done.

    if  (!m_cbaBuffer.GetSize() && m_iLine >= iTotalLines) {
        *plcb = 0;
        return  0;
    }

    unsigned    ucb = (unsigned) lcb;	// Number of bytes still wanted

    union   {
        LPTSTR  lpstr;
        LPBYTE  lpbThis;
    };

    //  First, empty anything buffered previously

    lpbThis = lpb;

	// If there is data left over from a line partially loaded into the REC
	// before..

    if  (m_cbaBuffer.GetSize())

		// ...If the partial line will fit into the REC buffer, copy it
		// into the buffer, update variables to indicate this, and continue.

        if  ((unsigned) m_cbaBuffer.GetSize() <= ucb) {
            memcpy(lpbThis, m_cbaBuffer.GetData(), (size_t)m_cbaBuffer.GetSize());
            ucb -= (unsigned)m_cbaBuffer.GetSize();
            lpbThis += m_cbaBuffer.GetSize();
            m_cbaBuffer.RemoveAll();

		// ...If the partial line won't fit in the REC buffer, copy the
		// portion of it that will fit into the REC buffer, remove those bytes
		// from the line buffer, and return because nothing more can be loaded.

		} else {
            memcpy(lpbThis, m_cbaBuffer.GetData(), ucb);
            m_cbaBuffer.RemoveAt(0, ucb);
            *plcb = lcb;
            return  0;
        }

	// Line by line, copy as much data as possible into the REC's buffer.

    for (; ucb && m_iLine < iTotalLines; m_iLine++) {
		// Get the next GPD line and add CR LF to it.

        CString csLine = m_csaGPD[m_iLine];
        csLine += _TEXT("\r\n");

		// If the entire line will fit into the REC's buffer, copy it in.  Then
		// update all pointers, counters, etc and then check the next line.

        if  ((csLine.GetLength()) * sizeof(TCHAR) <= ucb) {
            memcpy(lpbThis, (LPCTSTR) csLine,
                sizeof(TCHAR) * csLine.GetLength());
            ucb -= sizeof(TCHAR) * csLine.GetLength();
            lpstr += csLine.GetLength();
            continue;
        }

		// If this point is reached, the current line will not fit in the REC's
		// buffer so first copy the line into the temp buffer.  Then copy the
		// portion of the line that will fit into the REC's buffer.  Last,
		// update the buffers, pointers, and counters.

        m_cbaBuffer.SetSize(sizeof(TCHAR) * csLine.GetLength());
        memcpy(m_cbaBuffer.GetData(), (LPCTSTR) csLine,
            sizeof(TCHAR) * csLine.GetLength());
        memcpy(lpbThis, m_cbaBuffer.GetData(), ucb);
        m_cbaBuffer.RemoveAt(0, ucb);
        ucb = 0;
    }

	// Save the number of bytes load and return 0 to indicate success.

    *plcb = lcb - ucb;
    return  0;
}


/******************************************************************************

  CModelData::UpdateFrom(LPBYTE lpb, LONG lcb, LONG* plcb)

  This is a private member- an overload which adds the contents of the given
  buffer to the GPD CStringArray, by parsing it into strings.  A private buffer
  member is used to hold partial strings between calls.

******************************************************************************/

DWORD   CModelData::UpdateFrom(LPBYTE lpb, LONG lcb, LONG* plcb) {
    //  Copy the buffer to a byte buffer and null-terminate
    m_cbaBuffer.SetSize(1 + lcb);
    memcpy(m_cbaBuffer.GetData(), lpb, lcb);
    m_cbaBuffer.SetAt(-1 + m_cbaBuffer.GetSize(), 0);

    //  Convert to string and append to any buffered data.

    CString csWork(m_cbaBuffer.GetData());
    CString csEnd(_T("\r\x1A"));    //  These get dumped

    m_cbaBuffer.RemoveAll();

    m_csBuffer += csWork;

    //  Add any complete strings to the GPD contents.

    csWork = m_csBuffer.SpanExcluding(_T("\n"));

    while   (csWork.GetLength() != m_csBuffer.GetLength()) {
        m_csBuffer = m_csBuffer.Mid(csWork.GetLength() + 1);
        //  Remove any trailing whitespace.
        csWork.TrimRight();
        //  Add the string sans any leading control characters
        m_csaGPD.Add(csWork.Mid(csWork.SpanIncluding(csEnd).GetLength()));
        //  While we're here, remove any leading control characters from buffer
        m_csBuffer =
            m_csBuffer.Mid(m_csBuffer.SpanIncluding(csEnd).GetLength());
        csWork = m_csBuffer.SpanExcluding(_T("\n"));
    }
    //  The leftover data (if any) may be used later...

    *plcb = lcb;
    return  0;
}

/******************************************************************************

  CModelData::Classify

  This method identifies the line numbers for each warning comment, error
  comment, and any other sort of comment, so they can later be syntax colored.

******************************************************************************/

/******************************************************************************

  CModelData::CModelData

  Constructs an empty CModelData object- includes building the Menu table

******************************************************************************/

CModelData::CModelData() {
    m_pcmdt = NULL;
    m_cfn.SetExtension(_T(".GPD"));
    m_cfn.AllowPathEdit();

    //  Build the context menu control
    m_cwaMenuID.Add(ID_OpenItem);
    m_cwaMenuID.Add(ID_CopyItem);
    m_cwaMenuID.Add(ID_RenameItem);
    m_cwaMenuID.Add(ID_DeleteItem);
    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);

	// Initialize the variables needed for workspace completeness and tidiness
	// checking.

	m_bTCUpdateNeeded = false ;	
	m_pnUFMRCIDs = m_pnStringRCIDs = NULL ;
	m_nNumUFMsInGPD = m_nNumStringsInGPD = 0 ;
	m_pvRawData = NULL ;
}


/******************************************************************************

  CModelData::~CModelData()

  Free, unload, and delete the data used for completeness and tidiness checks.

******************************************************************************/

extern "C" void UnloadRawBinaryData(PVOID pRawData) ;

CModelData::~CModelData()
{
	// If the GPD has been parsed...

    if  (m_pvRawData) {

		// Free the parsed data

        UnloadRawBinaryData(m_pvRawData) ;

		// Delete the parsed data file

		try {
			CString cs ;
			cs = FilePath() + FileTitle() + _T(".BUD") ;
			DeleteFile(cs) ;
		}
		catch (CException *pce) {
			pce->ReportError();
			pce->Delete();
		}

		// Delete each of the resource lists that exist

		if (m_pnUFMRCIDs)
			delete m_pnUFMRCIDs ;
		if (m_pnStringRCIDs)
			delete m_pnStringRCIDs ;
	} ;
}


/******************************************************************************

  CModelData::Load(CStdioFile csiofGPD)

  This overload loads the GPD from a text file directly.

******************************************************************************/

BOOL    CModelData::Load(CStdioFile& csiofGPD)
{
    CString csWork;				// Used to read the GPD file's contents

	// Initialize the string array used to hold the GPD file's contents

    m_csaGPD.RemoveAll();

	// Load the GPD into the string array one line at a time.

    while   (csiofGPD.ReadString(csWork)) {
        csWork.TrimRight(); //  Cut off the trailing line stuff
        m_csaGPD.Add(csWork);
    }

    //  Set the correct name and path when necessary.  The rename checks may
    //  fail since the file is opened elsewhere (possibly with sharing
    //  conflicts), so disable them while the name is set.

    if  (FileTitle().IsEmpty()) {
        m_cfn.EnableCreationCheck(FALSE);
        SetFileName(csiofGPD.GetFilePath());
        m_cfn.EnableCreationCheck();
    }

	// All went well so...

    return  TRUE;
}


/******************************************************************************

  CModelData::Load()

  This overload loads the GPD file from the disk using the stored name and path
  information.

******************************************************************************/

BOOL    CModelData::Load()
{
	// There is nothing to load if no file has been associated with this
	// instance of CModelData.

    if  (FileTitle().IsEmpty())
        return  FALSE;

    // Open the GPD file and call another load routine to finish the work.

	try {
        CStdioFile  csiofGPD(FileName(),
            CFile::modeRead | CFile::shareDenyWrite);
        return  Load(csiofGPD);
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
    }

    return  FALSE;
}


/******************************************************************************

  CModelData::Store

  This method sends the GPD file to the disk.  Since GPD infromation can be
  easily edited with an external editor, this avoids replication and
  consistency issues.

******************************************************************************/

BOOL    CModelData::Store(LPCTSTR lpstrPath) {

	int n =	(int)m_csaGPD.GetSize() ;
	CString cs = m_csaGPD[0] ;

    //  Write the GPD file to the target location, with the traditional CR/LF
    //  separators.  If the given name is NULL, use the stored one.

    try {
        CStdioFile   csiofGPD(lpstrPath ? lpstrPath :
            FileName(), CFile::modeCreate | CFile::modeWrite |
            CFile::shareExclusive | CFile::typeBinary);

        for (int i = 0; i < m_csaGPD.GetSize(); i++)
            csiofGPD.WriteString(m_csaGPD[i] + _T("\r\n"));
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    Changed(FALSE);

    return  TRUE;
}


/******************************************************************************

  CModelData::BkupStore

  Backup the original contents of the GPD to file called "BKUP_GPD" before
  calling Store() to save the file.

  Return TRUE if the backup and storing succeed.  Otherwise, return FALSE.

******************************************************************************/

BOOL    CModelData::BkupStore()
{
	// Build the backup file's filespec

	CString csbkfspec = m_cfn.Path() ;
	if (csbkfspec[csbkfspec.GetLength() - 1] != _T('\\'))
		csbkfspec += _T("\\") ;
	csbkfspec += _T("BKUP_GPD") ;

	// raid 9730 : bug caused by "Read-Only"
	CFileStatus rStatus;
	CFile::GetStatus(FileName(), rStatus);
	// Back up the file. 
    try {
        if (rStatus.m_attribute & 0x01 || !CopyFile(FileName(), csbkfspec, FALSE)) {//end raid
			csbkfspec.Format(IDS_GPDBackupFailed, FileTitleExt()) ;
			if (AfxMessageBox(csbkfspec, MB_YESNO + MB_ICONQUESTION) == IDNO)
				return FALSE  ;
		} ;
    }
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return  FALSE ;
    } ; 

	// Now do a normal store operation.

	return (Store()) ;
}


/******************************************************************************

  CModelData::Restore

  Copy the file "BKUP_GPD" to the GPD file to restore the GPD's original
  contents.  If the restore operation is successful, delete the backup file.

  Return nonzero if this succeeds.  Otherwise, return FALSE.

******************************************************************************/

BOOL    CModelData::Restore()
{
	// Build the backup file's filespec

	CString csbkfspec = m_cfn.Path() ;
	if (csbkfspec[csbkfspec.GetLength() - 1] != _T('\\'))
		csbkfspec += _T("\\") ;
	csbkfspec += _T("BKUP_GPD") ;

	// Restore the file.

    try {
        if (CopyFile(csbkfspec, FileName(), FALSE)) {
			DeleteFile(csbkfspec) ;
			return TRUE ;
		} else
			return FALSE ;
    }
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return  FALSE ;
    } ;
}


/******************************************************************************

  CModelData::Parse

  This method is responsible for parsing the GPD file and collecting the
  resulting errors.

  The initial implementation will be a bit bizarre, because the GPD parser
  isn't stable, and converting it so it would work well for ma and then staying
  on top of the changes just doesn't make sense.

******************************************************************************/

extern "C" BOOL BcreateGPDbinary(LPCWSTR lpstrFile, DWORD dwVerbosity);
                                                        //  The parser hook
extern "C" PVOID LoadRawBinaryData(LPCWSTR lpstrFile) ;
extern "C" PVOID InitBinaryData(PVOID pv, PVOID pv2, PVOID pv3) ;
extern "C" void FreeBinaryData(PVOID pInfoHdr);
extern "C" void UseLog(FILE *pfLog);

//extern "C" DWORD gdwVerbosity ;

BOOL    CModelData::Parse(int nerrorlevel)
{
	//  Step 0: Set the error level.  This is 0 by default.

    //  Step 1: Establish the correct directory for the parser, and
    //  bang together a couple of file names

    CString csCurrent ;

    GetCurrentDirectory(MAX_PATH + 1, csCurrent.GetBuffer(MAX_PATH + 1));
    csCurrent.ReleaseBuffer();

    SetCurrentDirectory(m_cfn.Path().Left(m_cfn.Path().ReverseFind(_T('\\'))));

    //  Step 2: Fake out the error logging interface so it actually tosses
    //  them all into a CString Array for us, the invoke the parser.

    SetLog();


    //  Step 3:  Convert the file name to Unicode so we don't have to tweak the
    //  parser code.

	CString	csFile = FileTitle() + _T(".GPD");
	CByteArray	cbaIn;
	CWordArray	cwaOut;
	cbaIn.SetSize(csFile.GetLength() + 1);
	lstrcpy((LPSTR) cbaIn.GetData(), csFile);
	CCodePageInformation	ccpi;
	ccpi.Convert(cbaIn, cwaOut, GetACP());

    if  (BcreateGPDbinary((PWSTR)cwaOut.GetData(), nerrorlevel)) {
        PVOID   pRawData ;
        PVOID   pInfoHdr ;

        pRawData = LoadRawBinaryData((PWSTR)cwaOut.GetData());

        if(pRawData)
            pInfoHdr = InitBinaryData(pRawData, NULL, NULL);
        if  (pRawData && pInfoHdr)
            FreeBinaryData(pInfoHdr);
        if  (pRawData)
            UnloadRawBinaryData(pRawData) ;
        DeleteFile(FileTitle() + _T(".Bud"));
    }

    //  Finally, clean up the mess by restoring the original working
    //  directory and turn off logging.

    SetCurrentDirectory(csCurrent);
	EndLog() ;

    return  TRUE;
}

/******************************************************************************

  CModelData::RemoveError

  This removes the given error from the log.

******************************************************************************/

void    CModelData::RemoveError(unsigned u) {
    if  (u >= Errors())
        return;

    m_csaConvertLog.RemoveAt(u);
    Changed();
}


/******************************************************************************

  CModelData::Fill(CRichEditCtrl& crec)

  This overload fills the gven rich edit control with the GPD contents, either
  as currently cached in memory, or stored on the disk.

******************************************************************************/

void    CModelData::Fill(CRichEditCtrl& crec)
{
	// Prepare to load the rich edit control (REC) with the GPD data

	EDITSTREAM  es = {(DWORD_PTR) this, 0, FillViewer};
    m_iLine = 0;

    // If the GPD is not in memory yet, read it in before loading the REC.

	if  (!m_csaGPD.GetSize())
        Load();
	
	// Load the GPD into the REC.

    crec.StreamIn(SF_TEXT, es);
}


/******************************************************************************

  CModelData::UpdateFrom(CRichEditCtrl& crec)

  This overloaded member function discards the current GPD cache and refills
  it from the given edit control.

******************************************************************************/

void    CModelData::UpdateFrom(CRichEditCtrl& crec) {

    EDITSTREAM es = {(DWORD_PTR) this, 0, FromViewer};

    m_csaGPD.RemoveAll();

    m_csBuffer.Empty(); //  Just in case...

    crec.StreamOut(SF_TEXT, es);
    Changed();
}


/******************************************************************************

  CModelData::CreateEditor

  This member function launches an editing view for the GPD Data.

******************************************************************************/

CMDIChildWnd*   CModelData::CreateEditor()
{
	// Create a new document class instance for the new editor

    CGPDContainer* pcgpdcMe=
        new CGPDContainer(this, FileName());

	// Read in the GPD

    Load();

    //  Make up a cool title

    pcgpdcMe -> SetTitle(m_pcbnWorkspace -> Name() + _T(": ") + Name());

	// Build a frame for the editor and attach the doc class to it

    CMDIChildWnd    *pcmcwNew = (CMDIChildWnd *) m_pcmdt ->
        CreateNewFrame(pcgpdcMe, NULL);

	// Update the new frame/view

    if  (pcmcwNew) {
        m_pcmdt -> InitialUpdateFrame(pcmcwNew, pcgpdcMe, TRUE);
        m_pcmdt -> AddDocument(pcgpdcMe);
    }

	// Return the new frame pointer

    return  pcmcwNew;
}


/******************************************************************************

  CModelData::Import

  This method walks one step up the tree and passes the call to the import
  method for the fixed node which owns us.

******************************************************************************/

void CModelData::Import() {
    ((CBasicNode *) m_pctcOwner ->
        GetItemData(m_pctcOwner -> GetParentItem(m_hti))) -> Import();
}


/******************************************************************************

  CModelData::Serialize

  Stores the image, as we need it stored.

******************************************************************************/

void    CModelData::Serialize(CArchive& car) {
    CProjectNode::Serialize(car);

	//TRACE("\n%s has %d strings:\n", Name(), m_csaConvertLog.GetSize()) ;
	//for (int n = 0 ; n < m_csaConvertLog.GetSize() ; n++)
	//	TRACE("   %d: %s\n", n, m_csaConvertLog[n]) ;

	m_csaConvertLog.Serialize(car);
}


/******************************************************************************

  CModelData::UpdateResIDs

  This routine will make sure that the specified resource ID list is up to
  date.  There are several steps that must be taken to accomplish this goal:
	1.	Free/invalidate old resource lists and related information if the GPD
		has changed.
	2.  Parse the GPD and load its data if this is needed.
	3.	If step 2 is taken or the requested resource list is unitialized, get
		that data.

******************************************************************************/

//#define	RESLISTSIZE		16		// Initial resource list size

// Declarations for the GPD Parser routine that will get resource ID lists.

extern "C" BOOL GetGPDResourceIDs(LPINT lpiresarray, int numelts, LPINT lpicount,	
								  BOOL brestype, PVOID prawdata) ;

bool	CModelData::UpdateResIDs(bool bufmids)
{
	//TRACE("gdwVerbosity = %d\n", gdwVerbosity) ;

	// If the GPD has changed so the resource data needs to be updated...

	if (m_bTCUpdateNeeded) {
		if (m_pvRawData) {		// Free the old preparsed data if there is any
			UnloadRawBinaryData(m_pvRawData) ;
			m_pvRawData = NULL ;
		} ;
		if (m_pnUFMRCIDs) {		// Free the old UFM RC ID list if there is one
			delete m_pnUFMRCIDs ;
			m_pnUFMRCIDs = NULL ;
			m_nNumUFMsInGPD = 0 ;
		} ;
		if (m_pnStringRCIDs) {	// Free the old string RC ID list if there is one
			delete m_pnStringRCIDs ;
			m_pnStringRCIDs = NULL ;
			m_nNumStringsInGPD = 0 ;
		} ;
		m_bTCUpdateNeeded = false ;
	} ;

	// Parse and load the GPD data if this is needed.  If either of these steps
	// fail, return false because the resource list cannot be updated.

	if (!m_pvRawData) {
		try {
			WCHAR   wstrfilename[MAX_PATH] ;
			CString cs ;
			cs = FileName() ;
			MultiByteToWideChar(CP_ACP, 0, FileName(), -1, wstrfilename, MAX_PATH) ;
			//gdwVerbosity = 4 ;
			if (!BcreateGPDbinary(wstrfilename, 0))
				return false ;
			if ((m_pvRawData = LoadRawBinaryData(wstrfilename)) == NULL)
				return false ;
		}
		catch (CException *pce) {
			pce->ReportError() ;
			pce->Delete() ;
			return false ;
		}
	} ;

	// If the requested resource list is already up to date, just return true.

	if ((bufmids && m_pnUFMRCIDs) || (!bufmids && m_pnStringRCIDs))
		return true ;

	// Allocate space for the resource list

	int*	pn = NULL ;
	int		ncnt = -1 ;
	//pn = new int[RESLISTSIZE + 2] ;

	// Try to get the requested resource ID list.  If this fails because the
	// array used to hold the IDs isn't big enough, reallocate the array and
	// try to get the IDs again.  If this fails again, generate a hard error.

	GetGPDResourceIDs(pn, 0, &ncnt, bufmids, m_pvRawData) ;
	pn = new int[ncnt + 2] ;
	VERIFY(GetGPDResourceIDs(pn, ncnt, &ncnt, bufmids, m_pvRawData)) ;

	//if (GetGPDResourceIDs(pn, RESLISTSIZE, &ncnt, bufmids, m_pvRawData)) {
	//	delete pn ;
	//	pn = new int[ncnt + 2] ;
	//	VERIFY(!GetGPDResourceIDs(pn, ncnt, &ncnt, bufmids, m_pvRawData)) ;
	//} ;

	// Update the specific resource ID variables based with the info collected
	// above.

	if (bufmids) {
		m_pnUFMRCIDs = pn ;
		m_nNumUFMsInGPD = ncnt ;
	} else {
		m_pnStringRCIDs = pn ;
		m_nNumStringsInGPD = ncnt ;
	} ;

	// All went well so...

	return true ;
}


/******************************************************************************
//RAID 17897

  CModelData::GetKeywordValue

  Get the value of keyword in Gpd file, 

Arguments : 
 csFileName ; file path of gpd file 
 csKeyword  : section name such as *GpdFileVersion: , *ModleName:

Return :
 Success : return section value (string)
 Failue  : return csFileName : file path as it come
*****************************************************************************8*/


CString CModelData::GetKeywordValue(CString csfile, CString csKeyword)
{	
	CFile cf;
	CString  csModel,csline;
	int offset;
	
	CStringArray csaData;
	
	if(!LoadFile(csfile,csaData)){	// call global function in minidev.h(which is include for this fucntion)
		CString csErr;
		csErr.Format(IDS_InvalidFilename, csfile);
		AfxMessageBox(csErr,MB_OK);
		return csfile;
	}

	for(int i=0; i<csaData.GetSize();i++){
		csline = csaData[i];
		if(-1 ==(offset=csline.Find(csKeyword)))
			continue;
		else
		{
			csModel = csline.Mid(offset+csKeyword.GetLength());

			return csModel.Mid(csModel.Find(_T('"'))+1,csModel.ReverseFind(_T('"'))
				+ - csModel.Find(_T('"')) - 1 );	// cancel  : "
			
			
		}
	}
	return csfile;
}
/***************************************************************************************
	CModelData::SetKeywordValue
Set the keyword value 

Arguments:
csfile ; target file gpd file name
csKeyword : target keyword ex) *GPDFilename
csValue : value of keyworkd ex)*GPDFilename= g;\nt\dirver\mm.gpd


*****************************************************************************************/

void CModelData::SetKeywordValue(CString csfile, CString csKeyword, CString csValue,bool bSource)
{
	CFile cf;
	int offset;
	CString csline;
	CStringArray csaData;
	
	if(!LoadFile(csfile,csaData)){
		CString csErr;
		csErr.Format(IDS_InvalidFilename, csfile);
		AfxMessageBox(csErr,MB_OK);
	}


	for(int i=0; i<csaData.GetSize();i++){
		csline = csaData[i];
		if(-1 ==(offset=csline.Find(csKeyword)))
			continue;
		else
		{
			csline.Empty();
			if(bSource )
				csline = csKeyword + _T("=") + csValue ;
			else
				csline = csKeyword +_T(": ")+ _T('"') + csValue + _T('"');
			
			csaData[i]= csline;
			m_csaGPD.Copy(csaData);
			Store(csfile);
			return ;
		}
	}
}
	
	
			


/******************************************************************************

  CGPDContainer class implementation

  This class is a document class which contains one GPD file and its assorted
  control mechanisms

******************************************************************************/

IMPLEMENT_DYNCREATE(CGPDContainer, CDocument)

// This version of the constructor is called when the GPD Editor is started
// from the Workspace View.

CGPDContainer::CGPDContainer(CModelData *pcmd, CString csPath)
{
    m_bEmbedded = TRUE ;		// Called from Workspace View
    m_pcmd = pcmd;
    SetPathName(csPath, FALSE);
    m_pcmd -> NoteOwner(*this);
}


// This version of the constructor is called when the GPD Editor is started
// from the File Open command.

CGPDContainer::CGPDContainer()
{
    m_bEmbedded = FALSE;		// Called from File Open menu
    m_pcmd = new CModelData;
    m_pcmd -> NoteOwner(*this);
}


/******************************************************************************

  CGPDContainer::OnNewDocument

  We just pass it back to the default handler.  Could mean this one can be
  toasted

******************************************************************************/

BOOL CGPDContainer::OnNewDocument() {
	return  CDocument::OnNewDocument();
}

/******************************************************************************

  CGPDContainer::~CGPDContainer

  If this wasn't created from the workspace, then zap the data!

******************************************************************************/

CGPDContainer::~CGPDContainer() {
    if  (!m_bEmbedded && m_pcmd)
        delete  m_pcmd;
}


BEGIN_MESSAGE_MAP(CGPDContainer, CDocument)
	//{{AFX_MSG_MAP(CGPDContainer)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGPDContainer diagnostics

#ifdef _DEBUG
void CGPDContainer::AssertValid() const {
	CDocument::AssertValid();
}

void CGPDContainer::Dump(CDumpContext& dc) const {
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGPDContainer serialization

void CGPDContainer::Serialize(CArchive& ar) {
	if (ar.IsStoring()) {
		// TODO: add storing code here
	}
	else {
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGPDContainer commands

/******************************************************************************

  CGPDContainer::OnSaveDocument

  First, make sure that the document is up to date.  See CGPDViewer::OnUpdate()
  for more information.  Then, we bypass the normal serialization process, and
  simple blast it to the drive.

******************************************************************************/

BOOL CGPDContainer::OnSaveDocument(LPCTSTR lpszPathName)
{
	UpdateAllViews(NULL, 0x4545, (CObject*) 0x4545) ;

    return  ModelData()->Store(lpszPathName) ;
}

/******************************************************************************

  CDPSContainer::OnOpenDocument

  Again, blow off serialization- if I haven't figured out how to read a text
  file by now, I'm definitely in the wrong place.

******************************************************************************/

BOOL CGPDContainer::OnOpenDocument(LPCTSTR lpszPathName) {
    try {
        CStdioFile  csiofGPD(lpszPathName, CFile::modeRead |
            CFile::shareDenyWrite | CFile::typeText);

        return  ModelData() -> Load(csiofGPD);
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
    }

    return  FALSE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gpc2gpd.cpp ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    gpc2gpd.c

Abstract:

    GPC-to-GPD conversion program

Environment:

    User-mode, stand-alone utility tool

Revision History:

    10/16/96 -zhanw-
        Created it.

--*/

#include    "StdAfx.H"

#include    "ProjNode.H"
#include    "Resource.H"
#include    "GPDFile.H"
#include    "..\GPC2GPD\GPC2GPD.H"

extern "C" void VOutputGlobalEntries(PCONVINFO pci, PCSTR pstrModelName, 
                                     PCSTR pstrResourceDLLName, 
									 PCSTR pstrGPDFileName);

/******************************************************************************

  VPrintErros
  VOut

  These replace functions used in the command line converter.

******************************************************************************/

static void VPrintErrors(CStringArray& csaLog, DWORD dwError) {
    for (unsigned u = 0; u < NUM_ERRS; u++)
        if (dwError & gdwErrFlag[u])
            csaLog.Add(gpstrErrMsg[u]);
    for (u = 0; u < (unsigned) csaLog.GetSize(); u++)
        csaLog[u].TrimRight();  //  Trim off the white space, we won't need it
}

extern "C" void _cdecl
VOut(
    PCONVINFO pci,
    PSTR pstrFormat,
    ...)
/*++
Routine Description:
    This function formats a sequence of bytes and writes to the GPD file.

Arguments:
    pci - conversionr related info
    pstrFormat - the formatting string
    ... - optional arguments needed by formatting

Return Value:
    None
--*/
{
    va_list ap;
    BYTE aubBuf[MAX_GPD_ENTRY_BUFFER_SIZE];
    int iSize;

    va_start(ap, pstrFormat);
    StringCchPrintfA((PSTR)aubBuf, CCHOF(aubBuf), pstrFormat, ap);
    va_end(ap);

    iSize = strlen((CHAR*)aubBuf) + 1;

    if (pci->dwMode & FM_VOUT_LIST && iSize > 4)
    {
        //
        // check for the extra comma before the closing bracket
        //
        if (aubBuf[iSize-4] == ',' && aubBuf[iSize-3] == ')')
        {
            aubBuf[iSize-4] = aubBuf[iSize-3];  // ')'
            aubBuf[iSize-3] = aubBuf[iSize-2];  // '\r'
            aubBuf[iSize-2] = aubBuf[iSize-1];  // '\n'
            iSize--;
        }
    }
    //  Memory exceptions should be all that's possible, but call any MFC
    //  exception a "file write error" for compatibility.
    try {
        CString csLine(aubBuf);
        //  If the previous line does not end in whitespace, add this one to it

        if  (pci -> pcsaGPD -> GetSize()) {
            CString&    csPrevious = 
                pci -> pcsaGPD -> ElementAt( -1 + pci -> pcsaGPD -> GetSize());
            if  (csPrevious.Right(1)[0] != _TEXT('\n')) {
                csPrevious += csLine;
                return;
            }
            csPrevious.TrimRight(); //  Remove the CR/LF combo.
        }
        pci -> pcsaGPD -> Add(csLine);
    }
    catch   (CException * pce) {
        pce -> ReportError();
        pce -> Delete();
        pci -> dwErrorCode |= ERR_WRITE_FILE;
    }
    // continue even if an error has occurred.
}

/******************************************************************************

  CModelData::Load(PCSTR pcstr, CString csResource, unsigned uModel,
                   CMapWordToDWord& cmw2dFontMap, WORD wfGPDConvert)

  This member function fills this instance by converting a model from the GPC 
  data pointed at by pcstr.

******************************************************************************/

BOOL    CModelData::Load(PCSTR pstr, CString csResource, unsigned uModel,
                         CMapWordToDWord& cmw2dFontMap, WORD wfGPDConvert) {

    CONVINFO    ci;     // structure to keep track conversion information

    //
    // check if we have all the arguments needed
    //
    if (!pstr || csResource.IsEmpty() || !uModel)
        return  FALSE;

    ZeroMemory((PVOID)&ci, sizeof(CONVINFO));

    //
    // Open the GPC file and map it into memory.
    //
    ci.pdh = (PDH) pstr;

    //
    // GPC file sanity check
    //
    if (ci.pdh->sMagic != 0x7F00 ||
        !(ci.pmd = (PMODELDATA)GetTableInfo(ci.pdh, HE_MODELDATA, uModel-1)) ||
        !(ci.ppc = (PPAGECONTROL)GetTableInfo(ci.pdh, HE_PAGECONTROL,
        ci.pmd->rgi[MD_I_PAGECONTROL]))) {
        ci.dwErrorCode |= ERR_BAD_GPCDATA;
        goto exit;
    }

    //
    // allocate dynamic buffers needed for conversion
    //
    if (!(ci.ppiSize=(PPAPERINFO)MemAllocZ(ci.pdh->rghe[HE_PAPERSIZE].sCount*sizeof(PAPERINFO))) ||
        !(ci.ppiSrc=(PPAPERINFO)MemAllocZ(ci.pdh->rghe[HE_PAPERSOURCE].sCount*sizeof(PAPERINFO))) ||
        !(ci.presinfo=(PRESINFO)MemAllocZ(ci.pdh->rghe[HE_RESOLUTION].sCount*sizeof(RESINFO))))
    {
        ci.dwErrorCode |= ERR_OUT_OF_MEMORY;
        goto exit;
    }

    //
    // generate GPD data
    //

    ci.pcsaGPD = &m_csaGPD;
    ci.pcmw2dFonts = &cmw2dFontMap;
// eigos /1/16/98
//    ci.dwStrType = wfGPDConvert % (1 + STR_RCID_SYSTEM_PAPERNAMES); //  Paranoid conversion...
    //rm - Use value macros (see stdnames.gpd) - fixes a want request
    ci.dwStrType = STR_MACRO;

	// Emit RCID_DMPAPER_SYSTEM_NAME
	// Done by v-erike on 3/30/98.  Requested by patryan

	ci.bUseSystemPaperNames = TRUE ;

    VOutputGlobalEntries(&ci, m_csName, csResource + _T(".Dll"), FileTitleExt());
    VOutputUIEntries(&ci);
    VOutputPrintingEntries(&ci);

    m_csaGPD[-1 + m_csaGPD.GetSize()].TrimRight();

exit:
    if (ci.ppiSize)
        MemFree(ci.ppiSize);
    if (ci.ppiSrc)
        MemFree(ci.ppiSrc);
    if  (ci.presinfo)
        MemFree(ci.presinfo);
    if (ci.dwErrorCode) {
        //
        // Open the log file and print out errors/warnings.
        // Borrow the GPD file name buffer.
        //
        VPrintErrors(m_csaConvertLog, ci.dwErrorCode);
    }

    return TRUE;
}

/******************************************************************************

  vMapFontList

  This procedure uses the CMapWordToDWord mapping in the CONVINFO structure to
  map font indices in font lists.  This is the final bit of skullduggery needed
  to make the mapping of a single PFM to multiple UFMs effective.

******************************************************************************/

extern "C" void vMapFontList(IN OUT PWORD pwFonts, IN DWORD dwcFonts, 
                             IN PCONVINFO pci) {

	//	If there are n fonts, or just one and the ID is 0 (happens if there are
	//	no device fonts.

    if  (!dwcFonts || (dwcFonts == 1 && !*pwFonts))
        return;

    CWordArray          cwaFonts;
    CMapWordToDWord&    cmw2dFonts = *pci -> pcmw2dFonts;

    WORD    wGreatest = 0;	//	Highest font ID in the new array

    for (unsigned uFont = 0; uFont < dwcFonts; uFont++) {
        WORD    widThis = pwFonts[uFont];

        if  (cmw2dFonts[widThis])    //  It will be 0 if unmapped
            widThis = (WORD) cmw2dFonts[widThis];

        if  (widThis > wGreatest) {	//	Is this the new end of the list?
            cwaFonts.Add(widThis);
            wGreatest = widThis;
            continue;
        }

        for (int i = 0; i < cwaFonts.GetSize(); i++)
            if  (cwaFonts[i] > widThis) {
                cwaFonts.InsertAt(i, widThis);
                break;
            }

        _ASSERT(i < cwaFonts.GetSize());
    }

    //  OK, the font list is corrected and is once again sorted.  Copy it back

    memcpy(pwFonts, cwaFonts.GetData(), dwcFonts * sizeof wGreatest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gpdview.h ===
/******************************************************************************

  Header File:  GPD Viewer.H

  This defines the class which implements the GPD viewer / editor.  Looks
  pretty painless for the nonce.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03/24/1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(AFX_GPDVIEWER_H__1BDEA163_A492_11D0_9505_444553540000__INCLUDED_)
#define AFX_GPDVIEWER_H__1BDEA163_A492_11D0_9505_444553540000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CGPDViewer : public CRichEditView {
    int         m_iLine, m_iTopLineColored; //  Used for work items
    UINT        m_uTimer;					//  Identifier for change timer
    CDialogBar  m_cdbActionBar;				//  Holds GPD related controls/info
    CStatusBar  m_csb;						//  Manages the GPD Editor's status bar
    CFindReplaceDialog  m_cfrd;				//  Unused at this (6/29/98) time
    BOOL        m_bInColor, m_bStart;       //  Flags to avoid recursion
	int			m_nErrorLevel ;				//  Parser verbosity level
	bool		m_bEditingAidsEnabled ;		//  True iff editing aids are enabled
	void*		m_punk ;					//  Used to freeze REC display
	void*		m_pdoc ;					//  Used to freeze REC display
	long		m_lcount ;					//  Used to freeze REC display
	bool		m_bVScroll ;				//  True iff VScroll msg handled

    void        MarkError(unsigned u);
    void        CreateActionBar();
    void        LoadErrorListBox();
    void        Color();
    unsigned    TextColor(int i, int& nstartchar, int& nendchar);
	unsigned	CommentColor(CString csphrase, int ncomloc, CString csline, 
							 int& nstartchar, int& nendchar) ;
	unsigned	KeywordColor(CString csphrase, int nkeyloc, CString csline, 
							 int& nstartchar, int& nendchar) ;
	bool		IsRECLineVisible(int nline = -1) ;
	static LPTSTR	alptstrStringIDKeys[] ;	// Keywords with string ID values
	static LPTSTR	alptstrUFMIDKeys[] ;	// Keywords with UFM ID values

protected: // create from serialization only
	CGPDViewer();
	DECLARE_DYNCREATE(CGPDViewer)

// Attributes
public:
    CGPDContainer*  GetDocument() { return (CGPDContainer *) m_pDocument; }

// Operations
public:
    void        UpdateNow();
	void		FreezeREC() ;
	void		UnfreezeREC() ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGPDViewer)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL
    virtual HRESULT QueryAcceptData(LPDATAOBJECT lpdo, CLIPFORMAT FAR *pcf,
        DWORD dwUnused, BOOL bReally, HGLOBAL hgMetaFile);

// Implementation
public:
	virtual ~CGPDViewer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    afx_msg void    OnSelChange(LPNMHDR pnmh, LRESULT *plr);
      
	// Generated message map functions
	//{{AFX_MSG(CGPDViewer)
	afx_msg void OnDestroy();
	afx_msg void OnFileParse();
	afx_msg void OnChange();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnVscroll();
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
	afx_msg void OnFileErrorLevel();
	afx_msg void OnGotoGPDLineNumber();
	afx_msg void OnSrchNextBtn();
	afx_msg void OnSrchPrevBtn();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnSelchangeErrorLst();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnEditEnableAids();
	afx_msg void OnEditPaste();
	afx_msg void OnEditCut();
	afx_msg void OnFileInf();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void ChangeSelectedError(int nchange) ;
	bool SearchTheREC(bool bforward) ; 
	int  ReverseSearchREC(CRichEditCtrl& crec, FINDTEXTEX& fte, int norgcpmin, 
						  int norgcpmax) ;
	bool GotoMatchingBrace() ;
	bool IsBraceToMatch(CString& cssel, TCHAR& chopen, TCHAR& chclose, 
						bool bchecksecondchar, bool& bsearchup, CHARRANGE cr, 
						int& noffset) ;
	void InitGPDKeywordArray() ;
} ;


#define	MIN_PARSER_VERBOSITY	0
#define	MAX_PARSER_VERBOSITY	4


/////////////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////////////
// CGotoLine dialog

class CGotoLine : public CDialog
{
	int		m_nMaxLine ;		// Maximum allowable line number
	int		m_nLineNum ;		// Line number entered by user

// Construction
public:
	CGotoLine(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGotoLine)
	enum { IDD = IDD_GotoLine };
	CEdit	m_ceGotoBox;
	CString	m_csLineNum;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGotoLine)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGotoLine)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void	SetMaxLine(int nmax) { m_nMaxLine = nmax ; }
	int 	GetMaxLine() { return m_nMaxLine ; }
	int 	GetLineNum() { return m_nLineNum ; }
};




/////////////////////////////////////////////////////////////////////////////
// CErrorLevel dialog

class CErrorLevel : public CDialog
{
// Construction
public:
	CErrorLevel(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CErrorLevel)
	enum { IDD = IDD_ErrorLevel };
	CComboBox	m_ccbErrorLevel;
	int		m_nErrorLevel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CErrorLevel)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CErrorLevel)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void	SetErrorLevel(int nerrlev) { m_nErrorLevel = nerrlev ; }
	int		GetErrorLevel() { return m_nErrorLevel ; }
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GPDVIEWER_H__1BDEA163_A492_11D0_9505_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gpdfile.h ===
/******************************************************************************

  Header File:  Model Data.H

  This defines a C++ class that manipulates (or at lest initially, understands)
  the GPC data file used in earlier versions of the Mini-Driver technology.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Resreved.

  A Pretty Penny Enterprises Production

  Change History:
  02-19-97  Bob_Kjelgaard@Prodgy.Net    Created it

******************************************************************************/

#if !defined(GPD_FILE_INFORMATION)
#define GPD_FILE_INFORMATION


class CStringTable ;


class COldMiniDriverData {      //  comdd
    CWordArray  m_cwaidModel;   //  Model names of the printers
    CWordArray  m_cwaidCTT;     //  Default CTTs for each model
    CByteArray  m_cbaImage;     //  Image of the GPC file
    CSafeObArray m_csoaFonts;   //  Font list per model as CWordArrays
	CUIntArray	m_cuaSplitCodes;//	Contains multiple GPC codes.  See
								//  SplitMultiGPCs() and SplitCodes.
	CStringArray m_csaSplitNames; // Correct model names for split GPC entries

public:
    COldMiniDriverData() {}
	~COldMiniDriverData() ;
    BOOL    Load(CFile& cfImage);

//  Attributes

    unsigned    ModelCount() { return (unsigned) m_cwaidModel.GetSize(); }
    WORD        ModelName(unsigned u) const { return m_cwaidModel[u]; }
    WORD        DefaultCTT(unsigned u) const { return m_cwaidCTT[u]; }
    CMapWordToDWord&    FontMap(unsigned u) const;
    PCSTR       Image() const { return (PCSTR) m_cbaImage.GetData(); }

	// The following codes are used to indicate if a GPC manages multiple
	// printer models so its "name" must split into individual model names
	// and its data copied into multiple GPCs.

	enum SplitCodes {
		NoSplit,		// GPC represents one model so no splitting occurs
		FirstSplit,		// First model of a multiple model GPC
		OtherSplit		// One of the other models of a multiple model GPC
	} ;

	// Get, set or insert a model's split code

	SplitCodes GetSplitCode(unsigned u) {
		return ((SplitCodes) m_cuaSplitCodes[u]) ;
	}
	void SetSplitCode(unsigned u, SplitCodes sc) {
		m_cuaSplitCodes[u] = (unsigned) sc ;
	}
	void InsertSplitCode(unsigned u, SplitCodes sc) {
		m_cuaSplitCodes.InsertAt(u, (unsigned) sc) ;
	}

	// Get a split entry's correct model name

	CString& SplitModelName(unsigned u) { return m_csaSplitNames[u] ; }

    //  Operations
    void    NoteTranslation(unsigned uModel, unsigned uFont,
        unsigned uNewFont);
	bool SplitMultiGPCs(CStringTable& cstdriversstrings) ;
};

/******************************************************************************

  CModelData class

  This class handles the model data in GPD format.

******************************************************************************/

class CModelData : public CProjectNode {
    CStringArray        m_csaGPD, m_csaConvertLog;  //  GPD and error log

    //  Private syntax checking support
    void                SetLog();
    void                EndLog();

    //  Private view support
    CByteArray  m_cbaBuffer;    // Stream I/O buffer
    CString     m_csBuffer;     // Stream I/O buffer (partial lines)
    int         m_iLine;		// Currently GPD line number to load/store
    static DWORD CALLBACK   FillViewer(DWORD_PTR dwCookie, LPBYTE lpBuff, LONG lcb,
                                       LONG *plcb);
    static DWORD CALLBACK   FromViewer(DWORD_PTR dwCookie, LPBYTE lpBuff, LONG lcb,
                                       LONG *plcb);
    DWORD Fill(LPBYTE lpBuff, LONG lcb, LONG *plcb);
    DWORD UpdateFrom(LPBYTE lpBuff, LONG lcb, LONG *plcb);

	// Workspace completeness and tidiness checking related variables

	bool				m_bTCUpdateNeeded ;	// True iff IDs need to be updated
	int*				m_pnUFMRCIDs ;		// Ptr to UFM RC IDs in the GPD
	int					m_nNumUFMsInGPD ;	// Number if UFMs in the GPD
	int*				m_pnStringRCIDs ;	// Ptr to string RC IDs in the GPD
	int					m_nNumStringsInGPD ;// Number if strings in the GPD
	PVOID				m_pvRawData ;		// Ptr to GPD Parser data

    DECLARE_SERIAL(CModelData)
public:
	void SetKeywordValue(CString csfile, CString csKeyword, CString csValue,bool bSource = false);
	CString GetKeywordValue(CString csfile, CString csKeyword);
	CModelData();
    ~CModelData();

    //  Attributes

    BOOL            HasErrors() const { return !!m_csaConvertLog.GetSize(); }
    unsigned        Errors() const {
        return (unsigned) m_csaConvertLog.GetSize();
    }
    const CString   Error(unsigned u) const { return m_csaConvertLog[u]; }
    const int       LineCount() const { return (int)m_csaGPD.GetSize(); }

    //  Operations - Document support

    BOOL    Load(PCSTR pcstr, CString csResource, unsigned uidModel,
                 CMapWordToDWord& cmw2dFontMap, WORD wfGPDConvert);
    BOOL    Load(CStdioFile& csiofGPD);
    BOOL    Load();
    BOOL    Store(LPCTSTR lpstrPath = NULL);
    BOOL    BkupStore();
    BOOL    Restore();
    void    UpdateEditor() {
        if  (m_pcmcwEdit)
            m_pcmcwEdit -> GetActiveDocument() -> UpdateAllViews(NULL);
    }

    //  Operations- syntax and error checking support

    BOOL    Parse(int nerrorlevel = 0);
    void    RemoveError(unsigned u);

    //  View support- it's easier done from here

    void    Fill(CRichEditCtrl& crec);
    void    UpdateFrom(CRichEditCtrl& crec);

    //  Framework support operations

    virtual CMDIChildWnd*   CreateEditor();
    virtual void            Import();
    virtual void            Serialize(CArchive& car);

	// Workspace completeness checking support routines

	bool		UpdateResIDs(bool bufmids) ;
	int			GetUFMRCID(unsigned urcidx) { return *(m_pnUFMRCIDs + urcidx) ; }
	int			GetStringRCID(unsigned urcidx) { return *(m_pnStringRCIDs + urcidx) ; }
	unsigned	NumUFMsInGPD() { return m_nNumUFMsInGPD ; }
	unsigned	NumStringsInGPD() { return m_nNumStringsInGPD ; }

	
};

/******************************************************************************

  CGPDContainer class

  This class, derived from CDocument, contains the contents of a single GPD
  file in a conatiner suitable for the MFC document/view architecture.

******************************************************************************/

class CGPDContainer : public CDocument {

    // TRUE iff the GPD Editor was started from the Workspace View.  FALSE if
	// the GPD Editor was started from the File Open command.

	BOOL        m_bEmbedded;

    CModelData  *m_pcmd;

protected:
	CGPDContainer();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CGPDContainer)

// Attributes
public:

    CModelData* ModelData() { return m_pcmd; }
	BOOL		GetEmbedded() { return m_bEmbedded ; }

// Operations
public:

    //  First a constructor for the Driver viewer to use to launch a GPD
    //  editor...

    CGPDContainer(CModelData *pcmd, CString csPath);

    void    OnFileSave() { CDocument::OnFileSave(); }
    void    OnFileSaveAs() { CDocument::OnFileSaveAs(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGPDContainer)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CGPDContainer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CGPDContainer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gtt.cpp ===
/******************************************************************************

  Source File:  Glyph Translation.CPP

  This implements the classes which encode glyph mapping information.

  Copyright (c) 1997 by Microsoft Corporation.  All rights reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-13-97  Bob_Kjelgaard@Prodigy.Net

******************************************************************************/

#include    "StdAfx.H"
#include    "Resource.H"

// Psuedo definition of DESIGNVECTOR.
#if (_WIN32_WINNT < 0x0500)
typedef unsigned long DESIGNVECTOR;
#endif

#include    "GTT.H"
#include    <CodePage.H>
#include    <wingdi.h>
#include    <winddi.h>
#include    <prntfont.h>
#include    <uni16res.h>
#define _FMNEWFM_H_
#include	"ProjRec.h"
#include    "ChildFrm.H"
#include    "GTTView.H"
#include    "minidev.h"

extern "C"
BOOL
BConvertCTT2GTT(
    IN     HANDLE             hHeap,
    IN     PTRANSTAB          pCTTData,
    IN     DWORD              dwCodePage,
    IN     WCHAR              wchFirst,
    IN     WCHAR              wchLast,
    IN     PBYTE              pCPSel,
    IN     PBYTE              pCPUnSel,
    IN OUT PUNI_GLYPHSETDATA *ppGlyphSetData,
    IN     DWORD              dwGlySize);

extern "C"
PUNI_GLYPHSETDATA
PGetDefaultGlyphset(
	IN		HANDLE		hHeap,
	IN		WORD		wFirstChar,
	IN		WORD		wLastChar,
	IN		DWORD		dwCodePage) ;

struct sRLE {
    enum {Direct = 10, Paired, LengthOffset, LengthIndexOffset, Offset};
    WORD    m_wFormat;
    WORD    m_widRLE;   //  Must have unique "magic" value 0x78FE
    DWORD   m_dwcbThis; //  Total size of the memory image.
    WCHAR   m_wcFirst, m_wcLast;
    //  Handle mapping data follows
    DWORD   m_dwcbImage;    //  Size of the handle mapping data only
    DWORD   m_dwFlag;
    DWORD   m_dwcGlyphs, m_dwcRuns;
};

union uencCTT {
    WORD    wOffset;
    BYTE    m_bDirect;      //  This member is used in GTT only!
    BYTE    abPaired[2];
};

struct sMapTableEntry {
    enum {Composed = 1, Direct = 2, Paired = 4, Format = 7, SingleByte,
            DoubleByte = 0x10, DBCS = 0x18, Replace = 0x20, Add = 0x40,
            Disable = 0x80, PredefinedMask = 0xE0};
    BYTE    m_bCodePageIndex, m_bfType;
    uencCTT m_uectt;
};

//  Since I don't build the map table in memory, there is no need to declare
//  the fact that the array of entries follows it
struct sMapTable {
    DWORD   m_dwcbImage, m_dwcEntries;
    sMapTable(unsigned ucEntries) {
        m_dwcbImage = sizeof *this + ucEntries * sizeof (sMapTableEntry);
        m_dwcEntries = ucEntries; }
};

//  Use a static for Code Page information- gets the max benefit from caching

static CCodePageInformation* pccpi = NULL ;                                //  Use a static CCodePageInformation to derive more benefit from caching

/******************************************************************************
    CInvocation class implementation

******************************************************************************/

IMPLEMENT_SERIAL(CInvocation, CObject, 0)

void    CInvocation::Encode(BYTE c, CString& cs) const {
    if  (isprint(c))
        if  (c != _TEXT('\\'))
            cs = c;
        else
            cs = _TEXT("\\\\");
    else
        cs.Format(_TEXT("\\x%2.2x"), c);
}

/******************************************************************************

  CInvocation::Init

  This copies a series of bytes into the invocation.  Since the data structures
  used to represent these lend themselves most readily to this, this is the
  normal method used in reading info from a file.

******************************************************************************/

void    CInvocation::Init(PBYTE pb, unsigned ucb) {
    m_cbaEncoding.RemoveAll();

    while   (ucb--)
        m_cbaEncoding.Add(*pb++);
}

void    CInvocation::GetInvocation(CString& cs) const {
    CString csWork;

    cs.Empty();
    for (int i = 0; i < m_cbaEncoding.GetSize(); i++) {
        Encode(m_cbaEncoding[i], csWork);
        cs += csWork;
    }
}

//  This member converts a C-Style encoding of an invocation into
//  byte form and stores it.

void    CInvocation::SetInvocation(LPCTSTR lpstrNew) {

    CString csWork(lpstrNew);

    m_cbaEncoding.RemoveAll();

    while   (!csWork.IsEmpty()) {
        CString csClean = csWork.SpanExcluding("\\");

        if  (!csClean.IsEmpty()) {
            for (int i = 0; i < csClean.GetLength(); i++)
                m_cbaEncoding.Add((BYTE) csClean[i]);
            csWork = csWork.Mid(csClean.GetLength());
            continue;
        }

		// A backslash has been found.  If the string ends with a backslash, we
		// can't let the function assert in the switch statement so just return
		// and ignore the terminating backslash.  Yes, I know the string is
		// invalid if it ends this way but, according to MS, this isn't a field
		// they want validated.

		if (csWork.GetLength() <= 1)
			return ;

        // OK, we have something to decode

        switch  (csWork[1]) {

            case    _TEXT('r'):
                m_cbaEncoding.Add(13);
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('n'):
                m_cbaEncoding.Add(10);
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('b'):
                m_cbaEncoding.Add('\b');
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('\t'):
                m_cbaEncoding.Add(9);
                csWork = csWork.Mid(2);
                continue;

            case    _TEXT('x'):
            case    _TEXT('X'):
                {

                    CString csNumber = csWork.Mid(2,2).SpanIncluding(
                        _TEXT("1234567890abcdefABCDEF"));

                    csWork = csWork.Mid(2 + csNumber.GetLength());
                    unsigned    u;

#if defined(UNICODE) || defined(_UNICODE)
#define _tsscanf    swscanf
#else
#define _tsscanf    sscanf
#endif

                    _tsscanf(csNumber, _TEXT("%x"), &u);
                    m_cbaEncoding.Add((BYTE)u);
                    continue;
                }

                //  TODO: octal encodings are pretty common

            default:
                m_cbaEncoding.Add(
                    (BYTE) csWork[(int)(csWork.GetLength() != 1)]);
                csWork = csWork.Mid(2);
                continue;
        }
    }

    //  We've done it!
}

//  This member function records the offset for its image (if any) and updates
//  the given offset to reflect this

void    CInvocation::NoteOffset(DWORD& dwOffset) {
    m_dwOffset = Length() ? dwOffset : 0;
    dwOffset += Length();
}

//  I/O routines, both native and document form

void    CInvocation::WriteSelf(CFile& cfTarget) const {
    DWORD   dwWork = Length();
    cfTarget.Write(&dwWork, sizeof dwWork);
    cfTarget.Write(&m_dwOffset, sizeof m_dwOffset);
}

void    CInvocation::WriteEncoding(CFile& cfTarget, BOOL bWriteLength) const {
    if  (bWriteLength) {
        WORD w = (WORD)Length();
        cfTarget.Write(&w, sizeof w);
    }

    cfTarget.Write(m_cbaEncoding.GetData(), Length());
}

void    CInvocation::Serialize(CArchive& car) {
    CObject::Serialize(car);
    m_cbaEncoding.Serialize(car);
}

/******************************************************************************
    CGlyphHandle class implementation

******************************************************************************/


CGlyphHandle::CGlyphHandle()
{
    m_wPredefined = m_wIndex = 0;
    m_dwCodePage = m_dwidCodePage = m_dwOffset = 0;

    // Allocate a CCodePageInformation class if needed.

    if (pccpi == NULL)
        pccpi = new CCodePageInformation ;
}


unsigned    CGlyphHandle::CompactSize() const {
    return  (m_ciEncoding.Length() < 3) ? 0 : m_ciEncoding.Length();
}

/******************************************************************************

  CGlyphHandle::operator ==

  Returns true if the encoding, code point, and code page IDs (but maybe not
  the indices) are the same.

******************************************************************************/

BOOL    CGlyphHandle::operator ==(CGlyphHandle& cghRef) {

    if  (cghRef.m_wCodePoint != m_wCodePoint ||
        cghRef.m_dwCodePage != m_dwCodePage ||
        m_ciEncoding.Length() != cghRef.m_ciEncoding.Length())
        return  FALSE;

    for (int i = 0; i < (int) m_ciEncoding.Length(); i++)
        if  (m_ciEncoding[i] != cghRef.m_ciEncoding[i])
            return  FALSE;

    return  TRUE;
}

/******************************************************************************

  CGlyphHandle::Init

  This function has three overloads, for intializing from direc, paired, or
  composed data.

******************************************************************************/

void    CGlyphHandle::Init(BYTE b, WORD wIndex, WORD wCode) {
    m_wIndex = wIndex;
    m_wCodePoint = wCode;
    m_ciEncoding.Init(&b, 1);
}

void    CGlyphHandle::Init(BYTE ab[2], WORD wIndex, WORD wCode) {
    m_wIndex = wIndex;
    m_wCodePoint = wCode;
    m_ciEncoding.Init(ab, 2);
}

void    CGlyphHandle::Init(PBYTE pb, unsigned ucb, WORD wIndex, WORD wCode) {
    m_wIndex = wIndex;
    m_wCodePoint = wCode;
    m_ciEncoding.Init(pb, ucb);
}

/******************************************************************************

  CGlyphHandle::operator =

  This is a copy (assignment) operator for the class.

******************************************************************************/

CGlyphHandle&   CGlyphHandle::operator =(CGlyphHandle& cghTemplate) {
    m_dwCodePage = cghTemplate.m_dwCodePage;
    m_dwidCodePage = cghTemplate.m_dwidCodePage;
    m_wCodePoint = cghTemplate.m_wCodePoint;
    m_ciEncoding = cghTemplate.m_ciEncoding;
    return  *this;
}

//  This member records the current offset for the data in RLE format, and
//  then updates it to account for the length of any data that will go into
//  the extra storage at the end of the file/

void    CGlyphHandle::RLEOffset(DWORD& dwOffset, const BOOL bCompact) {
    if  (m_ciEncoding.Length() < 3)
        return; //  Don't need it, and don't use it!

    m_dwOffset = dwOffset;

    dwOffset += bCompact ? CompactSize() : MaximumSize();
}

/******************************************************************************

  CGlyphHandle::GTTOffset

  This member records the current offset for where our data will go, then adds
  the length of the encoding string to it and updates the offset.  It will only
  be updated if the encoding must be composed data.  The encoding length
  includes a WORD length in the GTT world.  Data of 1 byte, or of 2 if DBCS or
  a Paired font, does not add any length.

******************************************************************************/

void    CGlyphHandle::GTTOffset(DWORD& dwOffset, BOOL bPaired) {
    if  (m_ciEncoding.Length() >
         (unsigned) 1 + (bPaired || pccpi->IsDBCS(m_dwCodePage))) {
        m_dwOffset = dwOffset;
        dwOffset += m_ciEncoding.Length() + sizeof m_wIndex;
    }
    else
        m_dwOffset = 0;
}

//  These members write our vital stuff to a given file.

void    CGlyphHandle::WriteRLE(CFile& cfTarget, WORD wFormat) const {
    //  This is the RLE-specific glyph handle encoding

    union {
        DWORD   dwOffset;
        struct {
            union   {
                struct {
                    BYTE    bFirst, bSecond;
                };
                WORD    wOffset;
            };
            union   {
                struct {
                    BYTE    bIndexOrHiOffset, bLength;
                };
                WORD    wIndex;
            };
        };
    };

    switch  (wFormat) {
        case    sRLE::Direct:
        case    sRLE::Paired:

            bFirst = m_ciEncoding[0];
            bSecond = m_ciEncoding[1];
            wIndex = m_wIndex;
            break;

        case    sRLE::LengthIndexOffset:

            if  (!CompactSize()) { //  Encode it in the first two bytes
                bFirst = m_ciEncoding[0];
                bSecond = m_ciEncoding[1];
            }
            else
                wOffset = (WORD) m_dwOffset;

            bIndexOrHiOffset = (BYTE) m_wIndex;
            bLength = (BYTE)m_ciEncoding.Length();
            break;

        case    sRLE::LengthOffset:

            if  (!CompactSize()) { //  Encode it in the first two bytes
                bFirst = m_ciEncoding[0];
                bSecond = m_ciEncoding[1];
                bIndexOrHiOffset = (BYTE) m_wIndex;
                bLength = (BYTE)m_ciEncoding.Length();
                break;
            }

            dwOffset = m_dwOffset;
            bLength = (BYTE)m_ciEncoding.Length();
            break;

        case    sRLE::Offset:
            dwOffset = m_dwOffset;
            break;

        default:
            _ASSERTE(FALSE);
            //  Should probably throw an exception...
    }

    cfTarget.Write(&dwOffset, sizeof dwOffset);
}

/******************************************************************************

  CGlyphHandle::WriteGTT

  This member function writes the GTT map table entry for this glyph in the
  requested format.

******************************************************************************/

static BYTE abFlags[] = {sMapTableEntry::Replace, sMapTableEntry::Add,
sMapTableEntry::Disable};

void    CGlyphHandle::WriteGTT(CFile& cfTarget, BOOL bPredefined) const {
    sMapTableEntry  smte;

    smte.m_bCodePageIndex = (bPredefined && m_wPredefined == Removed) ?
        0 : (BYTE) m_dwidCodePage;

    //  GTTOffset set m_dwOffset if Composed is needed.  Otherwise we can tell
    //  the proper flags by looking at the length and whether it is DBCS or not

    if  (m_dwOffset) {
        smte.m_uectt.wOffset = (WORD) m_dwOffset;
        smte.m_bfType = sMapTableEntry::Composed;
    }
    else {
        smte.m_bfType = pccpi->IsDBCS(m_dwCodePage) ?
            ((m_ciEncoding.Length() == 2) ?
            sMapTableEntry::Paired : sMapTableEntry::Direct ) |
            (pccpi->IsDBCS(m_dwCodePage, m_wCodePoint) ?
            sMapTableEntry::DoubleByte : sMapTableEntry::SingleByte) :
            (m_ciEncoding.Length() == 2) ?
            sMapTableEntry::Paired : sMapTableEntry::Direct;

        smte.m_uectt.abPaired[0] = m_ciEncoding[0];
        smte.m_uectt.abPaired[1] = m_ciEncoding[1];
    }

    if  (bPredefined)
        smte.m_bfType |= abFlags[m_wPredefined];

    //  Just write it out!
    cfTarget.Write(&smte, sizeof smte);
}

/******************************************************************************

  CGlyphHandle::WriteEncoding

  This method writes the encoding to to the file in the desired format.  The
  formats are:

  GTT- write nothing if not composed.  If composed, write the length, and then
  the encoding.

  RLESmall- just the encoding
  RLEBig- the index and the encoding.

******************************************************************************/

void    CGlyphHandle::WriteEncoding(CFile& cfTarget, WORD wfHow) const {
    if  (!m_dwOffset)
        return; //  Nothing to write

    if  (wfHow == RLEBig)
        cfTarget.Write(&m_wIndex, sizeof m_wIndex);

    m_ciEncoding.WriteEncoding(cfTarget, wfHow == GTT);

}

/******************************************************************************

  CRunRecord class implementation

******************************************************************************/

CRunRecord::CRunRecord(CGlyphHandle *pcgh, CRunRecord *pcrrPrevious) {
    m_wFirst = pcgh -> CodePoint();
    m_wcGlyphs = 1;
    m_dwOffset = 0;
    m_cpaGlyphs.Add(pcgh);

    //  Maintain that old double chain!

    m_pcrrPrevious = pcrrPrevious;
    m_pcrrNext = m_pcrrPrevious -> m_pcrrNext;
    m_pcrrPrevious -> m_pcrrNext = this;
    if  (m_pcrrNext)
        m_pcrrNext -> m_pcrrPrevious = this;
}

/******************************************************************************

  CRunRecord::CRunRecord(CRunRecord *pcrrPrevious, WORD wFirst)

  This private constructor is the second tail record initializer.  It is called
  when a run is split due to a glyph deletion.  In this case, we need to hook
  into the chain, then fill in the details from our predecessor.  wFirst tells
  us where to begin extracting data from said predecessor.

******************************************************************************/

CRunRecord::CRunRecord(CRunRecord* pcrrPrevious, WORD wFirst) {
    m_pcrrPrevious = pcrrPrevious;
    m_pcrrNext = pcrrPrevious -> m_pcrrNext;

    if  (m_pcrrNext)
        m_pcrrNext -> m_pcrrPrevious = this;
    m_pcrrPrevious -> m_pcrrNext = this;

    m_wFirst = m_wcGlyphs = 0;
    m_dwOffset = 0;

    //  That's the normal empty initialization.  Now, er fill ourselves from
    //  our predecessor

    for (; wFirst < pcrrPrevious -> Glyphs(); wFirst++)
        Add(&pcrrPrevious -> Glyph(wFirst));
}

/******************************************************************************

  CRunRecord::CRunRecord(CRunRecord *pcrrPrevious)

  This private constructor is the third and final tail record initializer.  It
  makes an exact duplicate of the previous record, then links itself into the
  chain appropriately.

  This constructor is necessary when a new code point is inserted ahead of the
  earliest code point in the set of run records without extending the first
  run.

******************************************************************************/

CRunRecord::CRunRecord(CRunRecord *pcrrPrevious) {
    m_wFirst = pcrrPrevious -> m_wFirst;
    m_wcGlyphs = pcrrPrevious -> m_wcGlyphs;
    m_pcrrNext = pcrrPrevious -> m_pcrrNext;
    m_pcrrPrevious = pcrrPrevious;
    m_pcrrPrevious -> m_pcrrNext = this;
    if  (m_pcrrNext)
        m_pcrrNext -> m_pcrrPrevious = this;
    m_cpaGlyphs.Copy(pcrrPrevious -> m_cpaGlyphs);
}

//  Initialize empty- this is used for the root record only

CRunRecord::CRunRecord() {
    m_wFirst = m_wcGlyphs = 0;
    m_dwOffset = 0;
    m_pcrrNext = m_pcrrPrevious = NULL;
}

CRunRecord::~CRunRecord() {
    if  (m_pcrrNext)
        delete  m_pcrrNext;
}

unsigned    CRunRecord::TotalGlyphs() const {
    return m_pcrrNext ?
        m_wcGlyphs + m_pcrrNext -> TotalGlyphs() : m_wcGlyphs;
}

BOOL    CRunRecord::MustCompose() const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        if  (GlyphData(u).CompactSize())
            return  TRUE;   //   No need to look further

    return  m_pcrrNext ? m_pcrrNext -> MustCompose() : FALSE;
}

unsigned    CRunRecord::ExtraNeeded(BOOL bCompact) {
    unsigned uNeeded = 0;

    for (unsigned u = 0; u < m_wcGlyphs; u++)
        uNeeded += bCompact ? Glyph(u).CompactSize() : Glyph(u).MaximumSize();

    return  uNeeded + (m_pcrrNext ? m_pcrrNext -> ExtraNeeded() : 0);
}

/******************************************************************************

  CRunRecord::GetGlyph()

  This returns the nth handle in the run.  We use recursion.  This could get
  bad enough in terms of performance (ony used to fill glyph map page in
  editor) that we drop it, but I'll try it first.

******************************************************************************/

CGlyphHandle*   CRunRecord::GetGlyph(unsigned u) const {

    if  (u < m_wcGlyphs)
        return  (CGlyphHandle *) m_cpaGlyphs[u];
    return  m_pcrrNext ? m_pcrrNext -> GetGlyph(u - m_wcGlyphs) : NULL;
}

/******************************************************************************

  CRunRecord::Add

  This member adds a glyph to the set of run records.  This can mean adding an
  additional record at the beginning or end of the set, extending an existing
  record at either the beginning or end, and in those cases, orentiay merging
  two records together.

******************************************************************************/

void    CRunRecord::Add(CGlyphHandle *pcgh) {
    WCHAR   wcNew = pcgh -> CodePoint();
    //  If the glyph is already in the run, just update the info on it.

    if  (m_wcGlyphs && wcNew >= m_wFirst && wcNew < m_wFirst + m_wcGlyphs){
        m_cpaGlyphs.SetAt(wcNew - m_wFirst, pcgh);
        return;
    }

    //  If this is the first record, and the glyph falls ahead of our first
    //  entry, we must clone ourselves, and become a one-glyph run.  We cannot
    //  insert a record in front of oursleves as we are embedded in the
    //  glyph map structure directly.

    if  (m_wcGlyphs && wcNew < m_wFirst - 1) {
        //  This can only happen to the first record- otherwise the tail logic
        //  below would prevent this occurence

        _ASSERTE(!m_pcrrPrevious);

        //  Clone us, using the copy contructor

        CRunRecord  *pcrr = new CRunRecord(this);

        m_wFirst = pcgh -> CodePoint();
        m_wcGlyphs = 1;
        m_cpaGlyphs.RemoveAll();
        m_cpaGlyphs.Add(pcgh);
        return;
    }

    if  (m_wcGlyphs && wcNew != m_wFirst + m_wcGlyphs &&
         wcNew != m_wFirst - 1) {

        //  This belongs in some other record- pass it down the line, or
        //  append a new one.

        if  (m_pcrrNext)
            //  If this falls ahead of the next record, we must insert one now

            if  (wcNew < m_pcrrNext -> m_wFirst - 1)
                m_pcrrNext = new CRunRecord(pcgh, this);
            else
                m_pcrrNext -> Add(pcgh);
        else
            m_pcrrNext = new CRunRecord(pcgh, this);
    }
    else {
        //  We're adding either at the front or the back, so do it right!
        if  (m_wFirst > wcNew) {
            m_cpaGlyphs.InsertAt(0, pcgh);
            m_wFirst = wcNew;
        }
        else
            m_cpaGlyphs.Add(pcgh);

        //  This belonged here, so add it in- the root record begins with
        //  0 glyphs, so if this is the first, keep track of it.

        if  (!m_wcGlyphs++)
            m_wFirst = wcNew;

        //  If there is a following run, see if we need to merge it.

        if  (m_pcrrNext &&
             m_pcrrNext -> m_wFirst == m_wFirst + m_wcGlyphs) {
            //  Merge the records.

            m_cpaGlyphs.Append(m_pcrrNext -> m_cpaGlyphs);
            m_wcGlyphs += m_pcrrNext -> m_wcGlyphs;

            //  Time to update the list.  The class destructor removes the
            //  tail records, so that pointer must be set to NULL before the
            //  merged record is deleted.

            CRunRecord *pcrrDead = m_pcrrNext;

            m_pcrrNext = m_pcrrNext -> m_pcrrNext;

            if  (m_pcrrNext)
                m_pcrrNext -> m_pcrrPrevious = this;

            pcrrDead -> m_pcrrNext = NULL;  //  Avoid destructor overkill
            pcrrDead -> m_wcGlyphs = 0;     //  Ditto
            delete  pcrrDead;
        }
    }
}

/******************************************************************************

  CRunRecord::Delete

  This member deletes a given glyph from the set of runs.  Deleting an entry is
  messy- it means splitting the record, unless we were so fortunate as to
  merely lop off one of the ends.

******************************************************************************/

void    CRunRecord::Delete(WORD wCodePoint) {
    //  If this isn't the right record, recurse or return as appropriate

    if  (wCodePoint < m_wFirst)
        return;

    if  (wCodePoint >= m_wFirst + m_wcGlyphs) {
        if  (m_pcrrNext)
            m_pcrrNext -> Delete(wCodePoint);
        return;
    }

    WORD    wIndex = wCodePoint - m_wFirst;

    //  Did we get lucky and hit the first or the last?

    if  (!wIndex || wIndex == -1 + m_wcGlyphs) {
        //  If there is only one entry in this run, kill it.

        if  (m_wcGlyphs == 1) {
            if  (m_pcrrPrevious) {    //  Not the first, then die!
                m_pcrrPrevious -> m_pcrrNext = m_pcrrNext;
                if  (m_pcrrNext)
                    m_pcrrNext -> m_pcrrPrevious = m_pcrrPrevious;
                m_pcrrNext = NULL;  //  We no longer have a follwing
                delete  this;
                return;             //  It is finished
            }

            //  We are the first.  If there's someone after us, get their stuff
            //  and make it ours- otherwise, zero everything.

            if  (m_pcrrNext) {
                m_cpaGlyphs.Copy(m_pcrrNext -> m_cpaGlyphs);
                m_wFirst = m_pcrrNext -> m_wFirst;
                m_wcGlyphs = m_pcrrNext -> m_wcGlyphs;
                CRunRecord *pcrrVictim = m_pcrrNext;
                m_pcrrNext = m_pcrrNext -> m_pcrrNext;
				if (m_pcrrNext)	// Raid 118880: BUG_BUG: m_pcrrNext become zero when deleted 1252 defalt with add code points
					m_pcrrNext -> m_pcrrPrevious = this;
                pcrrVictim -> m_pcrrNext = NULL;
                delete  pcrrVictim;
            }
            else {
                m_cpaGlyphs.RemoveAll();
                m_wFirst = m_wcGlyphs = 0;
            }
            m_dwOffset = 0;
            return;
        }

        //  OK, we can now kill the offending entry

        m_cpaGlyphs.RemoveAt(wIndex);
        m_wcGlyphs--;

        //  Yes, the following line is trick code.  It's good for the soul...
        m_wFirst += !wIndex;
        return; //  The glyph, she be toast.
    }

    //  Alas, this means we must split the record.

    //  Since this means a new one must be made, let a new constructor do
    //  most of the dirty work for us.

    m_pcrrNext = new CRunRecord(this, wIndex + 1);

    _ASSERTE(m_pcrrNext);   //  We lose that, we might as well die...

    //  Delete everything after the offending member

    m_cpaGlyphs.RemoveAt(wIndex, m_wcGlyphs - wIndex);

    //  Well, that about settles it, eh!
    m_wcGlyphs = wIndex;
}

/******************************************************************************

  CRunRecord::Empty

  This method will be called if the glyph map is being re-initialized.  We set
  everything back to its initial state, and delete any tail records.

******************************************************************************/

void    CRunRecord::Empty() {

    if  (m_pcrrNext)
        delete  m_pcrrNext;

    m_pcrrNext = 0;

    m_wFirst = m_wcGlyphs = 0;

    m_cpaGlyphs.RemoveAll();
}

/******************************************************************************

  CRunRecord::NoteOffset

  This routine is given an offset which is to be managed in the run- the
  management needed differs depending upon the file image being produced, so
  we use a parameter to describe the tyoe being output.

  In any event, the offset is passed by reference, and updated by each run
  record in the set, in turn.

******************************************************************************/

void    CRunRecord::NoteOffset(DWORD& dwOffset, BOOL bRLE, BOOL bPaired) {
    if  (bRLE) {
        m_dwOffset = dwOffset;
        dwOffset += m_wcGlyphs *
            ((CGlyphHandle *) m_cpaGlyphs[0]) -> RLESize();
    }
    else
        for (unsigned u = 0; u < Glyphs(); u++)
            Glyph(u).GTTOffset(dwOffset, bPaired);

    //  Recurse if there's more...
    if  (m_pcrrNext)
        m_pcrrNext -> NoteOffset(dwOffset, bRLE, bPaired);
}

//  This routine passes a DWORD to each glyph handle denoting where it can
//  store its extra data.  Each updates the offset, if necessary.

//  We then recursively call each descendant to do the same thing.

void    CRunRecord::NoteExtraOffset(DWORD &dwOffset, const BOOL bCompact) {

    for (unsigned u = 0; u < m_wcGlyphs; u++)
        Glyph(u).RLEOffset(dwOffset, bCompact);

    if  (m_pcrrNext)
        m_pcrrNext -> NoteExtraOffset(dwOffset, bCompact);
}

//  File output functions-  These are all basically recursive.  The callee does
//  its thing, then passes it on down the chain.  Since this is the order RLE
//  and GTT are written in, everything is fine.

void    CRunRecord::WriteSelf(CFile& cfTarget, BOOL bRLE) const {
    cfTarget.Write(this, Size(bRLE));
    if  (m_pcrrNext)
        m_pcrrNext -> WriteSelf(cfTarget, bRLE);
}

void    CRunRecord::WriteHandles(CFile& cfTarget, WORD wFormat) const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        GlyphData(u).WriteRLE(cfTarget, wFormat);

    if  (m_pcrrNext)
        m_pcrrNext -> WriteHandles(cfTarget, wFormat);
}

//  Member for writing the total set of GTT Map Table Entries

void    CRunRecord::WriteMapTable(CFile& cfTarget, BOOL bPredefined) const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        GlyphData(u).WriteGTT(cfTarget, bPredefined);

    if  (m_pcrrNext)
        m_pcrrNext -> WriteMapTable(cfTarget, bPredefined);
}

/******************************************************************************

  CRunRecord::WriteEncodings

  This calls each glyph in the run record in ascending order to have it write
  its encoding into the file in the given format.  It then recursively calls
  the next run record.

******************************************************************************/

void    CRunRecord::WriteEncodings(CFile& cfTarget, WORD wfHow) const {
    for (unsigned u = 0; u < m_wcGlyphs; u++)
        GlyphData(u).WriteEncoding(cfTarget, wfHow);

    if  (m_pcrrNext)
        m_pcrrNext -> WriteEncodings(cfTarget, wfHow);
}

/******************************************************************************

  CCodePageData class implementation

******************************************************************************/

/******************************************************************************

  CCodePageData::Invocation

  This member function returns (in C-style string declaration form) the data to
  send to the printer to perform the requested select/deselect of this code
  page.

******************************************************************************/

void    CCodePageData::Invocation(CString& csReturn, BOOL bSelect) const {
    if  (bSelect)
        m_ciSelect.GetInvocation(csReturn);
    else
        m_ciDeselect.GetInvocation(csReturn);
}

/******************************************************************************

  CCodePageData::SetInvocation(LPCTSTR lpstrInvoke, BOOL bSelect)

  This member function sets the select or deselect sring using a string which
  is decoded as a C-style string declaration.

******************************************************************************/

void    CCodePageData::SetInvocation(LPCTSTR lpstrInvoke, BOOL bSelect) {

    if  (bSelect)
        m_ciSelect.SetInvocation(lpstrInvoke);
    else
        m_ciDeselect.SetInvocation(lpstrInvoke);
}

/******************************************************************************

  CCodePageData::SetInvocation(PBYTE pb, unsigned ucb, BOOL bSelect)

  This member function initializes one of the two CInvocation members via its
  Init function.

******************************************************************************/

void    CCodePageData::SetInvocation(PBYTE pb, unsigned ucb, BOOL bSelect) {
    if  (bSelect)
        m_ciSelect.Init(pb, ucb);
    else
        m_ciDeselect.Init(pb, ucb);
}

/******************************************************************************

  CCodePageData::NoteOffsets

  This member function is passed an offset at which it will record its
  invocation strings.  It simply funnels the call to each invocation member,
  which updates the value as appropriate.

******************************************************************************/

void    CCodePageData::NoteOffsets(DWORD& dwOffset) {
    m_ciSelect.NoteOffset(dwOffset);
    m_ciDeselect.NoteOffset(dwOffset);
}

//  Write the id and invocation location information to the file

void    CCodePageData::WriteSelf(CFile& cfTarget) {
    cfTarget.Write(&m_dwid, sizeof m_dwid);
    m_ciSelect.WriteSelf(cfTarget);
    m_ciDeselect.WriteSelf(cfTarget);
}

//  Write the invocation strings to a file.

void    CCodePageData::WriteInvocation(CFile& cfTarget) {
    m_ciSelect.WriteEncoding(cfTarget);
    m_ciDeselect.WriteEncoding(cfTarget);
}

/******************************************************************************

  CGlyphMap class implementation

******************************************************************************/

IMPLEMENT_SERIAL(CGlyphMap, CProjectNode, 0)

//  The GTT header

struct sGTTHeader {
    DWORD   m_dwcbImage;
    enum    {Version1Point0 = 0x10000};
    DWORD   m_dwVersion;
    DWORD   m_dwfControl;   //  Any flags defined?
    long    m_lidPredefined;
    DWORD   m_dwcGlyphs;
    DWORD   m_dwcRuns;
    DWORD   m_dwofRuns;
    DWORD   m_dwcCodePages;
    DWORD   m_dwofCodePages;
    DWORD   m_dwofMapTable;
    DWORD   m_dwReserved[2];
    sGTTHeader() {
        memset(this, 0, sizeof *this);
        m_dwVersion = Version1Point0;
        m_lidPredefined = CGlyphMap::NoPredefined;
        m_dwcbImage = sizeof *this;
    }
};

CSafeMapWordToOb    CGlyphMap::m_csmw2oPredefined;

/******************************************************************************

  CGlyphMap::Public

  This is a static member function which will return a pointer to one of the
  predefined GTT files, after loading it if necessary.

******************************************************************************/

CGlyphMap* CGlyphMap::Public(WORD wID, WORD wCP/*= 0*/, DWORD dwDefCP/*= 0*/,
							 WORD wFirst/*= 0*/, WORD wLast/*= 255*/)
{
	//TRACE("***  First char = %d\t\tLast char = %d\n", wFirst, wLast) ;
	
	// If a GTT in this driver is needed, return NULL to force the
	// program to go get it.

	if (((short) wID) > 0)
		return NULL ;

	// If no GTT ID is set, use the code page that is passed in.  If no code
	// page is passed in, use the project's default code page.  If there is
	// no project, use 1252 as the default code page.

	if (wID == 0)
		if ((wID = wCP) == 0)
			if ((wID = (WORD) dwDefCP) == 0)
				wID = 1252 ;

	// Check to see if wID is set to one of the Far East codepages that are 
	// built into the MDT.  If that is the case, change it to the resource ID
	// for that code page.

	switch (wID) {
		case 932:
			wID = -17 ;
			break ;
		case 936:
			wID = -16 ;
			break ;
		case 949:
			wID = -18 ;
			break ;
		case 950:
			wID = -10 ;
			break ;
	} ;

	// If the ID is 1252, switch to the resource ID for CP 1252.

	if (wID == 1252)
		wID = -IDR_CP1252 ;

    // The easy part comes if it is already loaded

    CObject*    pco ;
    if  (m_csmw2oPredefined.Lookup(wID, pco))
        return  (CGlyphMap*) pco ;

    //// DEAD_BUG - The program can't load huge GTTs so just return NULL.
    //
    //if ((short) wID >= -18 || (short) wID <= -10)
    //    return NULL ;

    // Manage loading a predefined code page or building a GTT based on a code
	// page.  Begin by declaring/initializing a class instance for it.

    CGlyphMap *pcgm = new CGlyphMap ;
	TCHAR acbuf[32] ;
    if (FindResource(AfxGetResourceHandle(),
					 MAKEINTRESOURCE((((short) wID) < 0) ? -(short) wID : wID),
					 MAKEINTRESOURCE(IDR_GLYPHMAP)))
		pcgm->m_csName.LoadString(IDS_DefaultPage + wID) ;
	else {
		strcpy(acbuf, _T("CP ")) ;
		_itoa(wID, &acbuf[3], 10) ;
		pcgm->m_csName = acbuf ;
	} ;
    pcgm->nSetRCID((int) wID) ;
	pcgm->m_wFirstChar = wFirst ;
	pcgm->m_wLastChar = wLast ;
	pcgm->m_bResBldGTT = true ;

	// Load/build the GTT.  If this works, add it to the list of "predefined"
	// GTTs and return a pointer to it.

    if  (pcgm->Load()) {
        m_csmw2oPredefined[wID] = pcgm ;
        return pcgm ;
    } ;

	// Clean up and return NULL if the load/build fails.

    delete pcgm ;
    return NULL ;
}

/******************************************************************************

  CGlyphMap::MergePredefined

  This merges in fresh glyph handles from the predefined GTT, then removes all
  glyphs destined for the gallows.

******************************************************************************/

void    CGlyphMap::MergePredefined() {
    if  (m_lidPredefined == NoPredefined)
        return;

    CWaitCursor cwc;    //  This takes a long time, I'll bet!

    CGlyphMap   *pcgm = Public((WORD) m_lidPredefined);

    if  (!pcgm)
        AfxThrowNotSupportedException();

    //  First, add any new code pages in the predefined GTT
    CMapWordToDWord cmw2dPageMap;   //  Map PDT code pages' indices to our own

    for (unsigned u = 0; u < pcgm -> CodePages(); u++) {
        for (unsigned u2 = 0; u2 < CodePages(); u2++)
            if  (PageID(u2) == pcgm -> PageID(u))
                break;

            if  (u2 == CodePages())
                AddCodePage(pcgm -> PageID(u));

            cmw2dPageMap[(WORD)u] = u2;
    }

    CPtrArray   cpaTemplate;
    pcgm -> Collect(cpaTemplate);

    for (int i = 0; i < cpaTemplate.GetSize(); i++) {
        CGlyphHandle&   cghTemplate = *(CGlyphHandle *) cpaTemplate[i];
        CObject*    pco;

        if  (!m_csmw2oEncodings.Lookup(cghTemplate.CodePoint(), pco)) {
            //  Add this one, and map the code page info.
            CGlyphHandle*   pcgh = new CGlyphHandle;
            if  (!pcgh)
                AfxThrowMemoryException();

            *pcgh = cghTemplate;
            pcgh -> SetCodePage(cmw2dPageMap[(WORD)cghTemplate.CodePage()],
                pcgm -> PageID(cghTemplate.CodePage()));

            m_csmw2oEncodings[cghTemplate.CodePoint()] = pcgh;
            m_crr.Add(pcgh);
        }
    }

    //  Now, all of the new pages have been added.  We must remove all points
    //  listed as "Remove".

    Collect(cpaTemplate);   //  Get all of the handles for ourselves

    for (i = (int)cpaTemplate.GetSize(); i--; ) {
        CGlyphHandle&   cgh = *(CGlyphHandle *) cpaTemplate[i];

        if  (cgh.Predefined() == CGlyphHandle::Removed)
            DeleteGlyph(cgh.CodePoint());
    }
}

/******************************************************************************

  CGlyphMap::UnmergePredefined

  This is the harder of the two predfined handlers, if that is conceivable.
  First (unless asked not to), glkyphs must be added to mark those missing from
  the predefined GTT.

  Then, the entire set is compared to the PDT, so they can be removed as
  equivalent, or flagged as added or modified.

******************************************************************************/

void    CGlyphMap::UnmergePredefined(BOOL bTrackRemovals) {
    if  (m_lidPredefined == NoPredefined)
        return;

    CWaitCursor cwc;    //  This takes a long time, I'll bet!

    CGlyphMap   *pcgm = Public((WORD) m_lidPredefined);

    if  (!pcgm)
        AfxThrowNotSupportedException();

    CPtrArray   cpaPDT;

    if  (bTrackRemovals) {
        pcgm -> Collect(cpaPDT);

        for (int i = 0; i < cpaPDT.GetSize(); i++) {
            CGlyphHandle&   cgh = *(CGlyphHandle*) cpaPDT[i];

            CObject*    pco;

            if  (m_csmw2oEncodings.Lookup(cgh.CodePoint(), pco))
                continue;

            //  This point was removed from the predefined set, so add it to
            //  ours, and mark it as such.

            CGlyphHandle    *pcghCorpse = new CGlyphHandle();

            if  (!pcghCorpse)
                AfxThrowMemoryException();

            *pcghCorpse = cgh;

            pcghCorpse -> SetPredefined(CGlyphHandle::Removed);

            m_csmw2oEncodings[cgh.CodePoint()] = pcghCorpse;
            m_crr.Add(pcghCorpse);
        }
    }

    //  Mark all of the glyphs in our set, now.  Also mark the code pages used

    Collect(cpaPDT);

    CMapWordToDWord cmw2dPages;

    for (int i = (int)cpaPDT.GetSize(); i--; ) {
        CGlyphHandle&   cgh = *(CGlyphHandle*) cpaPDT[i];

        union {
            CObject         *pco;
            CGlyphHandle    *pcgh;
        };

        if  (pcgm -> m_csmw2oEncodings.Lookup(cgh.CodePoint(), pco))
            if  (*pcgh == cgh) {
                if  (cgh.Predefined() == CGlyphHandle::Removed)
                    continue;   //  Already accounted for

                if  (m_bPaired != pcgm -> m_bPaired && cgh.PairedRelevant())
                    cgh.SetPredefined(CGlyphHandle::Modified);
                else {
                    DeleteGlyph(cgh.CodePoint());    //  Unmodified
                    continue;
                }
            }
            else
                cgh.SetPredefined(CGlyphHandle::Modified);
        else
            cgh.SetPredefined(CGlyphHandle::Added);

        cmw2dPages[(WORD)PageID(cgh.CodePage())]++;   //  Only track these pages
    }

    //  Remove the unused code pages, unless they have selections

    for (unsigned u = CodePages(); u--; )
        if  (!cmw2dPages[(WORD)PageID(u)])
            if  (CodePage(u).NoInvocation())
                RemovePage(u, !u);
}

/******************************************************************************

  CGlyphMap::GenerateRuns

  This member will create the run records by iterating over the mapped glyph
  handles.

******************************************************************************/

void    CGlyphMap::GenerateRuns() {
    if  (m_crr.TotalGlyphs() == Glyphs())
        return;

    for (POSITION pos = m_csmw2oEncodings.GetStartPosition(); pos;) {
        WORD    wValue;
        union {
            CObject     *pco;
            CGlyphHandle    *pcgh;
        };

        m_csmw2oEncodings.GetNextAssoc(pos, wValue, pco);
        m_crr.Add(pcgh);
    }
}

/******************************************************************************

  CGlyphMap::Serialize

  This member function serializes the Glyph map, i.e., loads or stores it into
  a persistent object store.  Only the project-level information is stored.

  The file will be loaded using the project-level data.

  Note:	There was a second copy of the GTT's RC ID saved in the MDW file.
		Because it could get out of sync with the one in the CGlyphMap's
		CRCIDNode instance, the copy of the ID read/written by this routine
		is no longer used.  A bogus value is written and the number read is
		discarded.  This "ID" is still kept in the MDW file so that no new MDW
		version is needed.

******************************************************************************/

void    CGlyphMap::Serialize(CArchive& car) 
{
	WORD	w = (WORD)0;		// Used to read/write bogus RC ID in MDW file.

    CProjectNode::Serialize(car) ;

    if  (car.IsLoading()) {
        car >> w ;
    }
    else {
        car << w ;
    }
}

/******************************************************************************

  CGlyphMap::CGlyphMap

  The class constructor, in addition to setting some default values, builds an
  array of IDs for the CProjectNode class from which it is derived to use in
  building the context menu in the driver/project view tree.

  It also allocates a single code page record for the current ANSI page, so we
  always have a default page.

******************************************************************************/

CGlyphMap::CGlyphMap() {
    m_cfn.SetExtension(_T(".GTT"));
    m_bPaired = FALSE;
    m_lidPredefined = NoPredefined;

    //  Build the context menu control
    m_cwaMenuID.Add(ID_OpenItem);
    m_cwaMenuID.Add(ID_CopyItem);
    m_cwaMenuID.Add(ID_RenameItem);
    m_cwaMenuID.Add(ID_DeleteItem);
    m_cwaMenuID.Add(0);
    m_cwaMenuID.Add(ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);
    //m_cwaMenuID.Add(0);
    //m_cwaMenuID.Add(ID_GenerateOne);

    //  Initialy, let the default code page be the current ANSI page, if this
    //  is not a DBCS locale.  Otherwise, use 1252, as no DBCS CTT file can be
    //  generated with UniTool
    for (WORD w = 0; w < 256; w++)
        if  (IsDBCSLeadByte((BYTE) w))
            break;
    m_csoaCodePage.Add(new CCodePageData(w < 256 ? 1252 : GetACP()));

    // Allocate a CCodePageInformation class if needed.

    if (pccpi == NULL)
        pccpi = new CCodePageInformation ;

	// Assume that the GTT's data should be read from a file.

	m_bResBldGTT = false ;

	m_ctSaveTimeStamp = (time_t) 0 ;	// The GTT has not been saved
}

/******************************************************************************

  CGlyphMap::CodePages(CDWordArray &cdaReturn)

  This overload fills a DWordArray with the code page IDs.

******************************************************************************/

void    CGlyphMap::CodePages(CDWordArray &cdaReturn) const {
    cdaReturn.RemoveAll();
    for (unsigned u = 0; u < CodePages(); u++)
        cdaReturn.Add(CodePage(u).Page());
}

/******************************************************************************

  CGlyphMap::PageName


  This member returns the name of a particular code page, by index.

******************************************************************************/

CString CGlyphMap::PageName(unsigned u) const {
    return  pccpi->Name(CodePage(u).Page());
}

/******************************************************************************

  CGlyphMap::Invocation

  This member returns (in C-style encoding) a string which is used to either
  select or deselect a given code page.

******************************************************************************/

void    CGlyphMap::Invocation(unsigned u, CString& csReturn,
                              BOOL bSelect) const {
    CodePage(u).Invocation(csReturn, bSelect);
}

/******************************************************************************

  CGlyphMap::UndefinedPoints

  This member fills a map with all code points NOT in the current mapping, and
  maps them to their related code pages.  Thus only translatable points will be
  passed back to the caller.

******************************************************************************/

void    CGlyphMap::UndefinedPoints(CMapWordToDWord& cmw2dCollector) const {

    cmw2dCollector.RemoveAll();

    CWaitCursor cwc;

    for (unsigned u = 0; u < CodePages(); u++) {
        CWordArray  cwaPage;

        //  Collect the code points in the code page

        pccpi->Collect(PageID(u), cwaPage);
        union {
            CObject *pco;
            DWORD   dw;
        };

        //  Check the entries- if they haven't been mapped yet, and
        //  some earlier code page hasn't claimed them, add them.

        for (int i = 0; i < cwaPage.GetSize(); i++)
            if  (!m_csmw2oEncodings.Lookup(cwaPage[i], pco) &&
                 !cmw2dCollector.Lookup(cwaPage[i], dw))
                 cmw2dCollector[cwaPage[i]] = u;
    }
}

/******************************************************************************

  CGlyphMap::Load(CByteArray& cbaMap)

  This loads an image of a GTT into safe memory, whether it is predefined or
  a file.

******************************************************************************/

//void    CGlyphMap::Load(CByteArray& cbaMap) const 
void    CGlyphMap::Load(CByteArray& cbaMap)
{
	short	xxx = (short) ((CProjectNode*) this)->nGetRCID() ;	// The GTT's RC ID
	short	sid = (short) nGetRCID() ;	// The GTT's RC ID

    try {
		// Try to load the GTT from a file when the GTT should not be loaded
		// from a resource or built.

        if  (!m_bResBldGTT 
		 && (sid > 0 || (sid < Wansung && sid != -IDR_CP1252))) {
            CFile   cfGTT(m_cfn.FullName(),
            CFile::modeRead | CFile::shareDenyWrite);

            cbaMap.SetSize(cfGTT.GetLength());
            cfGTT.Read(cbaMap.GetData(), (unsigned)cbaMap.GetSize());
            return;
        } ;

		// If the GTT is a resource, load it from there.
// raid 441362
		if(MAKEINTRESOURCE((sid < 0) ? -sid : sid) == NULL)
			return;

        HRSRC hrsrc = FindResource(AfxGetResourceHandle(),
            MAKEINTRESOURCE((sid < 0) ? -sid : sid),
            MAKEINTRESOURCE(IDR_GLYPHMAP));
        if  (hrsrc) {
			HGLOBAL hg = LoadResource(AfxGetResourceHandle(), hrsrc) ;
			if  (!hg)
				return ;
			LPVOID  lpv = LockResource(hg) ;
			if  (!lpv)
				return ;
			cbaMap.SetSize(SizeofResource(AfxGetResourceHandle(), hrsrc)) ;
			memcpy(cbaMap.GetData(), lpv, (size_t)cbaMap.GetSize()) ;
			return ;
		} ;

		//AfxMessageBox("GTT building code reached.") ;

		// If all else fails, try to generate a GTT based on the code page ID
		// that should be in m_wID if this point is reached.

        HANDLE   hheap ;
        UNI_GLYPHSETDATA *pGTT ;
        if (!(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024))) {
			AfxMessageBox(IDS_HeapInGLoad) ;
			return ;
		} ;
		pGTT = PGetDefaultGlyphset(hheap, m_wFirstChar, m_wLastChar,
								   (DWORD) sid) ;
		if (pGTT == NULL) {
			HeapDestroy(hheap) ;		//raid 116600 Prefix
			AfxMessageBox(IDS_PGetFailedInGLoad) ;
			return ;
		} ;
		cbaMap.SetSize(pGTT->dwSize) ;
		memcpy(cbaMap.GetData(), pGTT, (size_t)cbaMap.GetSize()) ;
		HeapDestroy(hheap) ;
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        CString csMessage;
        csMessage.Format(IDS_LoadFailure, Name());
        AfxMessageBox(csMessage);
    }
}

/******************************************************************************

  CGlyphmap::SetSourceName

  This takes and stores the source file name so we can load and convert later.
  It also renames (or rather, sets the original name) for the GlyphMap using
  the base file name.

******************************************************************************/

void    CGlyphMap::SetSourceName(LPCTSTR lpstrNew) {
    m_csSource = lpstrNew;

    m_csName = m_csSource.Mid(m_csSource.ReverseFind(_T('\\')) + 1);

    if  (m_csName.Find(_T('.')) >= 0)
        if  (m_csName.Right(4).CompareNoCase(_T(".CTT"))) {
            m_csName.SetAt(m_csName.Find(_T('.')), _T('_'));
            CProjectNode::Rename(m_csName);
        }
        else
            CProjectNode::Rename(m_csName.Left(m_csName.Find(_T('.'))));
    else
        CProjectNode::Rename(m_csName);
}


/******************************************************************************

  CGlyphMap::SetFileName

  This sets the new file name.  It is done differently than in SetSourceName()
  because the base file name must not be more than 8 characters long.  (The
  extra info is left in the node name by SetSourceName() because it is useful
  there and it has no length limit.)

******************************************************************************/

BOOL CGlyphMap::SetFileName(LPCTSTR lpstrNew)
{
    CString        csnew ;            // CString version of input parameter

    csnew = lpstrNew ;

    // If the input filespec contains an extension, remove it and pass the
    // resulting string to the file node's rename routine.  Otherwise, just
    // pass the original string to the rename routine.
    //
    // This check is complicated by the fact that one of the path components
    // might have a dot in it too.  We need to check for the last dot and make
    // sure it comes before a path separator.

    if  (csnew.ReverseFind(_T('.')) > csnew.ReverseFind(_T('\\')))
        return m_cfn.Rename(csnew.Left(csnew.ReverseFind(_T('.')))) ;
    else
        return m_cfn.Rename(csnew) ;
}


/******************************************************************************

  CGlyphMap::AddPoints

  This member adds one or more code points to the glyph map using the given
  list of points and associated pages.

******************************************************************************/

void    CGlyphMap::AddPoints(CMapWordToDWord& cmw2dNew) {
    WORD        wKey;
    DWORD       dwixPage;
    CWaitCursor cwc;        //  This could be slow!

    for (POSITION pos = cmw2dNew.GetStartPosition(); pos; ) {
        cmw2dNew.GetNextAssoc(pos, wKey, dwixPage);

        //  Get the MBCS encoding of the Unicode point as the initial
        //  glyph encoding.

        CWordArray  cwaIn;
        CByteArray  cbaOut;

        cwaIn.Add(wKey);
        pccpi->Convert(cbaOut, cwaIn, CodePage(dwixPage).Page());

        //  Create the glyph and add it to the map

        CGlyphHandle    *pcgh = new CGlyphHandle;

        pcgh -> Init(cbaOut.GetData(), (unsigned) cbaOut.GetSize(), (WORD)Glyphs(),
            wKey);
        pcgh -> SetCodePage(dwixPage, CodePage(dwixPage).Page());
        m_csmw2oEncodings[wKey] = pcgh;
        m_crr.Add(pcgh);
    }
    Changed();  //  Don't forget to tell the container!
}

/******************************************************************************

  CGlyphMap::DeleteGlyph

  This member function removes a glyph from the map.  The most tricky part is
  updating the run records, but that's not this class' responsibility, is it?

******************************************************************************/

void    CGlyphMap::DeleteGlyph(WORD wCodePoint) {
    if  (!m_csmw2oEncodings.RemoveKey(wCodePoint))
        return;     //  This glyph is already toast!

    m_crr.Delete(wCodePoint);
    Changed();
}

/******************************************************************************

  CGlyphMap::RemovePage

  This member function removes a code page from the list of available pages.
  Glyphs that used this page will be remapped to a second specified page.

******************************************************************************/

BOOL    CGlyphMap::RemovePage(unsigned uPage, unsigned uMapTo, bool bDelete /* bDelete = FALSE */) {

     if  (uPage >= CodePages() || uMapTo >= CodePages())
        return  FALSE;

    //  Pretty simple- walk the map- first replace any instances, then
    //  decrement any indices higher than uPage

    WORD    wKey;

    union {
        CObject*        pco;
        CGlyphHandle*   pcgh;
    };

    for (POSITION pos = m_csmw2oEncodings.GetStartPosition(); pos; ) {

        m_csmw2oEncodings.GetNextAssoc(pos, wKey, pco);
		if (!bDelete){	 
			if  (pcgh -> CodePage() == uPage)
				pcgh -> SetCodePage(uMapTo, CodePage(uMapTo).Page());
			if  (pcgh -> CodePage() > uPage)
				pcgh -> SetCodePage(pcgh -> CodePage() - 1,
					CodePage(pcgh -> CodePage()).Page());
		}	
		else {   // raid 118880
		if (pcgh -> CodePage() == uPage)
			DeleteGlyph(pcgh -> CodePoint() ) ;  // delete m_csm2oEncodings, RunRecord
		    
		else if (pcgh -> CodePage() > uPage)
            pcgh -> SetCodePage(pcgh -> CodePage() - 1,
                CodePage(pcgh -> CodePage()).Page());
		}

    }

    m_csoaCodePage.RemoveAt(uPage);

	// Marke the GTT as dirty and then return success.
	Changed();
    return  TRUE;
}

/******************************************************************************

  CGlyphMap::ChangeCodePage

  This member function changes the code page for one ore more glyphs to a
  different page.  At one time I thought remapping the code points would be
  required, but currently, the Unicode stays intact.  That seems a good feature
  for demand-driven implementation.

******************************************************************************/

//  This one changes the code page for one or more glyphs.
//  For now, we will simply keep the Unicode intact.  Eventually, a query
//  should be made about the intent, so we can remap through the existing
//  page, if that is what is desired.

void    CGlyphMap::ChangeCodePage(CPtrArray& cpaGlyphs, DWORD dwidNewPage) {
    for (unsigned u = 0; u < CodePages(); u++)
        if  (dwidNewPage == CodePage(u).Page())
            break;

    _ASSERTE(u < CodePages());

    if  (u >= CodePages())
        return;

    for (int i = 0; i < cpaGlyphs.GetSize(); i++)
        ((CGlyphHandle *) cpaGlyphs[i]) -> SetCodePage(u, dwidNewPage);

    Changed();
}

/******************************************************************************

  CGlyphMap::AddCodePage

  This member function adds a new code page to the list of pages used in this
  table.

******************************************************************************/

void    CGlyphMap::AddCodePage(DWORD dwidNewPage) {
    m_csoaCodePage.Add(new CCodePageData(dwidNewPage));
    Changed();
}

/******************************************************************************

  CGlyphMap::SetPredefinedID

  This changes the predefined table used by the map.  If it really is a change,
  we must remove all non-modified points from any existing map, and then flesh
  out using the new one.

******************************************************************************/

void    CGlyphMap::UsePredefined(long lidNew) {
    if  (m_lidPredefined == lidNew)
        return; //  Didn't need to do this!

    if  (m_lidPredefined != NoPredefined)
        UnmergePredefined(lidNew != NoPredefined);

    m_lidPredefined = lidNew;

    if  (m_lidPredefined != NoPredefined)
        MergePredefined();

    Changed();
}

/******************************************************************************

  CGlyphMap::SetInvocation

  This member changes the invocation string for selecting or unselecting a
  given code page.

******************************************************************************/

void    CGlyphMap::SetInvocation(unsigned u, LPCTSTR lpstrInvoke,
                                 BOOL bSelect) {
    CodePage(u).SetInvocation(lpstrInvoke, bSelect);
    Changed();
}

/******************************************************************************

  CGlyphMap::ChangeEncoding

  This member is called when the user changes the encoding string used to
  invoke a given code point.  This could be done via the glyph, but then the
  containing document won't know of the change, and thus the change could be
  inadvertently lost...

******************************************************************************/

void    CGlyphMap::ChangeEncoding(WORD wCodePoint, LPCTSTR lpstrNewInvoke) {

    union {
        CObject         *pco;
        CGlyphHandle    *pcgh;
    };

    if  (!m_csmw2oEncodings.Lookup(wCodePoint, pco) || !lpstrNewInvoke||
            !*lpstrNewInvoke)
        return;

    pcgh -> NewEncoding(lpstrNewInvoke);

    Changed();
}

/******************************************************************************

  CGlyphMap::ConvertCTT()

  This member fuction initializes the glyphmap structure from a CTT file

******************************************************************************/

int     CGlyphMap::ConvertCTT() {

    struct sCTT {
        enum {Composed, Direct, Paired};
        WORD    m_wFormat;
        BYTE    m_bFirstChar, m_bLastChar;
        union   {
            uencCTT m_uectt[1];
            BYTE    m_bDirect[1];
        };
    };

    //  If this map isn't empty, empty it now- at least of the glyph data

    m_csmw2oEncodings.RemoveAll();
    m_crr.Empty();

    CByteArray  cbaImage;

    try {

        CFile   cfCTT(m_csSource, CFile::modeRead | CFile::shareDenyWrite);

        cbaImage.SetSize(cfCTT.GetLength());

        cfCTT.Read(cbaImage.GetData(), cfCTT.GetLength());
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  IDS_FileReadError ;
    }

#if 0
    union {
        PBYTE   pbCTT;
        sCTT*   psctt;
    };

    pbCTT = cbaImage.GetData();
    BYTE    bFirst = min(0x20, psctt -> m_bFirstChar),
            bLast = 0xFF;   //  Since we use a byte this is the max!
    unsigned ucGlyphs = 1 + bLast - bFirst;


    //  Convert the code points to Unicode
    CByteArray  cbaCode;
    CWordArray  cwaCode;

    for (unsigned u = 0; u < ucGlyphs; u++)
        cbaCode.Add(u + bFirst);

    //  Convert the data to Unicode using the selected code page.  This uses
    //  data stored from MultiByteToWideChar, so it is similar, except we can
    //  do this with code pages which might not be installed on the user's
    //  system.

    if  (ucGlyphs != pccpi->Convert(cbaCode, cwaCode, CodePage(0).Page())) {
        CString csWork;
        csWork.Format(IDS_NoUnicodePoint, u + bFirst, CodePage(0).Page());
        AfxMessageBox(csWork);
        return  IDS_UnicodeConvFailed ;
    }

    //  Since we add phony glyphs to the table (why, one wonders), we must mark
    //  them so we can manufacture equally phony encodings for them.
    for (u = 0; u < ucGlyphs; u++) {

        //  Now, let's record the Encoding

        CGlyphHandle  *pcghNew = new CGlyphHandle;
        unsigned uToUse = u + bFirst - psctt -> m_bFirstChar;

        switch  (psctt -> m_wFormat) {

            case    sCTT::Direct:
                if  (u + bFirst < psctt -> m_bFirstChar)
                    pcghNew -> Init((BYTE) u + bFirst, u,cwaCode[u]);
                else
                    pcghNew -> Init(psctt -> m_bDirect[uToUse], u, cwaCode[u]);
                break;

            case    sCTT::Paired:
                if  (u + bFirst < psctt -> m_bFirstChar)
                    pcghNew -> Init((BYTE) u + bFirst, u, cwaCode[u]);
                else
                    if  (psctt -> m_uectt[uToUse].abPaired[1])
                        pcghNew -> Init(psctt -> m_uectt[uToUse].abPaired, u,
                            cwaCode[u]);
                    else
                        pcghNew -> Init(psctt -> m_uectt[uToUse].abPaired[0],
                            u, cwaCode[u]);
                break;

            case    sCTT::Composed:
                if  (u + bFirst < psctt -> m_bFirstChar) {
                    BYTE    bMe = u + bFirst;
                    pcghNew -> Init(&bMe, 1, u, cwaCode[u]);
                }
                else
                    pcghNew -> Init(pbCTT + psctt -> m_uectt[uToUse].wOffset,
                        psctt -> m_uectt[uToUse + 1].wOffset -
                        psctt -> m_uectt[uToUse].wOffset, u, cwaCode[u]);
                break;

            default:    //  Don't accept anything else!
                AfxMessageBox(IDS_InvalidCTTFormat);
                return  IDS_Invalid2CTTFormat ;
        }   //  One map entry coded

        //  Code page index inits OK, but must know the page

        pcghNew -> SetCodePage(0, DefaultCodePage());

        m_csmw2oEncodings[cwaCode[u]] = pcghNew;
        m_crr.Add(pcghNew);
    }   //  Loop of generating entries

    m_bPaired = sCTT::Paired == psctt -> m_wFormat;
#else
    {
        HANDLE   hheap;
        PBYTE   pbCTT;
        UNI_GLYPHSETDATA *pGTT;

        pbCTT = cbaImage.GetData();
        if( !(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 )))
        {
            char acMessage[256];
            wsprintf(acMessage, "HeapCreate() fails in ctt2gtt" );
            MessageBox(NULL, acMessage, NULL, MB_OK);
            return  IDS_HeapCFailed ;
        }
									
        //if (!BConvertCTT2GTT(hheap, (PTRANSTAB)pbCTT, DefaultCodePage(), 0x20,
		ASSERT(m_pcdOwner != NULL) ;
		DWORD dw = ((CProjectRecord*) m_pcdOwner)->GetDefaultCodePageNum() ;
        if (!BConvertCTT2GTT(hheap, (PTRANSTAB)pbCTT, dw, 0x20, 0xff, NULL, 
			NULL, &pGTT, 0)){
			HeapDestroy(hheap);   // raid 116619 prefix
            return IDS_ConvCTTFailed ;
		}
		try {
			CFile   cfGTT;
			if  (!cfGTT.Open(m_cfn.FullName(), CFile::modeCreate | CFile::modeWrite |
				CFile::shareExclusive))
				return  IDS_FileWriteError;
			cfGTT.Write(pGTT, pGTT->dwSize);
		}

		catch   (CException *pce) {
			pce -> ReportError();
			pce -> Delete();
			HeapDestroy(hheap);
			return  IDS_FileWriteError ;
		}

        HeapDestroy(hheap);
    }

    Load();

#endif

    return  0 ;
}

/******************************************************************************

  CGlyphMap::Load()

  This initializes the glyphmap from a GTT format file.  Since this is the
  primary means of loading, it requires no parameters.

******************************************************************************/

BOOL    CGlyphMap::Load(LPCTSTR lpstrName /*= NULL*/) {

    //  Note the correct name and path- the rename checks may fail, since the
    //  file is opened elsewhere (possibly with sharing conflicts), so disable
    //  them, for now.  This code is a little sleazy- but the only time the
    //  file name isn't null is if the file's being opened.

    if  (FileTitle().IsEmpty() && lpstrName) {
        m_cfn.EnableCreationCheck(FALSE);
        SetFileName(lpstrName);
        m_cfn.EnableCreationCheck();
    }

    if  (Glyphs()) { //  If we already have them, we're already loaded!
        m_csoaCodePage.RemoveAll(); //  Clean it all up, and reload.
        m_csmw2oEncodings.RemoveAll();
        m_crr.Empty();
    }

    CByteArray  cbaGTT;

    union   {
        PBYTE   pbGTT;
        sGTTHeader  *psgtth;
    };

    Load(cbaGTT);   //  If this fails, it will post a reason why

    if  (!cbaGTT.GetSize())
        return  FALSE;

    pbGTT = cbaGTT.GetData();

    sMapTable*  psmt = (sMapTable *) (pbGTT + psgtth -> m_dwofMapTable);
    sMapTableEntry* psmte = (sMapTableEntry *)(psmt + 1);

    //  Before we go any further, let's do some validation

    if  (psgtth -> m_dwVersion != sGTTHeader::Version1Point0)
        return  FALSE;

    m_bPaired = FALSE;

    //  First, let's snarf up the code page info

    struct sInvocation {
        DWORD   m_dwSize, m_dwOffset;
    };

    struct sCodePageInfo {
        DWORD   m_dwPage;
        sInvocation m_siSelect, m_siDeselect;
    }   *psci = (sCodePageInfo *)(pbGTT + psgtth -> m_dwofCodePages);

    m_csoaCodePage.RemoveAll();

    for (unsigned u = 0; u < psgtth -> m_dwcCodePages; u++, psci++) {
        m_csoaCodePage.Add(new CCodePageData(psci -> m_dwPage));
        if  (!psci -> m_siSelect.m_dwSize != !psci -> m_siSelect.m_dwOffset ||
             !psci -> m_siDeselect.m_dwSize !=
             !psci -> m_siDeselect.m_dwOffset)
            return  FALSE;  //  The data is bogus!

        CodePage(u).SetInvocation(((PBYTE) psci) + psci->m_siSelect.m_dwOffset,
            psci -> m_siSelect.m_dwSize, TRUE);
        CodePage(u).SetInvocation(((PBYTE) psci) + psci->m_siDeselect.m_dwOffset,
            psci -> m_siDeselect.m_dwSize, FALSE);
        //CodePage(u).SetInvocation(pbGTT + psci -> m_siSelect.m_dwOffset,
        //    psci -> m_siSelect.m_dwSize, TRUE);
        //CodePage(u).SetInvocation(pbGTT + psci -> m_siDeselect.m_dwOffset,
        //    psci -> m_siDeselect.m_dwSize, FALSE);
    }

    //  Next, we need to walk the glyph run tables to decipher and use the map
    //  table.

    struct sGlyphRun {
        WORD    m_wFirst, m_wc;
    }   *psgr = (sGlyphRun *)(pbGTT + psgtth -> m_dwofRuns);

    _ASSERTE(psgtth -> m_dwcGlyphs == psmt -> m_dwcEntries);

    WORD    wIndex = 0;

	/*** Changes have been made so that the following code is unneeded.
	 	 The MDT can load predefined GTTs now.  In addition, skipping
		 the complete loading of these GTTs causes some problems with
		 UFM width table loading.  The cumulative count of entries in
		 the glyph run tables is used to determine the maximum size of
		 the UFMs width table.  The data in the run tables is also used
		 to verify width table entries.

		// Don't do the rest if a predefined GTT is being loaded.  The code below
		// can blow on large GTTs; eg, the DBCS ones.  It may be better to find out
		// why the code blows but this seems to work for now.

		if ((short) m_wID >= CGlyphMap::Wansung
		 && (short) m_wID <= CGlyphMap::CodePage437)
			return TRUE ;
	*/

    for (unsigned uRun = 0; uRun < psgtth -> m_dwcRuns; uRun++, psgr++)
        for (u = 0; u < psgr -> m_wc; u++, psmte++, wIndex++) {
            CGlyphHandle*   pcgh = new CGlyphHandle;

            switch  (psmte -> m_bfType & sMapTableEntry::Format) {
                case    sMapTableEntry::Direct:

                    pcgh -> Init((PBYTE) &psmte -> m_uectt, 1, wIndex,
                        psgr -> m_wFirst + u);
                    break;

                case    sMapTableEntry::Paired:

                    pcgh -> Init(psmte -> m_uectt.abPaired, wIndex,
                        psgr -> m_wFirst + u);

                    if  (!(psmte -> m_bfType & sMapTableEntry::DBCS))
                        m_bPaired = TRUE;

                    break;

                case    sMapTableEntry::Composed:

                    pcgh -> Init(pbGTT + psgtth -> m_dwofMapTable +
                        psmte -> m_uectt.wOffset + sizeof wIndex,
                        *(PWORD) (pbGTT + psgtth -> m_dwofMapTable +
                        psmte -> m_uectt.wOffset), wIndex,
                        psgr -> m_wFirst + u);
                    break;

                default:    //  Bad news- bad format
                    delete  pcgh;   //  No orphans needed!
                    return  FALSE;
            }

            //  Don't forget the code page ID!

            pcgh -> SetCodePage(psmte -> m_bCodePageIndex,
                CodePage(psmte -> m_bCodePageIndex).Page());

            //  Mark this if it is to be disabled.

            if  (psmte -> m_bfType & sMapTableEntry::Disable)
                pcgh -> SetPredefined(CGlyphHandle::Removed);

            m_csmw2oEncodings[psgr -> m_wFirst + u] = pcgh;
            m_crr.Add(pcgh);
        }

    //  If we're predefined, Merge now.

    m_lidPredefined = psgtth -> m_lidPredefined;

    if  (m_lidPredefined != NoPredefined)
        MergePredefined();

    return  TRUE;   //  We actually did it!
}

/******************************************************************************

  CGlyphMap::RLE

  This generates an RLE-format file image of the glyph map.

******************************************************************************/

BOOL    CGlyphMap::RLE(CFile& cfTarget) {

    sRLE    srle;

    srle.m_widRLE = 0x78FE;
    srle.m_wcFirst = m_crr.First();
    srle.m_wcLast = m_crr.Last();
    srle.m_dwFlag = 0;
    srle.m_dwcGlyphs = m_csmw2oEncodings.GetCount();
    srle.m_dwcRuns = m_crr.RunCount();
    srle.m_dwcbImage = 4 * sizeof srle.m_dwcbImage + srle.m_dwcRuns *
         m_crr.Size();
    srle.m_dwcbThis = srle.m_dwcbImage + 3 * sizeof srle.m_dwcbThis +
        srle.m_dwcGlyphs * sizeof srle.m_dwcGlyphs;

    //  Determine the correct format, and thus the RLE size

    if  (!m_crr.MustCompose())
        srle.m_wFormat = m_bPaired ? sRLE::Paired : sRLE::Direct;
    else
        if  (srle.m_dwcGlyphs < 256 &&
             srle.m_dwcbThis + m_crr.ExtraNeeded() <= 0xffff) {
            srle.m_dwcbThis += m_crr.ExtraNeeded();
            srle.m_wFormat = sRLE::LengthIndexOffset;
        }
        else {
            srle.m_dwcbThis += m_crr.ExtraNeeded(FALSE);
            srle.m_wFormat = sRLE::LengthOffset;
        }

    //  We now need to feed the offset information down to the lower level
    //  classes, so that they are prepared to render their information to
    //  the target file.

    //  The first items encoded are the runs, which immediately follow the RLE
    //  header.

    DWORD   dwOffset = sizeof srle + srle.m_dwcRuns * m_crr.Size();

    m_crr.NoteOffset(dwOffset, TRUE, m_bPaired);

    //  If this requires extra data, it will be appearing after the FD_GLYPHSET

    if  (srle.m_wFormat == sRLE::LengthOffset ||
         srle.m_wFormat == sRLE::LengthIndexOffset)
        m_crr.NoteExtraOffset(dwOffset,
            srle.m_wFormat == sRLE::LengthIndexOffset);

    _ASSERTE(dwOffset == srle.m_dwcbThis);

    //  We've got our data, we've got our file, and we've got a job to do.
    //  Hop to it!

    try {
        cfTarget.Write(&srle, sizeof srle);
        m_crr.WriteSelf(cfTarget);
        m_crr.WriteHandles(cfTarget, srle.m_wFormat);
        m_crr.WriteEncodings(cfTarget, srle.m_wFormat == sRLE::LengthOffset ?
            CGlyphHandle::RLEBig : CGlyphHandle::RLESmall);
    }

    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}

/******************************************************************************

  CGlyphMap::Glyph

  I tried to do this in the header, file but that lets it be in-line, and I
  don't want to export CRunRecord.

******************************************************************************/

CGlyphHandle*   CGlyphMap::Glyph(unsigned u) {
    return  m_crr.GetGlyph(u);
}

/******************************************************************************

  CGlyphMap::CreateEditor

  This member function overrides the CProjectNode function to create a new
  CGlyphMapContainer document embedding this Glyph Map.  It then uses the
  appropriate document template to open a view on this document.

******************************************************************************/

CMDIChildWnd    *CGlyphMap::CreateEditor() {
    CGlyphMapContainer* pcgmcMe= new CGlyphMapContainer(this, FileName());

    //  Make up a cool title

    pcgmcMe -> SetTitle(m_pcbnWorkspace -> Name() + _TEXT(": ") + Name());

    CMDIChildWnd    *pcmcwNew = (CMDIChildWnd *) m_pcmdt ->
        CreateNewFrame(pcgmcMe, NULL);

    if  (pcmcwNew) {
        m_pcmdt -> InitialUpdateFrame(pcmcwNew, pcgmcMe, TRUE);
        m_pcmdt -> AddDocument(pcgmcMe);
    }

    return  pcmcwNew;
}

/******************************************************************************

  CGlyphMap::Generate

  This member function generates the GTT format image of the current data.

  It returns a BOOL indicating success or failure.

******************************************************************************/

BOOL    CGlyphMap::Generate(CFile& cfGTT) {

    sGTTHeader  sgtth;

    //  First, take care of any predefined stuff, if we have to

    if  (m_lidPredefined != NoPredefined)
        UnmergePredefined(TRUE);

    sgtth.m_dwcGlyphs = Glyphs();
    sgtth.m_dwcRuns = m_crr.RunCount();
    sgtth.m_dwcCodePages = CodePages();
    sgtth.m_lidPredefined = m_lidPredefined;

    //  The run table is the first item after the header, so add in its size

    sgtth.m_dwofRuns = sgtth.m_dwcbImage;   //  Runs are first item
    sgtth.m_dwcbImage += sgtth.m_dwcRuns * m_crr.Size(FALSE);
    sgtth.m_dwofCodePages = sgtth.m_dwcbImage;  //  Code pages are next

    //  Code page selection strings immediately follow the Code page structures
    //  The code page information size must be padded to a DWORD multiple

    sgtth.m_dwcbImage += sgtth.m_dwcCodePages * CodePage(0).Size();
	DWORD dwPadding ;	// # of padding bytes needed to DWORD align map table
	DWORD dwSelOffset ;	// Offset from each CODEPAGEINFO to sel/desel strings
	DWORD dwSelBytes ;	// Total # of bytes used by sel/desel strings
	dwSelOffset = sgtth.m_dwcbImage - sgtth.m_dwofCodePages ;
    for (unsigned u = 0 ; u < CodePages() ; u++) {
        CodePage(u).NoteOffsets(dwSelOffset) ;
		dwSelOffset -= CodePage(0).Size() ;
	} ;

    // Save the amount of padding, as we'll write it later.  It is also needed
	// as part of the computation for the mapping table offset.

    dwPadding = dwSelOffset + sgtth.m_dwcbImage ;
    dwPadding = (sizeof(DWORD) -
        (dwPadding & (sizeof(DWORD) - 1))) & (sizeof(DWORD) - 1) ;

	// Compute the number of bytes used for the sel/desel strings and pad.  Then
	// add this count to the image count of bytes so that it can be used to set
	// the mapping table offset.

	dwSelBytes = dwSelOffset + dwPadding ;
    sgtth.m_dwcbImage += dwSelBytes;
    sgtth.m_dwofMapTable = sgtth.m_dwcbImage;

	TRACE("***CGlyphMap::Generate() -  dwPadding = %d, dwSelBytes = %d, m_dwofMapTable = 0x%x\n", dwPadding, dwSelBytes, sgtth.m_dwofMapTable) ;

    //  Map Table size determination

    sMapTable   smt(Glyphs());

    //  Fortunately for us, the following not only preps the data, it also
    //  updates the image size for us
    if  (m_crr.MustCompose())
        m_crr.NoteOffset(smt.m_dwcbImage, FALSE, m_bPaired);

    //  Final Size calculation
    sgtth.m_dwcbImage += smt.m_dwcbImage;

    //  Now, we just write it out

    try {
        cfGTT.Write(&sgtth, sizeof sgtth);  //  Header
		
		ASSERT(sgtth.m_dwofRuns == cfGTT.GetPosition()) ;
        m_crr.WriteSelf(cfGTT, FALSE);      //  Glyph Runs
		
		ASSERT(sgtth.m_dwofCodePages == cfGTT.GetPosition()) ;
        for (unsigned u = 0; u < CodePages(); u++)
            CodePage(u).WriteSelf(cfGTT);   //  Code page structures

        for (u = 0; u < CodePages(); u++)
            CodePage(u).WriteInvocation(cfGTT); //  Code page invocations

		// Pad with 0's to DWORD align the mapping table

		dwSelBytes = 0 ;
        cfGTT.Write((LPSTR) &dwSelBytes, dwPadding) ;

        //  Do the map table, and we are finished!

		ASSERT(sgtth.m_dwofMapTable == cfGTT.GetPosition()) ;
        cfGTT.Write(&smt, sizeof smt);
        m_crr.WriteMapTable(cfGTT, m_lidPredefined != NoPredefined);
        m_crr.WriteEncodings(cfGTT, CGlyphHandle::GTT);
    }
    catch   (CException * pce) {
        //  Take care of any predefined stuff, if we have to

        if  (m_lidPredefined != NoPredefined)
            MergePredefined();

        //  Feedback- something broke when it shouldn't have
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }
    //  Take care of any predefined stuff, if we have to

    if  (m_lidPredefined != NoPredefined)
        MergePredefined();

    Changed(FALSE);

    return  TRUE;
}

/******************************************************************************

  CGlyphMapContainer class - this encases the glyph table UI when it is either
  embedded in the driver, or loaded directly from the GTT

******************************************************************************/

/******************************************************************************

  CGlyphMapContainer::CGlyphMapContainer()

  This default constructor is used whenever dynamic creation is used, which is
  most MFC usages of the document system.  It starts with an empty glyph map.

******************************************************************************/

IMPLEMENT_DYNCREATE(CGlyphMapContainer, CDocument)

CGlyphMapContainer::CGlyphMapContainer()
{
    m_pcgm = new CGlyphMap;
    m_pcgm -> NoteOwner(*this);
    m_bSaveSuccessful = m_bEmbedded = FALSE;
}

/******************************************************************************

  CGlyphMapContainer:CGlyphMapContainer(CGlyphMap *pvgm, CString csPath)

  This constructor override is used when we create a CGlyphMapContainer
  document from the driver/project level editor.  In this case, a digested
  map is passed, so no additional I/O us needed.

******************************************************************************/

CGlyphMapContainer::CGlyphMapContainer(CGlyphMap *pcgm, CString csPath)
{
    m_pcgm = pcgm;
    SetPathName(csPath, FALSE);
    m_bEmbedded = TRUE;
	m_bSaveSuccessful = FALSE;
    m_pcgm -> NoteOwner(*this); //  This is the document being edited!
}

BOOL CGlyphMapContainer::OnNewDocument() {
    return  CDocument::OnNewDocument();
}

CGlyphMapContainer::~CGlyphMapContainer() {
    if  (!m_bEmbedded && m_pcgm)
        delete  m_pcgm;
}


BEGIN_MESSAGE_MAP(CGlyphMapContainer, CDocument)
    //{{AFX_MSG_MAP(CGlyphMapContainer)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer diagnostics

#ifdef _DEBUG
void CGlyphMapContainer::AssertValid() const {
    CDocument::AssertValid();
}

void CGlyphMapContainer::Dump(CDumpContext& dc) const {
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer serialization

void CGlyphMapContainer::Serialize(CArchive& ar) {
    if (ar.IsStoring()) {
        // TODO: add storing code here
    }
    else {
        // TODO: add loading code here
    }
}

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer commands

BOOL CGlyphMapContainer::OnSaveDocument(LPCTSTR lpszPathName) {

    //  We save via the glyph map's Generate function.

    CFile   cfGTT;
    if  (!cfGTT.Open(lpszPathName, CFile::modeCreate | CFile::modeWrite |
        CFile::shareExclusive))
        return  FALSE;

    m_bSaveSuccessful = m_pcgm -> Generate(cfGTT) ;

	// Update the save timestamp.  This is done here so that other user of the
	// Generate() function don't update the timestamp.

	m_pcgm->m_ctSaveTimeStamp = CTime::GetCurrentTime() ;
	
	// when open mutiple workspace, last of the pos is the workspace conating current GTT or UFM
	CDriverResources * pcpr =(CDriverResources *) m_pcgm->GetWorkspace() ;
	if (m_pcgm->ChngedCodePt() && pcpr ) {//  && m_pcgm->Glyphs() <= 1000 ) {
		pcpr->SyncUFMWidth() ;
	}
    return m_bSaveSuccessful ;
}


/******************************************************************************

  CGlyphMapContainer::OnOpenDocument

  This overrides the typical MFC open document action, which is to open the
  document by serialization.  Instead, we use the CGlyphMap Load override for
  the GTT format to initialize the GlyphMap.

******************************************************************************/

BOOL CGlyphMapContainer::OnOpenDocument(LPCTSTR lpstrFile)
{
    return m_pcgm->Load(lpstrFile) ;
}


/******************************************************************************

  CGlyphMapContainer::SaveModified

  The document is about to close.  If the GTT was changed by the user but the
  user does not want to save the changes, the user wants to close the GTT, and
  the GTT was loaded from a workspace, then reload the GTT so that the changes
  are removed from the in memory copy of the GTT.  This keeps those "discarded"
  changes from being displayed the next time the GTT is edited.

  Return TRUE if it is ok for the doc to close.  Otherwise, FALSE.

******************************************************************************/

BOOL CGlyphMapContainer::SaveModified()
{
	// Get a pointer to the associate view class instance and use it to make
	// sure the code page select/deselect strings are copied into the GTT.

	POSITION pos = GetFirstViewPosition() ;
	ASSERT(pos != NULL) ;
	CGlyphMapView* pcgmv = (CGlyphMapView*) GetNextView(pos) ;
	pcgmv->SaveBothSelAndDeselStrings() ;
	
	// Find out if the document was modified and if the user wants to save it.

	m_bSaveSuccessful = FALSE ;
	BOOL bmodified = IsModified() ;
	BOOL bcloseok = CDocument::SaveModified() ;

	// If the GTT was loaded from a workspace, the GTT was changed, the user
	// does NOT want to save the changes, and he does want to close the doc,
	// then reload the GTT.
	
	if (m_bEmbedded	&& bmodified && bcloseok && !m_bSaveSuccessful)
		m_pcgm->Load() ;

	// Return flag indicating if it is ok to close the doc.

	return bcloseok ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gpdview.cpp ===
/******************************************************************************

  Source File:  GPD Viewer.CPP

  This file implements the GPD viewing/editing class.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  03-24-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "MiniDev.H"
#include    "MainFrm.H"
#include	<gpdparse.h>
#include    "ProjNode.H"
#include	"rcfile.h"
#include    "GPDFile.H"
#include    "GPDView.H"
#include    "Resource.H"
#include	"freeze.h"

#include "projview.h"
#include "comctrls.h"
#include    "INFWizrd.h"	//raid 0001


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/******************************************************************************

  CGPDViewer class

  This class implements the GPD viewer.

******************************************************************************/

IMPLEMENT_DYNCREATE(CGPDViewer, CRichEditView)


BEGIN_MESSAGE_MAP(CGPDViewer, CRichEditView)
	//{{AFX_MSG_MAP(CGPDViewer)
	ON_WM_DESTROY()
	ON_COMMAND(ID_FILE_PARSE, OnFileParse)
	ON_CONTROL_REFLECT(EN_CHANGE, OnChange)
	ON_WM_TIMER()
	ON_CONTROL_REFLECT(EN_VSCROLL, OnVscroll)
	ON_WM_VSCROLL()
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	ON_COMMAND(ID_FILE_ERROR_LEVEL, OnFileErrorLevel)
	ON_COMMAND(ID_EDIT_GOTO, OnGotoGPDLineNumber)
	ON_COMMAND(ID_SrchNextBtn, OnSrchNextBtn)
	ON_COMMAND(ID_SrchPrevBtn, OnSrchPrevBtn)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_LBN_SELCHANGE(IDC_ErrorLst, OnSelchangeErrorLst)
	ON_WM_LBUTTONDBLCLK()
	ON_COMMAND(ID_EDIT_ENABLE_AIDS, OnEditEnableAids)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_COMMAND(ID_FILE_INF, OnFileInf)
	//}}AFX_MSG_MAP
    ON_NOTIFY_REFLECT(EN_SELCHANGE, OnSelChange)
END_MESSAGE_MAP()


/******************************************************************************

  CGPDViewer::MarkError

  This private member highlights the given line in the error display.  The
  offending line in the GPD is displayed and selected if the error message
  contains a line number.

******************************************************************************/

void    CGPDViewer::MarkError(unsigned u)
{
	// Copy the error message to the status bar.

    CString cserror = GetDocument()->ModelData()->Error(u) ;
    m_csb.SetPaneText(0, cserror) ;
    SetFocus() ;

    // If the string starts with the GPD name, scroll to the line.
	
	CString csname = GetDocument()->ModelData()->FileTitleExt() ;
    if (!cserror.Find(csname) && cserror[csname.GetLength()] == _T('(')) {
        //  Extract the line number

        cserror = cserror.Mid(1 + csname.GetLength()) ;
        int iLine = atoi(cserror) ;

		// Determine the line's first character number and its length

		int nstartchar = GetRichEditCtrl().LineIndex(-1 + iLine) ;
		int nlinelen = GetRichEditCtrl().GetLine(iLine - 1,
												 cserror.GetBuffer(1024), 1024) ;
		cserror.ReleaseBuffer(nlinelen) ;
		nlinelen -= 2 ;

		// Select the line that caused the error and scroll it into view.

        GetRichEditCtrl().SetSel(nstartchar, nstartchar + nlinelen) ;
        GetRichEditCtrl().LineScroll(iLine  - (5 +
            GetRichEditCtrl().GetFirstVisibleLine())) ;
    } ;

    CWnd *pcwnderrors = m_cdbActionBar.GetDlgItem(IDC_ErrorLst);
    pcwnderrors->SendMessage(WM_HSCROLL, SB_TOP, NULL) ;
}


/******************************************************************************

  CGPDViewer::CreateActionBar

  Create the action bar and attach it to the GPD Editor window iff the GPD has
  errors to display.

******************************************************************************/

void    CGPDViewer::CreateActionBar()
{
	// Get reference to ModelData instance for the GPD in the editor

    CModelData& cmd = *GetDocument()->ModelData() ;

	// If the GPD has errors...

    if  (cmd.HasErrors()) {

		// ...Iff the action bar has not been created yet...

		if (m_cdbActionBar.m_hWnd == NULL) {
			// ...Create the error bar, position it, and resize the REC to make
			// room for it.

			m_cdbActionBar.Create(GetParentFrame(), IDD_GPDActionBar,
								  CBRS_BOTTOM, IDD_GPDActionBar) ;
			GetParentFrame()->RecalcLayout() ;

			// Now set the focus back to the REC.

			SetFocus() ;
		} ;
	} ;
}


/******************************************************************************

  CGPDViewer::LoadErrorListBox

  This fills the error dialog bar with the current set of errors, if there are
  any...

******************************************************************************/

void    CGPDViewer::LoadErrorListBox()
{
	// Get reference to ModelData instance for the GPD in the editor

    CModelData& cmd = *GetDocument()->ModelData() ;

	// If the GPD has errors...

    if  (cmd.HasErrors()) {
		// ...Get a pointer to the list box and attach it to CListBox.  Then
		// clear the list box.

		CWnd *pcwndlst = m_cdbActionBar.GetDlgItem(IDC_ErrorLst) ;
		CListBox clberrors  ;
		clberrors.Attach(pcwndlst->m_hWnd) ;
		clberrors.ResetContent() ;

		// Load the list box with the new errors.  Detach the list box when
		// done.

        for (unsigned u = 0 ; u < cmd.Errors() ; u++)
            clberrors.AddString(cmd.Error(u)) ;
		clberrors.Detach() ;

		// Set the list box label.  It contains the number of errors.

        CString cserror ;
		cserror.Format(IDS_ErrorLabel, u) ;
		m_cdbActionBar.SetDlgItemText(IDC_ErrorLabel, cserror) ;

		// Select the first error and set the focus to the REC.

        ChangeSelectedError(1) ;
        SetFocus() ;

	// Otherwise, just display a message saying there are no errors.

	} else {
        CString csWork;
        csWork.LoadString(IDS_NoSyntaxErrors);
        m_csb.SetPaneText(0, csWork);
    }
}


/******************************************************************************

  CGPDViewer::Color

  This private member syntax colors the rich edit controls contents using the
  information gleaned from the GPD file's analysis.

******************************************************************************/

void    CGPDViewer::Color()
{
    CHARRANGE   crCurrentSel;
    CHARFORMAT  cf;
    CModelData& cmd = *(GetDocument() -> ModelData());
    CRichEditCtrl&  crec = GetRichEditCtrl();
    m_bInColor = TRUE; 

    //  Turn off change and selection notification messages
	
	FreezeREC() ;

	// Get formatting info from the current selection to use as the default
	// characteristics for ever line on the screen.
    crec.GetSel(crCurrentSel);
    crec.GetDefaultCharFormat(cf);
    cf.dwEffects &= ~CFE_AUTOCOLOR;
    cf.dwMask |= CFM_COLOR;

    //  Color each visible line as it was classsified visibility is
    //  determined by checking the character bounds against the client
    //  rectangle for the control.

    int iTop = m_iTopLineColored = crec.GetFirstVisibleLine();
    int i    = iTop;
    int iLineHeight = crec.GetCharPos(crec.LineIndex(i+1)).y -
        crec.GetCharPos(crec.LineIndex(i)).y;

	// Tweak things to improve performance.

    CRect   crEdit ;
    crec.GetClientRect(crEdit) ;
    crec.LockWindowUpdate() ;    //  Don't let this show until done!
    crec.HideSelection(TRUE, TRUE) ;

	// Use the formatting characteristics of the current selection as a
	// starting place for the characteristics of each line on the screen.
	// Then set the line's colors based on the data returned by TextColor().

	int nlinesinrec = crec.GetLineCount() ;	// Number of lines in the REC
	int nstartchar, nendchar ;	// Used to determine starting/ending chars to
								// color in current line and to say line done
    do {
		nstartchar = nendchar = 0 ;

		// Colorize each segment of the current line that needs colorizing

		while (1) {
 			cf.crTextColor = TextColor(i, nstartchar, nendchar) ;
			if (nstartchar == -1) 
				break ;			// *** Loop exits here
			crec.SetSel(crec.LineIndex(i) + nstartchar,
						crec.LineIndex(i) + nendchar) ;
			crec.SetSelectionCharFormat(cf) ;
		} ; 
    } while (++i < nlinesinrec &&
	         crec.GetCharPos(crec.LineIndex(i)).y + iLineHeight <
		     crEdit.bottom - 1) ;

    //  Restore the original position of the cursor, and then the original
    //  line (in case the cursor is no longer on this page).

	  crec.SetSel(crCurrentSel); 
	  crec.LineScroll(iTop - crec.GetFirstVisibleLine());
      crec.HideSelection(FALSE, TRUE);
      crec.UnlockWindowUpdate();    //  Let it shine!

    //  Restore the notification mask

	UnfreezeREC() ;

	// Create the action bar and load the error list box.

    if  (m_bStart) {
		CreateActionBar() ;
        LoadErrorListBox() ;
	} ;
    m_bInColor = FALSE;
	
}


/******************************************************************************

  CGPDViewer::TextColor

  This determines what colors to make a line.  It is complicated a bit by the
  fact that the Rich Edit control gives false values for line length on long
  files.  Probably some brain-dead 64K thing, but I sure can't fix it.

  This routine is/can be called multiple times on a line.  Each time it is
  called, try to find the next piece of the line that needs to be colorized.
  If no colorizable part of the line can be found, set nstartchar to -1 and
  return.

  This routine will indicate the line range and color for these types of text:
	Normal to end of line comments (green)
	Comments containing error messages (red)
	Comments containing warning messages (amber/yellow)
	GPD keywords (blue)

  If a comment contains a keyword, the appropriate comment color is used.  IE,
  comments take precedence over everything as far as colorizing is concerned.

******************************************************************************/

unsigned CGPDViewer::TextColor(int i, int& nstartchar, int& nendchar)
{
	// Get the specified line

    CByteArray  cba ;
    CRichEditCtrl&  crec = GetRichEditCtrl() ;
    cba.SetSize(max(crec.LineLength(i) + sizeof (unsigned), 100)) ;
    CString csline((LPCTSTR) cba.GetData(),
        crec.GetLine(i, (LPSTR) cba.GetData(),
            (int)(cba.GetSize() - sizeof (unsigned)))) ;

	// If the end of the line was dealt with the last time, indicate that this
	// line is done and return.

	if (nendchar + 1 >= csline.GetLength()) {
		nstartchar = -1 ;
		return RGB(0, 0, 0) ;
	} ;

	// Now get the segment of the line we need to check and see if there is a
	// comment or something that might be a keyword in it.

	CString csphrase = csline.Mid(nendchar) ;
	int ncomloc = csphrase.Find(_T("*%")) ;
	int nkeyloc = csphrase.Find(_T('*')) ;

	// Process any comment found in the string

	if (ncomloc >= 0)
		return (CommentColor(csphrase, ncomloc, csline, nstartchar, nendchar)) ;

	// If no comment was found, process anything that might be a GPD keyword.

	if (nkeyloc >= 0)
		return (KeywordColor(csphrase, nkeyloc, csline, nstartchar, nendchar)) ;

	// The rest of the line should be black

	nstartchar = nendchar + 1 ;
	nendchar = csline.GetLength() ;
	return RGB(0, 0, 0) ;
}


/******************************************************************************

  CGPDViewer::CommentColor

  Determine and save the character range for the comment.  Then determine the
  type of comment and return the color required for that type.  (See TextColor()
  for more details.)

*******************************************************************************/

unsigned CGPDViewer::CommentColor(CString csphrase, int ncomloc, CString csline,
								  int& nstartchar, int& nendchar)
{
	// Determine the range in the line that contains the comment.  This starts
	// at the comment characters and goes to the end of the line.

	nstartchar = nendchar + ncomloc ;
	nendchar = csline.GetLength() - 1 ;

    // Errors

    if  (csphrase.Find(_T("Error:")) > ncomloc)
        return  RGB(0x80, 0, 0) ;

    // Warnings

    if  (csphrase.Find(_T("Warning:")) > ncomloc)
        return  RGB(0x80, 0x80, 0) ;

	// If this comment doesn't contain an error or warning, make it green.

    return  RGB(0, 0x80, 0) ;
}


/******************************************************************************

  CGPDViewer::KeywordColor

  Determine and save the character range for the comment.  Then determine the
  type of comment and return the color required for that type.  (See TextColor()
  for more details.)

*******************************************************************************/

unsigned CGPDViewer::KeywordColor(CString csphrase, int nkeyloc, CString csline,
								  int& nstartchar, int& nendchar)
{
	// Determine the length of the token that might be a keyword.  Keywords are
	// made up of letters, '?', '_', and '0'.

	TCHAR ch ;
	int nphlen = csphrase.GetLength() ;
	for (int nidx = nkeyloc + 1 ; nidx < nphlen ; nidx++) {
		ch = csphrase[nidx] ;
		if (ch != _T('?') && ch != _T('_') && (ch < _T('A') || ch > _T('Z'))
		 && (ch < _T('a') || ch > _T('z')) && ch != _T('0'))
			break ;
	} ;

	// If there is a keyword to check, isolate it.  Otherwise, update the range
	// for the * and return black as the color.

	CString cstoken ;
	if (nidx > nkeyloc + 1)
		cstoken = csphrase.Mid(nkeyloc + 1, nidx - nkeyloc - 1) ;
	else {
		nstartchar = nendchar + 1 ;
		nendchar = nstartchar + (nidx - nkeyloc - 1) ;
		return RGB(0, 0, 0) ;
	} ;

	// Update the range for the token no matter what it is.  Include the * in
	// the range.

	nstartchar = nendchar + nkeyloc ;
	nendchar = nstartchar + (nidx - nkeyloc) ;

	// Try to find the token in the keyword array
	
	CStringArray& csakeys = ThisApp().GetGPDKeywordArray() ;
	int nelts = (int)csakeys.GetSize() ;	// Number of elements in the keyword array
	int nleft, nright, ncomp ;	// Variables needed for searching of array
	int ncheck ;
	for (nleft = 0, nright = nelts - 1 ; nleft <= nright ; ) {
		ncheck = (nleft + nright) >> 1 ;
		ncomp = csakeys[ncheck].Compare(cstoken) ;
		//TRACE("Key[%d] = '%s', Tok = '%s', Comp Res = %d\n", ncheck, csakeys[ncheck], cstoken, ncomp) ;
		if (ncomp > 0)
			nright = ncheck - 1 ;
		else if (ncomp < 0)
			nleft = ncheck + 1 ;
		else
			break ;
	} ;							

	// If the token is a keyword, return blue as the color.  Otherwise,
	// return black.

	if (ncomp == 0)		
		return RGB(0, 0, 0x80) ;
	else
		return RGB(0, 0, 0) ;
}


/******************************************************************************

  CGPDViewer::UpdateNow

  This private member updates the underlying GPD and marks the document as
  changed, and the edit control as unmodified.  It is called whenever this
  needs to be done.

*******************************************************************************/

void    CGPDViewer::UpdateNow() {

    //  Don't do this if nothing's chenged...
    if  (!GetRichEditCtrl().GetModify())
        return;

    CWaitCursor cwc;    //  Just in case

    if  (m_uTimer)
        ::KillTimer(m_hWnd, m_uTimer);
    m_uTimer = 0;

    GetDocument() -> ModelData() -> UpdateFrom(GetRichEditCtrl());
    GetDocument() -> SetModifiedFlag();
    GetRichEditCtrl().SetModify(FALSE);
}


CGPDViewer::CGPDViewer()
{
	// Initialize member variables

    m_iLine = m_uTimer = 0 ;
    m_bInColor = FALSE ;
    m_bStart = TRUE ;
    m_iTopLineColored = -1 ;
	m_nErrorLevel = 0 ;
	m_bEditingAidsEnabled = true ;
	m_punk = NULL ;					
	m_pdoc = NULL ;
	m_bVScroll = false ;

	// Initialize the GPD keyword array if this hasn't been done already.

	if (ThisApp().GetGPDKeywordArray().GetSize() == 0)
		InitGPDKeywordArray() ;
}


CGPDViewer::~CGPDViewer()
{
	if (ThisApp().m_bOSIsW2KPlus)
		ReleaseFreeze(&m_punk, &m_pdoc) ;
}


/////////////////////////////////////////////////////////////////////////////
// CGPDViewer diagnostics

#ifdef _DEBUG
void CGPDViewer::AssertValid() const {
	CRichEditView::AssertValid();
}

void CGPDViewer::Dump(CDumpContext& dc) const {
	CRichEditView::Dump(dc);
}

#endif //_DEBUG

/******************************************************************************

  CGPDViewer::OnDestroy

  Handles the required project node notification when the view is destroyed.
  A GP Fault is a terrible thing to signal.

******************************************************************************/

void CGPDViewer::OnDestroy() {
	CRichEditView::OnDestroy();
	
	if  (GetDocument() -> ModelData())
        GetDocument() -> ModelData() -> OnEditorDestroyed();
	
	if (ThisApp().m_bOSIsW2KPlus)
		ReleaseFreeze(&m_punk, &m_pdoc) ;
}


/******************************************************************************

  CGPDViewer::OnInitialUpdate

  This is the wake-up call.  We fill the view from the GPD's contents, and
  eventually color things to suit us.

******************************************************************************/

void CGPDViewer::OnInitialUpdate()
{
	// Set the frame's window style and initialize the rich edit control (REC).

    GetParentFrame() -> ModifyStyle(0, WS_OVERLAPPEDWINDOW);
	CRichEditView::OnInitialUpdate();

	// Create and configure the GPD Editor's status bar

    if  (m_csb.Create(GetParentFrame())) {
        static UINT auid[] = {ID_SEPARATOR, ID_LineIndicator};
        m_csb.SetIndicators(auid, 2);
        m_csb.SetPaneInfo(1, ID_LineIndicator, SBPS_NORMAL, 200);
        GetParentFrame() -> RecalcLayout();
    }

    // We don't want EN_CHANGE messages while we load the control

    GetRichEditCtrl().SetEventMask(GetRichEditCtrl().GetEventMask() &
        ~ENM_CHANGE);

    // We also do not want the control to wrap lines for us, as it messes up
    // syntax coloring, etc.

    m_nWordWrap = WrapNone;
    WrapChanged();

	// Load the GPD's contents into the REC.

	GetDocument() -> ModelData() -> Fill(GetRichEditCtrl());
    SetFocus();

    // We want EN_CHANGE messages now that the initial load is complete so
	// that we can update the cache.  To keep from overloading the machine,
	// some change notifications are just acted upon once every half second.
	// A timer is used to do this.

    GetRichEditCtrl().SetEventMask(GetRichEditCtrl().GetEventMask() |
        ENM_CHANGE);
    m_uTimer = (unsigned) SetTimer((UINT_PTR) this, 500, NULL);

    GetRichEditCtrl().SetSel(1, 1); //  Have to change the selection!
    GetRichEditCtrl().SetSel(0, 0);

	// Initialize the pointers needed to freeze the REC.

	if (ThisApp().m_bOSIsW2KPlus)
		InitFreeze(GetRichEditCtrl().m_hWnd, &m_punk, &m_pdoc, &m_lcount) ;
}


/******************************************************************************

  CGPDViewer::OnFileParse

  Syntax check the GPD file, and show us the results

******************************************************************************/

void CGPDViewer::OnFileParse() {
    CWaitCursor cwc;

    if  (GetDocument() -> ModelData() -> HasErrors()) {
        m_cdbActionBar.DestroyWindow();
        GetParentFrame() -> RecalcLayout();
    }

    //  Save any changes made to the file.

	bool brestore = false ;		// True iff original file must be restored
	BOOL bdocmod = GetDocument()->IsModified() ;
    if (GetRichEditCtrl().GetModify() || bdocmod) {
        UpdateNow();    //  Pick up any new changes
        GetDocument()->ModelData()->BkupStore() ;
        GetDocument()->SetModifiedFlag(bdocmod) ;
		brestore = true ;
    }

	// Reparse the GPD

	if  (!GetDocument()->ModelData()->Parse(m_nErrorLevel))
        AfxMessageBox(IDS_UnusualError) ;

	// Restore the original GPD file (when needed) because the user wasn't
	// asked if it was ok to save the file.

	if (brestore)
        GetDocument()->ModelData()->Restore() ;

	// Display the action bar and load the error list.

	CreateActionBar() ;
    LoadErrorListBox() ;
    MessageBeep(MB_ICONASTERISK) ;

	// Mark the project containing this GPD as being dirty so that the new
	// errors (or lack there of) will be saved in the MDW file.
//RAID 17181  Here are suggestions. current fix is (3)
//   (1). Ask when workspace close if Error box has the bug in any Gpd file, which was check
//	 (2). Ask when Gpd viewer close if Error box has the bug in any Gpd file, which was check
//   (3). Do not ask at all, not saving error list

//	CModelData& cmd = *GetDocument()->ModelData(); //add 1/2
//	if(cmd.HasErrors())							// add 2/2
//		GetDocument()->ModelData()->WorkspaceChange() ;  (1)
//		OnChange(); (2) // add This prompt save ask message when close gpd viewer instead of workspace
//		(3)
	
}


/******************************************************************************

  CGPDViewer::OnChange

  This gets called whenever a change is made to the contents of the file.
  The coloring (now done only on the visible page) is updated, and the
  appropriate flags are set.  To keep performance smooth, the document is no
  longer updated as a result of this message.

******************************************************************************/

void CGPDViewer::OnChange()
{
	//  Since this is a RICHEDIT control, I override the
    //  CRichEditView::OnInitialUpdate() function to or the ENM_CHANGE flag
    //  into the control's event mask.  Otherwise this message wouldn't be
    //  sent.
	//
	//  To avoid thrashing the GPD contents unneedfully, we wait for 1 second
    //  of inactivity before bashing the changes into the GPD.

	// Scrolling data in the control generates two messages; first a scroll
	// message and then a change message.  This could cause scrolling to mark
	// the document as dirty if this flag wasn't used to keep this from
	// happening.

	if (m_bVScroll) {
		m_bVScroll = false ;
		return ;
	} ;

	// Do nothing if the change message was generated by Color().

    if (m_bInColor)
		return ;

	// Colorize whatever is on the screen and mark the document as having
	// changed.

    Color() ;
    GetDocument()->SetModifiedFlag() ;
}


/******************************************************************************

  CGPDViewer::OnTimer

  This handles the timeout of the timer used to batch changes into the
  underlying document.  If this isn't for that timer, we pass it on to the base
  class.

******************************************************************************/

void CGPDViewer::OnTimer(UINT uEvent) {

	// If this isn't our timer, let the base class do what it will with it.
	
    if  (m_uTimer == uEvent)
        if  (m_bStart) {
            if  (GetRichEditCtrl().GetLineCount() <
                GetDocument() -> ModelData() -> LineCount())
                return; //  The rich edit control isn't ready, yet...
            ::KillTimer(m_hWnd, m_uTimer);
            Color();
            m_uTimer = 0;
            m_bStart = FALSE;
        }
        else
            UpdateNow();
    else
	    CRichEditView::OnTimer(uEvent);
}

/******************************************************************************

  CGPDViewer::OnSelChange

  This handles the message sent by the control when the selection changes.  I'm
  hoping this means whenever the caret moves, since the selection, while empty,
  has changed.

******************************************************************************/

void    CGPDViewer::OnSelChange(LPNMHDR pnmh, LRESULT *plr) {
    SELCHANGE*  psc = (SELCHANGE *) pnmh;

    long    lLine = GetRichEditCtrl().LineFromChar(psc -> chrg.cpMin);

    CString csWork;
    csWork.Format(_T("Line %d, Column %d"), lLine + 1,
         1 + psc -> chrg.cpMax - GetRichEditCtrl().LineIndex(lLine));

    m_csb.SetPaneText(1, csWork);

}

/******************************************************************************

  CGPDViewer::OnUpdate

  If the first update hasn't been made, do nothing.

  Next, check to see if this routine was called by CGPDContainer::OnSaveDocument().
  If it was, make sure that the document has an up to date copy of the GPD.
  This is a hack to work around problems with CGPDContainer routines in
  modldata.dll call CGPDViewer routines in minidev.exe.  This problem should
  go away when the 3 MDT DLLs are folded back into the EXE.

  Otherwise, redo the error bar, because someone just syntax checked the
  workspace.

******************************************************************************/

void    CGPDViewer::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    if  (m_bStart) //  Have we already done the first update?
        return;

	// Update the document if this routine was called by the document class.

	if (lHint == 0x4545 && (INT_PTR) pHint == 0x4545) {
		UpdateNow() ;
		return ;
	} ;

    //  If there's a dialog bar, can it.

    if  (m_cdbActionBar.GetSafeHwnd()) {
        m_cdbActionBar.DestroyWindow();
        GetParentFrame() -> RecalcLayout();
    }

    // Recreate the action bar and load the error list.

	CreateActionBar() ;
	LoadErrorListBox();
}

/******************************************************************************

  CGPDViewer::QueryAcceptData

  Override the Rich Edit Control default behavior, because we (a) don't have
  an associated RichEditDoc, and (b) we don't want to paste anything but text.
  Not even rich text, because we control the formatting, and don't want to
  paste it.

******************************************************************************/

HRESULT CGPDViewer::QueryAcceptData(LPDATAOBJECT lpdo, CLIPFORMAT* lpcf, DWORD,
                                    BOOL bReally, HGLOBAL hgMetaFile) {
	_ASSERTE(lpcf != NULL);

	COleDataObject codo;
	codo.Attach(lpdo, FALSE);
	// if format is 0, then force particular formats if available
	if (*lpcf == 0 && (m_nPasteType == 0)&& codo.IsDataAvailable(CF_TEXT)) {
	    *lpcf = CF_TEXT;
		return S_OK;
	}
	return E_FAIL;
}


/******************************************************************************

  CGPDViewer::OnVScroll()

  This function is called when EN_VSCROLL messages are refelected from the
  edit control.  As long as we are not coloring, we color the new page.  The
  documentation says this message comes BEFORE the scolling occurs, but it
  obviously occurs afterwards.

******************************************************************************/

void    CGPDViewer::OnVscroll()
{
    // Even though we turn scroll notifications off in the color routine,
    // we still get them, so use a flag to keep from recursive death.
	//
	// In addition, a flag is set to say that a scroll message was just
	// processed so that the OnChange routine will know when it doesn't need to
	// do anything.  This is needed because scrolling generates both a scroll
	// and a change message.

    if  (m_iTopLineColored != GetRichEditCtrl().GetFirstVisibleLine() &&
        !m_bInColor) {
        if(!(GetKeyState(VK_SHIFT) & 0x8000)) // raid 28160 : GetSel,SetSel has bug(seem sdk bug)
			Color() ;
		m_bVScroll = true ;
		
	} ;
}


/******************************************************************************

  CGPDViewer::OnVScroll(UINT uCode, UINT uPosition, CScrollBar *pcsb)

  This is called whwnever the scoll bar gets clicked.  This may seem
  redundant, but EN_VSCROLL messages don't get sent when the thumb itself is
  moved with the mouse, and WM_VSCROLL doesn't get sent when the keyboard
  interface is used.  So you get to lose either way.

  This control is buggy as can be, IMHO.  Next time I want to do text editing,
  I'll use a third party tool.  They starve if they don't get it right.

******************************************************************************/

void CGPDViewer::OnVScroll(UINT uCode, UINT uPosition, CScrollBar* pcsb)
{
	CRichEditView::OnVScroll(uCode, uPosition, pcsb);
    //(Raid 16569)
	if(uCode == SB_THUMBTRACK)
		OnVscroll();
}


/******************************************************************************

  CGPDViewer::OnFileSave
  CGPDViewer::OnFileSaveAs

  Since we don't update the document as changes are made in the editor, we have
  to intercept these, update the document, and then pass these on to the
  document.

******************************************************************************/

void CGPDViewer::OnFileSave() {
	UpdateNow();
    GetDocument() -> OnFileSave();
}

void CGPDViewer::OnFileSaveAs() {
	UpdateNow();
    GetDocument() -> OnFileSaveAs();
}

/******************************************************************************

  CGPDViewer::OnUpdateEditPaste
  CGPDViewer::OnUpdateEditUndo

  These override the default processing for these menu items.  Paste is only
  possible with a text format.

  DEAE_BUG	Fix text coloring when an Undo operation is performed.

*******************************************************************************/

void CGPDViewer::OnUpdateEditPaste(CCmdUI* pccui) {
	pccui -> Enable(IsClipboardFormatAvailable(CF_TEXT));	
}

void CGPDViewer::OnUpdateEditUndo(CCmdUI* pccui) {
	pccui -> Enable(0);
}


void CGPDViewer::OnEditPaste()
{	//raid 16573
	CMainFrame *pcmf = (CMainFrame*) GetTopLevelFrame() ;
	ASSERT(pcmf != NULL) ;
	
	CGPDToolBar *cgtb = pcmf->GetGpdToolBar() ;
	
	if(GetFocus() == FromHandle(cgtb->ceSearchBox.m_hWnd) )
		cgtb->ceSearchBox.Paste();
	else
		GetRichEditCtrl().Paste() ;
		
	OnChange() ;	
}


void CGPDViewer::OnEditCut()
{
    GetRichEditCtrl().Cut() ;
	OnChange() ;
}


/******************************************************************************

  CGPDViewer::OnSelchangeErrorLst

  Update the REC by selected the GPD line corresponding to the currently
  selected error list item.

******************************************************************************/

void CGPDViewer::OnSelchangeErrorLst()
{
	ChangeSelectedError(0) ;
}


/******************************************************************************

  CGPDViewer::ChangeSelectedError

  Whenever the error message selected in the list box and/or the GPD line that
  generated the error should change, this routine is called to manage the work.

******************************************************************************/

void CGPDViewer::ChangeSelectedError(int nchange)
{
	// Make sure that the action bar exists before doing anything.

	if (m_cdbActionBar.m_hWnd == NULL || !IsWindow(m_cdbActionBar.m_hWnd))
		return ;

	// Get a pointer to the list box and attach it to CListBox.

	CWnd *pcwndlst = m_cdbActionBar.GetDlgItem(IDC_ErrorLst) ;
	CListBox clberrors ;
	clberrors.Attach(pcwndlst->m_hWnd) ;

	// Get the selected item number and the number of items.

	int nselitem = clberrors.GetCurSel() ;
	int numitems = clberrors.GetCount() ;
	
	// If the selected item number should change, change it.  Then "wrap" the
	// number if it goes out of bounds.  Last, select the referenced item.

	if (nchange != 0) {
		nselitem += nchange ;
		if (nselitem < 0)
			nselitem = numitems - 1 ;
		else if (nselitem >= numitems)
			nselitem = 0 ;
		clberrors.SetCurSel(nselitem) ;
	} ;

	// We're done with the list box now so detach from it.

	clberrors.Detach() ;

	// Select the error line in the REC and set the focus to the REC.

    MarkError(nselitem) ;
	SetFocus() ;
}


/******************************************************************************

  CGPDViewer::PreTranslateMessage

  Take special action when certain characters are entered.  Those characters
  are:
	F4			Select next error and corresponding GPD line when possible.
	Shift+F4	Select previous error and corresponding GPD line when possible.
	Ctrl+]    	Find a matching bracket "[]", paren "()", curly brace "{}", or
	      		angle brackets "<>".

******************************************************************************/

BOOL CGPDViewer::PreTranslateMessage(MSG* pMsg)
{
	// If F4 or Shift+F4 is pressed, change the selected error message and
	// update the current selected line in the GPD.

	if (pMsg->message == WM_KEYUP && pMsg->wParam == VK_F4) {
		if (!(GetKeyState(VK_SHIFT) & 0x8000))
			ChangeSelectedError(1) ;
		else
			ChangeSelectedError(-1) ;
		return CRichEditView::PreTranslateMessage(pMsg) ;
	} ;

	// Handle help command (F1)

	/*
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_F1) {
		//TRACE0("Calling Help on GPD\n") ;
		//ThisApp().WinHelp(0x20000 + IDR_GPD_VIEWER) ;
		//TRACE0("Calling Help on String\n") ;
		//ThisApp().WinHelp(0x20000 + IDR_STRINGEDITOR) ;
		//TRACE0("Calling Help on UFM\n") ;
		//ThisApp().WinHelp(0x20000 + IDR_FONT_VIEWER) ;
		TRACE0("Calling Help on GTT\n") ;
		ThisApp().WinHelp(0x20000 + IDR_GLYPHMAP) ;
		return 1 ;
	} ;
	*/

	// From here on, only messages (usually keys) for the REC are interesting
	// so process the rest normally and just return.

	if (this != GetFocus() || pMsg->message != WM_KEYUP)
		return CRichEditView::PreTranslateMessage(pMsg) ;

	// Handle matching brace command

	if (GetKeyState(VK_CONTROL) & 0x8000) {
		//TRACE("KEY = %d, 0x%x\n", pMsg->wParam, pMsg->wParam) ;
		
		// Process goto matching brace commands.

		if (pMsg->wParam == 0xDD)
	 		GotoMatchingBrace() ;
	} ;

	// Process the message normally.

	return CRichEditView::PreTranslateMessage(pMsg) ;
}


/******************************************************************************

  CGPDViewer::OnSrchNextBtn

  Search forward for the next part of the GPD that matches the specified text.

******************************************************************************/

void CGPDViewer::OnSrchNextBtn()
{
	SearchTheREC(true) ;
}


/******************************************************************************

  CGPDViewer::OnSrchPrevBtn

  Search backward for the previous part of the GPD that matches the specified
  text.

******************************************************************************/

void CGPDViewer::OnSrchPrevBtn()
{
	SearchTheREC(false) ;
}


/******************************************************************************

  CGPDViewer::SearchTheREC

  Search either forward or backward for the next part of the GPD that matches
  the specified text.  Select the matching text in the GPD.

  Return true if a match is found.  Otherwise, return false.

******************************************************************************/

bool CGPDViewer::SearchTheREC(bool bforward)
{
	CMainFrame *pcmf = (CMainFrame*) GetTopLevelFrame() ;
	ASSERT(pcmf != NULL) ;
	CString cstext ;
	pcmf->GetGPDSearchString(cstext) ;
	int nstlen ;
	if ((nstlen = cstext.GetLength()) == 0) {
        AfxMessageBox(IDS_BadSearchString) ;
		return false ;
	} ;

	// Declare the find text structure and get a reference to the REC.  Then
	// get the character range for the text currently selected in the REC.
	// This info will be used to compute the search range.

	FINDTEXTEX fte ;
    CRichEditCtrl& crec = GetRichEditCtrl() ;
	crec.GetSel(fte.chrg) ;

	// Set the search range.  If searching forward, search from the current
	// selection to the end of the GPD.  If searching backwards, search from
	// the current selection to the beginning of the GPD.
	//
	// DEAD_BUG	Is the latter correct???

	int norgcpmin = fte.chrg.cpMin ;
	int norgcpmax = fte.chrg.cpMax ;
	if (bforward) {
		fte.chrg.cpMin = fte.chrg.cpMax ;
		fte.chrg.cpMax = -1 ;
	} else {
		fte.chrg.cpMin = 0 ;
		fte.chrg.cpMax = norgcpmin ;
	} ;

	// Load a pointer to the search string into the fte.

	fte.lpstrText = cstext.GetBuffer(nstlen + 1) ;

	// Perform the first attempt at finding a match.

	int nmatchpos ;
	if (bforward)
		nmatchpos = crec.FindText(0, &fte) ;
	else
		nmatchpos = ReverseSearchREC(crec, fte, norgcpmin, norgcpmax) ;

	// If the match failed, try to search the other part of the GPD.  Return
	// failure if this doesn't work either.

/*	if (nmatchpos == -1) {
		if (bforward) {
			fte.chrg.cpMin = 0 ;
			fte.chrg.cpMax = norgcpmax ;
		} else {
			fte.chrg.cpMin = norgcpmin ;
			fte.chrg.cpMax = -1 ;
		} ;
		if (bforward)
			nmatchpos = crec.FindText(0, &fte) ;
		else			
			nmatchpos = ReverseSearchREC(crec, fte, norgcpmin, norgcpmax) ;
*/	if (nmatchpos == -1) {
		cstext.ReleaseBuffer() ;
		CString csmsg ;
		csmsg.Format(IDS_GPDStringSearchFailed, cstext) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return false ;
	} ;


	// A match was found so select it.

	crec.SetSel(nmatchpos, nmatchpos + nstlen) ;

	// A match was found and selected so return true.

	cstext.ReleaseBuffer() ;
	return true ;
}


/******************************************************************************

  CGPDViewer::ReverseSearchREC

  The REC's built in searching support does not search backwards so this
  routine is used to do this.  The text in the specified range is loaded
  into a string and searched.

  The index of the match is returned if one is found.  Otherwise, return -1.

******************************************************************************/

int CGPDViewer::ReverseSearchREC(CRichEditCtrl& crec, FINDTEXTEX& fte,
								 int norgcpmin, int norgcpmax)
{
	// Hide selections to prevent flashing

	crec.HideSelection(TRUE, TRUE) ;

	// Get the index of the last character in the GPD if it is needed.

	int nresult ;
	if (fte.chrg.cpMax == -1) {
		crec.SetSel(0, -1) ;
		nresult = fte.chrg.cpMin ;
		crec.GetSel(fte.chrg) ;
		fte.chrg.cpMin = nresult ;
	} ;

	// Get the text in the part of the GPD we need to check.

	crec.SetSel(fte.chrg) ;
	CString cstext = crec.GetSelText() ;

	// Search the string backwards
									
	cstext.MakeReverse() ;
	cstext.MakeUpper() ;
	CString csrevsrch = fte.lpstrText ;
	csrevsrch.MakeReverse() ;
	csrevsrch.MakeUpper() ;
	nresult = cstext.Find(csrevsrch) ;

	// If a match is found, "reverse" the number to reverse the affects of
	// reversing the strings.
	
	if (nresult >= 0) {
		nresult = fte.chrg.cpMax - fte.chrg.cpMin - nresult
				  - csrevsrch.GetLength() ;
	
		// Adjust the offset of the matching string when necessary.  We want a
		// REC index not a string index.

		if (fte.chrg.cpMin != 0)
			nresult += fte.chrg.cpMin - 2 ;
	} ;

	// Reset the original selection, show selections again, and return the
	// result.

	crec.SetSel(norgcpmin, norgcpmax) ;
	crec.HideSelection(FALSE, TRUE) ;
	return nresult ;
}


/******************************************************************************

  CGPDViewer::OnGotoGPDLineNumber

  Goto the requested GPD line number in the REC.

******************************************************************************/

void CGPDViewer::OnGotoGPDLineNumber()
{
	// Declare the Goto Line dialog box and set the maximum line number.

	CGotoLine cgl ;
    CRichEditCtrl& crec = GetRichEditCtrl() ;
	cgl.SetMaxLine(crec.GetLineCount()) ;

	// Display the dialog box and exit if the user cancels.

	if (cgl.DoModal() == IDCANCEL)
		return ;

	// Get the line number.  Then, determine the line's first character number
	// and its length.

	int nlinenum = cgl.GetLineNum() ;
	CString csline ;
	int nstartchar = crec.LineIndex(-1 + nlinenum) ;
	int nlinelen = crec.GetLine(nlinenum - 1, csline.GetBuffer(1024), 1024) ;
	csline.ReleaseBuffer(nlinelen) ;
	nlinelen -= 2 ;

	// Select the requested line and scroll it into view.

    crec.SetSel(nstartchar, nstartchar + nlinelen) ;
    crec.LineScroll(nlinenum  - (5 + crec.GetFirstVisibleLine())) ;

	// All went well so...

	return ;
}


/******************************************************************************

  CGPDViewer::OnFileErrorLevel

  Get and save the newly selected error level.

******************************************************************************/

void CGPDViewer::OnFileErrorLevel()
{
	// Initialize and display the error level dialog box.  Just return if the
	// user cancels.

	CErrorLevel	cel ;
	cel.SetErrorLevel(m_nErrorLevel) ;
	if (cel.DoModal() == IDCANCEL)
		return ;

	// Save the new error level

	m_nErrorLevel =	cel.GetErrorLevel() ;
}


/******************************************************************************

  CGPDViewer::GotoMatchingBrace

  Find and goto the matching brace in the REC.  The following types of braces
  are matched:
	(), {}, [], <>

  If there is a brace to match and a match is found, move the cursor to the
  left of the matching brace and make sure the line containing the brace is
  visible.  Return true in this case.

  If there is no brace to match or a match cannot be found, just beep and
  return false.

  In the case where the cursor is in between two braces, the one to the right
  of the cursor is matched.	 If 1+ characters are actually selected, only
  check the last character to see if it is a brace to match.

******************************************************************************/

bool CGPDViewer::GotoMatchingBrace()
{
	// Get a reference to the REC and hide selections in it because this
	// routine might change the selection several times and I don't want the
	// screen to flash as the selection changes.

    CRichEditCtrl& crec = GetRichEditCtrl() ;
    crec.LockWindowUpdate() ;
    crec.HideSelection(TRUE, TRUE) ;

	// Get the selection range and make a copy of it.  Increase the copy by one
	// on each side if the min and max are the same.  This is done to find
	// match characters when there is no selection.  Use the copy to set and get
	// the selection.

	CHARRANGE crorg, cr ;
	crec.GetSel(crorg) ;
	cr.cpMin = crorg.cpMin ;
	cr.cpMax = crorg.cpMax ;
	bool bchecksecondchar = false ;
	if (cr.cpMin == cr.cpMax) {
		cr.cpMax++ ;
		if (cr.cpMin > 0)		// Do go passed beginning of file and maintain
			cr.cpMin-- ;		// string length.
		else
			cr.cpMax++ ;
		crec.SetSel(cr) ;
		bchecksecondchar = true ;
	} ;
	CString cssel = crec.GetSelText() ;

	// HACK ALERT - There seems to be a bug in the REC that will return the
	// wrong characters if the cursor is flush left (at the beginning of
	// the line and cpMin is reduced so the characters requested span a
	// line.  This is determined by the cssel beginning with CR+LF.  When this
	// is detected, reset bchecksecondchar because in brace will be the last
	// character in the string so things will work fine if bchecksecondchar is
	// reset.  CpMin needs to be adjusted too.

	bool bbegline = false ;
	if (bchecksecondchar && cssel.GetLength() >= 2 && cssel[0] == 0xD
	 && cssel[1] == 0xA) {
		bchecksecondchar = false ;
		cr.cpMin = cr.cpMax - 1 ;
		bbegline = true ;
	} ;

	// Try to find a brace to match in the selection (opening character) and
	// use this info to set the matching brace (closing character).  If this
	// fails, reset everything, beep, and return.

	TCHAR chopen, chclose ;		// Opening/closing characters to match
	int noffset ;				// Offset in REC for brace to match
	bool bsearchup ;			// True iff must search up in REC for match
	if (!IsBraceToMatch(cssel, chopen, chclose, bchecksecondchar, bsearchup,
	 cr, noffset)) {
		crec.SetSel(crorg) ;
		crec.HideSelection(FALSE, TRUE) ;
		crec.UnlockWindowUpdate() ;
		MessageBeep(0xFFFFFFFF) ;
		return false ;
	} ;

	// Determine the starting and ending range to search.

	if (bsearchup) {
		cr.cpMin = 0 ;
		cr.cpMax = noffset ;
		if (bbegline)			// One more tweak to get around the bug
			cr.cpMax -= 2 ;
	} else {
		cr.cpMin = noffset + 1 ;
		cr.cpMax = -1 ;
	} ;

	// Get the text we want to search.

	crec.SetSel(cr) ;
	cssel = crec.GetSelText() ;

	// Set the loop counter, loop counter increment, and loop limit that will
	// cause a search up (backwards) or down (forwards).

	int nidx, nloopinc, nlimit ;
	if (bsearchup) {
		nidx = cssel.GetLength() - 1 ;
		nloopinc = -1 ;
		nlimit = -1 ;
	} else {
		nidx = 0 ;
		nloopinc = 1 ;
		nlimit = cssel.GetLength() ;
	} ;

	// Loop through the text checking characters for a matching brace.  The
	// brace count is incremented when an opening brace if found and decremented
	// when a closing brace is found.  The matching brace has been found when
	// the brace count reaches 0.

	int nbracecount = 1 ;		// Count first opening brace
	for ( ; nidx != nlimit && nbracecount != 0 ; nidx += nloopinc) {
		if (cssel[nidx] == chclose)
			nbracecount-- ;
		else if (cssel[nidx] == chopen)
			nbracecount++ ;
	} ;

	// Reset everything, beep, and return false if no matching brace was found.

	if (nbracecount != 0) {
		crec.SetSel(crorg) ;
		crec.HideSelection(FALSE, TRUE) ;
		crec.UnlockWindowUpdate() ;
		MessageBeep(0xFFFFFFFF) ;
		return false ;
	} ;

	// Determine the REC based range needed to put the cursor to the left of
	// the matching brace.  The method used to do this depends on the search
	// direction.  Then set the selection.

	if (bsearchup)
		cr.cpMin = cr.cpMax = nidx + 1 ;
	else
		cr.cpMin = cr.cpMax = cr.cpMin + nidx - 1 ;
	crec.SetSel(cr) ;

	// Scroll the line containing the matching brace into view iff it is not
	// already visible.

	int nline = crec.LineFromChar(cr.cpMin) ;
	if (!IsRECLineVisible(nline)) {
		if (bsearchup)
			crec.LineScroll(nline - (2 + crec.GetFirstVisibleLine())) ;
		else
			crec.LineScroll(nline - (5 + crec.GetFirstVisibleLine())) ;
	} ;

	// Show the selection again and return true to indicate a match was found.

    crec.HideSelection(FALSE, TRUE) ;
    crec.UnlockWindowUpdate() ;
	return true ;				
}


/******************************************************************************

  CGPDViewer::IsBraceToMatch

  Find out if there is a brace to match.  Return true if there is and save that
  brace as the opening character and save its matching brace as the closing
  character.  In addition, determine and save the REC offset for the opening
  character.  Last, set a flag to tell if searching for the match should go
  up into the REC or down into the REC based the opening character being the
  right or left brace.  If no opening brace is found, return false.

  In the case where the cursor is in between two braces, the one to the right
  of the cursor is matched.	 If 1+ characters are actually selected, only
  check the last character to see if it is a brace to match.

******************************************************************************/

bool CGPDViewer::IsBraceToMatch(CString& cssel, TCHAR& chopen, TCHAR& chclose,
								bool bchecksecondchar, bool& bsearchup,
								CHARRANGE cr, int& noffset)
{
	int nsellen = cssel.GetLength() ;	// Length of selection string

	// Loop through the character(s) to be checked.

	chclose = 0 ;
	for (int n = 1 ; n >= 0 ; n--) {
		// Use the type of selection and the iteration to determine which - if
		// any - character to check and that character's offset.

		if (bchecksecondchar) {
			if (n >= nsellen)
				continue ;
			chopen = cssel[n] ;
			noffset = cr.cpMin + n ;
		} else if (n == 0) {
			chopen = cssel[nsellen - 1] ;
			noffset = cr.cpMin + nsellen - 1 ;
		} else
			continue ;

		// Check all of the left braces.  If an one is found, save its right
		// brace.  A left brace as an opening character means that the REC
		// must be searched down.

		bsearchup = false ;
		if (chopen == _T('('))
			chclose = _T(')') ;
		if (chopen == _T('{'))
			chclose = _T('}') ;
		if (chopen == _T('['))
			chclose = _T(']') ;
		if (chopen == _T('<'))
			chclose = _T('>') ;

		// If we have a closing character, a match was found and all the needed
		// info has been saved so return true.

		if (chclose != 0)
			return true ;

		// Check all of the right braces.  If an one is found, save its left
		// brace.  A right brace as an opening character means that the REC
		// must be searched up.

		bsearchup = true ;
		if (chopen == _T(')'))
			chclose = _T('(') ;
		if (chopen == _T('}'))
			chclose = _T('{') ;
		if (chopen == _T(']'))
			chclose = _T('[') ;
		if (chopen == _T('>'))
			chclose = _T('<') ;

		// If we have a closing character, a match was found and all the needed
		// info has been saved so return true.

		if (chclose != 0)
			return true ;
	} ;

	// If this point is reached, no brace was found so...

	return false ;
}


/******************************************************************************

  CGPDViewer::InitGPDKeywordArray

  Build a sorted array of GPD keyword strings.  This array is used to find and
  colorize keywords, etc.

******************************************************************************/

extern "C" PSTR GetGPDKeywordStr(int nkeyidx, PGLOBL pglobl) ;
extern "C" int InitGPDKeywordTable(PGLOBL pglobl) ;

void CGPDViewer::InitGPDKeywordArray()
{
	// Begin by getting a reference to the array and setting its initial size.

    GLOBL   globl;

    PGLOBL pglobl = &globl;


	CStringArray& csakeys = ThisApp().GetGPDKeywordArray() ;
	csakeys.SetSize(400) ;

	// Initialize the GPD keyword table and save its size.  Shrink the array
	// and return if this fails.

	int numtabents ;
	if ((numtabents = InitGPDKeywordTable(pglobl)) == -1) {
		csakeys.SetSize(0) ;
		return ;
	} ;

	// Declare variables needed to insert elements into the array.

	int nelts = 0 ;				// Number of elements used in the array
	int nleft, nright, ncomp ;	// Variables needed for searching of array
	int ncheck ;
	LPSTR lpstrkey ;			// Pointer to current keyword

	// Get all of the GPD keywords and use them to make a sorted array of
	// keyword strings.

	for (int nkeyidx = 0 ; nkeyidx <= numtabents ; nkeyidx++) {
		// Get the next string pointer.  Skip it if the pointer is NULL.

		if ((lpstrkey = GetGPDKeywordStr(nkeyidx, pglobl)) == NULL)
			continue ;

		// Skip the curly braces that are in the keyword list.

		if (strcmp(lpstrkey, _T("{")) == 0 || strcmp(lpstrkey, _T("}")) == 0)
			continue ;

		// Now find the location to insert this string into the list

		for (nleft = 0, nright = nelts - 1 ; nleft <= nright ; ) {
			ncheck = (nleft + nright) >> 1 ;
			ncomp = csakeys[ncheck].Compare(lpstrkey) ;
			//TRACE("Key[%d] = '%s', Tok = '%s', Comp Res = %d\n", ncheck, csakeys[ncheck], lpstrkey, ncomp) ;
			if (ncomp > 0)
				nright = ncheck - 1 ;
			else if (ncomp < 0)
				nleft = ncheck + 1 ;
			else
				break ;
		} ;

		// Insert the new string at the correct spot in the array.

		csakeys.InsertAt(nleft, lpstrkey) ;

		// Count this element and assert if the array limit has been reached.

		nelts++ ;
		ASSERT(nelts < 400) ;
	} ;

	// Now that we know the actual number of keywords, shrink the array to its
	// correct size.

	csakeys.SetSize(nelts) ;

	// Either something is wrong with my array building code above or something
	// is wrong with the CStringArray class because the array isn't sorted
	// perfectly.  There are a few problems.  The code below is meant to fix
	// those problems.  The sorting algorithm is slow but it only has to be
	// run once and few strings need to be moved so it should be ok.

	int nidx1, nidx2 ;
	CString cstmp ;
	for (nidx1 = 0 ; nidx1 < nelts - 1 ; nidx1++) {
		for (nidx2 = nidx1 + 1 ; nidx2 < nelts ; nidx2++) {
			if (csakeys[nidx1].Compare(csakeys[nidx2]) > 0) {
				cstmp = csakeys[nidx1] ;
				csakeys[nidx1] = csakeys[nidx2] ;
				csakeys[nidx2] = cstmp ;
			} ;
		} ;
	} ;

	/*
	// Testing code used to make sure the array is sorted in ascending order.

	CString cs1, cs2 ;
	int x, y, z ;
	for (x = 0 ; x < (nelts - 1) ; x++) {
		if (csakeys[x].Compare(csakeys[x+1]) > 0) {
			cs1 = csakeys[x] ;
			cs2 = csakeys[x+1] ;
		} ;
	} ;
	*/

	// Dump the contents of the sorted keyword array.
	
	//for (nleft = 0 ; nleft < nelts ; nleft++)
	//	TRACE("%4d   %s\n", nleft, csakeys[nleft]) ;
}


/******************************************************************************

  CGPDViewer::IsRECLineVisible

  Return true if the specified line is visible in the REC's window.  Otherwise,
  return false.  If the specified line is -1 (the default), check the current
  line.

  Visibility is determined by getting the rect for the REC's window and - based
  on the line number and height - determine if the line is in that rect.

******************************************************************************/

bool CGPDViewer::IsRECLineVisible(int nline /*= -1*/)
{
	// Get a reference to the REC.

    CRichEditCtrl& crec = GetRichEditCtrl() ;

    //  Determine the height of lines in the REC's window.

    int ntopline = crec.GetFirstVisibleLine() ;
    int nlineheight = crec.GetCharPos(crec.LineIndex(ntopline+1)).y -
        crec.GetCharPos(crec.LineIndex(ntopline)).y ;

	// Determine the current line number if needed

	CHARRANGE cr ;
	if (nline == -1) {
		crec.GetSel(cr) ;
		nline = crec.LineFromChar(cr.cpMin) ;
	} ;

	// Get the dimensions of the REC's window

	CRect crwindim ;
    crec.GetClientRect(crwindim) ;

	// Return true if the bottom of the line is above the bottom of the
	// REC's window.

    return (crec.GetCharPos(crec.LineIndex(nline)).y + nlineheight <
		    crwindim.bottom - 1)  ;
}


LPTSTR	CGPDViewer::alptstrStringIDKeys[] = {	// Keywords with string ID values
	_T("*rcModelNameID"),
	_T("*rcInstalledOptionNameID"),
	_T("*rcNotInstalledOptionNameID"),
	_T("*rcInstallableFeatureNameID"),
	_T("*rcNameID"),
	_T("*rcPromptMsgID"),
	_T("*rcInstallableFeatureNameID"),
	_T("*rcNameID"),
	_T("*rcCartridgeNameID"),
	_T("*rcTTFontNameID"),
	_T("*rcDevFontNameID"),
	_T("*rcPersonalityID"),
	_T("*rcHelpTextID"),
	NULL
} ;

LPTSTR	CGPDViewer::alptstrUFMIDKeys[] = {		// Keywords with UFM ID values
	_T("*DeviceFonts"),
	_T("*DefaultFont"),
	_T("*MinFontID"),
	_T("*MaxFontID"),
	_T("*Fonts"),
	_T("*PortraitFonts"),
	_T("*LandscapeFonts"),
	NULL
} ;

/******************************************************************************

  CGPDViewer::OnLButtonDblClk

  If the user clicked on the RC ID for a string or a UFM, start the String
  Editor or the UFM Editor.  In the latter case, load the specified UFM into
  the editor.

  Current restrictions:
	o This instance of the GPD Editor must have been started from the Workspace
	  view.
	o Only numeric RC IDs are supported.  Macros representing an ID are not
	  supported.

******************************************************************************/

void CGPDViewer::OnLButtonDblClk(UINT nFlags, CPoint point)
{
// Do default double click processing first so that whatever the user
	// clicked on will be selected.
	
	CRichEditView::OnLButtonDblClk(nFlags, point) ;

	// Do no further processing if GPD editing aids have been disabled.	
	if (!m_bEditingAidsEnabled)
		return ; 

	// Another editor can only be started when the GPD Editor was run from the
	// workspace view.

//	if (!GetDocument()->GetEmbedded())
//		return ;

	// Get reference for the REC and get the selected text.

    CRichEditCtrl& crec = GetRichEditCtrl() ;
	CString cssel = crec.GetSelText() ;

	// Try to turn the selected text into a number.  Return if this doesn't
	// work or the number is negative because only positive, numeric RC IDs
	// are supported at this time.

	int nrcid ;
	if ((nrcid = atoi(cssel)) <= 0)
		return ;

	// Get the line containing the current selection

	CHARRANGE cr ;
	crec.GetSel(cr) ;
	int nline = crec.LineFromChar(cr.cpMin) ;
	TCHAR achline[1024] ;
	int numchars = crec.GetLine(nline, achline, 1024) ;
	achline[numchars] = 0 ;
	CString csline = achline ;

	// Do nothing if the number selected was in a comment.

	if (csline.Find(_T("*%")) >= 0
	 && csline.Find(_T("*%")) < cr.cpMin - crec.LineIndex(nline))
		return ;

	// Now try to find a keyword in the line that has a string or UFM ID
	// associated with it.  If no keyword is found in this line and it begins
	// with a plus sign (continuation character), check the previous line.

	bool bstring = false ;		// True iff a string ID was found
	bool bufm = false ;			// True iff a UFM ID was found
	int n ;						// Loop index
	for ( ; ; ) {
		// Try to find a matching string keyword in the current line
		
		for (n = 0 ; alptstrStringIDKeys[n] != NULL ; n++)
			if (csline.Find(alptstrStringIDKeys[n]) >= 0) {
				bstring = true ;
				break ;
			} ;

		// Try to find a matching UFM keyword in the current line
		
		for (n = 0 ; alptstrUFMIDKeys[n] != NULL ; n++)
			if (csline.Find(alptstrUFMIDKeys[n]) >= 0) {
				bufm = true ;
				break ;
			} ;

		// Blow if both types of keywords were found because this case isn't
		// handled correctly.

		ASSERT(!(bstring && bufm)) ;

		// Setup to process the previous line if no match was found and this
		// line starts with a continuation character.  Otherwise, exit the
		// loop or the routine.

		if (bstring || bufm)
			break ;				// *** Loop exits here
		else if (csline[0] != _T('+') || --nline < 0)
			return ;			// *** Routine exits when there is nothing to do
		else {
			numchars = crec.GetLine(nline, achline, 1024) ;
			achline[numchars] = 0 ;
			csline = achline ;
		} ;
	} ;

	// Start the appropriate editor with the appropriate data loaded.
	// Raid 3176 all below if.
	if (!GetDocument()->GetEmbedded()){
		// find the font name in RC file
	
		//1. get rc file name   2. load rc file 3. find font name   4.make array with it's number and file path
			
		//get rc file , assuem rc file is same with DLL name.if not user have to select rc file.
		CString csPath = GetDocument()->GetPathName();
		CString csrfile = csPath.Left(csPath.ReverseFind(_T('\\')) + 1);
		csrfile = csrfile + _T("*.rc"); 
		
		CFileFind cff;
	// raid 201554
		if ( cff.FindFile(csrfile)) {   
			cff.FindNextFile() ;
			csrfile = cff.GetFilePath();
		}
		else
		{
			CString cstmp;
			cstmp.LoadString(IDS_NotFoundRC);
			if ( AfxMessageBox(cstmp,MB_YESNO) == IDYES ) {
				CFileDialog cfd(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
					_T("RC Files (*.rc)|*.rc||") );   
				if(IDCANCEL == cfd.DoModal())
					return ;
				csrfile = cfd.GetFileName();
			}
			else 
				return ;

		}
		
		CWinApp *cwa = AfxGetApp();
		if (bstring){
			// we save RC path, its rcid for the use on StringEditorDoc
		
			cwa->WriteProfileString(_T("StrEditDoc"),_T("StrEditDocS"),csrfile);
			cwa->WriteProfileInt(_T("StrEditDoc"),_T("StrEditDoc"),nrcid );
		}
		// load rc file : only interested in font name
		CString csUFMName;
		if (bufm){ // can use just "else "
			CDriverResources* pcdr = new CDriverResources();
			CStringArray csaTemp1, csaTemp2,csaTemp3,csaTemp4,csaTemp5;
			CStringTable cstTemp1, cstFonts, cstTemp2;

			pcdr->LoadRCFile(csrfile , csaTemp1, csaTemp2,csaTemp3,csaTemp4,csaTemp5,
						cstTemp1, cstFonts, cstTemp2,Win2000);

			// get font name
			csUFMName = cstFonts[(WORD)nrcid];
			csUFMName = csPath.Left(csPath.ReverseFind(_T('\\')) + 1) + csUFMName ;
			
			}
		// call the document 
		
		POSITION pos = cwa->GetFirstDocTemplatePosition();
		CString csExtName;
		CDocTemplate *pcdt ;
		while (pos != NULL){
			pcdt = cwa -> GetNextDocTemplate(pos);

			ASSERT (pcdt != NULL);
			ASSERT (pcdt ->IsKindOf(RUNTIME_CLASS(CDocTemplate)));

			pcdt ->GetDocString(csExtName, CDocTemplate::filterExt);
			
			if (csExtName == _T(".UFM") & bufm){
				pcdt->OpenDocumentFile(csUFMName,TRUE);
				return;
			}
			if (csExtName == _T(".STR") & bstring){
				pcdt->OpenDocumentFile(NULL) ;
				return;
			}
		}

	
	}
	else{
		CDriverResources* pcdr = (CDriverResources*) GetDocument()->ModelData()->GetWorkspace() ;
		pcdr->RunEditor(bstring, nrcid) ;
	}
}


/******************************************************************************

  CGPDViewer::OnEditEnableAids

  Reverse the state of the "Editing Aids Enabled" flag and reverse the checked
  status of the corresponding menu command.

******************************************************************************/

void CGPDViewer::OnEditEnableAids()
{
	// Reverse the state of the flag

	m_bEditingAidsEnabled = !m_bEditingAidsEnabled ;

	// Reverse the checked status of the menu command

	CMenu* pcm = AfxGetMainWnd()->GetMenu() ;
	UINT ustate = (m_bEditingAidsEnabled) ? MF_CHECKED : MF_UNCHECKED ;
	pcm->CheckMenuItem(ID_EDIT_ENABLE_AIDS, ustate) ;
}


/******************************************************************************

  CGPDViewer::FreezeREC

  Use a COM interface to the REC to freeze its display if possible.  This is
  the most efficient but it is only possible under Win2K+.  In additon, tell the
  REC to ignore change messages.  This is needed even on Win2K+ because the
  messages are generated even when the REC's display is frozen.

******************************************************************************/

void CGPDViewer::FreezeREC()
{
	GetRichEditCtrl().SetEventMask(GetRichEditCtrl().GetEventMask() &
		~(ENM_CHANGE | ENM_SELCHANGE | ENM_SCROLLEVENTS)) ;
	if(!m_pdoc)//raid 104081: click and start : not call OnInitUpdate()
		InitFreeze(GetRichEditCtrl().m_hWnd, &m_punk, &m_pdoc, &m_lcount) ;
	
	if (ThisApp().m_bOSIsW2KPlus)	
		Freeze(m_pdoc, &m_lcount) ;
}


/******************************************************************************

  CGPDViewer::UnfreezeREC

  Use a COM interface to the REC to unfreeze its display if possible.  This is
  only possible under Win2K+.  In additon, tell the REC to process change
  messages again.  This is needed even on Win2K+ because the messages are 
  always disabled by FreezeREC().

******************************************************************************/

void CGPDViewer::UnfreezeREC()
{
	if (ThisApp().m_bOSIsW2KPlus)
		Unfreeze(m_pdoc, &m_lcount) ;
    GetRichEditCtrl().SetEventMask(GetRichEditCtrl().GetEventMask() |
		ENM_CHANGE | ENM_SELCHANGE | ENM_SCROLLEVENTS) ;
}



// RAID 0001
void CGPDViewer::OnFileInf() 
{
	
	CINFWizard* pciw = new CINFWizard(this, 1) ;
	
	if (pciw->DoModal() == IDCANCEL) {
		delete pciw ;
		return ;
	} ;

	
	// Generate the INF file based on the information collected.

	if (!pciw->GenerateINFFile()) {
		delete pciw ;
		return ;
	} ;

	// Allocate and initialize the document.

    CINFWizDoc* pciwd = new CINFWizDoc((CGPDContainer*) GetDocument(), pciw) ;

	// Create the window.

    CMDIChildWnd* pcmcwnew ;
	CMultiDocTemplate* pcmdt = INFViewerTemplate() ;
	pcmcwnew = (CMDIChildWnd *) pcmdt->CreateNewFrame(pciwd, NULL) ;

	// If the window was created, finish the initialization.  Otherwise, just 
	// return.

    if  (pcmcwnew) {
        pcmdt->InitialUpdateFrame(pcmcwnew, pciwd, TRUE) ;
        pcmdt->AddDocument(pciwd) ;
	} ;

}

 


/*
LRESULT CGPDViewer::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	return 0 ;
}
*/




/////////////////////////////////////////////////////////////////////////////
// CGotoLine dialog


CGotoLine::CGotoLine(CWnd* pParent /*=NULL*/)
	: CDialog(CGotoLine::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGotoLine)
	m_csLineNum = _T("");
	//}}AFX_DATA_INIT

	m_nMaxLine = m_nLineNum = -1 ;
}


void CGotoLine::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGotoLine)
	DDX_Control(pDX, IDC_GotoBox, m_ceGotoBox);
	DDX_Text(pDX, IDC_GotoBox, m_csLineNum);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGotoLine, CDialog)
	//{{AFX_MSG_MAP(CGotoLine)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGotoLine message handlers

void CGotoLine::OnOK()
{
	// Get the line number string.  Complain and exit if there is no line number.

	CString cserror ;
	UpdateData(TRUE) ;
	if (m_csLineNum == _T("")) {
		cserror.Format(IDS_BadGotoLineNum, m_csLineNum) ;
        AfxMessageBox(cserror) ;
		m_ceGotoBox.SetFocus() ;
		return ;
	} ;

	// Convert the line number string to a number.  Complain if the number is
	// invalid or too large.

	m_nLineNum = atoi(m_csLineNum) ;
	if (m_nLineNum < 1 || m_nLineNum > m_nMaxLine) {
		cserror.Format(IDS_BadGotoLineNum, m_csLineNum) ;
        AfxMessageBox(cserror) ;
		m_ceGotoBox.SetFocus() ;
		return ;
	} ;

	// The line number seems ok so...

	CDialog::OnOK();
}




/////////////////////////////////////////////////////////////////////////////
// CErrorLevel dialog


CErrorLevel::CErrorLevel(CWnd* pParent /*=NULL*/)
	: CDialog(CErrorLevel::IDD, pParent)
{
	//{{AFX_DATA_INIT(CErrorLevel)
	m_nErrorLevel = -1;
	//}}AFX_DATA_INIT
}


void CErrorLevel::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CErrorLevel)
	DDX_Control(pDX, IDC_ErrorLevelLst, m_ccbErrorLevel);
	DDX_CBIndex(pDX, IDC_ErrorLevelLst, m_nErrorLevel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CErrorLevel, CDialog)
	//{{AFX_MSG_MAP(CErrorLevel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CErrorLevel message handlers

BOOL CErrorLevel::OnInitDialog()
{
	CDialog::OnInitDialog() ;

	// Blow if the current error level was not set

	ASSERT(m_nErrorLevel != -1) ;
	
	// Set the current error level in the error level list box.

	UpdateData(FALSE) ;
	
	return TRUE ; // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CErrorLevel::OnOK()
{
	// Get the error level selected by the user

	UpdateData() ;
	
	CDialog::OnOK() ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gttview.cpp ===
/******************************************************************************

  Source File:  Glyph Map View.CPP

  This file implements the items that make up the glyph mapping editor

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-20-1997    Bob_Kjelgaard@Prodigy.Net   Created it.

******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "GTT.H"
#include    "ChildFrm.H"
#include    "GTTView.H"
#include    "Resource.H"
#include	"comctrls.h"
#include    "NewProj.H"
#include    <CodePage.H>
#include    "AddCdPt.H"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/******************************************************************************

  CGlyphMapView class implementation

  This is the view class for glyph translation tables.  It presents a property
  sheet for display of all of the relevant items in the glyph map.

******************************************************************************/

IMPLEMENT_DYNCREATE(CGlyphMapView, CView)

CGlyphMapView::CGlyphMapView() {
}

CGlyphMapView::~CGlyphMapView() {
}

BEGIN_MESSAGE_MAP(CGlyphMapView, CView)
	//{{AFX_MSG_MAP(CGlyphMapView)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************

  CGlyphMapView::OnInitialUpdate

  This member function is an override which handles the initial call to display
  the view.  It creates the property sheet, positions it within the view, then
  sets the frame size to match.

******************************************************************************/

void CGlyphMapView::OnInitialUpdate() {

    if  (GetDocument() -> GlyphMap() -> Name().IsEmpty()) {
        GetDocument() -> GlyphMap() -> Rename(GetDocument() -> GetTitle());
        GetDocument() -> SetModifiedFlag(FALSE);    //  Rename sets it
    }

    m_cps.Construct(IDR_MAINFRAME, this);
    m_cgmp.Init(GetDocument() -> GlyphMap());
    m_ccpp.Init(GetDocument() -> GlyphMap());
    m_cpm.Init(GetDocument() -> GlyphMap());
    m_cps.AddPage(&m_cgmp);
    m_cps.AddPage(&m_ccpp);
#if defined(NOPOLLO)    //  RAID 106376
    m_cps.AddPage(&m_cpm);
#endif

    m_cps.Create(this, WS_CHILD, WS_EX_CLIENTEDGE);

    CRect   crPropertySheet;
    m_cps.GetWindowRect(crPropertySheet);

	crPropertySheet -= crPropertySheet.TopLeft();
    m_cps.MoveWindow(crPropertySheet, FALSE);
    GetParentFrame() -> CalcWindowRect(crPropertySheet);
    GetParentFrame() -> SetWindowPos(NULL, 0, 0, crPropertySheet.Width(),
        crPropertySheet.Height(),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE);
	CView::OnInitialUpdate();
    m_cps.ShowWindow(SW_SHOWNA);
    GetParentFrame() -> ShowWindow(SW_SHOW);
}

void CGlyphMapView::OnDraw(CDC* pDC) {
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}


/******************************************************************************

  CGlyphMapView::SaveBothSelAndDeselStrings

  Save both the codepage, Select and the Deselect strings if they have changed.
  This routine is generally called by the document class to make sure this
  data is copied into the GTT before the GTT is saved.

******************************************************************************/

void CGlyphMapView::SaveBothSelAndDeselStrings() 
{
	m_ccpp.SaveBothSelAndDeselStrings() ;
}


/////////////////////////////////////////////////////////////////////////////
// CGlyphMapView diagnostics

#ifdef _DEBUG
void CGlyphMapView::AssertValid() const {
	CView::AssertValid();
}

void CGlyphMapView::Dump(CDumpContext& dc) const {
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapView message handlers

void CGlyphMapView::OnDestroy() {
	CView::OnDestroy();
	
	if  (GetDocument() -> GlyphMap())
        GetDocument() -> GlyphMap() -> OnEditorDestroyed();
	
}

/******************************************************************************

  CGlyphMapView::OnActivateView

  For some reason, the property sheet does not get the focus when the frame is
  activated (probably the view class takes it away from us).  This member
  function guarantees keyboard afficionados aren't perturbed by this.

******************************************************************************/

void CGlyphMapView::OnActivateView(BOOL bActivate, CView* pActivateView,
                                   CView* pDeactiveView) {

	CView::OnActivateView(bActivate, pActivateView, pDeactiveView);

    if  (bActivate)
        m_cps.SetFocus();
}

/******************************************************************************

  CGlyphMappingPage class

  This class implements the property page for viewing and editing the gory code
  point-by-code point details.

******************************************************************************/

//  Even before the constructor, we have the list sorting routine
int CALLBACK    CGlyphMappingPage::MapSorter(LPARAM lp1, LPARAM lp2,
                                             LPARAM lpThis) {
    //  A negative return means the first is less...

    //  First, let's uncast those LPARAMs
    CGlyphMappingPage   *pcgmp = (CGlyphMappingPage *) lpThis;
    CGlyphHandle *pcgh1 = (CGlyphHandle*) lp1;
    CGlyphHandle *pcgh2 = (CGlyphHandle*) lp2;

    //  We'll use 3 columns to store the sort possibilities.
    int aiResult[Columns];
    aiResult[Codes] = pcgh1 -> CodePoint() - pcgh2 -> CodePoint();
    aiResult[Pages] = pcgh1 -> CodePage() - pcgh2 -> CodePage();
    CString cs1, cs2;
    pcgh1 -> GetEncoding(cs1);
    pcgh2 -> GetEncoding(cs2);
    aiResult[Strings] = lstrcmp(cs1, cs2);

    if  (aiResult[pcgmp -> m_bSortFirst])
        return  pcgmp -> m_abDirection[pcgmp -> m_bSortFirst] ?
        aiResult[pcgmp -> m_bSortFirst] : -aiResult[pcgmp -> m_bSortFirst];

    if  (aiResult[pcgmp -> m_bSortSecond])
        return  pcgmp -> m_abDirection[pcgmp -> m_bSortSecond] ?
        aiResult[pcgmp -> m_bSortSecond] : -aiResult[pcgmp -> m_bSortSecond];

    return  pcgmp -> m_abDirection[pcgmp -> m_bSortLast] ?
        aiResult[pcgmp -> m_bSortLast] : -aiResult[pcgmp -> m_bSortLast];
}

/******************************************************************************

  CGlyphMappingPage constructor

  As befits a class of this complexity, there's a bit of work to do here.

******************************************************************************/

CGlyphMappingPage::CGlyphMappingPage() :
    CPropertyPage(CGlyphMappingPage::IDD) {

    m_pcgm = NULL;
    for (unsigned u = 0; u < Columns; u++)
        m_abDirection[u] = TRUE;

    m_bSortFirst = Codes;
    m_bSortSecond = Strings;
    m_bSortLast = Pages;
    m_bJustChangedSelectString = FALSE;
    m_uTimer = m_uidGlyph = 0;

	//{{AFX_DATA_INIT(CGlyphMappingPage)
	//}}AFX_DATA_INIT
}

CGlyphMappingPage::~CGlyphMappingPage() {
}

void CGlyphMappingPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGlyphMappingPage)
	DDX_Control(pDX, IDC_Banner, m_cpcBanner);
	DDX_Control(pDX, IDC_GlyphMapping, m_clcMap);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGlyphMappingPage, CPropertyPage)
	//{{AFX_MSG_MAP(CGlyphMappingPage)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(LVN_ENDLABELEDIT, IDC_GlyphMapping, OnEndlabeleditGlyphMapping)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_GlyphMapping, OnItemchangedGlyphMapping)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_GlyphMapping, OnColumnclickGlyphMapping)
	ON_NOTIFY(LVN_GETDISPINFO, IDC_GlyphMapping, OnGetdispinfoGlyphMapping)
	ON_NOTIFY(LVN_KEYDOWN, IDC_GlyphMapping, OnKeydownGlyphMapping)
	ON_WM_TIMER()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_ChangeInvocation, OnChangeInvocation)
    ON_COMMAND(ID_ChangeCodePage, OnChangeCodePage)
    ON_COMMAND(ID_DeleteItem, OnDeleteItem)
    ON_COMMAND(ID_AddItem, OnAddItem)
END_MESSAGE_MAP()

/******************************************************************************

  CGlyphMappingPage::OnInitDialog

  This member intializes the controls on this page, which in this case means a
  list view with a sizeable numer of items.

******************************************************************************/

BOOL CGlyphMappingPage::OnInitDialog() {
	CPropertyPage::OnInitDialog();
	
	//  Initialize the list control
    CString csWork;

    csWork.LoadString(IDS_MapColumn0);
    m_clcMap.InsertColumn(0, csWork, LVCFMT_LEFT,
        m_clcMap.GetStringWidth(csWork) * 2, 2);

    csWork.LoadString(IDS_MapColumn1);
    m_clcMap.InsertColumn(1, csWork, LVCFMT_LEFT,
        m_clcMap.GetStringWidth(csWork) * 2, 1);

    csWork.LoadString(IDS_MapColumn2);
    m_clcMap.InsertColumn(2, csWork, LVCFMT_LEFT,
        m_clcMap.GetStringWidth(csWork) * 2, 0);

    m_lPredefinedID = m_pcgm -> PredefinedID();

    //  Put up a message about the wait, then kick off a quick timer so the
    //  message is seen...

    m_uTimer = (unsigned)SetTimer(IDD, 100, NULL);

    if  (!m_uTimer) {
        CWaitCursor cwc;
        OnTimer(m_uTimer);
    }

	//LoadCharMapList() ;

	return TRUE;
}

/******************************************************************************

  CGlyphMappingPage::OnContextMenu

  This member function is called when a right-click with the mouse is detected.
  If it is within the area of the list view, we display an appropriate context
  menu.  Otherwise, we default to the normal system handling of the message.

******************************************************************************/

void CGlyphMappingPage::OnContextMenu(CWnd* pcw, CPoint cpt) {
	CPoint  cptThis = cpt;

    m_clcMap.ScreenToClient(&cptThis);

    //  Toss it out if it isn't within the view.

    CRect   crMap;
    m_clcMap.GetClientRect(crMap);
    if  (!crMap.PtInRect(cptThis))
        return;

    cptThis.x = 5;  //  Keep it well within the first column

    int idContext = m_clcMap.HitTest(cptThis);
    if  (idContext == -1) {   //  Nothing selected, allow the "Add" item
        CMenu   cmThis;
        CString csWork;

        cmThis.CreatePopupMenu();
        csWork.LoadString(ID_AddItem);
        cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
        cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y,
            this);

        return;
    }

    m_clcMap.SetItemState(idContext, LVIS_SELECTED | LVIS_FOCUSED,
        LVIS_SELECTED | LVIS_FOCUSED);

    CMenu   cmThis;
    CString csWork;

    cmThis.CreatePopupMenu();
    csWork.LoadString(ID_ChangeInvocation);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_ChangeInvocation,
        csWork);

    if  (m_pcgm -> CodePages() > 1) {
        csWork.LoadString(ID_ChangeCodePage);
        cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_ChangeCodePage,
            csWork);
    }

    cmThis.AppendMenu(MF_SEPARATOR);
    csWork.LoadString(ID_AddItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_AddItem, csWork);
    csWork.LoadString(ID_DeleteItem);
    cmThis.AppendMenu(MF_STRING | MF_ENABLED, ID_DeleteItem,
        csWork);

    cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cpt.x, cpt.y, this);
}

/******************************************************************************

  CGlyphMappingPage::OnChangeInvocation

  Called when the user decides to change the invocation for the code point.
  Simply initiate a label edit.

******************************************************************************/

void    CGlyphMappingPage::OnChangeInvocation() {
    int idContext = m_clcMap.GetNextItem(-1,
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    if  (idContext < 0 || idContext >= m_clcMap.GetItemCount())
        return;

    m_clcMap.EditLabel(idContext);
}

/******************************************************************************

  CGlyphMappingPage::OnChangeCodePage

  This handles a code page change request.

******************************************************************************/

void    CGlyphMappingPage::OnChangeCodePage() {

    int idContext = m_clcMap.GetNextItem(-1,
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    if  (idContext < 0 || idContext >= m_clcMap.GetItemCount())
        return;
    //  Create a string naming the item, and invoke the CSelectCodePage
    //  dialog...

    CGlyphHandle *pcgh = (CGlyphHandle*) m_clcMap.GetItemData(idContext);

    CSelectCodePage cscp(this, m_pcgm -> Name() + _TEXT(" ") +
        m_clcMap.GetItemText(idContext, 1),
        m_pcgm -> PageID(pcgh -> CodePage()));

    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);
    cdaPages.RemoveAt(pcgh -> CodePage());

    cscp.LimitTo(cdaPages);

    if  (cscp.DoModal() != IDOK)
        return;

    //  Change the code page.   For maximum flexibility, we'll use an array
    //  for this.  This is because if this is to correct a perceived mistake,
    //  the codes should be translated to MBCS and then back.

    //  NOTE: This was also to support multiple selection, which isn't allowed.

    CPtrArray   cpaThis;
    cpaThis.Add((void *) m_clcMap.GetItemData(idContext));
    m_pcgm -> ChangeCodePage(cpaThis, cscp.SelectedCodePage());

    m_clcMap.SetItemText(idContext, 2, cscp.GetCodePageName());
}

/******************************************************************************

  CGlyphMappingPage::OnDeleteItem

  This handles the Delete Item message from the context menu, by verifying
  this is what is wanted, and then doing it.

******************************************************************************/

void    CGlyphMappingPage::OnDeleteItem() {
    int idContext = m_clcMap.GetNextItem(-1,
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    if  (idContext < 0 || idContext >= m_clcMap.GetItemCount())
        return;

    if  (IDYES != AfxMessageBox(IDS_DeleteItemQuery,
         MB_YESNO | MB_ICONQUESTION))
        return;

    //  Delete the entry from the glyph map
    CGlyphHandle*   pcgh = (CGlyphHandle*) m_clcMap.GetItemData(idContext);
    m_pcgm -> DeleteGlyph(pcgh -> CodePoint());

    m_clcMap.DeleteItem(idContext);
    _ASSERTE((unsigned) m_clcMap.GetItemCount() == m_pcgm -> Glyphs());
}

/******************************************************************************

  CGlyphMappingPage::OnAddItem

  This is called whenever the user wishes to add new code points to the map.  I
  ask the glyph map which points exist, and if there are any, invoke a modal
  dialog to allow the selection of new glyphs.

******************************************************************************/

void    CGlyphMappingPage::OnAddItem() {

    CMapWordToDWord cmw2dAvailable;

    m_pcgm -> UndefinedPoints(cmw2dAvailable);

    if  (!cmw2dAvailable.Count()) {
        AfxMessageBox(IDS_NoUnmappedGlyphs);
        return;
    }

    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);

    CAddCodePoints  cacp(this, cmw2dAvailable, cdaPages, m_pcgm -> Name());

    if  (cacp.DoModal() != IDOK)    return;

    //  The map will now contain only the new code points...
    m_pcgm -> AddPoints(cmw2dAvailable);

    m_uTimer = (unsigned) SetTimer(IDD, 10, NULL);

    if  (!m_uTimer)
        OnTimer(m_uTimer);

    //  Reset the sort criteria so we don't have to sort the data
    for (unsigned u = 0; u < Columns; u++)
        m_abDirection[u] = TRUE;

    m_bSortFirst = Codes;
    m_bSortSecond = Strings;
    m_bSortLast = Pages;
}


/******************************************************************************

  CGlyphMappingPage::OnEndlabeleditGlyphMapping

  This is called when a user clicks outside the edit control to end editing of
  a selection string.  We pass the string down, and do some finagling to force
  the system to accept the value as we display it, which isn't as the user
  typed it, in some cases.

******************************************************************************/

void CGlyphMappingPage::OnEndlabeleditGlyphMapping(NMHDR* pnmh, LRESULT* plr) 
{
	LV_DISPINFO* plvdi = (LV_DISPINFO*) pnmh;

	// Pass the new invocation string to the glyph map to handle
    CGlyphHandle*   pcgh = (CGlyphHandle*) plvdi -> item.lParam;
    m_pcgm -> ChangeEncoding(pcgh -> CodePoint(), plvdi -> item.pszText);

    m_bJustChangedSelectString = TRUE;
	
	*plr = TRUE;
}


/******************************************************************************

  CGlyphMappingPage::OnItemchangedGlyphMapping

  This is called whenever anything changes in the list box- we are primarily
  interested in text changes (since we have to adjust encodings once entered)
  and selection changes (so we can move the "cursor" accordingly.

******************************************************************************/

void CGlyphMappingPage::OnItemchangedGlyphMapping(NMHDR* pnmh, LRESULT* plr) 
{
	NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;

    int idContext = m_clcMap.GetNextItem(-1,
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

    //  We only care if this notes a text change in the selected item and we
    //  haven't fixed it, yet.

    if  (pnmlv -> iItem != idContext || !(pnmlv -> uChanged & LVIF_TEXT) ||
        !m_bJustChangedSelectString)
        return;

    CGlyphHandle*   pcgh = (CGlyphHandle*) m_clcMap.GetItemData(idContext);

    CString csWork;
    m_bJustChangedSelectString = FALSE;
    pcgh -> GetEncoding(csWork);
    m_clcMap.SetItemText(idContext, 0, csWork);
	
	*plr = 0;
}


/******************************************************************************

  CGlyphMappingPage::OnColumnclickGlyphMapping

  Called when the user wants to sort the list- so that's what we do!

******************************************************************************/

void CGlyphMappingPage::OnColumnclickGlyphMapping(NMHDR* pnmh, LRESULT* plr) {
	NM_LISTVIEW* pnmlv = (NM_LISTVIEW*) pnmh;
	//  Resort the list based upon the selected column, and the current sort
    //  order

    if  (pnmlv -> iSubItem == m_bSortFirst)
        m_abDirection[m_bSortFirst] = !m_abDirection[m_bSortFirst]; //  Reverse
    else {
        if  (pnmlv -> iSubItem == m_bSortSecond)
            m_bSortSecond = m_bSortFirst;
        else {
            m_bSortLast = m_bSortSecond;
            m_bSortSecond = m_bSortFirst;
        }
        m_bSortFirst = (BYTE)pnmlv -> iSubItem;
    }

    CWaitCursor cwc;    //  On FE tables, this can take a while...

    m_clcMap.SortItems(&MapSorter, (UINT_PTR) this);
	
	*plr = 0;
}


void CGlyphMappingPage::LoadCharMapList()
{
	CWaitCursor cwc ;
    m_clcMap.EnableWindow(FALSE) ;

    CGlyphHandle* pcgh ;
    int idItem ;
    CString csWork ;

    for (unsigned u = 0 ; m_uidGlyph < m_pcgm -> Glyphs() ; u++, m_uidGlyph++) {
        pcgh = m_pcgm->Glyph(m_uidGlyph) ;

        if(pcgh != NULL)
			pcgh->GetEncoding(csWork) ;
        else
		{
			AfxMessageBox(IDS_LoadGTTError);//raid 116604 prefix : this fucntion(LoadCharMapList) are dead
			return ;
		} ;

        idItem = m_clcMap.InsertItem(m_uidGlyph, csWork) ;
        m_clcMap.SetItemData(idItem, (LPARAM) pcgh) ;

        csWork.Format(_TEXT("0x%4.4X"), pcgh->CodePoint()) ;
        m_clcMap.SetItem(idItem, 1, LVIF_TEXT, csWork, -1, 0, 0, u) ;

        csWork = m_pcgm->PageName(pcgh->CodePage()) ;
        m_clcMap.SetItem(idItem, 2, LVIF_TEXT, csWork, -1, 0, 0, u) ;
    }

    m_clcMap.EnableWindow(TRUE) ;
	m_cpcBanner.SetPos(0) ;
	m_cpcBanner.ShowWindow(SW_HIDE) ;
}


/******************************************************************************

  CGlyphMappingPage::OnGetdispinfoGlyphMapping

  This member function is an attempt to speed handling of large tables, and
  also to handle code page changes more gracefully.  All items are initially
  declared as callbacks, so the control requests names for items as they are
  displayed, via this member.

******************************************************************************/

void CGlyphMappingPage::OnGetdispinfoGlyphMapping(NMHDR* pnmh, LRESULT* plr) {
	LV_DISPINFO* plvdi = (LV_DISPINFO*) pnmh;
	
	*plr = 0;

    //  If the window is obstructed when an item is deleted, there might not
    //  be a glpyh at this point, so watch out!

    CGlyphHandle*   pcgh = (CGlyphHandle*) plvdi -> item.lParam;
    if  (!pcgh)
        return;

    CString csWork;

    switch  (plvdi -> item.iSubItem) {
        case    0:
             pcgh -> GetEncoding(csWork);
            break;

        case    1:
            csWork.Format(_TEXT("0x%4.4X"), pcgh -> CodePoint());
            plvdi -> item.mask |= LVIF_DI_SETITEM;  //  This never changes
            break;

        case    2:
            csWork = m_pcgm -> PageName(pcgh -> CodePage());
    }

    lstrcpyn(plvdi -> item.pszText, csWork, plvdi -> item.cchTextMax);
}

/******************************************************************************

  CGlyphMappingPage::OnSetActive

  Called when the page is activated, but after OnInitDialog on the first
  activation.  If the predefined code page ID has changed, we must rebuild the
  page.

******************************************************************************/
// //raid 118880
BOOL CGlyphMappingPage::OnSetActive() {

      m_lPredefinedID = m_pcgm -> PredefinedID();
      m_uTimer = (unsigned) SetTimer(IDD, 10, NULL);

	  m_clcMap.DeleteAllItems();
	  OnTimer(m_uTimer);  

	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CGlyphMappingPage::OnKeydownGlyphMapping

  This is called whenever the user presses a key.  We use it to provide an
  extended interface from the keyboard, to match the other editors.

******************************************************************************/

void    CGlyphMappingPage::OnKeydownGlyphMapping(NMHDR* pnmh, LRESULT* plr)
{
	LV_KEYDOWN* plvkd = (LV_KEYDOWN*)pnmh;

    if (plvkd->wVKey == VK_F1) {
		AfxGetApp()->WinHelp(HID_BASE_RESOURCE + IDR_GLYPHMAP) ;
		return ;
	} ;

	*plr = 0;

    int idItem = m_clcMap.GetNextItem(-1, LVIS_FOCUSED | LVIS_SELECTED);

    if  (idItem == -1) {
        if  (plvkd -> wVKey == VK_F10)
            OnAddItem();
        return;
    }

    switch  (plvkd -> wVKey) {

    case    VK_F2:
        OnChangeInvocation();
        break;

    case    VK_DELETE:
        OnDeleteItem();
        break;

    case    VK_F10: {
            CRect   crItem;

            m_clcMap.GetItemRect(idItem, crItem, LVIR_LABEL);
            m_clcMap.ClientToScreen(crItem);
            OnContextMenu(&m_clcMap, crItem.CenterPoint());
        }
    }
}

/******************************************************************************

  CGlhpyMappingPage::OnTimer

  The only event currently using a timer is the need to fill the list.

******************************************************************************/

void    CGlyphMappingPage::OnTimer(UINT uEvent) {
    if  (uEvent != m_uTimer) {
	    CPropertyPage::OnTimer(uEvent);
        return;
    }

    CString csWork;

    if  (m_uTimer)
        ::KillTimer(m_hWnd, m_uTimer);

    if  (!m_uidGlyph) {
        m_clcMap.DeleteAllItems();
        m_cpcBanner.SetRange(0, m_pcgm -> Glyphs() -1);
        m_cpcBanner.SetStep(1);
        m_cpcBanner.SetPos(0);
        m_cpcBanner.ShowWindow(SW_SHOW);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        if  (m_uTimer)
            m_clcMap.EnableWindow(FALSE);
        else
            m_clcMap.LockWindowUpdate();
        m_clcMap.SetItemCount(m_pcgm -> Glyphs());
    }

    for (unsigned u = 0;
         m_uidGlyph < m_pcgm -> Glyphs() && (!m_uTimer || u < 100);
         u++, m_uidGlyph++) {

        CGlyphHandle*   pcgh = m_pcgm -> Glyph(m_uidGlyph);

        int idItem = m_clcMap.InsertItem(m_uidGlyph, LPSTR_TEXTCALLBACK);
        m_clcMap.SetItemData(idItem, (LPARAM) pcgh);

        m_clcMap.SetItem(idItem, 1, LVIF_TEXT, LPSTR_TEXTCALLBACK, -1, 0, 0,
            (LPARAM) pcgh);
        m_clcMap.SetItem(idItem, 2, LVIF_TEXT, LPSTR_TEXTCALLBACK, -1, 0, 0,
            (LPARAM) pcgh);
    }

    if  (m_uidGlyph == m_pcgm -> Glyphs()) {
        if  (m_uTimer)
            m_clcMap.EnableWindow(TRUE);
        else
            m_clcMap.UnlockWindowUpdate();
        m_uTimer = 0;
        m_cpcBanner.SetPos(0);
        m_cpcBanner.ShowWindow(SW_HIDE);
        SetFocus();
        m_uidGlyph = 0;
    }

    if  (m_uTimer) {
        m_cpcBanner.SetPos(m_uidGlyph);
        csWork.LoadString(IDS_WaitToFill);
        CDC *pcdc = m_cpcBanner.GetDC();
        CRect   crBanner;
        m_cpcBanner.GetClientRect(crBanner);
        pcdc -> SetBkMode(TRANSPARENT);
        pcdc -> DrawText(csWork, crBanner, DT_CENTER | DT_VCENTER);
        m_cpcBanner.ReleaseDC(pcdc);
        m_uTimer = (unsigned) SetTimer(IDD, 10, NULL);
        if  (!m_uTimer) {
            CWaitCursor cwc;    //  Might be a while...
            m_clcMap.EnableWindow(TRUE);
            m_clcMap.LockWindowUpdate();
            OnTimer(m_uTimer);
        }
    }
}

/******************************************************************************

  CGlyphMappingPage::OnDestroy

  Since this also can be time-consuming, kill the list here, and throw up the
  wait cursor.

******************************************************************************/

void    CGlyphMappingPage::OnDestroy() {
    CWaitCursor cwc;
    if  (m_uTimer)
        ::KillTimer(m_hWnd, m_uTimer);
    m_clcMap.DeleteAllItems();
	CPropertyPage::OnDestroy();	
}


/******************************************************************************

  CCodePagePage class implementation

  This class implements the code page property page, providing an interface for
  viewing and implementing the code page assignments.

******************************************************************************/

CCodePagePage::CCodePagePage() : CToolTipPage(CCodePagePage::IDD) 
{
	//{{AFX_DATA_INIT(CCodePagePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_uHelpID = HID_BASE_RESOURCE + IDR_GLYPHMAP ;
	m_bInitialized = false ;
	m_bSelDeselChgSignificant = true ;
}


CCodePagePage::~CCodePagePage() {
}

void CCodePagePage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCodePagePage)
	DDX_Control(pDX, IDC_DeletePage, m_cbDelete);
	DDX_Control(pDX, IDC_SelectString, m_ceSelect);
	DDX_Control(pDX, IDC_DeselectString, m_ceDeselect);
	DDX_Control(pDX, IDC_RemovePage, m_cbRemove);
	DDX_Control(pDX, IDC_CodePageList, m_clbPages);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCodePagePage, CToolTipPage)
	//{{AFX_MSG_MAP(CCodePagePage)
	ON_EN_KILLFOCUS(IDC_SelectString, OnKillfocusSelectString)
	ON_EN_KILLFOCUS(IDC_DeselectString, OnKillfocusDeselectString)
	ON_BN_CLICKED(IDC_AddPage, OnAddPage)
	ON_LBN_SELCHANGE(IDC_CodePageList, OnSelchangeCodePageList)
	ON_BN_CLICKED(IDC_RemovePage, OnReplacePage)
	ON_EN_CHANGE(IDC_SelectString, OnChangeSelectString)
	ON_EN_CHANGE(IDC_DeselectString, OnChangeDeselectString)
	ON_BN_CLICKED(IDC_DeletePage, OnDeletePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/******************************************************************************

  CCodePagePage::OnInitDialog

  This member function handles the WM_INITDIALOG message by initializing the
  various controls of the dialog.

******************************************************************************/

BOOL CCodePagePage::OnInitDialog() {
	CToolTipPage::OnInitDialog();

    for (unsigned u = 0; u < m_pcgm -> CodePages(); u++) {
        int id =
            m_clbPages.AddString(m_pcgm -> PageName(u));
        m_clbPages.SetItemData(id, u);
        if  (!u)
            m_clbPages.SetCurSel(id);
    }

    //  Let the list box selection change handler do the rest

    OnSelchangeCodePageList();
	
	m_bInitialized = true ;
	return TRUE;
}


/******************************************************************************

  CCodePagePage::OnChangeSelectString

  Mark the GTT dirty to make sure the new string is saved.

******************************************************************************/

void CCodePagePage::OnChangeSelectString() 
{
	// Only mark the GTT as having changed when this function is called after
	// the GTT Editor and only if this change in the selection string is 
	// significant.  Do nothing when the string change is just because a 
	// previously entered string is being loaded into the control.

	if (m_bInitialized && m_bSelDeselChgSignificant)
		m_pcgm->Changed() ;
}


/******************************************************************************

  CCodePagePage::OnChangeDeselectString

  Mark the GTT dirty to make sure the new string is saved.

******************************************************************************/

void CCodePagePage::OnChangeDeselectString() 
{
	// Only mark the GTT as having changed when this function is called after
	// the GTT Editor and only if this change in the deselection string is 
	// significant.  Do nothing when the string change is just because a 
	// previously entered string is being loaded into the control.

	if (m_bInitialized && m_bSelDeselChgSignificant)
		m_pcgm->Changed() ;
}


/******************************************************************************

  CCodePagePage::OnKillfocusSelectString

  Save the Select String if it has changed.

******************************************************************************/

void CCodePagePage::OnKillfocusSelectString() 
{
	SaveSelDeselString(m_ceSelect, TRUE) ;
}


/******************************************************************************

  CCodePagePage::OnKillfocusDeselectString

  Save the Deselect String if it has changed.

******************************************************************************/

void CCodePagePage::OnKillfocusDeselectString() 
{
	SaveSelDeselString(m_ceDeselect, FALSE) ;
}


/******************************************************************************

  CCodePagePage::SaveBothSelAndDeselStrings

  Save both the Select and the Deselect strings if they have changed.

******************************************************************************/

void CCodePagePage::SaveBothSelAndDeselStrings() 
{
	SaveSelDeselString(m_ceSelect, TRUE) ;
	SaveSelDeselString(m_ceDeselect, FALSE) ;
}


/******************************************************************************

  CCodePagePage::SaveSelDeselString

  This function is called to update the GTT when the Selection or Deselection
  string may have changed.  Check to see if the control really was modified, and
  if it is, update the structure accordingly.  Then flag the control as 
  unmodified.

******************************************************************************/

void CCodePagePage::SaveSelDeselString(CEdit &cesd, BOOL bselstr)
{
	// Do nothing if the control has not been modified.

	if  (!cesd || !cesd.GetModify())
        return ;

    // Get the new sel/desel string.

	CString csWork ;
    cesd.GetWindowText(csWork) ;

	// Save the sel/desel string as determined by bselstr.  (Note: 
	// SetInvocation() sets the GTT's changed flag, too.)

    m_pcgm -> SetInvocation(
		(unsigned)m_clbPages.GetItemData(m_clbPages.GetCurSel()), csWork, 
		bselstr) ;

	// Clear the control's modified flag.

    cesd.SetModify(FALSE) ;

	// Now make sure that the string is displayed correctly.

    m_pcgm -> Invocation(
		(unsigned)m_clbPages.GetItemData(m_clbPages.GetCurSel()), csWork,
        bselstr) ;
    cesd.SetWindowText(csWork) ;
}


/******************************************************************************

  CCodePagePage::OnAddPage

  This is an event handler for the pressing of the "Add Page" button.  We invoke
  the Select Code Page dialog, and if a new page is selected, we add it to the
  list of pages that are available.

******************************************************************************/

void CCodePagePage::OnAddPage() {
    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);
    CSelectCodePage cscp(this, m_pcgm -> Name(), 0);
    cscp.Exclude(cdaPages);
	
    if  (cscp.DoModal() != IDOK)
        return;

    m_pcgm -> AddCodePage(cscp.SelectedCodePage());
    int id =
        m_clbPages.AddString(m_pcgm -> PageName(m_pcgm -> CodePages() - 1));
    m_clbPages.SetItemData(id, m_pcgm -> CodePages() -1);
    m_clbPages.SetCurSel(id);
    //  Let OnSelchangeCodePageList do the rest (that's what happened, eh?)
    OnSelchangeCodePageList();
    m_ceSelect.SetFocus();  //  A friendly place to leave it...
}


/******************************************************************************

  CCodePagePage::OnSelchangeCodePageList

  This member function handles changes in the selected code page.  It fills
  the edit controls for the selected page's name, selection and deselection
  strings, and handles enabling of the "Remove Page" button (this message
  could mean nothing is now selected...)

  Make sure that the operations of this function do not mark the GTT dirty.

******************************************************************************/

void CCodePagePage::OnSelchangeCodePageList() 
{
	m_bSelDeselChgSignificant = false ;

    int id = m_clbPages.GetCurSel();

    if  (id < 0) {
        m_ceSelect.SetWindowText(_T(""));
        m_ceDeselect.SetWindowText(_T(""));
        m_cbRemove.EnableWindow(FALSE);
	m_cbDelete.EnableWindow(FALSE);
        m_ceSelect.EnableWindow(FALSE);
        m_ceDeselect.EnableWindow(FALSE);
		m_bSelDeselChgSignificant = true ;
        return;
    }
	
    unsigned u = (unsigned)m_clbPages.GetItemData(id);

    SetDlgItemText(IDC_CurrentPage, m_pcgm -> PageName(u));

    CString csWork;

    m_pcgm -> Invocation(u, csWork, TRUE);
    m_ceSelect.SetWindowText(csWork);
    m_pcgm -> Invocation(u, csWork, FALSE);
    m_ceDeselect.SetWindowText(csWork);

    m_cbRemove.EnableWindow(m_pcgm -> CodePages() > 1);
	m_cbDelete.EnableWindow(m_pcgm -> CodePages() > 1);	// r118880
    m_ceSelect.EnableWindow();
    m_ceDeselect.EnableWindow();
	m_bSelDeselChgSignificant = true ;
}


/******************************************************************************

  CCodePagePage::OnReplacePage

  This handles the Remove Page button.  Not much to it, here- we just tell the
  glyph map what we want done.

******************************************************************************/

void CCodePagePage::OnReplacePage() {
	
    int id = m_clbPages.GetCurSel();

    if  (id < 0 || m_clbPages.GetCount() < 2)
        return;

    unsigned u = (unsigned)m_clbPages.GetItemData(id);

    //  Query for code page to map this one to

    CSelectCodePage cscp(this,
        CString(_TEXT("Replacing ")) + m_pcgm -> PageName(u), 0);

    CDWordArray cdaPages;

    m_pcgm -> CodePages(cdaPages);

    cdaPages.RemoveAt(u);

    cscp.LimitTo(cdaPages);

    if  (cscp.DoModal() != IDOK)
        return;

    for (unsigned uTo = 0; uTo < m_pcgm -> CodePages(); uTo++)
        if  (m_pcgm -> PageID(uTo) == cscp.SelectedCodePage())
            break;

    _ASSERTE(uTo < (unsigned) m_pcgm -> CodePages());

    if  (!m_pcgm -> RemovePage(u, uTo))
        return;

    //  Flush the list box and then refill it.

    m_clbPages.ResetContent();

    for (u = 0; u < m_pcgm -> CodePages(); u++) {
        int id = m_clbPages.AddString(m_pcgm -> PageName(u));
        m_clbPages.SetItemData(id, u);
    }

    //  Select whoever moved into our position, then update the rest

    m_clbPages.SetCurSel(id < m_clbPages.GetCount() ? id : id - 1);

	OnSelchangeCodePageList();
}



/******************************************************************************
//raid 118880
   CCodePagePage::OnDeletePage

  message handler :Delete code page when user push delete button 
	
  logic : get page id of selected code  -> get codepage id from Glyphmap ->
			call pcgm-> DeleteCodePage: actual part of deleting -> reset list box

********************************************************************************/
void CCodePagePage::OnDeletePage() 
{

	int id = m_clbPages.GetCurSel();

    if  (id < 0 || m_clbPages.GetCount() < 2)
        return;

    unsigned CodePageID = (unsigned)m_clbPages.GetItemData(id);

	// Actual delete call
	
	if (!m_pcgm -> RemovePage(CodePageID,CodePageID, TRUE))
		return;

    //  Flush the list box and then refill it.

    m_clbPages.ResetContent();

    for (unsigned u = 0; u < m_pcgm -> CodePages(); u++) {
        int id = m_clbPages.AddString(m_pcgm -> PageName(u));
        m_clbPages.SetItemData(id, u);
    }

    //  Select whoever moved into our position, then update the rest

    m_clbPages.SetCurSel(id < m_clbPages.GetCount() ? id : id - 1);

	OnSelchangeCodePageList();

}

/******************************************************************************

  CPredefinedMaps   class

  This implements the class which handles the page for pre-defined mappings
  in a GTT file.

******************************************************************************/

CPredefinedMaps::CPredefinedMaps() : CPropertyPage(CPredefinedMaps::IDD) {
	//{{AFX_DATA_INIT(CPredefinedMaps)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPredefinedMaps::~CPredefinedMaps() {
}

void CPredefinedMaps::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPredefinedMaps)
	DDX_Control(pDX, IDC_PredefinedList, m_clbIDs);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPredefinedMaps, CPropertyPage)
	//{{AFX_MSG_MAP(CPredefinedMaps)
	ON_BN_CLICKED(IDC_Overstrike, OnOverstrike)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPredefinedMaps message handlers

/******************************************************************************

  CPredefinedMaps::OnInitDialog

  This override handles the WM_INITDIALOG message by initializing the various
  controls.

******************************************************************************/

BOOL CPredefinedMaps::OnInitDialog() {
	CPropertyPage::OnInitDialog();

    //  Fill the list box- first, with none, then with the defined IDs

    CString csWork;

    csWork.LoadString(IDS_NoPredefined);
    m_clbIDs.AddString(csWork);
    if  (m_pcgm -> PredefinedID()== CGlyphMap::NoPredefined)
        m_clbIDs.SetCurSel(0);
    m_clbIDs.SetItemData(0, CGlyphMap::NoPredefined);
	
    for (int i = CGlyphMap::Wansung; i < 1; i++) {
        csWork.LoadString(IDS_DefaultPage + i);
        if  (csWork.IsEmpty())
            continue;
        int id = m_clbIDs.AddString(csWork);
        m_clbIDs.SetItemData(id, i);
        if  (i == m_pcgm -> PredefinedID())
            m_clbIDs.SetCurSel(i);
    }

    m_clbIDs.SetTopIndex(m_clbIDs.GetCurSel());

    CheckDlgButton(IDC_Overstrike, m_pcgm -> OverStrike());
    	
	return TRUE;  // return TRUE unless you set the focus to a control
}

/******************************************************************************

  CPredefinedMaps::OnKillActive

  This is called when we leave the page.  Since changing pages can be very
  time-consuming, we only check when you leave, not every time the selection
  changes.  Occasionally even my aged brain works.

******************************************************************************/

BOOL    CPredefinedMaps::OnKillActive() {
	
    if  (m_clbIDs.GetCurSel() >= 0)
        m_pcgm -> UsePredefined((unsigned)m_clbIDs.GetItemData(m_clbIDs.GetCurSel()));

    return CPropertyPage::OnKillActive();
}

/******************************************************************************

  CPredefinedMaps::OnOverstrike

  Called when the user clicks the check box for enabling / disabling overstrike

******************************************************************************/

void    CPredefinedMaps::OnOverstrike() {	
    m_pcgm -> OverStrike(IsDlgButtonChecked(IDC_Overstrike));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gtt.h ===
/******************************************************************************

  Header File:  Glyph Translation.H

  These classes define the mapping used from a Unicode or ANSI character to a
  character sequence to render said character on a printer.  They are content
  equivalent to the CTT, RLE and GTT formats used in the various flavors of the
  mini-driver architecture.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-13-97  Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(GLYPH_TRANSLATION)

#define GLYPH_TRANSLATION

#if defined(LONG_NAMES)
#include    "Project Node.H"
#else
#include    "ProjNode.H"
#endif

//  Win16 CTT formats- since these can't change, I've recoded them to suit.
//  Good thing, too- the mapping of direct was bogus- the union implies a word
//  aligned structure, but the fact is that direct data is byte-aligned.
class CInvocation : public CObject {
    CByteArray  m_cbaEncoding;
    DWORD       m_dwOffset;
    DECLARE_SERIAL(CInvocation)

    void        Encode(BYTE c, CString& cs) const;

public:

    CInvocation() {}
    void        Init(PBYTE pb, unsigned ucb);

    unsigned    Length() const { return (int)m_cbaEncoding.GetSize(); }
    const unsigned  Size() const { return 2 * sizeof m_dwOffset; }

    void    GetInvocation(CString& csReturn) const;

    BYTE    operator[](unsigned u) const {
        return u < Length() ? m_cbaEncoding[u] : 0;
    }

    CInvocation&    operator =(CInvocation& ciRef) {
        m_cbaEncoding.Copy(ciRef.m_cbaEncoding);
        return  *this;
    }

    void    SetInvocation(LPCTSTR lpstrNew);
    void    NoteOffset(DWORD& dwOffset);
    void    WriteSelf(CFile& cfTarget) const;
    void    WriteEncoding(CFile& cfTarget, BOOL bWriteLength = FALSE) const;
    virtual void    Serialize(CArchive& car);
};

//  The following class handles glyph handles and all associated details

class   CGlyphHandle : public CObject {

    CInvocation m_ciEncoding;
    DWORD       m_dwCodePage, m_dwidCodePage, m_dwOffset;
    WORD        m_wIndex;
    WORD        m_wCodePoint;   //  Unicode Representation of the glyph
    WORD        m_wPredefined;

public:
	CGlyphHandle() ;
	
    //  Atributes

    const unsigned  RLESize() const { return sizeof m_dwCodePage; }
    unsigned    CodePage() const { return m_dwidCodePage; } //  Only ID matters
    WORD        CodePoint() const { return m_wCodePoint; }

    unsigned    CompactSize() const;

    unsigned    MaximumSize() const {
        return  CompactSize() ?
            sizeof m_wIndex + ((CompactSize() + 1) & ~1) : 0;
    }

    void        GetEncoding(CString& csWhere) {
        m_ciEncoding.GetInvocation(csWhere);
    }

    enum {Modified, Added, Removed};
    WORD    Predefined() const { return m_wPredefined; }
    BOOL    operator ==(CGlyphHandle& cghRef);
    BOOL    PairedRelevant() const { return m_ciEncoding.Length() == 2; }

    //  Operations

    void    Init(BYTE b, WORD wIndex, WORD wCode);
    void    Init(BYTE ab[2], WORD wIndex, WORD wCode);
    void    Init(PBYTE pb, unsigned ucb, WORD wIndex, WORD wCode);

    CGlyphHandle&   operator =(CGlyphHandle& cghTemplate);

    void    RLEOffset(DWORD& dwOffset, const BOOL bCompact);
    void    GTTOffset(DWORD& dwOffset, BOOL bPaired);

    void    SetCodePage(DWORD dwidPage, DWORD dwNewPage) {
        m_dwCodePage = dwNewPage;
        m_dwidCodePage = dwidPage;
    }

    void    NewEncoding(LPCTSTR lpstrNew) {
        m_ciEncoding.SetInvocation(lpstrNew);
    }

    void    SetPredefined(WORD wNew) { m_wPredefined = wNew; }

    //  These write our contents for mini-driver files- they will throw
    //  exceptions on failure, so use an exception handler to handle errors

    void    WriteRLE(CFile& cfTarget, WORD wFormat) const;
    void    WriteGTT(CFile& cfTarget, BOOL bPredefined) const;

    enum    {GTT, RLEBig, RLESmall};    //  Desired encoding format
    void    WriteEncoding(CFile& cfTarget, WORD wfHow) const;
};

//  The next class maintains a record of the runs in the glyph set. It
//  generates and merges instances of itself as glyphs are added to the map.

class CRunRecord {
    WORD        m_wFirst, m_wcGlyphs;
    DWORD       m_dwOffset;    //  These are the image...
    CRunRecord  *m_pcrrNext, *m_pcrrPrevious;

    CPtrArray   m_cpaGlyphs;

    CRunRecord(CGlyphHandle *pcgh, CRunRecord* pcrrPrevious);
    CRunRecord(CRunRecord* crrPrevious, WORD wWhere);
    CRunRecord(CRunRecord* pcrrPrevious);

    CGlyphHandle&   Glyph(unsigned u) {
        return *(CGlyphHandle *) m_cpaGlyphs[u];
    }

    const CGlyphHandle& GlyphData(unsigned u) const {
        return *(CGlyphHandle *) m_cpaGlyphs[u];
    }

public:

    CRunRecord();
    ~CRunRecord();

    unsigned        Glyphs() const { return m_wcGlyphs; }
    unsigned        TotalGlyphs() const;
    BOOL            MustCompose() const;
    unsigned        RunCount() const {
        return 1 + (m_pcrrNext ? m_pcrrNext -> RunCount() : 0);
    }

    WORD            First() const { return m_wFirst; }
    WORD            Last() const {
        return m_pcrrNext ? m_pcrrNext ->Last() : -1 + m_wFirst + m_wcGlyphs;
    }

    unsigned        ExtraNeeded(BOOL bCompact = TRUE);

    const unsigned  Size(BOOL bRLE = TRUE) const {
        return  sizeof m_dwOffset << (unsigned) (!!bRLE);
    }

    void    Collect(CPtrArray& cpaGlyphs) const {
        cpaGlyphs.Append(m_cpaGlyphs);
        if  (m_pcrrNext)    m_pcrrNext -> Collect(cpaGlyphs);
    }

    CGlyphHandle*   GetGlyph(unsigned u ) const;

#if defined(_DEBUG) //  While the linkage code seems to check out, keep this
                    //  around in case of later problems
    BOOL    ChainIntact() {
        _ASSERTE(m_wcGlyphs == m_cpaGlyphs.GetSize());
        for (unsigned u = 0; u < Glyphs(); u++) {
            _ASSERTE(Glyph(u).CodePoint() == m_wFirst + u);
        }
        return  !m_pcrrNext || m_pcrrNext -> m_pcrrPrevious == this &&
            m_pcrrNext -> ChainIntact();
    }
#endif

    //  Operations

    void    Add(CGlyphHandle *pcgh);
    void    Delete(WORD wCodePoint);
    void    Empty();

    void    NoteOffset(DWORD& dwOffset, BOOL bRLE, BOOL bPaired);
    void    NoteExtraOffset(DWORD& dwOffset, const BOOL bCompact);

    //  File output operations

    void    WriteSelf(CFile& cfTarget, BOOL bRLE = TRUE) const;
    void    WriteHandles(CFile& cfTarget, WORD wFormat) const;
    void    WriteMapTable(CFile& cfTarget, BOOL bPredefined) const;
    void    WriteEncodings(CFile& cfTarget, WORD wfHow) const;
};

class CCodePageData : public CObject {
    DWORD   m_dwid;
    CInvocation  m_ciSelect, m_ciDeselect;

public:

    CCodePageData() { m_dwid = 0; }
    CCodePageData(DWORD dwid) { m_dwid = dwid; }

    //  Attributes

    DWORD   Page() const { return m_dwid; }
    void    Invocation(CString& csReturn, BOOL bSelect) const;
    const unsigned  Size() const {
        return sizeof m_dwid + 2 * m_ciSelect.Size();
    }

    BOOL    NoInvocation() const {
        return !m_ciSelect.Length() && !m_ciDeselect.Length();
    }

    //  Operations
    void    SetPage(DWORD dwNewPage) { m_dwid = dwNewPage; }
    void    SetInvocation(LPCTSTR lpstrInvoke, BOOL bSelect);
    void    SetInvocation(PBYTE pb, unsigned ucb, BOOL bSelect);
    void    NoteOffsets(DWORD& dwOffset);
    void    WriteSelf(CFile& cfTarget);
    void    WriteInvocation(CFile& cfTarget);
};

//  This class is the generic class encompassing all glyph translation
//  information.  We can use it to output any of the other forms.

class CGlyphMap : public CProjectNode {
    CSafeMapWordToOb    m_csmw2oEncodings;  //  All of the defined encodings
    CRunRecord          m_crr;
    long                m_lidPredefined;
    BOOL                m_bPaired;          //  Use paired encoding...
    CSafeObArray        m_csoaCodePage;     //  Code page(s) in this map

    //  Framework support (workspace)

    CString             m_csSource;         //  Source CTT File name

    //  Predefined GTT support- must be in this DLL

    static CSafeMapWordToOb m_csmw2oPredefined; //  Cache loaded PDTs here

    void            MergePredefined();  //  Use definitions to build "true" GTT
    void            UnmergePredefined(BOOL bTrackRemovals);

    void            GenerateRuns();

    CCodePageData&  CodePage(unsigned u) const {
        return *(CCodePageData *) m_csoaCodePage[u];
    }

    DECLARE_SERIAL(CGlyphMap)
public:
	bool ChngedCodePt() { return m_bChngCodePt ; } ;
	void SetCodePt( bool b) { m_bChngCodePt = b ; }
	// These variables hold parameters for PGetDefaultGlyphset().

	WORD	m_wFirstChar, m_wLastChar ;

	// True iff GTT data should be loaded from resources or built.
	
	bool	m_bResBldGTT ;		

	CTime	m_ctSaveTimeStamp ;	// The last time this GTT was saved

    //  Predefined IDs, and a static function for retrieving predefined maps

    enum {Wansung = -18, ShiftJIS, GB2312, Big5ToTCA, Big5ToNSA86, JISNoANK,
            JIS, KoreanISC, Big5, CodePage863 = -3, CodePage850, CodePage437,
            DefaultPage, NoPredefined = 0xFFFF};

    static CGlyphMap*	Public(WORD wID, WORD wCP = 0, DWORD dwDefCP = 0,
							   WORD wFirst = 0, WORD wLast = 255) ;

    CGlyphMap();

    //  Attributes

    unsigned    CodePages() const { return m_csoaCodePage.GetSize(); }
    DWORD       DefaultCodePage() const { return CodePage(0).Page(); }

    unsigned    Glyphs() const {
        return m_csmw2oEncodings.GetCount();
    }

    void        CodePages(CDWordArray& cdaReturn) const;
    unsigned    PageID(unsigned u) const { return CodePage(u).Page(); }
    long        PredefinedID() const { return m_lidPredefined; }

    CString     PageName(unsigned u) const;
    void        Invocation(unsigned u, CString& csReturn, BOOL bSelect) const;
    void        UndefinedPoints(CMapWordToDWord& cmw2dCollector) const;
    BOOL        OverStrike() const { return m_bPaired; }
    const CString&  SourceName() { return m_csSource; }

    //  Operations- Framework support
    void    SetSourceName(LPCTSTR lpstrNew);
    void    Load(CByteArray&    cbaMap) ;  //  Load GTT image
    //void    Load(CByteArray&    cbaMap) const;  //  Load GTT image

    //  Operations- editor support

    void    AddPoints(CMapWordToDWord& cmw2dNew);   //  Add points and pages
    void    DeleteGlyph(WORD wGlyph);
	BOOL    RemovePage(unsigned uPage, unsigned uMapTo, bool bDelete = FALSE); // 118880

    void    SetDefaultCodePage(unsigned u) { CodePage(0).SetPage(u); }
    void    ChangeCodePage(CPtrArray& cpaGlyphs, DWORD dwidNewPage);
    void    AddCodePage(DWORD dwidNewPage);

    void    UsePredefined(long lidPredefined);

    void    SetInvocation(unsigned u, LPCTSTR lpstrInvoke, BOOL bSelect);
    void    ChangeEncoding(WORD wCodePoint, LPCTSTR lpstrInvoke);
    void    OverStrike(BOOL bOn) { m_bPaired = bOn; Changed();}

    int     ConvertCTT();
    BOOL    Load(LPCTSTR lpstrName = NULL);
    BOOL    RLE(CFile& cfTarget);

    CGlyphHandle*   Glyph(unsigned u);

    //  Font editor support operations

    void    Collect(CPtrArray& cpaGlyphs) { //  Collect all glyph handles
        cpaGlyphs.RemoveAll();
        m_crr.Collect(cpaGlyphs);
    }

    virtual CMDIChildWnd*   CreateEditor();
    virtual BOOL            Generate(CFile& cfGTT);

    BOOL    SetFileName(LPCTSTR lpstrNew) ;

    virtual void    Serialize(CArchive& car);
private:
	bool m_bChngCodePt;
};

/////////////////////////////////////////////////////////////////////////////
// CGlyphMapContainer document

class CGlyphMapContainer : public CDocument {
    CGlyphMap   *m_pcgm;
    BOOL        m_bEmbedded;		// From driver, or not?
	BOOL		m_bSaveSuccessful;	// TRUE iff a successful save was performed

protected:
	CGlyphMapContainer();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CGlyphMapContainer)

// Attributes
public:

    CGlyphMap*  GlyphMap() { return m_pcgm; }

// Operations
public:
    //  Constructor- used to create from driver info editor
    CGlyphMapContainer(CGlyphMap *pcgm, CString csPath);
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGlyphMapContainer)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CGlyphMapContainer();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CGlyphMapContainer)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\infwizrd.cpp ===
// INFWizrd.cpp : implementation file
//

#include "stdafx.h"
#include "minidev.h"
#include <gpdparse.h>
#include "rcfile.h"
#include "projrec.h"
#include "projview.h"
#include "comctrls.h"
#include "Gpdview.h" //RAID 0001
#include "INFWizrd.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CINFWizard

IMPLEMENT_DYNAMIC(CINFWizard, CPropertySheet)

CINFWizard::CINFWizard(CWnd* pParentWnd, UINT iSelectPage)
	: CPropertySheet(IDS_INFWizTitle, pParentWnd )  //iSelectPage ) RAID 0001//Welcome page should be top even iselectpage=1
{
	// Save parent pointer

	m_pcpvParent = (CProjectView*) pParentWnd ;

	// Give the pages a pointer to the sheet.

	m_ciww.m_pciwParent = this ;
	m_ciwm.m_pciwParent = this ;
	m_ciwgpi.m_pciwParent = this ;
	m_ciwbd.m_pciwParent = this ;
	m_ciwip.m_pciwParent = this ;
	m_ciwif.m_pciwParent = this ;
	m_ciwis.m_pciwParent = this ;
	m_ciwds.m_pciwParent = this ;
	m_ciwef.m_pciwParent = this ;
	m_ciwmn.m_pciwParent = this ;
	m_ciwnse.m_pciwParent = this ;
	m_ciwnsms.m_pciwParent = this ;
	m_ciws.m_pciwParent = this ;

	// Add the wizard's pages and set wizard moede.
					
    AddPage(&m_ciww) ;
    AddPage(&m_ciwm) ;
    AddPage(&m_ciwgpi) ;
    AddPage(&m_ciwbd) ;
    AddPage(&m_ciwip) ;
    AddPage(&m_ciwif) ;
    AddPage(&m_ciwis) ;
    AddPage(&m_ciwds) ;
    AddPage(&m_ciwef) ;
    AddPage(&m_ciwmn) ;
    AddPage(&m_ciwnse) ;
    AddPage(&m_ciwnsms) ;
    AddPage(&m_ciws) ;
    SetWizardMode() ;

	// Get and save a pointer to the project record (document) class associated
	// with this class' parent.

	if(NULL != iSelectPage ){ //RAID 0001
		CGPDViewer*  pcgv = (CGPDViewer*) m_pcpvParent;
		m_pcgc = pcgv ->GetDocument();
	}
	else{					// END RAID
		m_pcpr = (CProjectRecord*) m_pcpvParent->GetDocument() ;
		m_pcgc = NULL;
	}
}


CINFWizard::~CINFWizard()
{
}


unsigned CINFWizard::GetModelCount()
{
	if(m_pcgc) //RAID 0001
		return 1;    // only one gpdviewer
	else		//END RAID
		return m_pcpr->ModelCount() ;
}


CModelData& CINFWizard::GetModel(unsigned uidx)
{
	return m_pcpr->Model(uidx) ;
}


void CINFWizard::SetFixupFlags()
{
	// Set flags in each of the pages that need to update their data and UI when
	// the selected models change.

	m_ciwgpi.m_bSelChanged = true ;
	m_ciwbd.m_bSelChanged = true ;
	m_ciwip.m_bSelChanged = true ;
	m_ciwif.m_bSelChanged = true ;
	m_ciwis.m_bSelChanged = true ;
	m_ciwds.m_bSelChanged = true ;
	m_ciwef.m_bSelChanged = true ;
	m_ciwnsms.m_bSelChanged = true ;
}


void CINFWizard::BiDiDataChanged()
{
	// If the selected models' BiDi data may have changed, call the pages that
	// maintain related data so that they can update their data when/if needed.

	m_ciwis.BiDiDataChanged() ;
	m_ciwds.BiDiDataChanged() ;
}


void CINFWizard::NonStdSecsChanged()
{
	// If the nonstandard sections may have changed, call the pages that
	// maintain related data so that they can update their data when/if needed.

	m_ciwnsms.NonStdSecsChanged() ;
}


bool CINFWizard::GenerateINFFile()
{
    //  This might take a while, so...

    CWaitCursor cwc ;

	// Mark all of the sections in the "section used in INF file flags" array
	// as NOT having been used.

	unsigned unumelts = (unsigned)m_ciwnse.m_cuaSecUsed.GetSize() ;
	for (unsigned u = 0 ; u < unumelts ; u++)
		m_ciwnse.m_cuaSecUsed[u] = false ;

	// Initialize the source disk files array.

	m_csaSrcDskFiles.RemoveAll() ;

	// Start by loading the string with the INF's opening comment header.

	m_csINFContents.LoadString(IDS_INFText_HeaderCmt) ;

	// Add the version section with the appropriate value for the provider.

	CString cs ;
	cs.Format(IDS_INFText_Version, m_ciwmn.m_csMfgAbbrev) ;
	ChkForNonStdAdditions(cs, _T("Version")) ;
	m_csINFContents += cs ;

	// Add the ClassInstall32.NT and printer_class_addreg sections plus the
	// comments for the manufacturer's section.

	cs.LoadString(IDS_INFText_ClInst32) ;
	ChkForNonStdAdditions(cs, _T("ClassInstall32.NT")) ;
	m_csINFContents += cs ;
	cs.LoadString(IDS_INFText_PCAddr) ;
	ChkForNonStdAdditions(cs, _T("printer_class_addreg")) ;
	m_csINFContents += cs ;
	cs.LoadString(IDS_INFText_MfgCmt) ;
	m_csINFContents += cs ;

    // Add the manufacturer's name to the manufacturer's section and add the
	// section.

	cs.Format(IDS_INFText_Manufacturer, m_ciwmn.m_csMfgName) ;
	ChkForNonStdAdditions(cs, _T("Manufacturer")) ;
	m_csINFContents += cs ;

	// Build the model specifications section and add the section.

	BldModSpecSec(m_csINFContents) ;

	// Build the copy file sections and add them to the INF contents.

	BuildInstallAndCopySecs(m_csINFContents) ;

	// Add the DestinationDirs section to the INF contents.	

	cs.LoadString(IDS_INFText_DestDirs) ;
	AddICMFilesToDestDirs(cs) ;
	ChkForNonStdAdditions(cs, _T("DestinationDirs")) ;
	m_csINFContents += cs ;

	// Add the SourceDisksNames sections to the INF contents.  Each section will
	// include the Provider string.	

	cs.LoadString(IDS_INFText_SrcDiskNamesI) ;
	ChkForNonStdAdditions(cs, _T("SourceDisksNames.x86")) ;
	m_csINFContents += cs ;

	// Add the SourceDisksFiles sections to the INF contents.

	AddSourceDisksFilesSec(m_csINFContents) ;

	// Add the nonstandard sections to the INF contents.

	AddNonStandardSecs(m_csINFContents) ;

	// Finish up by adding the Strings section to the INF contents.

	cs.LoadString(IDS_INFText_Strings) ;
	cs.Format(IDS_INFText_Strings, m_ciwmn.m_csMfgAbbrev, m_ciwmn.m_csMfgName,
			  m_ciwmn.m_csMfgName) ;
	ChkForNonStdAdditions(cs, _T("Strings")) ;
	m_csINFContents += cs ;

	m_csaSrcDskFiles.RemoveAll() ;		// Array not needed anymore

	// All went well so...

	return true ;
}


void CINFWizard::AddSourceDisksFilesSec(CString& csinf)
{
	// Begin the section with the section header.

	CString cs, cs2, csentry ;
	cs.LoadString(IDS_INFTextSrcDiskFilesHdr) ;

	// Remove any duplicate entries from source disk files array.

	int n, n2 ;
	for (n = 0 ; n < m_csaSrcDskFiles.GetSize() ; n++)
		for (n2 = n + 1 ; n2 < m_csaSrcDskFiles.GetSize() ; )
			if (m_csaSrcDskFiles[n] == m_csaSrcDskFiles[n2])
				m_csaSrcDskFiles.RemoveAt(n2) ;
			else
				n2++ ;

	// Get a count of the number of files in the source disk files array.

	unsigned unumelts = (unsigned)m_csaSrcDskFiles.GetSize() ;

	// Add an entry for each file in the array.

	for (unsigned u = 0 ; u < unumelts ; u++) {
		// Quote the file name if needed.

		cs2 = m_csaSrcDskFiles[u] ;
		//if (cs2[0] != _T('\"'))
		//	QuoteFile(cs2) ;

		// Use the model's file name to build the entry for this model.  Then
		// add this entry to the section.

		csentry.Format(IDS_INFText_SrcDiskFilesEntry, cs2) ;
		cs += csentry ;
	} ;

	// Add any extra entries there might be for this section and then add the
	// section to the INF contents.
			
	ChkForNonStdAdditions(cs, _T("SourceDisksFiles")) ;
	csinf += cs ;
}


void CINFWizard::ChkForNonStdAdditions(CString& cs, LPCTSTR strsection)
{
	// Try to find the section amongst the list of sections with nonstandard
	// additions.

	CStringArray& csasections = m_ciwnse.m_csaSections ;
	CString cssechdr ;
	cssechdr = csLBrack + strsection + csRBrack ;
	unsigned unumelts = (unsigned)csasections.GetSize() ;
	for (unsigned u = 0 ; u < unumelts ; u++) {
		if (csasections[u].CompareNoCase(cssechdr) == 0)
			break ;
	} ;

	// If the section was found, mark the section as used and add the entries
	// for the section to the string.
	//
	// DEAD_BUG - Sometimes, the user may have entered replacement entries for
	//			standard ones.  This isn't handled correctly. : 
	// S.G : check the same keyword between cs and m_ciwnse exist, and replace cs keywod 
	//        with that of m_ciwnse  // raid 71332
	unsigned unSize = 0 ;
	if (u < unumelts ) {
		CStringArray* pcsa ;
		pcsa = (CStringArray*) m_ciwnse.m_coaSectionArrays[u] ;
		
		unSize = (unsigned)pcsa->GetSize() ;
	} ;

	if ( unSize )  {
		m_ciwnse.m_cuaSecUsed[u] = true ;
		
		CStringArray* pcsa ;
		pcsa = (CStringArray*) m_ciwnse.m_coaSectionArrays[u] ;
		unumelts = (unsigned)pcsa->GetSize() ;
		
		CUIntArray cuia ;
		cuia.SetSize(10) ;
		CStringArray csaNewcs;
		int ulen = csCRLF.GetLength() ;  // just in case, unicode : what is the length of "\r\n".
		unsigned i , k ,utelen ;
		i = k = utelen = 0 ; 
		while (-1 != (i = cs.Find(csCRLF, i + 1) ) ) {
			utelen = i - k ;
			csaNewcs.Add(cs.Mid(k,utelen + ulen) ); // we have to cut the string between csCR and csCR
			k = i + ulen;  
		} ;

		for (i = 0 ; i < unSize ; i++ ) 
			cuia[i] = true;

		for (i = 1; i < (unsigned)csaNewcs.GetSize() ; i++ ) {
			CString cstmp = csaNewcs.GetAt(i);
			cstmp = cstmp.Left(cstmp.Find(_T("=")) + 1) ;
			if (! cstmp.CompareNoCase(_T("")) ) 
				break;
			for (u = 0 ; u < unSize ; u++) {
				CString csKeyw = pcsa->GetAt(u) ;
				CString csComp = csKeyw.Left(csKeyw.Find(_T("=")) + 1) ;
				if(! cstmp.CompareNoCase (csComp) ) {
					csKeyw += csCRLF ; 
					csaNewcs.SetAt(i,csKeyw) ;
					cuia[u] = false;
				} ;
					
			} ;
		} ;
		for ( u = 0 ; u < unSize ; u ++ ) 
			if (cuia[u] ) {
				CString csAdd = pcsa->GetAt(u) ;
				csAdd += csCRLF ;
				csaNewcs.Add(csAdd) ;
			} ;
		CString csnew ;
		for ( u = 0 ; u < (unsigned)csaNewcs.GetSize(); u ++ ) 
			csnew += csaNewcs.GetAt(u);
		
		cs = csnew ;

	} ;

	// Add an extra line to this section's strings to separate it from the
	// next one.


	cs += csCRLF ;
}


void CINFWizard::AddNonStandardSecs(CString& csinf)
{
	CString cs ;

	// Loop through each nonstandard section.

	CStringArray& csasections = m_ciwnse.m_csaSections ;
	unsigned unumelts = (unsigned)csasections.GetSize() ;
	CStringArray* pcsa ;
	unsigned u2, unumstrs ;
	for (unsigned u = 0 ; u < unumelts ; u++) {
		// Skip this section if it is not a nonstandard section.  IE, its
		// entries have already been added to one of the standard sections.

		if (m_ciwnse.m_cuaSecUsed[u])
			continue ;

		// Skip this section if it is the Strings section.  It will be added
		// later.

		if (csasections[u].CompareNoCase(_T("[Strings]")) == 0)
			continue ;

		// Get info about the section's entries.  Skip the section if it has
		// no entries.

		pcsa = (CStringArray*) m_ciwnse.m_coaSectionArrays[u] ;
		unumstrs = (unsigned)pcsa->GetSize() ;
		if (unumstrs == 0)
			continue ;

		// Start the section with its header.

		cs = csasections[u] + csCRLF ;

		// Add each of the entries to the section.

		for (u2 = 0 ; u2 < unumstrs ; u2++)
			cs += pcsa->GetAt(u2) + csCRLF ;
		cs += csCRLF ;

		// Add the section to the INF contents

		csinf += cs ;
	} ;
}


void CINFWizard::BldModSpecSec(CString& csinf)
{
	// Add the comment for this section to the INF file

	CString cs, csl, csr, csfn, csmodel, cspnpid ;
	cs.LoadString(IDS_INFText_ModCmt) ;
	csinf += cs ;

	// Build the section header

	cs = csLBrack + m_ciwmn.m_csMfgName + csRBrack + csCRLF ;

	// Build the entry for each model and add them to the section.  The format
	// is:
	//	"model name" = filename,PnP ID,model_name

	CStringArray& csamodels = GetINFModels() ;
	int nummodels = (int)csamodels.GetSize() ;
	int n, npos, nlen ;
	for (n = 0 ; n < nummodels ; n++) {
		csmodel = csamodels[n] ;
		csmodel.TrimLeft() ;
		csmodel.TrimRight() ;

		// If the user supplied a real PnP ID, it is used.  If not, a pseudo
		// PnP ID is generated.

		if (!m_ciwgpi.m_csaModelIDs[n].IsEmpty())
			cspnpid = m_ciwgpi.m_csaModelIDs[n] ;
		else {
			CCompatID ccid(m_ciwmn.m_csMfgName, csmodel) ;
			ccid.GenerateID(cspnpid) ;
		} ;

		nlen = csmodel.GetLength() ;
		while ((npos = csmodel.Find(_T(" "))) != -1) {
			csl = (npos > 0) ? csmodel.Left(npos) : csEmpty ;
			csr = (npos + 1 < nlen) ? csmodel.Right(nlen - npos - 1) : csEmpty ;
			csmodel = csl + _T("_") + csr ;
		} ;
		csfn = GetModelFile(csamodels[n]) ;
		//QuoteFile(csfn) ;
		cs += csQuote + csamodels[n] + csQuote + csEq + csfn + csComma
			+ cspnpid + csComma + csmodel + csCRLF ;
	} ;
	
	// Add non standard additions and then add the section to the INF file contents

	ChkForNonStdAdditions(cs, m_ciwmn.m_csMfgName) ;
	csinf += cs ;
}


void CINFWizard::BuildInstallAndCopySecs(CString& csinf)
{
	// Add the comment for the Install sections to the INF contents

	CString cs ;
	cs.LoadString(IDS_INFText_InstallCmt) ;
	csinf += cs ;

	// Load the section components that will be needed repeatedly

	CString cskey, csdrvdll ;
	cskey.LoadString(IDS_INFText_CopyKey) ;
	bool bbidiadded = false ;	// True iff BiDi DLL in [SourceDiskFiles] array

	// Create an install section for each model and add it the INF contents

	CStringArray& csamodels = GetINFModels() ;
	CStringArray csagpdfile ;
	CString csmodelfile, cshdr, csinc(_T("*Include:")), cstmp ;
	int numstrs, nloc ;
	unsigned unummodels = (unsigned)csamodels.GetSize() ;
	for (unsigned u = 0 ; u < unummodels ; u++) {
		// Build the section header

		cshdr = csmodelfile = GetModelFile(csamodels[u]) ;
		cs = csLBrack + csmodelfile + csRBrack + csCRLF ;

		// Read the GPD to get the DLL name & add it to	SourceDiskFiles array.

		if (!ReadGPDAndGetDLLName(csdrvdll,csamodels[u],csagpdfile,csmodelfile))
			continue ;

		// Build the copy files statement.  Begin by adding the copy files
		// entry, the DLL, and the GPD to the statement.

		//QuoteFile(csmodelfile) ;
		cs += cskey + csdrvdll + csComma + csAtSign + csmodelfile ;
		m_csaSrcDskFiles.Add(csmodelfile) ;	// Add to [SourceDiskFiles] array

		// Add ICM files to the copy files entry when needed.
		
		AddFileList(cs,	(CStringArray*) m_ciwip.m_coaProfileArrays[u]) ;
		
		// Add the nonstandard files for this model to the copy files entry
		// when needed.

		AddFileList(cs,	(CStringArray*) m_ciwef.m_coaExtraFSArrays[u]) ;

		// Scan the current model's GPD file for include statements.
		// If any are found, add them to the copy files entry.

		numstrs = (int) csagpdfile.GetSize() ;
		for (int n = 0 ; n < numstrs ; n++) {
			if ((nloc = csagpdfile[n].Find(csinc)) == -1)
				continue ;
			cstmp = csagpdfile[n].Mid(nloc + csinc.GetLength()) ;
			cstmp.TrimLeft() ;
			cstmp.TrimRight() ;
			if (cstmp[0] == csQuote[0])						// Remove quotes
				cstmp = cstmp.Mid(1, cstmp.GetLength() - 2) ;
			if ((nloc = cstmp.ReverseFind(_T('\\'))) > -1)	// Remove path
				cstmp = cstmp.Right(cstmp.GetLength() - nloc - 1) ;
			if (cstmp.CompareNoCase(_T("stdnames.gpd")) == 0)
				continue ;							// File include below
			//QuoteFile(cstmp) ;
			m_csaSrcDskFiles.Add(cstmp) ; // Add to [SourceDiskFiles] array
			cs += csComma + csAtSign + cstmp ;
		} ;

		// Add any required nonstandard sections to the model's CopyFiles stmt.

		AddNonStdSectionsForModel(cs, (int) u, csamodels[u]) ;

		// Add the data sections statement to the Installs section

		AddDataSectionStmt(cs, (int) u) ;

		// Add the data file statement to the Install section

		cstmp.Format(IDS_INFText_DataFileKey, csmodelfile) ;
		cs += cstmp ;

		// Add the Include and Needs statements to the Install section

		AddIncludeNeedsStmts(cs, (int) u) ;

		// Add the section to the INF contents.

		//cs += csCRLF ;
		ChkForNonStdAdditions(cs, cshdr) ;
		csinf += cs ;
	} ;
}


bool CINFWizard::ReadGPDAndGetDLLName(CString& csdrvdll, CString& csmodel,
									  CStringArray& csagpdfile,
									  CString& csmodelfile)
{
	// Load the GPD file.  Complain and return false if this fails.

	CString cserr ;

	if (!LoadFile(GetModelFile(csmodel, true), csagpdfile)) {
		cserr.Format(IDS_INFGPDReadError, csmodelfile) ;
		AfxMessageBox(cserr, MB_ICONEXCLAMATION) ;
		return false ;
	} ;

	// Get the number of lines in the file and the DLL keyword.

	int nloc ;
	int numstrs = (int) csagpdfile.GetSize() ;
	CString csdllkey(_T("*ResourceDLL:")) ;

	// Look for the DLL name in the GPD file.

	for (int n = 0 ; n < numstrs ; n++) {
		// Continue if current line doesn't contain DLL file name.

		if ((nloc = csagpdfile[n].Find(csdllkey)) == -1)
			continue ;

		// Isolate the DLL file name in the current statement.

		csdrvdll = csagpdfile[n].Mid(nloc + csdllkey.GetLength()) ;
		csdrvdll.TrimLeft() ;
		csdrvdll.TrimRight() ;
		if (csdrvdll[0] == csQuote[0])						// Remove quotes
			csdrvdll = csdrvdll.Mid(1, csdrvdll.GetLength() - 2) ;
		if ((nloc = csdrvdll.ReverseFind(_T('\\'))) > -1)	// Remove path
			csdrvdll = csdrvdll.Right(csdrvdll.GetLength() - nloc - 1) ;
		
		// Add the DLL file name to the SourceDiskFiles array and then add an
		// atsign to it so that it will be ready for future use.

		m_csaSrcDskFiles.Add(csdrvdll) ;
		csdrvdll = csAtSign + csdrvdll ;
		return true ;
	} ;

	// If this point is reached, the DLL file name could not be found so
	// complain and return false.
	
	cserr.Format(IDS_INFNoDLLError, csmodelfile) ;
	AfxMessageBox(cserr, MB_ICONEXCLAMATION) ;
	return false ;
}


void CINFWizard::AddFileList(CString& cssection, CStringArray* pcsa)
{	
	int n, numstrs, npos ;

	// If there is a list of files to add to the section...

	if ((numstrs = (int)pcsa->GetSize()) > 0) {
		// ... Add each file to the section

		CString cstmp ;
		for (n = 0 ; n < numstrs ; n++) {
			cstmp = pcsa->GetAt(n) ;

			// If the filespec contains a path, remove it.

			if ((npos = cstmp.ReverseFind(_T('\\'))) > -1)
				cstmp = cstmp.Right(cstmp.GetLength() - npos - 1) ;

			// Quote the file name if it contains space(s).

			//QuoteFile(cstmp) ;

			m_csaSrcDskFiles.Add(cstmp) ;	// Add to [SourceDiskFiles] array

			// Add this file to the section.

			cssection += csComma + csAtSign + cstmp ;
		} ;
	} ;
}


void CINFWizard::AddICMFilesToDestDirs(CString& cssection)
{
	int				n, n2, numstrs, npos, numarrays ;
	CStringArray*	pcsa ;
	CString			cstmp, cstmp2 ;

	// Find out how many ICM file, string arrays there are.

	numarrays = (int) m_ciwip.m_coaProfileArrays.GetSize() ;

	// Check each array for ICM filespecs...

	for (n = 0 ; n < numarrays ; n++) {
		// Find out how many strings are in the current array

		pcsa = (CStringArray*) m_ciwip.m_coaProfileArrays[n] ;
		numstrs = (int) pcsa->GetSize() ;

		// Add each string in the current array to the DestinationDirs section.

		for (n2 = 0 ; n2 < numstrs ; n2++) {
			cstmp = pcsa->GetAt(n2) ;

			// If the filespec contains a path, remove it.

			if ((npos = cstmp.ReverseFind(_T('\\'))) > -1)
				cstmp = cstmp.Right(cstmp.GetLength() - npos - 1) ;

			// Format the statement for this file and add it to the section.

			cstmp2.Format(IDS_INFText_ICMDest,cstmp) ;
			cssection += cstmp2 ;
		} ;
	} ;
}


CString CINFWizard::GetModelFile(CString& csmodel, bool bfspec/*=false*/)
{
	// Find the class instance associated with the specified model.

//RAID 0001
	if(m_pcgc){
		CString csFileName = m_pcgc->ModelData()->GetKeywordValue(m_pcgc->
			GetPathName(),_T("GPDFileName"));

	if (bfspec)
		return m_pcgc->GetPathName() ;
	else
		return csFileName;
	}

	else
	{
//END 0001
	unsigned unummodels = GetModelCount() ;
	for (unsigned u = 0 ; u < unummodels ; u++) {
		if (csmodel == GetModel(u).Name())
			break ;
	} ;
	ASSERT(u < unummodels) ;

	// Either return a full filespec or just a file name.

	if (bfspec)
		return (GetModel(u).FileName()) ;
	else
		return (GetModel(u).FileTitleExt()) ;
	}  // else{	 END RAID 0001
}


void CINFWizard::AddDataSectionStmt(CString& csinst, int nmod)
{
	// Prepare to determine the contents of the data section statement.

	CString cs, cs2 ;
	cs2 = csEmpty ;
	int nid = IDS_DataSecUni ;
	CUIntArray* pcuia = (CUIntArray*) m_ciwds.m_coaStdDataSecs[nmod] ;

	// Find the only one - if any - of the first three data section names that
	// can be added to the statement.

	for (int n = 0 ; n < NUMDATASECFLAGS - 1 ; n++, nid++)
		if ((*pcuia)[n]) {
			cs2.LoadString(nid) ;
			break ;
		} ;

	// If there is a nonstandard data section, add it too.

	if ((*pcuia)[IDF_OTHER]) {
		if (!cs2.IsEmpty())
			cs2 += csComma ;
		cs2 += m_ciwds.m_csaOtherDataSecs[nmod] ;
	} ;

	// Finish formating the data section statement and add it to the rest of
	// the install section.

	cs.Format(IDS_INFText_DataSecKey, cs2) ;
	csinst += cs ;
}


void CINFWizard::AddIncludeNeedsStmts(CString& csinst, int nmod)
{
	CString cs, cs2 ;

	// Build the Include statement and add it to the section..

	cs.Format(IDS_INFText_IncludeKey, m_ciwif.m_csaIncFiles[nmod]) ;
	csinst += cs ;

	// Prepare to determine the contents of the needs section statement.

	cs2 = csEmpty ;
	CUIntArray* pcuia = (CUIntArray*) m_ciwis.m_coaStdInstSecs[nmod] ;

	// The TrueType section, if needed, is the first section to list in the
	// Includes statement.

	if ((*pcuia)[ISF_TTF])
		cs2.LoadString(IDS_InstSecTtf) ;

	// Find the only one - if any - of the first three install section names
	// that can be added to the statement.

	int nid = IDS_InstSecUni ;
	for (int n = 0 ; n < NUMINSTSECFLAGS - 2 ; n++, nid++)
		if ((*pcuia)[n]) {
			if (!cs2.IsEmpty())
				cs2 += csComma ;
			cs.LoadString(nid) ;
			cs2 += cs ;
			break ;
		} ;

	// If there is a nonstandard install section, add it too.

	if ((*pcuia)[ISF_OTHER]) {
		if (!cs2.IsEmpty())
			cs2 += csComma ;
		cs2 += m_ciwis.m_csaOtherInstSecs[nmod] ;
	} ;

	// Finish formating the install section statement and add it to the rest of
	// the install section.

	cs.Format(IDS_INFText_NeedsKey, cs2) ;
	csinst += cs ;
}


void CINFWizard::AddNonStdSectionsForModel(CString& csinst, int nmod,
										   CString& csmodel)
{
	// Declare looping variables and find out how many nonstd sections there are

	int	n, n2, n3 ;
	int numelts = (int) m_ciwnsms.m_csaSections.GetSize() ;

	// If this is the first time this function is called, size and initialize
	// the "this section has already been added to the SourceDiskFiles" flags.

	if (nmod == 0) {
		m_cuiaNonStdSecsFlags.SetSize(numelts) ;
		for (n = 0 ; n < numelts ; n++)
			m_cuiaNonStdSecsFlags[n] = 0 ;
	} ;

	// Loop through all of the nonstandard sections looking for one that
	// references the current model.

	CStringArray* pcsa ;
	CStringArray* pcsa2 ;
	CString		  cssec ;
	for (n = 0 ; n < numelts ; n++) {
		// Get a pointer to the names of models that need the current section.

		pcsa = (CStringArray*) m_ciwnsms.m_coaModelsNeedingSecs[n] ;
		
		// Check each model in the above list to see if it matches the model
		// passed in as an argument to this function.

		for (n2 = 0 ; n2 < pcsa->GetSize() ; n2++)
			// If a match is found...

			if ((*pcsa)[n2] == csmodel) {
				// ...add the section name to the model's CopyFiles statement
				// (Strip the brackets off first.)...

				cssec = m_ciwnsms.m_csaSections[n] ;
				cssec = cssec.Mid(1, cssec.GetLength() - 2) ;
				csinst += csComma + cssec ;

				// ...and make sure that the sections files are listed in the
				// SourceDiskFiles section.

				if (!m_cuiaNonStdSecsFlags[n]) {
					pcsa2 = (CStringArray*) m_ciwnse.m_coaSectionArrays[n] ;
					for (n3 = 0 ; n3 < pcsa2->GetSize() ; n3++)
						m_csaSrcDskFiles.Add((*pcsa2)[n3]) ; // Add to [SourceDiskFiles] array
					m_cuiaNonStdSecsFlags[n] = 1 ;
				} ;
				break ;
			} ;
	} ;
}	


void CINFWizard::PrepareToRestart()
{
	// Set the flags needed to get the pages to reinitialize themselves but
	// keep all existing data.

	m_ciwm.m_bReInitWData = m_ciwbd.m_bReInitWData = true ;
	m_ciwip.m_bReInitWData = m_ciwef.m_bReInitWData = true ;
	m_ciwmn.m_bReInitWData = m_ciwnse.m_bReInitWData = true ;
	m_ciws.m_bReInitWData = m_ciwif.m_bReInitWData = true ;
	m_ciwis.m_bReInitWData = m_ciwds.m_bReInitWData = true ;
	m_ciwnsms.m_bReInitWData = m_ciwgpi.m_bReInitWData = true ;
}


BEGIN_MESSAGE_MAP(CINFWizard, CPropertySheet)
	//{{AFX_MSG_MAP(CINFWizard)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizard message handlers


/////////////////////////////////////////////////////////////////////////////
// CINFWizWelcome property page

IMPLEMENT_DYNCREATE(CINFWizWelcome, CPropertyPage)

CINFWizWelcome::CINFWizWelcome() : CPropertyPage(CINFWizWelcome::IDD)
{
	//{{AFX_DATA_INIT(CINFWizWelcome)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitialized = false ;
}

CINFWizWelcome::~CINFWizWelcome()
{
}

void CINFWizWelcome::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizWelcome)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizWelcome, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizWelcome)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizWelcome message handlers

BOOL CINFWizWelcome::OnSetActive()
{
	//  We wish to disable the "Back" button here.

	m_pciwParent->SetWizardButtons(PSWIZB_NEXT) ;
	m_pciwParent->GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;

	m_bInitialized = true ;		// Page is initialized now

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizModels property page

IMPLEMENT_DYNCREATE(CINFWizModels, CPropertyPage)

CINFWizModels::CINFWizModels() : CPropertyPage(CINFWizModels::IDD)
{
	//{{AFX_DATA_INIT(CINFWizModels)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Initialize member variables

	m_bInitialized = m_bSelChanged = m_bReInitWData = false ;
	m_uNumModels = m_uNumModelsSel = 0 ;
}

CINFWizModels::~CINFWizModels()
{
}

void CINFWizModels::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizModels)
	DDX_Control(pDX, IDC_ModelsList, m_cfelcModels);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizModels, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizModels)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizModels message handlers

BOOL CINFWizModels::OnSetActive()
{
	// Reenable the "Back" button.
	CString cstmp ;   // RAID 0001  move to head from body
	m_pciwParent->SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK) ;

	m_cfelcModels.SetFocus() ;		// The list control gets the focus

	// If this page has been initialized already, make a copy of the current
	// selections and set the flag that indicates that the selection may be
	// changing.  See below for more info.
// RAID 0001
	if(NULL != m_pciwParent->m_pcgc ){
		CString csFilePath = m_pciwParent->m_pcgc->GetPathName();
		CString csModelName = m_pciwParent->m_pcgc->ModelData()->
	   		GetKeywordValue(csFilePath,_T("ModelName"));
		
		m_uNumModels = 1;
		m_csaModels.RemoveAll( );
		m_csaModels.Add(csModelName);

		if (m_bInitialized && !m_bReInitWData)
			return CPropertyPage::OnSetActive() ;

		m_csToggleStr.LoadString(IDS_INFModelsToggleStr) ;
		m_csaInclude.RemoveAll();
		m_csaInclude.Add(m_csToggleStr); 

	}

	else {
//END RAID 0001

		unsigned u ;
		if (m_bInitialized)	{		
			m_csaModelsLast.SetSize(m_uNumModelsSel) ;
			for (u = 0 ; u < m_uNumModelsSel ; u++)
				m_csaModelsLast[u] = m_csaModels[u] ;
			m_bSelChanged = true ;

			// Nothing more need be done if the page is not being reinitialized.

			if (!m_bReInitWData)
				return CPropertyPage::OnSetActive() ;
		} ;

		// The following info is needed when reinitializing and is used/described
		// later.
		
		unsigned unumselected, u2, ureinitidx ;
		if (m_bReInitWData)
			unumselected = ureinitidx = (unsigned)m_csaModels.GetSize() ;

		// Save the number of models in the project and use this number to set the
		// length of the models string array.

		m_uNumModels = m_pciwParent->GetModelCount() ;
		m_csaModels.SetSize(m_uNumModels) ;
		if (!m_bReInitWData)
			m_csaInclude.RemoveAll() ;

		// Load the model names into the models string array.  This is straight
		// forward if we are NOT reinitializing but more complicated when we are
		// reinitializing.  In the latter case, the user's previous selections
		// must be maintained at the beginning of the array.  The rest of the
		// models should be added to array after the selections.

	//	CString cstmp ;		RAID 0001
		for (u = 0 ; u < m_uNumModels ; u++) {
			cstmp = m_pciwParent->GetModel(u).Name() ;

			// If not reinitializing, just add the model name to the array.

			if (!m_bReInitWData)
				m_csaModels[u] = cstmp ;

			// Otherwise only add the model name to the array if it is not one of
			// the selected models that are already in the array.

			else {
				for (u2 = 0 ; u2 < unumselected ; u2++)
					if (m_csaModels[u2] == cstmp)
						break ;
				if (u2 >= unumselected)
					m_csaModels[ureinitidx++] = cstmp ;
			} ;
		} ;
		
		// Initialize the list control
	} // RAID 0001. else {
	m_cfelcModels.InitControl(LVS_EX_FULLROWSELECT, m_uNumModels, 2,
							  TF_HASTOGGLECOLUMNS+TF_CLICKONROW, 0,
							  MF_IGNOREINSDEL) ;

	// Load the models column in the list control.

	cstmp.LoadString(IDS_INFModelsColLab) ;
	m_cfelcModels.InitLoadColumn(0, cstmp, COMPUTECOLWIDTH, 20, false, true,
								 COLDATTYPE_STRING, (CObArray*) &m_csaModels) ;
	
	// Initialize the includes column in the list control.

	cstmp.LoadString(IDS_INFIncludesColLab) ;
	m_csToggleStr.LoadString(IDS_INFModelsToggleStr) ;
	m_cfelcModels.InitLoadColumn(1, cstmp, SETWIDTHTOREMAINDER, -20, false,
								 true, COLDATTYPE_TOGGLE,
								 (CObArray*) &m_csaInclude, m_csToggleStr) ;
	
	m_bInitialized = true ;		// Page is initialized now
	m_bReInitWData = false ;	// Reinit is done now on this page
	return CPropertyPage::OnSetActive() ;
}


LRESULT CINFWizModels::OnWizardNext()
{
	// Make sure the list's contents are sorted in descending order by included
	// status.

	m_cfelcModels.SortControl(1) ;
	if (m_cfelcModels.GetColSortOrder(1))
		m_cfelcModels.SortControl(1) ;

	// Get the data in the included status column.

	m_cfelcModels.GetColumnData((CObArray*) &m_csaInclude, 1) ;

	// Complain and don't let the user continue if no models were selected.

	if (m_csaInclude.GetSize() == 0 || m_csaInclude[0].IsEmpty()) {
		CString csmsg ;
		csmsg.LoadString(IDS_INFNoModelsSel) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return -1 ;
	} ;

	// Get the data in the models column.

	m_cfelcModels.GetColumnData((CObArray*) &m_csaModels, 0) ;

	// Determine the number of included models and use this count to resize the
	// models array.

	m_uNumModelsSel = 0 ;
	for (unsigned u = 0 ; u < m_uNumModels ; u++) {
		if (m_csaInclude[u].IsEmpty())
			break ;
		m_uNumModelsSel++ ;
	} ;
	m_csaModels.SetSize(m_uNumModelsSel) ;

	// Call the sheet class to set the the other pages' fixup flags if the
	// selection changed.

	if (m_bSelChanged) {
		m_pciwParent->SetFixupFlags() ;
		m_bSelChanged = false ;
	} ;

	// All went well so move on to the next wizard page.
	
	return CPropertyPage::OnWizardNext() ;
}


int IdentifyOldAndNewModels(CStringArray& csanewmodels, CUIntArray& cuiaoldmodelsfound,
							CUIntArray& cuianewmodelsfound, int& newnumelts,
							CStringArray& csamodels)
{
	int		n, n2 ;				// Looping variables

	// Get the number of models in the new and old lists.

	int numelts = (int) csamodels.GetSize() ;
	newnumelts = (int) csanewmodels.GetSize() ;

	// Declare and initialize flag arrays used to determine which models are
	// in use.

	cuiaoldmodelsfound.SetSize(numelts) ;
	for (n = 0 ; n < numelts ; n++)
		cuiaoldmodelsfound[n] = 0 ;
	cuianewmodelsfound.SetSize(newnumelts) ;
	for (n = 0 ; n < newnumelts ; n++)
		cuianewmodelsfound[n] = 0 ;

	// Loop through the old & new models to see which of them are still in use.

	for (n = 0 ; n < numelts ; n++)
		for (n2 = 0 ; n2 < newnumelts ; n2++)
			if (csamodels[n] == csanewmodels[n2]) {
				cuiaoldmodelsfound[n] =	cuianewmodelsfound[n2] = 1 ;
				break ;
			} ;

	// Return the number models previously selected

	return numelts ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizGetPnPIDs property page

IMPLEMENT_DYNCREATE(CINFWizGetPnPIDs, CPropertyPage)

CINFWizGetPnPIDs::CINFWizGetPnPIDs() : CPropertyPage(CINFWizGetPnPIDs::IDD)
{
	//{{AFX_DATA_INIT(CINFWizGetPnPIDs)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
}

CINFWizGetPnPIDs::~CINFWizGetPnPIDs()
{
}


void CINFWizGetPnPIDs::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizGetPnPIDs)
	DDX_Control(pDX, IDC_ModelsPnPIDList, m_felcModelIDs);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizGetPnPIDs, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizGetPnPIDs)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CINFWizGetPnPIDs message handlers

BOOL CINFWizGetPnPIDs::OnSetActive()
{
	// Just perform the default actions if nothing special needs to be done.

	if (m_bInitialized && (!m_bReInitWData) && (!m_bSelChanged))
		return CPropertyPage::OnSetActive() ;
								
	int		n, n2 ;				// Looping and indexing variables

	// Perform the first time initialization.

	if (!m_bInitialized) {
		// Get a copy of the selected model names.  Then make the PnP ID array
		// the same size and initialize each entry to empty.

		m_csaModels.Copy(m_pciwParent->GetINFModels()) ;
		m_csaModelIDs.SetSize(m_csaModels.GetSize()) ;
		for (n = 0 ; n < m_csaModelIDs.GetSize() ; n++)
			m_csaModelIDs[n] = csEmpty ;

		// Initialize and load the list control

		InitModelsIDListCtl() ;

		// Set init flag, reset other flags, and return whatever the base class
		// function returns.

		m_bInitialized = true ;
		m_bReInitWData = m_bSelChanged = false ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Either the selected models have changed or the wizard is being
	// reinitialized if this point is reached.  They are handled in similar
	// ways.
	//
	// Begin by getting info about the models in this page and the ones that
	// are selected now.

	CStringArray& csanewmodels = m_pciwParent->GetINFModels() ;
	CUIntArray cuiaoldmodelsfound, cuianewmodelsfound ;
	int numelts, newnumelts ;
	numelts = IdentifyOldAndNewModels(csanewmodels, cuiaoldmodelsfound,
									  cuianewmodelsfound, newnumelts,
									  m_csaModels) ;

	// Remove the old models and related data that are no longer needed.

	for (n = numelts - 1 ; n >= 0 ; n--)
		if (cuiaoldmodelsfound[n] == 0) {
			m_csaModels.RemoveAt(n) ;
			m_csaModelIDs.RemoveAt(n) ;
		} ;

	// Add the truly new models to this page's array of model names and
	// initialize all related data for it.

	for (n = n2 = 0 ; n < newnumelts ; n++) {
		if (cuianewmodelsfound[n] == 1) {
			n2++ ;
			continue ;
		} ;
		m_csaModels.InsertAt(n2, csanewmodels[n]) ;
		m_csaModelIDs.InsertAt(n2, csEmpty) ;
	} ;

	// Reinitialize the list control if the wizard has been reinitialized.
	// Otherwise, just reload the columns in the list control.

	if (m_bReInitWData)
		InitModelsIDListCtl() ;
	else {
		// If necessary, zap extra old data that could be left in the control
		// after the new data is loaded.

		if (numelts > newnumelts) {
			CStringArray csa ;
			csa.SetSize(numelts) ;
			for (n = 0 ; n < numelts ; n++)
				csa[n] = csEmpty ;
			m_felcModelIDs.SetColumnData((CObArray*) &csa, 0) ;
			m_felcModelIDs.SetColumnData((CObArray*) &csa, 1) ;
		} ;

		m_felcModelIDs.SetColumnData((CObArray*) &m_csaModels, 0) ;
		m_felcModelIDs.SetColumnData((CObArray*) &m_csaModelIDs, 1) ;
	} ;

	// Set init flag, reset other flags, and return whatever the base class
	// function returns.

	m_bInitialized = true ;
	m_bReInitWData = m_bSelChanged = false ;
	return CPropertyPage::OnSetActive() ;
}


LRESULT CINFWizGetPnPIDs::OnWizardNext()
{
	// Get the data in the PnP ID column.

	m_felcModelIDs.GetColumnData((CObArray*) &m_csaModelIDs, 1) ;

	// Complain and exit without allowing the wizard page to change if a PnP ID
	// is found that contains spaces.

	int numelts = (int) m_csaModelIDs.GetSize() ;
	for (int n = 0 ; n < numelts ; n++) {
		if (m_csaModelIDs[n].Find(_T(' ')) >= 0) {
			AfxMessageBox(IDS_PnPSpacesError, MB_ICONEXCLAMATION) ;
			return -1 ;
		} ;
	} ;
	
	return CPropertyPage::OnWizardNext();
}


LRESULT CINFWizGetPnPIDs::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


void CINFWizGetPnPIDs::InitModelsIDListCtl()
{
	int				numelts ;	// Number of elements in an array
	CString			cstmp ;

	// Initialize the list control

	numelts = (int) m_csaModels.GetSize() ;
	m_felcModelIDs.InitControl(LVS_EX_FULLROWSELECT, numelts, 2, 0, 0,
							   MF_IGNOREINSDEL) ;

	// Load the models column in the list control.

	cstmp.LoadString(IDS_INFModelsColLab) ;
	m_felcModelIDs.InitLoadColumn(0, cstmp, COMPUTECOLWIDTH, 25, false,
								  false, COLDATTYPE_STRING,
								  (CObArray*) &m_csaModels) ;

	// Initialize the PnP ID column in the list control.

	cstmp.LoadString(IDS_INFPnPIDColLab) ;
	m_felcModelIDs.InitLoadColumn(1, cstmp, SETWIDTHTOREMAINDER, -25,
								  true, false, COLDATTYPE_STRING,
								  (CObArray*) &m_csaModelIDs) ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizBiDi property page

IMPLEMENT_DYNCREATE(CINFWizBiDi, CPropertyPage)

CINFWizBiDi::CINFWizBiDi() : CPropertyPage(CINFWizBiDi::IDD)
{
	//{{AFX_DATA_INIT(CINFWizBiDi)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
}


CINFWizBiDi::~CINFWizBiDi()
{
}


void CINFWizBiDi::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizBiDi)
	DDX_Control(pDX, IDC_ModelsList, m_cfelcBiDi);
	//}}AFX_DATA_MAP
}


void CINFWizBiDi::ModelChangeFixups(unsigned unummodelssel,
								    CStringArray& csamodels,
								    CStringArray& csamodelslast)
{	
	// Declare looping vars, get the size of the old selection array, and
	// declare and size a new flags array.

	unsigned u, u2, unumlst ;
	unumlst = (unsigned)csamodelslast.GetSize() ;
	CUIntArray cuaflags ;
	cuaflags.SetSize(unummodelssel) ;

	// Try to find each new model in the list of old models.  If found, copy the
	// models flag.  If not found, initialize the models flag to false.

	for (u = 0 ; u < unummodelssel ; u++) {
		for (u2 = 0 ; u2 < unumlst ; u2++) {
			if (csamodels[u] == csamodelslast[u2])
				break ;
		} ;
		cuaflags[u] = (u2 < unumlst) ? m_cuaBiDiFlags[u2] : false ;
	} ;

	// Copy the new flags array back into the member variable flags array.

	m_cuaBiDiFlags.SetSize(unummodelssel) ;
	for (u = 0 ; u < unummodelssel ; u++)
		m_cuaBiDiFlags[u] = cuaflags[u] ;

	// Now that the data structures are up to date, load the list control with
	// the new information.  (This part only needed if NOT reinitializing.)

	if (!m_bReInitWData) {
		m_cfelcBiDi.SetColumnData((CObArray*) &csamodels, 0) ;
		CString cs ;
		for (u = 0 ; u < unummodelssel ; u++) {
			cs = (m_cuaBiDiFlags[u]) ? m_csToggleStr : csEmpty ;
			VERIFY(m_cfelcBiDi.SetItemText(u, 1, cs)) ;
		} ;
	} ;
}


BEGIN_MESSAGE_MAP(CINFWizBiDi, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizBiDi)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizBiDi message handlers

BOOL CINFWizBiDi::OnSetActive()
{
	m_cfelcBiDi.SetFocus() ;	// The list control gets the focus

	// Nothing else need be done if this page has been initialized already
	// and it is not being asked to reinitialize the page...  That is,
	// except for possibly needing to pick up any selected model changes
	// that were made.

	if (m_bInitialized && !m_bReInitWData) {
		if (m_bSelChanged) {
			ModelChangeFixups(m_pciwParent->GetINFModsSelCount(),
							  m_pciwParent->GetINFModels(),
							  m_pciwParent->GetINFModelsLst()) ;
			m_bSelChanged = false ;
		} ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Get the array of selected models and declare an array for BiDi info.

	CStringArray& csamodels = m_pciwParent->GetINFModels() ;
	CStringArray csabidi ;
	unsigned unumelts = (unsigned)csamodels.GetSize() ;
	m_csToggleStr.LoadString(IDS_INFBiDiToggleStr) ;

	// If not reinitializing, make sure the BiDi array is empty.  Otherwise,
	// initialize the BiDi strings array based on the settings in the BiDi
	// flags array.

	if (!m_bReInitWData)
		csabidi.RemoveAll() ;
	else {
		ModelChangeFixups(m_pciwParent->GetINFModsSelCount(),
						  m_pciwParent->GetINFModels(),
						  m_pciwParent->GetINFModelsLst()) ;
		csabidi.SetSize(unumelts) ;
		for (unsigned u = 0 ; u < unumelts ; u++)
			if (m_cuaBiDiFlags[u])
				csabidi[u] = m_csToggleStr ;
	} ;

	// Initialize the list control

	m_cfelcBiDi.InitControl(LVS_EX_FULLROWSELECT, unumelts, 2,
							TF_HASTOGGLECOLUMNS+TF_CLICKONROW, 0,
							MF_IGNOREINSDEL) ;

	// Load the models column in the list control.

	CString cstmp ;
	cstmp.LoadString(IDS_INFModelsColLab) ;
	m_cfelcBiDi.InitLoadColumn(0, cstmp, COMPUTECOLWIDTH, 40, false, true,
							   COLDATTYPE_STRING, (CObArray*) &csamodels) ;

	// Initialize the bidi column in the list control.

	cstmp.LoadString(IDS_INFBiDiColLab) ;
	m_cfelcBiDi.InitLoadColumn(1, cstmp, SETWIDTHTOREMAINDER, -20, false, true,
							   COLDATTYPE_TOGGLE, (CObArray*) &csabidi,
							   m_csToggleStr) ;

	m_bInitialized = true ;		// Page is initialized now
	m_bReInitWData = false ;	// Reinit (if needed) is done now on this page
	return CPropertyPage::OnSetActive() ;
}


LRESULT CINFWizBiDi::OnWizardNext()
{
	// Make sure the list's contents are sorted in descending order by BI-DI
	// status.

	m_cfelcBiDi.SortControl(1) ;
	if (m_cfelcBiDi.GetColSortOrder(1))
		m_cfelcBiDi.SortControl(1) ;

	// Get the data in the models and BI-DI status columns.	 Then get the
	// original list of selected models.

	CStringArray csamodels, csabidi ;
	m_cfelcBiDi.GetColumnData((CObArray*) &csamodels, 0) ;
	m_cfelcBiDi.GetColumnData((CObArray*) &csabidi, 1) ;
	CStringArray& csaselmodels = m_pciwParent->GetINFModels() ;

	// Get the length of the arrays and use it to size the array that is used
	// to hold the BI-DI flags.

	unsigned unummodels = (unsigned)csaselmodels.GetSize() ;
	m_cuaBiDiFlags.SetSize(unummodels) ;

	// Now we need to set the BIDI flags correctly.  This is complicated a bit
	// because the models array from the Bi-Di list may not be in the same
	// order as the selected models array.  The flags array should map to the
	// selected models array.  There is extra code below to deal with this.

	for (unsigned u = 0 ; u < unummodels ; u++) {
		for (unsigned u2 = 0 ; u2 < unummodels ; u2++) {
			if (csaselmodels[u] == csamodels[u2]) {
				m_cuaBiDiFlags[u] = !csabidi[u2].IsEmpty() ;
				break ;
			} ;
		} ;
	} ;

	// If this is not the first time this page has been used, any changes made
	// could affect the data managed by some of the other pages.  Make a call
	// to fixup that data when needed.

	m_pciwParent->BiDiDataChanged() ;
		
	// All went well so move on to the next wizard page.
	
	return CPropertyPage::OnWizardNext() ;
}


LRESULT CINFWizBiDi::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


void InitListListPage(CListBox& clbmainlst, bool& binit, CINFWizard* pciwparent,
					  CObArray& coapermaindata,
					  CFullEditListCtrl& cfelcsecondlst, int ncollabid,
					  CStringArray& csamain, bool& breinitwdata,
					  int& ncurmodelidx, int neditlen, DWORD dwmiscflags)
{
	clbmainlst.SetFocus() ;	// The main list box gets the focus

	// Nothing else need be done if this page has been initialized already and
	// it has not be requested to reinitialize itself while keeping existing
	// data.

	if (binit && !breinitwdata)
		return ;

	// Count the array of items to load into the main list box.

	unsigned unummodels = (unsigned)csamain.GetSize() ;

	// Load the main items into the main list box.

	clbmainlst.ResetContent() ;
	for (unsigned u = 0 ; u < unummodels ; u++)
		clbmainlst.AddString(csamain[u]) ;

	CStringArray* pcsa ;
	
	// Initialize the array of string array pointers used to manage the data
	// in the second list for each item in the main list. (Only if not
	// reinitializing because the existing data must be maintained in this
	// case.)

	if (!breinitwdata) {
		coapermaindata.SetSize(unummodels) ;
		for (u = 0 ; u < unummodels ; u++) {	
			pcsa = new CStringArray ;
			pcsa->RemoveAll() ;
			coapermaindata[u] = (CObArray*) pcsa ;
		} ;
	} ;
	
	// Initialize the list control

	cfelcsecondlst.InitControl(LVS_EX_FULLROWSELECT+LVS_EX_GRIDLINES, 8, 1, 0,
							   neditlen, dwmiscflags) ;

	// Put some bogus entries into a string array that is used to "activate"
	// the list control.

	pcsa = new CStringArray ;
	pcsa->SetSize(8) ;
	for (u = 0 ; u < 8 ; u++)				
		pcsa->SetAt(u, csEmpty) ;

	// Initialize the only column in the list control.

	CString cstmp ;
	cstmp.LoadString(ncollabid) ;
	cfelcsecondlst.InitLoadColumn(0, cstmp, SETWIDTHTOREMAINDER, -16, true,
									true, COLDATTYPE_STRING, (CObArray*) pcsa) ;
	delete pcsa ;

	// Now that the list control has been initialized, disable it until a main
	// list item is selected.

	cfelcsecondlst.EnableWindow(false) ;

	ncurmodelidx = -1 ;			// Reset the current model index
	binit = true ;				// Page is initialized now
	breinitwdata = false ;		// Reinit (if needed) is done now on this page
	return ;
}


void SelChangedListListPage(CListBox& clbmainlst, bool binit,
							CObArray& coapermaindata,
						    CFullEditListCtrl& cfelcsecondlst,
							CButton* pcbbrowse, int& ncurmainidx)
{
	// Do nothing if the page has not been initialized yet.

	if (!binit)
		return ;

	// Make sure the Profiles list and Browse button are enabled.

	if (pcbbrowse != NULL)
		pcbbrowse->EnableWindow() ;
	cfelcsecondlst.EnableWindow() ;

	// If there was a previous selection in the list box, save that model's
	// filespecs before loading the current model's filespecs.

	CStringArray* pcsa ;
	if (ncurmainidx != -1) {
		cfelcsecondlst.SaveValue() ;
		pcsa = (CStringArray*) coapermaindata[ncurmainidx] ;
		cfelcsecondlst.GetColumnData((CObArray*) pcsa, 0) ;
	} ;

	// Update the current model index and load its filespecs into the list
	// control.  Before loading, make sure that the current model's file array
	// is long enough to overwrite all of the last model's file strings that
	// are currently in the list.

	if ((ncurmainidx = clbmainlst.GetCurSel()) != -1) {
		pcsa = (CStringArray*) coapermaindata[ncurmainidx] ;
		int nelts = (int)pcsa->GetSize() ;
		int nrows = cfelcsecondlst.GetItemCount() ;
		if (nelts < nrows) {
			pcsa->SetSize(nrows) ;
			for (int n = nrows ; n < nelts ; n++)
				pcsa->SetAt(n, csEmpty) ;
		} ;
		cfelcsecondlst.SetColumnData((CObArray*) pcsa, 0) ;
	} ;
}
						

void OnBrowseListListPage(CFullEditListCtrl& cfelcsecondlst, int nfiletypeid)
{	
	// Prepare for and prompt the user for a filespec to add to the list
	// control.  Return if the user cancels.

	CString cstmp ;
	cstmp.LoadString(nfiletypeid) ;
	CFileDialog cfd(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, cstmp) ;
	if (cfd.DoModal() != IDOK)
		return ;

	// Get the user selected filespec.

	cstmp = cfd.GetPathName() ;

	// Determine the row to place the filespec in

	int nrow ;
	if ((nrow = cfelcsecondlst.GetNextItem(-1, LVNI_SELECTED)) == -1)
		nrow = 0 ;

	// Save the filespec in the profiles list

	VERIFY(cfelcsecondlst.SetItemText(nrow, 0, cstmp)) ;
}


void OnWizNextListListPage(int& ncurmainidx, CFullEditListCtrl& cfelcsecondlst,
						   CObArray& coapermaindata)
{
	// If there was a previous selection in the list box, save that item's
	// data.

	CStringArray* pcsa ;
	if (ncurmainidx != -1) {
		cfelcsecondlst.SaveValue() ;
		pcsa = (CStringArray*) coapermaindata[ncurmainidx] ;
		cfelcsecondlst.GetColumnData((CObArray*) pcsa, 0) ;
	} ;

	// Users may not fill every string in the string arrays so get rid of the
	// ones that are empty.

	int nnummodels = (int)coapermaindata.GetSize() ;
	int nnumfiles, n, n2, n3 ;
	for (n = 0 ; n < nnummodels ; n++) {
		pcsa = (CStringArray*) coapermaindata[n] ;
		nnumfiles = (int)pcsa->GetSize() ;
		for (n2 = n3 = 0 ; n2 < nnumfiles ; n2++) {
			(pcsa->GetAt(n3)).TrimLeft() ;
			(pcsa->GetAt(n3)).TrimRight() ;
			if ((pcsa->GetAt(n3)).IsEmpty())
				pcsa->RemoveAt(n3) ;
			else
				n3++ ;
		} ;
	} ;
}


void ModelChangeFixupsListListPage(unsigned unummodelssel,
								   CStringArray& csamodels,	
								   CStringArray& csamodelslast,
								   CFullEditListCtrl& cfelcsecondlst,
								   CObArray& coapermaindata, int& ncurmainidx,
								   CButton* pcbbrowse, CListBox& clbmainlst,
								   bool& breinitwdata)
{
	// Declare looping vars, get the size of the old selection array, and
	// declare / size / initialize a new profiles array.

	unsigned u, u2, unumlst, unumrows, unumold ;
	unumlst = (unsigned) csamodelslast.GetSize() ;
	if ((unumrows = cfelcsecondlst.GetItemCount()) == 0)
		unumrows = 8 ;
	CObArray coaprofarrays ;
	CStringArray *pcsa, *pcsaold ;
	coaprofarrays.SetSize(unummodelssel) ;
	for (u = 0 ; u < unummodelssel ; u++) {
		pcsa = new CStringArray ;
		pcsa->SetSize(unumrows) ;
		for (u2 = 0 ; u2 < unumrows ; u2++)
			pcsa->SetAt(u2, csEmpty) ;
		coaprofarrays[u] = (CObArray*) pcsa ;
	} ;

	// Clear the list control if not reinitializing.

	if (!breinitwdata)
		cfelcsecondlst.SetColumnData((CObArray*) coaprofarrays[0], 0) ;

	// Try to find each new model in the list of old models.  If found, copy the
	// old model's data to the new profiles array.

	for (u = 0 ; u < unummodelssel ; u++) {
		for (u2 = 0 ; u2 < unumlst ; u2++) {
			if (csamodels[u] == csamodelslast[u2])
				break ;
		} ;
		if (u2 < unumlst) {
			pcsa = (CStringArray*) coaprofarrays[u] ;
			pcsaold = (CStringArray*) coapermaindata[u2] ;
			unumold	= (unsigned)pcsaold->GetSize() ;
			for (u2 = 0 ; u2 < unumold ; u2++)
				pcsa->SetAt(u2, pcsaold->GetAt(u2)) ;
		} ;
	} ;

	// Delete all of the old data

	for (u = 0 ; u < (unsigned) coapermaindata.GetSize() ; u++) {
		pcsaold = (CStringArray*) coapermaindata[u] ;
		delete pcsaold ;
	} ;

	// Copy the new data into the member variable

	coapermaindata.SetSize(unummodelssel) ;
	for (u = 0 ; u < unummodelssel ; u++)
		coapermaindata[u] = coaprofarrays[u] ;

	// Now that the data structures are up to date, finish updating the page's
	// controls.

	ncurmainidx = -1 ;
	cfelcsecondlst.EnableWindow(false) ;
	pcbbrowse->EnableWindow(false) ;
	clbmainlst.ResetContent() ;
	for (u = 0 ; u < unummodelssel ; u++)
		clbmainlst.AddString(csamodels[u]) ;
	clbmainlst.SetCurSel(-1) ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizICMProfiles property page

IMPLEMENT_DYNCREATE(CINFWizICMProfiles, CPropertyPage)

CINFWizICMProfiles::CINFWizICMProfiles() : CPropertyPage(CINFWizICMProfiles::IDD)
{
	//{{AFX_DATA_INIT(CINFWizICMProfiles)
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
	m_nCurModelIdx = -1 ;
}

CINFWizICMProfiles::~CINFWizICMProfiles()
{
	// Delete the string arrays referenced in m_coaProfileArrays.

	CStringArray* pcsa ;
	for (int n = 0 ; n < m_coaProfileArrays.GetSize() ; n++) {
		pcsa = (CStringArray*) m_coaProfileArrays[n] ;
		delete pcsa ;
	} ;
}

void CINFWizICMProfiles::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizICMProfiles)
	DDX_Control(pDX, IDC_ICMFSpecsLst, m_cfelcICMFSpecs);
	DDX_Control(pDX, IDC_ModelsLst, m_clbModels);
	DDX_Control(pDX, IDC_BrowseBtn, m_cbBrowse);
	//}}AFX_DATA_MAP
}


void CINFWizICMProfiles::ModelChangeFixups(unsigned unummodelssel,
										   CStringArray& csamodels,
										   CStringArray& csamodelslast)
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return ;

	// See ModelChangeFixupsListListPage() for more information.

	ModelChangeFixupsListListPage(unummodelssel, csamodels, csamodelslast,
								  m_cfelcICMFSpecs, m_coaProfileArrays,
								  m_nCurModelIdx, &m_cbBrowse, m_clbModels,
								  m_bReInitWData) ;
}


BEGIN_MESSAGE_MAP(CINFWizICMProfiles, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizICMProfiles)
	ON_BN_CLICKED(IDC_BrowseBtn, OnBrowseBtn)
	ON_LBN_SELCHANGE(IDC_ModelsLst, OnSelchangeModelsLst)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizICMProfiles message handlers

BOOL CINFWizICMProfiles::OnSetActive()
{
	// Get the list of models to load into the main list box.

	CStringArray& csamodels = m_pciwParent->GetINFModels() ;

	// Nothing else need be done if this page has been initialized already
	// and it is not being asked to reinitialize the page...  That is,
	// except for possibly needing to pick up any selected model changes
	// that were made.

	if (m_bInitialized && !m_bReInitWData) {
		if (m_bSelChanged) {
			ModelChangeFixups(m_pciwParent->GetINFModsSelCount(), csamodels,
							  m_pciwParent->GetINFModelsLst()) ;
			m_bSelChanged = false ;
		} ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Pick up selected model changes when reinitializing

	if (m_bReInitWData)	{
		ModelChangeFixups(m_pciwParent->GetINFModsSelCount(), csamodels,
						  m_pciwParent->GetINFModelsLst()) ;
		m_bSelChanged = false ;
	} ;

	// See InitListListPage() for more details.

	InitListListPage(m_clbModels, m_bInitialized, m_pciwParent,
					 m_coaProfileArrays, m_cfelcICMFSpecs, IDS_INFICMColLab,
					 csamodels, m_bReInitWData, m_nCurModelIdx, 256, 0) ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizICMProfiles::OnSelchangeModelsLst()
{
	SelChangedListListPage(m_clbModels, m_bInitialized, m_coaProfileArrays,
						   m_cfelcICMFSpecs, &m_cbBrowse, m_nCurModelIdx) ;
}


void CINFWizICMProfiles::OnBrowseBtn()
{
	// See OnBrowseListListPage() for more information.

	OnBrowseListListPage(m_cfelcICMFSpecs, IDS_CommonICMFile) ;
}


LRESULT CINFWizICMProfiles::OnWizardNext()
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return -1 ;

	// See OnWizNextListListPage() for more information.
	
	OnWizNextListListPage(m_nCurModelIdx, m_cfelcICMFSpecs, m_coaProfileArrays);
	return CPropertyPage::OnWizardNext() ;
}


LRESULT CINFWizICMProfiles::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizIncludeFiles property page

IMPLEMENT_DYNCREATE(CINFWizIncludeFiles, CPropertyPage)

CINFWizIncludeFiles::CINFWizIncludeFiles() : CPropertyPage(CINFWizIncludeFiles::IDD)
{
	//{{AFX_DATA_INIT(CINFWizIncludeFiles)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
	m_nCurModelIdx = -1 ;
}

CINFWizIncludeFiles::~CINFWizIncludeFiles()
{
}

void CINFWizIncludeFiles::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizIncludeFiles)
	DDX_Control(pDX, IDC_ModelsLst, m_clbModels);
	DDX_Control(pDX, IDC_IncludeFileBox, m_ceIncludeFile);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizIncludeFiles, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizIncludeFiles)
	ON_LBN_SELCHANGE(IDC_ModelsLst, OnSelchangeModelsLst)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizIncludeFiles message handlers

BOOL CINFWizIncludeFiles::OnSetActive()
{
	// Just perform the default actions if nothing special needs to be done.

	if (m_bInitialized && (!m_bReInitWData) && (!m_bSelChanged))
		return CPropertyPage::OnSetActive() ;

	int		n, n2 ;					// Looping variable
	int		numelts, newnumelts ;	// Number of elements in an array
	CString	cstmp ;					// Temp string

	// Perform the first time initialization.

	if (!m_bInitialized) {
		// Get a copy of the currently selected model names and then load them
		// into the list box. Set the focus to the list box.

		m_csaModels.Copy(m_pciwParent->GetINFModels()) ;
		for (n = 0, numelts = (int) m_csaModels.GetSize() ; n < numelts ; n++)
			m_clbModels.AddString(m_csaModels[n]) ;
		m_clbModels.SetFocus() ;

		// Size and initialize the include files array.  Initialize each
		// include file to the default.

		cstmp.LoadString(IDS_DefINFIncFile) ;
		m_csaIncFiles.SetSize(numelts) ;
		for (n = 0 ; n < numelts ; n++)
			m_csaIncFiles[n] = cstmp ;

		// Set init flag, reset other flags, and return whatever the base class
		// function returns.

		m_bInitialized = true ;
		m_bReInitWData = m_bSelChanged = false ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Either the selected models have changed or the wizard is being
	// reinitialized if this point is reached.  Both are handled the same way.
	//
	// Begin by getting info about the models in this page and the ones that
	// are selected now.

	CStringArray& csanewmodels = m_pciwParent->GetINFModels() ;
	CUIntArray cuiaoldmodelsfound, cuianewmodelsfound ;
	numelts = IdentifyOldAndNewModels(csanewmodels, cuiaoldmodelsfound,
									  cuianewmodelsfound, newnumelts,
									  m_csaModels) ;

	// Remove the old models and related data that are no longer needed.

	for (n = numelts - 1 ; n >= 0 ; n--)
		if (cuiaoldmodelsfound[n] == 0) {
			m_csaModels.RemoveAt(n) ;
			m_csaIncFiles.RemoveAt(n) ;
		} ;

	// Add the truly new models to this page's array of model names and
	// initialize an Include File string for it.

	cstmp.LoadString(IDS_DefINFIncFile) ;
	for (n = n2 = 0 ; n < newnumelts ; n++) {
		if (cuianewmodelsfound[n] == 1) {
			n2++ ;
			continue ;
		} ;
		m_csaModels.InsertAt(n2, csanewmodels[n]) ;
		m_csaIncFiles.InsertAt(n2, cstmp) ;
	} ;

	// Clear the Include Files edit box

	m_ceIncludeFile.SetWindowText(csEmpty) ;

	// Reinitialize the models array and the current model index.

	m_clbModels.ResetContent() ;
	for (n = 0, numelts = (int) m_csaModels.GetSize() ; n < numelts ; n++)
		m_clbModels.AddString(m_csaModels[n]) ;
	m_clbModels.SetCurSel(-1) ;
	m_clbModels.SetFocus() ;
	m_nCurModelIdx = -1 ;

	// Set init flag, reset other flags, and return whatever the base class
	// function returns.

	m_bInitialized = true ;
	m_bReInitWData = m_bSelChanged = false ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizIncludeFiles::OnSelchangeModelsLst()
{
	// If there was a previous model selection, save its include file string.
	// Otherwise, enable the include file edit box.

	if (m_nCurModelIdx != -1)
		m_ceIncludeFile.GetWindowText(m_csaIncFiles[m_nCurModelIdx]) ;
	else
		m_ceIncludeFile.EnableWindow() ;

	// Save the index for the currently selected model.  Then load the edit box
	// with the include file string for that model.

	m_nCurModelIdx = m_clbModels.GetCurSel() ;
	m_ceIncludeFile.SetWindowText(m_csaIncFiles[m_nCurModelIdx]) ;
}

	
LRESULT CINFWizIncludeFiles::OnWizardNext()
{
	// Save the index for the currently selected model.  If the value is valid,
	// save the include file string for this model.

	if ((m_nCurModelIdx = m_clbModels.GetCurSel()) != -1)
		m_ceIncludeFile.GetWindowText(m_csaIncFiles[m_nCurModelIdx]) ;

	// Make sure each model has an include file string.  Complain and exit
	// without allowing the page to change if an empty string is found.

	int numelts = (int) m_csaIncFiles.GetSize() ;
	for (int n = 0 ; n < numelts ; n++) {
		if (m_csaIncFiles[n].IsEmpty()) {
			CString cserrmsg ;
			cserrmsg.Format(IDS_INFMissingIncError, m_csaModels[n]) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
			m_clbModels.SetCurSel(n) ;
			OnSelchangeModelsLst() ;
			m_ceIncludeFile.SetFocus() ;
			return -1 ;
		} ;
	} ;

	// All went well so...
	
	return CPropertyPage::OnWizardNext();
}


LRESULT CINFWizIncludeFiles::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizInstallSections property page

IMPLEMENT_DYNCREATE(CINFWizInstallSections, CPropertyPage)

CINFWizInstallSections::CINFWizInstallSections() : CPropertyPage(CINFWizInstallSections::IDD)
{
	//{{AFX_DATA_INIT(CINFWizInstallSections)
	m_csOtherSections = _T("");
	m_bOther = FALSE;
	m_bPscript = FALSE;
	m_bTtfsub = FALSE;
	m_bUnidrvBidi = FALSE;
	m_bUnidrv = FALSE;
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
	m_nCurModelIdx = -1 ;
}


CINFWizInstallSections::~CINFWizInstallSections()
{
	// Delete the flag arrays referenced in m_coaStdInstSecs.

	CUIntArray* pcuia ;
	for (int n = 0 ; n < m_coaStdInstSecs.GetSize() ; n++) {
		pcuia = (CUIntArray*) m_coaStdInstSecs[n] ;
		delete pcuia ;
	} ;
}


void CINFWizInstallSections::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizInstallSections)
	DDX_Control(pDX, IDC_ModelsLst, m_clbModels);
	DDX_Text(pDX, IDC_OtherBox, m_csOtherSections);
	DDX_Check(pDX, IDC_OtherChk, m_bOther);
	DDX_Check(pDX, IDC_PscriptChk, m_bPscript);
	DDX_Check(pDX, IDC_TtfsubChk, m_bTtfsub);
	DDX_Check(pDX, IDC_UnidrvBidiChk, m_bUnidrvBidi);
	DDX_Check(pDX, IDC_UnidrvChk, m_bUnidrv);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizInstallSections, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizInstallSections)
	ON_LBN_SELCHANGE(IDC_ModelsLst, OnSelchangeModelsLst)
	ON_BN_CLICKED(IDC_OtherChk, OnOtherChk)
	ON_BN_CLICKED(IDC_PscriptChk, OnPscriptChk)
	ON_BN_CLICKED(IDC_TtfsubChk, OnTtfsubChk)
	ON_BN_CLICKED(IDC_UnidrvBidiChk, OnUnidrvBidiChk)
	ON_BN_CLICKED(IDC_UnidrvChk, OnUnidrvChk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizInstallSections message handlers

BOOL CINFWizInstallSections::OnSetActive()
{
	// Just perform the default actions if nothing special needs to be done.

	if (m_bInitialized && (!m_bReInitWData) && (!m_bSelChanged))
		return CPropertyPage::OnSetActive() ;

	int		n, n2 ;					// Looping variable
	int		numelts, newnumelts ;	// Number of elements in an array
	CUIntArray* pcuia ;				// Used to reference a model's flags array

	// Perform the first time initialization.

	if (!m_bInitialized) {
		// Get a copy of the currently selected model names and initialize the
		// controls on this page.

		m_csaModels.Copy(m_pciwParent->GetINFModels()) ;
		numelts = InitPageControls() ;

		// Size and initialize the standard install sections array.  There is
		// one entry in the array per model.  Each entry references an array
		// of flags that specify the install sections for each model.  See
		// below to see how the flags are initialized.
		//
		// The other install sections string array is sized and initialized too.
		
		m_coaStdInstSecs.SetSize(numelts) ;
		m_csaOtherInstSecs.SetSize(numelts) ;
		for (n = 0 ; n < numelts ; n++)	
			AddModelFlags(n) ;

		// Set init flag, reset other flags, and return whatever the base class
		// function returns.

		m_bInitialized = true ;
		m_bReInitWData = m_bSelChanged = false ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Either the selected models have changed or the wizard is being
	// reinitialized if this point is reached.  Both are handled the same way.
	//
	// Begin by getting info about the models in this page and the ones that
	// are selected now.

	CStringArray& csanewmodels = m_pciwParent->GetINFModels() ;
	CUIntArray cuiaoldmodelsfound, cuianewmodelsfound ;
	numelts = IdentifyOldAndNewModels(csanewmodels, cuiaoldmodelsfound,
									  cuianewmodelsfound, newnumelts,
									  m_csaModels) ;

	// Remove the old models and related data that are no longer needed.

	for (n = numelts - 1 ; n >= 0 ; n--)
		if (cuiaoldmodelsfound[n] == 0) {
			m_csaModels.RemoveAt(n) ;
			pcuia = (CUIntArray*) m_coaStdInstSecs[n] ;
			delete pcuia ;
			m_coaStdInstSecs.RemoveAt(n) ;
			m_csaOtherInstSecs.RemoveAt(n) ;
		} ;

	// Add the truly new models to this page's array of model names and
	// initialize all related Install Section data for it.

	for (n = n2 = 0 ; n < newnumelts ; n++) {
		if (cuianewmodelsfound[n] == 1) {
			n2++ ;
			continue ;
		} ;
		m_csaModels.InsertAt(n2, csanewmodels[n]) ;
		m_coaStdInstSecs.InsertAt(n2, (CObject*) NULL) ;
		m_csaOtherInstSecs.InsertAt(n2, csEmpty) ;
		AddModelFlags(n2) ;
	} ;

	// Initialize the controls on the page

	InitPageControls() ;

	// Set init flag, reset other flags, and return whatever the base class
	// function returns.

	m_bInitialized = true ;
	m_bReInitWData = m_bSelChanged = false ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizInstallSections::AddModelFlags(int nidx)
{
	int			n ;				// Looping variable
	CUIntArray* pcuia ;			// Used to reference a model's flags array
	CString		csfname ;		// Model's file name

	// Allocate the flags array and save it in the array of flags arrays.
	// Next, initialize the other sections string for this model.

	pcuia = new CUIntArray ;
	m_coaStdInstSecs[nidx] = (CObArray*) pcuia ;
	m_csaOtherInstSecs[nidx].Empty() ;

	// Size the current flags array and initialize each one to 0 (off).

	pcuia->SetSize(NUMINSTSECFLAGS) ;
	for (n = 0 ; n < NUMINSTSECFLAGS ; n++)
		(*pcuia)[n] = 0 ;

	// Get the model's file name and check its extension to see if
	// one of its Unidrv or its PostScript flag should be set.  (The
	// other flags are only user settable so they aren't changed.)
	//RAID 0001
	csfname = m_pciwParent->GetModelFile(m_csaModels[nidx]) ;
	if (csfname.Find(_T(".GPD")) != -1) {
		// The UNIDRVBIDI section is used (flagged) if the user marked
		// this model BIDI.  Otherwise, the UNIDRV section is used.

		if (m_pciwParent->m_ciwbd.m_cuaBiDiFlags[nidx])
			(*pcuia)[ISF_UNIBIDI] = 1 ;
		else
			(*pcuia)[ISF_UNI] = 1 ;
	
	// Postcript file.

	} else
		(*pcuia)[ISF_PSCR] = 1 ;
}


int CINFWizInstallSections::InitPageControls()
{
	int		n ;					// Looping variable
	int		numelts ;			// Number of elements in an array

	// Load the current set of models into the list box

	m_clbModels.ResetContent() ;
	for (n = 0, numelts = (int) m_csaModels.GetSize() ; n < numelts ; n++)
		m_clbModels.AddString(m_csaModels[n]) ;
	
	// Make sure there is no model selected in the list box and that the box
	// has the focus.

	m_clbModels.SetCurSel(-1) ;
	m_clbModels.SetFocus() ;
	m_nCurModelIdx = -1 ;

	// Clear and disable all of the check boxes and the Other edit box.

	for (n = IDC_UnidrvChk ; n <= IDC_TtfsubChk ; n++)
		GetDlgItem(n)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(FALSE) ;
	m_bUnidrv = m_bUnidrvBidi = m_bPscript = m_bTtfsub = m_bOther = FALSE ;
	m_csOtherSections = csEmpty ;
	UpdateData(FALSE) ;

	// Return the number of elements in the list box.  Ie, the number of
	// selected models.

	return numelts ;
}

	
LRESULT CINFWizInstallSections::OnWizardNext()
{
	// Save the index for the currently selected model.  If the value is valid,
	// save the install section data for this model.

	if ((m_nCurModelIdx = m_clbModels.GetCurSel()) != -1) {
		UpdateData(TRUE) ;
		CUIntArray* pcuia = (CUIntArray*) m_coaStdInstSecs[m_nCurModelIdx] ;
		(*pcuia)[ISF_UNI] =	(unsigned) m_bUnidrv ;
		(*pcuia)[ISF_UNIBIDI] =	(unsigned) m_bUnidrvBidi ;
		(*pcuia)[ISF_PSCR] = (unsigned) m_bPscript ;
		(*pcuia)[ISF_TTF] =	(unsigned) m_bTtfsub ;
		if ((*pcuia)[ISF_OTHER] = (unsigned) m_bOther)
			m_csaOtherInstSecs[m_nCurModelIdx] = m_csOtherSections ;
	} ;
	
	// Make sure that each model has one of the main sections selected and, if
	// the Other section was selected, it has an Other string.

	CString cserrmsg ;
	CUIntArray* pcuia ;
	int numelts = (int) m_csaModels.GetSize() ;
	for (int n = 0 ; n < numelts ; n++) {
		pcuia = (CUIntArray*) m_coaStdInstSecs[n] ;
		TRACE("*** %s: ISF_UNI=%d  ISF_UNIBIDI=%d  ISF_PSCR=%d  ISF_OTHER=%d\n", m_csaModels[n], (*pcuia)[ISF_UNI], (*pcuia)[ISF_UNIBIDI], (*pcuia)[ISF_PSCR], (*pcuia)[ISF_OTHER]) ;
		if ((*pcuia)[ISF_UNI] == 0 && (*pcuia)[ISF_UNIBIDI] == 0
		 && (*pcuia)[ISF_PSCR] == 0 && (*pcuia)[ISF_OTHER] == 0) {
			cserrmsg.Format(IDS_INFMissingInstSecError, m_csaModels[n]) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
			m_clbModels.SetCurSel(n) ;
			OnSelchangeModelsLst() ;
			return -1 ;
		} ;
		if ((*pcuia)[ISF_OTHER] && m_csaOtherInstSecs[n].IsEmpty()) {
			cserrmsg.Format(IDS_INFNoOtherStrError, m_csaModels[n]) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
			m_clbModels.SetCurSel(n) ;
			OnSelchangeModelsLst() ;
			return -1 ;
		} ;
	} ;

	// All went well so...

	return CPropertyPage::OnWizardNext();
}


LRESULT CINFWizInstallSections::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


void CINFWizInstallSections::OnSelchangeModelsLst()
{
	// If there was a previous model selection, save its install section flags.
	// Otherwise, enable the install section check boxes.

	if (m_nCurModelIdx != -1) {
		UpdateData(TRUE) ;
		CUIntArray* pcuia = (CUIntArray*) m_coaStdInstSecs[m_nCurModelIdx] ;
		(*pcuia)[ISF_UNI] =	(unsigned) m_bUnidrv ;
		(*pcuia)[ISF_UNIBIDI] =	(unsigned) m_bUnidrvBidi ;
		(*pcuia)[ISF_PSCR] = (unsigned) m_bPscript ;
		(*pcuia)[ISF_TTF] =	(unsigned) m_bTtfsub ;
		if ((*pcuia)[ISF_OTHER] = (unsigned) m_bOther)
			m_csaOtherInstSecs[m_nCurModelIdx] = m_csOtherSections ;
	} else {
		for (int n = IDC_UnidrvChk ; n <= IDC_TtfsubChk ; n++)
			GetDlgItem(n)->EnableWindow(TRUE) ;
	} ;

	// Save the index for the currently selected model.  Then set the check
	// boxes based on the flags for the specified model.

	m_nCurModelIdx = m_clbModels.GetCurSel() ;
	CUIntArray* pcuia = (CUIntArray*) m_coaStdInstSecs[m_nCurModelIdx] ;
	m_bUnidrv = (BOOL) ((*pcuia)[ISF_UNI]) ;
	m_bUnidrvBidi = (BOOL) ((*pcuia)[ISF_UNIBIDI]) ;
	m_bPscript = (BOOL) ((*pcuia)[ISF_PSCR]) ;
	m_bTtfsub = (BOOL) ((*pcuia)[ISF_TTF]) ;
	if (m_bOther = (BOOL) ((*pcuia)[ISF_OTHER]))
		m_csOtherSections = m_csaOtherInstSecs[m_nCurModelIdx] ;
	else
		m_csOtherSections = csEmpty ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(m_bOther) ;
	UpdateData(FALSE) ;
}


void CINFWizInstallSections::OnPscriptChk()
{
	// If the PostScript checkbox is checked, the Unidrv and TrueType check
	// boxes must be unchecked.

	UpdateData(TRUE) ;
	if (m_bPscript) {
		m_bTtfsub = m_bUnidrvBidi = m_bUnidrv = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizInstallSections::OnTtfsubChk()
{
	// If the TrueType box is checked, clear the PostScript checkbox.

	UpdateData(TRUE) ;
	if (m_bTtfsub) {
		m_bPscript = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizInstallSections::OnUnidrvBidiChk()
{
	// If the UNIDRV_BIDI box is checked, the UNIDRV and PostScript flags must
	// be unchecked.

	UpdateData(TRUE) ;
	if (m_bUnidrvBidi) {
		m_bPscript = m_bUnidrv = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizInstallSections::OnUnidrvChk()
{
	// If the UNIDRV box is checked, the UNIDRV_BIDI and PostScript flags must
	// be unchecked.

	UpdateData(TRUE) ;
	if (m_bUnidrv) {
		m_bPscript = m_bUnidrvBidi = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizInstallSections::OnOtherChk()
{
	// Enable or disable the Other sections edit box based on the new state of
	// the Other check box.

	UpdateData(TRUE) ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(m_bOther) ;

	// If the Other check box was just checked, move the focus to the Other box.

	if (m_bOther)
		GetDlgItem(IDC_OtherBox)->SetFocus() ;
}


void CINFWizInstallSections::BiDiDataChanged()
{
	// Do nothing if this page has not be initialized yet.  In addition, do
	// nothing if the selected models may have changed or a reinit has been
	// request.  These cases are taken care of in OnSetActive().  In additon,
	// it allows this routine to know that the model data in this page are in
	// the same order as the data in the BiDi page().

	if (!m_bInitialized || m_bReInitWData || m_bSelChanged)
		return ;

	// Loop through the data for each selected model and make sure it agrees
	// as much as possible with the current BiDi settings.

	CUIntArray* pcuia ;
	for (int n = 0 ; n < m_coaStdInstSecs.GetSize() ; n++) {
		pcuia = (CUIntArray*) m_coaStdInstSecs[n] ;

		// If the model's BiDi flag is set, make sure it is set here and that
		// its Unidriv and PScript flags are clear.

		if (m_pciwParent->m_ciwbd.m_cuaBiDiFlags[n]) {
			(*pcuia)[ISF_UNIBIDI] = 1 ;
			(*pcuia)[ISF_UNI] = (*pcuia)[ISF_PSCR] = 0 ;

		// Otherwise, clear the BiDi flag.  Then set the Unidrv flag if the
		// PScript flag is clear.

		} else {
			(*pcuia)[ISF_UNIBIDI] = 0 ;
			if ((*pcuia)[ISF_PSCR] == 0)
				(*pcuia)[ISF_UNI] = 1 ;
		} ;
	} ;

	// Reinitialize the controls on the page.

	InitPageControls() ;
}


//////////////////////////////////////////////////////////////////////////
// CINFWizDataSections property page

IMPLEMENT_DYNCREATE(CINFWizDataSections, CPropertyPage)

CINFWizDataSections::CINFWizDataSections() : CPropertyPage(CINFWizDataSections::IDD)
{
	//{{AFX_DATA_INIT(CINFWizDataSections)
	m_csOtherSections = _T("");
	m_bOther = FALSE;
	m_bPscript = FALSE;
	m_bUnidrvBidi = FALSE;
	m_bUnidrv = FALSE;
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
	m_nCurModelIdx = -1 ;
}


CINFWizDataSections::~CINFWizDataSections()
{
	// Delete the flag arrays referenced in m_coaStdDataSecs.

	CUIntArray* pcuia ;
	for (int n = 0 ; n < m_coaStdDataSecs.GetSize() ; n++) {
		pcuia = (CUIntArray*) m_coaStdDataSecs[n] ;
		delete pcuia ;
	} ;
}


void CINFWizDataSections::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizDataSections)
	DDX_Control(pDX, IDC_ModelsLst, m_clbModels);
	DDX_Text(pDX, IDC_OtherBox, m_csOtherSections);
	DDX_Check(pDX, IDC_OtherChk, m_bOther);
	DDX_Check(pDX, IDC_PscriptChk, m_bPscript);
	DDX_Check(pDX, IDC_UnidrvBidiChk, m_bUnidrvBidi);
	DDX_Check(pDX, IDC_UnidrvChk, m_bUnidrv);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizDataSections, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizDataSections)
	ON_LBN_SELCHANGE(IDC_ModelsLst, OnSelchangeModelsLst)
	ON_BN_CLICKED(IDC_OtherChk, OnOtherChk)
	ON_BN_CLICKED(IDC_PscriptChk, OnPscriptChk)
	ON_BN_CLICKED(IDC_UnidrvBidiChk, OnUnidrvBidiChk)
	ON_BN_CLICKED(IDC_UnidrvChk, OnUnidrvChk)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizDataSections message handlers

BOOL CINFWizDataSections::OnSetActive()
{
	// Just perform the default actions if nothing special needs to be done.

	if (m_bInitialized && (!m_bReInitWData) && (!m_bSelChanged))
		return CPropertyPage::OnSetActive() ;

	int		n, n2 ;					// Looping variable
	int		numelts, newnumelts ;	// Number of elements in an array
	CUIntArray* pcuia ;				// Used to reference a model's flags array

	// Perform the first time initialization.

	if (!m_bInitialized) {
		// Get a copy of the currently selected model names and initialize the
		// controls on this page.

		m_csaModels.Copy(m_pciwParent->GetINFModels()) ;
		numelts = InitPageControls() ;

		// Size and initialize the standard data sections array.  There is
		// one entry in the array per model.  Each entry references an array
		// of flags that specify the data sections for each model.  See
		// below to see how the flags are initialized.
		//
		// The other data sections string array is sized and initialized too.
		
		m_coaStdDataSecs.SetSize(numelts) ;
		m_csaOtherDataSecs.SetSize(numelts) ;
		for (n = 0 ; n < numelts ; n++)	
			AddModelFlags(n) ;

		// Set init flag, reset other flags, and return whatever the base class
		// function returns.

		m_bInitialized = true ;
		m_bReInitWData = m_bSelChanged = false ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Either the selected models have changed or the wizard is being
	// reinitialized if this point is reached.  Both are handled the same way.
	//
	// Begin by getting info about the models in this page and the ones that
	// are selected now.

	CStringArray& csanewmodels = m_pciwParent->GetINFModels() ;
	CUIntArray cuiaoldmodelsfound, cuianewmodelsfound ;
	numelts = IdentifyOldAndNewModels(csanewmodels, cuiaoldmodelsfound,
									  cuianewmodelsfound, newnumelts,
									  m_csaModels) ;

	// Remove the old models and related data that are no longer needed.

	for (n = numelts - 1 ; n >= 0 ; n--)
		if (cuiaoldmodelsfound[n] == 0) {
			m_csaModels.RemoveAt(n) ;
			pcuia = (CUIntArray*) m_coaStdDataSecs[n] ;
			delete pcuia ;
			m_coaStdDataSecs.RemoveAt(n) ;
			m_csaOtherDataSecs.RemoveAt(n) ;
		} ;

	// Add the truly new models to this page's array of model names and
	// initialize all related Data Section data for it.

	for (n = n2 = 0 ; n < newnumelts ; n++) {
		if (cuianewmodelsfound[n] == 1) {
			n2++ ;
			continue ;
		} ;
		m_csaModels.InsertAt(n2, csanewmodels[n]) ;
		m_coaStdDataSecs.InsertAt(n2, (CObject*) NULL) ;
		m_csaOtherDataSecs.InsertAt(n2, csEmpty) ;
		AddModelFlags(n2) ;
	} ;

	// Initialize the controls on the page

	InitPageControls() ;

	// Set init flag, reset other flags, and return whatever the base class
	// function returns.

	m_bInitialized = true ;
	m_bReInitWData = m_bSelChanged = false ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizDataSections::AddModelFlags(int nidx)
{
	int			n ;				// Looping variable
	CUIntArray* pcuia ;			// Used to reference a model's flags array
	CString		csfname ;		// Model's file name

	// Allocate the flags array and save it in the array of flags arrays.
	// Next, initialize the other sections string for this model.

	pcuia = new CUIntArray ;
	m_coaStdDataSecs[nidx] = (CObArray*) pcuia ;
	m_csaOtherDataSecs[nidx].Empty() ;

	// Size the current flags array and initialize each one to 0 (off).

	pcuia->SetSize(NUMDATASECFLAGS) ;
	for (n = 0 ; n < NUMDATASECFLAGS ; n++)
		(*pcuia)[n] = 0 ;

	// Get the model's file name and check its extension to see if
	// one of its Unidrv or its PostScript flag should be set.  (The
	// other flags are only user settable so they aren't changed.)

	csfname = m_pciwParent->GetModelFile(m_csaModels[nidx]) ;
	if (csfname.Find(_T(".GPD")) != -1) {
		// The UNIDRVBIDI section is used (flagged) if the user marked
		// this model BIDI.  Otherwise, the UNIDRV section is used.

		if (m_pciwParent->m_ciwbd.m_cuaBiDiFlags[nidx])
			(*pcuia)[IDF_UNIBIDI] = 1 ;
		else
			(*pcuia)[IDF_UNI] = 1 ;
	
	// Postcript file.

	} else
		(*pcuia)[IDF_PSCR] = 1 ;
}


int CINFWizDataSections::InitPageControls()
{
	int		n ;					// Looping variable
	int		numelts ;			// Number of elements in an array

	// Load the current set of models into the list box

	m_clbModels.ResetContent() ;
	for (n = 0, numelts = (int) m_csaModels.GetSize() ; n < numelts ; n++)
		m_clbModels.AddString(m_csaModels[n]) ;
	
	// Make sure there is no model selected in the list box and that the box
	// has the focus.

	m_clbModels.SetCurSel(-1) ;
	m_clbModels.SetFocus() ;
	m_nCurModelIdx = -1 ;

	// Clear and disable all of the check boxes and the Other edit box.

	for (n = IDC_UnidrvChk ; n <= IDC_OtherChk ; n++)
		GetDlgItem(n)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(FALSE) ;
	m_bUnidrv = m_bUnidrvBidi = m_bPscript = m_bOther = FALSE ;
	m_csOtherSections = csEmpty ;
	UpdateData(FALSE) ;

	// Return the number of elements in the list box.  Ie, the number of
	// selected models.

	return numelts ;
}

	
LRESULT CINFWizDataSections::OnWizardNext()
{
	// Save the index for the currently selected model.  If the value is valid,
	// save the install section data for this model.

	if ((m_nCurModelIdx = m_clbModels.GetCurSel()) != -1) {
		UpdateData(TRUE) ;
		CUIntArray* pcuia = (CUIntArray*) m_coaStdDataSecs[m_nCurModelIdx] ;
		(*pcuia)[IDF_UNI] =	(unsigned) m_bUnidrv ;
		(*pcuia)[IDF_UNIBIDI] =	(unsigned) m_bUnidrvBidi ;
		(*pcuia)[IDF_PSCR] = (unsigned) m_bPscript ;
		if ((*pcuia)[IDF_OTHER] = (unsigned) m_bOther)
			m_csaOtherDataSecs[m_nCurModelIdx] = m_csOtherSections ;
	} ;
	
	// Make sure that each model has one of the main sections selected and, if
	// the Other section was selected, it has an Other string.

	CString cserrmsg ;
	CUIntArray* pcuia ;
	int numelts = (int) m_csaModels.GetSize() ;
	for (int n = 0 ; n < numelts ; n++) {
		pcuia = (CUIntArray*) m_coaStdDataSecs[n] ;
		TRACE("*** %s: IDF_UNI=%d  IDF_UNIBIDI=%d  IDF_PSCR=%d  IDF_OTHER=%d\n", m_csaModels[n], (*pcuia)[IDF_UNI], (*pcuia)[IDF_UNIBIDI], (*pcuia)[IDF_PSCR], (*pcuia)[IDF_OTHER]) ;
		if ((*pcuia)[IDF_UNI] == 0 && (*pcuia)[IDF_UNIBIDI] == 0
		 && (*pcuia)[IDF_PSCR] == 0 && (*pcuia)[IDF_OTHER] == 0) {
			cserrmsg.Format(IDS_INFMissingDataSecError, m_csaModels[n]) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
			m_clbModels.SetCurSel(n) ;
			OnSelchangeModelsLst() ;
			return -1 ;
		} ;
		if ((*pcuia)[IDF_OTHER] && m_csaOtherDataSecs[n].IsEmpty()) {
			cserrmsg.Format(IDS_INFNoOtherStrError, m_csaModels[n]) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
			m_clbModels.SetCurSel(n) ;
			OnSelchangeModelsLst() ;
			return -1 ;
		} ;
	} ;

	// All went well so...

	return CPropertyPage::OnWizardNext();
}


LRESULT CINFWizDataSections::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


void CINFWizDataSections::OnSelchangeModelsLst()
{
	// If there was a previous model selection, save its data section flags.
	// Otherwise, enable the install section check boxes.

	if (m_nCurModelIdx != -1) {
		UpdateData(TRUE) ;
		CUIntArray* pcuia = (CUIntArray*) m_coaStdDataSecs[m_nCurModelIdx] ;
		(*pcuia)[IDF_UNI] =	(unsigned) m_bUnidrv ;
		(*pcuia)[IDF_UNIBIDI] =	(unsigned) m_bUnidrvBidi ;
		(*pcuia)[IDF_PSCR] = (unsigned) m_bPscript ;
		if ((*pcuia)[IDF_OTHER] = (unsigned) m_bOther)
			m_csaOtherDataSecs[m_nCurModelIdx] = m_csOtherSections ;
	} else {
		for (int n = IDC_UnidrvChk ; n <= IDC_OtherChk ; n++)
			GetDlgItem(n)->EnableWindow(TRUE) ;
	} ;

	// Save the index for the currently selected model.  Then set the check
	// boxes based on the flags for the specified model.

	m_nCurModelIdx = m_clbModels.GetCurSel() ;
	CUIntArray* pcuia = (CUIntArray*) m_coaStdDataSecs[m_nCurModelIdx] ;
	m_bUnidrv = (BOOL) ((*pcuia)[IDF_UNI]) ;
	m_bUnidrvBidi = (BOOL) ((*pcuia)[IDF_UNIBIDI]) ;
	m_bPscript = (BOOL) ((*pcuia)[IDF_PSCR]) ;
	if (m_bOther = (BOOL) ((*pcuia)[IDF_OTHER]))
		m_csOtherSections = m_csaOtherDataSecs[m_nCurModelIdx] ;
	else
		m_csOtherSections = csEmpty ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(m_bOther) ;
	UpdateData(FALSE) ;
}


void CINFWizDataSections::OnOtherChk()
{
	// Enable or disable the Other sections edit box based on the new state of
	// the Other check box.

	UpdateData(TRUE) ;
	GetDlgItem(IDC_OtherBox)->EnableWindow(m_bOther) ;

	// If the Other check box was just checked, move the focus to the Other box.

	if (m_bOther)
		GetDlgItem(IDC_OtherBox)->SetFocus() ;
}


void CINFWizDataSections::OnPscriptChk()
{
	// If the PostScript checkbox is checked, the Unidrv boxes must be
	// unchecked.

	UpdateData(TRUE) ;
	if (m_bPscript) {
		m_bUnidrvBidi = m_bUnidrv = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizDataSections::OnUnidrvBidiChk()
{
	// If the UNIDRV_BIDI box is checked, the UNIDRV and PostScript flags must
	// be unchecked.

	UpdateData(TRUE) ;
	if (m_bUnidrvBidi) {
		m_bPscript = m_bUnidrv = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizDataSections::OnUnidrvChk()
{
	// If the UNIDRV box is checked, the UNIDRV_BIDI and PostScript flags must
	// be unchecked.

	UpdateData(TRUE) ;
	if (m_bUnidrv) {
		m_bPscript = m_bUnidrvBidi = FALSE ;
		UpdateData(FALSE) ;
	}
}


void CINFWizDataSections::BiDiDataChanged()
{
	// Do nothing if this page has not be initialized yet.  In addition, do
	// nothing if the selected models may have changed or a reinit has been
	// request.  These cases are taken care of in OnSetActive().  In additon,
	// it allows this routine to know that the model data in this page are in
	// the same order as the data in the BiDi page().

	if (!m_bInitialized || m_bReInitWData || m_bSelChanged)
		return ;

	// Loop through the data for each selected model and make sure it agrees
	// as much as possible with the current BiDi settings.

	CUIntArray* pcuia ;
	for (int n = 0 ; n < m_coaStdDataSecs.GetSize() ; n++) {
		pcuia = (CUIntArray*) m_coaStdDataSecs[n] ;

		// If the model's BiDi flag is set, make sure it is set here and that
		// its Unidriv and PScript flags are clear.

		if (m_pciwParent->m_ciwbd.m_cuaBiDiFlags[n]) {
			(*pcuia)[IDF_UNIBIDI] = 1 ;
			(*pcuia)[IDF_UNI] = (*pcuia)[IDF_PSCR] = 0 ;

		// Otherwise, clear the BiDi flag.  Then set the Unidrv flag if the
		// PScript flag is clear.

		} else {
			(*pcuia)[IDF_UNIBIDI] = 0 ;
			if ((*pcuia)[IDF_PSCR] == 0)
				(*pcuia)[IDF_UNI] = 1 ;
		} ;
	} ;

	// Reinitialize the controls on the page.

	InitPageControls() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizExtraFiles property page

IMPLEMENT_DYNCREATE(CINFWizExtraFiles, CPropertyPage)

CINFWizExtraFiles::CINFWizExtraFiles() : CPropertyPage(CINFWizExtraFiles::IDD)
{
	//{{AFX_DATA_INIT(CINFWizExtraFiles)
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bSelChanged = false ;
	m_nCurModelIdx = -1 ;
}

CINFWizExtraFiles::~CINFWizExtraFiles()
{
	// Delete the string arrays referenced in m_coaExtraFSArrays.

	CStringArray* pcsa ;
	for (int n = 0 ; n < m_coaExtraFSArrays.GetSize() ; n++) {
		pcsa = (CStringArray*) m_coaExtraFSArrays[n] ;
		delete pcsa ;
	} ;
}

void CINFWizExtraFiles::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizExtraFiles)
	DDX_Control(pDX, IDC_ExtraFSpecsLst, m_cfelcFSpecsLst);
	DDX_Control(pDX, IDC_ModelLst, m_clbModels);
	DDX_Control(pDX, IDC_BrowsBtn, m_cbBrowse);
	//}}AFX_DATA_MAP
}


void CINFWizExtraFiles::ModelChangeFixups(unsigned unummodelssel,
										  CStringArray& csamodels,
										  CStringArray& csamodelslast)
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return ;

	// See ModelChangeFixupsListListPage() for more information.

	ModelChangeFixupsListListPage(unummodelssel, csamodels, csamodelslast,
								  m_cfelcFSpecsLst, m_coaExtraFSArrays,
								  m_nCurModelIdx, &m_cbBrowse, m_clbModels,
								  m_bReInitWData) ;
}


BEGIN_MESSAGE_MAP(CINFWizExtraFiles, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizExtraFiles)
	ON_LBN_SELCHANGE(IDC_ModelLst, OnSelchangeModelLst)
	ON_BN_CLICKED(IDC_BrowsBtn, OnBrowsBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizExtraFiles message handlers

BOOL CINFWizExtraFiles::OnSetActive()
{
	// Get the list of models to load into the main list box.

	CStringArray& csamodels = m_pciwParent->GetINFModels() ;

	// Nothing else need be done if this page has been initialized already
	// and it is not being asked to reinitialize the page...  That is,
	// except for possibly needing to pick up any selected model changes
	// that were made.

	if (m_bInitialized && !m_bReInitWData) {
		if (m_bSelChanged) {
			ModelChangeFixups(m_pciwParent->GetINFModsSelCount(), csamodels,
							  m_pciwParent->GetINFModelsLst()) ;
			m_bSelChanged = false ;
		} ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Pick up selected model changes when reinitializing

	if (m_bReInitWData) {
		ModelChangeFixups(m_pciwParent->GetINFModsSelCount(), csamodels,
						  m_pciwParent->GetINFModelsLst()) ;
		m_bSelChanged = false ;
	} ;

	// See InitListListPage() for more details.

	InitListListPage(m_clbModels, m_bInitialized, m_pciwParent,
					 m_coaExtraFSArrays, m_cfelcFSpecsLst,
					 IDS_INFExFilesColLab, csamodels, m_bReInitWData,
					 m_nCurModelIdx, 256, 0) ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizExtraFiles::OnSelchangeModelLst()
{
	SelChangedListListPage(m_clbModels, m_bInitialized, m_coaExtraFSArrays,
						   m_cfelcFSpecsLst, &m_cbBrowse, m_nCurModelIdx) ;
}


void CINFWizExtraFiles::OnBrowsBtn()
{
	// See OnBrowseListListPage() for more information.

	OnBrowseListListPage(m_cfelcFSpecsLst, IDS_CommonExtraFile) ;
}


LRESULT CINFWizExtraFiles::OnWizardNext()
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return -1 ;

	// See OnWizNextListListPage() for more information.
	
	OnWizNextListListPage(m_nCurModelIdx, m_cfelcFSpecsLst, m_coaExtraFSArrays);
	return CPropertyPage::OnWizardNext() ;
}


LRESULT CINFWizExtraFiles::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizMfgName property page

IMPLEMENT_DYNCREATE(CINFWizMfgName, CPropertyPage)

CINFWizMfgName::CINFWizMfgName() : CPropertyPage(CINFWizMfgName::IDD)
{
	//{{AFX_DATA_INIT(CINFWizMfgName)
	m_csMfgName = csEmpty;
	m_csMfgAbbrev = csEmpty;
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = false ;
}


CINFWizMfgName::~CINFWizMfgName()
{
}


void CINFWizMfgName::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizMfgName)
	DDX_Control(pDX, IDC_ProviderBox, m_ceMfgAbbrev);
	DDX_Control(pDX, IDC_ManufacturerBox, m_ceMfgName);
	DDX_Text(pDX, IDC_ManufacturerBox, m_csMfgName);
	DDV_MaxChars(pDX, m_csMfgName, 64);
	DDX_Text(pDX, IDC_ProviderBox, m_csMfgAbbrev);
	DDV_MaxChars(pDX, m_csMfgAbbrev, 2);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizMfgName, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizMfgName)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizMfgName message handlers

BOOL CINFWizMfgName::OnSetActive()
{
	// Do nothing if the page has been initialized already and it is not being
	// asked to reinitialize itself.
	CStringArray csagpd ;		 // RAID 0001 ; move to head from body
	if (m_bInitialized && !m_bReInitWData)
		return CPropertyPage::OnSetActive() ;

	// Most of the work needed to initialize this page is only needed when it
	// is NOT being asked to REinitialized itself.

	if (!m_bReInitWData) {
		// Find the class instance associated with the first selected model.

		CStringArray& csamodels = m_pciwParent->GetINFModels() ;
		unsigned unummodels = m_pciwParent->GetModelCount() ;
		if(!m_pciwParent->m_pcgc){	//RAID 0001
			for (unsigned u = 0 ; u < unummodels ; u++) {
				if (csamodels[0] == m_pciwParent->GetModel(u).Name())
					break ;
			} ;
			ASSERT(u < unummodels) ;
			LoadFile(m_pciwParent->GetModel(u).FileName(), csagpd) ;
		}							
		else
			LoadFile(m_pciwParent->m_pcgc->GetPathName(), csagpd) ;
			//END RAID 0001
		// Open/Read/Close the model's GPD file.

		
			

		// Scan the file for and isolate the ModelName entry.

		int numlines = (int)csagpd.GetSize() ;
		CString csmodelname(_T("ModelName")) ;
		CString cscurline ;
		int nloc ;
		for (int n = 0 ; n < numlines ; n++) {
			if ((nloc = csagpd[n].Find(csmodelname)) >= 0) {
				csmodelname = csagpd[n].Mid(csmodelname.GetLength() + nloc) ;
				if ((nloc = csmodelname.Find(_T('"'))) >= 0) {
					csmodelname = csmodelname.Mid(nloc + 1) ;
					if ((nloc = csmodelname.Find(_T('"'))) >= 0)
						csmodelname = csmodelname.Left(nloc) ;
				} else {
					if (csmodelname[0] == _T(':'))
						csmodelname = csmodelname.Mid(1) ;
				} ;
				csmodelname.TrimLeft() ;
				csmodelname.TrimRight() ;
				break ;
			} ;
		} ;

		// If the ModelName entry was found...

		if (n < numlines && !csmodelname.IsEmpty()) {
			// Use the first space terminated value in the ModelName entry for
			// the manufacturer's name.

			if ((nloc = csmodelname.Find(_T(' '))) >= 0)
				m_csMfgName = csmodelname.Left(nloc) ;
			else
				m_csMfgName = csmodelname ;

			// Use the first two letters of the ModelName entry for the
			// provider's "name".

			m_csMfgAbbrev = csmodelname.Left(2) ;
			m_csMfgAbbrev.MakeUpper() ;

			// Load the manufacturer and provider names into the edit boxes on
			// this	page.

			UpdateData(false) ;
		} ;
	
	// When reinitializing, the member variables associated with the controls
	// are already set so just use them.

	} else
		UpdateData(false) ;
	
	// Set focus to first control, set initialization flag, and return.

	m_ceMfgName.SetFocus() ;
	m_bInitialized = true ;	
	m_bReInitWData = false ;	// Reinit (if needed) is done now on this page
	return CPropertyPage::OnSetActive();
}


LRESULT CINFWizMfgName::OnWizardNext()
{
	// Get the values for the manufacturer and provider.

	UpdateData(true) ;

	// Complain if either field is blank and do not move on to the next page.
	// Make sure the abbreviation is 2 characters long, too.
	
	m_csMfgName.TrimLeft() ;
	m_csMfgName.TrimRight() ;
	m_csMfgAbbrev.TrimLeft() ;
	m_csMfgAbbrev.TrimRight() ;
	CString csmsg ;
	if (m_csMfgName.IsEmpty()) {
		m_ceMfgName.SetFocus() ;
		csmsg.LoadString(IDS_NoMfgError) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return -1 ;
	}  ;
	if (m_csMfgAbbrev.IsEmpty() || m_csMfgAbbrev.GetLength() != 2) {
		m_ceMfgAbbrev.SetFocus() ;
		csmsg.LoadString(IDS_NoMfgAbbrevError) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return -1 ;
	}  ;

	// All appears to be well so...

	return CPropertyPage::OnWizardNext() ;
}


LRESULT CINFWizMfgName::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdElts property page

IMPLEMENT_DYNCREATE(CINFWizNonStdElts, CPropertyPage)

CINFWizNonStdElts::CINFWizNonStdElts() : CPropertyPage(CINFWizNonStdElts::IDD)
{
	//{{AFX_DATA_INIT(CINFWizNonStdElts)
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = m_bNewSectionAdded = false ;
	m_nCurSectionIdx = -1 ;
}

CINFWizNonStdElts::~CINFWizNonStdElts()
{
	// Delete the string arrays referenced in m_coaSectionArrays.

	CStringArray* pcsa ;
	for (int n = 0 ; n < m_coaSectionArrays.GetSize() ; n++) {
		pcsa = (CStringArray*) m_coaSectionArrays[n] ;
		delete pcsa ;
	} ;
}

void CINFWizNonStdElts::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizNonStdElts)
	DDX_Control(pDX, IDC_NewSectionBtn, m_ceNewSection);
	DDX_Control(pDX, IDC_KeyValueLst, m_felcKeyValueLst);
	DDX_Control(pDX, IDC_SectionLst, m_clbSections);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizNonStdElts, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizNonStdElts)
	ON_LBN_SELCHANGE(IDC_SectionLst, OnSelchangeSectionLst)
	ON_BN_CLICKED(IDC_NewSectionBtn, OnNewSectionBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdElts message handlers

BOOL CINFWizNonStdElts::OnSetActive()
{
	// Build an array of valid section names.

	if (!m_bInitialized) {
		m_csaSections.Add(_T("[ControlFlags]")) ;
		m_csaSections.Add(_T("[DestinationDirs]")) ;
		m_csaSections.Add(_T("[Device]")) ;
		m_csaSections.Add(_T("[Install]")) ;
		m_csaSections.Add(_T("[Manufacturer]")) ;
		m_csaSections.Add(_T("[SourceDisksFiles]")) ;
		m_csaSections.Add(_T("[SourceDisksNames]")) ;
		m_csaSections.Add(_T("[Strings]")) ;
	} ;
	
	// See InitListListPage() for more details.

	InitListListPage(m_clbSections, m_bInitialized, m_pciwParent,
					 m_coaSectionArrays, m_felcKeyValueLst, IDS_NonStdColLab,
					 m_csaSections, m_bReInitWData, m_nCurSectionIdx, 256, 0) ;

	m_bNewSectionAdded = false ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizNonStdElts::OnSelchangeSectionLst()
{
	SelChangedListListPage(m_clbSections, m_bInitialized, m_coaSectionArrays,
						   m_felcKeyValueLst, NULL, m_nCurSectionIdx) ;
}


void CINFWizNonStdElts::OnNewSectionBtn()
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return ;

	// Prompt the user for a new section name.  Return if the user cancels.

	CNewINFSection cnis ;
	if (cnis.DoModal() == IDCANCEL)
		return ;

	// Get the new section name and add brackets if necessary.

	CString csnewsec = cnis.m_csNewSection ;
	csnewsec.TrimLeft() ;
	csnewsec.TrimRight() ;
	if (csnewsec[0] != _T('['))
		csnewsec = csLBrack + csnewsec ;
	if (csnewsec.Right(1) != csRBrack)
		csnewsec += csRBrack ;

	// Add a new string array to hold the data for the new section.
	
	CStringArray* pcsa = new CStringArray ;
	int nelts = m_felcKeyValueLst.GetItemCount() ;
	pcsa->SetSize(nelts) ;
	for (int n = 0 ; n < nelts ; n++)
		pcsa->SetAt(n, csEmpty) ;
	m_coaSectionArrays.Add((CObject*) pcsa) ;

	// Add the new section to the sections array.  Then, add the new section to
	// the sections list box and try to select this item and make it visible.

	m_csaSections.Add(csnewsec) ;
	int nidx = m_clbSections.AddString(csnewsec) ;
	m_clbSections.SetCurSel(nidx) ;
	OnSelchangeSectionLst() ;

	// Note that a new section was added during this activation of the page.

	m_bNewSectionAdded = true ;
}


LRESULT CINFWizNonStdElts::OnWizardNext()
{
	// Do nothing if the page has not been initialized yet.

	if (!m_bInitialized)
		return -1 ;

	// See OnWizNextListListPage() for more information.
	
	OnWizNextListListPage(m_nCurSectionIdx, m_felcKeyValueLst,
						  m_coaSectionArrays) ;

	// Make sure the "section used in INF file flags" array is correctly sized.

	m_cuaSecUsed.SetSize(m_csaSections.GetSize()) ;

	// If this is not the first time this page has been used, any changes made
	// could affect the data managed by some of the other pages.  Make a call
	// to fixup that data when needed.

	if (m_bNewSectionAdded)
		m_pciwParent->NonStdSecsChanged() ;
		
	return CPropertyPage::OnWizardNext() ;
}


LRESULT CINFWizNonStdElts::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdModelSecs property page

IMPLEMENT_DYNCREATE(CINFWizNonStdModelSecs, CPropertyPage)

CINFWizNonStdModelSecs::CINFWizNonStdModelSecs() : CPropertyPage(CINFWizNonStdModelSecs::IDD)
{
	//{{AFX_DATA_INIT(CINFWizNonStdModelSecs)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = false ;
	m_nCurSectionIdx = -1 ;
}


CINFWizNonStdModelSecs::~CINFWizNonStdModelSecs()
{
	// Delete the string arrays referenced in m_coaModelsNeedingSecs.

	CStringArray* pcsa ;
	for (int n = 0 ; n < m_coaModelsNeedingSecs.GetSize() ; n++) {
		pcsa = (CStringArray*) m_coaModelsNeedingSecs[n] ;
		delete pcsa ;
	} ;
}


void CINFWizNonStdModelSecs::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizNonStdModelSecs)
	DDX_Control(pDX, IDC_ModelSectionLst, m_cfelcModelsLst);
	DDX_Control(pDX, IDC_SectionLst, m_clbSectionsLst);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizNonStdModelSecs, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizNonStdModelSecs)
	ON_LBN_SELCHANGE(IDC_SectionLst, OnSelchangeSectionLst)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdModelSecs message handlers

BOOL CINFWizNonStdModelSecs::OnSetActive()
{
	// Turn off the finish button.

	m_pciwParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT) ;

	// Just perform the default actions if nothing special needs to be done.

	if (m_bInitialized && (!m_bReInitWData) && (!m_bSelChanged))
		return CPropertyPage::OnSetActive() ;
								
	int				n, n2, n3 ;	// Looping variable
	int				numelts ;	// Number of elements in an array
	CStringArray*	pcsa ;		// Used to reference a sections models array

	// Perform the first time initialization.

	if (!m_bInitialized) {
		// Get a copy of the nonstandard section names and the selected model
		// names.

		m_csaSections.Copy(m_pciwParent->m_ciwnse.m_csaSections) ;
		m_csaModels.Copy(m_pciwParent->GetINFModels()) ;

		// The following array is used to manage the models that need each
		// section.  Set its size to the same as the number of sections and
		// load its elements with pointers to string arrays.  Load the sections
		// list box in the same loop.

		numelts = (int) m_csaSections.GetSize() ;
		m_coaModelsNeedingSecs.SetSize(numelts) ;
		m_clbSectionsLst.ResetContent() ;
		for (n = 0 ; n < numelts ; n++) {
			pcsa = new CStringArray ;
			pcsa->RemoveAll() ;
			m_coaModelsNeedingSecs[n] = (CObArray*) pcsa ;
			m_clbSectionsLst.AddString(m_csaSections[n]) ;
		} ;
		m_clbSectionsLst.SetFocus() ;
	
		// Initialize and load the list control

		InitModelsListCtl() ;

		// Set init flag, reset other flags, and return whatever the base class
		// function returns.

		m_bInitialized = true ;
		m_bReInitWData = m_bSelChanged = false ;
		return CPropertyPage::OnSetActive() ;
	} ;

	// Either the selected models have changed or the wizard is being
	// reinitialized if this point is reached.  They are handled in similar
	// ways.
	//
	// Begin by removing references to models that are no longer selected.

	m_csaModels.RemoveAll() ;
	m_csaModels.Copy(m_pciwParent->GetINFModels()) ;
	int nummodels = (int) m_csaModels.GetSize() ;
	numelts = (int) m_coaModelsNeedingSecs.GetSize() ;
	for (n = 0 ; n < numelts ; n++) {
		pcsa = (CStringArray*) m_coaModelsNeedingSecs[n] ;
		for (n2 = (int) pcsa->GetSize() - 1 ; n2 >= 0 ; n2--) {
			for (n3 = 0 ; n3 < nummodels ; n3++)
				if ((*pcsa)[n2] == m_csaModels[n3])
					break ;
			if (n3 >= nummodels)
				pcsa->RemoveAt(n2) ;
		} ;
	} ;

	// Reinitialize the list control if the wizard has been reinitialized.
	// Otherwise, the models may have changed so update that column of the
	// list control.

	if (m_bReInitWData)
		InitModelsListCtl() ;
	else
		m_cfelcModelsLst.SetColumnData((CObArray*) &m_csaModels, 0) ;

	// Update the sections information.

	UpdateSectionData() ;

	// Set init flag, reset other flags, and return whatever the base class
	// function returns.

	m_bInitialized = true ;
	m_bReInitWData = m_bSelChanged = false ;
	return CPropertyPage::OnSetActive() ;
}


void CINFWizNonStdModelSecs::OnSelchangeSectionLst()
{
	// If there was a previous section selection, save the list of models that
	// need it.  Otherwise, enable the models list control.

	if (m_nCurSectionIdx != -1)
		SaveSectionModelInfo() ;
	else
		m_cfelcModelsLst.EnableWindow(TRUE) ;

	// Save the index of the newly selected section and then use that index to
	// get the array of selected models for the section.

	m_nCurSectionIdx = m_clbSectionsLst.GetCurSel() ;
	CStringArray* pcsa ;
	pcsa = (CStringArray*) m_coaModelsNeedingSecs[m_nCurSectionIdx] ;

	// Declare and size a new array that will be loaded with info on the
	// selected models for the current section.  Then load the string displayed
	// in the list control for selected models.

	CStringArray csaselmods ;
	int numelts = (int) m_csaModels.GetSize() ;
	csaselmods.SetSize(numelts) ;
	CString csselstr ;
	csselstr.LoadString(IDS_INF_NSMS_ToggleStr) ;

	// Use the list of all models and the current selection's list of models to
	// build an array with the selected string in the right spots so that this
	// array can be loaded into the list control.

	for (int n2 = 0 ; n2 < pcsa->GetSize() ; n2++)
		for (int n = 0 ; n < numelts ; n++)
			if ((*pcsa)[n2] == m_csaModels[n])
				csaselmods[n] = csselstr ;

	// Load array built above into the list control so that the user can see
	// which models have been selected for the current section.

	m_cfelcModelsLst.SetColumnData((CObArray*) &csaselmods, 1) ;
}


LRESULT CINFWizNonStdModelSecs::OnWizardNext()
{
	// If there was a previous section selection, save the list of models that
	// need it.

	if (m_nCurSectionIdx != -1)
		SaveSectionModelInfo() ;
	
	return CPropertyPage::OnWizardNext();
}


LRESULT CINFWizNonStdModelSecs::OnWizardBack()
{
	// This works because the same thing needs to be done for both
	// OnWizardNext() and OnWizardBack().  In addition,
	// CPropertyPage::OnWizardNext() and CPropertyPage::OnWizardBack() just
	// return 0.
	
	return OnWizardNext() ;
}


void CINFWizNonStdModelSecs::SaveSectionModelInfo()
{
	// Get the selection data out of the list control.

	CStringArray csaselmods ;
	m_cfelcModelsLst.GetColumnData((CObArray*) &csaselmods, 1) ;

	// Use the index of the selected section to get a list of its currently
	// selected models.  Remove the models in it because it will be refilled
	// with new data later.

	CStringArray* pcsa ;
	pcsa = (CStringArray*) m_coaModelsNeedingSecs[m_nCurSectionIdx] ;
	pcsa->RemoveAll() ;

	// Add every selected model to the section's selected models array.

	for (int n = 0 ; n < m_csaModels.GetSize() ; n++)
		if (!csaselmods[n].IsEmpty())
			pcsa->Add(m_csaModels[n]) ;
}


void CINFWizNonStdModelSecs::NonStdSecsChanged()
{
	// Do nothing if this page has not be initialized yet.  In addition, do
	// nothing if the selected models may have changed or a reinit has been
	// request.  These cases are taken care of in OnSetActive().

	if (!m_bInitialized || m_bReInitWData || m_bSelChanged)
		return ;

	// Update the section data to agree with any changes that may have been
	// made.

	UpdateSectionData() ;
}


void CINFWizNonStdModelSecs::UpdateSectionData()
{
	// Get a copy of the latest nonstandard section.

	int		n, n2 ;				// Looping variables
	CStringArray csanewsections ;
	csanewsections.Copy(m_pciwParent->m_ciwnse.m_csaSections) ;

	// Allocate and size the flags arrays used to determine which sections are
	// still in use.

	int numelts = (int) m_csaSections.GetSize() ;
	int newnumelts = (int) csanewsections.GetSize() ;
	CUIntArray cuiaoldflags, cuianewflags ;
	cuiaoldflags.SetSize(numelts) ;
	for (n = 0 ; n < numelts ; n++)
		cuiaoldflags[n] = 0 ;
	cuianewflags.SetSize(newnumelts) ;
	for (n = 0 ; n < newnumelts ; n++)
		cuianewflags[n] = 0 ;

	// Loop through the old & new models to see which of them are still in use.

	for (n = 0 ; n < numelts ; n++)
		for (n2 = 0 ; n2 < newnumelts ; n2++)
			if (m_csaSections[n] == csanewsections[n2]) {
				cuiaoldflags[n] =	cuianewflags[n2] = 1 ;
				break ;
			} ;

	// Remove the old sections and related data that are no longer needed.

	CStringArray* pcsa ;
	for (n = numelts - 1 ; n >= 0 ; n--)
		if (cuiaoldflags[n] == 0) {
			m_csaSections.RemoveAt(n) ;
			pcsa = (CStringArray*) m_coaModelsNeedingSecs[n] ;
			delete pcsa ;
			m_coaModelsNeedingSecs.RemoveAt(n) ;
		} ;

	// Add the truly new sections to this page's array of section names and
	// initialize all related section data for it.

	for (n = n2 = 0 ; n < newnumelts ; n++) {
		if (cuianewflags[n] == 1) {
			n2++ ;
			continue ;
		} ;
		m_csaSections.InsertAt(n2, csanewsections[n]) ;
		pcsa = new CStringArray ;
		m_coaModelsNeedingSecs.InsertAt(n2, (CObject*) pcsa) ;
	} ;

	// Clear the sections list box and reload it with the new sections data.
	// Make sure that nothing is selected in the listbox and give it the focus.

	m_clbSectionsLst.ResetContent() ;
	for (n = 0, numelts = (int) m_csaSections.GetSize() ; n < numelts ; n++)
		m_clbSectionsLst.AddString(m_csaSections[n]) ;
	m_clbSectionsLst.SetCurSel(-1) ;
	m_nCurSectionIdx = -1 ;
	m_clbSectionsLst.SetFocus() ;

	// Clear the selected models column in the list control and disable it.

	CStringArray csa ;
	csa.SetSize(m_csaModels.GetSize()) ;
	m_cfelcModelsLst.SetColumnData((CObArray*) &csa, 1) ;
	m_cfelcModelsLst.EnableWindow(FALSE) ;
}


void CINFWizNonStdModelSecs::InitModelsListCtl()
{
	int				numelts ;	// Number of elements in an array
	CString			cstmp ;

	// Initialize the list control

	numelts = (int) m_csaModels.GetSize() ;
	m_cfelcModelsLst.InitControl(LVS_EX_FULLROWSELECT, numelts, 2,
								 TF_HASTOGGLECOLUMNS+TF_CLICKONROW, 0,
								 MF_IGNOREINSDEL) ;

	// Load the models column in the list control.

	cstmp.LoadString(IDS_INFModelsColLab) ;
	m_cfelcModelsLst.InitLoadColumn(0, cstmp, COMPUTECOLWIDTH, 25, false,
									false, COLDATTYPE_STRING,
									(CObArray*) &m_csaModels) ;

	// Initialize the bidi column in the list control.

	cstmp.LoadString(IDS_INFSecNeededColLab) ;
	CStringArray csaempty ;
	m_csToggleStr.LoadString(IDS_INF_NSMS_ToggleStr) ;
	m_cfelcModelsLst.InitLoadColumn(1, cstmp, SETWIDTHTOREMAINDER, -25,
									false, false, COLDATTYPE_TOGGLE,
									(CObArray*) &csaempty, m_csToggleStr) ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizSummary property page

IMPLEMENT_DYNCREATE(CINFWizSummary, CPropertyPage)

CINFWizSummary::CINFWizSummary() : CPropertyPage(CINFWizSummary::IDD)
{
	//{{AFX_DATA_INIT(CINFWizSummary)
	//}}AFX_DATA_INIT

	m_bInitialized = m_bReInitWData = false ;
}


CINFWizSummary::~CINFWizSummary()
{
}


void CINFWizSummary::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFWizSummary)
	DDX_Control(pDX, IDC_SummaryBox, m_ceSummary);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFWizSummary, CPropertyPage)
	//{{AFX_MSG_MAP(CINFWizSummary)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizSummary message handlers

BOOL CINFWizSummary::OnSetActive()
{
	// Turn on the finish button.

	m_pciwParent->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH) ;

	// Initialize the summary to empty.

	CString cs, cs2, cs3, cs4, cssummary ;
	cssummary = csEmpty ;

	// Add the selected models to the summary

	CStringArray& csamodels = m_pciwParent->GetINFModels() ;
	cssummary.LoadString(IDS_ModelsSumTxt) ;
	int nummodels = (int)csamodels.GetSize() ;
	for (int n = 0 ; n < nummodels ; n++) {
		cs.Format("\t%s\r\n", csamodels[n]) ;	
		cssummary += cs ;
	} ;

	// Add PnP ID info to the summary

	cs.LoadString(IDS_PnPIDSumTxt) ;
	cssummary += cs ;
	bool bfoundone = false ;
	for (n = 0 ; n < nummodels ; n++) {
		if (!m_pciwParent->m_ciwgpi.m_csaModelIDs[n].IsEmpty()) {
			cs.Format("\t%s: %s\r\n", csamodels[n],
					  m_pciwParent->m_ciwgpi.m_csaModelIDs[n]) ;
			cssummary += cs ;
			bfoundone = true ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;
	
	// Add BIDI info to the summary

	cs.LoadString(IDS_BIDISumTxt) ;
	cssummary += cs ;
	bfoundone = false ;
	for (n = 0 ; n < nummodels ; n++) {
		if (m_pciwParent->m_ciwbd.m_cuaBiDiFlags[n]) {
			cs.Format("\t%s\r\n", csamodels[n]) ;	
			cssummary += cs ;
			bfoundone = true ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;
	
	// Add the ICM profiles info to the summary.

	cs.LoadString(IDS_ICMSumTxt) ;
	cssummary += cs ;
	bfoundone = false ;
	CStringArray* pcsa ;
	int n2, numstrs ;
	for (n = 0 ; n < nummodels ; n++) {
		pcsa = (CStringArray*) m_pciwParent->m_ciwip.m_coaProfileArrays[n] ;
		if ((numstrs = (int)pcsa->GetSize()) > 0) {
			cs.Format("\t%s\r\n", csamodels[n]) ;	
			cssummary += cs ;
			bfoundone = true ;
			for (n2 = 0 ; n2 < numstrs ; n2++) {
				cs.Format("\t\t%s\r\n", pcsa->GetAt(n2)) ;
				cssummary += cs ;
			} ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;
	
	// Add the include files info to the summary

	cs.LoadString(IDS_IncFilesSumTxt) ;
	cssummary += cs ;
	for (n = 0 ; n < nummodels ; n++) {
		cs.Format("\t%s\r\n\t\t%s\r\n", csamodels[n],
				  m_pciwParent->m_ciwif.m_csaIncFiles[n]) ;
		cssummary += cs ;
	} ;

	// Add the install sections info to the summary

	cs.LoadString(IDS_InstSecsSumTxt) ;
	cssummary += cs ;
	CUIntArray* pcuia ;
	int nid ;
	for (n = 0 ; n < nummodels ; n++) {
		cs.Format("\t%s\r\n", csamodels[n]) ;
		cssummary += cs ;
		pcuia = (CUIntArray*) m_pciwParent->m_ciwis.m_coaStdInstSecs[n] ;
		cs = cs3 = cs4 = csEmpty ;
		cs = "\t\t" ;
		nid = IDS_InstSecUni ;
		for (n2 = 0 ; n2 < NUMINSTSECFLAGS - 1 ; n2++, nid++)
			if ((*pcuia)[n2]) {
				cs2.LoadString(nid) ;
				cs4.Format("%s%s", cs3, cs2) ;
				cs += cs4 ;
				cs3 = _T(", ") ;
			} ;
		if ((*pcuia)[ISF_OTHER]) {
			cs4.Format("%s%s", cs3,
					   m_pciwParent->m_ciwis.m_csaOtherInstSecs[n]) ;
			cs += cs4 ;
		} ;
		cssummary += cs + csCRLF ;
	} ;

	// Add the data sections info to the summary

	cs.LoadString(IDS_DataSecsSumTxt) ;
	cssummary += cs ;
	for (n = 0 ; n < nummodels ; n++) {
		cs.Format("\t%s\r\n", csamodels[n]) ;
		cssummary += cs ;
		pcuia = (CUIntArray*) m_pciwParent->m_ciwds.m_coaStdDataSecs[n] ;
		cs = cs3 = cs4 = csEmpty ;
		cs = "\t\t" ;
		nid = IDS_DataSecUni ;
		for (n2 = 0 ; n2 < NUMDATASECFLAGS - 1 ; n2++, nid++)
			if ((*pcuia)[n2]) {
				cs2.LoadString(nid) ;
				cs4.Format("%s%s", cs3, cs2) ;
				cs += cs4 ;
				cs3 = _T(", ") ;
			} ;
		if ((*pcuia)[IDF_OTHER]) {
			cs4.Format("%s%s", cs3,
					   m_pciwParent->m_ciwds.m_csaOtherDataSecs[n]) ;
			cs += cs4 ;
		} ;
		cssummary += cs + csCRLF ;
	} ;

	// Add the nonstandard files info to the summary

	cs.LoadString(IDS_NonStdFilesSumTxt) ;
	cssummary += cs ;
	bfoundone = false ;
	for (n = 0 ; n < nummodels ; n++) {
		pcsa = (CStringArray*) m_pciwParent->m_ciwef.m_coaExtraFSArrays[n] ;
		if ((numstrs = (int)pcsa->GetSize()) > 0) {
			cs.Format("\t%s\r\n", csamodels[n]) ;	
			cssummary += cs ;
			bfoundone = true ;
			for (n2 = 0 ; n2 < numstrs ; n2++) {
				cs.Format("\t\t%s\r\n", pcsa->GetAt(n2)) ;
				cssummary += cs ;
			} ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;
	
	// Add the manufacturer and provider info to the summary

	cs.Format(IDS_MfgSumTxt, m_pciwParent->m_ciwmn.m_csMfgName) ;
	cssummary += cs ;
	cs.Format(IDS_ProvSumTxt, m_pciwParent->m_ciwmn.m_csMfgAbbrev) ;
	cssummary += cs ;

	// Add the nonstandard sections info to the summary

	cs.LoadString(IDS_NonStdSecSumTxt) ;
	cssummary += cs ;
	bfoundone = false ;
	CStringArray& csasections = m_pciwParent->m_ciwnse.m_csaSections ;
	nummodels = (int)csasections.GetSize() ;
	for (n = 0 ; n < nummodels ; n++) {
		pcsa = (CStringArray*) m_pciwParent->m_ciwnse.m_coaSectionArrays[n] ;
		if ((numstrs = (int)pcsa->GetSize()) > 0) {
			cs.Format("\t%s\r\n", csasections[n]) ;	
			cssummary += cs ;
			bfoundone = true ;
			for (n2 = 0 ; n2 < numstrs ; n2++) {
				cs.Format("\t\t%s\r\n", pcsa->GetAt(n2)) ;
				cssummary += cs ;
			} ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;

	// Add the nonstandard sections needed by models info to the summary

	cs.LoadString(IDS_NonStdModelsSumTxt) ;
	cssummary += cs ;
	bfoundone = false ;
	int numsections = (int) m_pciwParent->m_ciwnsms.m_csaSections.GetSize() ;
	for (n = 0 ; n < numsections ; n++) {
		pcsa = (CStringArray*)m_pciwParent->m_ciwnsms.m_coaModelsNeedingSecs[n];
		if ((numstrs = (int)pcsa->GetSize()) > 0) {
			cs.Format("\t%s\r\n", m_pciwParent->m_ciwnsms.m_csaSections[n]) ;	
			cssummary += cs ;
			bfoundone = true ;
			for (n2 = 0 ; n2 < numstrs ; n2++) {
				cs.Format("\t\t%s\r\n", pcsa->GetAt(n2)) ;
				cssummary += cs ;
			} ;
		} ;
	} ;
	if (!bfoundone) {
		cs.LoadString(IDS_NoneSumTxt) ;
		cssummary += cs ;
	} ;
	
	// Load the edit box, set the initialized flag, and return.

	m_ceSummary.SetSel(0, -1) ;
	m_ceSummary.ReplaceSel(cssummary) ;
	m_ceSummary.SetSel(0, 0) ;
	m_ceSummary.SetSel(-1, 0) ;
	m_ceSummary.SetReadOnly() ;
	m_bInitialized = true ;		// Page is initialized now
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CNewINFSection dialog

CNewINFSection::CNewINFSection(CWnd* pParent /*=NULL*/)
	: CDialog(CNewINFSection::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewINFSection)
	m_csNewSection = csEmpty;
	//}}AFX_DATA_INIT
}


void CNewINFSection::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewINFSection)
	DDX_Text(pDX, IDC_NewSectionBox, m_csNewSection);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewINFSection, CDialog)
	//{{AFX_MSG_MAP(CNewINFSection)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CNewINFSection message handlers

void CNewINFSection::OnOK()
{
	UpdateData() ;
	
	CDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
// CINFWizView

IMPLEMENT_DYNCREATE(CINFWizView, CEditView)

CINFWizView::CINFWizView()
{
	m_pcicdCheckDoc = NULL ;
	m_pcmcwCheckFrame = NULL ;
}


CINFWizView::~CINFWizView()
{
}


BEGIN_MESSAGE_MAP(CINFWizView, CEditView)
	//{{AFX_MSG_MAP(CINFWizView)
	ON_COMMAND(ID_FILE_Change_INF, OnFILEChangeINF)
	ON_COMMAND(ID_FILE_Check_INF, OnFILECheckINF)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizView drawing

void CINFWizView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CINFWizView diagnostics

#ifdef _DEBUG
void CINFWizView::AssertValid() const
{
	CEditView::AssertValid();
}

void CINFWizView::Dump(CDumpContext& dc) const
{
	CEditView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CINFWizView message handlers

void CINFWizView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
	// TODO: Add your specialized code here and/or call the base class
	
	CEditView::OnActivateView(bActivate, pActivateView, pDeactiveView);
}


void CINFWizView::OnInitialUpdate()
{
	// Set the frame's window style and initialize the edit box.

    GetParentFrame()->ModifyStyle(0, WS_OVERLAPPEDWINDOW) ;
	CEditView::OnInitialUpdate();
	
	// Set a default title for the window.

	CString cs ;
	cs.LoadString(IDS_INFFile) ;
	GetDocument()->SetTitle(cs) ;

	// Load the edit box with the contents of the INF file.

	GetEditCtrl().SetSel(0, -1) ;
	GetEditCtrl().ReplaceSel( ((CINFWizDoc*) GetDocument())->m_pciw->m_csINFContents ) ;
	GetEditCtrl().SetSel(0, 0) ;
	GetEditCtrl().SetSel(-1, 0) ;
//	GetEditCtrl().SetReadOnly() ;
}


void CINFWizView::OnFILEChangeINF()
{
	// Restart the wizard so that the users changes can be collected.

	CINFWizDoc* pciwd = (CINFWizDoc*) GetDocument() ;
	CINFWizard* pciw = pciwd->m_pciw ;
	pciw->PrepareToRestart() ;
    if (pciw->DoModal() == IDCANCEL)
		return ;

	// Regenerate the INF contents

	if (!pciw->GenerateINFFile())
		return ;

	// Load the edit box with the contents of the new INF.

	GetEditCtrl().SetSel(0, -1) ;
	GetEditCtrl().ReplaceSel(pciw->m_csINFContents) ;
	GetEditCtrl().SetSel(0, 0) ;
	GetEditCtrl().SetSel(-1, 0) ;
	GetEditCtrl().SetReadOnly() ;
}


void CINFWizView::OnFILECheckINF()
{
    //  This might take a while, so...

    CWaitCursor cwc ;

	// Remove the contents of any existing INF checking window and reset the
	// checking flag.

	ResetINFErrorWindow() ;

	// Get a pointer to the wizard class because it contains some functions
	// that will be useful to file checking process.

	CINFWizDoc* pciwd = (CINFWizDoc*) GetDocument() ;
	CINFWizard* pciw = pciwd->m_pciw ;

	// Get a reference to the array of selected models and a count of them.  Use
	// them to loop through each model.  Allocate all of the variables needed
	// for processing including the string to hold the various paths that will
	// be needed.

	CStringArray& csamodels = pciw->GetINFModels() ;
	int nummodels = (int)csamodels.GetSize() ;
	CString csfspec, cspath, csmodel, cs, cstmp,csprojpath ;
	//RAID 0001

if(pciw ->m_pcgc){
    cstmp      = pciwd->m_pcgc->GetPathName();
    cstmp      = cstmp.Left(cstmp.ReverseFind(csBSlash[0]));	//cstmp are used instead GetW2000()
	csprojpath = cstmp.Left(cstmp.ReverseFind(csBSlash[0])+1) ;
}	//END RAID 0001
else {
	csprojpath = pciwd->m_pcpr->GetProjFSpec() ;
	csprojpath = csprojpath.Left(csprojpath.ReverseFind(csBSlash[0]) + 1) ;
}
	CFileStatus cfs ;
	int n ;
	BOOL bexists ;

	// Do all of the checking for each model before moving on to the next one.

	for (n = 0 ; n < nummodels ; n++) {
		csmodel = csamodels[n] ;

		// Make sure that the GPD file for the model exists.

		csfspec = pciw->GetModelFile(csmodel, true) ;
		if (!(bexists = CFile::GetStatus(csfspec, cfs))) {
			cs.Format(IDS_INFChk_NoModErr, csmodel, csfspec) ;
			PostINFCheckingMessage(cs) ;
		} ;
		cspath = csfspec.Left(csfspec.ReverseFind(csBSlash[0]) + 1) ;

		// Verify the existence of the files referenced in include statements
		// in the current GPD file iff the GPD file exists.

		if (bexists)
			CheckIncludeFiles(csfspec, cspath, csmodel) ;

		// Check for the existence of the ICM files (if any) for this GPD.
		
		CheckArrayOfFiles((CStringArray*) pciw->m_ciwip.m_coaProfileArrays[n],
						  csfspec, cspath, csprojpath, csmodel,
						  IDS_INFChk_NoICMFileErr) ;

		// Check for the existence of the nonstd files (if any) for this GPD.

		CheckArrayOfFiles((CStringArray*) pciw->m_ciwef.m_coaExtraFSArrays[n],
						  csfspec, cspath, csprojpath, csmodel,
						  IDS_INFChk_NoNonStdFileErr) ;
	} ;

	// Check for the existence of the resource DLL.  First look for it in the
	// project directory.  If it isn't there, try the W2K directory.

	// RAID 0001
	if(pciw->m_pcgc)
		cs = pciw->m_pcgc->ModelData()->GetKeywordValue(pciw->m_pcgc->GetPathName(),_T("ResourceDLL"));
	else{	//END RAID 0001
		cs = pciwd->m_pcpr->DriverName() ;
		cs = cs.Left(8) + _T(".dll") ;		// Resource DLL name.
	} 
	if (!CFile::GetStatus(csprojpath + cs, cfs)) {
		cstmp = (pciw->m_pcgc) ? cstmp + csBSlash : pciwd->m_pcpr->GetW2000Path() + csBSlash ; //RAID 0001
		if (!CFile::GetStatus(cstmp + cs, cfs)) {
			cstmp.Format(IDS_INFChk_NoResDLLErr, (pciw->m_pcgc)? cs :
							pciwd->m_pcpr->DriverName(), cs) ;		//RAID 0001
		 PostINFCheckingMessage(cstmp) ;
		} ;
	} ;

	// Tell the user if no problems were found.

	if (!m_bChkingErrsFound)
		AfxMessageBox(IDS_INFChecksOK, MB_ICONINFORMATION) ;
}


void CINFWizView::CheckArrayOfFiles(CStringArray* pcsa, CString& csfspec,
									CString& cspath, CString& csprojpath,
									CString& csmodel, int nerrid)
{
	// There is nothing to do if there are no filespecs in the array.

	int numfiles ;
	if ((numfiles = (int)pcsa->GetSize()) == 0)
		return ;

	// Variables needed for file existence checking

	int n ;
	BOOL bexists ;
	CString csfile, csmsg ;
	CFileStatus cfs ;

	// Check for the existence of each file.

	for (n = 0 ; n < numfiles ; n++) {
		csfile = pcsa->GetAt(n) ;

		// If the file string contains a full filespec, just check it.

		if (csfile[1] == _T(':'))
			bexists = CFile::GetStatus(csfile, cfs) ;

		// Otherwise, add the GPD path and, if needed, the project path to the
		// file string and check to see if the file is there.

		else {
			if (!(bexists = CFile::GetStatus(cspath + csfile, cfs)))
				bexists = CFile::GetStatus(csprojpath + csfile, cfs) ;
		} ;

		// Post a message if the file was not found.

		if (!bexists) {
			csmsg.Format(nerrid, csmodel, csfile) ;
			PostINFCheckingMessage(csmsg) ;
		} ;
	} ;
}


void CINFWizView::CheckIncludeFiles(CString& csfspec, CString& cspath,
									CString& csmodel)
{
	// Variables needed to read the GPD and check include files.

	CStringArray csagpdfile ;
	CString csinc(_T("*Include:")), cs, cstmp ;
	int n, numstrs, nloc ;
	CFileStatus cfs ;

	// Include files can only be checked if the GPD file can be read.

	if (LoadFile(csfspec, csagpdfile))	{
		numstrs = (int)csagpdfile.GetSize() ;

		// Check each line in the GPD file to see if it contains an include
		// statement.

		for (n = 0 ; n < numstrs ; n++) {
			// Skip statement if not include statement

			if ((nloc = csagpdfile[n].Find(csinc)) == -1)
				continue ;

			// Isolate the filespec in the include statement

			cs = csagpdfile[n].Mid(nloc + csinc.GetLength()) ;
			cs.TrimLeft() ;
			cs.TrimRight() ;
			if (cs[0] == csQuote[0])					// Remove quotes
				cs = cs.Mid(1, cs.GetLength() - 2) ;

			// If the include file's filespec is relative, add the GPD's
			// path to it.  Then test for the file's existence.  Post a
			// message if the file does not exist.

			if (cs[1] != _T(':'))
				cs = cspath + cs ;
			if (!CFile::GetStatus(cs, cfs)) {
				cstmp.Format(IDS_INFChk_NoIncFileErr, csmodel, cs,
							 csfspec) ;
				PostINFCheckingMessage(cstmp) ;
			} ;
		} ;

	// Complain if the GPD file could not be read.

	} else {
		cstmp.Format(IDS_INFChk_GPDReadErr, csfspec) ;
		AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
	} ;
}


/******************************************************************************

  CINFWizView::PostINFCheckingMessage

  Create the checking results window if needed and then post a message to it.

******************************************************************************/

bool CINFWizView::PostINFCheckingMessage(CString& csmsg)
{
	// Clean up before continuing if the user closed the checking window.

	if (m_pcicdCheckDoc && m_pcmcwCheckFrame
	 && !IsWindow(m_pcmcwCheckFrame->m_hWnd)) {
		m_pcicdCheckDoc = NULL ;
		m_pcmcwCheckFrame = NULL ;
	} ;

	// Create the INF checking, error display window if one does not exist.

	if (m_pcicdCheckDoc == NULL) {
		m_pcicdCheckDoc = new CINFCheckDoc ;
		if (m_pcicdCheckDoc == NULL)
			return false ;
		CString cstitle ;		// Set the new window's title
		cstitle.Format(IDS_INFCheckTitle, GetDocument()->GetTitle()) ;
		m_pcicdCheckDoc->SetTitle(cstitle) ;
		CMultiDocTemplate*  pcmdt = WSCheckTemplate() ;	
		m_pcmcwCheckFrame = (CMDIChildWnd *) pcmdt->CreateNewFrame(m_pcicdCheckDoc, NULL) ;
		if  (m_pcmcwCheckFrame) {
			pcmdt->InitialUpdateFrame(m_pcmcwCheckFrame, m_pcicdCheckDoc, TRUE) ;
			pcmdt->AddDocument(m_pcicdCheckDoc) ;
		} else {
			delete m_pcicdCheckDoc ;
			m_pcicdCheckDoc = NULL ;
			return false ;
		} ;
	} ;

	// Post the message and return

	m_pcicdCheckDoc->PostINFChkMsg(csmsg) ;
	m_bChkingErrsFound = true ;
	return true ;
}


/******************************************************************************

  CINFWizView::ResetINFErrorWindow

  If there is an existing checking results window for this INF file, clear
  out its contents.  Next, initialize a flag that has to be set before the
  checking begins.

******************************************************************************/

void CINFWizView::ResetINFErrorWindow()
{
	// Clear the checking window if there is one.
  
 	if (m_pcicdCheckDoc && m_pcmcwCheckFrame && IsWindow(m_pcmcwCheckFrame->m_hWnd))
	 	m_pcicdCheckDoc->DeleteAllMessages() ;
	else {
		m_pcicdCheckDoc = NULL ;
		m_pcmcwCheckFrame = NULL ;
		// DEAD_BUG - Do I need to delete these classes first??? // No you can't.
	} ;

	// Initialize checking flag

	m_bChkingErrsFound = false ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizDoc

IMPLEMENT_DYNCREATE(CINFWizDoc, CDocument)

CINFWizDoc::CINFWizDoc()
{
	// This constructor is called when the File Open command is used.  That is
	// not supported at this point.

	m_bGoodInit = false ;
}


CINFWizDoc::CINFWizDoc(CProjectRecord* pcpr, CINFWizard* pciw)
{
	// Save the input parameters.

	m_pcpr = pcpr ;
	m_pciw = pciw ;
	ASSERT(m_pciw != NULL) ;

	// Class is correctly constructed.

	m_bGoodInit = true ;
}
//RAID 0001
CINFWizDoc::CINFWizDoc(CGPDContainer * pcgc, CINFWizard * pciw)
{
	m_pcgc = pcgc ;
	m_pciw = pciw ;
	ASSERT(m_pciw != NULL) ;

	// Class is correctly constructed.

	m_bGoodInit = true ;

}
// RAID 0001

BOOL CINFWizDoc::OnNewDocument()
{
	// Creating a new INF doc in this way is not supported.

	return FALSE ;

	//if (!CDocument::OnNewDocument())
	//	return FALSE;
	//return TRUE;
}


CINFWizDoc::~CINFWizDoc()
{
	// Do nothing if this class was not correctly constructed.

	if (!m_bGoodInit)
		return ;

	// Free the wizard classes if they exist.

	if (m_pciw != NULL)
		delete m_pciw ;
}


BEGIN_MESSAGE_MAP(CINFWizDoc, CDocument)
	//{{AFX_MSG_MAP(CINFWizDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFWizDoc diagnostics

#ifdef _DEBUG
void CINFWizDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CINFWizDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CINFWizDoc serialization

void CINFWizDoc::Serialize(CArchive& ar)
{
	unsigned unumbytes ;
	CString& csinfcontents = m_pciw->m_csINFContents ;

	if (ar.IsStoring())
	{
		unumbytes = csinfcontents.GetLength() ;
		ar.Write(csinfcontents.GetBuffer(unumbytes + 10), unumbytes) ;
		csinfcontents.ReleaseBuffer() ;
	}
	else
	{
		// TODO: add loading code here
	}
}


/////////////////////////////////////////////////////////////////////////////
// CINFWizDoc commands

void CINFWizDoc::OnCloseDocument()
{
	// Clean up the wizard if the class was correctly constructed.

	if (m_bGoodInit) {
		delete m_pciw ;
		m_pciw = NULL ;
	} ;

	CDocument::OnCloseDocument();
}


BOOL CINFWizDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
	// Opening an INF doc in this way is not supported so complain and exit.

	CString csmsg ;
	csmsg.LoadString(IDS_INFOpenError) ;
	AfxMessageBox(csmsg, MB_ICONINFORMATION) ;
	return FALSE ;

	//if (!CDocument::OnOpenDocument(lpszPathName))
	//	return FALSE;
	
	// TODO: Add your specialized creation code here
	
	//return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CINFCheckView

IMPLEMENT_DYNCREATE(CINFCheckView, CFormView)

CINFCheckView::CINFCheckView()
	: CFormView(CINFCheckView::IDD)
{
	//{{AFX_DATA_INIT(CINFCheckView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CINFCheckView::~CINFCheckView()
{
}

void CINFCheckView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CINFCheckView)
	DDX_Control(pDX, IDC_ErrWrnLstBox, m_clbMissingFiles);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CINFCheckView, CFormView)
	//{{AFX_MSG_MAP(CINFCheckView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFCheckView diagnostics

#ifdef _DEBUG
void CINFCheckView::AssertValid() const
{
	CFormView::AssertValid();
}

void CINFCheckView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CINFCheckView message handlers

/******************************************************************************

  CINFCheckView::OnInitialUpdate

  Resize the frame to better fit the visible controls in it.

******************************************************************************/

void CINFCheckView::OnInitialUpdate()
{
    CRect	crtxt ;				// Coordinates of list box label
	CRect	crlbfrm ;			// Coordinates of list box and frame

	CFormView::OnInitialUpdate() ;

	// Get the dimensions of the list box label

	HWND	hlblhandle ;		
	GetDlgItem(IDC_INFCLabel, &hlblhandle) ;
	::GetWindowRect(hlblhandle, crtxt) ;
	crtxt.NormalizeRect() ;

	// Get the dimensions of the list box and then add the height of the label
	// to those dimensions.

	m_clbMissingFiles.GetWindowRect(crlbfrm) ;
	crlbfrm.bottom += crtxt.Height() ;

	// Make sure the frame is big enough for these 2 controls plus a little bit
	// more.

	crlbfrm.right += 40 ;
	crlbfrm.bottom += 40 ;
    GetParentFrame()->CalcWindowRect(crlbfrm) ;
    GetParentFrame()->SetWindowPos(NULL, 0, 0, crlbfrm.Width(), crlbfrm.Height(),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE) ;
}


/******************************************************************************

  CINFCheckView::PostINFChkMsg

  Add an error or warning message to the list box.

******************************************************************************/

void CINFCheckView::PostINFChkMsg(CString& csmsg)
{	
	int n = m_clbMissingFiles.AddString(csmsg) ;
}


/******************************************************************************

  CINFCheckView::DeleteAllMessages

  Delete all of the messages in the list box.

******************************************************************************/

void CINFCheckView::DeleteAllMessages(void)
{
	m_clbMissingFiles.ResetContent() ;
}


/////////////////////////////////////////////////////////////////////////////
// CINFCheckDoc

IMPLEMENT_DYNCREATE(CINFCheckDoc, CDocument)

CINFCheckDoc::CINFCheckDoc()
{
}

BOOL CINFCheckDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;
	return TRUE;
}

CINFCheckDoc::~CINFCheckDoc()
{
}


/******************************************************************************

  CINFCheckDoc::PostINFChkMsg

  Pass the specified request on to what should be the one and only view
  attached to this document.

******************************************************************************/

void CINFCheckDoc::PostINFChkMsg(CString& csmsg)
{	
	POSITION pos = GetFirstViewPosition() ;
	if (pos != NULL) {
		CINFCheckView* pcicv = (CINFCheckView *) GetNextView(pos) ;
		pcicv->PostINFChkMsg(csmsg) ;
		pcicv->UpdateWindow() ;
	} ;
}


/******************************************************************************

  CINFCheckDoc::DeleteAllMessages

  Pass the specified request on to what should be the one and only view
  attached to this document.

******************************************************************************/

void CINFCheckDoc::DeleteAllMessages(void)
{
	POSITION pos = GetFirstViewPosition() ;
	if (pos != NULL) {
		CINFCheckView* pcicv = (CINFCheckView *) GetNextView(pos) ;
		pcicv->DeleteAllMessages() ;
		pcicv->UpdateWindow() ;
	} ;
}


BEGIN_MESSAGE_MAP(CINFCheckDoc, CDocument)
	//{{AFX_MSG_MAP(CINFCheckDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CINFCheckDoc diagnostics

#ifdef _DEBUG
void CINFCheckDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CINFCheckDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CINFCheckDoc serialization

void CINFCheckDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCompatID::CCompatID( CString csMfg, CString csModel )
{
   // Save the Parameters
   m_csMfg = csMfg;
   m_csModel = csModel;
}


CCompatID::~CCompatID()
{

}


void CCompatID::TransString(CString &csInput)
{
   // Walk Through the String changing Spaces to Underscores
   DWORD i;
   TCHAR cszSpace[] = TEXT(" ");
   TCHAR cszUS[] = TEXT("_");
   DWORD dwLength = csInput.GetLength();

   for ( i = 0; i < dwLength; i++ )
   {
      if (csInput.GetAt(i) == cszSpace[0])
         csInput.SetAt(i, cszUS[0]);
   }
}


USHORT CCompatID::GetCheckSum(CString csValue)
{
    WORD    wCRC16a[16]={
        0000000,    0140301,    0140601,    0000500,
        0141401,    0001700,    0001200,    0141101,
        0143001,    0003300,    0003600,    0143501,
        0002400,    0142701,    0142201,    0002100,
    };

    WORD    wCRC16b[16]={
        0000000,    0146001,    0154001,    0012000,
        0170001,    0036000,    0024000,    0162001,
        0120001,    0066000,    0074000,    0132001,
        0050000,    0116001,    0104001,    0043000,
    };

    BYTE    byte;
    USHORT  CS=0;
    DWORD   dwSize = csValue.GetLength();
    PBYTE   ptr = (PBYTE) csValue.GetBuffer(dwSize);

    dwSize *= sizeof(TCHAR);

    for ( ; dwSize ; --dwSize, ++ptr) {

        byte = (BYTE)(((WORD)*ptr)^((WORD)CS));  // Xor CRC with new char
        CS      = ((CS)>>8) ^ wCRC16a[byte&0x0F] ^ wCRC16b[byte>>4];
    }
    csValue.ReleaseBuffer();

    return CS;
}


void CCompatID::GenerateID(CString &csCompID)
{
   CString csTransModel, csMfgModel;

   // Build the Mfg Model string
   csMfgModel = m_csMfg;
   csMfgModel += m_csModel;

   // Convert the spaces to underscores
   TransString( csMfgModel );

   csTransModel = m_csModel;
   TransString( csTransModel );

   csCompID = csMfgModel;

   // Get the CheckSum
   USHORT usCheckSum = GetCheckSum( csCompID );


   // Now chop off the Mfg/Model string if too Long.
   if ( csCompID.GetLength() > MAX_DEVNODE_NAME_ROOT )
   {
      csCompID.GetBufferSetLength(MAX_DEVNODE_NAME_ROOT);
      csCompID.ReleaseBuffer();
   }

   TCHAR szCheckSum[6] = { 0x00 };
   // _itot( usCheckSum, szCheckSum, 16 );
   StringCchPrintf( szCheckSum, CCHOF(szCheckSum), _T("%04X"), usCheckSum );
   csCompID +=szCheckSum;

   //csCompID += TEXT(",");
   //csCompID += csTransModel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\gttview.h ===
/******************************************************************************

  Header File:  Glyph Map View.H

  This defines the classes used to edit and view the glyph mappings.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-20-1997    Bob_Kjelgaard@Prodigy.Net   Began work on it.

******************************************************************************/

/******************************************************************************

  CGlyphMappingPage class

  This class handles the property sheet page which displays a list of the
  individual code points in the glyph translatin table.

******************************************************************************/

class CGlyphMappingPage : public CPropertyPage {

    //  Sorting members and methods
    enum {Strings, Codes, Pages, Columns};
    BOOL    m_abDirection[Columns];   //  Sort directions;
    BYTE    m_bSortFirst, m_bSortSecond, m_bSortLast;

    static int CALLBACK MapSorter(LPARAM lp1, LPARAM lp2, LPARAM lp3);

    CGlyphMap*  m_pcgm;
    BOOL        m_bJustChangedSelectString; //  Semi-flaky work-around
    long        m_lPredefinedID;    //  So we know if we need to change this.
    unsigned    m_uTimer;           //  Using a timer for long fills
    unsigned    m_uidGlyph;         //  Used to track where we are on fills

// Construction
public:
	CGlyphMappingPage();
	~CGlyphMappingPage();

    void    Init(CGlyphMap* pcgm) { m_pcgm = pcgm; }

// Dialog Data
	//{{AFX_DATA(CGlyphMappingPage)
	enum { IDD = IDD_GlyphMappings };
	CProgressCtrl	m_cpcBanner;
	CListCtrl	m_clcMap;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGlyphMappingPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    //  Stuff Class Wizard doesn't know about, because we generate it from
    //  our on-the-fly context menus...
    afx_msg void    OnChangeInvocation();
    afx_msg void    OnChangeCodePage();
    afx_msg void    OnDeleteItem();
    afx_msg void    OnAddItem();
	// Generated message map functions
	//{{AFX_MSG(CGlyphMappingPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnEndlabeleditGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnGetdispinfoGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownGlyphMapping(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void LoadCharMapList() ;
};

/*****************************************************************************

  CCodePagePage class

  This class handles the property page which describes the code pages used
  along with their selection and deselection strings.

******************************************************************************/

class CCodePagePage : public CToolTipPage {
    CGlyphMap   *m_pcgm;
	bool		m_bInitialized ;	// True iff page has been initialized.
	bool		m_bSelDeselChgSignificant ;	// True iff a change to a sel/desel
											// editbox means contents should be
// Construction								// saved.
public:
	CCodePagePage();						   
	~CCodePagePage();

    void    Init(CGlyphMap * pcgm) { m_pcgm = pcgm; }
	void	SaveBothSelAndDeselStrings() ;
	void	SaveSelDeselString(CEdit &cesd, BOOL bselstr) ;

// Dialog Data
	//{{AFX_DATA(CCodePagePage)
	enum { IDD = IDD_CodePageView };
	CButton	m_cbDelete;
	CEdit	m_ceSelect;
	CEdit	m_ceDeselect;
	CButton	m_cbRemove;
	CListBox	m_clbPages;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCodePagePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCodePagePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusSelectString();
	afx_msg void OnKillfocusDeselectString();
	afx_msg void OnAddPage();
	afx_msg void OnSelchangeCodePageList();
	afx_msg void OnReplacePage();
	afx_msg void OnChangeSelectString();
	afx_msg void OnChangeDeselectString();
	afx_msg void OnDeletePage();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CPredefinedMaps class

  This class allows the user to specify a predefined mapping (if desired) and
  the way the code points in the table are ro be considered in relation to the
  same.

******************************************************************************/

class CPredefinedMaps : public CPropertyPage {
    CGlyphMap   *m_pcgm;

// Construction
public:
	CPredefinedMaps();
	~CPredefinedMaps();

    void    Init(CGlyphMap *pcgm) { m_pcgm = pcgm; }

// Dialog Data
	//{{AFX_DATA(CPredefinedMaps)
	enum { IDD = IDD_PredefinedPage };
	CListBox	m_clbIDs;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPredefinedMaps)
	public:
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPredefinedMaps)
	virtual BOOL OnInitDialog();
	afx_msg void OnOverstrike();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/******************************************************************************

  CGlyphMapView class

  This class is the view class for glyph maps.  It creates a property sheet
  using the above pages.

******************************************************************************/

class CGlyphMapView : public CView {
    CPropertySheet      m_cps;
    CGlyphMappingPage   m_cgmp;
    CCodePagePage       m_ccpp;
    CPredefinedMaps     m_cpm;

protected:
	CGlyphMapView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CGlyphMapView)

// Attributes
public:

    CGlyphMapContainer* GetDocument() { 
        return (CGlyphMapContainer *) m_pDocument; 
    }

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGlyphMapView)
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnInitialUpdate();     // first time after construct
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

public:
	void SaveBothSelAndDeselStrings() ;

// Implementation
protected:
	virtual ~CGlyphMapView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CGlyphMapView)
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\llist.cpp ===
// LinkedList.cpp: implementation of the CLinkedList class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "minidev.h"
#include "llist.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLinkedList::CLinkedList()
{
	m_dwSize ++ ; 
}

CLinkedList::~CLinkedList()
{
	m_dwSize -- ;
}

DWORD CLinkedList::Size()
{
	return m_dwSize ;
}



void CLinkedList::InitSize()
{
	m_dwSize = 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\infwizrd.h ===
#if !defined(AFX_INFWIZRD_H__D9592262_711B_11D2_ABFD_00C04FA30E4A__INCLUDED_)
#define AFX_INFWIZRD_H__D9592262_711B_11D2_ABFD_00C04FA30E4A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// INFWizrd.h : header file
//


class CINFWizard ;


#define MAX_DEVNODE_NAME_ROOT   20

/////////////////////////////////////////////////////////////////////////////
// CCompatID class used to generate pseudo PNP ID for each model

class CCompatID  
{
public:
	void GenerateID( CString &csCompID );
	CCompatID( CString csMfg, CString csModel );
	virtual ~CCompatID();

protected:
	USHORT GetCheckSum( CString csValue );
	void TransString( CString &csInput );
	CString m_csModel;
	CString m_csMfg;
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizWelcome dialog

class CINFWizWelcome : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizWelcome)

// Construction
public:
	CINFWizWelcome();
	~CINFWizWelcome();

// Dialog Data
	//{{AFX_DATA(CINFWizWelcome)
	enum { IDD = IDD_INFW_Welcome };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizWelcome)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizWelcome)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizModels dialog

class CINFWizModels : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizModels)

// Construction
public:
	CINFWizModels();
	~CINFWizModels();

// Dialog Data
	//{{AFX_DATA(CINFWizModels)
	enum { IDD = IDD_INFW_ChooseModels };
	CFullEditListCtrl	m_cfelcModels;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizModels)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizModels)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	CStringArray	m_csaModels ;		// Model names
	CStringArray	m_csaModelsLast ;	// Model names (copy of last ones sel'd)
	CStringArray	m_csaInclude ;		// Include strings for models
	unsigned		m_uNumModels ;		// Number of models in the project
	unsigned		m_uNumModelsSel ;	// Number of models selected for INF
	CString			m_csToggleStr ;		// String used in toggle column
	bool			m_bSelChanged ;		// True iff initial selections may have	// changed.
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizGetPnPIDs dialog

class CINFWizGetPnPIDs : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizGetPnPIDs)

// Construction
public:
	CINFWizGetPnPIDs();
	~CINFWizGetPnPIDs();

// Dialog Data
	//{{AFX_DATA(CINFWizGetPnPIDs)
	enum { IDD = IDD_INFW_ModelPnPIDS };
	CFullEditListCtrl	m_felcModelIDs;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizGetPnPIDs)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizGetPnPIDs)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
	CStringArray	m_csaModels ;		// Selected model names
	CStringArray	m_csaModelIDs ;		// PnP IDs for the selected models.

// Operations
public:
	void InitModelsIDListCtl() ;
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizBiDi dialog

class CINFWizBiDi : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizBiDi)

// Construction
public:
	CINFWizBiDi();
	~CINFWizBiDi();

// Dialog Data
	//{{AFX_DATA(CINFWizBiDi)
	enum { IDD = IDD_INFW_BiDi };
	CFullEditListCtrl	m_cfelcBiDi;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizBiDi)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Operations
public:
	void ModelChangeFixups(unsigned unummodelssel, CStringArray& csamodels,
						   CStringArray& csamodelslast) ;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizBiDi)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	CString			m_csToggleStr ;		// String used in toggle column
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	CUIntArray		m_cuaBiDiFlags ;	// Per model BIDI flags kept here
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizICMProfiles dialog

class CINFWizICMProfiles : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizICMProfiles)

// Construction
public:
	CINFWizICMProfiles();
	~CINFWizICMProfiles();

// Dialog Data
	//{{AFX_DATA(CINFWizICMProfiles)
	enum { IDD = IDD_INFW_ICMProfiles };
	CFullEditListCtrl	m_cfelcICMFSpecs;
	CListBox	m_clbModels;
	CButton	m_cbBrowse;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizICMProfiles)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Operations
public:
	void ModelChangeFixups(unsigned unummodelssel, CStringArray& csamodels,
						   CStringArray& csamodelslast) ;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizICMProfiles)
	afx_msg void OnBrowseBtn();
	afx_msg void OnSelchangeModelsLst();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	int				m_nCurModelIdx ;	// Index of model selected in list box

	// Array of CStringArray pointers.  One for each selected model.  Each
	// CStringArray will contain the ICM profile filespecs for a model.

	CObArray		m_coaProfileArrays ;
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizIncludeFiles dialog

class CINFWizIncludeFiles : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizIncludeFiles)

// Construction
public:
	CINFWizIncludeFiles();
	~CINFWizIncludeFiles();

// Dialog Data
	//{{AFX_DATA(CINFWizIncludeFiles)
	enum { IDD = IDD_INFW_IncludeFiles };
	CListBox	m_clbModels;
	CEdit	m_ceIncludeFile;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizIncludeFiles)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizIncludeFiles)
	afx_msg void OnSelchangeModelsLst();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
	CStringArray	m_csaModels ;		// Selected models
	CStringArray	m_csaIncFiles ;		// Include files for each model
	int				m_nCurModelIdx ;	// Index of model selected in list box
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizInstallSections dialog

#define	NUMINSTSECFLAGS 5		// Number of per model, install section flags
#define ISF_UNI			0		// Install section flag indexes
#define ISF_UNIBIDI		1
#define ISF_PSCR		2
#define ISF_TTF			3
#define ISF_OTHER		4

class CINFWizInstallSections : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizInstallSections)

// Construction
public:
	CINFWizInstallSections();
	~CINFWizInstallSections();

// Dialog Data
	//{{AFX_DATA(CINFWizInstallSections)
	enum { IDD = IDD_INFW_InstallSections };
	CListBox	m_clbModels;
	CString	m_csOtherSections;
	BOOL	m_bOther;
	BOOL	m_bPscript;
	BOOL	m_bTtfsub;
	BOOL	m_bUnidrvBidi;
	BOOL	m_bUnidrv;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizInstallSections)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizInstallSections)
	afx_msg void OnSelchangeModelsLst();
	afx_msg void OnOtherChk();
	afx_msg void OnPscriptChk();
	afx_msg void OnTtfsubChk();
	afx_msg void OnUnidrvBidiChk();
	afx_msg void OnUnidrvChk();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
	CStringArray	m_csaModels ;		// Selected models
	CObArray		m_coaStdInstSecs ;	// Standard install section info
	CStringArray	m_csaOtherInstSecs ;// Other install sections
	int				m_nCurModelIdx ;	// Index of model selected in list box

// Operations
public:
	void AddModelFlags(int nidx) ;
	int InitPageControls() ;
	void BiDiDataChanged() ;
} ;


#define	NUMDATASECFLAGS 4		// Number of per model, data section flags
#define IDF_UNI			0		// Data section flag indexes
#define IDF_UNIBIDI		1
#define IDF_PSCR		2
#define IDF_OTHER		3


/////////////////////////////////////////////////////////////////////////////
// CINFWizDataSections dialog

class CINFWizDataSections : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizDataSections)

// Construction
public:
	CINFWizDataSections();
	~CINFWizDataSections();

// Dialog Data
	//{{AFX_DATA(CINFWizDataSections)
	enum { IDD = IDD_INFW_DataSections };
	CListBox	m_clbModels;
	CString	m_csOtherSections;
	BOOL	m_bOther;
	BOOL	m_bPscript;
	BOOL	m_bUnidrvBidi;
	BOOL	m_bUnidrv;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizDataSections)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizDataSections)
	afx_msg void OnSelchangeModelsLst();
	afx_msg void OnOtherChk();
	afx_msg void OnPscriptChk();
	afx_msg void OnUnidrvBidiChk();
	afx_msg void OnUnidrvChk();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
	CStringArray	m_csaModels ;		// Selected models
	CObArray		m_coaStdDataSecs ;	// Standard data section info
	CStringArray	m_csaOtherDataSecs ;// Other data sections
	int				m_nCurModelIdx ;	// Index of model selected in list box

// Operations
public:
	void AddModelFlags(int nidx) ;
	int InitPageControls() ;
	void BiDiDataChanged() ;
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizExtraFiles dialog

class CINFWizExtraFiles : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizExtraFiles)

// Construction
public:
	CINFWizExtraFiles();
	~CINFWizExtraFiles();

// Dialog Data
	//{{AFX_DATA(CINFWizExtraFiles)
	enum { IDD = IDD_INFW_ExtraFiles };
	CFullEditListCtrl	m_cfelcFSpecsLst;
	CListBox	m_clbModels;
	CButton	m_cbBrowse;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizExtraFiles)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Operations
public:
	void ModelChangeFixups(unsigned unummodelssel, CStringArray& csamodels,
						   CStringArray& csamodelslast) ;

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizExtraFiles)
	afx_msg void OnSelchangeModelLst();
	afx_msg void OnBrowsBtn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	int				m_nCurModelIdx ;	// Index of model selected in list box

	// Array of CStringArray pointers.  One for each selected model.  Each
	// CStringArray will contain the extra filespecs for a model.

	CObArray		m_coaExtraFSArrays ;
	bool			m_bSelChanged ;		// True iff initial selections may have
										// changed.
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizMfgName dialog

class CINFWizMfgName : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizMfgName)

// Construction
public:
	CINFWizMfgName();
	~CINFWizMfgName();

// Dialog Data
	//{{AFX_DATA(CINFWizMfgName)
	enum { IDD = IDD_INFW_MfgName };
	CEdit	m_ceMfgAbbrev;
	CEdit	m_ceMfgName;
	CString	m_csMfgName;
	CString	m_csMfgAbbrev;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizMfgName)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizMfgName)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdElts dialog

class CINFWizNonStdElts : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizNonStdElts)

// Construction
public:
	CINFWizNonStdElts();
	~CINFWizNonStdElts();

// Dialog Data
	//{{AFX_DATA(CINFWizNonStdElts)
	enum { IDD = IDD_INFW_NonStdElements };
	CButton	m_ceNewSection;
	CFullEditListCtrl	m_felcKeyValueLst;
	CListBox	m_clbSections;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizNonStdElts)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizNonStdElts)
	afx_msg void OnSelchangeSectionLst();
	afx_msg void OnNewSectionBtn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	int				m_nCurSectionIdx ;	// Index of section selected in list box
	CStringArray	m_csaSections ;		// Array of INF file sections
	CUIntArray		m_cuaSecUsed ;		// An element is true iff section used

	// Array of CStringArray pointers.  One for each section.  Each CStringArray
	// will contain the extra filespecs for a model.

	CObArray		m_coaSectionArrays ;
	bool			m_bNewSectionAdded ;// True iff a new section was added
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizNonStdModelSecs dialog

class CINFWizNonStdModelSecs : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizNonStdModelSecs)

// Construction
public:
	CINFWizNonStdModelSecs();
	~CINFWizNonStdModelSecs();

// Dialog Data
	//{{AFX_DATA(CINFWizNonStdModelSecs)
	enum { IDD = IDD_INFW_NonStdModelSecs };
	CFullEditListCtrl	m_cfelcModelsLst;
	CListBox	m_clbSectionsLst;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizNonStdModelSecs)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizNonStdModelSecs)
	afx_msg void OnSelchangeSectionLst();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bSelChanged ;		// True iff initial selections may have
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
	int				m_nCurSectionIdx ;	// Index of section selected in list box
	CStringArray	m_csaModels ;		// Array of selected models
	CStringArray	m_csaSections ;		// Array of INF file sections
	CObArray		m_coaModelsNeedingSecs ;// Arrays of models needing sections
	CString			m_csToggleStr ;		// String used in toggle column

// Operations
public:
	void SaveSectionModelInfo() ;
	void NonStdSecsChanged() ;
	void UpdateSectionData() ;
	void InitModelsListCtl() ;
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizSummary dialog

class CINFWizSummary : public CPropertyPage
{
	DECLARE_DYNCREATE(CINFWizSummary)

// Construction
public:
	CINFWizSummary();
	~CINFWizSummary();

// Dialog Data
	//{{AFX_DATA(CINFWizSummary)
	enum { IDD = IDD_INFW_Summary };
	CEdit	m_ceSummary;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CINFWizSummary)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CINFWizSummary)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CINFWizard*		m_pciwParent ;
	bool			m_bInitialized ;	// True iff page has been initialized
	bool			m_bReInitWData ;	// True iff page should be reinitialized
										// with the existing data
};


// The following constants are used to piece together INF file contents.

const CString csLBrack(_T("[")) ;
const CString csRBrack(_T("]")) ;
const CString csEmpty(_T("")) ;
const CString csCRLF(_T("\r\n")) ;
const CString csEq(_T(" = ")) ;
const CString csComma(_T(",")) ;
const CString csCommaSp(_T(", ")) ;
const CString csQuote(_T("\"")) ;
const CString csAtSign(_T("@")) ;
const CString csBSlash(_T("\\")) ;


/////////////////////////////////////////////////////////////////////////////
// CINFWizard

class CINFWizard : public CPropertySheet
{
	CProjectView*	m_pcpvParent ;	// Parent window

	CProjectRecord*		m_pcpr ;	// Document class ptr

	DECLARE_DYNAMIC(CINFWizard)

// Construction
public:
	CINFWizard(CWnd* pParentWnd = NULL, UINT iSelectPage = 0) ;

// Attributes
public:
	CStringArray	m_csaSrcDskFiles ;	// Used to collect SourceDiskFiles names

// Operations
public:
	void SetFixupFlags() ;
	CProjectView* GetOwner() { return m_pcpvParent ; }
	CModelData& GetModel(unsigned uidx) ;
	unsigned GetModelCount() ;
	CStringArray& GetINFModels() { return m_ciwm.m_csaModels ; }
	CStringArray& GetINFModelsLst() { return m_ciwm.m_csaModelsLast ; }
	unsigned GetINFModsSelCount() { return m_ciwm.m_uNumModelsSel ; }
	bool GenerateINFFile() ;
	void ChkForNonStdAdditions(CString& cs, LPCTSTR strsection) ;
	void BldModSpecSec(CString& csinf) ;
	CString GetModelFile(CString& csmodel, bool bfspec = false) ;
	void BuildInstallAndCopySecs(CString& csinf) ;
	void QuoteFile(CString& csf) {
		if (csf.Find(_T(" ")) != -1)
			csf = csQuote + csf + csQuote ;
	} 
	void AddFileList(CString& cssection, CStringArray* pcsa) ;
	void AddSourceDisksFilesSec(CString& csinf) ;
	void AddNonStandardSecs(CString& csinf) ;
	void PrepareToRestart() ;
	void BiDiDataChanged() ;
	void AddDataSectionStmt(CString& csinst, int nmod) ;
	void AddIncludeNeedsStmts(CString& csinst, int nmod) ;
	void NonStdSecsChanged() ;
	void AddNonStdSectionsForModel(CString& csinst, int nmod, CString& csmodel);
	bool ReadGPDAndGetDLLName(CString& csdrvdll, CString& csmodel, 
							  CStringArray& csagpdfile, CString& csmodelfile) ;
	void AddICMFilesToDestDirs(CString& cssection) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CINFWizard)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CINFWizard();

	// Generated message map functions
protected:
	//{{AFX_MSG(CINFWizard)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	// Allocate class instances for each page

	CINFWizWelcome			m_ciww ;
	CINFWizModels			m_ciwm ;
	CINFWizGetPnPIDs		m_ciwgpi ;
	CINFWizBiDi				m_ciwbd ;
	CINFWizICMProfiles		m_ciwip ;
	CINFWizIncludeFiles		m_ciwif ;
	CINFWizInstallSections	m_ciwis ;
	CINFWizDataSections		m_ciwds ;
	CINFWizExtraFiles		m_ciwef ;
	CINFWizMfgName			m_ciwmn ;
	CINFWizNonStdElts		m_ciwnse ;
	CINFWizNonStdModelSecs	m_ciwnsms ;
	CINFWizSummary			m_ciws ;

	CString					m_csINFContents ;	// INF contents built here
	CUIntArray				m_cuiaNonStdSecsFlags ;	// Flags set when sec used
	CGPDContainer*			m_pcgc ; // RAID 0001
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CNewINFSection dialog

class CNewINFSection : public CDialog
{
// Construction
public:
	CNewINFSection(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewINFSection)
	enum { IDD = IDD_INFW_Sub_NewSection };
	CString	m_csNewSection;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewINFSection)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewINFSection)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CINFCheckView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CINFCheckView : public CFormView
{
protected:
	CINFCheckView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CINFCheckView)

// Form Data
public:
	//{{AFX_DATA(CINFCheckView)
	enum { IDD = IDD_INFCheck };
	CListBox	m_clbMissingFiles;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:
	void PostINFChkMsg(CString& csmsg) ;
	void DeleteAllMessages(void) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CINFCheckView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CINFCheckView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CINFCheckView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CINFCheckDoc document

class CINFCheckDoc : public CDocument
{
protected:
	//CINFCheckDoc();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CINFCheckDoc)

// Attributes
public:

// Operations
public:
	CINFCheckDoc();           // protected constructor used by dynamic creation
	void PostINFChkMsg(CString& csmsg) ;
	void DeleteAllMessages(void) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CINFCheckDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CINFCheckDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CINFCheckDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CINFWizView view

class CINFWizView : public CEditView
{
protected:
	CINFWizView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CINFWizView)

// Attributes
public:
	bool	m_bChkingErrsFound ;	// True iff file checking error(s) found
	CINFCheckDoc*	m_pcicdCheckDoc ;	// Checking windows document
	CMDIChildWnd*	m_pcmcwCheckFrame ;	// Checking window frame

// Operations
public:
	bool PostINFCheckingMessage(CString& csmsg) ;
	void CheckArrayOfFiles(CStringArray* pcsa, CString& csfspec, 
						   CString& cspath, CString& csprojpath, 
						   CString& csmodel, int nerrid) ;
	void CheckIncludeFiles(CString& csfspec, CString& cspath, CString& csmodel);
	void ResetINFErrorWindow() ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CINFWizView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CINFWizView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CINFWizView)
	afx_msg void OnFILEChangeINF();
	afx_msg void OnFILECheckINF();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CINFWizDoc document

class CINFWizDoc : public CDocument
{
protected:
	CINFWizDoc();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CINFWizDoc)

// Attributes
public:
	CProjectRecord*	m_pcpr ;		// Pointer to parent project (workspace)
	CINFWizard*		m_pciw ;		// Pointer to the INF's wizard
	bool			m_bGoodInit ;	// True iff the doc was correctly opened /
									// created / initialized.
	CGPDContainer*  m_pcgc ;		// RAID 0001. 
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CINFWizDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual void OnCloseDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
    CINFWizDoc(CGPDContainer* pcgc, CINFWizard* pciw);
	CINFWizDoc(CProjectRecord* cpr, CINFWizard* pciw);
	virtual ~CINFWizDoc();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CINFWizDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INFWIZRD_H__D9592262_711B_11D2_ABFD_00C04FA30E4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\llist.h ===
// llist.h: interface for the CLinkedList class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LINKEDLIST_H__34C04A7C_A22A_4B17_B6EF_4CB32E4F9756__INCLUDED_)
#define AFX_LINKEDLIST_H__34C04A7C_A22A_4B17_B6EF_4CB32E4F9756__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CLinkedList  
{
public:
	
	
	static DWORD Size();
	static void InitSize();
	CLinkedList* Next;
	
	WORD data;
	CLinkedList();
	virtual ~CLinkedList();
	
private:
	static DWORD m_dwSize;
};

#endif // !defined(AFX_LINKEDLIST_H__34C04A7C_A22A_4B17_B6EF_4CB32E4F9756__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\modldata.cpp ===
/******************************************************************************

  Source File: Model Data Knowledge Base.CPP
  
  This implements the DLL initialization routines for the DLL, for starters.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-19-1997    Bob_Kjelgaard@Prodigy.Net   Created it

*******************************************************************************/

#include    "StdAfx.H"
//#include    <AfxDllX.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/******************************************************************************

  DllMain

  DLL initialization routine.  This has the responsibility of adding this DLL
  to the recognized sets of extensions, so the MFC methods for resource sharing
  will work properly.

******************************************************************************/

/*** Commented out because this is no longer part of a DLL.

static AFX_EXTENSION_MODULE ModelDataKnowledgeBaseDLL = {NULL, NULL};

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved) {
	UNREFERENCED_PARAMETER(lpReserved);

	if (dwReason == DLL_PROCESS_ATTACH) {
		TRACE0("Model Data Knowledge Base.Dll Initializing!\n");
		
		if (!AfxInitExtensionModule(ModelDataKnowledgeBaseDLL, hInstance))
			return 0;

		new CDynLinkLibrary(ModelDataKnowledgeBaseDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH) 	{
		TRACE0("Model Data Knowledge Base.Dll Terminating!\n");
		AfxTermExtensionModule(ModelDataKnowledgeBaseDLL);
	}
	return 1;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\mainfrm.cpp ===
/******************************************************************************

  Source File:  Main Frame.CPP

  This implements the main frame class for the application.  Since MFC does
  so much for us, this file's going to be pretty empty, for a while, at least.

  Copyright (c) 1997 by Microsoft Corporaiton.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
#if defined(LONG_NAMES)
#include    "MiniDriver Developer Studio.H"

#include    "Main Frame.h"
#else
#include    "MiniDev.H"
#include    "MainFrm.H"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	ON_WM_INITMENU()
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, CMDIFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_HELP, CMDIFrameWnd::OnHelp)
	//ON_COMMAND(ID_CONTEXT_HELP, CMDIFrameWnd::OnContextHelp)
	//ON_COMMAND(ID_DEFAULT_HELP, CMDIFrameWnd::OnHelpFinder)
END_MESSAGE_MAP()

static UINT indicators[] = {
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame() {
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame() {
}

static TCHAR    sacToolBarSettings[] = _TEXT("Tool Bar Settings");

/******************************************************************************

  CMainFrame::OnCreate

  This is a standard App-Wizard supplied skeleton for the code to be called
  when the main window frame is created.  Primary modification made to date is
  the addition of an additional toolbar, and toolbar state restoration.

******************************************************************************/

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) {
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_ctbMain.Create(this) || !m_ctbBuild.Create(this, WS_CHILD |
        WS_VISIBLE | CBRS_TOP, AFX_IDW_TOOLBAR + 1) ||
		!m_ctbMain.LoadToolBar(IDR_MAINFRAME) || 
        !m_ctbBuild.LoadToolBar(IDR_GPD_VIEWER)) {
		TRACE0("Failed to create toolbars\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT))) {
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	m_ctbMain.SetBarStyle(m_ctbMain.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
    m_ctbBuild.SetBarStyle(m_ctbBuild.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// Dock the tool bars
	m_ctbMain.EnableDocking(CBRS_ALIGN_ANY);
    m_ctbBuild.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_ctbMain);
    DockControlBar(&m_ctbBuild);
    LoadBarState(sacToolBarSettings);

	// Replace a bogus, GPD tool bar button with the Search edit box.  

	CRect cr ;		 
	int nidx = m_ctbBuild.CommandToIndex(ID_BOGUS_SBOX) ;
	m_ctbBuild.SetButtonInfo(nidx, ID_BOGUS_SBOX, TBBS_SEPARATOR, GPD_SBOX_WIDTH) ;
	m_ctbBuild.GetItemRect(nidx, &cr) ;
	if (!m_ctbBuild.ceSearchBox.Create(ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE
	 | WS_BORDER, cr, &m_ctbBuild, IDC_SearchBox)) {
		TRACE0("Failed to create search edit box.\n");
		return -1;      // fail to create
	} ;

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs) {
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const {
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const {
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::OnInitMenu(CMenu* pMenu)
{
   CMDIFrameWnd::OnInitMenu(pMenu);

//#if defined(NOPOLLO)   //  CSRUS
  
	// CG: This block added by 'Tip of the Day' component.
	{
		// TODO: This code adds the "Tip of the Day" menu item
		// on the fly.  It may be removed after adding the menu
		// item to all applicable menu items using the resource
		// editor.

		// Add Tip of the Day menu item on the fly!
		static CMenu* pSubMenu = NULL;

		CString strHelp; strHelp.LoadString(CG_IDS_TIPOFTHEDAYHELP);
		CString strMenu;
		int nMenuCount = pMenu->GetMenuItemCount();
		BOOL bFound = FALSE;
		for (int i=0; i < nMenuCount; i++) 
		{
			pMenu->GetMenuString(i, strMenu, MF_BYPOSITION);
			if (strMenu == strHelp)
			{ 
				pSubMenu = pMenu->GetSubMenu(i);
				bFound = TRUE;
				ASSERT(pSubMenu != NULL);
			}
		}

		CString strTipMenu;
		strTipMenu.LoadString(CG_IDS_TIPOFTHEDAYMENU);
		if (!bFound)
		{
			// Help menu is not available. Please add it!
			if (pSubMenu == NULL) 
			{
				// The same pop-up menu is shared between mainfrm and frame 
				// with the doc.
				static CMenu popUpMenu;
				pSubMenu = &popUpMenu;
				pSubMenu->CreatePopupMenu();
				pSubMenu->InsertMenu(0, MF_STRING|MF_BYPOSITION, 
					CG_IDS_TIPOFTHEDAY, strTipMenu);
			} 
			pMenu->AppendMenu(MF_STRING|MF_BYPOSITION|MF_ENABLED|MF_POPUP, 
				(UINT_PTR)pSubMenu->m_hMenu, strHelp);
			DrawMenuBar();
		} 
		else
		{      
			// Check to see if the Tip of the Day menu has already been added.
			pSubMenu->GetMenuString(0, strMenu, MF_BYPOSITION);

			if (strMenu != strTipMenu) 
			{
				// Tip of the Day submenu has not been added to the 
				// first position, so add it.
				pSubMenu->InsertMenu(0, MF_BYPOSITION);  // Separator
				pSubMenu->InsertMenu(0, MF_STRING|MF_BYPOSITION, 
					CG_IDS_TIPOFTHEDAY, strTipMenu);
			}
		}
	}
//#endif
}

/******************************************************************************

  CMainFrame::OnDestroy

  This member function. called when the frame is to be destroyed, saves the
  toolbar states, before proceeding to do the normal kinds of stuff...

******************************************************************************/

void CMainFrame::OnDestroy() {

    //  Save the tool bar states.
    SaveBarState(sacToolBarSettings);

    CMDIFrameWnd::OnDestroy();
}


/******************************************************************************

  CMainFrame::GetGPDSearchString

  Load the specified string with the search string in the GPD Search string edit 
  box on the GPD tool bar.

******************************************************************************/

void CMainFrame::GetGPDSearchString(CString& cstext)
{
	m_ctbBuild.ceSearchBox.GetWindowText(cstext) ;
}


/******************************************************************************

  CMainFrame::OnViewStatusBar

  Show the status bar if the command is not checked.  Otherwise, hide the status
  bar.  Then update the window and the menu command.

******************************************************************************/

/*

  This routine does not check and uncheck the menu command for some reason
  and turning off the status bar turns off the GPD tool bar, too.  There
  are problems because of the ID used for the GPD tool bar.  Maybe, I should
  try to just add the tool bar when a GPD is displayed...

void CMainFrame::OnViewStatusBar() 
{
	CMenu* pcm = GetMenu() ;
	unsigned ustate = pcm->GetMenuState(ID_VIEW_STATUS_BAR, MF_BYCOMMAND) ;
	if (ustate & MF_CHECKED) {
		m_wndStatusBar.ShowWindow(SW_HIDE) ;
		pcm->CheckMenuItem(ID_VIEW_STATUS_BAR, MF_UNCHECKED) ;
	} else {
		m_wndStatusBar.ShowWindow(SW_SHOW) ;
		pcm->CheckMenuItem(ID_VIEW_STATUS_BAR, MF_CHECKED) ;
	} ;
	RecalcLayout() ;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\nconvert.cpp ===
// NewProject.cpp : implementation file
//


#include "stdafx.h"
#include "minidev.h"

#include "codepage.h"

#include    <wingdi.h>
#include    <winddi.h>
#include    <prntfont.h>
#include    <uni16res.h>

#include  "gtt.h"
#include  "nconvert.h" 

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConvPfmDlg property page

IMPLEMENT_DYNCREATE(CConvPfmDlg, CPropertyPage)

CConvPfmDlg::CConvPfmDlg() : CPropertyPage(CConvPfmDlg::IDD)
{

	//{{AFX_DATA_INIT(CConvPfmDlg)
	m_csGttPath = _T("");
	m_csPfmPath = _T("");
	m_csUfmDir = _T("");
	//}}AFX_DATA_INIT
}

CConvPfmDlg::~CConvPfmDlg()
{
}

void CConvPfmDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConvPfmDlg)
	DDX_Control(pDX, IDC_ComboCodePage, m_ccbCodepages);
	DDX_Text(pDX, IDC_GttPath, m_csGttPath);
	DDX_Text(pDX, IDC_PfmFiles, m_csPfmPath);
	DDX_Text(pDX, IDC_UfmDir, m_csUfmDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConvPfmDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CConvPfmDlg)
	ON_BN_CLICKED(IDC_GTTBrowser, OnGTTBrowser)
	ON_BN_CLICKED(IDC_PFMBrowser, OnPFMBrowsers)
	ON_CBN_SELCHANGE(IDC_ComboCodePage, OnSelchangeComboCodePage)
	ON_BN_CLICKED(IDC_UfmDirBrowser, OnUfmDirBrowser)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvPfmDlg message handlers

BOOL CConvPfmDlg::OnWizardFinish() 
{
	CString csErr ; 


	if( ConvPFMToUFM() ) {
		csErr.Format(IDS_NewUFM,m_csUfmDir) ;
		AfxMessageBox(csErr,MB_ICONINFORMATION) ;
	}
	else
	{
		csErr.LoadString(IDS_NewUFMError);
		AfxMessageBox(csErr,MB_ICONEXCLAMATION) ;
	}
	return CPropertyPage::OnWizardFinish();
}

LRESULT CConvPfmDlg::OnWizardBack() 
{
	
	// restore the parent propertysheet dialog.
	EndDialog(IDD_ConvertPFM) ;
	return CPropertyPage::OnWizardBack();
}


BOOL CConvPfmDlg::OnSetActive() 
{
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_DISABLEDFINISH) ;	
	((CPropertySheet*)GetParent())->GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;

	CCodePageInformation ccpi ;
	unsigned unumcps = ccpi.InstalledCount() ;

	// Get the installed code page numbers and load them into the code page
	// list box.

	DWORD dwcp, dwdefcp ;
	dwdefcp = GetACP() ;
	TCHAR accp[32] ;
	int n ; ;
	for (unsigned u = 0 ; u < unumcps ; u++) {
		dwcp = ccpi.Installed(u) ;

		// There are 3 code pages that seem to make MultiByteToWideChar() to 
		// fail.  Don't let the user choose one of those code pages unless
		// he knows the secret password (ie, undocument command line switch
		// 'CP').

		if (ThisApp().m_bExcludeBadCodePages)
			if (dwcp == 1361 || dwcp == 28595 || dwcp == 28597) 
				continue ;

		wsprintf(accp, "%5d", dwcp) ;
		n = m_ccbCodepages.AddString(accp) ;
		if (dwcp == 1252) // change dwdefcp to 1252 due to not support DBCS.
			m_ccbCodepages.SetCurSel(n) ;
	} ;
	return CPropertyPage::OnSetActive();
}

void CConvPfmDlg::OnGTTBrowser() 
{
	UpdateData() ;
	CString csFilter = _T("GTT File(*.gtt)|*.gtt||") ;
	CString csExtension = _T(".GTT") ;
	CFileDialog cfd(TRUE, csExtension, NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST ,csFilter);
	
	if  (cfd.DoModal() == IDOK) {
        m_csGttPath = cfd.GetPathName() ;
		UpdateData(FALSE) ;	
	} ;
	
	
}

void CConvPfmDlg::OnPFMBrowsers() 
{
	UpdateData() ;
	CString csFilter( _T("PFM Files (*.pfm)|*.pfm||") ) ; 
	
	CFileDialog cfd(TRUE, _T(".ctt"), NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        this);

	cfd.m_ofn.lpstrFile = new char[4096];
	memset(cfd.m_ofn.lpstrFile,0,4096);
	cfd.m_ofn.nMaxFile = 4096;
    if  (cfd.DoModal() != IDOK) {
        delete cfd.m_ofn.lpstrFile ;
		return;
	}
	// save the file path to member string array 	
	for (POSITION pos = cfd.GetStartPosition(); pos; ) {

		m_csaPfmFiles.Add(cfd.GetNextPathName(pos)) ;
	}
	
	m_csPfmPath = m_csaPfmFiles[0] ;
	// GTT directory is same with the CTT directory as default.
	m_csUfmDir = m_csPfmPath.Left(m_csPfmPath.ReverseFind(_T('\\') ) );
	SetCurrentDirectory(m_csUfmDir) ;
	UpdateData(FALSE) ;

	if(m_csPfmPath.GetLength() )
		((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH) ;		
	
}


/**************************************************************************************
bool CConvPfmDlg::OnUfmDirBrowser()
Do ; just directory browser
Args 
Ret.

***************************************************************************************/

void CConvPfmDlg::OnUfmDirBrowser() 
{
	OPENFILENAME    ofn ;       // Used to send/get info to/from common dlg
    char    acpath[_MAX_PATH] ; // Path is saved here (or an error message)
//    char    acidir[_MAX_PATH] ; // Initial directory is built here
    BOOL    brc = FALSE ;       // Return code

	// Update the contents of csinitdir

	UpdateData(TRUE) ;

    // Load the open file name structure

    ofn.lStructSize = sizeof(ofn) ;
    ofn.hwndOwner = m_hWnd ;
    ofn.hInstance = GetModuleHandle(_T("MINIDEV.EXE")) ;
    ofn.lpstrFilter = ofn.lpstrCustomFilter = NULL ;
    ofn.nMaxCustFilter = ofn.nFilterIndex = 0 ;
    strcpy(acpath, _T("JUNK")) ;	// No need to localize this string
    ofn.lpstrFile = acpath ;
    ofn.nMaxFile = _MAX_PATH ;
    ofn.lpstrFileTitle = NULL ;
    ofn.nMaxFileTitle = 0 ;
	ofn.lpstrInitialDir = m_csUfmDir ; //  in parent dialog box
    ofn.lpstrTitle = NULL ;
    ofn.Flags = OFN_HIDEREADONLY /*| OFN_ENABLEHOOK */| OFN_NOCHANGEDIR
        | OFN_NOTESTFILECREATE | OFN_ENABLETEMPLATE | OFN_NONETWORKBUTTON ;
    ofn.lpstrDefExt = NULL ;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPENORD) ;
    ofn.lpfnHook = NULL ;// BrowseDlgProc ;

    // Display the dialog box.  If the user cancels, just return.

    if (!GetOpenFileName(&ofn))
		return ;

    // Take the bogus file name off the path and put the path into the page's
	// edit box.

    acpath[ofn.nFileOffset - 1] = 0 ;
    
	m_csUfmDir = (LPCTSTR) acpath ;


	UpdateData(FALSE) ;
	
}


/**************************************************************************************
bool CConvPfmDlg::OnSelchangeComboCodePage()
Do ;DBCS code page convert does not supported in this version. so we have to show exclamtion
messag to the user when they select DBCS code page; the reason of showing DBCS in the list
although they are not supported is that it cann't less confusing to the user.

Args 
Ret.

***************************************************************************************/


// 
void CConvPfmDlg::OnSelchangeComboCodePage() 
{
	CString csCodepage ;
	DWORD   dwCodepage ;
	m_ccbCodepages.GetLBText(m_ccbCodepages.GetCurSel(),csCodepage) ;

	dwCodepage = atoi(csCodepage) ;


	if (dwCodepage == 932 || dwCodepage == 936 || dwCodepage == 949 || dwCodepage == 950 ) {
		AfxMessageBox(_T("DBCS conversion is not supported in this version"),MB_ICONINFORMATION) ;
		DWORD dwacp = GetACP() ;
		TCHAR acp[16] ;
		wsprintf(acp, "%5d",dwacp) ;
		int nI = m_ccbCodepages.FindString(-1,acp ) ;
		m_ccbCodepages.SetCurSel(nI ) ;
	} ;
		

} ;

struct sGTTHeader {
    DWORD   m_dwcbImage;
    enum    {Version1Point0 = 0x10000};
    DWORD   m_dwVersion;
    DWORD   m_dwfControl;   //  Any flags defined?
    long    m_lidPredefined;
    DWORD   m_dwcGlyphs;
    DWORD   m_dwcRuns;
    DWORD   m_dwofRuns;
    DWORD   m_dwcCodePages;
    DWORD   m_dwofCodePages;
    DWORD   m_dwofMapTable;
    DWORD   m_dwReserved[2];
    sGTTHeader() {
        memset(this, 0, sizeof *this);
        m_dwVersion = Version1Point0;
        m_lidPredefined = CGlyphMap::NoPredefined;
        m_dwcbImage = sizeof *this;
    }
};

extern "C" {

    BOOL    BConvertPFM(LPBYTE lpbPFM, DWORD dwCodePage, LPBYTE lpbGTT,
                        PWSTR pwstrUnique, LPCTSTR lpstrUFM, int iGTTID);

	PUNI_GLYPHSETDATA PGetDefaultGlyphset(
	IN		HANDLE		hHeap,
	IN		WORD		wFirstChar,
	IN		WORD		wLastChar,
	IN		DWORD		dwCodePage) ;


}

/**************************************************************************************
bool CConvPfmDlg::ConvPFMToUFM()
Do ; this is workhorse. untimately, all routine exist for BConvertPFM; correct codepage
inside gtt file, ufm directory, gtt files or resource gtt or default. new UFM files 
are created inside BConvertPFM function. just set correct UFM path.

Args .
Ret.

***************************************************************************************/
bool CConvPfmDlg::ConvPFMToUFM()
{
	// Call BConvertPFM for each PFM data with codepage, gtt data if exist,
	// ufm file path and name, 
	CByteArray cbaGTT ;
	// loading the GTT
	// change the codepage value of GTT(
	CString csCodePage ;
	DWORD   dwCodePage ;
	m_ccbCodepages.GetLBText(m_ccbCodepages.GetCurSel(),csCodePage) ;
	dwCodePage = atoi(csCodePage) ;

	// loading the GTT file when there is gtt file or we have to use resource file or 
	// default GTT file instead of real GTT file
	if (m_csGttPath.GetLength() ) {

		try {
			CFile   cfLoad(m_csGttPath, CFile::modeRead | CFile::shareDenyWrite);
			cbaGTT.SetSize(cfLoad.GetLength());
			cfLoad.Read(cbaGTT.GetData(), cfLoad.GetLength());
		}

		catch   (CException   *pce) {
			pce -> ReportError();
			pce -> Delete();
			cbaGTT.RemoveAll();
			return false;
		}
	
	} 
	else
	{
		short sid = (short)dwCodePage ;
		if(MAKEINTRESOURCE((sid < 0) ? -sid : sid) == NULL)
			return false ;

        HRSRC hrsrc = FindResource(AfxGetResourceHandle(),
            MAKEINTRESOURCE((sid < 0) ? -sid : sid),
            MAKEINTRESOURCE(IDR_GLYPHMAP));
        if  (hrsrc) {
			HGLOBAL hg = LoadResource(AfxGetResourceHandle(), hrsrc) ;
			if  (!hg)
				return false;
			LPVOID  lpv = LockResource(hg) ;
			if  (!lpv)
				return false ;
			cbaGTT.SetSize(SizeofResource(AfxGetResourceHandle(), hrsrc)) ;
			memcpy(cbaGTT.GetData(), lpv, (size_t)cbaGTT.GetSize()) ;
			return false ;
		} ;

		//AfxMessageBox("GTT building code reached.") ;

		// If all else fails, try to generate a GTT based on the code page ID
		// that should be in m_wID if this point is reached.

        HANDLE   hheap ;
        UNI_GLYPHSETDATA *pGTT ;
        if (!(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024))) {
			AfxMessageBox(IDS_HeapInGLoad) ;
			return false ;
		} ;
		pGTT = PGetDefaultGlyphset(hheap, 0x20, 0xff,
								   (DWORD) sid) ;
		if (pGTT == NULL) {
			HeapDestroy(hheap) ;		//raid 116600 Prefix
			AfxMessageBox(IDS_PGetFailedInGLoad) ;
			return false ;
		} ;
		cbaGTT.SetSize(pGTT->dwSize) ;
		memcpy(cbaGTT.GetData(), pGTT, (size_t)cbaGTT.GetSize()) ;
		HeapDestroy(hheap) ;
    }

	// Creating the UFM Path
	UpdateData() ;
	SECURITY_ATTRIBUTES st;
	st.nLength = sizeof(SECURITY_ATTRIBUTES);
	st.lpSecurityDescriptor = NULL;
	st.bInheritHandle = FALSE ;

	WIN32_FIND_DATA wfd32 ;
	HANDLE hDir = FindFirstFile(m_csUfmDir,&wfd32) ;
	if (hDir == INVALID_HANDLE_VALUE) {
		if (!CreateDirectory(m_csUfmDir,&st) ) {
			CString csmsg ;
			csmsg = _T("Fail to create the template directory") ;
			AfxMessageBox(csmsg) ;
			return false ;
		} 
	} ;

	//Set the GTT codepage with selected code page by user
	union {
		BYTE* pbGTT ;
		sGTTHeader* psGTTH ;
	} ;

	pbGTT = cbaGTT.GetData() ;
	if (!pbGTT)
		return false ;
	PUNI_CODEPAGEINFO pCodepage = (PUNI_CODEPAGEINFO)(pbGTT + psGTTH->m_dwofCodePages );
	CopyMemory(&pCodepage->dwCodePage,&dwCodePage,sizeof(DWORD) ) ;
	
	// Convert the PFM to UFM: calling the BConvertPFM for every selected PFM files
	CCodePageInformation ccpi ;
	
	for ( int i = 0 ; i < m_csaPfmFiles.GetSize() ; i++ ) {
		// loading the PFM
		CString csPFMPath = m_csaPfmFiles[i] ;
		
		CByteArray cbaPFM ;
		try {
			CFile   cfLoad(csPFMPath, CFile::modeRead | CFile::shareDenyWrite);
			cbaPFM.SetSize(cfLoad.GetLength());
			cfLoad.Read(cbaPFM.GetData(), cfLoad.GetLength());
			cfLoad.Close() ;
		}
		
		catch   (CException   *pce) {
			pce -> ReportError();
			pce -> Delete();
			cbaPFM.RemoveAll();
			return  false ;
		}

		CString csUFMName = csPFMPath.Mid(csPFMPath.ReverseFind(_T('\\') )+1 ) ;
		
		csUFMName = csUFMName.Left(csUFMName.ReverseFind(('.')) ) ;
		csUFMName.MakeUpper() ;
		CString csUFMPath = m_csUfmDir + _T("\\") + csUFMName + _T(".UFM") ;
		
		// convert ansi unique name to unicode.
		CByteArray  cbaIn;
        CWordArray  cwaOut;

        cbaIn.SetSize(1 + csUFMName.GetLength());
        lstrcpy((LPSTR) cbaIn.GetData(), (LPCTSTR) csUFMName);
        ccpi.Convert(cbaIn, cwaOut, GetACP());
		
		// Call the global function BConvertPFM, BConvertPFM creat the UFM file under the
		// specified path.
		if(!BConvertPFM(cbaPFM.GetData(), dwCodePage, cbaGTT.GetData(),
				cwaOut.GetData(), csUFMPath, (short) 0 ) )
			return false;
		// clear the data field

//		cbaPFM.RemoveAll() ;
//		cwaOut.RemoveAll() ;
		

	}

	return true ;
}

/////////////////////////////////////////////////////////////////////////////
// CConverPFM

IMPLEMENT_DYNAMIC(CConvertPFM, CPropertySheet)

CConvertPFM::CConvertPFM(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CConvertPFM::CConvertPFM(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{

	AddPage(&m_ccpd) ;

	SetWizardMode() ;


}

CConvertPFM::~CConvertPFM()
{
}


BEGIN_MESSAGE_MAP(CConvertPFM, CPropertySheet)
	//{{AFX_MSG_MAP(CConverPFM)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConverPFM message handlers

/////////////////////////////////////////////////////////////////////////////
// CConvCttDlg property page

IMPLEMENT_DYNCREATE(CConvCttDlg, CPropertyPage)

CConvCttDlg::CConvCttDlg() : CPropertyPage(CConvCttDlg::IDD)
{
	//{{AFX_DATA_INIT(CConvCttDlg)
	m_csCttPath = _T("");
	m_csGttDir = _T("");
	//}}AFX_DATA_INIT
}

CConvCttDlg::~CConvCttDlg()
{
}

void CConvCttDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConvCttDlg)
	DDX_Control(pDX, IDC_COMBO_Codepage, m_ccbCodepages);
	DDX_Text(pDX, IDC_EDIT_CTTFile, m_csCttPath);
	DDX_Text(pDX, IDC_GttDirectory, m_csGttDir);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConvCttDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CConvCttDlg)
	ON_BN_CLICKED(IDC_CTTBrowser, OnCTTBrowser)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvCttDlg message handlers

BOOL CConvCttDlg::OnWizardFinish() 
{
	CString csErr ;
	if(ConvCTTToGTT() ) {
		csErr.Format(IDS_NewGTT,m_csGttDir) ;
		AfxMessageBox(csErr,MB_ICONINFORMATION) ;
	}
	else
	{
		csErr.LoadString(IDS_NewGTTError);
		AfxMessageBox(csErr,MB_ICONEXCLAMATION) ;
	}
	
	return CPropertyPage::OnWizardFinish();
}

LRESULT CConvCttDlg::OnWizardBack() 
{
	EndDialog(IDD_ConvertCTT) ;
	return CPropertyPage::OnWizardBack();
}

void CConvCttDlg::OnCTTBrowser() 
{
	UpdateData() ;
	CString csFilter( _T("CTT Files (*.ctt)|*.ctt||") ) ; 
	
	CFileDialog cfd(TRUE, _T(".ctt"), NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        this);

	cfd.m_ofn.lpstrFile = new char[4096];
	memset(cfd.m_ofn.lpstrFile,0,4096);
	cfd.m_ofn.nMaxFile = 4096;
    if  (cfd.DoModal() != IDOK) {
        delete cfd.m_ofn.lpstrFile ;
		return;
	}
	// save the file path to member string array 	
	for (POSITION pos = cfd.GetStartPosition(); pos; ) {
		m_csaCttFiles.Add(cfd.GetNextPathName(pos)) ;
	}
	
	
	m_csCttPath = m_csaCttFiles[0] ;
	// GTT directory is same with the CTT directory as default.
	m_csGttDir = m_csCttPath.Left(m_csCttPath.ReverseFind(_T('\\') ) );
	SetCurrentDirectory(m_csGttDir) ;

	UpdateData(FALSE) ;

	if(m_csCttPath.GetLength() )
		((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH) ;		
	
}

//DEL BOOL CConvCttDlg::OnInitDialog() 
//DEL {
//DEL 	CPropertyPage::OnInitDialog();
//DEL 	
//DEL 	//Fill the list with installed codepage rather than supported code page.
//DEL 	
//DEL 	CCodePageInformation ccpi ; 
//DEL 
//DEL //	ccpi.
//DEL 
//DEL 	return TRUE;  // return TRUE unless you set the focus to a control
//DEL 	              // EXCEPTION: OCX Property Pages should return FALSE
//DEL }

BOOL CConvCttDlg::OnSetActive() 
{
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
	((CPropertySheet*)GetParent())->SetWizardButtons(PSWIZB_BACK | PSWIZB_DISABLEDFINISH) ;	
	((CPropertySheet*)GetParent())->GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;
	CCodePageInformation ccpi ;
	unsigned unumcps = ccpi.InstalledCount() ;

	// Get the installed code page numbers and load them into the code page
	// list box.

	DWORD dwcp, dwdefcp ;
	dwdefcp = GetACP() ;
	TCHAR accp[32] ;
	int n ; ;
	for (unsigned u = 0 ; u < unumcps ; u++) {
		dwcp = ccpi.Installed(u) ;

		// There are 3 code pages that seem to make MultiByteToWideChar() to 
		// fail.  Don't let the user choose one of those code pages unless
		// he knows the secret password (ie, undocument command line switch
		// 'CP').

		
		if (dwcp == 1361 || dwcp == 28595 || dwcp == 28597) 
			continue ;

		wsprintf(accp, "%5d", dwcp) ;
		n = m_ccbCodepages.AddString(accp) ;
		if (dwcp == 1252) // change dwdefcp to 1252 due to not support DBCS.
			m_ccbCodepages.SetCurSel(n) ;
	} ;	

	return CPropertyPage::OnSetActive();
}

extern "C"
BOOL
BConvertCTT2GTT(
    IN     HANDLE             hHeap,
    IN     PTRANSTAB          pCTTData,
    IN     DWORD              dwCodePage,
    IN     WCHAR              wchFirst,
    IN     WCHAR              wchLast,
    IN     PBYTE              pCPSel,
    IN     PBYTE              pCPUnSel,
    IN OUT PUNI_GLYPHSETDATA *ppGlyphSetData,
    IN     DWORD              dwGlySize);

extern "C"
PUNI_GLYPHSETDATA
PGetDefaultGlyphset(
	IN		HANDLE		hHeap,
	IN		WORD		wFirstChar,
	IN		WORD		wLastChar,
	IN		DWORD		dwCodePage) ;


bool CConvCttDlg::ConvCTTToGTT()
{

	CString csCodePage ;
	DWORD   dwCodePage ;
	m_ccbCodepages.GetLBText(m_ccbCodepages.GetCurSel(),csCodePage) ;
	dwCodePage = atoi(csCodePage) ;

	// Creating the UFM Path
	UpdateData() ;
	SECURITY_ATTRIBUTES st;
	st.nLength = sizeof(SECURITY_ATTRIBUTES);
	st.lpSecurityDescriptor = NULL;
	st.bInheritHandle = FALSE ;

	WIN32_FIND_DATA wfd32 ;
	HANDLE hDir = FindFirstFile(m_csGttDir,&wfd32) ;
	if (hDir == INVALID_HANDLE_VALUE) {
		if (!CreateDirectory(m_csGttDir,&st) ) {
			CString csmsg ;
			csmsg = _T("Fail to create the template directory") ;
			AfxMessageBox(csmsg) ;
			return false ;
		} 
	} ;

	for (int i = 0 ; i < m_csaCttFiles.GetSize() ; i ++ ) {
		
	// load the cTT files
		CString csCTTPath = m_csaCttFiles[i] ;
		CByteArray cbaCTT ;
		try {
			CFile   cfLoad(csCTTPath, CFile::modeRead | CFile::shareDenyWrite);
			cbaCTT.SetSize(cfLoad.GetLength());
			cfLoad.Read(cbaCTT.GetData(), cfLoad.GetLength());
		}
		catch   (CException   *pce) {
        pce -> ReportError();
        pce -> Delete();
        cbaCTT.RemoveAll();
        return  false ;
		}

		PBYTE  pbCTT = cbaCTT.GetData() ;
		HANDLE hheap ;
		  if( !(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 )))
		{
			CString csErr ;
			csErr.Format(IDS_HeapCFailed,csCTTPath) ;
			AfxMessageBox(csErr ,MB_ICONEXCLAMATION);
			return  false ;
		}
									
		// call the convert extern function
		UNI_GLYPHSETDATA *pGTT = new UNI_GLYPHSETDATA ;
		if(NULL == pGTT){
			HeapDestroy(hheap);
			return false;
		}
			
		
		if (!BConvertCTT2GTT(hheap, (PTRANSTAB)pbCTT, dwCodePage, 0x20, 0xff, NULL, 
			NULL, &pGTT, 0)){
			delete pGTT; // raid fix 692536 prefix
			HeapDestroy(hheap);   // raid 116619 prefix
			return false ;
		}

		

		// store the GTT files
		CString csGTTName = csCTTPath.Mid(csCTTPath.ReverseFind(_T('\\') )+1 ) ;
		csGTTName = csGTTName.Left(csGTTName.ReverseFind(('.')) ) ;
		CString csGTTPath = m_csGttDir + _T("\\") + csGTTName + _T(".GTT") ;
		csGTTName.MakeUpper() ;	
		try {
			CFile   cfGTT;
			if  (!cfGTT.Open(csGTTPath, CFile::modeCreate | CFile::modeWrite |
				CFile::shareExclusive))
				return  false;
			cfGTT.Write(pGTT, pGTT->dwSize);
			cfGTT.Close() ;
		}

		catch   (CException *pce) {
			pce -> ReportError();
			pce -> Delete();
			delete pGTT;
			HeapDestroy(hheap);
			return  false ;
		}
		
		if (pGTT )
			delete pGTT ;
		HeapDestroy(hheap);
	}
	return true ;
}
/////////////////////////////////////////////////////////////////////////////
// CConvertCTT

IMPLEMENT_DYNAMIC(CConvertCTT, CPropertySheet)

CConvertCTT::CConvertCTT(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CConvertCTT::CConvertCTT(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
	AddPage(&m_cccd) ;

	SetWizardMode() ;

}

CConvertCTT::~CConvertCTT()
{
}


BEGIN_MESSAGE_MAP(CConvertCTT, CPropertySheet)
	//{{AFX_MSG_MAP(CConvertCTT)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvertCTT message handlers
/////////////////////////////////////////////////////////////////////////////
// CNewConvert property page

IMPLEMENT_DYNCREATE(CNewConvert, CPropertyPage)

CNewConvert::CNewConvert() : CPropertyPage(CNewConvert::IDD)
{
	//{{AFX_DATA_INIT(CNewConvert)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}



CNewConvert::~CNewConvert()
{
}

void CNewConvert::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewConvert)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewConvert, CPropertyPage)
	//{{AFX_MSG_MAP(CNewConvert)
	ON_BN_CLICKED(IDC_CONVERT, OnPrjConvert)
	ON_BN_CLICKED(IDC_CONV_PFM, OnPFMConvert)
	ON_BN_CLICKED(IDC_CONV_CTT, OnCTTConvert)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewConvert message handlers


/*************************************************************************************
void CNewConvert::OnPrjConvert() 
Creat Doc-> call Convert Wizard -> Creat frame -> Create View by updatefram

**************************************************************************************/
void CNewConvert::OnPrjConvert() 
{
	 //  Invoke the wizard.
	m_pcps->ShowWindow(SW_HIDE) ;
	CMultiDocTemplate* pcmdt = ThisApp().WorkspaceTemplate() ;

	CDocument* pcdWS = pcmdt->CreateNewDocument() ;

	if  (!pcdWS || !pcdWS -> OnNewDocument()) {
        if  (pcdWS) {
            delete  pcdWS;
			m_pcps->EndDialog(1) ;
		}
        return;
    }
	pcmdt->SetDefaultTitle(pcdWS) ;
	
	CFrameWnd* pcfw = pcmdt->CreateNewFrame(pcdWS,NULL) ;

	if (pcfw) 
		pcmdt->InitialUpdateFrame(pcfw,pcdWS) ;

	m_pcps->EndDialog(1) ;
	

	
}

/*************************************************************************************
void CNewConvert::OnPFMConvert() 


**************************************************************************************/

void CNewConvert::OnPFMConvert() 
{
	CConvertPFM cnp ( _T("PFM Convert To UFM ") ) ;

	m_pcps->ShowWindow(SW_HIDE) ;

	INT_PTR ret = cnp.DoModal() ;
	if (ret == (INT_PTR)IDD_ConvertPFM )
		m_pcps->ShowWindow(SW_RESTORE) ;
	else
		m_pcps->EndDialog(1) ;
}


/*************************************************************************************
void CNewConvert::OnCTTConvert() 

**************************************************************************************/

void CNewConvert::OnCTTConvert() 
{
	CConvertCTT ccc ( _T("GTT Converter ") ) ;

	m_pcps->ShowWindow(SW_HIDE) ;

    INT_PTR ret = ccc.DoModal() ;
	if (ret == (INT_PTR)IDD_ConvertCTT )
		m_pcps->ShowWindow(SW_RESTORE) ;
	else
		m_pcps->EndDialog(1) ;
}


/***************************************************************************************
	BOOL CNewConvert::OnSetActive() 
Do.
****************************************************************************************/
BOOL CNewConvert::OnSetActive() 
{
	
	return CPropertyPage::OnSetActive();
}

/***************************************************************************************
	BOOL CNewConvert::OnInitDialog()  
Do; Getting perent pointer

****************************************************************************************/
BOOL CNewConvert::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	m_pcps = DYNAMIC_DOWNCAST(CPropertySheet,GetOwner() ) ;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\minidev.h ===
/******************************************************************************

  Source File:  MiniDriver Developer Studio.H

  This defines the main application class, and other relatively global data.

  Copyright (c) 1997 By Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it.

******************************************************************************/

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/******************************************************************************

  CMiniDriverStudio class

  This is the application class for this application. 'Nuff said?

******************************************************************************/

class CMiniDriverStudio : public CWinApp {
    //  Document templates for the various editors and error display windows
    CMultiDocTemplate   *m_pcmdtGlyphMap, *m_pcmdtFont, *m_pcmdtModel,
                        *m_pcmdtWorkspace, *m_pcmdtWSCheck, *m_pcmdtStringEditor,
						*m_pcmdtINFViewer, *m_pcmdtINFCheck ;
	CString				m_strAppPath ;	// Application path

	CStringArray		m_csaGPDKeywordArray ;	// Array of GPD keyword strings

public:
	CMiniDriverStudio();

    bool	m_bOSIsW2KPlus ;			// True iff OS ver >= 5.0
	bool	m_bExcludeBadCodePages ;	// See CDefaultCodePageSel:OnSetActive()
	
	CMultiDocTemplate*  GlyphMapTemplate() const { return m_pcmdtGlyphMap; }
    CMultiDocTemplate*  FontTemplate() const { return m_pcmdtFont; }
    CMultiDocTemplate*  GPDTemplate() const { return m_pcmdtModel; }
    CMultiDocTemplate*  WSCheckTemplate() const { return m_pcmdtWSCheck; }
    CMultiDocTemplate*  StringEditorTemplate() const { return m_pcmdtStringEditor; }
    CMultiDocTemplate*  INFViewerTemplate() const { return m_pcmdtINFViewer; }
    CMultiDocTemplate*  INFCheckTemplate() const { return m_pcmdtINFCheck; }
	CMultiDocTemplate*  WorkspaceTemplate() const { return m_pcmdtWorkspace; } 
    
	void SaveAppPath() ;
	CString GetAppPath() const { return m_strAppPath ; } 

	CStringArray& GetGPDKeywordArray() { return m_csaGPDKeywordArray ; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMiniDriverStudio)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMiniDriverStudio)
	afx_msg void OnAppAbout();
	afx_msg void OnUpdateFileGeneratemaps(CCmdUI* pCmdUI);
	afx_msg void OnFileGeneratemaps();
	//}}AFX_MSG
#if !defined(NOPOLLO)
	afx_msg void OnFileNew();
#endif
	DECLARE_MESSAGE_MAP()
private:
	void ShowTipAtStartup(void);
private:
	void ShowTipOfTheDay(void);
};

//  App access function(s)

CMiniDriverStudio&  ThisApp();

CMultiDocTemplate*  GlyphMapDocTemplate();
CMultiDocTemplate*  FontTemplate();
CMultiDocTemplate*  GPDTemplate();
CMultiDocTemplate*  WSCheckTemplate();
CMultiDocTemplate*  StringEditorTemplate();
CMultiDocTemplate*  INFViewerTemplate();
CMultiDocTemplate*  INFCheckTemplate();

//  Text File Loading (into a CStringArray) function

BOOL    LoadFile(LPCTSTR lpstrFile, CStringArray& csaContents);


class CMDTCommandLineInfo : public CCommandLineInfo
{
// Construction
public:
	CMDTCommandLineInfo() ;
	~CMDTCommandLineInfo() ;

// Implementation
public:
	virtual void ParseParam(LPCTSTR lpszParam, BOOL bFlag, BOOL bLast) ;

// Data
public:
    bool	m_bCheckOS ;				// Check OS version >= 5 iff true
	bool	m_bExcludeBadCodePages ;	// See CDefaultCodePageSel:OnSetActive()
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\mainfrm.h ===
/******************************************************************************

  Header File:  Main Frame.H

  This defines the class which handles the application's main window's frame.
  It will begin life, at the least, as a standaard MFC App Wizard creation.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  03-04-2997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/


// CGPDToolBar is used to add control(s) to the GPD tool bar.

class CGPDToolBar : public CToolBar
{
public:
	CEdit	ceSearchBox ;		// Search text edit box
	//CButton	cbNext ;			// Search next button
	//CButton cbPrevious ;		// Search previous button
} ;


// Widths of control(s) in CGPDToolBar.

#define	GPD_SBOX_WIDTH		170


class CMainFrame : public CMDIFrameWnd {
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

	void GetGPDSearchString(CString& cstext) ;
	CGPDToolBar* GetGpdToolBar() { return &m_ctbBuild; }	// raid 16573
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	afx_msg void OnInitMenu(CMenu* pMenu);
	CStatusBar  m_wndStatusBar;
	CToolBar    m_ctbMain;
	CGPDToolBar	m_ctbBuild;		  

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newcomp.cpp ===
// NewComponent.cpp : implementation file
//

#include "stdafx.h"
#include "minidev.h"

#include "NewFile.h"

#include "utility.h"
#include "projnode.h"
#include "gpdfile.h"
#include "nproject.h"

#include "nconvert.h"

#include "newcomp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewComponent

IMPLEMENT_DYNAMIC(CNewComponent, CPropertySheet)


CNewComponent::CNewComponent(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
	AddPage(&m_cnf) ;
	AddPage(&m_cnp) ;
	AddPage(&m_cnc) ;
}


CNewComponent::CNewComponent(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{

}


CNewComponent::~CNewComponent()
{
}


BEGIN_MESSAGE_MAP(CNewComponent, CPropertySheet)
	//{{AFX_MSG_MAP(CNewComponent)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewComponent message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\minidev.cpp ===
/******************************************************************************

  Source File:  MiniDriver Developer Studio.CPP

  This implements the MFC application object and closely related classes.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it
  03-03-1997    Bob_Kjelgaard@Prodigy.Net   Renamed it when the project was
                reorganized into an EXE with multiple DLLs

******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include	"resource.h"
#include	"WSCheck.H"
#include    "MiniDev.H"
#include    "MainFrm.H"
#include    "ChildFrm.H"
#include    "ProjView.H"
#include    "GTTView.H"
#include    "comctrls.h"
#include    "FontView.H"
#include    "GPDView.H"
#include    <CodePage.H>
#include	"tips.h"
#include	"StrEdit.h"
#include	"INFWizrd.h"
#include	<string.h>

// for new project and new file

#include    "newcomp.h"

#include    <Dos.H>
#include    <Direct.H>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio

BEGIN_MESSAGE_MAP(CMiniDriverStudio, CWinApp)
	ON_COMMAND(CG_IDS_TIPOFTHEDAY, ShowTipOfTheDay)
	//{{AFX_MSG_MAP(CMiniDriverStudio)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_UPDATE_COMMAND_UI(ID_FILE_GENERATEMAPS, OnUpdateFileGeneratemaps)
	ON_COMMAND(ID_FILE_GENERATEMAPS, OnFileGeneratemaps)
	//}}AFX_MSG_MAP
	// Standard file based document commands
#if defined(NOPOLLO)
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
#else
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
#endif
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio construction

CMiniDriverStudio::CMiniDriverStudio() 
{
	m_bOSIsW2KPlus = false ;
	m_bExcludeBadCodePages = true ;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMiniDriverStudio object

static CMiniDriverStudio theApp;

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio initialization

BOOL CMiniDriverStudio::InitInstance() {

    // Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

    SetRegistryKey(_TEXT("Microsoft"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	m_pcmdtWorkspace = new CMultiDocTemplate(
		IDR_MINIWSTYPE,
		RUNTIME_CLASS(CProjectRecord),
		RUNTIME_CLASS(CMDIChildWnd), 
		RUNTIME_CLASS(CProjectView));
	AddDocTemplate(m_pcmdtWorkspace);
    m_pcmdtGlyphMap = new CMultiDocTemplate(IDR_GLYPHMAP, 
        RUNTIME_CLASS(CGlyphMapContainer),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CGlyphMapView));
    AddDocTemplate(m_pcmdtGlyphMap);
    m_pcmdtFont = new CMultiDocTemplate(IDR_FONT_VIEWER, 
        RUNTIME_CLASS(CFontInfoContainer),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CFontViewer));
    AddDocTemplate(m_pcmdtFont);
    m_pcmdtModel = new CMultiDocTemplate(IDR_GPD_VIEWER,
        RUNTIME_CLASS(CGPDContainer),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CGPDViewer));
    AddDocTemplate(m_pcmdtModel);
    m_pcmdtWSCheck = new CMultiDocTemplate(IDR_WSCHECK,
        RUNTIME_CLASS(CWSCheckDoc),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CWSCheckView));
    AddDocTemplate(m_pcmdtWSCheck);
    m_pcmdtStringEditor = new CMultiDocTemplate(IDR_STRINGEDITOR,
        RUNTIME_CLASS(CStringEditorDoc),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CStringEditorView));
    AddDocTemplate(m_pcmdtStringEditor);
    m_pcmdtINFViewer = new CMultiDocTemplate(IDR_INF_FILE_VIEWER,
        RUNTIME_CLASS(CINFWizDoc),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CINFWizView));
    AddDocTemplate(m_pcmdtINFViewer);
    m_pcmdtINFCheck = new CMultiDocTemplate(IDR_INFCHECK,
        RUNTIME_CLASS(CINFCheckDoc),
        RUNTIME_CLASS(CChildFrame),
        RUNTIME_CLASS(CINFCheckView));
    AddDocTemplate(m_pcmdtINFCheck);

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes();	//raid 104081 ..Types(TRUE) ->..Types()

	// Parse command line for standard shell commands, DDE, file open

	CMDTCommandLineInfo cmdInfo ;
	ParseCommandLine(cmdInfo) ;

	//  Turn off New on startup

    if  (cmdInfo.m_nShellCommand == CCommandLineInfo::FileNew)
        cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing ;
															    
	// Check to see if the OS check should be skipped.  Clean up command line
	// related info if the OS check will be skipped.

	if (!cmdInfo.m_bCheckOS || !cmdInfo.m_bExcludeBadCodePages) 
		if  (cmdInfo.m_nShellCommand == CCommandLineInfo::FileOpen)
			cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing ;
	
	m_bExcludeBadCodePages = cmdInfo.m_bExcludeBadCodePages ;

	// Dispatch commands specified on the command line

	if (!ProcessShellCommand(cmdInfo))
		return FALSE ;

	// The MDT can only run on Win 98 or NT 4.0+.

	if (cmdInfo.m_bCheckOS) {
		OSVERSIONINFO	osinfo ;	// Filled by GetVersionEx()
		osinfo.dwOSVersionInfoSize = sizeof(osinfo) ;
		GetVersionEx(&osinfo) ;
		if (osinfo.dwPlatformId != VER_PLATFORM_WIN32_NT 
		 || osinfo.dwMajorVersion < 5) {
			AfxMessageBox(IDS_ReqOSError) ;
			return FALSE ;
		} ;
		m_bOSIsW2KPlus = true ;
	} ;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	// Get and save the application path

	SaveAppPath() ;

	// CG: This line inserted by 'Tip of the Day' component.
	ShowTipAtStartup();

	return TRUE;
}


void CMiniDriverStudio::SaveAppPath() 
{
	// Get the program's filespec

	GetModuleFileName(m_hInstance, m_strAppPath.GetBufferSetLength(256), 256) ;
	m_strAppPath.ReleaseBuffer() ;

	// Take the file name off the string so that only the path is left.

	int npos = npos = m_strAppPath.ReverseFind(_T('\\')) ;
	m_strAppPath = m_strAppPath.Left(npos + 1) ;
}


/////////////////////////////////////////////////////////////////////////////
// CMDTCommandLineInfo used to process command line info

CMDTCommandLineInfo::CMDTCommandLineInfo()
{
	m_bCheckOS = true ;
	m_bExcludeBadCodePages = true ;
}


CMDTCommandLineInfo::~CMDTCommandLineInfo()
{
}


void CMDTCommandLineInfo::ParseParam(LPCTSTR lpszParam, BOOL bFlag, BOOL bLast)
{
	if (strcmp(lpszParam, _T("4")) == 0)
		m_bCheckOS = false ;
	else if (_stricmp(lpszParam, _T("CP")) == 0)
		m_bExcludeBadCodePages = false ;
	else
		CCommandLineInfo::ParseParam(lpszParam, bFlag, bLast)	;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog {
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual BOOL OnInitDialog();
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD) {
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMiniDriverStudio::OnAppAbout() {
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMiniDriverStudio commands


//  Handle the File GenerateMaps menu item.  We only enable it if there's
//  something new to see.

void CMiniDriverStudio::OnUpdateFileGeneratemaps(CCmdUI* pccui) {
	
    CCodePageInformation    ccpi;

    for (unsigned u = 0; u < ccpi.InstalledCount(); u++)
        if  (!ccpi.HaveMap(ccpi.Installed(u)))
            break;

    pccui -> Enable(u < ccpi.InstalledCount());
}

void CMiniDriverStudio::OnFileGeneratemaps() {
	CCodePageInformation    ccpi;

    AfxMessageBox(ccpi.GenerateAllMaps() ? IDS_MapsGenerated : IDS_MapsFailed);
}

void CMiniDriverStudio::ShowTipAtStartup(void) {
	// CG: This function added by 'Tip of the Day' component.

	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);
	if (cmdInfo.m_bShowSplash) 	{
		CTipOfTheDay dlg;
		if (dlg.m_bStartup)
			dlg.DoModal();
	}
}

void CMiniDriverStudio::ShowTipOfTheDay(void) {
	// CG: This function added by 'Tip of the Day' component.

	CTipOfTheDay dlg;
	dlg.DoModal();
}

#if !defined(NOPOLLO)

/******************************************************************************

  CMiniDriverStudio::OnFileNew

  This allows you to create a workspace by conversion.  Perhaps when the Co.
  Jones arrive, this will be invoked as a separate menu item, rather than the
  File New item...

******************************************************************************/

void CMiniDriverStudio::OnFileNew() {
//	LPBYTE pfoo = (LPBYTE) 0x2cffe7 ;

	CNewComponent cnc(_T("New") ) ;
 
	cnc.DoModal() ;
/*    CDocument*  pcdWS = m_pcmdtWorkspace -> CreateNewDocument();
    if  (!pcdWS || !pcdWS -> OnNewDocument()) {
        if  (pcdWS)
            delete  pcdWS;
        return;
    }
    m_pcmdtWorkspace -> SetDefaultTitle(pcdWS);
    CFrameWnd*  pcfw = m_pcmdtWorkspace -> CreateNewFrame(pcdWS, NULL);
    if  (!pcfw) return;
    m_pcmdtWorkspace -> InitialUpdateFrame(pcfw, pcdWS);
*/

}




#endif  //!defined(NOPOLLO)

//  Global Functions go here, saith the Bob...

CMiniDriverStudio&  ThisApp() { return theApp; }

CMultiDocTemplate*  GlyphMapDocTemplate() {
    return  theApp.GlyphMapTemplate();
}

CMultiDocTemplate* FontTemplate() { return theApp.FontTemplate(); }

CMultiDocTemplate*  GPDTemplate() { return theApp.GPDTemplate(); }

CMultiDocTemplate*  WSCheckTemplate() { return theApp.WSCheckTemplate(); }

CMultiDocTemplate*  StringEditorTemplate() { return theApp.StringEditorTemplate(); }

CMultiDocTemplate*  INFViewerTemplate() { return theApp.INFViewerTemplate(); }

CMultiDocTemplate*  INFCheckTemplate() { return theApp.INFCheckTemplate(); }

BOOL    LoadFile(LPCTSTR lpstrFile, CStringArray& csaContents) {

    CStdioFile  csiof;

    if  (!csiof.Open(lpstrFile, 
        CFile::modeRead | CFile::shareDenyWrite | CFile::typeText))

        return  FALSE;

    csaContents.RemoveAll();
    try {
        CString csContents;
        while   (csiof.ReadString(csContents))
            csaContents.Add(csContents);
    }
    catch(...) {
        return  FALSE;
    }

    return  TRUE;
}

//  CAboutDlg command handlers.

BOOL CAboutDlg::OnInitDialog() {

	CDialog::OnInitDialog();

    CString csWork, csFormat;

	// Fill available memory
    MEMORYSTATUS ms = {sizeof(MEMORYSTATUS)};
	GlobalMemoryStatus(&ms);
	csFormat.LoadString(CG_IDS_PHYSICAL_MEM);
	csWork.Format(csFormat, ms.dwAvailPhys / 1024L, ms.dwTotalPhys / 1024L);

	SetDlgItemText(IDC_PhysicalMemory, csWork);

	// Fill disk free information
	struct _diskfree_t diskfree;
	int nDrive = _getdrive(); // use current default drive
	if (_getdiskfree(nDrive, &diskfree) == 0) {
		csFormat.LoadString(CG_IDS_DISK_SPACE);
		csWork.Format(csFormat, (DWORD)diskfree.avail_clusters *
			(DWORD)diskfree.sectors_per_cluster *
			(DWORD)diskfree.bytes_per_sector / (DWORD)1024L,
			nDrive - 1 + _T('A'));
	}
 	else
 		csWork.LoadString(CG_IDS_DISK_SPACE_UNAVAIL);

	SetDlgItemText(IDC_FreeDiskSpace, csWork);

    csWork.Format(_TEXT("Code Pages:  ANSI %u OEM %u"), GetACP(), GetOEMCP());

    SetDlgItemText(IDC_CodePages, csWork);

    return TRUE;
}


// This code is needed because of the references to the following functions
// and variable in DEBUG.H.

#ifdef DBG

ULONG _cdecl DbgPrint(PCSTR, ...)
{
	return 0 ;
}

VOID DbgBreakPoint(VOID)
{
}

PCSTR StripDirPrefixA(PCSTR pstrFilename)
{
	return "" ;
}

int  giDebugLevel ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newcomp.h ===
#if !defined(AFX_NEWCOMPONENT_H__BF7CE06F_A5C1_4985_BA38_C80D4178B0AF__INCLUDED_)
#define AFX_NEWCOMPONENT_H__BF7CE06F_A5C1_4985_BA38_C80D4178B0AF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// newcompo.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewComponent
#include "NewFile.h"
#include "nproject.h"
#include "nconvert.h"

class CNewComponent : public CPropertySheet
{
	DECLARE_DYNAMIC(CNewComponent)

// Construction
public:

	CNewComponent(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CNewComponent(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	

// Attributes
public:

// Operations
public:
	CNewFile     m_cnf ; // rename CNewPrjWResource // del
	CNewProject  m_cnp ; // rename CNewPrjWTemplate
	CNewConvert  m_cnc ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewComponent)
	//}}AFX_VIRTUAL

// Implementation
public:
	CNewProject* GetProjectPage() { return &m_cnp ; } ;
	virtual ~CNewComponent();

	// Generated message map functions
protected:
	//{{AFX_MSG(CNewComponent)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWCOMPONENT_H__BF7CE06F_A5C1_4985_BA38_C80D4178B0AF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\nconvert.h ===
#if !defined(AFX_NEWPROJECT_H__CC553456_AD1E_4816_8A20_5DF52F336FA6__INCLUDED_)
#define AFX_NEWPROJECT_H__CC553456_AD1E_4816_8A20_5DF52F336FA6__INCLUDED_

//#include "minidev.h"	// Added by ClassView
#include "utility.h"	// Added by ClassView
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NewProject.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CConvPfmDlg dialog

class CConvPfmDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CConvPfmDlg)

// Construction
public:
	CConvPfmDlg();
	~CConvPfmDlg();

// Dialog Data
	//{{AFX_DATA(CConvPfmDlg)
	enum { IDD = IDD_ConvertPFM };
	CComboBox	m_ccbCodepages;
	CString	m_csGttPath;
	CString	m_csPfmPath;
	CString	m_csUfmDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CConvPfmDlg)
	public:
	virtual BOOL OnWizardFinish();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CConvPfmDlg)
	afx_msg void OnGTTBrowser();
	afx_msg void OnPFMBrowsers();
	afx_msg void OnSelchangeComboCodePage();
	afx_msg void OnUfmDirBrowser();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool ConvPFMToUFM();
	CStringArray m_csaPfmFiles;
};

/////////////////////////////////////////////////////////////////////////////
// CConverPFM

class CConvertPFM : public CPropertySheet
{
	DECLARE_DYNAMIC(CConvertPFM)

// Construction
public:
	CConvertPFM(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CConvertPFM(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

private:
	CConvPfmDlg m_ccpd ;
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConverPFM)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CConvertPFM();

	// Generated message map functions
protected:
	//{{AFX_MSG(CConverPFM)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CConvCttDlg dialog

class CConvCttDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CConvCttDlg)

// Construction
public:
	CConvCttDlg();
	~CConvCttDlg();

// Dialog Data
	//{{AFX_DATA(CConvCttDlg)
	enum { IDD = IDD_ConvertCTT };
	CComboBox	m_ccbCodepages;
	CString	m_csCttPath;
	CStringArray m_csaCttFiles ;
	CString	m_csGttDir;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CConvCttDlg)
	public:
	virtual BOOL OnWizardFinish();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CConvCttDlg)
	afx_msg void OnCTTBrowser();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool ConvCTTToGTT();
};

/////////////////////////////////////////////////////////////////////////////
// CConvertCTT

class CConvertCTT : public CPropertySheet
{
	DECLARE_DYNAMIC(CConvertCTT)

// Construction
public:
	CConvertCTT(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CConvertCTT(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:
private:
	CConvCttDlg m_cccd ;
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConvertCTT)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CConvertCTT();

	// Generated message map functions
protected:
	//{{AFX_MSG(CConvertCTT)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CNewConvert dialog

class CNewConvert : public CPropertyPage
{
	DECLARE_DYNCREATE(CNewConvert)

// Construction
public:
	

	CNewConvert();
	~CNewConvert();

// Dialog Data
	//{{AFX_DATA(CNewConvert)
	enum { IDD = IDD_NewConvert };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewConvert)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CNewConvert)
	afx_msg void OnPrjConvert();
	afx_msg void OnPFMConvert();
	afx_msg void OnCTTConvert(); 
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
//	CSafeObArray m_csoaModels,m_csoaFonts,m_csoaAtlas;

	CPropertySheet * m_pcps;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWPROJECT_H__CC553456_AD1E_4816_8A20_5DF52F336FA6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newfile.cpp ===
// NewFile.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"

#include "NewFile.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewFile property page

TCHAR* pszFileNames[] = {_T("GPD"), _T("UFM"), _T("GTT")};
TCHAR* pszExt[] = {_T(".GPD"), _T(".UFM"), _T(".GTT") };
int  iBitmap[] = {IDB_GPD_VIEWER,IDB_FONT_VIEWER,IDB_GLYPHMAP};
WORD  wID[] = {120,122,124 } ;



IMPLEMENT_DYNCREATE(CNewFile, CPropertyPage)



CNewFile::CNewFile() : CPropertyPage(CNewFile::IDD),FILES_NUM(3)
{
	//{{AFX_DATA_INIT(CNewFile)
	m_csFileLoc = _T("");
	m_csNewFile = _T("");
	//}}AFX_DATA_INIT
//	m_bproj = FALSE ;
}

CNewFile::CNewFile(CPropertySheet *pcps): CPropertyPage(CNewFile::IDD),FILES_NUM(3)
{
//	m_pcps = pcps ;
}


CNewFile::~CNewFile()
{

}

void CNewFile::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewFile)
	DDX_Control(pDX, IDC_NEWFILES_LIST, m_clcFileName);
	DDX_Text(pDX, IDC_FILE_LOC, m_csFileLoc);
	DDX_Text(pDX, IDC_NEWFILENAME, m_csNewFile);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewFile, CPropertyPage)
	//{{AFX_MSG_MAP(CNewFile)
	ON_BN_CLICKED(IDC_Browser, OnBrowser)
	ON_NOTIFY(NM_DBLCLK, IDC_NEWFILES_LIST, OnDblclkNewfilesList)
	ON_EN_CHANGE(IDC_NEWFILENAME, OnChangeNewFilename)
	ON_NOTIFY(NM_CLICK, IDC_NEWFILES_LIST, OnClickNewfilesList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewFile message handlers


/********************************************************************************
	BOOL CNewFile::OnSetActive() 
Do: Enumerate the file list to the list control box
Args:
Ret.


*********************************************************************************/
BOOL CNewFile::OnSetActive() 
{
	m_clcFileName.DeleteAllItems();
	// create object for imagelist, it didn't work when use this as reference.
	CImageList* pcil = new CImageList ;

	pcil->Create(32,32,ILC_COLOR4,3,1);
 	CBitmap cb;
	 
    for (int j =0; j< FILES_NUM; j++)	{
		cb.LoadBitmap(iBitmap[j]);
		pcil->Add(&cb,RGB(0,0,0) );
		cb.DeleteObject();
	}
 
	m_clcFileName.SetImageList(pcil,LVSIL_NORMAL);
// set the items with image and text
	LV_ITEM lvi;
	for (int i = 0; i< FILES_NUM; i++)
	{
		lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM ;
		lvi.iItem = i;
		lvi.iSubItem = 0;
		lvi.pszText = pszFileNames[i]; 
		lvi.iImage = i;
	    lvi.lParam = (ULONG_PTR)pszExt[i];
 
		m_clcFileName.InsertItem(&lvi);
	}


	
	return CPropertyPage::OnSetActive();
}


/********************************************************************************
	BOOL CNewFile::CallNewDoc()
Do:  this is workhourse. it load the resource file for gpd, gtt, ufm, creat gtt, ufm 
directory, and then creat file.

*********************************************************************************/

BOOL CNewFile::CallNewDoc()
{

	UpdateData();

/* Tell what is selected

  if (ufm, gtt)
	make new file based on selected files base.

  if( project file)
  { 
    run Wizard :
		: user chose GPD template -> 
		    1.Do this template make rc file(?)
		    2.what UFM, GTT are included in template
			3.how can take care of ufm, gtt mentioned GPD 
			4.what user chose when make GPD template.
	
	Make sub directory W2K, UFM, GTT.
	
	  	  

  }
	*/	
	
	// get selected file text name (ex. .UFM, .GTT
	int idContext = m_clcFileName.GetNextItem(-1,
        LVNI_ALL | LVNI_FOCUSED | LVNI_SELECTED);

	if (idContext == -1 )
		return FALSE ;

	union {ULONG_PTR lParam; LPCTSTR lpstrExt;};
	// get extention for file
	lParam = m_clcFileName.GetItemData(idContext);


	// compare the selected file name and parsing
	// Call new Document 

	CWinApp *cwa = AfxGetApp();
	POSITION pos = cwa->GetFirstDocTemplatePosition();
	CString csExtName;
	CDocTemplate *pcdt ;
	while (pos != NULL){
		pcdt = cwa -> GetNextDocTemplate(pos);

		ASSERT (pcdt != NULL);
		ASSERT (pcdt ->IsKindOf(RUNTIME_CLASS(CDocTemplate)));

		pcdt ->GetDocString(csExtName, CDocTemplate::filterExt);

		if (csExtName == lpstrExt){
			// 1. create the file when a.created with project file  b. created with file name
//			if (m_bproj || m_csNewFile.GetLength() != 0) { 
			if (! m_csNewFile.GetLength())
				m_csNewFile = _T("Untitled") ;
			if (m_csNewFile.GetLength() != 0) { 
				// check the file name if user put or not
				if (m_csNewFile.GetLength() == 0 ) {
					CString csErr ;
					csErr.LoadString(IDS_NoFileName) ;
					AfxMessageBox(csErr, MB_ICONEXCLAMATION);
					return FALSE ;
				} ;
				// make UFM, GTT directory if user create these file
				CString csDir = m_csFileLoc.Right(m_csFileLoc.ReverseFind(_T('\\'))) ;
					// create directory
				SECURITY_ATTRIBUTES st;
				st.nLength = sizeof(SECURITY_ATTRIBUTES);
				st.lpSecurityDescriptor = NULL;
				st.bInheritHandle = FALSE ;
				try {
					if (!csExtName.CompareNoCase(_T(".UFM")) ){
						if (!!csDir.CompareNoCase(_T("UFM")) ) {
							m_csFileLoc += _T("\\UFM") ;
							CreateDirectory(m_csFileLoc,&st) ;
						}
					}
					else if (!csExtName.CompareNoCase(_T(".GTT")) ){
						if (!!csDir.CompareNoCase(_T("GTT") ) ) {
							m_csFileLoc += _T("\\GTT") ;
							CreateDirectory(m_csFileLoc,&st) ;
						}
					} 
				}
				catch (CException* pce) {
					pce->ReportError() ;
					pce->Delete() ;
					return FALSE ;
				} ;
				// check if specified named file is exist or not in the directory
				CString csFileName = m_csFileLoc +_T("\\") + m_csNewFile + csExtName;
				CFileFind cff ;
				if ( cff.FindFile(csFileName) ) {
					
					CString csMsg ;
					csMsg.LoadString(IDS_FileNewExist) ;
					if (AfxMessageBox (csMsg, MB_YESNO ) == IDNO)
						return FALSE ;

				}
				
				CFile cf(csFileName,CFile::modeCreate | CFile::modeWrite ) ;
				
				// load the UFM, GTT, GPD from the resources.
				for (unsigned i = 0 ; i < sizeof (*pszExt) ; i ++ ) {
					if (!csExtName.CompareNoCase(pszExt[i] ) )
						break;
				} ;

				WORD wi = wID [i] ;
				HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE(wID[i]),
					MAKEINTRESOURCE(IDR_NEWFILE));
					
 
				if (!hrsrc) {
					CString csErr ;
					csErr.LoadString(IDS_ResourceError) ;
					AfxMessageBox(csErr, MB_ICONEXCLAMATION ) ;
					return FALSE;
				} ;

			    HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);
			    if  (!hgMap)
					return  FALSE;  //  This should never happen!
			
				int nsize = SizeofResource(AfxGetResourceHandle(),hrsrc ) ;
				LPVOID lpv = LockResource(hgMap);
				
				cf.Write(lpv,nsize) ;
				cf.Close() ;

				pcdt->OpenDocumentFile(csFileName) ;

				// add the new file into the project tree.
			}
			else // 2.created the file with no file name, project 
				pcdt->OpenDocumentFile(NULL);
			return TRUE;
		}
	}

	return FALSE;
}

/********************************************************************************
	void CNewFile::OnBrowser() 
Do:  Using the old version browser rather than SHELL. code reuse in the MDT and 
faster than SHELL to be loaded
Args:
Ret.

*********************************************************************************/


void CNewFile::OnBrowser() 
{

	OPENFILENAME    ofn ;       // Used to send/get info to/from common dlg
    char    acpath[_MAX_PATH] ; // Path is saved here (or an error message)
    BOOL    brc = FALSE ;       // Return code

	// Update the contents of csinitdir

	UpdateData(TRUE) ;

    // Load the open file name structure

    ofn.lStructSize = sizeof(ofn) ;
    ofn.hwndOwner = m_hWnd ;
    ofn.hInstance = GetModuleHandle(_T("MINIDEV.EXE")) ;
    ofn.lpstrFilter = ofn.lpstrCustomFilter = NULL ;
    ofn.nMaxCustFilter = ofn.nFilterIndex = 0 ;
    strcpy(acpath, _T("JUNK")) ;	// No need to localize this string
    ofn.lpstrFile = acpath ;
    ofn.nMaxFile = _MAX_PATH ;
    ofn.lpstrFileTitle = NULL ;
    ofn.nMaxFileTitle = 0 ;
	ofn.lpstrInitialDir = NULL ; //  in parent dialog box
    ofn.lpstrTitle = NULL ;
    ofn.Flags = OFN_HIDEREADONLY /*| OFN_ENABLEHOOK */| OFN_NOCHANGEDIR
        | OFN_NOTESTFILECREATE | OFN_ENABLETEMPLATE | OFN_NONETWORKBUTTON ;
    ofn.lpstrDefExt = NULL ;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPENORD) ;
    ofn.lpfnHook = NULL ;
    // Display the dialog box.  If the user cancels, just return.

    if (!GetOpenFileName(&ofn))
		return ;

    // Take the bogus file name off the path and put the path into the page's
	// edit box.

    acpath[ofn.nFileOffset - 1] = 0 ;
    
	m_csFileLoc = (LPCTSTR) acpath ;
	
	UpdateData(FALSE) ;
/*	if (pidlSelected)
		pMalloc->Free(pidlSelected) ;

	pMalloc->Release() ;
*/
}

/********************************************************************************
	void CNewFile::OnOK() 
Do: 
Args:
Ret.

*********************************************************************************/
void CNewFile::OnOK() 
{
	//to do
	/*
	Read what item is selected and open the file

  */
	if(CallNewDoc())
		CPropertyPage::OnOK();
	
}



/********************************************************************************
	void CNewFile::OnDblclkNewfilesList(NMHDR* pNMHDR, LRESULT* pResult) 
Do: Call the CallNewDoc() like OK () button, we need to check the filename is set or not
Args:
Ret.


*********************************************************************************/
void CNewFile::OnDblclkNewfilesList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	
	if (CallNewDoc() )
		EndDialog(IDD_NewFile) ;
	// bug; need to close the dialog ?? OnOK() call directly does not works.

	*pResult = 0 ;
	

	

}


/********************************************************************************
	void CNewFile::OnCheckProject() 
Do:  Enable and disable by checking the Project file name checkec status
Args:
Ret.

*********************************************************************************/
/*
void CNewFile::OnCheckProject() 
{
	CEdit cePrjName;
	CWnd *pcw ;
	if ( m_cbEnPrj.GetCheck() )  {// check the button
		pcw = GetDlgItem(IDC_EDIT_PRJ_NAME) ;
		cePrjName.Attach(pcw->m_hWnd ) ;
		cePrjName.EnableWindow(TRUE) ;
		cePrjName.Detach() ;	
	}
	else {
		pcw = GetDlgItem(IDC_EDIT_PRJ_NAME) ;
		cePrjName.Attach(pcw->m_hWnd ) ;
		cePrjName.EnableWindow(FALSE) ;
		cePrjName.Detach() ;
	} ;
} ;


*/
/********************************************************************************
	BOOL CNewFile::OnInitDialog() 
Do: Enumberate File name list
Args:
Ret.


*********************************************************************************/
BOOL CNewFile::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	m_pcps = DYNAMIC_DOWNCAST(CPropertySheet,GetOwner() ) ;
	
	m_pcps->GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;

	
//	CMDIFrameWnd *pFrame = DYNAMIC_DOWNCAST(CMDIFrameWnd, AfxGetApp()->m_pMainWnd) ;
// Get the active MDI child window.
//	CMDIChildWnd *pChild = DYNAMIC_DOWNCAST(CMDIChildWnd, pFrame->GetActiveFrame() );

	CString cstmp ;
	
//	CDocument *pDoc ;
	cstmp.LoadString(IDS_MDWExtension) ;
/*	
	for ( ; pChild ; pChild = (CMDIChildWnd* ) pChild->GetNextWindow() ) {
		pDoc = (CDocument *) pChild->GetActiveDocument();
		if(pDoc) {
			CString cs = pDoc->GetTitle() ;
			if(cs.Find(cstmp) != -1 ) {
			m_bproj = TRUE;
			break;
			} 
		}
		else
			break;

	} 

	if(m_bproj) {
		CheckDlgButton(IDC_CHECK_PROJECT,1);
		m_csPrjName = ((CProjectRecord*)pDoc)->DriverName();

		m_csFileLoc = ((CProjectRecord*)pDoc)->GetW2000Path();
		
		m_pcps->GetDlgItem(IDOK)->EnableWindow(FALSE) ;

		UpdateData(FALSE);

		
	}
	else{
*/	
//		GetDlgItem(IDC_CHECK_PROJECT)->EnableWindow(FALSE);
//	    GetDlgItem(IDC_STATIC_ADDTOPRJ)->EnableWindow(FALSE);
	CWinApp* pApp = AfxGetApp();
	CString csPath = pApp->m_pszHelpFilePath;
	m_csFileLoc = csPath.Left(csPath.ReverseFind(_T('\\') ) ) ;
	
	UpdateData(FALSE);
		
//	}

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/********************************************************************************
void CNewFile::OnChangeNewFilename() 
Do: Called whenever File Name edit box clicked. just call SetOkButton()
Args:
Ret.

*********************************************************************************/
void CNewFile::OnChangeNewFilename() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	SetOkButton() ;
}

void CNewFile::OnClickNewfilesList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	SetOkButton() ;
	*pResult = 0;
}

/********************************************************************************
void CNewFile::SetOkButton()

Do; Enable and disable OK button by checking the filename and 
selection of file on the list


*********************************************************************************/
void CNewFile::SetOkButton()
{
	UpdateData() ;
	POSITION pos = m_clcFileName.GetFirstSelectedItemPosition();

	if (m_csNewFile.GetLength() != 0 && pos )
		m_pcps->GetDlgItem(IDOK)->EnableWindow()  ;
	else
		m_pcps->GetDlgItem(IDOK)->EnableWindow(FALSE)  ;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newfile.h ===
#if !defined(AFX_NEWFILE_H__97287CE6_9DCB_47D4_920D_23575A63D0B5__INCLUDED_)
#define AFX_NEWFILE_H__97287CE6_9DCB_47D4_920D_23575A63D0B5__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// NewFile.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewFile dialog

/*
class CNewFile : public CPropertyPage

This version doesn't support insert to project file creation. Actually this is intially 
desigend support, but time isn't enough to implement that, so just delete relevant edit,
button in the Dlg box. I don't delete the 


*/
class CNewFile : public CPropertyPage
{
	DECLARE_DYNCREATE(CNewFile)

// Construction
	const int FILES_NUM;

public:
	CNewFile();
	CNewFile(CPropertySheet *pcps) ;
	~CNewFile();

// Dialog Data
	//{{AFX_DATA(CNewFile)
	enum { IDD = IDD_NewFile };
//	CButton	m_cbEnPrj;
	CListCtrl	m_clcFileName;
	CString	m_csFileLoc;
//	CString	m_csPrjName;
	CString	m_csNewFile;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewFile)
	public:
	virtual BOOL OnSetActive();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CNewFile)
	afx_msg void OnBrowser();
	afx_msg void OnDblclkNewfilesList(NMHDR* pNMHDR, LRESULT* pResult);
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewFilename();
	afx_msg void OnClickNewfilesList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void SetOkButton();
//	BOOL m_bproj;
	BOOL CallNewDoc();
	CPropertySheet *m_pcps ;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWFILE_H__97287CE6_9DCB_47D4_920D_23575A63D0B5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\nproject.cpp ===
// NewTProject.cpp : implementation file
//

#include "stdafx.h"
#include "Minidev.h"

#include "utility.h"
#include "projnode.h"
#include "gpdfile.h"

#include <gpdparse.h>
#include "comctrls.h"
#include "newproj.h"

#include "newcomp.h"
#include "nconvert.h"
#include "nproject.h"

//#include "nprjwiz.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewProject dialog

TCHAR *TName[] =  {_T("PCL 3"),_T("PCL 5e"),_T("HPGL 2"),_T("PCL 6"),_T("ESC / 2") } ;
DWORD TID[] = {100,101,102,103,104 } ;
TCHAR *TFileName[] = {_T("pcl3.gpd"),_T("pcl5e.gpd"),_T("hpgl2.gpd"),_T("pcl6.gpd"),_T("escp2.gpd")} ;

TCHAR *AddedGpd[] = { _T("pjl.gpd"),_T("p6disp.gpd"),_T("pclxl.gpd"),_T("p6font.gpd") } ;
DWORD AddID [] = {110,111,112,113} ;

//IMPLEMENT_DYNCREATE(CNewProject, CPropertyPage)

IMPLEMENT_SERIAL(CNewProject, CPropertyPage, 0) 


CNewProject::CNewProject()
	: CPropertyPage(CNewProject::IDD)
{
	//{{AFX_DATA_INIT(CNewProject)
	m_csPrjname = _T("");
	m_csPrjpath = _T("");
	m_cstname = _T("");
	m_cstpath = _T("");
	//}}AFX_DATA_INIT
	unsigned uTemplate = sizeof(TName)/sizeof(TName[0]) ;

	// this routine run when this called for the first time in MDT program
	// project wizard are serialized. 
	if (!m_csaTlst.GetSize() ){  
		for(unsigned i = 0 ; i < uTemplate ; i ++  )
			m_csaTlst.Add(TName[i]) ; 

		CWinApp* pApp = AfxGetApp();
		CString cshelppath = pApp->m_pszHelpFilePath;
		CString csAdded = cshelppath.Left(cshelppath.ReverseFind('\\') ) ;
		csAdded += _T("\\Template\\*.gpd") ;

		CFileFind cff; // BUG_BUG :: code clean below.
		WIN32_FIND_DATA fd;

		HANDLE hFile = FindFirstFile(csAdded,&fd ) ;
		if (INVALID_HANDLE_VALUE != hFile  ) {
			csAdded = csAdded.Left(csAdded.ReverseFind('\\') + 1) ;
			CString cstname = fd.cFileName ;
			cstname = cstname.Left(cstname.ReverseFind(_T('.') )  ) ;
			m_csaTlst.Add(cstname ) ;
			m_cmstsTemplate[m_csaTlst[i++]] = csAdded + fd.cFileName ;
	

			while (FindNextFile(hFile,&fd) ) {
				CString cstname = fd.cFileName ;
				cstname = cstname.Left(cstname.ReverseFind(_T('.') )  ) ;
				m_csaTlst.Add(cstname ) ;
				m_cmstsTemplate[m_csaTlst[i++]] = csAdded + fd.cFileName ;
			}
			
		} ;
	} ;
} ;


void CNewProject::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewProject)
	DDX_Control(pDX, IDC_DirBrowser, m_cbLocprj);
	DDX_Control(pDX, IDC_CHECK_ADD, m_cbAddT);
	DDX_Control(pDX,IDC_LIST_ProjectTemplate,m_clcTemplate) ;
	DDX_Text(pDX, IDC_EDIT_NPRJNAME, m_csPrjname);
	DDX_Text(pDX, IDC_EDIT_NPRJLOC, m_csPrjpath);
	DDX_Text(pDX, IDC_EDIT_AddTName, m_cstname);
	DDX_Text(pDX, IDC_EDIT_AddTPath, m_cstpath);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewProject, CPropertyPage)
	//{{AFX_MSG_MAP(CNewProject)
	ON_BN_CLICKED(IDC_Search_PRJ, OnGpdBrowser)
	ON_BN_CLICKED(IDC_DirBrowser, OnDirBrowser)
	ON_BN_CLICKED(IDC_CHECK_ADD, OnCheckAdd)
	ON_BN_CLICKED(IDC_AddTemplate, OnAddTemplate)
	ON_EN_CHANGE(IDC_EDIT_NPRJNAME, OnChangeEditPrjName)
	ON_EN_CHANGE(IDC_EDIT_NPRJLOC, OnChangeEditPrjLoc)
	ON_NOTIFY(NM_CLICK, IDC_LIST_ProjectTemplate, OnClickListTemplate)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_ProjectTemplate, OnDblclkListTemplate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewProject message handlers

/********************************************************************************
void CNewProject::OnGpdBrowser() 
Look for template file browser (*.gpd)
*********************************************************************************/

void CNewProject::OnGpdBrowser() 
{
	UpdateData() ;
	CString csFilter = _T("Template file(*.gpd)|*.gpd||") ;
	CString csExtension = _T(".GPD") ;
	CFileDialog cfd(TRUE, csExtension, NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST ,csFilter);
	
	if  (cfd.DoModal() == IDOK) {
        m_cstpath = cfd.GetPathName() ;
		UpdateData(FALSE) ;	
	} ;
	
	
}


/********************************************************************************
void CNewProject::OnDirBrowser()
1. locate the directory of project : under this \ufm, \gtt will be created .
2.

*********************************************************************************/

void CNewProject::OnDirBrowser()
{

/*
	BROWSEINFO  brif = {0} ;

    LPITEMIDLIST pidlRoot = NULL;
	LPITEMIDLIST pidlSelected = NULL;
	LPMALLOC pMalloc = NULL ;
	char * pszPath = new char[256] ;

	SHGetMalloc(&pMalloc) ;

//	SHGetSpecialFolderLocation(m_hWnd,CSIDL_RECENT,&pidlRoot) ;

	brif.hwndOwner = m_hWnd ;
	brif.pidlRoot = pidlRoot ;
	brif.pszDisplayName  = new char[256] ;
	brif.lpszTitle = _T("Set Directory") ;
	brif.ulFlags = 0 ;
	brif.lpfn = NULL ;
	

	pidlSelected = SHBrowseForFolder(&brif) ;

	SHGetPathFromIDList(pidlSelected,pszPath) ;
*/
	OPENFILENAME    ofn ;       // Used to send/get info to/from common dlg
    char    acpath[_MAX_PATH] ; // Path is saved here (or an error message)
//    char    acidir[_MAX_PATH] ; // Initial directory is built here
    BOOL    brc = FALSE ;       // Return code

	// Update the contents of csinitdir

	UpdateData(TRUE) ;

    // Load the open file name structure

    ofn.lStructSize = sizeof(ofn) ;
    ofn.hwndOwner = m_hWnd ;
    ofn.hInstance = GetModuleHandle(_T("MINIDEV.EXE")) ;
    ofn.lpstrFilter = ofn.lpstrCustomFilter = NULL ;
    ofn.nMaxCustFilter = ofn.nFilterIndex = 0 ;
    StringCchCopyA(acpath, CCHOF(acpath), _T("JUNK")) ;	// No need to localize this string
    ofn.lpstrFile = acpath ;
    ofn.nMaxFile = _MAX_PATH ;
    ofn.lpstrFileTitle = NULL ;
    ofn.nMaxFileTitle = 0 ;
	ofn.lpstrInitialDir = NULL ; //  in parent dialog box
    ofn.lpstrTitle = NULL ;
    ofn.Flags = OFN_HIDEREADONLY /*| OFN_ENABLEHOOK */| OFN_NOCHANGEDIR
        | OFN_NOTESTFILECREATE | OFN_ENABLETEMPLATE | OFN_NONETWORKBUTTON ;
    ofn.lpstrDefExt = NULL ;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPENORD) ;
    ofn.lpfnHook = NULL ;// BrowseDlgProc ;

    // Display the dialog box.  If the user cancels, just return.

    if (!GetOpenFileName(&ofn))
		return ;

    // Take the bogus file name off the path and put the path into the page's
	// edit box.

    acpath[ofn.nFileOffset - 1] = 0 ;
    
	m_csPrjpath = (LPCTSTR) acpath ;
	m_csoldPrjpath = m_csPrjpath ;
	if ( m_csPrjname.GetLength() != 0)
		m_csPrjpath += _T("\\") + m_csPrjname ;

	UpdateData(FALSE) ;
/*	if (pidlSelected)
		pMalloc->Free(pidlSelected) ;

	pMalloc->Release() ;
*/


}

/********************************************************************************
BOOL CNewProject::OnInitDialog()
ToDo : load the template gpd file and show them to list control box, also disable
add template relevant control
*********************************************************************************/

BOOL CNewProject::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// get PropertySheet pointer
	m_pcps = DYNAMIC_DOWNCAST(CPropertySheet,GetOwner() ) ;

	// uncheck the check box,
	m_cbAddT.SetCheck(false) ;
	
	// disable Add Template Edit box
	TCHAR cBuf[256];

	GetCurrentDirectory(256,cBuf) ;
	m_csPrjpath = cBuf ;
	m_csoldPrjpath = m_csPrjpath ;
	UpdateData(FALSE);

	// initialize the tempalte list with its icon
	CImageList* pcil = new CImageList ;

	pcil->Create(16,16,ILC_COLOR4,4,1 );

	CBitmap cb;
	   
	cb.LoadBitmap(IDB_SMALLGLYPH);
	for (unsigned j =0; j< (unsigned)m_csaTlst.GetSize(); j++)	{
		pcil->Add(&cb,RGB(0,0,0) );
	}
    cb.DeleteObject() ;
	
	m_clcTemplate.SetImageList(pcil,LVSIL_SMALL);

	LV_ITEM lvi ;
	for(unsigned i = 0 ; i < (unsigned)m_csaTlst.GetSize() ; i ++  ) {
		 
		lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM ;
		lvi.iItem = i ;
		lvi.iSubItem = 0 ;
		lvi.pszText = m_csaTlst[i].GetBuffer(m_csaTlst[i].GetLength() ) ;
		lvi.iImage = i ;
		lvi.lParam = (UINT_PTR)i ;

		m_clcTemplate.InsertItem(&lvi) ;
	
	}
	
	// disable unused button
	GetDlgItem(IDC_EDIT_AddTName)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_EDIT_AddTPath)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_AddTemplate)->EnableWindow(FALSE) ;
		
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/********************************************************************************
BOOL CNewProject::OnSetActive() 

*********************************************************************************/

BOOL CNewProject::OnSetActive() 
{
	SetButton() ;
	
//	UpdateData(FALSE) ;
	
	return CPropertyPage::OnSetActive();
}

/********************************************************************************
CNewProject::OnCheckAdd() 
when user check the add template box, it will enable other control


**********************************************************************************/
void CNewProject::OnCheckAdd() 
{
	CEdit ceTName, ceTPath ;

	if ( m_cbAddT.GetCheck() )  {// check the button
		GetDlgItem(IDC_EDIT_AddTName)->EnableWindow(TRUE) ;
		GetDlgItem(IDC_EDIT_AddTPath)->EnableWindow(TRUE) ;
		GetDlgItem(IDC_AddTemplate)->EnableWindow(TRUE) ;
			
	} 
	else {
		GetDlgItem(IDC_EDIT_AddTName)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_EDIT_AddTPath)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_AddTemplate)->EnableWindow(FALSE) ;
	} ;


} ; 



/********************************************************************************
	void CNewProject::OnAddTemplate() 
1. Add template name to Template list box.
2. Save template file and its file to mapping variable



********************************************************************************/
void CNewProject::OnAddTemplate() 
{
	UpdateData() ;
	// check the added template nane is right ?
	BOOL bname = FALSE ;
	for ( unsigned i = 0 ; i < (unsigned) m_csaTlst.GetSize() ; i++ ) {
		CString cstmp = m_csaTlst[i] ;
		if (!cstmp.CompareNoCase(m_cstname) ){
			bname = TRUE ;
			break;	
		}
	} ;

	if (m_cstname.GetLength() == 0 || m_cstpath.GetLength() == 0 || bname) {
		CString csErr ;
		csErr.LoadString(IDS_FailCreateTemplate) ;
	
	    AfxMessageBox(csErr,MB_ICONEXCLAMATION) ;
		return ;
	} ;
	
	// add the template name to its CStrinArray name list and list control.
	m_csaTlst.Add(m_cstname) ;
	i = PtrToInt(PVOID(m_csaTlst.GetSize()) ) ; 
	m_clcTemplate.InsertItem(i-1, m_csaTlst[i-1] ) ;
	
	
	// copy the template file into the template directory, which is under MDT file
	// directory\template
	// Get the mdt dir.
	CWinApp* pApp = AfxGetApp();
	CString csRoot = pApp->m_pszHelpFilePath;
	csRoot = csRoot.Left(csRoot.ReverseFind('\\') ) ;
	csRoot += _T("\\Template") ;

	// Create the directory under MDT help file directory if it does not exist
	SECURITY_ATTRIBUTES st;
	st.nLength = sizeof(SECURITY_ATTRIBUTES);
	st.lpSecurityDescriptor = NULL;
	st.bInheritHandle = FALSE ;

	WIN32_FIND_DATA wfd32 ;
	HANDLE hDir = FindFirstFile(csRoot,&wfd32) ;
	if (hDir == INVALID_HANDLE_VALUE) {
		if (!CreateDirectory(csRoot,&st) ) {
			CString csErr ;
			csErr.LoadString(IDS_FailCreateTempDir) ;
			AfxMessageBox(csErr) ;
			return ;
		} 
	} ;
	// copy the file, target file name should be template file name for convernience 
	// when loading the template file.
	CString csdst = csRoot + _T('\\') +  m_cstname + _T(".GPD") ;
	if (!CopyFile(m_cstpath,csdst , TRUE)) {
			CString csmsg ;
			csmsg.Format(IDS_AddCopyFailed, m_cstpath,
						 csdst.Left(csdst.GetLength() - 1)) ;
			csmsg += csdst ;
			AfxMessageBox(csmsg) ;
			return ;
	};

	// add to the collection as its template name and its path
	m_cmstsTemplate[m_cstname] = (LPCTSTR)csdst.GetBuffer(256) ;

	
	CString csmsg ;
	csmsg.Format(IDS_TemplateCreated, csRoot ) ;
	AfxMessageBox(csmsg) ;

}



/***************************************************************************************
	void CNewProject::OnChangeEditPrjName() 

1.  As user write project name, same name will be written to prject path simultaneously.


****************************************************************************************/
void CNewProject::OnChangeEditPrjName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	

	
	UpdateData() ;
	
	SetButton() ;

	m_csPrjpath = m_csoldPrjpath + _T("\\") + m_csPrjname ;
	
	UpdateData(FALSE) ;

}

/***************************************************************************************
void CNewProject::OnChangeEditPrjLoc() 


****************************************************************************************/
void CNewProject::OnChangeEditPrjLoc() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	UpdateData();
	m_csoldPrjpath = m_csPrjpath ;

	
}



/***************************************************************************************
void CNewProject::OnClickListTemplate(NMHDR* pNMHDR, LRESULT* pResult) 


****************************************************************************************/
void CNewProject::OnClickListTemplate(NMHDR* pNMHDR, LRESULT* pResult) 
{
	
	SetButton() ;
	*pResult = 0;
}


/***************************************************************************************
void CNewProject::OnDblclkListTemplate(NMHDR* pNMHDR, LRESULT* pResult) 
ToDo ; Do nothing when no project name exist

****************************************************************************************/
void CNewProject::OnDblclkListTemplate(NMHDR* pNMHDR, LRESULT* pResult) 
{
	POSITION pos = m_clcTemplate.GetFirstSelectedItemPosition();
	
	// template and project name has to be selected or exist
	if ( m_csPrjname.GetLength() != 0 && pos )
		m_pcps->PressButton(PSBTN_OK) ;
    else
		AfxMessageBox (_T("No Project name exist or template is not selected"), MB_ICONINFORMATION) ;
	*pResult = 0;
}


/***************************************************************************************
void CNewProject::SetButton()


****************************************************************************************/
void CNewProject::SetButton()
{
	POSITION pos = m_clcTemplate.GetFirstSelectedItemPosition();
	
	// template and project name has to be selected or exist
	if ( m_csPrjname.GetLength() == 0 || !pos )
		m_pcps->GetDlgItem(IDOK)->EnableWindow(FALSE) ;
	else
		m_pcps->GetDlgItem(IDOK)->EnableWindow() ;

}


/***************************************************************************************
void CNewProject::Serialize(CArchive& car) 

****************************************************************************************/
void CNewProject::Serialize(CArchive& car) 
{
	CPropertyPage::Serialize(car) ;
	if (car.IsStoring())
	{	
		
	}
	else
	{	
		
	}
}

/*****************************************************************************************
void CNewProject::OnOK() 
ToDo : Creat poject directory as well as creat temp file for resource gpd file / get path 
of custom gpd file


******************************************************************************************/
void CNewProject::OnOK() 
{
		// TODO: Add your specialized code here and/or call the base class
	UpdateData() ;		// copy all edit value to its member data.

	POSITION pos = m_clcTemplate.GetFirstSelectedItemPosition();
	
	int iSelected = m_clcTemplate.GetNextSelectedItem(pos );
	
	if (iSelected < sizeof(TName)/sizeof(TName[0]) ) { // for using template from the resource
	
		CString cstmp = AfxGetApp()->m_pszHelpFilePath ;
		cstmp = cstmp.Left(cstmp.ReverseFind(_T('\\')) + 1 )  ;
		cstmp += _T("tmp.gpd")   ;
		CFile cf(cstmp,CFile::modeCreate | CFile::modeWrite ) ;
		
		HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE(TID[iSelected]),
			MAKEINTRESOURCE(IDR_NEWPROJECT));
			

		if (!hrsrc) {
			CString csError ; 
			csError.LoadString(IDS_ResourceError) ;
			AfxMessageBox(csError,MB_ICONEXCLAMATION) ;		
			return ;
		} ;

		HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);
		if  (!hgMap)
			return ;  //  This should never happen!
	
		int nsize = SizeofResource(AfxGetResourceHandle(),hrsrc ) ;
		LPVOID lpv = LockResource(hgMap);
		
		cf.Write(lpv,nsize) ;
		m_csGPDpath = cf.GetFilePath() ;

		cf.Close() ;
			
	}
	else {
		m_csGPDpath = (LPCTSTR)m_cmstsTemplate[m_csaTlst[iSelected]] ;
	}

	// create directory
	SECURITY_ATTRIBUTES st;
	st.nLength = sizeof(SECURITY_ATTRIBUTES);
	st.lpSecurityDescriptor = NULL;
	st.bInheritHandle = FALSE ;

	if (!CreateDirectory(m_csPrjpath.GetBuffer(256),&st) ) {
		DWORD dwError = GetLastError() ;
		CString csmsg ;
		if ( dwError == ERROR_ALREADY_EXISTS)
			csmsg.LoadString(IDS_FileAlreadExist) ;
		else
			csmsg.LoadString(IDS_FileCreateDirectory) ;
		AfxMessageBox(csmsg) ;
		return ;
	}
	
	CString csTmp = m_clcTemplate.GetItemText(iSelected,0);
	
	//Check selected template if it required added file (PCL 6 need e more resource files)
	// if so, Call AddGpds() for creating these files
	if(!csTmp.Compare(_T("PCL 6") )&& !AddGpds(csTmp) ){
		CString csError ; 
		csError.LoadString(IDS_ResourceError) ;
		AfxMessageBox(csError,MB_ICONEXCLAMATION) ;		
		return ;
	}

	m_pcps->ShowWindow(SW_HIDE) ;

	CNewProjectWizard cntp (_T("New Project Wizard"), this ) ;
 
	if (cntp.DoModal() == IDCANCEL)
		m_pcps->ShowWindow(SW_RESTORE) ;		
	else CPropertyPage::OnOK();
}


/***************************************************************************************
bool CNewProject::AddGpds() 

Do : copy required gpd filss according to a selected template. for instance, PCL6 need pjl.gpd,
p6disp.gpd, pclxl.gpd files.

****************************************************************************************/


bool CNewProject::AddGpds(CString& csTemplate)
{

	for (int i = 0 ; i < sizeof(AddID) / sizeof(AddID[0]) ; i ++ ) {
		CString cstmp = m_csPrjpath + _T('\\') + AddedGpd[i] ;
		
		CFile cf(cstmp,CFile::modeCreate | CFile::modeWrite ) ;
			
		HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE(AddID[i]),
			MAKEINTRESOURCE(IDR_NEWPROJECT));
			

		if (!hrsrc) {
			CString csError ; 
			csError.LoadString(IDS_ResourceError) ;
			AfxMessageBox(csError,MB_ICONEXCLAMATION) ;		
			return false;
		} ;

		HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);
		if  (!hgMap) 
			return false ;  //  This should never happen!

		int nsize = SizeofResource(AfxGetResourceHandle(),hrsrc ) ;
		LPVOID lpv = LockResource(hgMap);
		
		cf.Write(lpv,nsize) ;
		cf.Close() ;
	}
	return true ;
}






/////////////////////////////////////////////////////////////////////////////
// CNewPrjWResource dialog

IMPLEMENT_DYNCREATE(CNewPrjWResource, CPropertyPage)

CNewPrjWResource::CNewPrjWResource()
	: CPropertyPage(CNewPrjWResource::IDD)
{
	//{{AFX_DATA_INIT(CNewPrjWResource)
	m_csUFMpath = _T("");
	m_csGTTpath = _T("");
	m_csGpdFileName = _T("");
	m_csModelName = _T("");
	m_csRCName = _T("");
	//}}AFX_DATA_INIT
//	m_csaUFMFiles.SetSize(10) ;
//	m_csaGTTFiles.SetSize(10) ; 
}


void CNewPrjWResource::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewPrjWResource)
	DDX_Control(pDX, IDC_CHECK_FONTS, m_cbCheckFonts);
	DDX_Text(pDX, IDC_UFM_PATH, m_csUFMpath);
	DDX_Text(pDX, IDC_GTT_PATH, m_csGTTpath);
	DDX_Text(pDX, IDC_EDIT_GPD, m_csGpdFileName);
	DDX_Text(pDX, IDC_EDIT_MODEL, m_csModelName);
	DDX_Text(pDX, IDC_EDIT_RESOUREC, m_csRCName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewPrjWResource, CPropertyPage)
	//{{AFX_MSG_MAP(CNewPrjWResource)
	ON_BN_CLICKED(IDC_SerchUFM, OnSerchUFM)
	ON_BN_CLICKED(IDC_SearchGTT, OnSearchGTT)
	ON_BN_CLICKED(IDC_CHECK_FONTS, OnCheckFonts)
	ON_EN_CHANGE(IDC_EDIT_GPD, OnChangeEditGpd)
	ON_EN_CHANGE(IDC_EDIT_MODEL, OnChangeEditModel)
	ON_EN_CHANGE(IDC_EDIT_RESOUREC, OnChangeEditResourec)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/********************