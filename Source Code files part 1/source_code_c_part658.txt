//
    NCB             *pNCB;
    PUCHAR          pzDnsName;
    PULONG          pIpAddress;

} DNS_DIRECT_WORK_ITEM_CONTEXT, *PDNS_DIRECT_WORK_ITEM_CONTEXT;

typedef struct
{
    tDEVICECONTEXT  *pDeviceContext;
    TDI_CONNECTION_INFORMATION
                    SendInfo;
    TA_IP_ADDRESS   NameServerAddress;
    tBUFFER         SendBuffer;   // send buffer and header to send
    tNAMEHDR        NameHdr;
} DNS_DIRECT_SEND_CONTEXT, *PDNS_DIRECT_SEND_CONTEXT;

//
// Flag bits useful for DNS direct name queries.
//
#define DNS_DIRECT_CANCELLED        0x0001      // request cancelled
#define DNS_DIRECT_DNS_SERVER       0x0002      // going to main DNS
#define DNS_DIRECT_DNS_BACKUP       0x0004      // going to main DNS
#define DNS_DIRECT_TIMED_OUT        0x0008      // request timed out
#define DNS_DIRECT_NAME_HAS_DOTS    0x0010      // name has dots in it, could be fully formed
                                                // DNS specifier
#define DNS_DIRECT_ANSWERED         0x0020      // This query has been answered
#endif // VXD

#ifndef VXD
// configuration information is passed between the registry reading
// code and the driver entry code in this data structure
// see ntdef.h for this type....
typedef struct
{
    PKEY_VALUE_FULL_INFORMATION RegistryData;   // MULTI_SZ data read from the registry
    UNICODE_STRING              Names[1];       // array of strings initialized from RegistryData above
}tDEVICES;
#endif  // !VXD

// this is the control object for all of NBT that tracks a variety
// of counts etc.  There is a ptr to this in the GlobConfig structure
// below so that we can delete it later at clean up time
typedef struct
{
    // a value to verify that this is a device context record
    ULONG           Verify;

    // this is a LARGE structure of goodies that is returned to the client
    // when they do a QueryInformation on TDI_PROVIDER_INFO
    TDI_PROVIDER_INFO  ProviderInfo;
} tCONTROLOBJECT;

// Keep an Irp around for the out of resource case, so that we can still
// disconnection a connection with the transport
// Also, keep a KDPC handy so if we can use it in case lot of connections
// are to be killed in succession
//
typedef struct
{
    PIRP        pIrp;
    LIST_ENTRY  ConnectionHead;
#ifndef VXD
    PKDPC       pDpc;
#endif

} tOUTOF_RSRC;


// this type holds NBT configuration information... is globally available
// within NBT using NbtConfig.
typedef struct
{
    // Line # 1
    LIST_ENTRY  DeviceContexts;     // list of DeviceContexts, 1/network adapter(tDEVICECONTEXT)
    LIST_ENTRY  DevicesAwaitingDeletion;    // list of DeviceContexts waiting to be deleted

    // Line # 2
    tHASHTABLE  *pLocalHashTbl;     // hash table to keep track of local names
    tHASHTABLE  *pRemoteHashTbl;    // hash table to keep track of remote names
    LIST_ENTRY  DgramTrackerFreeQ;  // buffers to track Dgram sends...

    // Line # 3
    LIST_ENTRY  NodeStatusHead;     // list of node status messages being sent
    LIST_ENTRY  AddressHead;        // allocated addresses in a linked list

    // Line # 4
    LIST_ENTRY  PendingNameQueries;
    LONG        lNumPendingNameQueries;
    LONG        lMaxNumPendingNameQueries;

#ifdef VXD
    LIST_ENTRY  DNSDirectNameQueries;
    LIST_ENTRY  SendTimeoutHead;    //  Tracks Send NCBs to check if they have timed out yet.
    LIST_ENTRY  SessionBufferFreeList; // Free eNBT_SESSION_HDR buffer list
    LIST_ENTRY  SendContextFreeList;// TDI_SEND_CONTEXT (not SEND_CONTEXT!) -- eNBT_SEND_CONTEXT
    LIST_ENTRY  RcvContextFreeList; // Free eNBT_RCV_CONTEXT buffer list
    LIST_ENTRY  DelayedEvents;      // all events scheduled for later (that apply to all device contexts)
    LIST_ENTRY  BlockingNcbs;
#else

    // Line # 5
    tCONTROLOBJECT      *pControlObj; // a ptr to keep track of the memory allocated to the control object
    PDRIVER_OBJECT      DriverObject;
    SINGLE_LIST_ENTRY   SessionMdlFreeSingleList; // MDLs for session sends to speed up sending session PDUs

    // Line # 6
    UNICODE_STRING      pRegistry;  // ptr to registry Node for Netbt if DHCP requests come down later.
    PWSTR       pTcpBindName;       // a ptr to the name of the transport (i.e. \Device\Streams\")
#endif //VXD
    tTIMERQENTRY *pRefreshTimer;    // timer entry for refreshing names with WINS
    tTIMERQENTRY *pWakeupRefreshTimer;    // timer entry for Waking machine up from Hibernation!
    tTIMERQENTRY *pSessionKeepAliveTimer;
    tTIMERQENTRY *pRemoteHashTimer;

    // Line # 7
#ifdef _PNP_POWER_
    USHORT      uNumDevicesInRegistry;  // number of adapters counted in registry
#else
    USHORT      uNumDevices;            // number of adapters counted in registry
#endif  // _PNP_POWER_
    USHORT      iCurrentNumBuff[eNBT_NUMBER_BUFFER_TYPES];  // track how many buffers have been allocated
    USHORT      iMaxNumBuff[eNBT_NUMBER_BUFFER_TYPES];
    USHORT      iBufferSize[eNBT_NUMBER_BUFFER_TYPES];      // eNBT_NUMBER_BUFFER_TYPES == 5

    // Line # 9
    int         NumConnections;     // number of connections set in registry
    int         NumAddresses;       // number of addresses node supports set in reg.
    ULONG       InterfaceIndex;
#ifndef VXD
    // This structure keeps an Irp ready to disconnect a connection in the
    // event we run out of resources and cannot do anything else. It also allows
    // connections to Q up for disconnection.
    tOUTOF_RSRC OutOfRsrc;

    // used to hold Address exclusively while registering - when mucking with
    // ShareAccess and the security descriptors
    //
    ERESOURCE          Resource;
#endif  // !VXD

    USHORT      uNumLocalNames;         // size of remote hash table for Pnode
    USHORT      uNumRemoteNames;        // size of remote hash table for Proxy
    USHORT      uNumBucketsRemote;
    USHORT      uNumBucketsLocal;
    USHORT      TimerQSize;             // the number of timer Q blocks
    USHORT      AdapterCount;           // bindings/devices/local IP addresses in use

    LONG        uBcastTimeout;          // timeout between Broadcasts
    LONG        uRetryTimeout;          // timeout between retries

    CTEULONGLONG CurrentAdaptersMask;   // Bit mask of currently active adapters
    ULONG       CacheTimeStamp;
    USHORT      RemoteCacheLen;
    UCHAR       MultipleCacheFlags;
    BOOLEAN     CachePerAdapterEnabled; // Will try to resolve names on all interfaces
    BOOLEAN     ConnectOnRequestedInterfaceOnly;    // Strict source routing
    BOOLEAN     SendDgramOnRequestedInterfaceOnly;  // Strict source routing for sending datagram.
    BOOLEAN     SMBDeviceEnabled;       // Whether SMB device should be enabled or not

    USHORT      uNumRetries;            // number of times to send a dgram - NS as well as Dgram Queries
    USHORT      uNumBcasts;             // number of times to bcast name queries

    // the scope must begin with a length byte that gives the length of the next
    // label, and it must end with a NULL indicating the zero length root
    USHORT      ScopeLength;            // number of bytes in scope including the 0 on the end
    USHORT      SizeTransportAddress;   // number of bytes in transport addr (sizeof TDI_ADDRESS_IP for IP)
    PCHAR       pScope;                 // scope if ScopeLength > 0

    tNAMEADDR   *pBcastNetbiosName;     // a ptr to the netbios name record in the local hash table

    // the shortest Ttl of any name registered by this node and the name that
    // has the shortest Ttl
    ULONG       MinimumTtl;
    ULONG       RefreshDivisor;
    ULONG       RemoteHashTtl;

    ULONG       RandomNumberSeed;

    LONG        InboundDgramNameCacheTtl;
    ULONG       MinimumRefreshSleepTimeout;
    LONG        NumNameCached;
    LONG        MaxNumNameCached;

    //
    // This is amount of time to stop talking to WINS when we fail to contact
    // it on a name registration. Nominally around 5 seconds - configurable.
    //
    ULONG       WinsDownTimeout;
    ULONG       InitialRefreshTimeout;  // to refresh names to WINS till we hear from WINS
    ULONG       KeepAliveTimeout;       // keep alive timeout for sessions
    ULONG       RegistryBcastAddr;

    ULONG       DhcpNumConnections;     // # connections to restore when the ip address becomes valid again.
    USHORT      CurrentHashBucket;

    USHORT      PduNodeType;     // node type that goes into NS pdus
    USHORT      TransactionId;   // for name service request, to number them

    USHORT      NameServerPort;  // UDP port to send queries/reg to (on the name server)
#ifdef VXD
    USHORT      DnsServerPort;   // UDP port to send DNS queries to (on the dns server)
#endif  // VXD
    USHORT      sTimeoutCount;   // current time segment we are on for refresh

    USHORT      LastSwitchTimeoutCount;  // Count to know when we last switched to primary

    // this spin lock is used to coordinate access to the timer Q and the
    // hash tables when either a timer is expiring or a name service PDU
    // has come in from the wire.  This lock must be acquired first, and
    // then the timer Q lock.
    tJOINTLOCK  JointLock;
    tNBT_LOCK_INFO  LockInfo;     // spin lock info for this struct
    USHORT      RemoteTimeoutCount; // how long to timeout remote hash entries
    USHORT      InboundDgramNameCacheTimeOutCount;

    // if 1, then use -1 for bcast addr - if 0 use subnet broadcast address
    BOOLEAN     UseRegistryBcastAddr;

    // the maximum amount of buffering that we will do for sent datagrams
    // This is also used by Wins to determine inbound and outbound buffer
    // limits.
    ULONG       MaxDgramBuffering;
    // this is the time that a name query can spend queued waiting for the
    // the worker thread to service it. - default is 30 seconds.
    ULONG       LmHostsTimeout;

    PUCHAR      pLmHosts;
    ULONG       PathLength;  // the length of the directory portion of pLmHosts
    CTESystemTime   LastForcedReleaseTime;
    CTESystemTime   LastOutOfRsrcLogTime;
#ifdef VXD
    PUCHAR      pHosts;      // path to the hosts file
    PUCHAR      pDomainSearchOrder; // primary domain: used during DNS resolution
    PUCHAR      pDNSDevolutions; // "other domains"

    ULONG       lRegistryDnsServerAddress;
    ULONG       lRegistryDnsBackupServer;

    USHORT      lRegistryMaxNames;
    USHORT      lRegistryMaxSessions;
#endif  // VXD

    BOOLEAN     MultiHomed;  // True if NBT is bound to more than one adapter
    BOOLEAN     SingleResponse; // if TRUE it means do NOT send all ip addresses on a name query request

     // if TRUE randomly select an IP addr on name query response rather than
     // return the address that the request came in on.
    BOOLEAN     SelectAdapter;

    // This boolean tells Nbt to attempt name resolutions with DNS
    BOOLEAN     ResolveWithDns;
    // This boolean tells Nbt not to use the cached entries for SMB device
    // if they are not resolved through DNS
    BOOLEAN     SmbDisableNetbiosNameCacheLookup;
    // Nbt tries all addresses of a multi-homed machine if this is TRUE (by default its TRUE).
    BOOLEAN     TryAllAddr;
    BOOLEAN     UseDnsOnly; // Flag to tell us not to use WINs for name Resolutions
    BOOLEAN     NoNameReleaseOnDemand; // Flag to tell us not to release any Name on demand
#ifdef MULTIPLE_WINS
    //  This boolean tells Nbt to try the list of other name servers in addition
    //  to the primary and secondary when doing name queries
    BOOLEAN     TryAllNameServers;
#endif  // MULTIPLE_WINS
    // This boolean tells Nbt to attempt name resolutions with LMhosts
    BOOLEAN     EnableLmHosts;
    // This allows a proxy to do name queries to WINS to check Bnode name
    // registrations.  By default this functionality is off since it could
    // be a RAS client who has changed its IP address and the proxy will
    // deny the new registration since it only does a query and not a
    // registration/challenge.
    //
    BOOLEAN     EnableProxyRegCheck;
    tPROXY_TYPE ProxyType;

    UCHAR       GlobalRefreshState; // Keep track of what RefreshState we are in
#ifdef VXD
    BOOLEAN     DoDNSDevolutions;
#endif  // VXD
    UCHAR       CurrProc;
    //
    // allow the refresh op code to be registry configured since UB uses
    // a different value than everyone else due to an ambiguity in the spec.
    // - we use 0x40 and they use 0x48 (8, or 9 in the RFC)
    //
    USHORT      OpRefresh;
    uint        MaxPreloadEntries;

    ULONG   MaxBackLog;
    ULONG   SpecialConnIncrement;
    ULONG   MinFreeLowerConnections;

    USHORT      DefaultSmbSessionPort;
    USHORT      DefaultSmbDatagramPort;

    LONG            lNumTimersRunning;
    LONG            lMaxNumTimersRunning;
    KEVENT          TimerQLastEvent;
    KEVENT          WakeupTimerStartedEvent;

    tJOINTLOCK WorkerQLock;
    LIST_ENTRY WorkerQList;
    ULONG NumWorkItemQueued;
    volatile BOOL bSystemWorkThreadQueued;
    WORK_QUEUE_ITEM SystemWorkItem;
    PRKTHREAD pWorkThread;

    CTESystemTime   LastRefreshTime;
#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    LONG        DhcpProcessingDelay;    // the delay (in ms) after a DHCP requests comes in
#endif
    ULONG           LoopbackIfContext;


    PWSTR           pServerBindings;
    PWSTR           pClientBindings;
    CTEULONGLONG    ServerMask;         // Bit mask of adapters on which server is currently active
    CTEULONGLONG    ClientMask;         // Bit mask of adapters on which client is currently active

    UCHAR       MaxIrpStackSize;        // The maximum stack size

    BOOLEAN     BreakOnAssert;      // To enable tests to run on checked builds
    //
    // Tdi registration / deregistration requests
    //
    BOOLEAN     Unloading;

#if DBG
    LIST_ENTRY      StaleRemoteNames;
#endif  // DBG
    //
    // Put all Debug Info at the end!
    //
#if DBG && !defined(VXD)
    // NBT's current lock level - an array entry for up to 32 processors
    ULONG       CurrentLockNumber[MAXIMUM_PROCESSORS];
    DEFINE_LOCK_STRUCTURE(DbgSpinLock)
#endif  // DBG && !defined(VXD)
} tNBTCONFIG;

extern tNBTCONFIG           *pNbtGlobConfig;
extern tNBTCONFIG           NbtConfig;
extern tNAMESTATS_INFO      NameStatsInfo;
extern tLMHSVC_REQUESTS     CheckAddr;
extern tLMHSVC_REQUESTS     DnsQueries;            // defined in parse.c
extern tLMHSVC_REQUESTS     LmHostQueries;         // defined in parse.c
extern tDOMAIN_LIST         DomainNames;
#ifndef VXD
extern tWINS_INFO           *pWinsInfo;
extern LIST_ENTRY           FreeWinsList;
#ifdef _PNP_POWER_
extern tDEVICECONTEXT       *pWinsDeviceContext;
#endif  // _PNP_POWER_
#ifdef _NETBIOSLESS
extern BOOL                 gbDestroyingSmbDevice;
extern DWORD                gdwPendingEnableDisableSmbDevice;
extern tDEVICECONTEXT       *pNbtSmbDevice;
extern DWORD    AddressCount;
#endif  // _NETBIOSLESS
extern PEPROCESS            NbtFspProcess;
#endif  // !VXD
extern ULONG                NbtMemoryAllocated;

#ifdef VXD
extern ULONG                DefaultDisconnectTimeout;
#else
extern LARGE_INTEGER        DefaultDisconnectTimeout;
#endif  // VXD
// ************** REMOVE LATER********************
extern BOOLEAN              StreamsStack;

//#if DBG
extern LIST_ENTRY           UsedTrackers;
extern LIST_ENTRY           UsedIrps;
//#endif  // DBG


#ifdef _PNP_POWER_

enum eTDI_ACTION
{
#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    NBT_TDI_NOACTION,       // No delayed TDI notification for clients
    NBT_TDI_BUSY,           // The worker thread is busy in notifying the client
#endif
    NBT_TDI_REGISTER,       // Register the Device and Net Address
    NBT_TDI_DEREGISTER      // DeRegister the Net Address and Device respectively
};


#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    #define WS_DHCP_PROCESSING_DELAY        ANSI_IF_VXD("DhcpProcessingDelay")

    //
    // DHCP Processing Delay
    //
    #define MIN_DHCP_PROCESSING_DELAY               0           // millisecs
    #define DEFAULT_DHCP_PROCESSING_DELAY           75          // millisecs
#endif       // REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG


//
// IP, UDP, and NetBT headers copied from:
// ip.h, udp.h and types.h respectively
//
typedef struct _NETBT_WAKEUP_PATTERN_
{
    // * IP Header format *                                           ** Bit Mask **
    UCHAR           iph_verlen;         // Version and length.          **    0 **
    UCHAR           iph_tos;            // Type of service.             **    0 **
    USHORT          iph_length;         // Total length of datagram.    **   00 **
    USHORT          iph_id;             // Identification.              **   00 **
    USHORT          iph_offset;         // Flags and fragment offset.   **   00 **
                                                                    // 8 byte boundary
    UCHAR           iph_ttl;            // Time to live.                **    0 **
    UCHAR           iph_protocol;       // Protocol.                    **    1 **
    USHORT          iph_xsum;           // Header checksum.             **   00 **
    tIPADDRESS      iph_src;            // Source address.              ** 0000 **
                                                                    // 8 byte boundary
    tIPADDRESS      iph_dest;           // Destination address.         ** 0000 **

    // * UDP header *
    USHORT          udph_src;           // Source port.                 **   11 **
    USHORT          udph_dest;          // Destination port.            **   11 **
                                                                    // 8 byte boundary
    USHORT          udph_length;        // Length                       **   00 **
    USHORT          udph_xsum;          // Checksum.                    **   00 **

    // * NetBT header *
    USHORT          nbt_TransactId;     //                              **   00 **
    USHORT          nbt_OpCodeFlags;    // BCast Name Qeuries/Reg       **   01 **
                                                                    // 8 byte boundary
    UCHAR           nbt_Zero1;          //                              **    0 **
    UCHAR           nbt_QdCount;        //                              **    0 **
    UCHAR           nbt_Zero2;          //                              **    0 **
    UCHAR           nbt_AnCount;        //                              **    0 **
    UCHAR           nbt_Zero3;          //                              **    0 **
    UCHAR           nbt_NsCount;        //                              **    0 **
    UCHAR           nbt_Zero4;          //                              **    0 **
    UCHAR           nbt_ArCount;        //                              **    0 **
                                                                    // 8 byte boundary
    UCHAR           nbt_NameRR[1 + 2*NETBIOS_NAME_SIZE + 1];        //  **    1 <*> 34 **
} NETBT_WAKEUP_PATTERN, *PNETBT_WAKEUP_PATTERN;


#define NetBTPatternLen  (40 + (1+30))                              // Ignore 16th byte of name
// The mask bits are in the order of least significant to most sig!
#define NetBTPatternMask "\x00\x02\xF0\x80\x00\xFF\xFF\xFF\x7F\x00" // Extra ULONG precaution

#endif  // _PNP_POWER_

#define NBT_ALIGN(x,b)  (((x)+(b)-1) & (~((b)-1)))
#define NBT_DWORD_ALIGN(x)  NBT_ALIGN(x,4)

//
// The following structures needs to be mis-aligned and packed
//
#include <packon.h>

typedef UNALIGNED struct _TDI_ADDRESS_NETBT_INTERNAL {
    USHORT                  NameType;

    // Basically, NetBT support only two address types.
    // TDI_ADDRESS_TYPE_NETBIOS and TDI_ADDRESS_TYPE_NETBIOS_EX
    // TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX is mapped into TDI_ADDRESS_TYPE_NETBIOS_EX
    USHORT                  AddressType;

    // Don't use Rtl* routines below guys unless you're sure they are properly null-terminated!!!
    // Note: legacy NetBT address type ( may use fixed length string which is not null-terminated.
    //       The new TDI_ADDRESS_NETBIOS_UNICODE_EX address type is fully null-terminated.
    OEM_STRING              OEMEndpointName;
    OEM_STRING              OEMRemoteName;

    //
    // Point to the original UNICODE structure
    //
    TDI_ADDRESS_NETBIOS_UNICODE_EX  *pNetbiosUnicodeEX;
} TDI_ADDRESS_NETBT_INTERNAL, *PTDI_ADDRESS_NETBT_INTERNAL;

typedef UNALIGNED struct _TA_ADDRESS_NETBT_INTERNAL {
    LONG TAAddressCount;            // can only be ONE!!!
    struct _AddrNetBTInternal {
        USHORT AddressLength;       // length in bytes of this address == ??
        USHORT AddressType;         // this will == TDI_ADDRESS_TYPE_NETBT_INTERNAL
        TDI_ADDRESS_NETBT_INTERNAL Address[1];
    } Address [1];
} TA_NETBT_INTERNAL_ADDRESS, *PTA_NETBT_INTERNAL_ADDRESS;
#include <packoff.h>

#define MIN_NBT_NUM_PENDING_NAME_QUERIES        16

#endif  // _TYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\inc\vxdprocs.h ===
/**********************************************************************/
/**           Microsoft Windows/NT               **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    vxdprocs.h

    This file contains VxD specific types/manifests for the NBT driver


    FILE HISTORY:
        Johnl   29-Mar-1993     Created
        MohsinA, 17-Nov-96.     Make it work on Memphis.
                                Enough confusion, added DEBUG_PRINT.

*/

#ifndef _VXDPROCS_H_
#define _VXDPROCS_H_

//--------------------------------------------------------------------
//
//  Define some ndis stuff here because tdivxd.h needs it however we can't
//  include ndis3\inc\ndis.h because it conflicts with ntconfig.h and we
//  can't take out ntconfig.h because it has definitions needed by other
//  header files...grrrr....
//

#ifdef CHICAGO
#ifndef NDIS_STDCALL
#define NDIS_STDCALL    1
#endif
#include <vmm.h>
#undef PAGE
#define PAGE _PTEXT
#endif

#ifdef NDIS_STDCALL
#define NDIS_API __stdcall
#else
#define NDIS_API
#endif

//
// Ndis Buffer
//

#define BUFFER_POOL_SIGN  (UINT)0X4C50424E  /* NBPL */
#define BUFFER_SIGN       (UINT)0x4655424e  /* NBUF */

typedef INT NDIS_SPIN_LOCK, * PNDIS_SPIN_LOCK;

struct _NDIS_BUFFER;
typedef struct _NDIS_BUFFER_POOL {
    UINT Signature;                     //character signature for debug "NBPL"
    NDIS_SPIN_LOCK SpinLock;            //to serialize access to the buffer pool
    struct _NDIS_BUFFER *FreeList;      //linked list of free slots in pool
    UINT BufferLength;                  //amount needed for each buffer descriptor
    UCHAR Buffer[1];                    //actual pool memory
    } NDIS_BUFFER_POOL, * PNDIS_BUFFER_POOL;

#ifdef NDIS_STDCALL
typedef struct _NDIS_BUFFER {
    struct _NDIS_BUFFER *Next;          //pointer to next buffer descriptor in chain
    PVOID VirtualAddress;               //linear address of this buffer
    PNDIS_BUFFER_POOL Pool;             //pointer to pool so we can free to correct pool
    UINT Length;                        //length of this buffer
    UINT Signature;                     //character signature for debug "NBUF"
} NDIS_BUFFER, * PNDIS_BUFFER;

#else

typedef struct _NDIS_BUFFER {
    UINT Signature;                     //character signature for debug "NBUF"
    struct _NDIS_BUFFER *Next;          //pointer to next buffer descriptor in chain
    PVOID VirtualAddress;               //linear address of this buffer
    PNDIS_BUFFER_POOL Pool;             //pointer to pool so we can free to correct pool
    UINT Length;                        //length of this buffer
} NDIS_BUFFER, * PNDIS_BUFFER;
#endif

#define NDIS_STATUS_SUCCESS         0   // Used by CTEinitBlockStruc macro

//
// Possible data types
//

typedef enum _NDIS_PARAMETER_TYPE {
    NdisParameterInteger,
    NdisParameterHexInteger,
    NdisParameterString,
    NdisParameterMultiString
} NDIS_PARAMETER_TYPE, *PNDIS_PARAMETER_TYPE;

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PUCHAR Buffer;
} STRING, *PSTRING;

typedef STRING NDIS_STRING, *PNDIS_STRING;
typedef PVOID NDIS_HANDLE, *PNDIS_HANDLE;

//
// To store configuration information
//
typedef struct _NDIS_CONFIGURATION_PARAMETER {
    NDIS_PARAMETER_TYPE ParameterType;
    union {
    ULONG IntegerData;
    NDIS_STRING StringData;
    } ParameterData;
} NDIS_CONFIGURATION_PARAMETER, *PNDIS_CONFIGURATION_PARAMETER;

typedef ULONG NDIS_STATUS;
typedef NDIS_STATUS *PNDIS_STATUS;

VOID NDIS_API
NdisOpenProtocolConfiguration(
    OUT PNDIS_STATUS    Status,
    OUT PNDIS_HANDLE    ConfigurationHandle,
    IN  PNDIS_STRING    ProtocolName
    );

VOID NDIS_API
NdisReadConfiguration(
    OUT PNDIS_STATUS Status,
    OUT PNDIS_CONFIGURATION_PARAMETER *ParameterValue,
    IN NDIS_HANDLE ConfigurationHandle,
    IN PNDIS_STRING Parameter,
    IN NDIS_PARAMETER_TYPE ParameterType
    );

VOID NDIS_API
NdisCloseConfiguration(
    IN NDIS_HANDLE ConfigurationHandle
    );

//--------------------------------------------------------------------

#include <tdivxd.h>
#include <tdistat.h>

//--------------------------------------------------------------------
//
//  Initializes a TA_NETBIOS_ADDRESS structure
//
//     ptanb - Pointer to the TA_NETBIOS_ADDRESS
//     pName - Pointer to the netbios name this address structure represents
//
#define InitNBAddress( ptanb, pName )                                 \
{                                                                     \
    (ptanb)->TAAddressCount           = 1 ;                           \
    (ptanb)->Address[0].AddressLength = sizeof( TDI_ADDRESS_NETBIOS );\
    (ptanb)->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS ;    \
    (ptanb)->Address[0].Address[0].NetbiosNameType = 0 ;              \
    CTEMemCopy( (ptanb)->Address[0].Address[0].NetbiosName,           \
                pName,                                                \
                NCBNAMSZ ) ;                                          \
}

//
//  Initializes a TDI_CONNECTION_INFORMATION structure for Netbios
//
//      pConnInfo - Pointer to TDI_CONNECTION_INFORMATION structure
//      ptanb - same as for InitNBAddress
//      pName - same as for InitNBAddress
//
#define InitNBTDIConnectInfo( pConnInfo, ptanb, pName )               \
{                                                                     \
    InitNBAddress( ((PTA_NETBIOS_ADDRESS)ptanb), (pName) ) ;          \
    (pConnInfo)->RemoteAddressLength = sizeof( TA_NETBIOS_ADDRESS ) ; \
    (pConnInfo)->RemoteAddress       = (ptanb) ;                      \
}

//
//  Initializes an NDIS buffer (doesn't allocate memory)
//
//      pndisBuff - Pointer to NDIS buffer to initialize
//      pvData    - Pointer to buffer data
//      cbLen     - Length of user data (in bytes)
//      pndisBuffnext - Next NDIS buffer in chain (or NULL if last)
//
#define InitNDISBuff( pndisBuff, pvData, cbLen, pndisBuffNext )       \
{                                                                     \
    (pndisBuff)->Signature      = BUFFER_SIGN ;                       \
    (pndisBuff)->Next           = (pndisBuffNext) ;                   \
    (pndisBuff)->Length         = (cbLen) ;                           \
    (pndisBuff)->VirtualAddress = (pvData) ;                          \
    (pndisBuff)->Pool           = NULL ;                              \
}

//
//  Proper NCB error type
//
typedef uchar NCBERR ;

//
//  This is a private NCB command used for adding name number 0 to the
//  name table.  It is submitted directly by the Nbt driver during
//  initialization.  Note that if a client tries to submit an NCB with
//  this command we'll return illegal command.
//

#define NCBADD_PERMANENT_NAME       0xff

//
//  Last valid NCB session or name number
//

#define MAX_NCB_NUMS                254

//
//  When a send or receive tick count reaches this value, it's timed out
//

#define NCB_TIMED_OUT                 1

//
//  A timeout of this value means the NCB will never timeout
//

#define NCB_INFINITE_TIME_OUT         0

//--------------------------------------------------------------------
//
//  Receieve session data context, set in VxdReceive.
//  Allocated on the heap (too big for ncb_reserve).
//

#define RCVCONT_SIGN                    0x1900BEEF
typedef struct _RCV_CONTEXT
{
    union
    {
        LIST_ENTRY         ListEntry ;  // Used when NCB is put on RcvHead
        EventRcvBuffer     evrcvbuf ;   // Used for doing actual receive
                                        // (after removed from RcvHead)
    } ;
    UINT               Signature ;
    tLOWERCONNECTION * pLowerConnId ;   // Where data is arriving from
    NCB *              pNCB ;           // Pointer to NCB
    NDIS_BUFFER        ndisBuff ;       // Transport fills this buffer
    UCHAR              RTO ;            // 1/2 second ticks till timeout
    USHORT             usFlags;         // in case different from default
} RCV_CONTEXT, *PRCV_CONTEXT ;

//
//  Allocate, initialize and free a receive context structure
//

#define GetRcvContext( ppContext )                                        \
    (STATUS_SUCCESS == NbtGetBuffer( &NbtConfig.RcvContextFreeList,       \
                       (PLIST_ENTRY*)ppContext,                           \
                       eNBT_RCV_CONTEXT ))

#define FreeRcvContext( pRcvContext )                          \
{                                                              \
    ASSERT( (pRcvContext)->Signature == RCVCONT_SIGN ) ;       \
    InsertTailList( &NbtConfig.RcvContextFreeList,             \
                    &(pRcvContext)->ListEntry ) ;              \
}

#define InitRcvContext(  pRcvCont, pRcvLowerConn, pRcvNCB ) \
{                                                        \
    pRcvCont->Signature   = RCVCONT_SIGN ;               \
    pRcvCont->pLowerConnId= pRcvLowerConn ;              \
    pRcvCont->pNCB        = pRcvNCB ;                    \
}

//--------------------------------------------------------------------
//
//  Send session data context, set in VxdSend.
//  Stored in ncb_reserve
//
typedef struct _SEND_CONTEXT
{
    LIST_ENTRY         ListEntry ;      // Kept on timeout queue
    tSESSIONHDR      * pHdr ;           // Allocated session header
    UCHAR              STO ;            // 1/2 second ticks till timeout
} SEND_CONTEXT, *PSEND_CONTEXT ;


#define GetSessionHdr( ppHdr )                                            \
    (STATUS_SUCCESS == NbtGetBuffer( &NbtConfig.SessionBufferFreeList,    \
                                     (PLIST_ENTRY*)ppHdr,                 \
                                     eNBT_SESSION_HDR ))

#define FreeSessionHdr( pSessionHdr )                          \
{                                                              \
    InsertTailList( &NbtConfig.SessionBufferFreeList,          \
                    (PLIST_ENTRY) pSessionHdr ) ;              \
}

//--------------------------------------------------------------------
//
//  TDI Send context (used by TdiSend)
//
//  When handling the datagram completion routines, we need to set up
//  another completion routine.  We store the old completion routine
//  in this structure
//
typedef union _TDI_SEND_CONTEXT
{
    LIST_ENTRY     ListEntry ;         // Only used when on buffer free list

    struct
    {
        PVOID          NewContext ;
        NBT_COMPLETION OldRequestNotifyObject ;
        PVOID          OldContext ;
        NDIS_BUFFER    ndisHdr ;       // Generally NBT message
        NDIS_BUFFER    ndisData1 ;     // Data or SMB
        NDIS_BUFFER    ndisData2 ;     // Data if ndisData1 is an SMB
    } ;
} TDI_SEND_CONTEXT, * PTDI_SEND_CONTEXT ;

//
//  Allocates a TDI_SEND_CONTEXT
//
#define GetSendContext( ppContext )                                        \
    (STATUS_SUCCESS == NbtGetBuffer( &NbtConfig.SendContextFreeList,       \
                       (PLIST_ENTRY*)ppContext,                            \
                       eNBT_SEND_CONTEXT ))

//
//  Frees a send context structure and its allocated memory
//
#define FreeSendContext( psendCont )                           \
{                                                              \
    InsertTailList( &NbtConfig.SendContextFreeList,            \
                    &(psendCont)->ListEntry ) ;                \
}

//--------------------------------------------------------------------
//
//  Lana related stuff
//

#define NBT_MAX_LANAS     8

typedef struct
{
    tDEVICECONTEXT * pDeviceContext ;   // Adapter for this Lana
} LANA_ENTRY, *PLANA_ENTRY ;

extern LANA_ENTRY LanaTable[NBT_MAX_LANAS] ;

//--------------------------------------------------------------------
//
//  Procedures in ncb.c
//
//
NCBERR MapTDIStatus2NCBErr( TDI_STATUS status ) ;

//
//  Get the correct adapter for this NCBs Lana
//
tDEVICECONTEXT *
GetDeviceContext(
	NCB * pNCB
	);

BOOL
NbtWouldLoopback(
	ULONG	IpAddr
	);

extern BOOL fNCBCompleted ;    // Wait NCB completed before returning to submitter
extern BOOL fWaitingForNCB ;   // We are blocked waiting for a Wait NCB to complete
extern CTEBlockStruc WaitNCBBlock ;  // Wait on this until signaled in completion
extern UCHAR LanaBase ;

#define IPINFO_BUFF_SIZE  (sizeof(IPInfo) + MAX_IP_NETS * sizeof(NetInfo))

//--------------------------------------------------------------------
//
//  externs from fileio.c
//
extern PUCHAR  pFileBuff;
extern PUCHAR  pFilePath;

//--------------------------------------------------------------------
//
//  TDI Dispatch table (exported from vtdi.386)
//
extern TDIDispatchTable * TdiDispatch ;

//
//  Wrappers for interfacing to the TDI Dispatch table
//
#define TdiVxdOpenAddress           TdiDispatch->TdiOpenAddressEntry
#define TdiVxdCloseAddress          TdiDispatch->TdiCloseAddressEntry
#define TdiVxdOpenConnection        TdiDispatch->TdiOpenConnectionEntry
#define TdiVxdCloseConnection       TdiDispatch->TdiCloseConnectionEntry
#define TdiVxdAssociateAddress      TdiDispatch->TdiAssociateAddressEntry
#define TdiVxdDisAssociateAddress   TdiDispatch->TdiDisAssociateAddressEntry
#define TdiVxdConnect               TdiDispatch->TdiConnectEntry
#define TdiVxdDisconnect            TdiDispatch->TdiDisconnectEntry
#define TdiVxdListen                TdiDispatch->TdiListenEntry
#define TdiVxdAccept                TdiDispatch->TdiAcceptEntry
#define TdiVxdReceive               TdiDispatch->TdiReceiveEntry
#define TdiVxdSend                  TdiDispatch->TdiSendEntry
#define TdiVxdSendDatagram          TdiDispatch->TdiSendDatagramEntry
#define TdiVxdReceiveDatagram       TdiDispatch->TdiReceiveDatagramEntry
#define TdiVxdSetEventHandler       TdiDispatch->TdiSetEventEntry
#define TdiVxdQueryInformationEx    TdiDispatch->TdiQueryInformationExEntry
#define TdiVxdSetInformationEx      TdiDispatch->TdiSetInformationExEntry

//--------------------------------------------------------------------
//
//  NTSTATUS to TDI_STATUS mappings.
//
//  Rather then convert from NTSTATUS to TDI_STATUS (then sometimes back to
//  NTSTATUS) we'll just use TDI_STATUS codes everywhere (and map to NCBERR
//  when returning codes to the Netbios interface).
//
#undef STATUS_SUCCESS
#undef STATUS_INSUFFICIENT_RESOURCES
#undef STATUS_ADDRESS_ALREADY_EXISTS
#undef STATUS_TOO_MANY_ADDRESSES
#undef STATUS_INVALID_ADDRESS
#undef STATUS_BUFFER_OVERFLOW
#undef STATUS_TRANSACTION_INVALID_TYPE
#undef STATUS_TRANSACTION_INVALID_ID
#undef STATUS_EVENT_DONE
#undef STATUS_TRANSACTION_TIMED_OUT
#undef STATUS_EVENT_PENDING
#undef STATUS_PENDING
#undef STATUS_BAD_NETWORK_NAME
#undef STATUS_REQUEST_NOT_ACCEPTED
#undef STATUS_INVALID_CONNECTION
#undef STATUS_DATA_NOT_ACCEPTED
#undef STATUS_MORE_PROCESSING_REQUIRED
#undef STATUS_IO_TIMEOUT
#undef STATUS_TIMEOUT
#undef STATUS_GRACEFUL_DISCONNECT
#undef STATUS_CONNECTION_RESET

#define STATUS_SUCCESS                    TDI_SUCCESS
//#define STATUS_UNSUCCESSFUL
#define STATUS_MORE_PROCESSING_REQUIRED   TDI_MORE_PROCESSING
#define STATUS_BAD_NETWORK_NAME           TDI_INVALID_CONNECTION
#define STATUS_DATA_NOT_ACCEPTED          TDI_NOT_ACCEPTED
//#define STATUS_REMOTE_NOT_LISTENING
//#define STATUS_DUPLICATE_NAME
//#define STATUS_INVALID_PARAMETER
//#define STATUS_OBJECT_NAME_COLLISION    Duplicate Name
//#define STATUS_SHARING_VIOLATION        Duplicate Name
#define STATUS_CONNECTION_INVALID         TDI_INVALID_CONNECTION
#define STATUS_INVALID_CONNECTION         TDI_INVALID_CONNECTION
#define STATUS_INSUFFICIENT_RESOURCES     TDI_NO_RESOURCES
#define STATUS_ADDRESS_ALREADY_EXISTS     TDI_ADDR_IN_USE
#define STATUS_TOO_MANY_ADDRESSES         TDI_NO_FREE_ADDR
#define STATUS_INVALID_ADDRESS            TDI_ADDR_INVALID
#define STATUS_BUFFER_OVERFLOW            TDI_BUFFER_OVERFLOW
#define STATUS_TRANSACTION_INVALID_TYPE   TDI_BAD_EVENT_TYPE
#define STATUS_TRANSACTION_INVALID_ID     TDI_BAD_OPTION     // ??
#define STATUS_EVENT_DONE                 TDI_EVENT_DONE
#define STATUS_TRANSACTION_TIMED_OUT      TDI_TIMED_OUT
#define STATUS_IO_TIMEOUT                 TDI_TIMED_OUT
#define STATUS_TIMEOUT                    TDI_TIMED_OUT
#define STATUS_EVENT_PENDING              TDI_PENDING
#define STATUS_PENDING                    TDI_PENDING
#define STATUS_GRACEFUL_DISCONNECT        TDI_GRACEFUL_DISC
#define STATUS_CONNECTION_RESET           TDI_CONNECTION_RESET
#define STATUS_INVALID_ADDRESS_COMPONENT  TDI_BAD_ADDR

//
//  This is the "Name deregistered but not deleted because of
//  active sessions" error code.
//
#define STATUS_NRC_ACTSES                 0xCA000001

//
//  The NT_SUCCESS macro looks at the high bytes of the errr code which isn't
//  appropriate for our mapping to TDI_STATUS error codes
//
#undef NT_SUCCESS
#define NT_SUCCESS(err)   ((err==TDI_SUCCESS)||(err==TDI_PENDING))

//--------------------------------------------------------------------
//
//  General porting macros
//
//
//--------------------------------------------------------------------

//
//  Note that the ExInterlocked* routines (in ntos\ex\i386) do a spinlock
//  for MP machines.  Since we aren't MP we shouldn't need the spin lock.
//  We shouldn't need to disable interrupts either.
//

#define ExInterlockedInsertTailList(list, entry, spinlock )     \
            InsertTailList( (list), (entry) )

#define ExInterlockedInsertHeadList(list, entry, spinlock )     \
            InsertHeadList( (list), (entry) )

//
//  These two definitions must be kept keep a couple of NT macros use
//  the ExInterlocked* macros
//

#ifdef InterlockedIncrement
#undef InterlockedIncrement
#endif

#ifdef InterlockedIncrementLong
#undef InterlockedIncrementLong
#endif

#define InterlockedIncrement(n)                  \
            CTEInterlockedIncrementLong( n )
#define InterlockedIncrementLong InterlockedIncrement

#ifdef InterlockedDecrement
#undef InterlockedDecrement
#endif

#ifdef InterlockedDecrementLong
#undef InterlockedDecrementLong
#endif

#define InterlockedDecrement(n)                  \
            CTEInterlockedDecrementLong( n )
#define InterlockedDecrementLong InterlockedDecrement

//--------------------------------------------------------------------
//
//  Debug helper macros
//

#undef  ASSERT
#undef  ASSERTMSG

#ifdef DEBUG
    #include <vxddebug.h>
#endif



#ifdef DBG_PRINT
//
//  Debug output Definitions and functions
//

    #define DBGFLAG_ERROR           (0x00000001)
    #define DBGFLAG_REG             (0x00000002)     // Informative Printouts
    #define DBGFLAG_ALL             (0x00000004)     // Everything else
    #define DBGFLAG_LMHOST          (0x00000008)
    #define DBGFLAG_KDPRINTS        (0x00000010)     // Jim's KdPrint output
    #define DBGFLAG_AUX_OUTPUT      (0x00000020)


    extern DWORD NbtDebug ;
    extern char  DBOut[4096] ;
    extern char  szOutput[1024];
    extern int   iCurPos ;
    extern BYTE  abVecTbl[256];

    void VxdPrintf                  ( char * pszFormat, ... );
    int  VxdSprintf                 ( char * pszStr, char * pszFmt, ... );
    void VxdDebugOutput             ( char * pszMessage );
    void NbtPrintDebug              ( char * ) ;

// ========================================================================

    #define VXD_PRINT(args)                     \
        if ( NbtDebug & DBGFLAG_REG )           \
            VxdPrintf args

    #define DEBUG_OUTPUT(x)                     \
        if ( NbtDebug & DBGFLAG_REG )           \
            VxdDebugOutput(x)

#undef KdPrint
#define KdPrint( s )                            \
   if ( NbtDebug & DBGFLAG_KDPRINTS )           \
   {                                            \
       VxdPrintf s ;                            \
   }else{}

// eg. DEBUG_PRINT(("Error %d, retry.\n", err ));
    #define DEBUG_PRINT( S )                    \
        if ( NbtDebug & DBGFLAG_REG )           \
            VxdPrintf S

// eg. PRINT_IPADDR( "Cannot find:", htonl(ipaddress) );
#define PRINT_IPADDR( S, IP )                   \
        if ( NbtDebug & DBGFLAG_REG )           \
            VxdPrintf( S "%d.%d.%d.%d\n",       \
                (IP>>0)&0xff,(IP>>8)&0xff,(IP>>16)&0xff,(IP>>24)&0xff )

// ========================================================================

#define DbgPrint( s )                           \
   if ( NbtDebug & DBGFLAG_ALL )                \
   {                                            \
      VxdSprintf( szOutput, s ) ;               \
      VxdCopyToDBOut() ;                        \
      NbtPrintDebug( DBOut+iCurPos ) ;          \
   }else{}

#define DbgPrintNum( n )                        \
   if ( NbtDebug & DBGFLAG_ALL )                \
   {                                            \
      VxdSprintf( szOutput, "%d", n ) ;         \
      VxdCopyToDBOut() ;                        \
      NbtPrintDebug( DBOut+iCurPos ) ;          \
   }else{}

// ========================================================================
//  Conditional print routines
//

#define CDbgPrint( flag, s )                    \
   if ( NbtDebug & (flag) )                     \
   {                                            \
      VxdSprintf( szOutput, s );                \
      VxdCopyToDBOut() ;                        \
      NbtPrintDebug( DBOut+iCurPos ) ;          \
   }else{}

#define CDbgPrintNum( flag, n )                 \
   if ( NbtDebug & (flag) )                     \
   {                                            \
      VxdSprintf( szOutput, "%d", n ) ;         \
      VxdCopyToDBOut() ;                        \
      NbtPrintDebug( DBOut+iCurPos ) ;          \
   }else{}

    extern void NbtCTEPrint( char * );

#else
    //
    //  No debug output.
    //

    #define IF_DEBUG(flag)                          if(0)
    #define VXD_PRINT(args)                     /* Nothing */
    #define DEBUG_OUTPUT(x)                     /* Nothing */

    #undef  KdPrint
    #define KdPrint( s )                        /* Nothing */

    #define DEBUG_PRINT( S )                    /* Nothing */
    #define PRINT_IPADDR( S, IP )               /* Nothing */

    #define DbgPrint( s )                       /* Nothing */
    #define DbgPrintNum( n )                    /* Nothing */
    #define CDbgPrint( flag, s )                /* Nothing */
    #define CDbgPrintNum( flag, n )             /* Nothing */

    #define NbtCTEPrint( s )                    /* Nothing */
#endif


#ifdef DEBUG

// ========================================================================

    #define DbgBreak()             _asm int 3
    #define ASSERT( exp )          VXD_ASSERT( exp )

    #define ASSERTMSG( msg, exp )  VXD_ASSERT( exp )

    //
    //  REQUIRE is an ASSERT that keeps the expression under non-debug
    //  builds
    //

    #define REQUIRE( exp )         ASSERT( exp )

#ifdef DBG_PRINT
    //
    //  Consistency checks of the interrupt vector table to help watch
    //  for NULL pointer writes
    //
    #define INIT_NULL_PTR_CHECK()  memcpy( abVecTbl, 0, sizeof( abVecTbl ))

    #define CHECK_MEM() if(sizeof(abVecTbl)                             \
       != VxdRtlCompareMemory( 0, abVecTbl, sizeof(abVecTbl))){         \
    DEBUG_PRINT(("Vector table corrupt at %d\n",                        \
                 VxdRtlCompareMemory( 0, abVecTbl, sizeof(abVecTbl) )));\
    _asm int 3                                                          \
    }else{}                                                             \
    CTECheckMem(__FILE__) ;
#else
    #define INIT_NULL_PTR_CHECK()   /* Nothing */
    #define CHECK_MEM()             /* Nothing */
#endif  // DBG_PRINT

#else

    #define DbgBreak()              /* Nothing */

    #define ASSERT( exp )           { ; }
    #define ASSERTMSG( msg, exp )   { ; }
    #define REQUIRE( exp )          { exp ; }

    #define INIT_NULL_PTR_CHECK()   /* Nothing */
    #define CHECK_MEM()             /* Nothing */
#endif

//---------------------------------------------------------------------
//
// FROM tdihndlr.c
//
TDI_STATUS
TdiReceiveHandler (
    IN PVOID ReceiveEventContext,
    IN PVOID ConnectionContext,
    IN USHORT ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT PULONG BytesTaken,
    IN PVOID Data,
    EventRcvBuffer * pevrcvbuf
    );

TDI_STATUS
ReceiveAnyHandler (                     //  Handles NCBRCVANY commands, is
    IN PVOID ReceiveEventContext,       //  called after all other receive
    IN PVOID ConnectionContext,         //  handlers
    IN USHORT ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT PULONG BytesTaken,
    IN PVOID Data,
    PVOID * ppBuffer                    // Pointer to ListEntry of RCV_CONTEXT
    ) ;

TDI_STATUS
VxdDisconnectHandler (                  //  Cleans up Netbios stuff for remote
    IN PVOID DisconnectEventContext,    //  disconnects
    IN PVOID ConnectionContext,
    IN PVOID DisconnectData,
    IN ULONG DisconnectInformationLength,
    IN PVOID pDisconnectInformation,
    IN ULONG DisconnectIndicators
    ) ;

VOID
CompletionRcv(
    IN PVOID pContext,
    IN uint tdistatus,
    IN uint BytesRcvd
    );

TDI_STATUS
TdiConnectHandler (
    IN PVOID    pConnectEventContext,
    IN int      RemoteAddressLength,
    IN PVOID    pRemoteAddress,
    IN int      UserDataLength,
    IN PVOID    pUserData,
    IN int      OptionsLength,
    IN PVOID    pOptions,
    IN PVOID  * pAcceptingID,
    IN ConnectEventInfo * pEventInfo
    );

TDI_STATUS
TdiDisconnectHandler (
    PVOID EventContext,
    PVOID ConnectionContext,
    ULONG DisconnectDataLength,
    PVOID DisconnectData,
    ULONG DisconnectInformationLength,
    PVOID DisconnectInformation,
    ULONG DisconnectIndicators      // Is this the Flags field?
    );

TDI_STATUS
TdiRcvDatagramHandler(
    IN PVOID    pDgramEventContext,
    IN int      SourceAddressLength,
    IN PVOID    pSourceAddress,
    IN int      OptionsLength,
    IN PVOID    pOptions,
    IN UINT     ReceiveDatagramFlags,
    IN ULONG    BytesIndicated,
    IN ULONG    BytesAvailable,
    OUT ULONG   *pBytesTaken,
    IN PVOID    pTsdu,
    OUT EventRcvBuffer * * ppBuffer //OUT PIRP    *pIoRequestPacket
    );
TDI_STATUS
TdiRcvNameSrvHandler(
    IN PVOID    pDgramEventContext,
    IN int      SourceAddressLength,
    IN PVOID    pSourceAddress,
    IN int      OptionsLength,
    IN PVOID    pOptions,
    IN UINT     ReceiveDatagramFlags,
    IN ULONG    BytesIndicated,
    IN ULONG    BytesAvailable,
    OUT ULONG   *pBytesTaken,
    IN PVOID    pTsdu,
    OUT EventRcvBuffer * * ppBuffer //OUT PIRP    *pIoRequestPacket
    );
TDI_STATUS
TdiErrorHandler (
    IN PVOID Context,
    IN ULONG Status
    );

VOID
CompletionRcvDgram(
    IN PVOID      Context,
    IN UINT       tdistatus,
    IN UINT       RcvdSize
    ) ;

//---------------------------------------------------------------------
//
// FROM init.c
//

PVOID
CTEAllocInitMem(
    IN ULONG cbBuff ) ;

NTSTATUS
VxdReadIniString(
    IN      LPTSTR   pchKeyName,
    IN OUT  LPTSTR * ppStringBuff
    ) ;

NTSTATUS CreateDeviceObject(
    IN  tNBTCONFIG  *pConfig,
    IN  ULONG        IpAddr,
    IN  ULONG        IpMask,
#ifdef MULTIPLE_WINS
    IN  PULONG       pIpNameServers,
#else
    IN  ULONG        IpNameServer,
    IN  ULONG        IpBackupServer,
#endif
    IN  ULONG        IpDnsServer,
    IN  ULONG        IpDnsBackupServer,
    IN  UCHAR        MacAddr[],
    IN  UCHAR        IpIndex
    ) ;

void GetNameServerAddress( ULONG   IpAddr,
#ifdef WINS_PER_ADAPTER
                           PULONG  pIpNameServer,
                           PNDIS_STRING AdapterName);
#else
                           PULONG  pIpNameServer);
#endif  // WINS_PER_ADAPTER

void GetDnsServerAddress( ULONG   IpAddr,
                          PULONG  pIpNameServer);

#ifdef MULTIPLE_WINS
#define COUNT_NS_ADDR     2+MAX_NUM_OTHER_NAME_SERVERS  // Maximum number of name server addresses
#else
#define COUNT_NS_ADDR     4   // Maximum number of name server addresses
#endif
//---------------------------------------------------------------------
//
// FROM vxdfile.asm
//

HANDLE
VxdFileOpen(
    IN char * pchFile ) ;

ULONG
VxdFileRead(
    IN HANDLE hFile,
    IN ULONG  BytesToRead,
    IN BYTE * pBuff ) ;

VOID
VxdFileClose(
    IN HANDLE hFile ) ;

PUCHAR
VxdWindowsPath(
    );

//---------------------------------------------------------------------
//
// FROM vnbtd.asm
//

ULONG
GetProfileHex(
    IN HANDLE ParametersHandle,     // Not used
    IN PCHAR ValueName,
    IN ULONG DefaultValue,
    IN ULONG MinimumValue
    );

ULONG
GetProfileInt(
    IN HANDLE ParametersHandle,     // Not used
    IN PCHAR ValueName,
    IN ULONG DefaultValue,
    IN ULONG MinimumValue
    );

TDI_STATUS DhcpQueryInfo( UINT Type, PVOID pBuff, UINT * pSize ) ;

//---------------------------------------------------------------------
//
// FROM tdiout.c
//
NTSTATUS VxdDisconnectWait( tLOWERCONNECTION * pLowerConn,
                            tDEVICECONTEXT   * pDeviceContext,
                            ULONG              Flags,
                            PVOID              Timeout) ;

NTSTATUS VxdScheduleDelayedCall( tDGRAM_SEND_TRACKING * pTracker,
                                 PVOID                  pClientContext,
                                 PVOID                  ClientCompletion,
                                 PVOID                  CallBackRoutine,
                                 tDEVICECONTEXT        *pDeviceContext,
                                 BOOLEAN                CallbackInCriticalSection );

//---------------------------------------------------------------------
//
// FROM timer.c
//
BOOL CheckForTimedoutNCBs( CTEEvent *pEvent, PVOID pCont ) ;
VOID StopTimeoutTimer( VOID );
NTSTATUS StartRefreshTimer( VOID );

//---------------------------------------------------------------------
//
// FROM tdicnct.c
//
NTSTATUS CloseAddress( HANDLE hAddress ) ;


//---------------------------------------------------------------------
//
// FROM wfw.c - Snowball specific routines
//
#ifndef CHICAGO

BOOL GetActiveLanasFromIP( VOID );

#endif //!CHICAGO


//---------------------------------------------------------------------
//
// FROM chic.c - Chicago specific routines
//
#ifdef CHICAGO

NTSTATUS DestroyDeviceObject(
    tNBTCONFIG  *pConfig,
    ULONG        IpAddr
    );

BOOL IPRegisterAddrChangeHandler( PVOID AddChangeHandler, BOOL );

TDI_STATUS IPNotification( ULONG    IpAddress,
                           ULONG    IpMask,
                           PVOID    pDevNode,
                           USHORT   IPContext,
#ifdef WINS_PER_ADAPTER
                           BOOL     fNew,
                           PNDIS_STRING AdapterName);
#else
                           BOOL     fNew);
#endif  // WINS_PER_ADAPTER

BOOL VxdInitLmHostsSupport( PUCHAR pchLmHostPath, USHORT ulPathSize );

VOID SaveNameDnsServerAddrs( VOID );
BOOL VxdOpenNdis( VOID );
VOID VxdCloseNdis( VOID );


VOID ReleaseNbtConfigMem( VOID );

NTSTATUS VxdUnload( LPSTR pchModuleName );

#endif //CHICAGO

//--------------------------------------------------------------------
//
//  Procedures in vxdisol.c
//
//
NCBERR   VxdOpenName( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdCloseName( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdCall( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdListen( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdDgramSend( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdDgramReceive( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdReceiveAny( tDEVICECONTEXT  *pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdReceive( tDEVICECONTEXT  * pDeviceContext, NCB * pNCB, BOOL fReceive ) ;
NCBERR   VxdHangup( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdCancel( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
NCBERR   VxdSend( tDEVICECONTEXT  * pDeviceContext, NCB * pNCB   ) ;
NCBERR   VxdSessionStatus( tDEVICECONTEXT * pDeviceContext, NCB * pNCB ) ;
VOID     DelayedSessEstablish( PVOID pContext );


//--------------------------------------------------------------------
//
//  Procedures in dns.c
//
//
PCHAR
DnsStoreName(
    OUT PCHAR            pDest,
    IN  PCHAR            pName,
    IN  PCHAR            pDomainName,
    IN  enum eNSTYPE     eNsType
    );

VOID
DnsExtractName(
    IN  PCHAR            pNameHdr,
    IN  LONG             NumBytes,
    OUT PCHAR            pName,
    OUT PULONG           pNameSize
    );

VOID
ProcessDnsResponse(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags
    );

VOID
DnsCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

//
// These routines all have "Direct" at the end of the routine name
// because they are used exclusively for name queries to the DNS
// server to resolve DNS names and not NetBIOS names.
//

VOID
ProcessDnsResponseDirect(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags
    );

ULONG
DoDnsResolveDirect(
        PNCB pncb,
        PUCHAR pzDnsName,
        PULONG pIpAddressList
	);

BOOL
DoDnsCancelDirect(
        PNCB pncb
	);

VOID
DnsCompletionDirect(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

PDNS_DIRECT_WORK_ITEM_CONTEXT
FindContextDirect(
	USHORT	TransactionId
	);

VOID
DnsActualCompletionDirect(
    IN NBT_WORK_ITEM_CONTEXT * pnbtContext
    );

VOID
DnsUnlinkAndCompleteDirect(
    IN PDNS_DIRECT_WORK_ITEM_CONTEXT pContext
    );

NTSTATUS
UdpSendDNSBcastDirect(
	IN	PDNS_DIRECT_WORK_ITEM_CONTEXT	pContext,
	IN	ULONG							Retries,
	IN	ULONG							Timeout
	);

VOID
SendDNSBcastDoneDirect(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo
    );

PDNS_DIRECT_SEND_CONTEXT
CreateSendContextDirect(
    IN  PCHAR       pName,
    IN  PCHAR       pchDomainName,
    OUT PVOID       *pHdrs,
    OUT PULONG      pLength,
    IN  PDNS_DIRECT_WORK_ITEM_CONTEXT	pContext
    );

VOID
IpToAscii(
	IN	DWORD		IpAddress,
	IN OUT PCHAR	pzAscii
	);

//
//  Flag passed to TdiSend indicating we are dealing with a chain send
//  and not a normal send.
//
#define CHAIN_SEND_FLAG     0x80
typedef struct _tBUFFERCHAINSEND
{
    tBUFFER tBuff ;     // Must be first member of this structure!!
    PVOID   pBuffer2 ;
    ULONG   Length2 ;
} tBUFFERCHAINSEND ;


//
//  Flag for pConnectEle->Flags indicating whether the client has been
//  notified the session is dead (by completing an NCB with NRC_SCLOSED)
//
#define   NB_CLIENT_NOTIFIED    0x01


//
//  Translates the name number/logical session number to the appropriate
//  structure pointer
//
NCBERR   VxdFindClientElement( tDEVICECONTEXT * pDeviceContext,
                               UCHAR            ncbnum,
                               tCLIENTELE   * * ppClientEle,
                               enum CLIENT_TYPE Type ) ;
NCBERR   VxdFindConnectElement( tDEVICECONTEXT * pDeviceContext,
                                NCB            * pNCB,
                                tCONNECTELE  * * ppConnectEle ) ;
NCBERR   VxdFindLSN( tDEVICECONTEXT * pDeviceContext,
                     tCONNECTELE    * pConnectEle,
                     UCHAR          * plsn ) ;
NCBERR   VxdFindNameNum( tDEVICECONTEXT * pDeviceContext,
                         tADDRESSELE    * pAddressEle,
                         UCHAR          * pNum ) ;
//
//  Used by Register/Unregister for selecting either the name table or the
//  session table from the device context
//
typedef enum
{
    NB_NAME,
    NB_SESSION
} NB_TABLE_TYPE ;

BOOL NBRegister( tDEVICECONTEXT * pDeviceContext,
                 UCHAR          * pNCBNum,
                 PVOID            pElem,
                 NB_TABLE_TYPE    NbTable ) ;
BOOL NBUnregister( tDEVICECONTEXT * pDeviceContext,
                   UCHAR            NCBNum,
                   NB_TABLE_TYPE    NbTable ) ;

TDI_STATUS VxdCompleteSessionNcbs( tDEVICECONTEXT * pDeviceContext,
                                   tCONNECTELE    * pConnEle ) ;

NCBERR VxdCleanupAddress( tDEVICECONTEXT * pDeviceContext,
                          NCB            * pNCB,
                          tCLIENTELE     * pClientEle,
                          UCHAR            NameNum,
                          BOOL             fDeleteAddress ) ;

BOOL ActiveSessions( tCLIENTELE * pClientEle ) ;

//
//  This structure holds context information while we are waiting for
//  a session setup to complete (either listen or call)
//
//  It is stored in the ncb_reserve field of the NCB
//
typedef struct _SESS_SETUP_CONTEXT
{
    TDI_CONNECTION_INFORMATION * pRequestConnect ;  //
    TDI_CONNECTION_INFORMATION * pReturnConnect ;   // Name who answered the listen
    tCONNECTELE                * pConnEle ;
    UCHAR                        fIsWorldListen ;   // Listenning for '*'?
} SESS_SETUP_CONTEXT, *PSESS_SETUP_CONTEXT ;


void VxdTearDownSession( tDEVICECONTEXT      * pDevCont,
                         tCONNECTELE         * pConnEle,
                         PSESS_SETUP_CONTEXT   pCont,
                         NCB                 * pNCB ) ;

//
//  Finishes off a Netbios request (fill in NCB fields, call the post
//  routine etc.).  Is macroed as CTEIoComplete.
//

VOID
VxdIoComplete(
    PCTE_IRP pirp,
    NTSTATUS status,
    ULONG cbExtra
);

ULONG
_stdcall
VNBT_NCB_X(
    PNCB pNCB,
    PUCHAR pzDnsName,
    PULONG pIpAddress,
    PVOID pExtended,
    ULONG fFlag
);

ULONG
_stdcall
VNBT_LANA_MASK();

#endif //_VXDPROCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\nbtstat\makefile.inc ===
$(O)\nlstxt.mc: ..\..\tcpip\commands\common\common.mc localmsg.mc
    copy /a ..\..\tcpip\commands\common\common.mc+localmsg.mc $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\lmhosts\lmhsvc.c ===
/*++

Copyright (c) 1992,1993  Microsoft Corporation

Module Name:

    lmhsvc.c

Abstract:

    This module implements the LmHosts Service, which is part of the LmSvc
    process.

    One purpose of the LmHosts Service is to send down a NBT_RESYNC
    ioctl command to netbt.sys, after the LanmanWorkstation service has been
    started.  To accomplish this, the NT Registry is primed so that the
    LmHosts service is dependent on the LanmanWorkStation service.

    This service also handle name query requests from netbt destined for
    DNS by way of gethostbyname.


Author:

    Jim Stewart                           November 18 22, 1993

Revision History:

    ArnoldM   14-May-1996      Use winsock2 name resolution
                               instead of gethostbyname



Notes:

--*/


//
// Standard NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// C Runtime Library Headers
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
//
// Transport Specific Header Files
//
#include <nbtioctl.h>

//
// Standard Windows Headers
//
#include <windows.h>

#include <tdi.h>

//
// LAN Manager Headers
//
#include <lm.h>
#include <netlib.h>
#include <netevent.h>

//
// Sockets Headers
//
#include <winsock2.h>
#include <svcguid.h>
#include <wsahelp.h>
#ifdef NEWSMB
    #include "..\smb\inc\svclib.h"
#endif

#include "../inc/debug.h"

#include "lmhsvc.tmh"

//
// Private Definitions
//
#define NBT_DEVICE	"\\Device\\Streams\\Nbt"
#define WSA_QUERY_BUFFER_LENGTH (3*1024)
BYTE    pWSABuffer[WSA_QUERY_BUFFER_LENGTH];

//
// We currently have two threads; one for DNS names, the other for checking IP addresses
// for reachability.
//
#define NUM_THREADS 2

//
// Function Prototypes
//
VOID
announceStatus (
    IN LPSERVICE_STATUS svcstatus
    );

DWORD
SmbsvcUpdateStatus(
    VOID
    );

VOID
lmhostsHandler (
    IN DWORD opcode
    );

VOID
lmhostsSvc (
    IN DWORD argc,
    IN LPTSTR *argv
    );

VOID
DeinitData(
    VOID
    );

NTSTATUS
InitData (
    VOID
    );

LONG
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN ULONG            i
    );

LONG
PrimeCacheNbt(
    OUT PHANDLE     pHandle,
    IN  ULONG       index
    );

NTSTATUS
Resync(
    IN HANDLE   fd
    );

NTSTATUS
OpenNbt(
    IN  WCHAR  *path[],
    OUT PHANDLE pHandle
    );

LONG
GetHostName(
    IN HANDLE               fd,
    IN tIPADDR_BUFFER_DNS   *pIpAddrBuffer
    );

LONG
PostForGetHostByName(
    IN HANDLE           fd
    );

VOID
CheckIPAddrWorkerRtn(
    IN  LPVOID  lpUnused
    );

LONG
CheckIPAddresses(
    IN tIPADDR_BUFFER_DNS   *pIpAddrBuffer,
    IN ULONG   *IpAddr,
    IN BOOLEAN  fOrdered
    );

//
// Global Variables
//
PUCHAR                EventSource = "LmHostsService";

HANDLE                Poison[NUM_THREADS];                       // set to kill this service
HANDLE                NbtEvent[NUM_THREADS];                     // set when Nbt returns the Irp
SERVICE_STATUS_HANDLE SvcHandle = NULL;
SERVICE_STATUS        SvcStatus;
BOOLEAN               Trace = FALSE;                // TRUE for debugging
tIPADDR_BUFFER_DNS    gIpAddrBuffer = { 0 };
tIPADDR_BUFFER_DNS    gIpAddrBufferChkIP = { 0 };
BOOLEAN               SocketsUp = FALSE;

#if DBG
#define DBG_PRINT   DbgPrint
#else
#define DBG_PRINT
#endif  // DBG

#if DBG
BOOLEAN
EnableDebug()
{
    DWORD   dwError;
    HKEY    Key;
    LPWSTR  KeyName = L"system\\currentcontrolset\\services\\Lmhosts\\Parameters";
    LPWSTR  ValueName = L"EnableDebug";
    DWORD   dwData, cbData, dwType;

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 KeyName,
                 0,
                 KEY_READ,
                 &Key);

    if (dwError != ERROR_SUCCESS) {
        DbgPrint("Fail to open registry key %ws, error=%d\n", KeyName, dwError);
        return FALSE;
    }

    dwType = REG_DWORD;
    cbData = sizeof(dwData);
    dwError = RegQueryValueEx(
            Key,
            ValueName,
            NULL,
            &dwType,
            (PVOID)&dwData,
            &cbData
            );
    RegCloseKey(Key);
    Key = NULL;

    if (dwError != ERROR_SUCCESS) {
        DbgPrint("Fail to read %ws\\%ws, error=%d\n", KeyName, ValueName, dwError);
        return FALSE;
    }

    if (dwType != REG_DWORD) {
        DbgPrint("%ws\\%ws is not typed as REG_DWORD\n", KeyName, ValueName);
        return FALSE;
    }

    DbgPrint("%ws\\%ws (REG_DWORD) = 0x%08lx\n", KeyName, ValueName, dwData);
    return (dwData != 0);
}
#endif

//------------------------------------------------------------------------
VOID
ServiceMain (
    IN DWORD argc,
    IN LPTSTR *argv
    )

/*++

Routine Description:

    This is the SERVICE_MAIN_FUNCTION.

Arguments:

    argc, argv

Return Value:

    None.

--*/

{
    DWORD   status = 0;
    HANDLE  hNbt = NULL;
    HANDLE  EventList[2];
    ULONG   EventCount = 0;
    LONG    err = 0;
    WSADATA WsaData;
    HANDLE  hThread = NULL;
    ULONG   i;

    LARGE_INTEGER Timeout = RtlEnlargedIntegerMultiply (-10 * 60, 1000 * 1000 * 10); // 10 minutes

    NbtTrace(NBT_TRACE_DNS, ("Service Start"));
    if (SvcStatus.dwCurrentState != 0 && SvcStatus.dwCurrentState != SERVICE_STOPPED) {
        return;
    }

#if DBG
    Trace = EnableDebug();
#endif

    if (Trace)
    {
        DbgPrint("LMHSVC: calling RegisterServiceCtrlHandler()\n");
    }

    SvcHandle = RegisterServiceCtrlHandler(SERVICE_LMHOSTS,    // ServiceName
                                           lmhostsHandler);    // HandlerProc

    if (SvcHandle == (SERVICE_STATUS_HANDLE) 0)
    {
        DBG_PRINT ("LMHSVC: RegisterServiceCtrlHandler failed %d\n", GetLastError());
        return;
    }

    gIpAddrBuffer.Resolved = FALSE;
    gIpAddrBuffer.IpAddrsList[0] = 0;
    gIpAddrBufferChkIP.Resolved = FALSE;
    gIpAddrBufferChkIP.IpAddrsList[0] = 0;

    SvcStatus.dwServiceType             = SERVICE_WIN32;
    SvcStatus.dwCurrentState            = SERVICE_START_PENDING;
    SvcStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP;
    SvcStatus.dwWin32ExitCode           = 0;
    SvcStatus.dwServiceSpecificExitCode = 0;
    SvcStatus.dwCheckPoint              = 0;
    SvcStatus.dwWaitHint                = 20000;         // 20 seconds

    SET_SERVICE_EXITCODE(NO_ERROR,                                // SomeApiStatus
                         SvcStatus.dwWin32ExitCode,               // Win32CodeVariable
                         SvcStatus.dwServiceSpecificExitCode);    // NetCodeVariable

    announceStatus(&SvcStatus);

    if (!SocketsUp) {
        //
        // startup the sockets interface
        //
        err = WSAStartup( 0x0101, &WsaData );
        if ( err == SOCKET_ERROR ) {
            SocketsUp = FALSE;
        } else {
            SocketsUp = TRUE;
        }
    }

#ifdef NEWSMB
#if DBG
    SmbSetTraceRoutine(Trace? DbgPrint: NULL);
#endif
#endif

    if (Trace)
    {
        DbgPrint("LMHSVC: CreateThread attempting...\n");
    }

    hThread = CreateThread (NULL,                   // lpThreadAttributes
                            0,                      // dwStackSize
                            (LPTHREAD_START_ROUTINE) CheckIPAddrWorkerRtn,  // lpStartAddress
                            NULL,                           //  lpParameter
                            0,                              //  dwCreationFlags
                            NULL                            //  lpThreadId
                            );

    if (hThread == NULL)
    {
        DBG_PRINT ("LMHSVC: CreateThread failed %d\n", GetLastError());
        goto cleanup;
    }


#ifdef NEWSMB
    err = SmbStartService(0, SmbsvcUpdateStatus);
#endif

    SvcStatus.dwCurrentState = SERVICE_RUNNING;
    SvcStatus.dwCheckPoint   = 0;
    SvcStatus.dwWaitHint     = 0;
    announceStatus(&SvcStatus);

    //
    // ignore the return code from resyncNbt().
    //
    // In most cases (no domains spanning an ip router), it is not a
    // catastrophe if nbt.sys couldn't successfully process the NBT_RESYNC
    // ioctl command.  Since I'm ignoring the return, I announce I'm running
    // before I call it to allow other dependent services to start.
    //
    //
    status = PrimeCacheNbt(&hNbt, 0);

    if (Trace)
    {
        DbgPrint("LMHSVC: Thread 0, hNbt %lx\n", hNbt);
    }

    if (hNbt != (HANDLE)-1)
    {
        status = PostForGetHostByName(hNbt);
        if (status == NO_ERROR)
        {
            EventCount = 2;
        }
        else
        {
            if (Trace)
            {
                DbgPrint("Lmhsvc: Error posting Irp for get host by name\n");
            }
            EventCount = 1;
        }
    }
    else
    {
        EventCount = 1;
    }
    //
    // "A SERVICE_MAIN_FUNCTION does not return until the service is ready
    // to terminate."
    //
    // (ref: api32wh.hlp, SERVICE_MAIN_FUNCTION)
    //
    //
    ASSERT(Poison[0]);
    EventList[0] = Poison[0];
    EventList[1] = NbtEvent[0];

    while (TRUE)
    {
        status = NtWaitForMultipleObjects(EventCount,
                                          EventList,
                                          WaitAny,              // wait for any event
                                          FALSE,
                                          (EventCount == 1)? &Timeout: NULL);
        if (status == WAIT_TIMEOUT)
        {
            if (hNbt == (HANDLE)-1)
            {
                PrimeCacheNbt(&hNbt, 0);
                if (hNbt == (HANDLE)-1)
                {
                    continue; // to wait
                }
            }
            status = PostForGetHostByName(hNbt); // try again
            if (status == NO_ERROR)
            {
                EventCount = 2;
            }
        }
        else if (status == 1)
        {
            if (Trace)
            {
                DbgPrint("LMHSVC: Doing GetHostName\n");
            }

            // the irp used for gethostby name has returned
            status = GetHostName(hNbt, &gIpAddrBuffer);

            //
            // disable the get host by name stuff if we have an error
            // posting a buffer to the transport
            //
            if (status != NO_ERROR)
            {
                EventCount = 1;
            }
        }
        else
        {
            // it must have been a the Poison event signalling the end of the
            // the service, so exit after getting the Irp back from the
            // transport.  This system will look after canceling the IO and
            // getting the Irp back.

            NtClose(hNbt);
            hNbt = NULL;
            break;
        }
    }

    if (Trace)
    {
        DBG_PRINT ("LMHSVC: [LMSVCS_ENTRY_POINT] Exiting now!\n");
    }
    NbtTrace(NBT_TRACE_DNS, ("Service Exiting"));

    if (hThread) {
        WaitForSingleObject(hThread, INFINITE);
        CloseHandle(hThread);
        hThread = NULL;
    }

#ifdef NEWSMB
    SmbStopService(SmbsvcUpdateStatus);
#endif

cleanup:
    if (SocketsUp) {
        WSACleanup();
        SocketsUp = FALSE;
    }

    for (i=0; i<NUM_THREADS; i++) {
        ResetEvent(Poison[i]);
    }
 
    SvcStatus.dwCurrentState = SERVICE_STOPPED;
    SvcStatus.dwCheckPoint   = 0;
    SvcStatus.dwWaitHint     = 0;
    announceStatus(&SvcStatus);

    NbtTrace(NBT_TRACE_DNS, ("Service Stopped"));
    return;

} // lmhostsSvc



//------------------------------------------------------------------------
VOID
announceStatus (
    IN LPSERVICE_STATUS status
    )

/*++

Routine Description:

    This procedure announces the service's status to the service controller.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (!SvcHandle) {
        return;
    }

#if DBG
    if (Trace)
    {
        DbgPrint( "LMHSVC: announceStatus:\n"
                  "        CurrentState %lx\n"
                  "        ControlsAccepted %lx\n"
                  "        Win32ExitCode %lu\n"
                  "        ServiceSpecificExitCode %lu\n"
                  "        CheckPoint %lu\n"
                  "        WaitHint %lu\n",
                status->dwCurrentState,
                status->dwControlsAccepted,
                status->dwWin32ExitCode,
                status->dwServiceSpecificExitCode,
                status->dwCheckPoint,
                status->dwWaitHint);
    }
#endif // DBG

    SetServiceStatus(SvcHandle, status);

} // announceStatus

DWORD
SmbsvcUpdateStatus(
    VOID
    )
{
    DWORD   Error = ERROR_SUCCESS;

    if (NULL == SvcHandle) {
        return ERROR_SUCCESS;
    }
    SvcStatus.dwCheckPoint++;
    if (!SetServiceStatus(SvcHandle, &SvcStatus)) {
        Error = GetLastError();
    }
    return Error;
}

//------------------------------------------------------------------------
VOID
lmhostsHandler (
    IN DWORD controlcode
    )

/*++

Routine Description:

    This is the HANDLER_FUNCTION of the LmHosts service.

    It only responds to two Service Controller directives: to stop, and
    to announce the current status of the service.

Arguments:

    opcode

Return Value:

    None.

--*/

{
    BOOL retval;
    ULONG   i;

    switch (controlcode) {
    case SERVICE_CONTROL_STOP:
        NbtTrace(NBT_TRACE_DNS, ("Receive Stop Request"));

        if (SvcStatus.dwCurrentState == SERVICE_RUNNING) {
            SvcStatus.dwCurrentState = SERVICE_STOP_PENDING;
            SvcStatus.dwCheckPoint   = 0;
            SvcStatus.dwWaitHint     = 0;
            announceStatus(&SvcStatus);

            NbtTrace(NBT_TRACE_DNS, ("Service: stopping"));

            for (i=0; i<NUM_THREADS; i++) {
                retval = SetEvent(Poison[i]);
                ASSERT(retval);
            }

            for (i = 0; i < 8; i++) {
                if (*(volatile DWORD*)(&SvcStatus.dwCurrentState) == SERVICE_STOPPED) {
                    break;
                }
                Sleep(1000);
            }
        }
        break;

    case SERVICE_CONTROL_INTERROGATE:
        announceStatus(&SvcStatus);
        break;

    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_SHUTDOWN:
    default:
        break;
    }

} // lmhostsHandler

VOID
DeinitData(
    VOID
    )
{
    DWORD i;

    for (i=0; i<NUM_THREADS; i++) {
        if (NULL != Poison[i]) {
            CloseHandle(Poison[i]);
            Poison[i] = NULL;
        }
        if (NULL != NbtEvent[i]) {
            CloseHandle(NbtEvent[i]);
            NbtEvent[i] = NULL;
        }
    }
}

//------------------------------------------------------------------------
NTSTATUS
InitData (
    VOID
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    DWORD i;
    DWORD status;

    for (i=0; i<NUM_THREADS; i++)
    {
        Poison[i] = CreateEvent(NULL,                            // security attributes
                                FALSE,                           // ManualReset
                                FALSE,                           // InitialState
                                NULL);                           // EventName

        if (!Poison[i])
        {
            DBG_PRINT ("LMHSVC: couldn't CreateEvent()\n");
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        NbtEvent[i] = CreateEvent(NULL,                            // security attributes
                                  FALSE,                           // ManualReset
                                  FALSE,                           // InitialState
                                  NULL);                           // EventName
        if (!NbtEvent[i])
        {
            DBG_PRINT ("LMHSVC: couldn't CreateEvent()\n");
            return (STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    return STATUS_SUCCESS;

} // InitData


//------------------------------------------------------------------------
LONG
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN ULONG            index
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    TDI_REQUEST_QUERY_INFORMATION   QueryInfo;
    IO_STATUS_BLOCK                 iosb;
    PVOID                           pInput;
    ULONG                           SizeInput;

    pInput = NULL;
    SizeInput = 0;
    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NbtEvent[index],                // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        // do not wait for this to complete since it could complete
        // at any time in the future.
        //
        if ((Ioctl == IOCTL_NETBT_DNS_NAME_RESOLVE) ||
            (Ioctl == IOCTL_NETBT_CHECK_IP_ADDR))
        {
            return(NO_ERROR);
        }
        else
        {
            status = NtWaitForSingleObject(
                        fd,                         // Handle
                        TRUE,                       // Alertable
                        NULL);                      // Timeout
            NbtTrace(NBT_TRACE_DNS, ("%!status!", status));
        }
    }

    if (NT_SUCCESS(status))
    {
        return(NO_ERROR);
    }
    else
        return(ERROR_FILE_NOT_FOUND);

}

//------------------------------------------------------------------------
NTSTATUS
Resync(
    IN HANDLE   fd
    )

/*++

Routine Description:

    This procedure tells NBT to purge all names from its remote hash
    table cache.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    NTSTATUS    status;
    CHAR        Buffer;

    status = DeviceIoCtrl(fd,
                          &Buffer,
                          1,
                          IOCTL_NETBT_PURGE_CACHE,
                          0);   // pass 0 since we know that we are called only for the first thread

    return(status);
}

#if 0
//------------------------------------------------------------------------
PCHAR
GetHost(ULONG addr,BOOLEAN Convert)
{
    static char string[32];

    union inet
    {
        unsigned long l;
        char          c[4];
    }in;
    struct hostent *hp;

    int     i;

    if (addr == 0L)
        return(" ");

    /*
     *  Look up the address in the in-core host table.
     *  If it's there, that'll do the trick.
     */

    if (Convert)
    {
        if ( hp = gethostbyname((char  *) &addr,sizeof(addr),2) )
        {
            return( hp->h_name );
        }
    }

    in.l = addr;
    sprintf(string, "%u.%u.%u.%u", (unsigned char) in.c[0],
        (unsigned char) in.c[1], (unsigned char) in.c[2],
            (unsigned char) in.c[3]);
    return(string);
}
#endif

//------------------------------------------------------------------------
NTSTATUS
PrimeCacheNbt(
    OUT PHANDLE     pHandle,
    IN  ULONG       index
    )

/*++

Routine Description:

    This procedure sends a NBT_PURGE ioctl command down to netbt.sys.

Arguments:

    None.

Return Value:

    0 if successful, an error code otherwise.

--*/

{
    LONG        status = NO_ERROR;
    HANDLE      Handle = NULL;
    PWCHAR ExportDevice[ ] = { L"\\Device\\NetBt_Wins_Export", 0 };

    *pHandle = (HANDLE)-1;

    status = OpenNbt(ExportDevice,&Handle);
    if (status == NO_ERROR)
    {
        //
        // Resync only once...
        //
        if (index == 0) {
            Resync(Handle);
        }

        *pHandle = Handle;
    }

    return(status);
}

//------------------------------------------------------------------------
NTSTATUS
OpenNbt(
    IN  WCHAR  *path[],
    OUT PHANDLE pHandle
    )

/*++

Routine Description:

    This function opens a stream.

Arguments:

    path        - path to the STREAMS driver
    oflag       - currently ignored.  In the future, O_NONBLOCK will be
                    relevant.
    ignored     - not used

Return Value:

    An NT handle for the stream, or INVALID_HANDLE_VALUE if unsuccessful.

--*/

{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    LONG                index=0;

    while ((path[index]) && (index < NBT_MAXIMUM_BINDINGS))
    {
        RtlInitUnicodeString(&uc_name_string,path[index]);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &uc_name_string,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

        status =
        NtCreateFile(
            &StreamHandle,
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0);

        if (NT_SUCCESS(status))
        {
            *pHandle = StreamHandle;
            return(NO_ERROR);
        }

        ++index;
    }

    return(ERROR_FILE_NOT_FOUND);

}
//------------------------------------------------------------------------
LONG
PostForGetHostByName(
    IN HANDLE           fd
    )

/*++

Routine Description:

    This procedure passes a buffer down to Netbt for it to return when it
    wants a name resolved via DNS.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    LONG        status = ERROR_FILE_NOT_FOUND;
    CHAR        Buffer;

    status = DeviceIoCtrl (fd,
                           &gIpAddrBuffer,
                           sizeof(tIPADDR_BUFFER_DNS),
                           IOCTL_NETBT_DNS_NAME_RESOLVE,
                           0);   // hard coded thread Index

    NbtTrace(NBT_TRACE_DNS, ("%!status!", status));
    return(status);
}

LONG
PostForCheckIPAddr(
    IN HANDLE           fd
    )

/*++

Routine Description:

    This procedure passes a buffer down to Netbt for it to return when it
    wants a name resolved via DNS.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    LONG        status = ERROR_FILE_NOT_FOUND;
    CHAR        Buffer;

    status = DeviceIoCtrl (fd,
                           &gIpAddrBufferChkIP,
                           sizeof(tIPADDR_BUFFER_DNS),
                           IOCTL_NETBT_CHECK_IP_ADDR,
                           1);   // hard coded thread Index

    if (Trace)
    {
        DbgPrint("LMHSVC: Entered PostForCheckIPAddr. status: %lx\n", status);
    }

    return(status);
}

GUID HostnameGuid = SVCID_INET_HOSTADDRBYNAME;

VOID
GetHostNameCopyBack(
    tIPADDR_BUFFER_DNS   *pIpAddrBuffer,
    PWSAQUERYSETW   pwsaq
    )
{
    //
    // success, fetch the CSADDR  structure
    //
    PCSADDR_INFO    pcsadr;
    ULONG       GoodAddr;
    NTSTATUS    Status;
    int         i = 0;
    int         imax = min(MAX_IPADDRS_PER_HOST, pwsaq->dwNumberOfCsAddrs);

    pcsadr = pwsaq->lpcsaBuffer;
    if (pwsaq->lpszServiceInstanceName) {
        wcsncpy(pIpAddrBuffer->pwName, pwsaq->lpszServiceInstanceName, DNS_NAME_BUFFER_LENGTH);
        pIpAddrBuffer->pwName[DNS_NAME_BUFFER_LENGTH-1] = 0;
        pIpAddrBuffer->NameLen = wcslen(pIpAddrBuffer->pwName) * sizeof(WCHAR);
        NbtTrace(NBT_TRACE_DNS, ("FQDN= %ws", pIpAddrBuffer->pwName));
        if (Trace) {
            DbgPrint("Lmhsvc: Resolved name = \"%ws\"\n", pIpAddrBuffer->pwName);
        }
    }

    if (pIpAddrBuffer->Resolved) {
        /* In this case, we have been called before. No need to copy the IPs back again. */
        /* But we do need to copy the name back since it is the alias name that KsecDD requires */
        return;
    }

    for(i=0; i<imax; i++, pcsadr++)
    {
        PSOCKADDR_IN sockaddr;

        sockaddr = (PSOCKADDR_IN)pcsadr->RemoteAddr.lpSockaddr;
        pIpAddrBuffer->IpAddrsList[i] = htonl( sockaddr->sin_addr.s_addr);
        NbtTrace(NBT_TRACE_DNS, ("IP %d: %!ipaddr!", i + 1, pIpAddrBuffer->IpAddrsList[i]));

        if (Trace)
        {
            DbgPrint("LmhSvc: Dns IpAddrsList[%d/%d] =%x\n",
                (i+1),imax,pIpAddrBuffer->IpAddrsList[i]);
        }
    }
    pIpAddrBuffer->IpAddrsList[i] = 0;

    //
    // Check the IP addr list.
    //
    Status = CheckIPAddresses(pIpAddrBuffer, &GoodAddr, FALSE);
    if (Status == NO_ERROR)
    {
        pIpAddrBuffer->Resolved = TRUE;
        pIpAddrBuffer->IpAddrsList[0] = htonl(GoodAddr);
        pIpAddrBuffer->IpAddrsList[1] = 0;
        if (Trace)
        {
            DbgPrint("LmhSvc: SUCCESS -- Dns address = <%x>\n", pIpAddrBuffer->IpAddrsList[0]);
        }
    }
    else
    {
        pIpAddrBuffer->IpAddrsList[0] = 0;
        if (Trace)
        {
            DbgPrint("LmhSvc: CheckIPAddresses returned <%x>\n", Status);
        }
    }
}


//------------------------------------------------------------------------
LONG
GetHostName(
    IN HANDLE               fd,
    IN tIPADDR_BUFFER_DNS   *pIpAddrBuffer
    )

/*++

Routine Description:

    This procedure attempts to resolve a name using the Resolver through
    the Sockets interface to DNS.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    LONG            status;
    ULONG           NameLen;
    ULONG           IpAddr;
    PWSAQUERYSETW   pwsaq = (PWSAQUERYSETW) pWSABuffer;
    INT             err;
    HANDLE          hRnR;
    PWSTR           szHostnameW;
    BYTE            *pAllocatedBuffer = NULL;
    DWORD           dwLength;

    pIpAddrBuffer->Resolved = FALSE;

    // Hostname is encoded with OEMCP, so we convert from OEMCP->Unicode
    if (pIpAddrBuffer->bUnicode) {
        NameLen = pIpAddrBuffer->NameLen;
        ASSERT((NameLen % sizeof(WCHAR)) == 0);
        NameLen /= sizeof(WCHAR);
    } else {
        WCHAR   uncName[DNS_NAME_BUFFER_LENGTH];

        ASSERT(pIpAddrBuffer->NameLen < DNS_NAME_BUFFER_LENGTH);
        pIpAddrBuffer->pName[pIpAddrBuffer->NameLen] = 0;
        MultiByteToWideChar (CP_OEMCP, 0, pIpAddrBuffer->pName, -1, uncName, sizeof(uncName)/sizeof(WCHAR));
        uncName[DNS_NAME_BUFFER_LENGTH-1] = 0;
        NameLen = wcslen(uncName);
        memcpy (pIpAddrBuffer->pwName, uncName, NameLen * sizeof(WCHAR));
        pIpAddrBuffer->pwName[NameLen] = 0;
    }
    szHostnameW = pIpAddrBuffer->pwName;

    NbtTrace(NBT_TRACE_DNS, ("Resolving %ws", szHostnameW));

    // truncate spaces from the end for netbios names
    //
    if (NameLen < NETBIOS_NAMESIZE)
    {
        //
        // Start from the end and find the first non-space character
        //
        NameLen = NETBIOS_NAMESIZE-1;
        while ((NameLen) && (szHostnameW[NameLen-1] == 0x20))
        {
            NameLen--;
        }
        szHostnameW[NameLen] = '\0';
    }

    if (!NameLen || !SocketsUp) {
        if (Trace) {
            DbgPrint("Lmhsvc: Failed to Resolve name, NameLen=<%d>\n", NameLen);
        }
        goto label_exit;
    }

    //
    // do a lookup using RNR
    //

    if (Trace) {
        DbgPrint("Lmhsvc: Resolving name = \"%ws\", NameLen=<%d>\n", szHostnameW, NameLen);
    }

    RtlZeroMemory(pwsaq, sizeof(*pwsaq));
    pwsaq->dwSize = sizeof(*pwsaq);
    pwsaq->lpszServiceInstanceName = szHostnameW;
    pwsaq->lpServiceClassId = &HostnameGuid;
    pwsaq->dwNameSpace = NS_DNS;

    err = WSALookupServiceBeginW (pwsaq, LUP_RETURN_NAME| LUP_RETURN_ADDR| LUP_RETURN_ALIASES, &hRnR);
    if(err != NO_ERROR) {
        err = GetLastError();
        NbtTrace(NBT_TRACE_DNS, ("error %!winerr!", err));

        if (Trace) {
            DbgPrint("LmhSvc: WSALookupServiceBeginA returned <%x>, Error=<%d>\n", err, GetLastError());
        }
        goto label_exit;
    }

    //
    // The query was accepted, so execute it via the Next call.
    //
    dwLength = WSA_QUERY_BUFFER_LENGTH;
    err = WSALookupServiceNextW (hRnR, 0, &dwLength, pwsaq);
    if (err != NO_ERROR)
    {
        err = GetLastError();
        NbtTrace(NBT_TRACE_DNS, ("error %!winerr!", err));
    } else if (pwsaq->dwNumberOfCsAddrs) {
        GetHostNameCopyBack(pIpAddrBuffer, pwsaq);

        /* check if there is any alias available */
        err = WSALookupServiceNextW (hRnR, 0, &dwLength, pwsaq);
        if (err != NO_ERROR) {
            err = GetLastError();
            if (err != WSAEFAULT) {
                err = NO_ERROR;         // Ignore this error
            } else {
                NbtTrace(NBT_TRACE_DNS, ("error %!winerr!", err));
            }
        } else if (pwsaq->dwOutputFlags & RESULT_IS_ALIAS) {
            GetHostNameCopyBack(pIpAddrBuffer, pwsaq);
        }
    }

    WSALookupServiceEnd (hRnR);
    if ((WSAEFAULT == err) &&
        (pAllocatedBuffer = malloc(2*dwLength)))
    {
        NbtTrace(NBT_TRACE_DNS, ("buffer length %d", 2 * dwLength));

        if (Trace)
        {
            DbgPrint("\tLmhsvc: WSALookupServiceNextW ==> WSAEFAULT: Retrying, BufferLength=<%d>-><2*%d> ...\n",
                WSA_QUERY_BUFFER_LENGTH, dwLength);
        }

        dwLength *= 2;
        pwsaq = (PWSAQUERYSETW) pAllocatedBuffer;
        RtlZeroMemory(pwsaq, sizeof(*pwsaq));
        pwsaq->dwSize = sizeof(*pwsaq);
        pwsaq->lpszServiceInstanceName = szHostnameW;
        pwsaq->lpServiceClassId = &HostnameGuid;
        pwsaq->dwNameSpace = NS_DNS;

        err = WSALookupServiceBeginW(pwsaq, LUP_RETURN_NAME| LUP_RETURN_ADDR| LUP_RETURN_ALIASES, &hRnR);
        if(err == NO_ERROR)
        {
            err = WSALookupServiceNextW (hRnR, 0, &dwLength, pwsaq);
            if (err == NO_ERROR && pwsaq->dwNumberOfCsAddrs) {
                GetHostNameCopyBack(pIpAddrBuffer, pwsaq);
                if (WSALookupServiceNextW (hRnR, 0, &dwLength, pwsaq) == NO_ERROR) {
                    if (pwsaq->dwOutputFlags & RESULT_IS_ALIAS) {
                        GetHostNameCopyBack(pIpAddrBuffer, pwsaq);
                    }
                }
            }
            WSALookupServiceEnd (hRnR);
        }
    }

    if (err != NO_ERROR)
    {
        NbtTrace(NBT_TRACE_DNS, ("return %!winerr!", err));
        if (Trace)
        {
            DbgPrint("LmhSvc: WSALookupServiceNextW returned <%x>, NumAddrs=<%d>, Error=<%d>, dwLength=<%d>\n",
                err, pwsaq->dwNumberOfCsAddrs, GetLastError(), dwLength);
        }
    }

label_exit:
    if (pAllocatedBuffer) {
        free(pAllocatedBuffer);
    }

    status = PostForGetHostByName(fd);
    return(status);
}

#include    <ipexport.h>
#include    <icmpapi.h>

#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define DEFAULT_SEND_SIZE           32
#define DEFAULT_COUNT               2
#define DEFAULT_TTL                 32
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             2000L           // default timeout set to 2 secs.

LONG
CheckIPAddresses(
    IN tIPADDR_BUFFER_DNS   *pIpAddrBuffer,
    IN ULONG   *IpAddr,
    IN BOOLEAN  fOrdered
    )

/*++

Routine Description:

    This function checks a list of IP addrs for reachability by pinging each in turn
    until a successful one is found. This function assumes that the list of addresses
    is terminated by a 0 address.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/
{
    ULONG   i;
    ULONG   *pIpAddrs;
    HANDLE  IcmpHandle;
    PUCHAR  pSendBuffer = NULL;
    PUCHAR  pRcvBuffer = NULL;
    ULONG   address = 0;
    ULONG   result;
    ULONG   status;
    ULONG   numberOfReplies;
    IP_OPTION_INFORMATION SendOpts;

    if (!(pSendBuffer = malloc(DEFAULT_SEND_SIZE)) ||
        (!(pRcvBuffer = malloc(DEFAULT_BUFFER_SIZE))))
    {
        NbtTrace(NBT_TRACE_DNS, ("Out of memory"));

        if (Trace)
        {
            DbgPrint("LmhSvc.CheckIPAddresses: ERROR -- malloc failed for %s\n",
                (pSendBuffer ? "pRcvBuffer" : "pSendBuffer"));
        }

        if (pSendBuffer)
        {
            free (pSendBuffer);
        }

        return -1;
    }

    //
    // Open channel
    //
    IcmpHandle = IcmpCreateFile();
    if (IcmpHandle == INVALID_HANDLE_VALUE)
    {
        DBG_PRINT ( "Unable to contact IP driver, error code %d.\n", GetLastError() );
        free (pSendBuffer);
        free (pRcvBuffer);
        return -1;
    }

    //
    // init to the first address.
    //
    pIpAddrs = pIpAddrBuffer->IpAddrsList;
    *IpAddr = (fOrdered) ? *pIpAddrs : htonl(*pIpAddrs);

    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < DEFAULT_SEND_SIZE; i++)
    {
        pSendBuffer[i] = (UCHAR)('A' + (i % 23));
    }

    //
    // Initialize the send options
    //
    SendOpts.OptionsData = NULL;
    SendOpts.OptionsSize = 0;
    SendOpts.Ttl = DEFAULT_TTL;
    SendOpts.Tos = DEFAULT_TOS;
    SendOpts.Flags = 0;

    //
    // For each IP address in the list
    //
    while (*pIpAddrs)
    {
        struct in_addr addr;

        address = (fOrdered) ? *pIpAddrs : htonl(*pIpAddrs);
        addr.s_addr = address;

        if (address == INADDR_BROADCAST)
        {
            NbtTrace(NBT_TRACE_DNS, ("Cannot ping %!ipaddr!", address));

            if (Trace)
            {
                DbgPrint("LmhSvc: Cannot ping a Broadcast address = <%s>\n", inet_ntoa(addr));
            }

            pIpAddrs++;
            continue;
        }

        for (i=0; i < DEFAULT_COUNT; i++)
        {
            if (Trace)
            {
                DbgPrint("LmhSvc: Pinging <%s>\n", inet_ntoa(addr));
            }

            numberOfReplies = IcmpSendEcho (IcmpHandle,
                                            address,
                                            pSendBuffer,
                                            (unsigned short) DEFAULT_SEND_SIZE,
                                            &SendOpts,
                                            pRcvBuffer,
                                            DEFAULT_BUFFER_SIZE,    // pRcvBuffer size!
                                            DEFAULT_TIMEOUT);

            NbtTrace(NBT_TRACE_DNS, ("Ping %!ipaddr!: %d replies", address, numberOfReplies));

            //
            // If ping successful, return the IP address
            //
            if (numberOfReplies != 0)
            {
                PICMP_ECHO_REPLY    reply;

                reply = (PICMP_ECHO_REPLY) pRcvBuffer;
                if (reply->Status == IP_SUCCESS)
                {
                    NbtTrace(NBT_TRACE_DNS, ("Ping %!ipaddr!: success", address));

                    if (Trace)
                    {
                        DbgPrint("LmhSvc: SUCCESS: Received <%d> replies after Pinging <%s>\n",
                            numberOfReplies, inet_ntoa(addr));
                    }
                    result = IcmpCloseHandle(IcmpHandle);
                    IcmpHandle = NULL;
                    *IpAddr = address;
                    free (pSendBuffer);
                    free (pRcvBuffer);
                    return 0;
                }
            }
        }

        NbtTrace(NBT_TRACE_DNS, ("Ping %!ipaddr!: failed", address));

        if (Trace)
        {
            DbgPrint("LmhSvc: FAILed: Pinging <%s>\n", inet_ntoa(addr));
        }

        pIpAddrs++;
    }

    result = IcmpCloseHandle(IcmpHandle);
    IcmpHandle = NULL;

    //
    // Return the first addr if none matched in the hope that TCP session setup might succeed even though
    // the pings failed.
    //

    free (pSendBuffer);
    free (pRcvBuffer);

    return NO_ERROR;
}

ULONG
VerifyIPAddresses(
    IN HANDLE               fd,
    IN tIPADDR_BUFFER_DNS   *pIpAddrBuffer
    )
/*++

Routine Description:

    This function finds out the reachable IP addr and returns the Irp to Netbt

Arguments:


Return Value:

    NONE

--*/
{
    DWORD   Status;
    ULONG  GoodAddr;

    pIpAddrBuffer->Resolved = FALSE;
    Status = CheckIPAddresses(pIpAddrBuffer, &GoodAddr, TRUE);

    NbtTrace(NBT_TRACE_DNS, ("CheckIPAddresses return %d", Status));

    if (Status == NO_ERROR) {
        pIpAddrBuffer->IpAddrsList[0] = ntohl(GoodAddr);
        //
        // NULL terminate
        //
        pIpAddrBuffer->IpAddrsList[1] = 0;
        pIpAddrBuffer->Resolved = TRUE;
    } else {
        pIpAddrBuffer->IpAddrsList[0] = 0;
    }

    Status = PostForCheckIPAddr(fd);

    return  Status;
}


VOID
CheckIPAddrWorkerRtn(
    IN  LPVOID  lpUnused
    )
/*++

Routine Description:

    This function submits IP address check Irps into Netbt, on completion of the Irp, it submits the IP address
    list to CheckIPAddresses.

Arguments:


Return Value:

    NONE

--*/
{
    HANDLE  EventList[2];
    DWORD   status;
    HANDLE  hNbt;
    ULONG   EventCount;
    LONG    err;
    LONG    Value;

    LARGE_INTEGER Timeout = RtlEnlargedIntegerMultiply (-10 * 60, 1000 * 1000 * 10); // 10 minutes

    UNREFERENCED_PARAMETER(lpUnused);

    //
    // ignore the return code from resyncNbt().
    //
    // In most cases (no domains spanning an ip router), it is not a
    // catastrophe if nbt.sys couldn't successfully process the NBT_RESYNC
    // ioctl command.  Since I'm ignoring the return, I announce I'm running
    // before I call it to allow other dependent services to start.
    //
    //
    status = PrimeCacheNbt(&hNbt, 1);

    if (Trace)
    {
        DbgPrint("LMHSVC: Entered CheckIPAddrWorkerRtn, hNbt %lx.\n", hNbt);
    }

    if (hNbt != (HANDLE)-1)
    {
        status = PostForCheckIPAddr(hNbt);
        if (status == NO_ERROR)
        {
            EventCount = 2;
        }
        else
        {
            if (Trace)
            {
                DbgPrint("Lmhsvc:Error posting Irp for get host by name\n");
            }

            EventCount = 1;
        }
    }
    else
    {
        EventCount = 1;
    }
    //
    // "A SERVICE_MAIN_FUNCTION does not return until the service is ready
    // to terminate."
    //
    // (ref: api32wh.hlp, SERVICE_MAIN_FUNCTION)
    //
    //
    ASSERT(Poison[1]);
    EventList[0] = Poison[1];
    EventList[1] = NbtEvent[1];

    while (TRUE)
    {
        status = NtWaitForMultipleObjects(
                        EventCount,
                        EventList,
                        WaitAny,              // wait for any event
                        FALSE,
                        (EventCount == 1)? &Timeout: NULL);

        if (status == WAIT_TIMEOUT)
        {
            if (hNbt == (HANDLE)-1)
            {
                PrimeCacheNbt(&hNbt, 1);
                if (hNbt == (HANDLE)-1)
                {
                    continue; // to wait
                }
            }
            status = PostForCheckIPAddr(hNbt); // try again
            if (status == NO_ERROR)
            {
                EventCount = 2;
            }
        }
        else if (status == 1)
        {

            if (Trace)
            {
                DbgPrint("LMHSVC: Doing VerifyAddr\n");
            }
            // the irp used for gethostby name has returned
            status = VerifyIPAddresses(hNbt, &gIpAddrBufferChkIP);

            //
            // disable the get host by name stuff if we have an error
            // posting a buffer to the transport
            //
            if (status != NO_ERROR)
            {
                EventCount = 1;
            }
        }
        else
        {
            // it must have been a the Poison event signalling the end of the
            // the service, so exit after getting the Irp back from the
            // transport.  This system will look after canceling the IO and
            // getting the Irp back.

            NtClose(hNbt);
            hNbt = NULL;
            break;
        }

    }

    if (Trace)
    {
        DBG_PRINT ("LMHSVC: Exiting [CheckIPAddrWorkerRtn] now!\n");
    }

    ExitThread(NO_ERROR);
    return;
}

BOOLEAN
DllMain(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
/*++

Routine Description:

    This is the DLL initialization routine for lmhsvc.dll.

Arguments:

    Standard.

Return Value:

    TRUE iff initialization succeeded.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(DllHandle);  // avoid compiler warnings
    UNREFERENCED_PARAMETER(Context);    // avoid compiler warnings

    //
    // Handle attaching netlogon.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {

        WPP_INIT_TRACING(L"LmhSvc");
        DisableThreadLibraryCalls(DllHandle);

        ntStatus = InitData();
        if (STATUS_SUCCESS != ntStatus) return FALSE;

    } else if (Reason == DLL_PROCESS_DETACH) {
        DeinitData();
        WPP_CLEANUP();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\kdext\kdextlib.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    rdr2kd.h

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _KDEXTLIB_H_
#define _KDEXTLIB_H_

#include <windef.h>

//
// The help strings printed out
//

extern LPSTR Extensions[];

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// The task of generating these descriptors by augmenting the front end, but that will have to
// wait till we play around with these extensions and modify the data structures to meet most
// of the requirements.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.
//
// There are certain conventions that have been adopted to ease the definition of the macros
// as well as facilitate the automation of the generation of these descriptors.
// These are as follows ....
//
// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeLong,
    FieldTypeUShort,
    FieldTypeShort,
    FieldTypePointer,
    FieldTypeULongULong,
    FieldTypeListEntry,
    FieldTypeIpAddr,
    FieldTypeMacAddr,
    FieldTypeNBName,
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeFileTime
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    USHORT           Offset;      // The offset of the field in the structure
    union {
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL}

#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,AuxInfo}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRITOR_ {
    LPSTR 	          StructName;
    ULONG             StructSize;
    FIELD_DESCRIPTOR  *FieldDescriptors;
} STRUCT_DESCRIPTOR;

#define STRUCT(StructTypeName,FieldDescriptors) \
        { #StructTypeName,sizeof(StructTypeName),FieldDescriptors}

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

//
// Support for displaying global variables
//

extern LPSTR GlobalBool[];
extern LPSTR GlobalShort[];
extern LPSTR GlobalLong[];
extern LPSTR GlobalPtrs[];

#endif // _KDEXTLIB_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\kdext\kdextlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include <nt.h>
#include <ntrtl.h>
#include "ntverp.h"

#define KDEXTMODE

#include <windef.h>
#include <ntkdexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <..\..\inc\types.h>

PNTKD_OUTPUT_ROUTINE         lpOutputRoutine;
PNTKD_GET_EXPRESSION         lpGetExpressionRoutine;
PNTKD_GET_SYMBOL             lpGetSymbolRoutine;
PNTKD_READ_VIRTUAL_MEMORY    lpReadMemoryRoutine;

#define    PRINTF    lpOutputRoutine
#define    ERROR     lpOutputRoutine

#define    NL      1
#define    NONL    0

#define MAX_LIST_ELEMENTS 4096
BYTE    DataBuffer[4096];

#define    SETCALLBACKS() \
    lpOutputRoutine = lpExtensionApis->lpOutputRoutine; \
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine; \
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine; \
    lpReadMemoryRoutine = lpExtensionApis->lpReadVirtualMemRoutine;

#define DEFAULT_UNICODE_DATA_LENGTH 4096
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 4096
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

//
// No. of columns used to display struct fields;
//

ULONG s_MaxNoOfColumns = 3;
ULONG s_NoOfColumns = 1;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetData(PVOID dwAddress, PVOID ptr, ULONG size)
{
    BOOL b;
    ULONG BytesRead;

    b = (lpReadMemoryRoutine)(dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size )
    {
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
GetString(PUCHAR dwAddress, PSZ buf )
{
    do
    {
        if (!GetData (dwAddress, buf, 1))
        {
            return FALSE;
        }

        dwAddress++;
        buf++;

    } while( *buf != '\0' );

    return TRUE;
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&7 ], "0123456789abcdef"[ c&7 ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING    AnsiString;
    BOOL           b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = (lpReadMemoryRoutine)(
                (LPVOID) puStr->Buffer,
                  UnicodeString.Buffer,
                UnicodeString.Length,
                NULL);

    if (b)    {
        RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
        RtlFreeAnsiString(&AnsiString);
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL        b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = (lpReadMemoryRoutine)(
                (LPVOID) pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}


/*
 * Get the ULONG value referenced by the pointer given to us
 */
VOID
Next3(
    PVOID   Ptr,
    PVOID   *pFLink,
    PVOID   *pBLink,
    PULONG_PTR pVerify
    )
{
    PVOID Buffer[4];

    GetData(Ptr, (PVOID) Buffer, sizeof(PVOID)*3);

    if (pFLink)
    {
        *pFLink = Buffer[0];
    }

    if (pBLink)
    {
        *pBLink = Buffer[1];
    }

    if (pVerify)
    {
        *pVerify = (ULONG_PTR) Buffer[2];
    }
}


/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */

char *NewLine  = "\n";
char *FieldSeparator = " ";
char *DotSeparator = ".";
#define NewLineForFields(FieldNo) \
        ((((FieldNo) % s_NoOfColumns) == 0) ? NewLine : FieldSeparator)
#define FIELD_NAME_LENGTH 30

VOID
PrintStructFields(PVOID dwAddress, VOID *ptr, FIELD_DESCRIPTOR *pFieldDescriptors )
{
    int i;
    int j;
    BYTE  ch;

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            PRINTF( "%-17s...%s ", pFieldDescriptors->Name, pFieldDescriptors->Name+strlen(pFieldDescriptors->Name)-10 );
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        PRINTF( "(0x%-2X) ", pFieldDescriptors->Offset );

        switch( pFieldDescriptors->FieldType ) {
          case FieldTypeByte:
          case FieldTypeChar:
              PRINTF( "%-16d%s",
                  *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeBoolean:
              PRINTF( "%-16s%s",
                  *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                  NewLineForFields(i));
              break;

          case FieldTypeBool:
              PRINTF( "%-16s%s",
                  *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                  NewLineForFields(i));
              break;

          case FieldTypePointer:
              PRINTF( "%-16X%s",
                  *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeULongULong:
              PRINTF( "%d%s",
                  *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset + sizeof(ULONG)),
                  FieldSeparator );
              PRINTF( "%d%s",
                  *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeListEntry:

              if ( (PVOID)((PUCHAR)dwAddress + pFieldDescriptors->Offset) ==
                  *(PVOID *)(((PUCHAR)ptr) + pFieldDescriptors->Offset ))
              {
                  PRINTF( "%s", "List Empty\n" );
              }
              else
              {
                    PVOID  Address, StartAddress;
                    ULONG  Count = 0;
                    UCHAR  Greater = ' ';

                    StartAddress = (PVOID) (((PUCHAR)dwAddress) + pFieldDescriptors->Offset);
                    Address = *(PVOID *) (((PUCHAR)ptr) + pFieldDescriptors->Offset);

                    while ((Address != StartAddress) &&
                           (++Count < MAX_LIST_ELEMENTS))
                    {
                        Next3 (Address, &Address, NULL, NULL);
                    }

                    if (Address != StartAddress)
                    {
                        Greater = '>';
                    }

                  PRINTF( "%-8X%s",
                      *(PVOID *)(((PUCHAR)ptr) + pFieldDescriptors->Offset ),
                      FieldSeparator );
                  PRINTF( "%-8X, (%c %d Elements)%s",
                      *(PVOID *)(((PUCHAR)ptr) + pFieldDescriptors->Offset + sizeof(PVOID)),
                      Greater, Count,
                      NewLineForFields(i) );
              }
              break;

          // Ip address: 4 bytes long
          case FieldTypeIpAddr:
             PRINTF( "%X%s",
                  *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  FieldSeparator );
             PRINTF( "(%d%s",
                 *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + 3),
                  DotSeparator );
             PRINTF( "%d%s",
                 *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + 2 ),
                  DotSeparator );
             PRINTF( "%d%s",
                 *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + 1 ),
                  DotSeparator );
             PRINTF( "%d)%s",
                 *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
             break;

          // Mac address: 6 bytes long
          case FieldTypeMacAddr:
             for (j=0; j<5; j++)
             {
                 PRINTF( "%X%s",
                     *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + j),
                      FieldSeparator );
             }
             PRINTF( "%X%s",
                 *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + 5),
                  NewLineForFields(i) );
             break;

          // Netbios name: 16 bytes long
          case FieldTypeNBName:
             //
             // if first byte is printable, print the first 15 bytes as characters
             // and 16th byte as a hex value.  otherwise, print all the 16 bytes
             // as hex values
             //
             ch = *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset);
             if (ch >= 0x20 && ch <= 0x7e)
             {
                 for (j=0; j<15; j++)
                 {
                     PRINTF( "%c", *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + j));
                 }
                 PRINTF( "<%X>%s",
                     *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + 15),
                      NewLineForFields(i) );
             }
             else
             {
                 for (j=0; j<16; j++)
                 {
                     PRINTF( "%.2X",
                         *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset + j));
                 }
                 PRINTF( "%s", NewLineForFields(i) );
             }
             break;

          case FieldTypeULong:
          case FieldTypeLong:
              PRINTF( "%-16d%s",
                  *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeShort:
              PRINTF( "%-16X%s",
                  *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeUShort:
              PRINTF( "%-16X%s",
                  *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeUnicodeString:
              PrintStringW( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
              PRINTF( NewLine );
              break;

          case FieldTypeAnsiString:
              PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
              PRINTF( NewLine );
              break;

          case FieldTypeSymbol:
              {
                  UCHAR SymbolName[ 200 ];
                  ULONG Displacement;
                  PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ));

                  lpGetSymbolRoutine( sym, SymbolName, &Displacement );
                  PRINTF( "%-16s%s",
                          SymbolName,
                          NewLineForFields(i) );
              }
              break;

          case FieldTypeEnum:
              {
                 ULONG EnumValue;
                 ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
                 // Get the associated numericla value.

                 EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

                 if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                      != NULL) {
                     //
                     // An auxilary textual description of the value is
                     // available. Display it instead of the numerical value.
                     //

                     LPSTR pEnumName = NULL;

                     while (pEnumValueDescr->EnumName != NULL) {
                         if (EnumValue == pEnumValueDescr->EnumValue) {
                             pEnumName = pEnumValueDescr->EnumName;
                             break;
                         }
                     }

                     if (pEnumName != NULL) {
                         PRINTF( "%-16s ", pEnumName );
                     } else {
                         PRINTF( "%-4d (%-10s) ", EnumValue,"@$#%^&*");
                     }

                 } else {
                     //
                     // No auxilary information is associated with the ehumerated type
                     // print the numerical value.
                     //
                     PRINTF( "%-16d",EnumValue);
                 }
              }
              break;

          case FieldTypeStruct:
              PRINTF( "@%-15X%s",
                  ((PUCHAR)dwAddress + pFieldDescriptors->Offset ),
                  NewLineForFields(i) );
              break;

          case FieldTypeLargeInteger:
          case FieldTypeFileTime:
          default:
              ERROR( "Unrecognized field type %c for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
              break;
        }
    }
}

LPSTR LibCommands[] = {
    "columns <d> -- controls the number of columns in the display ",
    "logdump <Log Address>\n",
    "dump <Struct Type Name>@<address expr>, for eg: !netbtkd.dump tNBTCONFIG@xxxxxx ",
    "devices <netbt!NbtConfig>",
    "connections <netbt!NbtConfig>",
    "verifyll <ListHead> [<Verify>]",
    "cache [Local|Remote]",
    0
};

BOOL
help(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    int i;

    SETCALLBACKS();

    for( i=0; Extensions[i]; i++ )
        PRINTF( "   %s\n", Extensions[i] );

    for( i=0; LibCommands[i]; i++ )
        PRINTF( "   %s\n", LibCommands[i] );

    return TRUE;
}


BOOL
columns(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG NoOfColumns;
    int   i;

    SETCALLBACKS();

    sscanf(lpArgumentString,"%ld",&NoOfColumns);

    if (NoOfColumns > s_MaxNoOfColumns) {
        // PRINTF( "No. Of Columns exceeds maximum(%ld) -- directive Ignored\n", s_MaxNoOfColumns );
    } else {
        s_NoOfColumns = NoOfColumns;
    }

    PRINTF("Not Yet Implemented\n");

    return TRUE;
}



BOOL
globals(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PVOID dwAddress;
    CHAR buf[ 100 ];
    int i;
    int c=0;

    SETCALLBACKS();

    strcpy( buf, "srv!" );

    for( i=0; GlobalBool[i]; i++, c++ ) {
        BOOL b;

        strcpy( &buf[4], GlobalBool[i] );
        dwAddress = (PVOID) (lpGetExpressionRoutine) (buf);
        if( dwAddress == 0 ) {
            ERROR( "Unable to get address of %s\n", GlobalBool[i] );
            continue;
        }
        if( !GetData( dwAddress,&b, sizeof(b)) )
            return FALSE;

        PRINTF( "%s%-30s %10s%s",
            c&1 ? "    " : "",
            GlobalBool[i],
            b ? " TRUE" : "FALSE",
            c&1 ? "\n" : "" );
    }

    for( i=0; GlobalShort[i]; i++, c++ ) {
        SHORT s;

        strcpy( &buf[4], GlobalShort[i] );
        dwAddress = (PVOID) (lpGetExpressionRoutine) ( buf );
        if( dwAddress == 0 ) {
            ERROR( "Unable to get address of %s\n", GlobalShort[i] );
            continue;
        }
        if( !GetData( dwAddress,&s,sizeof(s)) )
            return FALSE;

        PRINTF( "%s%-30s %10d%s",
            c&1 ? "    " : "",
            GlobalShort[i],
            s,
            c&1 ? "\n" : "" );
    }

    for( i=0; GlobalLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[4], GlobalLong[i] );
        dwAddress = (PVOID) (lpGetExpressionRoutine) ( buf );
        if( dwAddress == 0 ) {
            ERROR( "Unable to get address of %s\n", GlobalLong[i] );
            continue;
        }
        if( !GetData(dwAddress,&l, sizeof(l)) )
            return FALSE;

        PRINTF( "%s%-30s %10d%s",
            c&1 ? "    " : "",
            GlobalLong[i],
            l,
            c&1 ? "\n" : "" );
    }

    PRINTF( "\n" );

    return TRUE;
}


BOOL
version
(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
#if    VER_DEBUG
    char *kind = "checked";
#else
    char *kind = "free";
#endif

    SETCALLBACKS();

    PRINTF( "Redirector debugger Extension dll for %s build %u\n", kind, VER_PRODUCTBUILD );

    return TRUE;
}

#define NAME_DELIMITER '@'
#define NAME_DELIMITERS "@ "
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    ULONG             ArgumentLength = strlen(lpArgument);
    BOOLEAN           fAmbigous = FALSE;


    while ((pStructs->StructName != 0)) {
        int Result = _strnicmp(lpArgument,
                              pStructs->StructName,
                              MIN(strlen(pStructs->StructName),ArgumentLength));

        if (Result == 0) {
            if (NameIndex != INVALID_INDEX) {
                // We have encountered duplicate matches. Print out the
                // matching strings and let the user disambiguate.
               fAmbigous = TRUE;
               break;
            } else {
               NameIndex = i;
            }

        }
        pStructs++;i++;
    }

    if (fAmbigous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (_strnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(strlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}

BOOL
dump(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PVOID   dwAddress;

    SETCALLBACKS();

    if( lpArgumentString && *lpArgumentString ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = lpArgumentString;
        LPSTR lpArgs = strpbrk(lpArgumentString, NAME_DELIMITERS);
        ULONG Index;

        if (lpArgs) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {

                dwAddress = (PVOID) (lpGetExpressionRoutine)( ++lpArgs );
                if (GetData(dwAddress,DataBuffer,Structs[Index].StructSize)) {

                    PRINTF(
                        "++++++++++++++++ %s@%lx ++++++++++++++++\n",
                        Structs[Index].StructName,
                        dwAddress);
                    PrintStructFields(
                        dwAddress,
                        &DataBuffer,
                        Structs[Index].FieldDescriptors);
                    PRINTF(
                        "---------------- %s@%lx ----------------\n",
                        Structs[Index].StructName,
                        dwAddress);
                } else {
                    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                }
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
        }
    } else {
        //
        // display the list of structs currently handled.
        //

        DisplayStructs();
    }

    return TRUE;
}


BOOL
devices(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PLIST_ENTRY         pEntry;
    PLIST_ENTRY         pHead;
    tDEVICECONTEXT      *pDeviceContext;
    STRUCT_DESCRIPTOR   *pStructs = Structs;
    ULONG               Index = 0;
    tNBTCONFIG          *ConfigPtr = (tNBTCONFIG *) lpArgumentString;
    tDEVICECONTEXT      **ppNbtSmbDevice;

    PVOID dwAddress;

    SETCALLBACKS();

    if (!lpArgumentString || !(*lpArgumentString ))
    {
        ConfigPtr = (tNBTCONFIG *) lpGetExpressionRoutine ("netbt!NbtConfig");
    }
    else
    {
        ConfigPtr = (tNBTCONFIG *) lpGetExpressionRoutine (lpArgumentString);
    }
    ppNbtSmbDevice = (tDEVICECONTEXT **) lpGetExpressionRoutine ("netbt!pNbtSmbDevice");

    while (pStructs->StructName != 0)
    {
        if (!(_strnicmp("tDEVICECONTEXT", pStructs->StructName, 10)))
        {
            break;
        }
        Index++;
        pStructs++;
    }

    if (pStructs->StructName == 0)
    {
        PRINTF ("ERROR:  Could not find structure definition for <tDEVICECONTEXT>\n");
        return FALSE;
    }

    if (!GetData(ppNbtSmbDevice, DataBuffer, sizeof (tDEVICECONTEXT *)))
    {
        PRINTF ("ERROR:  Could not read pNbtSmbDevice ptr\n");
    }
    else if (!(pDeviceContext = *((tDEVICECONTEXT **) DataBuffer)))
    {
        PRINTF ("pNbtSmbDevice is NULL\n");
    }
    else if (!GetData(pDeviceContext, DataBuffer, Structs[Index].StructSize))
    {
        PRINTF ("ERROR:  Could not read pNbtSmbDevice data@ <%p>\n", pDeviceContext);
    }
    else
    {
        //
        // Dump this Device's Info
        //
        PRINTF("pNbtSmbDevice @ <%p>\n", pDeviceContext);
        PRINTF( "++++++++++++++++ %s @%lx ++++++++++++++++\n", Structs[Index].StructName, pDeviceContext);
        PrintStructFields( pDeviceContext, &DataBuffer, Structs[Index].FieldDescriptors);
        PRINTF("\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    }

    pHead = &ConfigPtr->DeviceContexts;
    if (!GetData(ConfigPtr, DataBuffer, sizeof(tNBTCONFIG)))
    {
        PRINTF ("ERROR:  Could not read NbtConfig data @<%x>\n", ConfigPtr);
        return FALSE;
    }

    //
    // Get the number of Devices attached
    //
    {
        PVOID StartAddress;
        PVOID Address;
        ULONG Count = 0;
        PVOID Buffer[4];
        UCHAR Greater = ' ';

        StartAddress = pHead;
        GetData( StartAddress, Buffer, sizeof(ULONG)*4 );
        Address = Buffer[0];

        while ((Address != StartAddress) &&
               (++Count < MAX_LIST_ELEMENTS))
        {
            GetData( Address, Buffer, sizeof(ULONG)*4 );
            Address = Buffer[0];
        }

        PRINTF( "Dumping <%d> Devices attached to NbtConfig@<%x>\n", Count, ConfigPtr);
    }

    ConfigPtr = (tNBTCONFIG *) DataBuffer;
    pEntry = ConfigPtr->DeviceContexts.Flink;

    while (pEntry != pHead)
    {
        pDeviceContext = (tDEVICECONTEXT *) CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
        if (!GetData(pDeviceContext, DataBuffer, Structs[Index].StructSize))
        {
            PRINTF ("ERROR:  Could not read DeviceContext data @<%x>\n", pDeviceContext);
            return FALSE;
        }

        //
        // Dump this Device's Info
        //
        PRINTF( "++++++++++++++++ %s @%lx ++++++++++++++++\n", Structs[Index].StructName, pDeviceContext);
        PrintStructFields( pDeviceContext, &DataBuffer, Structs[Index].FieldDescriptors);

        //
        // Go to next device
        //
        pDeviceContext = (tDEVICECONTEXT *) DataBuffer;
        pEntry = pDeviceContext->Linkage.Flink;
    }

    return (TRUE);
}

BOOL
connections(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PLIST_ENTRY         pEntry, pHead, pClientHead, pClientEntry, pConnHead, pConnEntry;
    tNBTCONFIG          *ConfigPtr;
    tADDRESSELE         *pAddressEle;
    tCLIENTELE          *pClient;
    tCONNECTELE         *pConnEle, *pSavConnEle;
    tNAMEADDR           *pNameAddr;
    tLISTENREQUESTS     *pListen;

    SETCALLBACKS();

    PRINTF ("Dumping information on all NetBT conections ...\n");

    if (!lpArgumentString || !(*lpArgumentString ))
    {
        ConfigPtr    =   (tNBTCONFIG *) lpGetExpressionRoutine ("netbt!NbtConfig");
    }
    else
    {
        ConfigPtr = (tNBTCONFIG *) (lpGetExpressionRoutine) (lpArgumentString);
    }

    pHead = &ConfigPtr->AddressHead;
    if (!GetData(ConfigPtr, DataBuffer, sizeof(tNBTCONFIG)))
    {
        PRINTF ("ERROR:  Could not read NbtConfig data @<%x>\n", ConfigPtr);
        return FALSE;
    }
    ConfigPtr = (tNBTCONFIG *) DataBuffer;
    Next3 (pHead, &pEntry, NULL, NULL);

    while (pEntry != pHead)
    {
        pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);

        Next3 (&pAddressEle->pNameAddr, &pNameAddr, NULL, NULL);
        if (!GetData(pNameAddr, DataBuffer, sizeof(tNAMEADDR)))
        {
            PRINTF ("[1] Error reading pNameAddr data @<%x>", pNameAddr);
            return FALSE;
        }
        pNameAddr = (tNAMEADDR *) DataBuffer;
        PRINTF ("Address@<%x> ==> <%-16.16s:%x>\n", pAddressEle, pNameAddr->Name, pNameAddr->Name[15]);

        pClientHead = &pAddressEle->ClientHead;
        Next3 (pClientHead, &pClientEntry, NULL, NULL);
        while (pClientEntry != pClientHead)
        {
            pClient = CONTAINING_RECORD(pClientEntry,tCLIENTELE,Linkage);
            if (!GetData(pClient, DataBuffer, sizeof(tCLIENTELE)))
            {
                PRINTF ("Error reading pClientEle data @<%p>", pClient);
                continue;
            }

            PRINTF ("\tClient@<%p> ==> pDevice=<%p>\n", pClient, ((tCLIENTELE *)DataBuffer)->pDeviceContext);

            PRINTF ("\t\t(ConnectHead):\n");
            pConnHead = &pClient->ConnectHead;
            Next3 (pConnHead, &pConnEntry, NULL, NULL);
            while (pConnEntry != pConnHead)
            {
                pSavConnEle = pConnEle = CONTAINING_RECORD(pConnEntry,tCONNECTELE,Linkage);
                if (!GetData(pConnEle, DataBuffer, sizeof(tCONNECTELE)))
                {
                    PRINTF ("[2] Error reading pConnEle data @<%x>", pConnEle);
                    return FALSE;
                }
                pConnEle = (tCONNECTELE *) DataBuffer;
                PRINTF ("\t\t ** Connection@<%x> ==> <%-16.16s:%x>:\n",
                    pSavConnEle, pConnEle->RemoteName, pConnEle->RemoteName[15]);

                Next3 (pConnEntry, &pConnEntry, NULL, NULL);
            }

            PRINTF ("\t\t(ConnectActive):\n");
            pConnHead = &pClient->ConnectActive;
            Next3 (pConnHead, &pConnEntry, NULL, NULL);
            while (pConnEntry != pConnHead)
            {
                pSavConnEle = pConnEle = CONTAINING_RECORD(pConnEntry,tCONNECTELE,Linkage);
                if (!GetData(pConnEle, DataBuffer, sizeof(tCONNECTELE)))
                {
                    PRINTF ("[3] Error reading pConnEle data @<%x>", pConnEle);
                    return FALSE;
                }
                pConnEle = (tCONNECTELE *) DataBuffer;
                PRINTF ("\t\t ** Connection@<%x> ==> <%-16.16s:%x>:\n",
                    pSavConnEle, pConnEle->RemoteName, pConnEle->RemoteName[15]);

                Next3 (pConnEntry, &pConnEntry, NULL, NULL);
            }

            PRINTF ("\t\t(ListenHead):\n");
            pConnHead = &pClient->ListenHead;
            Next3 (pConnHead, &pConnEntry, NULL, NULL);
            while (pConnEntry != pConnHead)
            {
                pSavConnEle = pConnEle = CONTAINING_RECORD(pConnEntry,tCONNECTELE,Linkage);
                if (!GetData(pConnEle, DataBuffer, sizeof(tLISTENREQUESTS)))
                {
                    PRINTF ("[4] Error reading pListen data @<%x>", pSavConnEle);
                    return FALSE;
                }
                pListen = (tLISTENREQUESTS *) DataBuffer;
                PRINTF ("\t\t ** pListen@<%p> ==> pIrp=<%p>\n", pSavConnEle, pListen->pIrp);

                Next3 (pConnEntry, &pConnEntry, NULL, NULL);
            }

            Next3 (pClientEntry, &pClientEntry, NULL, NULL);
        }
        Next3 (pEntry, &pEntry, NULL, NULL);
        PRINTF ("\n");
    }

    PRINTF( "---------------- Connections ----------------\n");

    return (TRUE);
}


BOOL
verifyll(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    PLIST_ENTRY pHead, pCurrentEntry, pNextEntry, pPreviousEntry;
    ULONG_PTR   VerifyRead, VerifyIn = 0;
    ULONG       Count = 0;
    BOOL        fVerifyIn = FALSE;
    BOOL        fListCorrupt = FALSE;

    SETCALLBACKS();

    PRINTF ("Verifying Linked list ...\n");

    if (!lpArgumentString || !(*lpArgumentString ))
    {
        PRINTF ("Usage: !NetbtKd.VerifyLL <ListHead> [<Verify]>\n");
        return FALSE;
    }
    else
    {
        //
        // lpArgumentString = "<pHead> [<Verify>]"
        //
        LPSTR lpVerify;

        while (*lpArgumentString == ' ')
        {
            lpArgumentString++;
        }
        lpVerify = strpbrk(lpArgumentString, NAME_DELIMITERS);

        pHead = (PVOID) (lpGetExpressionRoutine) (lpArgumentString);
        if (lpVerify)
        {
            VerifyIn = (lpGetExpressionRoutine) (lpVerify);
            fVerifyIn = TRUE;
        }
    }

    PRINTF ("** ListHead@<%x>, fVerifyIn=<%x>, VerifyIn=<%x>:\n\n", pHead, fVerifyIn, VerifyIn);
    PRINTF ("Verifying Flinks ...");

    // Read in the data for the first FLink in the list!
    pPreviousEntry = pHead;
    Next3 (pHead, &pCurrentEntry, NULL, NULL);
    Next3 (pCurrentEntry, &pNextEntry, NULL, &VerifyRead);

    while ((pCurrentEntry != pHead) &&
           (++Count < MAX_LIST_ELEMENTS))
    {
        if ((fVerifyIn) &&
            (VerifyRead != VerifyIn))
        {
            PRINTF ("Verify FAILURE:\n\t<%d> Elements Read so far, Previous=<%x>, Current=<%x>, Next=<%x>\n",
                Count, pPreviousEntry, pCurrentEntry, pNextEntry);
            fListCorrupt = TRUE;
            break;
        }
        pPreviousEntry = pCurrentEntry;
        pCurrentEntry = pNextEntry;
        Next3 (pCurrentEntry, &pNextEntry, NULL, &VerifyRead);
    }

    if (!fListCorrupt)
    {
        PRINTF ("SUCCESS: %s<%d> Elements!\n", (pCurrentEntry==pHead? "":"> "), Count);
    }

    PRINTF ("Verifying Blinks ...");

    Count = 0;
    fListCorrupt = FALSE;
    // Read in the data for the first BLink in the list!
    pPreviousEntry = pHead;
    Next3 (pHead, NULL, &pCurrentEntry, NULL);
    Next3 (pCurrentEntry, NULL, &pNextEntry, &VerifyRead);

    while ((pCurrentEntry != pHead) &&
           (++Count < MAX_LIST_ELEMENTS))
    {
        if ((fVerifyIn) &&
            (VerifyRead != VerifyIn))
        {
            PRINTF ("Verify FAILURE:\n\t<%d> Elements Read so far, Previous=<%x>, Current=<%x>, Next=<%x>\n",
                Count, pPreviousEntry, pCurrentEntry, pNextEntry);
            fListCorrupt = TRUE;
            break;
        }
        pPreviousEntry = pCurrentEntry;
        pCurrentEntry = pNextEntry;
        Next3 (pCurrentEntry, NULL, &pNextEntry, &VerifyRead);
    }

    if (!fListCorrupt)
    {
        PRINTF ("SUCCESS: %s<%d> Elements!\n", (pCurrentEntry==pHead? "":"> "), Count);
    }

    PRINTF( "---------------- Verify LinkedList ----------------\n");

    return (TRUE);
}


BOOL
DumpCache(
    tHASHTABLE          *pHashTable,
    enum eNbtLocation   CacheType
    )
{
    LONG                    i, NumBuckets;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    tHASHTABLE              HashTbl;
    tNAMEADDR               NameAddr, *pNameAddr;

    if (!GetData(pHashTable, &HashTbl, sizeof(tHASHTABLE)))
    {
        PRINTF ("ERROR:  Could not read %s HashTable data @<%x>\n",
            (CacheType == NBT_LOCAL ? "Local":"Remote"), pHashTable);
        return FALSE;
    }

    NumBuckets = HashTbl.lNumBuckets;
    PRINTF ("\nDumping %s Cache = <%d> buckets:\n",
        (CacheType == NBT_LOCAL ? "Local":"Remote"), NumBuckets);
    PRINTF ("[Bkt#]\t<Address>  => <Name              > |  IpAddr  | RefC |    State |       Ttl\n");
    PRINTF ("-----------------------------------------------------------------------------------\n");

    for (i=0; i < NumBuckets; i++)
    {
        pHead = &pHashTable->Bucket[i];
        Next3 (pHead, &pEntry, NULL, NULL);

        //
        // Go through each name in each bucket of the hashtable
        //
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            if (!GetData(pNameAddr, &NameAddr, sizeof(tNAMEADDR)))
            {
                PRINTF ("ERROR:  Could not read NameAddr data @<%x>\n", pNameAddr);
                return FALSE;
            }

            if ((NameAddr.Verify == LOCAL_NAME) || (NameAddr.Verify == REMOTE_NAME))
            {
                PRINTF ("[%d]\t<%x> => <%-15.15s:%2x> | %8x |    %d | %8x | %9d\n",
                    i, pNameAddr, NameAddr.Name, (NameAddr.Name[15]&0x000000ff), NameAddr.IpAddress, NameAddr.RefCount, NameAddr.NameTypeState, NameAddr.Ttl);
            }
            else
            {
                PRINTF ("ERROR:  Bad Name cache entry @ <%x>!\n", pNameAddr);
                return FALSE;
            }

            Next3 (pEntry, &pEntry, NULL, NULL);    // next hash table entry
        }
    }       // for ( .. pHashTable .. )
    return TRUE;           
}


BOOL
cache(
    DWORD                   dwCurrentPC,
    PNTKD_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    tNBTCONFIG  NbtConfig, *pConfig;
    BOOL        fDumpLocal = TRUE;      // Dump both local and remote cache by default
    BOOL        fDumpRemote = TRUE;

    SETCALLBACKS();

    if (lpArgumentString && (*lpArgumentString ))
    {
        //
        // lpArgumentString = "[Local|Remote]"
        //
        while (*lpArgumentString == ' ')
        {
            lpArgumentString++;
        }

        if ((*lpArgumentString == 'l') || (*lpArgumentString == 'L'))
        {
            fDumpRemote  = FALSE;
        }
        else if ((*lpArgumentString == 'r') || (*lpArgumentString == 'R'))
        {
            fDumpLocal  = FALSE;
        }
    }

    pConfig = (tNBTCONFIG *) lpGetExpressionRoutine ("netbt!NbtConfig");
    if (!GetData(pConfig, &NbtConfig, sizeof(tNBTCONFIG)))
    {
        PRINTF ("ERROR:  Could not read NbtConfig data @<%x>\n", pConfig);
        return FALSE;
    }

    if (fDumpLocal)
    {
        DumpCache (NbtConfig.pLocalHashTbl, NBT_LOCAL);
    }
    if (fDumpRemote)
    {
        DumpCache (NbtConfig.pRemoteHashTbl, NBT_REMOTE);
    }

    PRINTF( "---------------- Cache ----------------\n");

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\kdext\netbtkd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    netbtkd.c

Abstract:

    NETBT kd extension

Author:

    Jiandong Ruan   July 2000

Notes:
    This version is totally rewritten to support 32-bit and 64-bit debug by using
    new features of WINDBG

Revision History:

    11-Jul-2000 jruan   Support both 32-bit and 64-bit.

--*/

#include <nt.h>
#include <ntrtl.h>

#define KDEXTMODE
#define KDEXT_64BIT

#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <..\..\inc\types.h>

#define PRINTF  dprintf
#define ERROR   dprintf

EXT_API_VERSION        ApiVersion = {
        (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff),
        EXT_API_VERSION_NUMBER64, 0
    };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                ChkTarget;
ULONG64                ConfigPtr;

static char* inet_addr(ULONG ip, char* addr);

DECLARE_API(init)
{
    ReloadSymbols("netbt.sys");

    if (*args) {
        ConfigPtr = GetExpression(args);
    } else {
        ConfigPtr = GetExpression("netbt!NbtConfig");
    }
    if (ConfigPtr == 0) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }
    return;
}

__inline
ULONG
read_list_entry(
    ULONG64 addr,
    PLIST_ENTRY64 List
    )
{
    if (InitTypeRead(addr, LIST_ENTRY)) {
        return 1;
    }
    List->Flink = ReadField(Flink);
    List->Blink = ReadField(Blink);
    return 0;
}

#define READLISTENTRY   read_list_entry 

/*++
    Call callback for each entry in the list
 --*/
typedef BOOL (*LIST_FOR_EACH_CALLBACK)(ULONG64 address, PVOID);
int
ListForEach(ULONG64 address, int maximum, PVOID pContext, LIST_FOR_EACH_CALLBACK callback)
{
    LIST_ENTRY64    list;
    int             i;

    if (READLISTENTRY(address, &list)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", address);
        return (-1);
    }
    if (list.Flink == address) {
        return (-1);
    }

    if (maximum < 0) {
        maximum = 1000000;
    }
    for (i = 0; i < maximum && (list.Flink != address); i++) {
        /*
         * Allow user to break us.
         */
        if (CheckControlC()) {
            break;
        }
        callback(list.Flink, pContext);
        if (READLISTENTRY(list.Flink, &list)) {
            PRINTF ("Failed to read memory 0x%I64lx\n", list.Flink);
            return (-1);
        }
    }
    return i;
}

#define    NL      1
#define    NONL    0

#define MAX_LIST_ELEMENTS 4096

#define DEFAULT_UNICODE_DATA_LENGTH 4096
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 4096
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

LPSTR Extensions[] = {
    "Netbt debugger extensions",
    0
};

LPSTR LibCommands[] = {
    "help -- print out these messages",
    "init <nbtconfig address> -- Reload symbols for NETBT.SYS",
    "\tinit get the address of netbt!nbtconfig which will be used by other netbt kdext commands.",
    "\tIn case that the symbol table cannot be loaded, you can manually set the address.",
    "\tExamples:",
    "\t\tinit  --- reload symbols and automatically find the address of netbt!nbtconfig",
    "\t\tinit 0xfac30548 --- Force 0xfac30548 to be the address of netbt!nbtconfig",
    "dump -- is no longer supported. Please use 'dt <type> <addr>' instead",
    "\tFor example 'dt netbt!tDEVICECONTEXT 0x98765432'",
    "devices -- list all devices",
    "dev <devobj> -- dump a device",
    "connections -- list all connections",
    "cache [Local|Remote]",
    "localname <tNAMEADDR>   Display the connections associated with a local name",
    "verifyll <ListHead> [<Verify>]",
    "sessionhdr <session header>    Dump the session HDR",
    "nbtworkitems       Dump netbt workitems",
    0
};

BOOL
help(void)
{
    int i;

    for( i=0; Extensions[i]; i++ )
        PRINTF( "   %s\n", Extensions[i] );

    for( i=0; LibCommands[i]; i++ )
        PRINTF( "   %s\n", LibCommands[i] );
    return TRUE;
}

DECLARE_API(version)
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    PRINTF ( "NETBT: %s extension dll (build %d) debugging %s kernel (build %d)\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

#define NAME_DELIMITER '@'
#define NAME_DELIMITERS "@ "
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

void
dump_device(ULONG64 addr)
{
    ULONG   linkage_offset = 0;
    ULONG   tag;
    ULONG   ip, subnet_mask, assigned_ip, name_server1, name_server2;
    UCHAR   mac[6];

    if (GetFieldOffset("netbt!tDEVICECONTEXT", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }

    InitTypeRead(addr, netbt!tDEVICECONTEXT);
    tag = (ULONG)ReadField(Verify);
    if (tag != NBT_VERIFY_DEVCONTEXT && tag != NBT_VERIFY_DEVCONTEXT_DOWN) {
        addr -= linkage_offset;
        InitTypeRead(addr, netbt!tDEVICECONTEXT);
        tag = (ULONG)ReadField(Verify);
        if (tag != NBT_VERIFY_DEVCONTEXT && tag != NBT_VERIFY_DEVCONTEXT_DOWN) {
            PRINTF ("Tag not found. %I64lx may not be a valid NETBT device\n", addr + linkage_offset);
            return;
        }
    }

    PRINTF ("+++++++++++++++ tDEVICECONTEXT @ %I64lx (%s) ++++++++++++++++\n",
            addr, (tag == NBT_VERIFY_DEVCONTEXT)? "Active": "Down");
    ip = (ULONG)ReadField(IpAddress);
    assigned_ip = (ULONG)ReadField(AssignedIpAddress);
    subnet_mask = (ULONG)ReadField(SubnetMask);
    GetFieldData(addr, "netbt!tDEVICECONTEXT", "MacAddress", 6, mac);
    PRINTF ("       IP Address: %s\n", inet_addr(ip, NULL));
    PRINTF ("IP Interface Flag: %I64lx\n", ReadField(IpInterfaceFlags));
    PRINTF ("      MAC Address: %02x:%02x:%02x:%02x:%02x:%02x\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    PRINTF ("           subnet: %s\n", inet_addr(subnet_mask & ip, NULL));
    if (ip != assigned_ip) {
        PRINTF (" Assigned Address: %s\n", inet_addr(assigned_ip, NULL));
    }
    PRINTF ("      subnet mask: %s\n", inet_addr(subnet_mask, NULL));
    PRINTF ("broadcast address: %s\n", inet_addr((ULONG)ReadField(BroadcastAddress), NULL));
    PRINTF ("     network mask: %s\n", inet_addr((ULONG)ReadField(NetMask), NULL));
    name_server1 = (ULONG)ReadField(lNameServerAddress);
    name_server2 = (ULONG)ReadField(lBackupServer);
    if (name_server1 == 0) {
        PRINTF ("             WINS: <not configured>\n");
    } else if (name_server2 == 0) {
        PRINTF ("             WINS: %s\n", inet_addr(name_server1, NULL));
    } else {
        if (ReadField(SwitchedToBackup)) {
            PRINTF ("     Primary WINS: %s\n", inet_addr(name_server2, NULL));
            PRINTF ("   Secondary WINS: %s (in use)\n", inet_addr(name_server1, NULL));
        } else {
            PRINTF ("     Primary WINS: %s (in use)\n", inet_addr(name_server1, NULL));
            PRINTF ("   Secondary WINS: %s\n", inet_addr(name_server2, NULL));
        }
    }
    if (ReadField(WinsIsDown)) {
        PRINTF ("************* WINS(s) ARE DOWN ***************\n");
    }
    PRINTF ("  pFileObject: %I64lx (type netbt!tFILE_OBJECTS)\n", ReadField(pFileObjects));
    PRINTF ("TCP Session: HANDLE=%I64lx DeviceObject=%I64lx FileObject=%I64lx\n",
            ReadField(hSession), ReadField(pSessionDeviceObject), ReadField(pSessionFileObject));
    PRINTF ("TCP Control: HANDLE=%I64lx DeviceObject=%I64lx FileObject=%I64lx\n",
            ReadField(hControl), ReadField(pControlDeviceObject), ReadField(pControlFileObject));

    PRINTF ("\n");
}

/*++
    Dump a NETBT device
 --*/
DECLARE_API (dev)
{
    if (*args == 0) {
        return;
    }
    dump_device(GetExpression(args));
}

/*++
    Dump all NETBT devices
 --*/
DECLARE_API (devices)
{
    ULONG64         NbtSmbDevice;
    ULONG           Offset;
    USHORT          AdapterCounter;
    int             num;

    GetFieldValue(ConfigPtr, "netbt!tNBTCONFIG", "AdapterCount", AdapterCounter);

    /*
     * SMB device
     */
    NbtSmbDevice = GetExpression("netbt!pNbtSmbDevice");
    ReadPtr(NbtSmbDevice, &NbtSmbDevice);
    PRINTF( "Dumping SMB device\n");
    dump_device(NbtSmbDevice);

    /*
     * dump device list
     */
    if (GetFieldOffset("netbt!tNBTCONFIG", (LPSTR)"DeviceContexts", &Offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }

    num = ListForEach(ConfigPtr + Offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)dump_device);
    PRINTF ("Total devices = %d (include SMB device)\n", num + 1);

    /*
     * Check consistency
     */
    if (num != AdapterCounter) {
        PRINTF ("Inconsistent!!! Number of devices = %d in NbtConfig.AdapterCount\n", AdapterCounter);
    }
}

/*
 * call back function for dumping a list of listening request
 */
BOOL
listen_callback(ULONG64 addr, PVOID pContext)
{
    ULONG   irp_offset;
    ULONG   linkage_offset;
    ULONG64 irp_addr;

    if (GetFieldOffset("netbt!tLISTENREQUESTS", (LPSTR)"pIrp", &irp_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    if (GetFieldOffset("netbt!tLISTENREQUESTS", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    addr -= linkage_offset;
    if (ReadPtr(addr+irp_offset, &irp_addr)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    PRINTF ("\t\t ** pListen@<%I64lx> ==> pIrp = %I64lx\n", addr, irp_addr);
    return TRUE;
}

/*
 * call back function for dumping a list of connection element
 */
BOOL
connect_callback(ULONG64 addr, PVOID pContext)
{
    ULONG   linkage_offset;
    UCHAR   name[NETBIOS_NAME_SIZE];

    if (GetFieldOffset("netbt!tCONNECTELE", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    addr -= linkage_offset;

    if (GetFieldData(addr, "netbt!tCONNECTELE", "RemoteName", NETBIOS_NAME_SIZE, name)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    PRINTF ("\t\t ** Connection@<%I64lx> ==> <%-15.15s:%x>\n", addr, name, name[15]&0xff);
    return TRUE;
}

/*
 * call back function for dumping a list of client element
 */
BOOL
client_callback(ULONG64 addr, PVOID pContext)
{
    ULONG   connect_offset;
    ULONG   listen_offset;
    ULONG   active_connect_offset;
    ULONG   linkage_offset, tag;
    UCHAR   name[NETBIOS_NAME_SIZE];

    if (GetFieldOffset("netbt!tCLIENTELE", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    addr -= linkage_offset;
    if (InitTypeRead(addr, netbt!tCLIENTELE)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    tag = (ULONG)ReadField(Verify);
    if (tag == NBT_VERIFY_CLIENT) {
        PRINTF ("\tActive ");
    } else if (tag == NBT_VERIFY_CLIENT_DOWN) {
        PRINTF ("\tClosed ");
    } else {
        PRINTF ("\tClient @ %I64lx: bad client tag: %lx\n", addr, tag);
        return FALSE;
    }
    if (GetFieldData(addr, "netbt!tCLIENTELE", "EndpointName", NETBIOS_NAME_SIZE, name)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    PRINTF ("Client@<%I64lx> ==> pDevice = %I64lx\tEndpoint=<%-15.15s:%x>\n",
            addr, ReadField(pDeviceContext), name, name[15]);

    /*
     * dump the connection associated with the client element
     */
    PRINTF ("\t\t(ConnectHead):\n");
    if (GetFieldOffset("netbt!tCLIENTELE", (LPSTR)"ConnectHead", &connect_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    ListForEach(addr + connect_offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)connect_callback);

    PRINTF ("\t\t(ConnectActive)\n");
    if (GetFieldOffset("netbt!tCLIENTELE", (LPSTR)"ConnectActive", &active_connect_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    ListForEach(addr + active_connect_offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)connect_callback);

    PRINTF ("\t\t(ListenHead):\n");
    if (GetFieldOffset("netbt!tCLIENTELE", (LPSTR)"ListenHead", &listen_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }
    ListForEach(addr + listen_offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)listen_callback);

    PRINTF ("\n");
    return TRUE;
}

/*
 * call back function for dumping a list of address element
 */
BOOL
addresses_callback(ULONG64 addr, PVOID pContext)
{
    UCHAR   name[NETBIOS_NAME_SIZE];
    ULONG64 NameAddr;
    ULONG   tag, linkage_offset, client_offset;

    if (GetFieldOffset("netbt!tADDRESSELE", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT: %d of %s\n", __LINE__, __FILE__);
        return FALSE;
    }
    addr -= linkage_offset;

    if (InitTypeRead(addr, netbt!tADDRESSELE)) {
        PRINTF ("Error -- please fix symbol path for NETBT: %I64lx\n", addr);
        return FALSE;
    }
    tag = (ULONG)ReadField(Verify);

    /*
     * Check tag
     */
    if (tag != NBT_VERIFY_ADDRESS) {
        PRINTF ("ERROR: incorrect tag <%4.4s>. %lx is properly not a address element\n", tag, addr);
        return FALSE;
    }

    /*
     * Print out the address element
     */
    NameAddr = ReadField(pNameAddr);
    if (GetFieldData(NameAddr, "netbt!tNAMEADDR", "Name", NETBIOS_NAME_SIZE, name)) {
        PRINTF ("Error -- please fix symbol path for NETBT: pNameAddr=%I64lx\n", NameAddr);
        return FALSE;
    }
    PRINTF ("Address@<%I64lx> ==> <%-15.15s:%x>\n", addr, name, name[15]);

    /*
     * dump the client element associated with the address element
     */
    if (GetFieldOffset("netbt!tADDRESSELE", (LPSTR)"ClientHead", &client_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT: %I64lx\n", addr);
        return FALSE;
    }
    ListForEach(addr + client_offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)client_callback);
    return TRUE;
}

DECLARE_API(connections)
{
    ULONG   Offset;

    if (GetFieldOffset("netbt!tNBTCONFIG", (LPSTR)"AddressHead", &Offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }

    PRINTF ("Dumping information on all NetBT conections ...\n");
    ListForEach(ConfigPtr + Offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)addresses_callback);
    PRINTF( "---------------- End of Connections ----------------\n");
}

char* inet_addr(ULONG ip, char* addr)
{
    static char my_addr[16];

    if (addr == NULL) {
        addr = my_addr;
    }
    sprintf (addr, "%d.%d.%d.%d",
        (ip >> 24) & 0xff, (ip >> 16) & 0xff, (ip >> 8) & 0xff, ip & 0xff);
    return addr;
}

WCHAR*
GetUnicodeString(ULONG64 addr)
{
    USHORT  length;
    ULONG   readed_bytes;
    ULONG64 buffer = 0;
    WCHAR   *p;

    InitTypeRead(addr, netbt!UNICODE_STRING);
    length = (USHORT)ReadField(Length);
    buffer = ReadField(Buffer);
    if (buffer == 0 || length == 0) {
        return NULL;
    }

    p = (WCHAR*)LocalAlloc(LMEM_FIXED, length + sizeof(WCHAR));
    if (p == NULL) {
        return NULL;
    }
    ReadMemory(buffer, (PVOID)p, length, &readed_bytes);
    if ((USHORT)readed_bytes != length) {
        LocalFree(p);
        return NULL;
    }
    p[length/sizeof(WCHAR)] = L'\0';
    return p;
}

/*
 * call back function for dumping a list of cache entries
 */
BOOL
cache_callback(ULONG64 addr, const int *bkt)
{
    static  ULONG   addr_offset = (ULONG)(-1);
    static  ULONG   fqdn_offset = (ULONG)(-1);
    ULONG   Verify;
    UCHAR   name[NETBIOS_NAME_SIZE];
    ULONG   ip, refcnt, state, ttl;
    WCHAR   *fqdn = NULL;

    if (addr_offset == (ULONG)(-1)) {
        if (GetFieldOffset("netbt!tNAMEADDR", (LPSTR)"Linkage", &addr_offset)) {
            PRINTF ("Error -- please fix symbol path for NETBT\n");
            addr_offset = (ULONG)(-1);
            return FALSE;
        }
    }
    if (fqdn_offset == (ULONG)(-1)) {
        if (GetFieldOffset("netbt!tNAMEADDR", (LPSTR)"FQDN", &fqdn_offset)) {
            fqdn_offset = (ULONG)(-1);
        }
    }

    addr -= addr_offset;
    if (InitTypeRead(addr, netbt!tNAMEADDR)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    Verify = (ULONG)ReadField(Verify);
    if (Verify != LOCAL_NAME && Verify != REMOTE_NAME) {
        PRINTF ("ERROR: bad name cache entry @ %I64x tag %lx!\n", addr, Verify);
        return FALSE;
    }
    ip = (ULONG)ReadField(IpAddress);
    refcnt = (ULONG)ReadField(RefCount);
    state = (ULONG)ReadField(NameTypeState);
    ttl = (ULONG)ReadField(Ttl);
    if (GetFieldData(addr, "netbt!tNAMEADDR", "Name", NETBIOS_NAME_SIZE, name)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    if (fqdn_offset != (ULONG)(-1)) {
        fqdn = GetUnicodeString(addr + fqdn_offset);
    }
    PRINTF ("[%d]\t<%16.16I64lx> => <%-15.15s:%2x> | %-15.15s |    %d | %8x | %9d\n",
            *bkt, addr, name, name[15], inet_addr(ip, NULL), refcnt, state, ttl);
    if (fqdn != NULL) {
        PRINTF("\t\t%ws\n", fqdn);
        LocalFree(fqdn);
        fqdn = NULL;
    }
    PRINTF("\t\tName State:");
    if (state & NAMETYPE_QUICK) {
        PRINTF(" QUICK");
    }
    if (state & NAMETYPE_UNIQUE) {
        PRINTF(" UNIQUE");
    }
    if (state & NAMETYPE_GROUP) {
        PRINTF(" GROUP");
    }
    if (state & NAMETYPE_INET_GROUP) {
        PRINTF(" INET_GROUP");
    }
    if (state & STATE_RESOLVED) {
        PRINTF(" RESOLVED");
    }
    if (state & STATE_RELEASED) {
        PRINTF(" RELEASED");
    }
    if (state & STATE_CONFLICT) {
        PRINTF(" CONFLICT");
    }
    if (state & STATE_RESOLVING) {
        PRINTF(" RESOLVING");
    }
    if (state & REFRESH_FAILED) {
        PRINTF(" REFRESH_FAILED");
    }
    if (state & PRELOADED) {
        PRINTF(" PRELOADED");
    }
    PRINTF("\n");

    return TRUE;
}

void
dump_cache(ULONG64 addr)
{
    LONG   bucket_number;
    int    i;
    static ULONG buckets_offset = (ULONG)(-1);
    static ULONG sizeof_list;

    if (buckets_offset == (ULONG)(-1)) {
        if (GetFieldOffset("netbt!tHASHTABLE", (LPSTR)"Bucket", &buckets_offset)) {
            PRINTF ("\nError -- please fix symbol path for NETBT\n");
            return;
        }
        sizeof_list = GetTypeSize ("LIST_ENTRY");
    }
    if (InitTypeRead(addr, netbt!tHASHTABLE)) {
        PRINTF ("\nError -- please fix symbol path for NETBT\n");
        return;
    }
    bucket_number = (ULONG) ReadField(lNumBuckets);

    PRINTF (" %d buckets\n", bucket_number);
    PRINTF ("[Bkt#]\t<    Address    >  => <Name              > |      IpAddr     | RefC |   State  |       Ttl\n");
    for (i=0; i < bucket_number; i++) {
        ListForEach(addr + buckets_offset + i * sizeof_list, -1, &i, (LIST_FOR_EACH_CALLBACK)cache_callback);
    }
    PRINTF ("-----------------------------------------------------------------------------------\n");
}

DECLARE_API (cache)
{
    ULONG64 local_addr, remote_addr;

    if (InitTypeRead(ConfigPtr, netbt!tNBTCONFIG)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }
    local_addr = ReadField(pLocalHashTbl);
    remote_addr = ReadField(pRemoteHashTbl);

    if (_stricmp(args, "local") == 0) {
        PRINTF ("Dumping local cache %I64lx", local_addr);
        dump_cache (local_addr);
    } else if (_stricmp(args, "remote") == 0) {
        PRINTF ("Dumping remote cache %I64lx", remote_addr);
        dump_cache (remote_addr);
    } else {
        PRINTF ("Dumping local cache %I64lx", local_addr);
        dump_cache (local_addr);
        PRINTF ("Dumping remote cache %I64lx", remote_addr);
        dump_cache (remote_addr);
    }
    PRINTF( "---------------- Cache ----------------\n");
    return;
}

DECLARE_API (localname)
{
    ULONG   linkage_offset;
    ULONG32 tag;
    ULONG64 addr;

    if (*args == 0) {
        PRINTF ("Usage: localname pointer\n");
        return;
    }

    addr = GetExpression(args);
    if (GetFieldValue(addr, "netbt!tNAMEADDR", "Verify", tag)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }
    if (tag == REMOTE_NAME) {
        PRINTF ("%I64x is a remote name. Please use a local name.\n", addr);
        return;
    }
    if (tag == LOCAL_NAME) {
        ULONG   addr_offset;

        /*
         * GetFieldValue won't do signextended for 32-bit. Use ReadPtr
         */
        if (GetFieldOffset("netbt!tNAMEADDR", (LPSTR)"pAddressEle", &addr_offset)) {
            PRINTF ("Error -- please fix symbol path for NETBT\n");
            return;
        }
        if (ReadPtr(addr + addr_offset, &addr)) {
            PRINTF ("Error -- please fix symbol path for NETBT\n");
            return;
        }
    }
    if (GetFieldValue(addr, "netbt!tADDRESSELE", "Verify", tag)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }
    if (tag != NBT_VERIFY_ADDRESS) {
        PRINTF ("%I64x is not a local name. Please use a local name.\n", addr);
        return;
    }
    if (GetFieldOffset("netbt!tADDRESSELE", (LPSTR)"Linkage", &linkage_offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }
    addresses_callback(addr - linkage_offset, NULL);
}

ULONG
dump_field_callback(PFIELD_INFO pField, PVOID context)
{
    PRINTF ("%s, %s, %I64lx\n", pField->fName, pField->printName, pField->address);
    return 0;
}

DECLARE_API(dump)
{
    PRINTF ("dump is no longer supported because 'dt type address' is better\n");
    PRINTF ("\tFor example 'dt netbt!tDEVICECONTEXT 0x98765432'\n");
}

/*
 * read in a list entry and a ULONG following that list entry.
 */
__inline ULONG
read_list_verify(
    ULONG64 addr,
    PLIST_ENTRY64 List,
    ULONG  *verify
    )
{
    static ULONG list_size = 0;
    ULONG64 a;

    if (list_size == 0) {
        list_size = GetTypeSize("LIST_ENTRY");
    }
    if (InitTypeRead(addr, LIST_ENTRY)) {
        return 1;
    }
    List->Flink = ReadField(Flink);
    List->Blink = ReadField(Blink);
    if (GetFieldData(addr+list_size, "ULONG", NULL, sizeof(ULONG64), &a)) {
        return 1;
    }
    *verify = (ULONG)a;
    return 0;
}

DECLARE_API(verifyll)
{
    LIST_ENTRY64    list;
    ULONG64     pHead, pCurrentEntry, pNextEntry, pPreviousEntry;
    ULONG       VerifyRead, VerifyIn = 0;
    ULONG       Count = 0;
    BOOL        fVerifyIn = FALSE;
    BOOL        fListCorrupt = FALSE;

    PRINTF ("Verifying Linked list ...\n");

    if (!args || !(*args)) {
        PRINTF ("Usage: !NetbtKd.VerifyLL <ListHead>\n");
        return;
    } else {
        //
        // args = "<pHead> [<Verify>]"
        //
        LPSTR lpVerify;

        while (*args == ' ') {
            args++;
        }
        lpVerify = strpbrk(args, NAME_DELIMITERS);

        pHead = GetExpression (args);
        if (lpVerify) {
            VerifyIn = (ULONG)GetExpression (lpVerify);
            fVerifyIn = TRUE;
        }
    }

    PRINTF ("** ListHead@<%I64lx>, fVerifyIn=<%x>, VerifyIn=<%x>:\n\n", pHead, fVerifyIn, VerifyIn);
    PRINTF ("Verifying Flinks ...");

    // Read in the data for the first FLink in the list!
    pPreviousEntry = pHead;
    if (READLISTENTRY(pHead, &list)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", pHead);
        return;
    }
    pCurrentEntry = list.Flink;
    if (read_list_verify(pCurrentEntry, &list, &VerifyRead)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", pCurrentEntry);
        return;
    }
    pNextEntry = list.Flink;

    while ((pCurrentEntry != pHead) && (++Count < MAX_LIST_ELEMENTS)) {
        if (CheckControlC()) {
            break;
        }
        if ((fVerifyIn) && (VerifyRead != VerifyIn)) {
            PRINTF ("Verify FAILURE:\n\t<%d> Elements Read so far\n"
                    "\tPrevious=<%I64lx>, Current=<%I64lx>, Next=<%I64lx>\n",
                Count, pPreviousEntry, pCurrentEntry, pNextEntry);
            fListCorrupt = TRUE;
            break;
        }
        pPreviousEntry = pCurrentEntry;
        pCurrentEntry = pNextEntry;
        if (read_list_verify(pCurrentEntry, &list, &VerifyRead)) {
            PRINTF ("Failed to read memory 0x%I64lx\n", pCurrentEntry);
            return;
        }
        pNextEntry = list.Flink;
    }

    if (!fListCorrupt) {
        PRINTF ("SUCCESS: %s<%d> Elements!\n", (pCurrentEntry==pHead? "":"> "), Count);
    }

    PRINTF ("Verifying Blinks ...");
    Count = 0;
    fListCorrupt = FALSE;
    // Read in the data for the first BLink in the list!
    pPreviousEntry = pHead;
    if (READLISTENTRY(pHead, &list)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", pHead);
        return;
    }
    pCurrentEntry = list.Blink;
    if (read_list_verify(pCurrentEntry, &list, &VerifyRead)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", pCurrentEntry);
        return;
    }
    pNextEntry = list.Blink;

    while ((pCurrentEntry != pHead) && (++Count < MAX_LIST_ELEMENTS)) {
        if (CheckControlC()) {
            break;
        }
        if ((fVerifyIn) && (VerifyRead != VerifyIn)) {
            PRINTF ("Verify FAILURE:\n\t<%d> Elements Read so far\n"
                    "\tPrevious=<%I64lx>, Current=<%I64lx>, Next=<%I64lx>\n",
                Count, pPreviousEntry, pCurrentEntry, pNextEntry);
            fListCorrupt = TRUE;
            break;
        }
        pPreviousEntry = pCurrentEntry;
        pCurrentEntry = pNextEntry;
        if (read_list_verify(pCurrentEntry, &list, &VerifyRead)) {
            PRINTF ("Failed to read memory 0x%I64lx\n", pCurrentEntry);
            return;
        }
        pNextEntry = list.Blink;
    }

    if (!fListCorrupt) {
        PRINTF ("SUCCESS: %s<%d> Elements!\n", (pCurrentEntry==pHead? "":"> "), Count);
    }

    PRINTF( "---------------- Verify LinkedList ----------------\n");

    return;
}

DECLARE_API(sessionhdr)
{
    tSESSIONHDR     Hdr;
    char            called_name[34];
    char            callee_name[34];
    ULONG64         addr;
    ULONG           Size;
    int             i;

    if (!args || !(*args)) {
        PRINTF ("Usage: !NetbtKd.sessionhdr hdr\n");
        return;
    }

    addr = GetExpression(args);
    if (addr == 0) {
        return;
    }

    ReadMemory(addr, &Hdr, sizeof(Hdr), &Size);
    ReadMemory(addr + sizeof(Hdr), called_name, sizeof(called_name), &Size);
    ReadMemory(addr + sizeof(Hdr)+sizeof(called_name), callee_name, sizeof(callee_name), &Size);

    if (called_name[0] != 32 || callee_name[0] != 32) {
        PRINTF ("Error -- invalid called/callee name length called=%d, callee=%d\n",
                (unsigned)called_name[0], (unsigned)callee_name[0]);
        return;
    }

    for (i = 0; i < 16; i++) {
        called_name[i + 1] = ((called_name[i*2+1] - 'A') << 4) | (called_name[i*2+2] - 'A');
        callee_name[i + 1] = ((callee_name[i*2+1] - 'A') << 4) | (callee_name[i*2+2] - 'A');
    }
    called_name[i + 1] = 0;
    callee_name[i + 1] = 0;

    PRINTF ("called name=%15.15s<%02x>\n", called_name+1, (unsigned)called_name[16]);
    PRINTF ("callee name=%15.15s<%02x>\n", callee_name+1, (unsigned)callee_name[16]);
    return;
}

/*
 * call back function for dumping a list of workitem entries
 */
BOOL
workitem_callback(ULONG64 addr, const int *bkt)
{
    static  ULONG   WorkerRtn_offset = (ULONG)(-1);
    static  ULONG   addr_offset = (ULONG)(-1);
    ULONG64 WorkerRoutine = 0;
    ULONG64 pTracker = 0;
    ULONG64 pDeviceContext = 0;
    ULONG64 ClientCompletion = 0;
    ULONG64 ClientContext = 0;
    UCHAR ucSymbols[128];
    ULONG64 uDisplacement = 0;

    if (addr_offset == (ULONG)(-1)) {
        if (GetFieldOffset("netbt!NBT_WORK_ITEM_CONTEXT", (LPSTR)"Linkage", &addr_offset)) {
            PRINTF ("Error -- please fix symbol path for NETBT\n");
            addr_offset = (ULONG)(-1);
            return FALSE;
        }
    }
    if (WorkerRtn_offset == (ULONG)(-1)) {
        if (GetFieldOffset("netbt!NBT_WORK_ITEM_CONTEXT", (LPSTR)"WorkerRoutine", &WorkerRtn_offset)) {
            WorkerRtn_offset = (ULONG)(-1);
            return FALSE;
        }
    }

    addr -= addr_offset;
    if (InitTypeRead(addr, netbt!NBT_WORK_ITEM_CONTEXT)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return FALSE;
    }

    WorkerRoutine = ReadField(WorkerRoutine);
    ClientCompletion = ReadField(ClientCompletion);
    ClientContext = ReadField(pClientContext);
    pTracker = ReadField(pTracker);
    pDeviceContext = ReadField(pDeviceContext);

    if (0 == WorkerRoutine) {
        strcpy(ucSymbols, "null");
    } else {
        GetSymbol(WorkerRoutine, ucSymbols, &uDisplacement);
    }

    PRINTF ("%16.16I64lx : %s", addr, ucSymbols);

    if (pTracker) {
        PRINTF(" pTracker= %16.16I64lx", pTracker);
    }

    if (pDeviceContext) {
        PRINTF(" pDeviceContext= %16.16I64lx", pDeviceContext);
    }

    if (0 != ClientCompletion) {
        GetSymbol(WorkerRoutine, ucSymbols, &uDisplacement);
        PRINTF (" pClientCompletion= %s", ucSymbols);
    }

    if (0 != ClientContext) {
        PRINTF (" ClientContext= %16.16I64lx", ClientContext);
    }

    PRINTF("\n");
    return TRUE;
}


DECLARE_API(nbtworkitems)
{
    ULONG Offset = 0;

    if (GetFieldOffset("netbt!tNBTCONFIG", (LPSTR)"WorkerQList", &Offset)) {
        PRINTF ("Error -- please fix symbol path for NETBT\n");
        return;
    }

    ListForEach(ConfigPtr + Offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)workitem_callback);
}

//
// Standard Functions
//
DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_PROCESS_ATTACH:
        break;
    }

    return TRUE;
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;

    init(0, 0, 0, 0, "");
    return;
}

VOID
CheckVersion(VOID)
{
    return;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\nbtstat\vxdonly.h ===
#ifdef VXD

#ifndef _NBT_H
#define _NBT_H

//
// lifted from windef.h and ntdef.h
//
#define VOID           void
typedef void          *PVOID;
typedef char           CHAR;
typedef CHAR          *PCHAR;
typedef unsigned char  UCHAR;
typedef UCHAR         *PUCHAR;
typedef short          SHORT;
typedef unsigned short USHORT;
typedef USHORT        *PUSHORT;
typedef unsigned long  ULONG;
typedef ULONG         *PULONG;
typedef unsigned long  DWORD;
typedef int            BOOL;
typedef UCHAR          BOOLEAN;
typedef unsigned char  BYTE;
typedef unsigned short WORD;

#define APIENTRY       WINAPI
#define IN
#define OUT
#define STDOUT         stdout
#define STDERR         stderr


#include <windows.h>
#include <conio.h>
#include <stdio.h>
#include <string.h>
#include <varargs.h>
#include <stdarg.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <io.h>
#include <memory.h>
#include <ctype.h>
#include <malloc.h>
#include <time.h>
#include <nb30.h>

//
// This lifted straight from miniport.h
//
typedef double LONGLONG;
#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

//
//  These definitions work around NTisms found in various difficult to change
//  places.
//

typedef ULONG NTSTATUS ;
typedef PNCB  PIRP ;
typedef PVOID PDEVICE_OBJECT ;


#include <tdi.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <nbtioctl.h>
#include <netvxd.h>
#include <winsock.h>
#include <assert.h>


//
//  These are needed because we include windef.h rather then
//  ntddk.h, which end up not being defined
//  Also, from ntdef.h and ntstatus.h
//
#define NT_SUCCESS(err)                 ((err==TDI_SUCCESS)||(err==TDI_PENDING))

#define STATUS_SUCCESS                  0
#define STATUS_BUFFER_OVERFLOW          9
#define STATUS_INVALID_PARAMETER        10
#define STATUS_INSUFFICIENT_RESOURCES   1

#define STATUS_UNSUCCESSFUL             ((NTSTATUS)0xC0000001L)

#define CTRL_C   3

#endif  // _NBT_H

#endif  // VXD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\nbtstat\nbtstat.h ===
#ifndef VXD
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <netconp.h>

#include <assert.h>
#include <stdio.h>

#include <winsock.h>
#include <wsahelp.h>
#include <nb30.h>
#include <nbtioctl.h>

//#include "../../tcpip/commands/common/tcpcmd.h"


#else
#include "vxdonly.h"
#endif

#define PROTODB_SIZE    (_MAX_PATH + 10)
#define SERVDB_SIZE     (_MAX_PATH + 10)


#define MAX_FAST_TDI_ADDRESS 32


#define TDI_QUERY_PURGE_CACHE       97
#define TDI_QUERY_CONNECTION_LIST   98
#define TDI_QUERY_CACHE_STATUS      99
#define TDI_DHCP_TEST              133
#define TDI_BCAST_RESOLVED_NAMES   134
#define NETBIOS_NAME_SIZE 16

/*
 *  Display Modes.
 */
#define ADAPTERSTATUS            0x0001
#define ADAPTERSTATUSIP          0x0002
#define BCAST                    0x0004
#define CACHE                    0x0008
#define CONNECTION               0x0010
#define CONNECTION_ALL           0x0020
#define CONNECTION_WITH_IP       0x0040
#define CONNECTION_WITH_IP_ALL   0x0080
#define DHCP                     0x0100
#define NAMES                    0x0200
#define NAMES_ALL                0x0400
#define NAME_RELEASE_REFRESH     0x0800  // not really a display mode
#define RESYNC                   0x1000  // not really a display mode

//
enum eSTATE
{
    NBT_RECONNECTING,      // waiting for the worker thread to run NbtConnect
    NBT_IDLE,              // not Transport connection
    NBT_ASSOCIATED,        // associated with an address element
    NBT_CONNECTING,        // establishing Transport connection
    NBT_SESSION_INBOUND,   // waiting for a session request after tcp connection setup inbound
    NBT_SESSION_WAITACCEPT, // waiting for accept after a listen has been satisfied
    NBT_SESSION_OUTBOUND,  // waiting for a session response after tcp connection setup
    NBT_SESSION_UP,        // got positive response
    NBT_DISCONNECTING,     // sent a disconnect down to Tcp, but it hasn't completed yet
    NBT_DISCONNECTED      // a session has been disconnected but not closed with TCP yet
};
//
// These are other states for connections that are not explicitly used by
// NBT but are returned on the NbtQueryConnectionList call.
//
#define LISTENING   20
#define UNBOUND     21
#if 0
struct {
    long        TdiError;
    NTSTATUS    UnixError;
} UnixErrorMap[] = {
    {STATUS_INVALID_PARAMETER,EINVAL},
    {STATUS_INVALID_NETWORK_RESPONSE,ENETDOWN},
    {STATUS_INVALID_NETWORK_RESPONSE,ENODEV},
    {STATUS_INVALID_NETWORK_RESPONSE,ENXIO},
    {STATUS_NETWORK_BUSY,EBUSY},
    {STATUS_INSUFFICIENT_RESOURCES,ENOSR},
    {STATUS_ACCESS_DENIED,EACCES},
    {STATUS_LINK_FAILED,ECONNRESET},
    {STATUS_REMOTE_NOT_LISTENING,ECONNREFUSED},
    {STATUS_IO_TIMEOUT,ETIMEDOUT},
    {STATUS_BAD_NETWORK_PATH,ENETUNREACH},
    {STATUS_BAD_NETWORK_PATH,EHOSTUNREACH},
    {0,0}
};
#endif

//
// The format of Adapter Status responses
//
typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;


//              1234567890123456
#define SPACES "                "
#define ClearNcb( PNCB ) {                                          \
    RtlZeroMemory( PNCB , sizeof (NCB) );                           \
    RtlMoveMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    RtlMoveMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }

//
// the defines that do the right thing
//
NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    );

#define CALL_DRIVER     DeviceIoCtrl


//----------------------------------------------------------------------
//
//  Function Prototypes
//

typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    tREMOTE_CACHE  Names[32];
} tREMOTE;

NTSTATUS
ReadRegistry(
    IN PUCHAR  pScope
    );

NTSTATUS
GetInterfaceList(
    );

HANDLE
OpenNbt(
    IN  ULONG   Index
    );

VOID
PrintKorM(
    IN PVOID    pBytesIn
    );

NTSTATUS
GetNames(
    IN HANDLE   fd,
    IN LONG     WhichNames
    );
NTSTATUS
GetConnections(
    IN HANDLE   fd,
    IN LONG     Display
    );
NTSTATUS
Resync(
    IN HANDLE   fd
    );

NTSTATUS
ReleaseNamesThenRefresh(
    IN HANDLE   fd
    );

PCHAR
gethost(ULONG addr,
        BOOLEAN Convert);

NTSTATUS
GetBcastResolvedNames(
    IN HANDLE   fd
    );

NTSTATUS
Dhcp(
    IN HANDLE   fd
    );

VOID
FormattedDump(
    PCHAR far_p,
    LONG  len
    );
VOID
HexDumpLine(
    PCHAR       pch,
    ULONG       len,
    PCHAR       s,
    PCHAR       t
    );
NTSTATUS
AdapterStatus(
    IN HANDLE   fd,
    IN PCHAR    RemoteName
    );

NTSTATUS
AdapterStatusIpAddr(
    IN HANDLE   fd,
    IN PCHAR    RemoteName,
    IN LONG    Display
    );

NTSTATUS
GetIpAddress(
    IN HANDLE           fd,
    OUT PULONG          pIpAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\nbtstat\nbtstat.c ===
/*++

Copyright (c) 1992, 1993  Microsoft Corporation

Module Name:

    nbtinfo.c

Abstract:

    This module implements the statistics gathering and display for NBT.

Author:

    Jim Stewart                           November 18 22, 1993

Revision History:

    Shirish Koti   June 17, 1994    Modified to make code common between
                                    NT and VxD
    MohsinA,       06-Dec-96.       Synchronize stdout and stderr, messages.
                                    added nls_printf().
    MohsinA,       19-Mar-97.       Cleanup mutli adaptor fix (index).

Notes:

--*/

#include "nlstxt.h"
#ifdef CHICAGO_PRODUCT
#include "tdistat.h"
#endif  // CHICAGO_PRODUCT
#include "nbtstat.h"

#ifndef CHICAGO_PRODUCT
#include "nls.h"
#include "nhapi.h"
#endif  // !CHICAGO_PRODUCT

#if defined(DBG) || defined(DEBUG)
#define    DEBUG_PRINT(S) printf S
#else
#define    DEBUG_PRINT(S) /* nothing */
#endif

#if DBG
#define NT_DEBUG_PRINT(S) printf S
#else
#define NT_DEBUG_PRINT(S) /* nothing */
#endif


CHAR        pScope[MAX_NAME];

/**********************************************************************/

/*
 *  The following option combinations are possible:
 *
 *  (default)   Display active connections.
 *      -c  List NetBIOS remote name cache, showing dotted decimal ip addresses
 *      -N  List local NetBIOS names
 *      -n  List local NetBIOS names
 *      -R  Rsync Remote NetBIOS name cache
 *      -r  Names resolved via broadcast and via WINS
 *      -s  List Netbios Sessions converting IpAddresses through Hosts file
 *      -S  List Netbios Sessions with IP Addresses
 *      -RR Send Name Release packets to WINS and then, start Refresh
 *
 */


int display = CONNECTION;   /* things to display */


char        *state();
char        *type();
char        *name_type();
char        *status();
char        *expand();
int         usage(void);
char        *expand(char *stretch, int len, char *code);
char        *printable(char *string,char *strout);
BOOLEAN     IsInteger(char *string);

#define     BUFF_SIZE   650
ULONG       NumDevices = 0;
ULONG       NetbtIpAddress;

#ifndef CHICAGO_PRODUCT
CHAR        pDeviceInfo[NBT_MAXIMUM_BINDINGS+1][MAX_NAME+1];
#else
ULONG       pDeviceInfo[NBT_MAXIMUM_BINDINGS+1] = {0};

#define VNBT_Device_ID      0x049B
HANDLE  gNbtVxdHandle;
#endif  // !CHICAGO_PRODUCT


#define dim(X) (sizeof(X)/sizeof((X)[0]))

LPSTR MapAdapterGuidToName(LPSTR AdapterNameM)
{
    static CHAR     AdapterFriendlyNameM[MAX_NAME + 1];
    ULONG           i;
    LPSTR           AdapterGuidM;
    GUID            Guid;
    UNICODE_STRING  AdapterGuidU;
    WCHAR           AdapterGuidW[MAX_NAME+1];
    WCHAR           AdapterFriendlyNameW[MAX_NAME+1];
    DWORD           Size = dim(AdapterFriendlyNameW);

    //
    //  Get the GUID out of the device name string
    //
    for (i = strlen(AdapterNameM); i != 0; i--)
    {
        if (AdapterNameM[i] == '{')
        {
            break;
        }
    }
    if (i == 0)
    {
        return AdapterNameM;
    }

    AdapterGuidM = &AdapterNameM[i];
    i = MultiByteToWideChar (CP_ACP, 0, AdapterGuidM, -1, AdapterGuidW, dim(AdapterGuidW));
    if (i <= 0)
    {
        return AdapterNameM;
    }

    RtlInitUnicodeString (&AdapterGuidU, AdapterGuidW);
    if (STATUS_SUCCESS != RtlGUIDFromString (&AdapterGuidU, &Guid))
    {
        return AdapterNameM;
    }

    if (NO_ERROR != NhGetInterfaceNameFromDeviceGuid (&Guid, AdapterFriendlyNameW, &Size, FALSE, TRUE))
    {
        return AdapterNameM;
    }

    WideCharToMultiByte (CP_ACP, 0, AdapterFriendlyNameW, -1, AdapterFriendlyNameM, sizeof(AdapterFriendlyNameM), NULL,NULL);

    return (AdapterFriendlyNameM);
}

// ========================================================================
#define LEN_DbgPrint 1000

void
nls_printf(
    char * format,
    ...
    )
{
    va_list ap;
    char    message[LEN_DbgPrint];
    int     message_len;

    va_start( ap, format );
    message_len = vsprintf( message, format, ap );
    va_end( ap );
    assert( message_len < LEN_DbgPrint );

    NlsPutMsg( STDOUT, IDS_PLAIN_STRING, message );
}

/*****************************  M A I N  ******************************/
__cdecl
main( int argc, char * argv[] )
{


    NTSTATUS    status;
    LONG        interval=-1;
    UCHAR       RemoteName[50];
    CHAR        HostAddr[20];
    PUCHAR      Addr;
    HANDLE      NbtHandle = 0;
    ULONG       index;

    DEBUG_PRINT(("FILE %s\nBuilt on %s at %s\n", __FILE__, __DATE__, __TIME__));

    //
    //  Process arguments to determine which statistics to gather.
    //  Optional parameter is interval between statistics updates.
    //  Default is to display statistics once only.
    //
    if (argc == 1)
    {
        exit(usage());
    }

    display = 0;
    while (--argc, *++argv)
    {
        if ((argv[0][0] == '-') || (argv[0][0] == '/'))     // process option string
        {
            register char   c, *p = *argv+1;
            int             arg_exhausted = 0;

            if (*p == '\0')
            {
                exit(usage());
            }

            //
            //  Loop along this set of flags.
            //
            while (!arg_exhausted && (c = *p++))
            {
                switch (c)
                {
                    case 'a':
                    case 'A':
                        display = ADAPTERSTATUS;

                        //
                        // "A" - this means the user has given us an IP address
                        // rather than a name to do an adapter status to.
                        //
                        if (c == 'A')
                        {
                            display = ADAPTERSTATUSIP;
                        }

                        RemoteName[0] = '\0';
                        if (--argc)
                        {
                            *++argv;
                            p = *argv;

                            if ((p) && (*p) && (strlen(p) < sizeof(RemoteName)))
                            {
                                strcpy(RemoteName,p);
                            }
                            else
                            {
                                DEBUG_PRINT(("invalid name or ip address\n"));
                                exit(usage());
                            }
                            arg_exhausted = TRUE;
                        }
                        else
                        {
                            DEBUG_PRINT(("Need name or ip address\n"));
                        }
                        break;

                    case 'c':
                        display = CACHE;
                        break;

                    case 'n':
                    case 'N':
                        display = NAMES;
                        break;

                    case 'r':
                        display = BCAST;

                        break;

                    case 'R':
                        if (*p == 'R')
                        {
                            p++;
                            display = NAME_RELEASE_REFRESH;
                        }
                        else
                        {
                            display = RESYNC;
                        }
                        break;

                    case 's':
                        display = CONNECTION;
                        break;

                    case 'S':
                        display = CONNECTION_WITH_IP;
                        break;

                    default:    /* unrecognized flag */
                        DEBUG_PRINT(("Unrecognized flag %s\n", argv[0] ));
                        exit(usage());
                }
            }
        }
        else if (IsInteger(*argv))
        {
            interval = (int) atoi( * argv );
        }
        else
        {
            DEBUG_PRINT(("invalid time interval\n"));
            exit(usage());
        }
    }   // while (argc ...)

    if ( display == 0 )
    {
        DEBUG_PRINT(("nothing to display?\n"));
        exit(usage());
    }

    // ====================================================================

    //
    // Get the list of interfaces to which NetBT is currently bound
    //
    status = GetInterfaceList ();
    if (!NT_SUCCESS(status))
    {
        NlsPutMsg(STDERR, IDS_FAILURE_NBT_DRIVER);
        exit(1);
    }

    if (0 == NumDevices)
    {
        NlsPutMsg(STDERR, IDS_FAILED_NBT_NO_DEVICES);
        exit(1);
    }

    //
    //  Loop forever, sleeping for "interval" seconds between cycles.
    //  If (interval < 0), return after one cycle.
    //
    //  Note that we're nice boys who close all devices while we're
    //  sleeping (after all, it is possible to say "netstat 5000"!).
    //  This probably doesn't help much, but it's a nice gesture...
    //
    do
    {
        for (index=0; index < NumDevices; index++)
        {
            //
            //  Open the device of the appropriate streams module to start with.
            //
            NbtHandle = OpenNbt (index);
            if (NbtHandle < 0)
            {
                if (!(display & (BCAST | RESYNC)))
                {
#ifndef CHICAGO_PRODUCT
                    nls_printf ("\tFailed to access NBT Device %s",
                             MapAdapterGuidToName (pDeviceInfo[index]));
#else
                    nls_printf ("\tFailed to access NBT Device, Lana # %d",
                             NbtHandle);
#endif  // CHICAGO_PRODUCT
                }

                //
                // Try the next binding!
                //
                continue;
            }

            GetIpAddress (NbtHandle,&NetbtIpAddress);
            Addr = (PUCHAR) &NetbtIpAddress;
            //
            // print out the Device name + Ip Address of this node
            //
            if (!(display & (BCAST | RESYNC | NAME_RELEASE_REFRESH)))
            {
#ifndef CHICAGO_PRODUCT
                nls_printf ("\n%s:\n", MapAdapterGuidToName (pDeviceInfo[index]));
#else
                nls_printf ("\nLana # %d:\n", pDeviceInfo[index]);
#endif  // CHICAGO_PRODUCT
                sprintf(HostAddr,"%d.%d.%d.%d", Addr[3], Addr[2], Addr[1], Addr[0]);
                NlsPutMsg(STDOUT, IDS_STATUS_FIELDS, HostAddr, pScope);
            }

            switch (display)
            {
                case ADAPTERSTATUS:
                case ADAPTERSTATUSIP:

                    if (RemoteName[0] == '\0')
                    {
                        usage();
                        interval = -1;
                    }
                    else
                    {
                        status = AdapterStatusIpAddr (NbtHandle, RemoteName, display);
                    }

                    break;

                case BCAST:
                    status = GetBcastResolvedNames (NbtHandle);
                    break;

                case CACHE:
                case NAMES:
                    status = GetNames(NbtHandle, display);
                    break;

                case RESYNC:
                    status = Resync (NbtHandle);
                    break;

                case NAME_RELEASE_REFRESH:
                    status = ReleaseNamesThenRefresh (NbtHandle);
                    break;

                case CONNECTION:
                case CONNECTION_WITH_IP:

                    status = GetConnections (NbtHandle,display);
                    break;

                default:
                    usage();
                    interval = -1;

                    break;

            }   // switch

#ifndef CHICAGO_PRODUCT
            NtClose (NbtHandle);       // Close everything while we sleep.
#endif

            if (display & (BCAST | RESYNC | NAME_RELEASE_REFRESH))
            {
                if (NT_SUCCESS (status))
                {
                        break;               // break only for the case(s) above
                }
            }
        }   // for (index ...)


        //
        //  Go to sleep for the appropriate interval until the
        //  next round, or exit if this is a once-only job.
        //
        if (interval > 0)
        {
            Sleep (interval*1000);    // ms.
        }
    } while (interval > 0);

#ifdef CHICAGO_PRODUCT
    if (!CloseHandle (gNbtVxdHandle))
    {
        DEBUG_PRINT(("CloseHandle FAILed:  Handle=<%x>, Error=<%x>\n", gNbtVxdHandle, GetLastError()));
    }
#endif  // CHICAGO_PRODUCT

    return 0;
}

/*  =======================================================================
 *  IsInteger
 *
 *  ENTRY Parameter   - pointer to string
 *
 *  EXIT
 *
 *  RETURNS TRUE if Parameter is a valid integer
 *
 *  ASSUMES
 *
 */

BOOLEAN
IsInteger(
    char *Parameter
    )
{
    while (*Parameter != '\0')
    {
        if ((*Parameter < '0') || (*Parameter > '9'))
        {
            return (FALSE);
        }

        Parameter++;
    }

    return (TRUE);
}

/*  =======================================================================
 *  name_type()     --  describe NBT Name types
 *
 */

char *
name_type(int t)
{
    static int  first_time = 1;
    static char group[32];
    static char unique[32];

    if (first_time) {
        first_time = 0;
        NlsSPrintf(IDS_NAMETYPE_GROUP, group, sizeof(group)-1);
        NlsSPrintf(IDS_NAMETYPE_UNIQUE, unique, sizeof(unique)-1);
    }

    if (t & GROUP_NAME)    return group;
    else                   return unique;
}

/* ========================================================================
 *  NameStatus()        --  describe NBT Name status
 *
 */

char *
NameStatus(int s)
{
    switch(s & 0x0F)
    {
        case DUPLICATE_DEREG:   return("CONFLICT DEREGISTERED");
        case DUPLICATE:         return("CONFLICT");
        case REGISTERING:       return("REGISTERING");
        case DEREGISTERED:      return("DEREGISTERED");
        case REGISTERED:        return("REGISTERED");
        default:                return("?");
    }
}


/* ========================================================================
 *  usage()     --  print out a standard usage message
 */

int
usage(void)
{
    //fprintf(stderr, "%s", args);
    NlsPutMsg(STDERR, IDS_USAGE);
    return(2);
}


//------------------------------------------------------------------------

/*++

Routine Description:

    This procedure converts non prinatble characaters to periods ('.')

Arguments:
    string - the string to convert
    StrOut - ptr to a string to put the converted string into

Return Value:

    a ptr to the string that was converted (Strout)

--*/

PCHAR
printable(
    IN PCHAR  string,
    IN PCHAR  StrOut
    )
{
    unsigned char *Out;
    unsigned char *cp;
    LONG     i;

    Out = StrOut;
    for (cp = string, i= 0; i < NETBIOS_NAME_SIZE; cp++,i++)
    {
        if (isprint(*cp))
        {
            *Out++ = *cp;
            continue;
        }

        if (*cp >= 128) // extended characters are ok
        {
            *Out++ = *cp;
            continue;
        }
        *Out++ = '.';
    }

    //
    // Convert to Ansi since NlsPutMsg will convert back to Oem
    // Bug # 170935
    //
    OemToCharBuffA(StrOut, StrOut, NETBIOS_NAME_SIZE);
    return(StrOut);
}

//------------------------------------------------------------------------
/*++

Routine Description:

    This function calls into netbt to get the ip address.

Arguments:

   fd - file handle to netbt
   pIpAddress - the ip address returned

Return Value:

   ntstatus

--*/



NTSTATUS
GetIpAddress(
    IN HANDLE           fd,
    OUT PULONG          pIpAddress
    )
{
    NTSTATUS    status;
    ULONG       BufferSize=100;
    PVOID       pBuffer;

    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = STATUS_BUFFER_OVERFLOW;

    status = CALL_DRIVER(fd,
                         pBuffer,
                         BufferSize,
                         IOCTL_NETBT_GET_IP_ADDRS,
                         NULL,
                         0);

    if (STATUS_SUCCESS == status)
    {
        *pIpAddress = *(ULONG *)pBuffer;
    }
    else
    {
        *pIpAddress = 0;
    }

    LocalFree(pBuffer);
    return(status);
}


//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure does an adapter status query to get the local name table.
    It either prints out the local name table or the remote (cache) table
    depending on whether WhichNames is NAMES or CACHE .

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
GetNames(
    IN HANDLE   fd,
    IN LONG     WhichNames
    )
{
    LONG                            Count;
    PVOID                           pBuffer;
    ULONG                           BufferSize=600;
    NTSTATUS                        status;
    tADAPTERSTATUS                  *pAdapterStatus;
    PUCHAR                          Addr;
    ULONG                           Ioctl;
    TDI_REQUEST_QUERY_INFORMATION   QueryInfo;
    PVOID                           pInput;
    ULONG                           SizeInput;
    NAME_BUFFER UNALIGNED           *pNames;
    CHAR                            HostAddr[20];
    CHAR                            NameOut[NETBIOS_NAME_SIZE +4];


    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = STATUS_BUFFER_OVERFLOW;

    //
    // set the correct Ioctl for the call to NBT, to get either
    // the local name table or the remote name table
    //
    if (WhichNames == NAMES)
    {
#ifndef CHICAGO_PRODUCT
        Ioctl = IOCTL_TDI_QUERY_INFORMATION;
#else
        Ioctl = IOCTL_NETBT_GET_LOCAL_NAMES;
#endif
        QueryInfo.QueryType = TDI_QUERY_ADAPTER_STATUS; // node status or whatever
        SizeInput = sizeof(TDI_REQUEST_QUERY_INFORMATION);
        pInput = &QueryInfo;
    }
    else
    {
        Ioctl = IOCTL_NETBT_GET_REMOTE_NAMES;
        SizeInput = 0;
        pInput = NULL;
    }

    while (status == STATUS_BUFFER_OVERFLOW)
    {
        status = CALL_DRIVER(fd,
                             pBuffer,
                             BufferSize,
                             Ioctl,
                             pInput,
                             SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pBuffer);

            BufferSize *=2;
            if ((BufferSize >= 0x7FFFFFFF) ||
                (!(pBuffer = LocalAlloc(LMEM_FIXED,BufferSize))))
            {
                NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
    }

    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    if ((pAdapterStatus->AdapterInfo.name_count == 0) ||
        (status != STATUS_SUCCESS))
    {
        LocalFree(pBuffer);
        NlsPutMsg(STDOUT,IDS_NONAMES_INCACHE);
        return(status);
    }

    if (WhichNames & NAMES)
    {
        NlsPutMsg(STDOUT, IDS_NETBIOS_LOCAL_STATUS);
    }
    else
    {
        NlsPutMsg(STDOUT, IDS_NETBIOS_REMOTE_STATUS);
    }

    pNames = pAdapterStatus->Names;
    Count = pAdapterStatus->AdapterInfo.name_count;
    while(Count--)
    {
        nls_printf("%-15.15s<%02.2X>  %-10s  ",
            printable(pNames->name,NameOut), pNames->name[NETBIOS_NAME_SIZE-1],name_type(pNames->name_flags));

        if (WhichNames == CACHE)
        {
            Addr = (PUCHAR) &((tREMOTE_CACHE *)pNames)->IpAddress;
            sprintf (HostAddr,"%d.%d.%d.%d", Addr[3], Addr[2], Addr[1], Addr[0]);
            nls_printf("%-20.20s" "%-d", HostAddr, *(ULONG UNALIGNED *) &((tREMOTE_CACHE *)pNames)->Ttl);

            ((tREMOTE_CACHE *)pNames)++;
        }
        else
        {
            switch(pNames->name_flags & 0x0F)
            {
                case DUPLICATE_DEREG:
                   NlsPutMsg(STDOUT,IDS_CONFLICT_DEREGISTERED);
                   break;
                case DUPLICATE:
                   NlsPutMsg(STDOUT,IDS_CONFLICT);
                   break;
                case REGISTERING:
                   NlsPutMsg(STDOUT,IDS_REGISTERING);
                   break;
                case DEREGISTERED:
                   NlsPutMsg(STDOUT,IDS_DEREGISTERED);
                   break;
                case REGISTERED:
                   NlsPutMsg(STDOUT,IDS_REGISTERED);
                   break;
                default:
                   NlsPutMsg(STDOUT,IDS_DONT_KNOW);
            }

            pNames++;
        }

        NlsPutMsg(STDOUT, IDS_NEWLINE );
    }

    LocalFree(pBuffer);
    return(status);
}

//------------------------------------------------------------------------

/*++

Routine Description:

    This procedure does an adapter status query to get the remote name table.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
AdapterStatusIpAddr(
    IN HANDLE   fd,
    IN PCHAR    RemoteNameA,
    IN LONG     Display
    )
{
    LONG                        Count;
    LONG                        i;
    PVOID                       pBuffer;
    ULONG                       BufferSize=600;
    NTSTATUS                    status;
    tADAPTERSTATUS              *pAdapterStatus;
    NAME_BUFFER                 *pNames;
    CHAR                        MacAddress[20];
    tIPANDNAMEINFO              *pIpAndNameInfo;
    ULONG                       SizeInput;
    ULONG                       IpAddress;
    OEM_STRING                  OemName;
    WCHAR                       RemoteNameW[256];
    UCHAR                       RemoteNameOem[256];
    UNICODE_STRING              RemoteNameU;
    USHORT                      NameLength;
    PUCHAR                      pRemoteName = NULL;

    if (!NetbtIpAddress)
    {
        NlsPutMsg(STDOUT,IDS_MACHINE_NOT_FOUND);
        return(STATUS_BAD_NETWORK_PATH);
    }

    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pIpAndNameInfo = LocalAlloc(LMEM_FIXED,sizeof(tIPANDNAMEINFO));
    if (!pIpAndNameInfo)
    {
        LocalFree(pBuffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = STATUS_BUFFER_OVERFLOW;
    RtlZeroMemory((PVOID)pIpAndNameInfo,sizeof(tIPANDNAMEINFO));
    if (Display == ADAPTERSTATUSIP)
    {
        //
        // Convert the remote name which is really a dotted decimal ip address
        // into a ulong
        //
        IpAddress = inet_addr(RemoteNameA);
        //
        // Don't allow zero for the address since it sends a broadcast and
        // every one responds
        //
        if ((IpAddress == INADDR_NONE) || (IpAddress == 0))
        {
            NlsPutMsg(STDOUT, IDS_BAD_IPADDRESS, RemoteNameA);
            LocalFree(pBuffer);
            LocalFree(pIpAndNameInfo);
            return(STATUS_UNSUCCESSFUL);
        }
        pIpAndNameInfo->IpAddress = ntohl(IpAddress);

        pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0] = '*';
    }
    else
    {
        //
        // the remote name was supplied by the user, so blank pad to the
        // right and put a zero on the end to get the workstation name.
        //
        RtlFillMemory(&pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0],
                      NETBIOS_NAME_SIZE, ' ');
        NameLength = (USHORT)strlen(RemoteNameA);

#ifndef CHICAGO_PRODUCT
        //
        // Convert the name from ANSI to UpperCase OEM (max length = NETBIOS_NAME_SIZE)
        // Bug # 409792
        //
        MultiByteToWideChar (CP_ACP, 0, RemoteNameA, -1, RemoteNameW, 256);
        RemoteNameW[255] = UNICODE_NULL;  // for safety
        RtlInitUnicodeString (&RemoteNameU, RemoteNameW);
        OemName.MaximumLength = 255;
        OemName.Buffer        = RemoteNameOem;
        status = RtlUpcaseUnicodeStringToOemString (&OemName, &RemoteNameU, FALSE);
        if (NT_SUCCESS (status))
        {
            status = STATUS_BUFFER_OVERFLOW;
        }
        NameLength = min (OemName.Length, NETBIOS_NAME_SIZE);
        pRemoteName = RemoteNameOem;
#else
        //
        // Chicago does not appear to have Unicode support ?
        //
        for (i=0;i < (LONG) NameLength; i++)
        {
            RemoteNameA[i] = toupper (RemoteNameA[i]);
        }

        NameLength = min (NameLength, NETBIOS_NAME_SIZE);
        pRemoteName = RemoteNameA;
#endif  // !CHICAGO_PRODUCT

        RtlMoveMemory(&pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0],
                      pRemoteName,
                      NameLength);

        pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[NETBIOS_NAME_SIZE-1] = 0;
    }

    pIpAndNameInfo->NetbiosAddress.TAAddressCount = 1;
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    SizeInput = sizeof(tIPANDNAMEINFO);

    while (status == STATUS_BUFFER_OVERFLOW)
    {

        status = CALL_DRIVER(fd,
                             pBuffer,
                             BufferSize,
                             IOCTL_NETBT_ADAPTER_STATUS,
                             pIpAndNameInfo,
                             SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pBuffer);

            BufferSize *=2;
            if ((BufferSize >= 0xFFFF) ||
                (!(pBuffer = LocalAlloc(LMEM_FIXED,BufferSize))))
            {
                NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                LocalFree(pIpAndNameInfo);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
    }

    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    if ((status != STATUS_SUCCESS) ||
        (pAdapterStatus->AdapterInfo.name_count == 0))
    {
        LocalFree(pIpAndNameInfo);
        LocalFree(pBuffer);
        NlsPutMsg(STDOUT,IDS_MACHINE_NOT_FOUND);
        return(status);
    }

    pNames = pAdapterStatus->Names;
    Count = pAdapterStatus->AdapterInfo.name_count;


    //
    // put out a heading for the table of names
    //
    NlsPutMsg(STDOUT, IDS_REMOTE_NAMES);

    while(Count--)
    {
        CHAR    NameOut[NETBIOS_NAME_SIZE +4];

        nls_printf("%-15.15s<%02.2X>  %-10s  ",
                   printable(pNames->name,NameOut),
                   pNames->name[NETBIOS_NAME_SIZE-1],
                   name_type(pNames->name_flags)
        );


        switch(pNames->name_flags & 0x0F)
        {
        case DUPLICATE_DEREG:
           NlsPutMsg(STDOUT,IDS_CONFLICT_DEREGISTERED);
           break;
        case DUPLICATE:
           NlsPutMsg(STDOUT,IDS_CONFLICT);
           break;
        case REGISTERING:
           NlsPutMsg(STDOUT,IDS_REGISTERING);
           break;
        case DEREGISTERED:
           NlsPutMsg(STDOUT,IDS_DEREGISTERED);
           break;
        case REGISTERED:
           NlsPutMsg(STDOUT,IDS_REGISTERED);
           break;
        default:
           NlsPutMsg(STDOUT,IDS_DONT_KNOW);
        }
        pNames++;

        NlsPutMsg(STDOUT, IDS_NEWLINE );
    }

    //
    // Dump the MAC address
    //
    {
        PUCHAR   a;

        a = &pAdapterStatus->AdapterInfo.adapter_address[0];
        sprintf(MacAddress,"%02.2X-%02.2X-%02.2X-%02.2X-%02.2X-%02.2X",
                    a[0],a[1],a[2],a[3],a[4],a[5]);
    }

    NlsPutMsg(STDOUT, IDS_MAC_ADDRESS, MacAddress);

    LocalFree(pIpAndNameInfo);
    LocalFree(pBuffer);
    return(status);
}

//------------------------------------------------------------------------

/*++

Routine Description:

    This procedure does gets the connection information from NBT.  If the
    Display value indicates CONNECTION_WITH_IP, then only the ip address
    of the destination is diplayed, otherwise the name of the destination
    host is displayed.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
GetConnections(
    IN HANDLE   fd,
    IN LONG     Display
    )
{
    LONG                        Count;
    PVOID                       pBuffer;
    ULONG                       BufferSize=600;
    NTSTATUS                    status;
    tCONNECTION_LIST            *pConList;
    tCONNECTIONS UNALIGNED      *pConns;

    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = STATUS_BUFFER_OVERFLOW;
    while (status == STATUS_BUFFER_OVERFLOW)
    {
        status = CALL_DRIVER(fd,
                             pBuffer,
                             BufferSize,
                             IOCTL_NETBT_GET_CONNECTIONS,
                             NULL,
                             0);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pBuffer);

            BufferSize *=2;
            if ((BufferSize >= 0xFFFF) ||
                (!(pBuffer = LocalAlloc(LMEM_FIXED,BufferSize))))
            {
                NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
    }

    pConList = (tCONNECTION_LIST *)pBuffer;
    if ((status != STATUS_SUCCESS) ||
        ((Count = pConList->ConnectionCount) == 0) )
    {
        // printf(" ntstatus = %X\n",status);
        NlsPutMsg(STDOUT,IDS_NO_CONNECTIONS);

        LocalFree(pBuffer);
        return(status);
    }

    pConns = pConList->ConnList;
    //
    // put out a heading for the table of names
    //
    NlsPutMsg(STDOUT, IDS_NETBIOS_CONNECTION_STATUS);

    while(Count--)
    {
        CHAR    NameOut[NETBIOS_NAME_SIZE +4];

        if (pConns->LocalName[0])
        {
            if (pConns->LocalName[NETBIOS_NAME_SIZE-1] < ' ')
            {
                nls_printf("%-15.15s<%02.2X>  ",
                           printable(pConns->LocalName,NameOut),
                           pConns->LocalName[NETBIOS_NAME_SIZE-1]);

            }
            else
            {
                nls_printf("%-16.16s     ", printable(pConns->LocalName,NameOut));
            }

        }

        switch (*(ULONG UNALIGNED *) &pConns->State)
        {
        case NBT_RECONNECTING:
            NlsPutMsg(STDOUT,IDS_RECONNECTING);
            break;
        case NBT_IDLE:
            NlsPutMsg(STDOUT,IDS_IDLE);
            break;
        case NBT_ASSOCIATED:
            NlsPutMsg(STDOUT,IDS_ASSOCIATED);
            break;
        case NBT_CONNECTING:
            NlsPutMsg(STDOUT,IDS_CONNECTING);
            break;
        case NBT_SESSION_OUTBOUND:
            NlsPutMsg(STDOUT,IDS_OUTGOING);
            break;
        case NBT_SESSION_INBOUND:
            NlsPutMsg(STDOUT,IDS_INCOMING);
            break;
        case NBT_SESSION_WAITACCEPT:
            NlsPutMsg(STDOUT,IDS_ACCEPTING);
            break;
        case NBT_SESSION_UP:
            NlsPutMsg(STDOUT,IDS_CONNECTED);
            break;
        case NBT_DISCONNECTING:
            NlsPutMsg(STDOUT,IDS_DISCONNECTING);
            break;
        case NBT_DISCONNECTED:
            NlsPutMsg(STDOUT,IDS_DISCONNECTED);
            break;
        case LISTENING:
            NlsPutMsg(STDOUT,IDS_LISTENING);

            break;

        case UNBOUND:
        default:
            NlsPutMsg(STDOUT,IDS_UNBOUND);
            break;
        }

        if (*(ULONG UNALIGNED *) &pConns->SrcIpAddr)
        {

            if (pConns->Originator)
            {
                NlsPutMsg(STDOUT,IDS_NETBIOS_OUTBOUND);
            }
            else
            {
                NlsPutMsg(STDOUT,IDS_NETBIOS_INBOUND);
            }

            //
            // either display the IP address or the Remote host name
            //
            if (Display & CONNECTION_WITH_IP)
            {
                PUCHAR   in;
                UCHAR    AddrBuff[30];

                in = (PUCHAR)&pConns->SrcIpAddr;

                sprintf(AddrBuff,"%u.%u.%u.%u", (unsigned char) in[0],
                    (unsigned char) in[1], (unsigned char) in[2],
                        (unsigned char) in[3]);
                nls_printf("   %-19.19s",AddrBuff);

            }
            else
            {
                nls_printf("   %-15.15s<%02.2X>",
                           printable(pConns->RemoteName,NameOut),
                           pConns->RemoteName[NETBIOS_NAME_SIZE-1]);
            }

            PrintKorM ((PVOID) &pConns->BytesRcvd);
            PrintKorM ((PVOID) &pConns->BytesSent);
        }
        else
        {
            nls_printf("                         ");

        }


        NlsPutMsg(STDOUT, IDS_NEWLINE );
        pConns++;
    }

    LocalFree(pBuffer);
    return(status);

}

//------------------------------------------------------------------------
/*++

  Routine Description:

    This procedure tells NBT to purge all names from its remote hash
    table cache.

  Arguments:


  Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
Resync(
    IN HANDLE   fd
    )
{
    NTSTATUS    status;
    CHAR        Buffer;

    status = CALL_DRIVER(fd,
                         &Buffer,
                         1,
                         IOCTL_NETBT_PURGE_CACHE,
                         NULL,
                         0);

    if (status == STATUS_SUCCESS)
    {
        NlsPutMsg(STDOUT,IDS_RESYNC_OK);
    }
    else
    {
        NlsPutMsg(STDOUT,IDS_RESYNC_FAILED);
    }
    return(status);
}

//-----------------------------------------------------------------------
/*++

  Routine Description:

    This procedure tells NBT to release all of its names on this Device and
    then Refresh them.

  Arguments:


  Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
ReleaseNamesThenRefresh(
    IN HANDLE   fd
    )
{
    NTSTATUS    status;
    CHAR        Buffer;

    status = CALL_DRIVER(fd,
                         &Buffer,
                         1,
                         IOCTL_NETBT_NAME_RELEASE_REFRESH,
                         NULL,
                         0);

    if (STATUS_SUCCESS == status)
    {
        NlsPutMsg(STDOUT,IDS_RELEASE_REFRESH_OK);
    }
    else if (status == STATUS_IO_TIMEOUT)
    {
        NlsPutMsg(STDOUT,IDS_RELEASE_REFRESH_TIMEOUT);
        status = STATUS_SUCCESS;
    }
    else
    {
        NlsPutMsg(STDOUT,IDS_RELEASE_REFRESH_ERROR);
    }

    return(status);
}

//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure tells NBT to purge all names from its remote hash
    table cache.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
GetBcastResolvedNames(
    IN HANDLE   fd
    )
{
    NTSTATUS        status;
    tNAMESTATS_INFO Stats;
    tNAME           *pName;
    LONG            Count;
    UCHAR           Value[60];

    status = CALL_DRIVER(fd,
                         &Stats,
                         sizeof(tNAMESTATS_INFO),
                         IOCTL_NETBT_GET_BCAST_NAMES,
                         NULL,
                         0);

    if (status != STATUS_SUCCESS)
    {
        NlsPutMsg(STDOUT,IDS_BCASTNAMES_FAILED);
        return(status);
    }

    NlsPutMsg(STDOUT,IDS_NAME_STATS);

    // name query stats
    sprintf(Value,"%d",Stats.Stats[0]);
    NlsPutMsg(STDOUT,IDS_NUM_BCAST_QUERIES,Value);
    sprintf(Value,"%d",Stats.Stats[2]);
    NlsPutMsg(STDOUT,IDS_NUM_WINS_QUERIES,Value);

    // Name Registration stats
    sprintf(Value,"%d",Stats.Stats[1]);
    NlsPutMsg(STDOUT,IDS_NUM_BCAST_REGISTRATIONS,Value);
    sprintf(Value,"%d",Stats.Stats[3]);
    NlsPutMsg(STDOUT,IDS_NUM_WINS_REGISTRATIONS,Value);


    pName = Stats.NamesReslvdByBcast;
    Count = 0;

    // if there are no names, then return.
    if (pName->Name[0] == '\0')
    {
        return(STATUS_SUCCESS);
    }

    NlsPutMsg(STDOUT,IDS_BCAST_NAMES_HEADER);

    while ((Count < SIZE_RESOLVD_BY_BCAST_CACHE) && (pName->Name[0] != '\0'))
    {

        // if the last character is not a space then print it in hex
        //
        if (pName->Name[NETBIOS_NAME_SIZE-1] != ' ')
        {
            nls_printf("       %15.15s<%02.2X>\n",
                   pName->Name,
                   pName->Name[NETBIOS_NAME_SIZE-1]);

        }
        else
        {
            nls_printf("       %16.16s\n",pName->Name);

        }


        pName++;
        Count++;
    }
    return(status);
}

//
// @@@@@@@@@@------ Begin NT-specific routines ------@@@@@@@@@@@
//

#ifndef CHICAGO_PRODUCT
//------------------------------------------------------------------------
NTSTATUS
GetInterfaceList(
    )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string, AnsiString;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    char                pNbtWinsDeviceName[MAX_NAME] = "\\Device\\NetBt_Wins_Export";

    PUCHAR  SubKeyParms="system\\currentcontrolset\\services\\netbt\\parameters";
    HKEY    Key;
    LONG    Type;
    ULONG   size;
    CHAR    pScopeBuffer[BUFF_SIZE];
    PUCHAR  Scope="ScopeId";

    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    ULONG                   InterfaceInfoSize=10*sizeof(NETBT_ADAPTER_INDEX_MAP)+sizeof(ULONG);
    PVOID                   pInput = NULL;
    ULONG                   SizeInput = 0;
    ULONG                   index=0;
    LONG                    i;

    pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
    if (!pInterfaceInfo)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlInitString(&name_string, pNbtWinsDeviceName);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | GENERIC_EXECUTE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    RtlFreeUnicodeString(&uc_name_string);

    if (!NT_SUCCESS (status))
    {
        LocalFree(pInterfaceInfo);
        return (status);
    }

    do
    {
        status = CALL_DRIVER (StreamHandle,
                              pInterfaceInfo,
                              InterfaceInfoSize,
                              IOCTL_NETBT_GET_INTERFACE_INFO,
                              pInput,
                              SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pInterfaceInfo);

            InterfaceInfoSize *=2;
            if ((InterfaceInfoSize >= 0xFFFF) ||
                (!(pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize))))
            {
                NtClose(StreamHandle);
                NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
        }
        else if (STATUS_SUCCESS != status)
        {
            LocalFree(pInterfaceInfo);
            NtClose(StreamHandle);
            return(status);
        }

    } while (status == STATUS_BUFFER_OVERFLOW);
    NtClose (StreamHandle);

    for (i=0; i<pInterfaceInfo->NumAdapters; i++)
    {
        RtlInitString(&name_string, NULL);
        RtlInitUnicodeString(&uc_name_string, pInterfaceInfo->Adapter[i].Name);
        if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&name_string, &uc_name_string, TRUE)))
        {
            size = (name_string.Length > MAX_NAME) ? MAX_NAME : name_string.Length;

            strncpy(pDeviceInfo[index], name_string.Buffer, size);
            pDeviceInfo[index][size] = '\0';
            RtlFreeAnsiString (&name_string);

            index++;
        }
    }

    LocalFree(pInterfaceInfo);

    //
    // NULL out the next device string ptr
    //
    if (index < NBT_MAXIMUM_BINDINGS)
    {
        pDeviceInfo[index][0] = '\0';
    }

    NumDevices = index;

    //
    // Read the ScopeId key!
    //
    size = BUFF_SIZE;
    *pScope = '\0';     // By default
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 SubKeyParms,
                 0,
                 KEY_READ,
                 &Key);

    if (status == ERROR_SUCCESS)
    {
        // now read the Scope key
        status = RegQueryValueEx(Key, Scope, NULL, &Type, pScopeBuffer, &size);
        if ((Type == REG_SZ || Type == REG_EXPAND_SZ) && status == ERROR_SUCCESS)
        {
            strcpy(pScope,pScopeBuffer);
        }
        status = RegCloseKey(Key);
    }

    return (STATUS_SUCCESS);
}


//------------------------------------------------------------------------

/*++

Routine Description:

    This function opens a stream.

Arguments:

    path        - path to the STREAMS driver
    oflag       - currently ignored.  In the future, O_NONBLOCK will be
                    relevant.
    ignored     - not used

Return Value:

    An NT handle for the stream, or INVALID_HANDLE_VALUE if unsuccessful.

--*/



HANDLE
OpenNbt(
    IN  ULONG   Index
    )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;

    assert (Index < NBT_MAXIMUM_BINDINGS);

    if (pDeviceInfo[Index][0] == '\0')
    {
        return ((HANDLE) -1);
    }

    RtlInitString (&name_string, pDeviceInfo[Index]);
    RtlAnsiStringToUnicodeString (&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes (&ObjectAttributes,
                                &uc_name_string,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL);

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | GENERIC_EXECUTE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    RtlFreeUnicodeString (&uc_name_string);

    if (!NT_SUCCESS(status))
    {
        StreamHandle = (HANDLE) -1;
    }

    return (StreamHandle);
} // OpenNbt


//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    )
{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    IO_STATUS_BLOCK                 iosb;

    status = NtDeviceIoControlFile (fd,                      // Handle
                                    NULL,                    // Event
                                    NULL,                    // ApcRoutine
                                    NULL,                    // ApcContext
                                    &iosb,                   // IoStatusBlock
                                    Ioctl,                   // IoControlCode
                                    pInput,                  // InputBuffer
                                    SizeInput,               // InputBufferSize
                                    (PVOID) ReturnBuffer,    // OutputBuffer
                                    BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject (fd,                         // Handle
                                        TRUE,                       // Alertable
                                        NULL);                      // Timeout
        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    return(status);
}


//------------------------------------------------------------------------

/*++

Routine Description:

    This procedure converts to KBytes or Mbytes

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


VOID
PrintKorM(
    IN PVOID    pBytesIn
    )
{
    LARGE_INTEGER   BytesIn = *(LARGE_INTEGER UNALIGNED *) pBytesIn;
    LARGE_INTEGER   Bytes;

    if (BytesIn.QuadPart > (ULONGLONG)1000)
    {
        Bytes = RtlExtendedLargeIntegerDivide(BytesIn,1000,NULL);
        if (Bytes.QuadPart > (ULONGLONG)1000)
        {
            Bytes = RtlExtendedLargeIntegerDivide(Bytes,1000,NULL);
            if (Bytes.QuadPart > (ULONGLONG)1000)
            {
                Bytes = RtlExtendedLargeIntegerDivide(Bytes,1000,NULL);

                nls_printf("%6dGB ",Bytes.LowPart);
            }
            else
            {
                nls_printf("%6dMB ",Bytes.LowPart);
            }
        }
        else
        {
            nls_printf("%6dKB ",Bytes.LowPart);
        }
    }
    else
    {
        nls_printf("%6dB  ",BytesIn.LowPart);
    }

}

#else

//
// @@@@@@@@@@------ Begin CHICAGO-specific routines ------@@@@@@@@@@@
//

/*******************************************************************

    NAME:       OsOpenVxdHandle

    SYNOPSIS:   Opens a handle to the specified VxD.

    ENTRY:      VxdName - The ASCII name of the target VxD.

                VxdId - The unique ID of the target VxD.

    RETURNS:    DWORD - A handle to the target VxD if successful,
                    0 if not.

    HISTORY:
        KeithMo     16-Jan-1994 Created.
        DavidKa     18-Apr-1994 Dynamic load.

********************************************************************/
HANDLE
OsOpenVxdHandle(
    CHAR * VxdName,
    WORD   VxdId
    )
{
    HANDLE  VxdHandle;
    CHAR    VxdPath[260];

    //
    //  Build the VxD path.
    //
    lstrcpy( VxdPath, "\\\\.\\");
    lstrcat( VxdPath, VxdName);

    //
    //  Open the device.
    //
    //  First try the name without the .VXD extension.  This will
    //  cause CreateFile to connect with the VxD if it is already
    //  loaded (CreateFile will not load the VxD in this case).
    //
    VxdHandle = CreateFile (VxdPath,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_DELETE_ON_CLOSE,
                            NULL );

    if (VxdHandle == INVALID_HANDLE_VALUE)
    {
        //
        //  Not found.  Append the .VXD extension and try again.
        //  This will cause CreateFile to load the VxD.
        //
        lstrcat( VxdPath, ".VXD" );
        VxdHandle = CreateFile( VxdPath,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_DELETE_ON_CLOSE,
                                NULL );
    }

    if (VxdHandle != INVALID_HANDLE_VALUE)
    {
        return VxdHandle;
    }

    DEBUG_PRINT(("OsOpenVxdHandle: cannot open %s (%04X), error %d\n", VxdPath, VxdId, GetLastError()));
    return 0;
}   // OsOpenVxdHandle


//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure gets the entry point into the vxd (we call into this entry
    point for all the ioctl needs)

Arguments:

    VxdEntryProc: pointer to receive the entry point

Return Value:

    0 if successful, -1 otherwise.

--*/


NTSTATUS
GetInterfaceList(
    )
{
    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    ULONG                   InterfaceInfoSize= sizeof(ULONG) + (NBT_MAXIMUM_BINDINGS+1)*sizeof(NETBT_ADAPTER_INDEX_MAP);
    PVOID                   pInput = NULL;
    ULONG                   i, SizeInput = 0;
    NTSTATUS                status = STATUS_UNSUCCESSFUL;

    if (!(pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize)))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory ((PVOID)pInterfaceInfo, InterfaceInfoSize);
    if (gNbtVxdHandle = OsOpenVxdHandle("VNBT", VNBT_Device_ID))
    {
        status = CALL_DRIVER ((HANDLE) -1,
                              pInterfaceInfo,
                              InterfaceInfoSize,
                              IOCTL_NETBT_GET_INTERFACE_INFO,
                              pInput,
                              SizeInput);

        if (STATUS_SUCCESS != status)
        {
            CloseHandle (gNbtVxdHandle);
            gNbtVxdHandle = NULL;
        }
    }

    if (STATUS_SUCCESS == status)
    {
        for (i=0; i<pInterfaceInfo->NumAdapters; i++)
        {
            pDeviceInfo[i] = pInterfaceInfo->Adapter[i].LanaNumber;
        }

        NumDevices = pInterfaceInfo->NumAdapters;
    }

    LocalFree(pInterfaceInfo);
    return status;
}

//------------------------------------------------------------------------
HANDLE
OpenNbt(
    IN  ULONG   Index
    )
{
    return ((HANDLE) pDeviceInfo[Index]);
}


//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure is a wrapper which makes the calls to the entry point

Arguments:

    VxdEntryProc: pointer the entry point
    pOutBuffer  : buffer to receive data in from the vxd, if applicable
    OutBufLen   : length of the output buffer
    Ioctl       : what request is this?
    pInBuffer   : ptr to the input buffer passed to netbt
    InBufLen    : size of the input buffer

Return Value:

    None

--*/

NTSTATUS
DeviceIoCtrl(
    HANDLE  LanaNumber,
    PVOID   pOutBuffer,
    ULONG   OutBufLen,
    ULONG   Ioctl,
    PVOID   pInBuffer,
    ULONG   InBufLen
    )
{
    USHORT              usIoctl;
    USHORT              usOutBufLen;
    DWORD               ActualInBufLen;
    PCHAR               pBufferData, pInBufferCopy;
    NTSTATUS            status = STATUS_SUCCESS;
    tNBT_IOCTL_HEADER   *pIoctlHeader;
    DWORD               BytesOut = 0;

    usOutBufLen = (USHORT)OutBufLen;
    usIoctl = (USHORT)Ioctl;

    //
    // vxd will copy the return code in the first 4 bytes of input buffer
    // to make sure we don't trash the input buffer that we received even
    // though it's probably not important, or to provide an input buffer
    // if we weren't given one, we allocate new memory and copy into it
    //
    if (InBufLen < sizeof(NTSTATUS))
    {
        ActualInBufLen = (USHORT) (FIELD_OFFSET (tNBT_IOCTL_HEADER, UserData) + sizeof (NTSTATUS));
    }
    else
    {
        ActualInBufLen = (USHORT) (FIELD_OFFSET (tNBT_IOCTL_HEADER, UserData) + InBufLen);
    }

    if (!(pInBufferCopy = malloc (ActualInBufLen)))
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    if (((LONG) LanaNumber) >= 0)
    {
        pIoctlHeader = (tNBT_IOCTL_HEADER *) pInBufferCopy;
        pIoctlHeader->Signature = NBT_VERIFY_VXD_IOCTL;
        pIoctlHeader->LanaNumber = (ULONG) LanaNumber;
        pBufferData = (PCHAR) &pIoctlHeader->UserData;
    }
    else
    {
        pBufferData = pInBufferCopy;
    }
    RtlMoveMemory (pBufferData, pInBuffer, (USHORT) InBufLen);

    if (DeviceIoControl (gNbtVxdHandle,
                         Ioctl,
                         pInBufferCopy,
                         ActualInBufLen,
                         pOutBuffer,
                         OutBufLen,
                         &BytesOut,
                         FALSE))
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        status = GetLastError();
        //
        // Since VNbt could return Tdi error status, remap it
        //
        if (status == TDI_BUFFER_OVERFLOW)
        {
            status = STATUS_BUFFER_OVERFLOW;
        }
    }

    free (pInBufferCopy);

    return( status );
}

//------------------------------------------------------------------------
/*++

Routine Description:

    This procedure converts to KBytes or Mbytes

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/


VOID
PrintKorM(
    IN PVOID    pBytesIn
    )
{
    ULONG   BytesIn = *(ULONG UNALIGNED *) pBytesIn;
    ULONG   Bytes;

    if ( BytesIn > 1000 )
    {
        Bytes = BytesIn/1000;
        if ( Bytes > 1000 )
        {
            Bytes = Bytes/1000;
            if (Bytes > 1000 )
            {
                Bytes = Bytes/1000;

                nls_printf("%6dGB ",Bytes);
            }
            else
            {
                nls_printf("%6dMB ",Bytes);
            }
        }
        else
        {
            nls_printf("%6dKB ",Bytes);
        }
    }
    else
    {
        nls_printf("%6dB  ",BytesIn);
    }
}

#endif  // !CHICAGO_PRODUCT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\cache.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    cache.h

Abstract:

    DNS name cache and preloaded name

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __CACHE_H__
#define __CACHE_H__

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\nbtstat\vxdtxt.h ===
//
//  These strings have been pulled from localmsg.mc for NT.  Attempt is made
//  to keep these strings in exactly the same format as in NT.  This is the
//  extent of localization we can have in the vxd world.
//

#define COMMON_UNABLE_TO_ALLOCATE_PACKET   "\nUnable to allocate packet"

#define IDS_FAILURE_NBT_DRIVER  "\nFailed to access NBT driver"

#define IDS_BLANK   " "

#define IDS_NETBIOS_LOCAL_STATUS  "\n\
            NetBIOS Local Name Table\n\
\n\
   Name               Type         Status\n\
---------------------------------------------\n"

#define IDS_STATUS_FIELDS  "\nNode IpAddress: [%s] Scope Id: [%s]"

#define IDS_NONAMES_INCACHE  "No names in cache"

#define IDS_NO_CONNECTIONS   "\nNo Connections"

#define IDS_NETBIOS_CONNECTION_STATUS  "\n\
                 NetBIOS Connection Table\n\
\n\
Local Name             State    In/Out  Remote Host           Input   Output\n\
----------------------------------------------------------------------------\n"

#define IDS_MACHINE_NOT_FOUND   "Host not found."

#define IDS_MAC_ADDRESS         "\nMAC Address = %s"

#define IDS_BAD_IPADDRESS   \
"\nThe IP address is not in the correct format. It needs to be\n\
dotted decimal, for example 11.11.12.13\n\
You entered \"%s\""

#define IDS_REMOTE_NAMES   \
"\n       NetBIOS Remote Machine Name Table\n\
\n\
   Name               Type         Status\n\
---------------------------------------------\n"

#define IDS_NETBIOS_REMOTE_STATUS   "\n\
              NetBIOS Remote Cache Name Table\n\
\n\
    Name              Type       Host Address    Life [sec]\n\
------------------------------------------------------------\n"

#define IDS_RESYNC_OK   "\n\
Successful purge and preload of the NBT Remote Cache Name Table."

#define IDS_RESYNC_FAILED   "\n\
Failed to Purge the NBT Remote Cache Table."

#define IDS_NETBIOS_OUTBOUND   "  Out"

#define IDS_NETBIOS_INBOUND    "  In"

#define IDS_RECONNECTING   "Reconnect"

#define IDS_IDLE           "Idle"

#define IDS_ASSOCIATED     "Associated"

#define IDS_CONNECTING     "Connecting"

#define IDS_OUTGOING       "Out-going"

#define IDS_INCOMING       "In-coming"

#define IDS_ACCEPTING      "Accepting"

#define IDS_CONNECTED      "Connected"

#define IDS_DISCONNECTING  "Disconnecting"

#define IDS_DISCONNECTED   "Disconnected"

#define IDS_LISTENING      "Listening"

#define IDS_UNBOUND        "Unbound"

#define IDS_CONFLICT_DEREGISTERED   "Conflict - Deregistered"

#define IDS_CONFLICT                "Conflict"

#define IDS_REGISTERING             "Registering"

#define IDS_REGISTERED              "Registered"

#define IDS_DEREGISTERED            "Deregistered"

#define IDS_DONT_KNOW               "??"

#define IDS_BCAST_NAMES_HEADER      "\n\
\n\
    NetBIOS Names Resolved By Broadcast\n\
---------------------------------------------\n"

#define IDS_NUM_BCAST_QUERIES   "\nResolved By Broadcast     = %s"

#define IDS_NUM_BCAST_REGISTRATIONS   "\nRegistered By Broadcast   = %s"

#define IDS_NUM_WINS_QUERIES    "\nResolved By Name Server   = %s"

#define IDS_NUM_WINS_REGISTRATIONS   "\nRegistered By Name Server = %s"

#define IDS_BCASTNAMES_FAILED   "\n\
Retrieval of Broadcast Resolved names failed."

#define IDS_NAME_STATS   "\n\
\n\
NetBIOS Names Resolution and Registration Statistics\n\
----------------------------------------------------\n"

#define IDS_USAGE  \
"\n\
Displays protocol statistics and current TCP/IP connections using NBT\
(NetBIOS over TCP/IP).\
\n\
NBTSTAT [-a RemoteName] [-A IP address] [-c] [-n]\n\
        [-r] [-R] [-s] [S] [interval] ]\n\
  -a   (adapter status) Lists the remote machine's name table given its name\n\
  -A   (Adapter status) Lists the remote machine's name table given its\n\
                        IP address.\n\
  -c   (cache)          Lists the remote name cache including the IP addresses\n\
  -n   (names)          Lists local NetBIOS names.\n\
  -r   (resolved)       Lists names resolved by broadcast and via WINS\n\
  -R   (Reload)         Purges and reloads the remote cache name table\n\
  -S   (Sessions)       Lists sessions table with the destination IP addresses\n\
  -s   (sessions)       Lists sessions table converting destination IP\n\
                        addresses to host names via the hosts file.\n\
\n\
  RemoteName   Remote host machine name.\n\
  IP address   Dotted decimal representation of the IP address.\n\
  interval     Redisplays selected statistics, pausing interval seconds\n\
               between each display. Press Ctrl+C to stop redisplaying\n\
               statistics.\n"

#define IDS_PLAIN_STRING "%s"
#define IDS_NEWLINE      "\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\common.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    common.h

Abstract:

    Platform independent utility functions

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __COMMON_H__
#define __COMMON_H__

////////////////////////////////////////////////////////////////////////////////
// The common routines for handling SMB objects
////////////////////////////////////////////////////////////////////////////////
typedef enum {
    SMB_REF_CREATE,
    SMB_REF_FIND,
    SMB_REF_DPC,
    SMB_REF_ASSOCIATE,
    SMB_REF_CONNECT,
    SMB_REF_DISCONNECT,
    SMB_REF_SEND,
    SMB_REF_RECEIVE,
    SMB_REF_TDI,
    SMB_REF_MAX
} SMB_REF_CONTEXT;

//
// Forward declaration of SMB_OBJECT
//
struct _SMB_OBJECT;
typedef struct _SMB_OBJECT SMB_OBJECT, *PSMB_OBJECT;
typedef VOID (*PSMB_OBJECT_CLEANUP)(PSMB_OBJECT);
struct _SMB_OBJECT {
    LIST_ENTRY          Linkage;
    ULONG               Tag;
    LONG                RefCount;
    KSPIN_LOCK          Lock;

    PSMB_OBJECT_CLEANUP CleanupRoutine;
#ifdef REFCOUNT_DEBUG
    LONG                RefContext[SMB_REF_MAX];
#endif
};

void __inline
SmbInitializeObject(PSMB_OBJECT ob, ULONG Tag, PSMB_OBJECT_CLEANUP cleanup)
{
    ASSERT(cleanup);

    InitializeListHead(&ob->Linkage);
    ob->RefCount = 1;
    ob->CleanupRoutine = cleanup;
    ob->Tag = Tag;
#ifdef REFCOUNT_DEBUG
    RtlZeroMemory(ob->RefContext, sizeof(ob->RefContext));
    ob->RefContext[SMB_REF_CREATE] = 1;
#endif
}

void __inline
SmbReferenceObject(PSMB_OBJECT ob, SMB_REF_CONTEXT ctx)
{
    //
    // When the object is created, the refcount is initialized as 1
    // It is impossible for someone to reference an object whose
    // creation reference has been removed.
    //
    ASSERT(ob->RefCount > 0);
    InterlockedIncrement(&ob->RefCount);
#ifdef REFCOUNT_DEBUG
    ASSERT(ob->RefContext[ctx] >= 0);
    InterlockedIncrement(&ob->RefContext[ctx]);
#else
    UNREFERENCED_PARAMETER(ctx);
#endif
}

void __inline
SmbDereferenceObject(PSMB_OBJECT ob, SMB_REF_CONTEXT ctx)
{
    ASSERT(ob->RefCount > 0);

#ifdef REFCOUNT_DEBUG
    ASSERT(ob->RefContext[ctx] > 0);
    InterlockedDecrement(&ob->RefContext[ctx]);
#else
    UNREFERENCED_PARAMETER(ctx);
#endif

    if (0 == InterlockedDecrement(&ob->RefCount)) {
#ifdef REFCOUNT_DEBUG
        LONG    i;

        for (i = 0; i < SMB_REF_MAX; i++) {
            ASSERT(ob->RefContext[i] == 0);
        }
#endif
        ob->CleanupRoutine(ob);
    }
}

#endif  // __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\dgram.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    dgram.h

Abstract:

    Datagram service

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __DGRAM_H__
#define __DGRAM_H__


NTSTATUS
SmbSendDatagram(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbReceiveDatagram(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\fileio.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    fileio.h

Abstract:

    A set of function similar to fopen, fclose, fgetc

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __FILEIO_H__
#define __FILEIO_H__

#define SMB_FILEIO_LOOKAHEAD_SIZE   256

typedef struct _SMB_FILE {
    HANDLE  fd;

    //
    // The offset of next byte in the Buffer
    //
    int     offset;

    //
    // The # of byte available in the Buffer
    //  When we reach the end of file, # of byte could be smaller than the buffer size
    //
    int     size;

    BYTE    Buffer[SMB_FILEIO_LOOKAHEAD_SIZE];
} SMB_FILE, *PSMB_FILE;

PSMB_FILE
Smb_fopen(
    PWCHAR  path,
    PWCHAR  mode
    );

void
Smb_fclose(
    PSMB_FILE   fp
    );

int
Smb_fgetc(
    PSMB_FILE   fp
    );

#ifndef EOF
#define EOF     (-1)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\dns.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    dns.h

Abstract:

    Kernel Mode DNS resolver

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __DNS_H__
#define __DNS_H__

#define DNS_MAX_RESOLVER    8

typedef struct {
    KSPIN_LOCK  Lock;

    ULONG       NextId;
    //
    // Resolvers
    //  An array is enough. No need to use the fancy linked-list.
    //  We don't expect more than 8 DNS resolvers. If so, having
    //  a TRUE kernel-mode DNS resolver is more meaningful than
    //  using a user-mode proxy.
    //
    LONG            ResolverNumber;
    PIRP            ResolverList[DNS_MAX_RESOLVER];

    //
    // The list of requests which are being served.
    //
    LIST_ENTRY      BeingServedList;

    //
    // The list of request waiting for the next available resolver
    //
    LIST_ENTRY      WaitingServerList;
} SMBDNS;
extern SMBDNS      Dns;

NTSTATUS
SmbNewResolver(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbInitDnsResolver(
    VOID
    );

VOID
SmbShutdownDnsResolver(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\debug.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Software Tracing

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __DEBUG_H__
#define __DEBUG_H__


#if DBG
#define SmbPrint(x,y)                                        \
        if (WPP_MASK(WPP_BIT_ ## x) & SmbCfg.DebugFlag) {    \
            DbgPrint y;                                      \
        }
#else
#   define SmbPrint(x,y)
#endif

#if DBG
#define TODO(x)         \
    do {                                                                \
        SmbPrint(SMB_TRACE_TODO, (x " %d of %s\n", __LINE__, __FILE__)); \
    } while(0)
#else
#define TODO(x)
#endif

#define BREAK_WHEN_TAKE()    \
    ASSERTMSG("This is a code path not covered in my sanity test. This break has 2 purposes:\n" \
              "\t1. indicating that we does get covered.\n"      \
              "\t2. giving me a chance to check the internal state.\n"  \
              "Please contact JRuan before you hit 'g'. ", 0);

/*
 * Pool Tags
 */
#define CLIENT_OBJECT_POOL_TAG      'cBMS'
#define CONNECT_OBJECT_POOL_TAG     'dBMS'
#define SMB_TCP_DEVICE_POOL_TAG     'IBMS'
#define SMB_POOL_REGISTRY           'rBMS'
#define TCP_CONTEXT_POOL_TAG        'tBMS'
#define NBT_HEADER_TAG              'hTBN'

#define BAIL_OUT_ON_ERROR(status)                 \
        do {                                \
            if (!NT_SUCCESS(status)) {      \
                goto cleanup;               \
            }                               \
        } while(0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\hash.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Abstract Data Type: Hash

Author:

    Jiandong Ruan

Revision History:

--*/

typedef struct SMB_HASH_TABLE *PSMB_HASH_TABLE;


typedef PVOID (*PSMB_HASH_GET_KEY)(PLIST_ENTRY entry);      // return the key stored in the entry
typedef DWORD (*PSMB_HASH)(PVOID key);
typedef VOID (*PSMB_HASH_DEL)(PLIST_ENTRY entry);
typedef VOID (*PSMB_HASH_ADD)(PLIST_ENTRY entry);           // OnAdd
typedef LONG (*PSMB_HASH_REFERENCE)(PLIST_ENTRY entry);
typedef LONG (*PSMB_HASH_DEREFERENCE)(PLIST_ENTRY entry);
typedef int (*PSMB_HASH_CMP)(PLIST_ENTRY a, PVOID key);


PSMB_HASH_TABLE
SmbCreateHashTable(
    DWORD           NumberOfBuckets,
    PSMB_HASH       HashFunc,
    PSMB_HASH_GET_KEY   GetKeyFunc,
    PSMB_HASH_CMP   CmpFunc,
    PSMB_HASH_ADD   AddFunc,                // optional
    PSMB_HASH_DEL   DelFunc,                // optional
    PSMB_HASH_REFERENCE     RefFunc,        // optional
    PSMB_HASH_DEREFERENCE   DerefFunc       // optional
    );


VOID
SmbDestroyHashTable(
    PSMB_HASH_TABLE HashTbl
    );


PLIST_ENTRY
SmbLookupHashTable(
    PSMB_HASH_TABLE HashTbl,
    PVOID           Key
    );


PLIST_ENTRY
SmbLookupHashTableAndReference(
    PSMB_HASH_TABLE HashTbl,
    PVOID           Key
    );


PLIST_ENTRY
SmbAddToHashTable(
    PSMB_HASH_TABLE HashTbl,
    PLIST_ENTRY     Entry
    );

PLIST_ENTRY
SmbRemoveFromHashTable(
    PSMB_HASH_TABLE HashTbl,
    PVOID           Key
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\ip2netbios.h ===
BOOL
GetNetbiosNameFromIp6Address(BYTE ip6[16], CHAR SmbName[16]);

VOID
FreeNetbiosNameForIp6Address(BYTE ip6[16]);

NTSTATUS
SmbInitIPv6NetbiosMappingTable(
    VOID
    );

VOID
SmbShutdownIPv6NetbiosMappingTable(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\init.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    init.h

Abstract:

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __INIT_H__
#define __INIT_H__

NTSTATUS
SmbInitRegistry(
    IN PUNICODE_STRING  RegistryPath
    );

VOID
SmbShutdownRegistry(
    VOID
    );

VOID
SmbShutdownTdi(
    VOID
    );

NTSTATUS
SmbInitTdi(
    VOID
    );

NTSTATUS
SmbCreateSmbDevice(
    PSMB_DEVICE     *ppDevice,
    USHORT          Port,
    UCHAR           EndpointName[NETBIOS_NAME_SIZE]
    );

NTSTATUS
SmbDestroySmbDevice(
    PSMB_DEVICE     pDevice
    );

VOID
SmbShutdownPnP(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\ioctl.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

    Implement IOCTL of SMB6

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __IOCTL_H__
#define __IOCTL_H__

NTSTATUS
SmbCloseControl(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbCreateControl(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbQueryInformation(
    PSMB_DEVICE Device,
    PIRP        Irp,
    BOOL        *bComplete
    );

NTSTATUS
SmbSetEventHandler(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbSetInformation(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbSetBindingInfo(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbClientSetTcpInfo(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
IoctlSetIPv6Protection(
    PSMB_DEVICE pDeviceObject,
    PIRP pIrp,
    PIO_STACK_LOCATION  pIrpSp
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\name.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    name.h

Abstract:

    Local Name Management

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __NAME_H__
NTSTATUS
SmbCloseClient(
    IN PSMB_DEVICE  Device,
    IN PIRP         Irp
    );

NTSTATUS
SmbCreateClient(
    IN PSMB_DEVICE  Device,
    IN PIRP         Irp,
    PFILE_FULL_EA_INFORMATION   ea
    );

PSMB_CLIENT_ELEMENT
SmbVerifyAndReferenceClient(
    PFILE_OBJECT    FileObject,
    SMB_REF_CONTEXT ctx
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\ping6.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ping6.h

Abstract:

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __PING6_H__
#define __PING6_H__

#include <ntddip6.h>

HANDLE __inline
IcmpCreateFile6(
    VOID
    )
{
    return CreateFileW(
            WIN_IPV6_DEVICE_NAME,
            0,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );
}

BOOL __inline
IcmpCloseHandle6(
    HANDLE Handle
    )
{
    return CloseHandle(Handle);
}

BOOL
IsReachable6(
    struct sockaddr_in6 *dstaddr,
    HANDLE  Handle,
    BYTE    *RcvBuffer,
    ULONG   RcvSize
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\ntpnp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ntpnp.h

Abstract:


Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __NTPNP_H__
#define __NTPNP_H__

VOID
SmbBindHandler(
    TDI_PNP_OPCODE  PnPOpCode,
    PUNICODE_STRING pDeviceName,
    PWSTR           MultiSZBindList
    );

NTSTATUS
TdiPnPPowerHandler(
    IN  PUNICODE_STRING     pDeviceName,
    IN  PNET_PNP_EVENT      PnPEvent,
    IN  PTDI_PNP_CONTEXT    Context1,
    IN  PTDI_PNP_CONTEXT    Context2
    );

NTSTATUS
SmbTdiRegister(
    IN PSMB_DEVICE  DeviceObject
    );

NTSTATUS
SmbTdiDeregister(
    IN PSMB_DEVICE  DeviceObject
    );

NTSTATUS
SmbClientSetTcpInfo(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbSetInboundIPv6Protection(
    IN PSMB_DEVICE pDeviceObject
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\ip6util.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ip6util.h

Abstract:

    IP6 utilities

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __IP6UTIL_H__
#define __IP6UTIL_H__

#ifndef htons
#define htons(x)    RtlUshortByteSwap(x)
#endif
#ifndef ntohs
#define ntohs htons
#endif

#ifndef htonl
#define htonl(x)    RtlUlongByteSwap(x)
#endif

#ifndef ntohl
#define ntohl htonl
#endif

typedef struct {
    union {
        USHORT  sin6_addr[8];
        BYTE    sin6_addr_bytes[16];
    };
    ULONG       sin6_scope_id;
} SMB_IP6_ADDRESS, *PSMB_IP6_ADDRESS;

typedef struct {
    union {
        ULONG   sin4_addr;
        BYTE    sin4_addr_bytes[4];
    };
} SMB_IP4_ADDRESS, *PSMB_IP4_ADDRESS;

typedef struct {
    enum {
        SMB_AF_INET,
        SMB_AF_INET6,
        SMB_AF_INVALID_INET6,
    } sin_family;

    union {
        SMB_IP4_ADDRESS ip4;
        SMB_IP6_ADDRESS ip6;
    };
} SMB_IP_ADDRESS, *PSMB_IP_ADDRESS;

void __inline
ip6addr_getany(
    PSMB_IP6_ADDRESS addr
    )
{
    RtlZeroMemory(addr->sin6_addr, sizeof(addr->sin6_addr));
}

void __inline
ip6addr_getloopback(
    PSMB_IP6_ADDRESS addr
    )
{
    RtlZeroMemory(addr->sin6_addr, sizeof(addr->sin6_addr));
    addr->sin6_addr[7] = 1;
    addr->sin6_scope_id = 0;
}

void __inline
hton_ip6addr(
    PSMB_IP6_ADDRESS addr
    )
{
    int i;
    BYTE    a, b;

    for (i = 0; i < 8; i++) {
        addr->sin6_addr[i] = RtlUshortByteSwap(addr->sin6_addr[i]);
    }
}

#define ntoh_ip6addr    hton_ip6addr

BOOL
inet_addr6W(
    WCHAR               *str,
    PSMB_IP6_ADDRESS    addr
    );

BOOL
inet_ntoa6W(
    WCHAR               *str,
    DWORD               Size,
    PSMB_IP6_ADDRESS    addr
    );

BOOL
inet_ntoa6(
    CHAR                *str,
    DWORD               Size,
    PSMB_IP6_ADDRESS    addr
    );

void
Inet_ntoa_nb(
    ULONG Address,
    PCHAR Buffer
    );

unsigned long PASCAL
inet_addrW(
    IN WCHAR *cp
    );

#ifndef INADDR_ANY
#   define INADDR_ANY      0
#endif

#ifndef INADDR_NONE
#   define INADDR_NONE     0
#endif

#ifndef INADDR_LOOPBACK
#   define INADDR_LOOPBACK  (0x7f000001)
#endif

int __inline
SMB_IS_LINKLOCAL(const BYTE bytes[16])
{
    return ((bytes[0] == 0xfe) && ((bytes[1] & 0xc0) == 0x80));
}

int __inline
SMB_IS_SITELOCAL(const BYTE bytes[16])
{
    return ((bytes[0] == 0xfe) && ((bytes[1] & 0xc0) == 0xc0));
}

int __inline
SMB_IS_LOOPBACK(const BYTE bytes[16])
{
    return ((bytes[0] == 0) &&
            (bytes[1] == 0) &&
            (bytes[2] == 0) &&
            (bytes[3] == 0) &&
            (bytes[4] == 0) &&
            (bytes[5] == 0) &&
            (bytes[6] == 0) &&
            (bytes[7] == 0) &&
            (bytes[8] == 0) &&
            (bytes[9] == 0) &&
            (bytes[10] == 0) &&
            (bytes[11] == 0) &&
            (bytes[12] == 0) &&
            (bytes[13] == 0) &&
            (bytes[14] == 0) &&
            (bytes[15] == 1));
}

int __inline
SMB_IS_ADDRESS_ALLOWED(const BYTE bytes[16])
{
    if (SMB_IS_LINKLOCAL(bytes) || SMB_IS_SITELOCAL(bytes) || SMB_IS_LOOPBACK(bytes)) {
        return TRUE;
    }
    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\smb.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    smb.h

Abstract:


Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __SMB_H__
#define __SMB_H__

typedef struct _SMB_DEVICE SMB_DEVICE, *PSMB_DEVICE;

NTSTATUS
SmbDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    IN OUT PDEVICE_OBJECT *SmbDevice
    );

NTSTATUS
SmbDispatchCleanup(
    IN PSMB_DEVICE      Device,
    IN PIRP             Irp
    );

NTSTATUS
SmbDispatchClose(
    IN PSMB_DEVICE      device,
    IN PIRP             Irp
    );

NTSTATUS
SmbDispatchCreate(
    IN PSMB_DEVICE      Device,
    IN PIRP             Irp
    );

NTSTATUS
SmbDispatchDevCtrl(
    IN PSMB_DEVICE      device,
    IN PIRP             Irp
    );

NTSTATUS
SmbDispatchInternalCtrl(
    IN PSMB_DEVICE      device,
    IN PIRP             Irp
    );

NTSTATUS
SmbDispatchPnP(
    IN PSMB_DEVICE      device,
    IN PIRP             Irp
    );

VOID
SmbUnload(
    IN PDRIVER_OBJECT   driver
    );

VOID
SmbAddressArrival(
    PTA_ADDRESS         Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    );

VOID
SmbAddressDeletion(
    PTA_ADDRESS         Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    );

VOID
SmbBindHandler(
    TDI_PNP_OPCODE  PnPOpCode,
    PUNICODE_STRING pDeviceName,
    PWSTR           MultiSZBindList
    );

#ifndef STANDALONE_SMB
VOID
SmbSetTdiHandles(
    HANDLE  ProviderHandle,
    HANDLE  ClientHandle
    );
#endif

#endif  //__SMB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\registry.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Registry functions

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __REGISTRY_H__
#define __REGISTRY_H__

PKEY_VALUE_FULL_INFORMATION
SmbQueryValueKey(
    HANDLE  hKey,
    LPWSTR  ValueStringName
    );

LONG
SmbReadLong(
    IN HANDLE   hKey,
    IN WCHAR    *KeyName,
    IN LONG     DefaultValue,
    IN LONG     MinimumValue
    );

ULONG
SmbReadULong(
    IN HANDLE   hKey,
    IN WCHAR    *KeyName,
    IN ULONG    DefaultValue,
    IN ULONG    MinimumValue
    );

NTSTATUS
SmbReadRegistry(
    IN HANDLE   Key,
    IN LPWSTR   ValueStringName,
    IN OUT DWORD *Type,
    IN OUT DWORD *Size,
    IN OUT PVOID *Buffer
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\session.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    session.h

Abstract:

    Implement session service

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __SESSION_H__
#define __SESSION_H__

NTSTATUS
SmbCreateConnection(
    PSMB_DEVICE Device,
    PIRP        Irp,
    PFILE_FULL_EA_INFORMATION   ea
    );

NTSTATUS
SmbCloseConnection(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbAssociateAddress(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbDisAssociateAddress(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbConnect(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbListen(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbDisconnect(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbAccept(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbSend(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

NTSTATUS
SmbReceive(
    PSMB_DEVICE Device,
    PIRP        Irp
    );

void
SmbSessionCompleteRequest(
    PSMB_CONNECT    ConnectObject,
    NTSTATUS        status,
    DWORD           information
    );

PSMB_CONNECT
SmbVerifyAndReferenceConnect(
    PFILE_OBJECT    FileObject,
    SMB_REF_CONTEXT ctx
    );

NTSTATUS
SmbDoDisconnect(
    PSMB_CONNECT    ConnectObject
    );

VOID
SmbDisconnectCleanup(
    IN PSMB_DEVICE          DeviceObject,
    IN PSMB_CLIENT_ELEMENT  ClientObject,
    IN PSMB_CONNECT         ConnectObject,
    IN PSMB_TCP_CONTEXT     TcpContext,
    IN DWORD                dwFlag,
    IN BOOL                 bWait
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\svclib.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    svclib.h

Abstract:

    Declarations for SMB service

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __SVCLIB_H__
#define __SVCLIB_H__

VOID
SmbSetTraceRoutine(
    int (*trace)(char *,...)
    );

typedef DWORD (*SMBSVC_UPDATE_STATUS)(VOID);

DWORD
SmbStartService(
    LONG                    NumWorker,
    SMBSVC_UPDATE_STATUS    HeartBeating
    );

VOID
SmbStopService(
    SMBSVC_UPDATE_STATUS    HeartBeating
    );

#endif  // __SVCLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\smbtdi.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    smbtdi.h

Abstract:

    Wrappers for TDI

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __SMBTDI_H__
#define __SMBTDI_H__

#ifndef TDI_MINIMUM_INDICATE
#define TDI_MINIMUM_INDICATE    128
#endif

#define INVALID_INTERFACE_INDEX (0xffff)

struct _SMB_ASYNC_CONTEXT;
typedef struct _SMB_ASYNC_CONTEXT SMB_ASYNC_CONTEXT, *PSMB_ASYNC_CONTEXT;

typedef void (*PSMB_TDI_COMPLETION) (
    IN PSMB_ASYNC_CONTEXT   AsyncContext
    );
struct _SMB_ASYNC_CONTEXT {
    LIST_ENTRY      Linkage;
    PVOID           AsyncInternalContext;       // Internally used by the asychn routine.

    KTIMER          Timer;
    KDPC            Dpc;

    PSMB_TDI_COMPLETION Completion;
    PVOID           ClientContext;
    DWORD           Timeout;

    NTSTATUS        status;
};

#define SMB_TDI_TIMEOUT_INFINITE    (0xffffffffU)

void __inline
SmbInitAsyncContext(
    IN OUT PSMB_ASYNC_CONTEXT Context,
    IN     PSMB_TDI_COMPLETION ClientCompletion,
    IN     PVOID               ClientContext,
    IN     DWORD               Timeout
    )
{
    PAGED_CODE();

    InitializeListHead(&Context->Linkage);

    Context->AsyncInternalContext = NULL;

    Context->Completion = ClientCompletion;
    Context->ClientContext = ClientContext;
    Context->Timeout = Timeout;
    Context->status  = STATUS_PENDING;
}

void __inline
SmbAsyncStartTimer(
    IN OUT PSMB_ASYNC_CONTEXT   Context,
    IN PKDEFERRED_ROUTINE       TimeoutCompletion
    )
{
    LARGE_INTEGER   DueTime;

    PAGED_CODE();

    if (Context->Timeout != SMB_TDI_TIMEOUT_INFINITE) {
        KeInitializeTimer(&Context->Timer);
        KeInitializeDpc(&Context->Dpc, TimeoutCompletion, Context);
        DueTime.QuadPart = -Int32x32To64(Context->Timeout, 10000);

        KeSetTimer(&Context->Timer, DueTime, &Context->Dpc);
    }
}

void __inline
SmbAsyncStopTimer(
    IN OUT PSMB_ASYNC_CONTEXT   Context
    )
{
    if (Context->Timeout != SMB_TDI_TIMEOUT_INFINITE) {
        KeCancelTimer(&Context->Timer);
    }
}

void __inline
SmbAsyncCompleteRequest(
    IN OUT PSMB_ASYNC_CONTEXT   Context
    )
{
    SmbAsyncStopTimer(Context);
    Context->Completion((PSMB_ASYNC_CONTEXT)Context);
}

/*
 * TCP Address object
 */
typedef struct {
    PDEVICE_OBJECT  DeviceObject;
    HANDLE          AddressHandle;
    PFILE_OBJECT    AddressObject;
} SMB_TCP_ADDRESS, *PSMB_TCP_ADDRESS;

VOID __inline
SmbInitTcpAddress(
    IN OUT PSMB_TCP_ADDRESS Context
    )
{
    Context->DeviceObject  = NULL;
    Context->AddressHandle = NULL;
    Context->AddressObject = NULL;
}

BOOL __inline
ValidTcpAddress(
    IN OUT PSMB_TCP_ADDRESS Context
    )
{
    return (Context->DeviceObject && Context->AddressHandle && Context->AddressObject);
}

typedef struct {
    HANDLE              ConnectHandle;
    PFILE_OBJECT        ConnectObject;
    PVOID               UpperConnect;

    // for debugging purpose.
    // We save a copy here so that we
    // can find out the upper connection
    // even when UpperConnect is null-ed
    // out.
    PVOID pLastUprCnt;
} SMB_TCP_CONNECT, *PSMB_TCP_CONNECT;

VOID __inline
SmbInitTcpConnect(
    IN OUT PSMB_TCP_CONNECT Context
    )
{
    Context->ConnectHandle = NULL;
    Context->ConnectObject = NULL;
    Context->UpperConnect  = NULL;
}

BOOL __inline
ValidTcpConnect(
    IN OUT PSMB_TCP_CONNECT Context
    )
{
    return (Context->ConnectHandle && Context->ConnectObject);
}

//
// Placeholder for IP FastQuery routine to determine InterfaceContext + metric for dest addr
//
typedef NTSTATUS
(*PIP4FASTQUERY)(
    IN   IPAddr   Address,
    OUT  PULONG   pIndex,
    OUT  PULONG   pMetric
    );
typedef NTSTATUS
(*PIP6FASTQUERY)(
    IN   PSMB_IP6_ADDRESS   Address,
    OUT  PULONG   pIndex,
    OUT  PULONG   pMetric
    );

//
// Placeholder for TCP Send routine if Fast Send is possible
// 
typedef NTSTATUS
(*PTCPSEND_DISPATCH) (
   IN PIRP Irp,
   IN PIO_STACK_LOCATION irpsp
   );

//
// SMB is bound to either TCP4 or TCP6, or both.
// We have a record for each binding.
//
// We use this data structure to cache our connection object with TCP
// Opening new TCP connection can only be done at PASSIVE level. However,
// due to the following reasons, we need a TCP connection object at
// DISPATCH level,
//  1. For outbound request, we don't know whether we're going to use TCP4
//     or TCP6 until the name resoltuion is done. Our DNS name resolution
//     completion routine could be called at DISPATCH level.
//  2. For inbound requests, we don't know whether we're going to use TCP4
//     or TCP6 until our TdiConnectHandler is called. Again, it is called
//     at DISPATCH level.
// To allow SMB get an TCP connection whenever it needs it, we use the following
// data structure to cache the connection object.
//
// The cache algorithm works as follow:
//  Parameters: L, M,   L < M
//  1. During initialization, we create M TCP connection object;
//  2. Whenever the number of connection objects goes below L, we start a
//     worker thread to bring it up to M.
//
typedef struct _SMB_TCP_INFO {
    KSPIN_LOCK      Lock;

    //
    // The TDI event context. We need this context to set TDI event handler
    //
    PVOID           TdiEventContext;

    SMB_IP_ADDRESS  IpAddress;              // The local Ip address (in Network Order)
    USHORT          Port;                   // The listening port (in network order)

    SMB_TCP_ADDRESS InboundAddressObject;   // The TCP address object we're lisening on

    LIST_ENTRY      InboundPool;
    LONG            InboundNumber;          // Number of entries in InboundPool
    LONG            InboundLow, InboundMid, InboundHigh;

    LIST_ENTRY      DelayedDestroyList;

    //
    // Control channel: used to send IOCTLs to TCP
    //
    USHORT              TcpStackSize;
    PFILE_OBJECT        TCPControlFileObject;
    PDEVICE_OBJECT      TCPControlDeviceObject;
    PFILE_OBJECT        IPControlFileObject;
    PDEVICE_OBJECT      IPControlDeviceObject;

    //
    // FastSend and FastQuery routine
    //
    PTCPSEND_DISPATCH   FastSend;
    PVOID               FastQuery;

    //
    // We use the loopback interface index to determine if an IP is local or not
    //  1. Query the outgoing interface from TCP
    //  2. If the index of outgoing interface is loopback, then the IP is a local IP.
    //
    ULONG               LoopbackInterfaceIndex;
} SMB_TCP_INFO, *PSMB_TCP_INFO;

//
// Used to store the connection information with TCP
//
typedef struct {
    LIST_ENTRY          Linkage;

    PSMB_TCP_INFO       CacheOwner;

    //
    // The IRP which is used to do the disconnect
    // This field is put here only for saving debugging time
    // When we see disconnect problem, IRP can tell us
    // where we are. (We did see the request pending in TCP forever.)
    //
    PIRP                DisconnectIrp;

    SMB_TCP_ADDRESS     Address;
    SMB_TCP_CONNECT     Connect;
} SMB_TCP_CONTEXT, *PSMB_TCP_CONTEXT;

NTSTATUS
SmbInitTCP4(
    PSMB_TCP_INFO   TcpInfo,
    USHORT          Port,
    PVOID           TdiEventContext
    );

NTSTATUS
SmbInitTCP6(
    PSMB_TCP_INFO   TcpInfo,
    USHORT          Port,
    PVOID           TdiEventContext
    );

NTSTATUS
SmbShutdownTCP(
    PSMB_TCP_INFO   TcpInfo
    );

VOID
SmbReadTCPConf(
    IN HANDLE   hKey,
    PSMB_TCP_INFO TcpInfo
    );

NTSTATUS
SmbSynchConnCache(
    PSMB_TCP_INFO   TcpInfo,
    BOOL            Cleanup
    );

PSMB_TCP_CONTEXT
SmbAllocateOutbound(
    PSMB_TCP_INFO   TcpInfo
    );

VOID
SmbFreeOutbound(
    PSMB_TCP_CONTEXT    TcpCtx
    );

PSMB_TCP_CONTEXT
SmbAllocateInbound(
    PSMB_TCP_INFO   TcpInfo
    );

VOID
SmbFreeInbound(
    PSMB_TCP_CONTEXT    TcpCtx
    );

VOID
SmbFreeTcpContext(
    PSMB_TCP_CONTEXT    TcpCtx
    );

VOID
SmbDelayedDestroyTcpContext(
    PSMB_TCP_CONTEXT    TcpCtx
    );

typedef struct _SMB_DEVICE SMB_DEVICE, *PSMB_DEVICE;
NTSTATUS
SmbWakeupWorkerThread(
    IN PSMB_DEVICE      DeviceObject
    );

VOID __inline
SmbInitTcpContext(
    IN OUT PSMB_TCP_CONTEXT Context
    )
{
    InitializeListHead(&Context->Linkage);
    Context->DisconnectIrp = NULL;
    SmbInitTcpAddress(&Context->Address);
    SmbInitTcpConnect(&Context->Connect);
}

NTSTATUS
SmbOpenTcpAddress(
    IN  PSMB_IP_ADDRESS     addr,
    IN  USHORT              port,
    IN OUT PSMB_TCP_ADDRESS context
    );

NTSTATUS
SmbOpenUdpAddress(
    IN  PSMB_IP_ADDRESS     addr,
    IN  USHORT              port,
    IN OUT PSMB_TCP_ADDRESS context
    );

NTSTATUS
SmbCloseAddress(
    IN OUT PSMB_TCP_ADDRESS context
    );

NTSTATUS
SmbOpenTcpConnection(
    IN PSMB_TCP_ADDRESS     Address,
    IN OUT PSMB_TCP_CONNECT Connect,
    IN PVOID                ConnectionContext
    );

NTSTATUS
SmbCloseTcpConnection(
    IN OUT PSMB_TCP_CONNECT Connect
    );

NTSTATUS
TdiSetEventHandler(
    PFILE_OBJECT    FileObject,
    ULONG           EventType,
    PVOID           EventHandler,
    PVOID           Context
    );

typedef struct {
    SMB_ASYNC_CONTEXT;
    ULONG           Id;         // TransactionId

    PTDI_ADDRESS_NETBIOS_UNICODE_EX pUnicodeAddress;
    UNICODE_STRING  FQDN;

    LONG            ipaddr_num;
    SMB_IP_ADDRESS  ipaddr[SMB_MAX_IPADDRS_PER_HOST];
} SMB_GETHOST_CONTEXT, *PSMB_GETHOST_CONTEXT;

BOOL
SmbLookupHost(
    WCHAR               *host,
    PSMB_IP_ADDRESS     ipaddr
    );

void
SmbAsyncGetHostByName(
    IN PUNICODE_STRING      Name,
    IN PSMB_GETHOST_CONTEXT Context
    );

typedef struct {
    SMB_ASYNC_CONTEXT;

    // Local end point
    SMB_TCP_CONNECT     TcpConnect;


    //
    // GetHostByName returns multiple IP address.
    // We try to connect to each of them until
    // we succeed in making a connection
    //

    // the result of GetHostByName
    PSMB_GETHOST_CONTEXT    pSmbGetHostContext;
    // the IP address currently being tried
    USHORT                  usCurrentIP;

    PIO_WORKITEM            pIoWorkItem;

} SMB_CONNECT_CONTEXT, *PSMB_CONNECT_CONTEXT;
typedef struct _SMB_CONNECT SMB_CONNECT, *PSMB_CONNECT;
typedef struct _SMB_DEVICE SMB_DEVICE, *PSMB_DEVICE;

typedef NTSTATUS (*PRECEIVE_HANDLER) (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    );

#ifndef __SMB_KDEXT__
void
SmbAsyncConnect(
    IN PSMB_IP_ADDRESS      ipaddr,
    IN USHORT               port,
    IN PSMB_CONNECT_CONTEXT Context
    );

NTSTATUS
SmbTcpDisconnect(
    PSMB_TCP_CONTEXT TcpContext,
    LONG             TimeoutMilliseconds,
    ULONG            Flags
    );

NTSTATUS
SmbAsynchTcpDisconnect(
    PSMB_TCP_CONTEXT        TcpContext,
    ULONG                   Flags
    );

NTSTATUS
SmbSetTcpEventHandlers(
    PFILE_OBJECT    AddressObject,
    PVOID           Context
    );

NTSTATUS
SubmitSynchTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP         Irp
    );

NTSTATUS
SmbSendIoctl(
    PFILE_OBJECT    FileObject,
    ULONG           Ioctl,
    PVOID           InBuf,
    ULONG           InBufSize,
    PVOID           OutBuf,
    ULONG           *OutBufSize
    );

NTSTATUS
SmbSetTcpInfo(
    IN PFILE_OBJECT FileObject,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG ToiId,
    IN ULONG ToiType,
    IN ULONG InfoBufferValue
    );

#define ATTACH_FSP(Attached)                                \
    do {                                                    \
        if (PsGetCurrentProcess() != SmbCfg.FspProcess) {   \
            Attached = TRUE;                                \
            KeAttachProcess((PRKPROCESS)SmbCfg.FspProcess); \
        } else {                                            \
            Attached = FALSE;                               \
        }                                                   \
    } while(0)

#define DETACH_FSP(Attached)        \
    do {                            \
        if (Attached) {             \
            KeDetachProcess();      \
        }                           \
    } while(0)

#endif  // __SMB_KDEXT__

#endif  // __SMBTDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\smbioctl.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    smbioctl.h

Abstract:

    SMB IOCTLs

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __SMBIOCTL_H__
#define __SMBIOCTL_H__

//
// This 2 IOCTLs are used at development stage.
//
#define IOCTL_SMB_START         CTL_CODE(FILE_DEVICE_TRANSPORT, 101, METHOD_BUFFERED, FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_SMB_STOP          CTL_CODE(FILE_DEVICE_TRANSPORT, 102, METHOD_BUFFERED, FILE_READ_ACCESS|FILE_WRITE_ACCESS)

//
// IOCTLs exposed to user
//
#define IOCTL_SMB_DNS                           CTL_CODE(FILE_DEVICE_TRANSPORT, 110, \
                                                METHOD_OUT_DIRECT, FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_SMB_ENABLE_NAGLING                CTL_CODE(FILE_DEVICE_TRANSPORT, 111, \
                                                METHOD_BUFFERED, FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_SMB_DISABLE_NAGLING               CTL_CODE(FILE_DEVICE_TRANSPORT, 112, \
                                                METHOD_BUFFERED, FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_SMB_SET_IPV6_PROTECTION_LEVEL     CTL_CODE(FILE_DEVICE_TRANSPORT, 113, \
                                                METHOD_BUFFERED, FILE_READ_ACCESS|FILE_WRITE_ACCESS)

    typedef struct NBSMB_IPV6_PROTECTION_PARAM {
        ULONG uIPv6ProtectionLevel;
        BOOL bIPv6EnableOutboundGlobal;
    } NBSMB_IPV6_PROTECTION_PARAM, * PNBSMB_IPV6_PROTECTION_PARAM;

//
// The following definitions are from Dns.c
//
#define DNS_NAME_BUFFER_LENGTH      (256)
#define DNS_MAX_NAME_LENGTH         (255)
#define SMB_MAX_IPADDRS_PER_HOST    (16)

//
// Type of requests (bit mask)
//
#define SMB_DNS_A                   1       // A record (IPv4) needed
#define SMB_DNS_AAAA                2       // AAAA record (IPv6) needed
#define SMB_DNS_AAAA_GLOBAL         4       // AAAA Global IPv6 record (IPv6) needed
#define SMB_DNS_RESERVED            (~(SMB_DNS_AAAA|SMB_DNS_A|SMB_DNS_AAAA_GLOBAL))

typedef struct {
    ULONG           Id;
    ULONG           RequestType;

    BOOL            Resolved;
    WCHAR           Name[DNS_NAME_BUFFER_LENGTH];
    LONG            NameLen;
    SMB_IP_ADDRESS  IpAddrsList[SMB_MAX_IPADDRS_PER_HOST];
    LONG            IpAddrsNum;
} SMB_DNS_BUFFER, *PSMB_DNS_BUFFER;

#if 0
////////////////////////////////////////////////////////////////////////////////
// The following is copied form nbtioctl.h
//      It is required for compatibility
////////////////////////////////////////////////////////////////////////////////
//
// This structure is returned by Nbt when a TdiQueryInformation()
// call asks for TDI_QUERY_ADDRESS_INFO on a connection.  This is
// the same as a TRANSPORT_ADDRESS struct from "tdi.h" containing
// two address, a NetBIOS address followed by an IP address.
//

typedef struct _NBT_ADDRESS_PAIR {
    LONG TAAddressCount;                   // this will always == 2

    struct {
        USHORT AddressLength;              // length in bytes of this address == 18
        USHORT AddressType;                // this will == TDI_ADDRESS_TYPE_NETBIOS
        TDI_ADDRESS_NETBIOS Address;
    } AddressNetBIOS;

    struct {
        USHORT AddressLength;              // length in bytes of this address == 14
        USHORT AddressType;                // this will == TDI_ADDRESS_TYPE_IP
        TDI_ADDRESS_IP Address;
    } AddressIP;

} NBT_ADDRESS_PAIR, *PNBT_ADDRESS_PAIR;

typedef struct _NBT_ADDRESS_PAIR_INFO {
    ULONG ActivityCount;                   // outstanding open file objects/this address.
    NBT_ADDRESS_PAIR AddressPair;          // the actual address & its components.
} NBT_ADDRESS_PAIR_INFO, *PNBT_ADDRESS_PAIR_INFO;
#endif

#define DD_SMB6_EXPORT_NAME          L"\\Device\\NetbiosSmb"

#include "nbtioctl.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\tdihndlr.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    tdihndlr.h

Abstract:

    TDI handlers

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __TDIHNDLR_H__
#define __TDIHNDLR_H__

NTSTATUS
SmbTdiConnectHandler(
    IN PSMB_DEVICE      DeviceObject,
    IN LONG             RemoteAddressLength,
    IN PTRANSPORT_ADDRESS RemoteAddress,
    IN LONG             UserDataLength,
    IN PVOID            UserData,
    IN LONG             OptionsLength,
    IN PVOID            Options,
    OUT CONNECTION_CONTEXT  *ConnectionContext,
    OUT PIRP                *AcceptIrp
    );

NTSTATUS 
CommonDisconnectHandler (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            DisconnectFlags
    );

NTSTATUS 
SmbTdiDisconnectHandler (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_TCP_CONNECT TcpConnect,
    IN LONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS 
Indicate (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    );

NTSTATUS 
WaitingHeader (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    );

NTSTATUS 
SmbPartialRcv (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    );

NTSTATUS 
SmbTdiReceiveHandler (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_TCP_CONNECT TcpConnect,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    );

#ifdef NO_ZERO_BYTE_INDICATE
NTSTATUS 
TdiReceiveHandlerRdr (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_TCP_CONNECT TcpConnect,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    );
#endif

NTSTATUS
TdiSetEventHandler(
    PFILE_OBJECT    FileObject,
    ULONG           EventType,
    PVOID           EventHandler,
    PVOID           Context
    );

NTSTATUS
SmbSynchTdiCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
SmbFillIrp(
    IN PSMB_CONNECT     ConnectObject,
    IN PVOID            Tsdu,
    IN LONG             BytesIndicated,
    OUT LONG            *BytesTaken
    );

VOID
SmbGetHeaderDpc(
    IN PKDPC Dpc,
    IN PSMB_CONNECT     ConnectObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
SmbPrepareReceiveIrp(
    IN PSMB_CONNECT     ConnectObject
    );

#if DBG
BOOL
IsValidPartialRcvState(
    IN PSMB_CONNECT     ConnectObject
    );
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\smbtrace.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    smbtrace.h

Abstract:

    Software Tracing

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __SMBTRACE_H__
#define __SMBTRACE_H__

#define WPP_CONTROL_GUIDS                                                   \
    WPP_DEFINE_CONTROL_GUID(SmbGuid,(bca7bd7f,b0bf,4051,99f4,03cfe79664c1), \
        WPP_DEFINE_BIT(SMB_TRACE_DNS)                                      \
        WPP_DEFINE_BIT(SMB_TRACE_TCP)                                       \
        WPP_DEFINE_BIT(SMB_TRACE_RECEIVE)                                   \
        WPP_DEFINE_BIT(SMB_TRACE_CALL)                                       \
        WPP_DEFINE_BIT(SMB_TRACE_REGISTRY)                                   \
        WPP_DEFINE_BIT(SMB_TRACE_ERRORS)                                     \
        WPP_DEFINE_BIT(SMB_TRACE_INBOUND)                                    \
        WPP_DEFINE_BIT(SMB_TRACE_OUTBOUND)                                   \
        WPP_DEFINE_BIT(SMB_TRACE_CONNECT)                                   \
        WPP_DEFINE_BIT(SMB_TRACE_XPORT)                                    \
        WPP_DEFINE_BIT(SMB_TRACE_PNP)                                        \
        WPP_DEFINE_BIT(SMB_TRACE_IOCTL)                                      \
        WPP_DEFINE_BIT(SMB_TRACE_TODO)                                      \
        WPP_DEFINE_BIT(SMB_TRACE_VERBOSE)                                      \
    )                                                                       \
    WPP_DEFINE_CONTROL_GUID(ConnectionShutdownGuid,(3757e105,5437,4a6f,a263,47eb04a593ac),  \
        WPP_DEFINE_BIT(SMB_DONT_CARE3)                                       \
    )

#define WPP_LOGIPV6(x)      WPP_LOGPAIR((16), (x))
#define WPP_LOGMACADDR(x)   WPP_LOGPAIR((6), (x))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inf\sources.inc ===
TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=NOTARGET

SOURCES=

NTTARGETFILE0=make_infs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\install\makefile.inc ===
$(O)\msg00001.bin: localmsg.mc
    $(MC) -v -h $(O) -r $(O) localmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\install\installsmb.cpp ===
#include <stdio.h>
#include <netcfgx.h>
#include <devguid.h>

//
// Localization library and MessageIds.
//
#include <nls.h>
#include "localmsg.h"

EXTERN_C void ausage(void);

HRESULT
HrCreateINetCfg (
    IN BOOL fAcquireWriteLock,
    OUT INetCfg** ppINetCfg)
{
    HRESULT hr;
    INetCfg* pINetCfg;

    // Get the INetCfg interface.
    //
    hr = CoCreateInstance(
        CLSID_CNetCfg,
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        IID_INetCfg,
        reinterpret_cast<void**>(&pINetCfg));

    if (S_OK == hr) {
        INetCfgLock * pnclock = NULL;

        if (fAcquireWriteLock) {
            // Get the locking interface
            hr = pINetCfg->QueryInterface(IID_INetCfgLock,
                                     reinterpret_cast<LPVOID *>(&pnclock));
            if (SUCCEEDED(hr)) {
                LPWSTR pwszLockHolder;

                // Attempt to lock the INetCfg for read/write
                hr = pnclock->AcquireWriteLock(100, L"InstallSmb6", 
                    &pwszLockHolder);
                if (S_FALSE == hr) {
                    // Couldn't acquire the lock
                    hr = NETCFG_E_NO_WRITE_LOCK;
                    NlsPutMsg(STDOUT, SMB_MESSAGE_0);
// printf("The write lock could not be acquired.\n");

                    NlsPutMsg(STDOUT, SMB_MESSAGE_1, pwszLockHolder);
// printf("You must close %ls first.\n", pwszLockHolder);

                }
                if (pwszLockHolder) {
                    CoTaskMemFree(pwszLockHolder);
                }
            }
        }

        if (S_OK == hr) {
            hr = pINetCfg->Initialize (NULL);
            if (S_OK == hr) {
                *ppINetCfg = pINetCfg;
                pINetCfg->AddRef();
            }
            else {
                if (pnclock) {
                    pnclock->ReleaseWriteLock();
                }
            }
        }

        if (pnclock) {
            pnclock->Release();
        }

        //Transfer ownership to caller.
        pINetCfg->Release();
    }
    return hr;
}


VOID
pAddOrRemoveSmb6(BOOL fAddSmb6)
{
    HRESULT hr;
    INetCfg* pINetCfg;

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr) {
        INetCfgClassSetup* pSetup;

        // Get the setup interface used for installing
        // and uninstalling components.
        //
        hr = pINetCfg->QueryNetCfgClass (
                &GUID_DEVCLASS_NETTRANS,
                IID_INetCfgClassSetup,
                (VOID**)&pSetup);

        if (S_OK == hr) {
            OBO_TOKEN OboToken;
            INetCfgComponent* pIComp;

            ZeroMemory (&OboToken, sizeof(OboToken));
            OboToken.Type = OBO_USER;

            if (fAddSmb6) {
                NlsPutMsg(STDOUT, SMB_MESSAGE_2);
// printf("Installing...\n");

                hr = pSetup->Install (
                        L"MS_SMB",
                        &OboToken,
                        0, 0, NULL, NULL,
                        &pIComp);

                if (pIComp) {
                    pIComp->Release();
                }
            }
            else {
                // Need to remove the component.
                // Find it first.
                //
                hr = pINetCfg->FindComponent (
                        L"MS_SMB",
                        &pIComp);

                if (S_OK == hr) {
                    NlsPutMsg(STDOUT, SMB_MESSAGE_3);
// printf("Uninstalling...\n");

                    hr = pSetup->DeInstall (
                            pIComp,
                            &OboToken,
                            NULL);

                    pIComp->Release();
                }
                else {
                    NlsPutMsg(STDOUT, SMB_MESSAGE_4);
// printf("Microsoft Smb6 Developer Edition is not installed.\n");

                }
            }

            if (SUCCEEDED(hr)) {
                if (NETCFG_S_REBOOT == hr) {
                    hr = S_OK;
                    NlsPutMsg(STDOUT, SMB_MESSAGE_5);
// printf("A reboot is required to complete this action.\n");

                }
                else {
                    NlsPutMsg(STDOUT, SMB_MESSAGE_6);
// printf("Succeeded.\n");

                }
            }
            else {
                NlsPutMsg(STDOUT, SMB_MESSAGE_7);
// printf("Failed to complete the action.\n");

                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) {
                    hr = S_OK;
                    NlsPutMsg(STDOUT, SMB_MESSAGE_8);
// printf("The INF file for Microsoft Smb6 Developer Edition could not be found.\n");

                }
                else if (NETCFG_E_NEED_REBOOT == hr) {
                    NlsPutMsg(STDOUT, SMB_MESSAGE_9);
// printf("A reboot is required before any further changes can be made.\n");

                }
                else {
                    NlsPutMsg(STDOUT, SMB_MESSAGE_10, hr);
// printf("Error 0x%08x\n", hr);

                }
            }

            pSetup->Release();
        }

        hr = pINetCfg->Uninitialize();
        if (SUCCEEDED(hr))
        {
            INetCfgLock *   pnclock;

            // Get the locking interface
            hr = pINetCfg->QueryInterface(IID_INetCfgLock,
                                     reinterpret_cast<LPVOID *>(&pnclock));
            if (SUCCEEDED(hr))
            {
                // Attempt to lock the INetCfg for read/write
                hr = pnclock->ReleaseWriteLock();

               pnclock->Release();
            }
        }

        pINetCfg->Release();
    }
    else if (NETCFG_E_NO_WRITE_LOCK == hr) {
        // Message has already been printed
    }
    else if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr) {
        ausage();
    }
    else {
        NlsPutMsg(STDOUT, SMB_MESSAGE_11, hr);
// printf("Problem 0x%08x occurred.\n", hr);

    }

}

EXTERN_C
BOOL
IsSmb6Installed()
{
    HRESULT hr = S_OK;
    BOOL fInitCom = TRUE;
    BOOL fPresent = FALSE;

    // Initialize COM.
    //
    hr = CoInitializeEx( NULL,
            COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (RPC_E_CHANGED_MODE == hr) {
        // If we changed mode, then we won't uninitialize COM when we are done.
        //
        hr = S_OK;
        fInitCom = FALSE;
    }

    if (SUCCEEDED(hr)) {
        HRESULT hr;
        INetCfg* pINetCfg;

        hr = HrCreateINetCfg (FALSE, &pINetCfg);
        if (S_OK == hr) {
            fPresent = (S_OK == pINetCfg->FindComponent(L"MS_SMB", NULL));
            pINetCfg->Uninitialize();
            pINetCfg->Release();
        }
        else {
            NlsPutMsg(STDOUT, SMB_MESSAGE_12, hr);
// printf("Problem 0x%08x occurred while accessing network configuration.\n", hr);

            exit(1);
        }

        if (fInitCom) {
            CoUninitialize();
        }
    }
    else {
        NlsPutMsg(STDOUT, SMB_MESSAGE_13, hr);
// printf("Problem 0x%08x initializing COM library\n", hr);

    }

    return fPresent;

}

EXTERN_C
void
AddOrRemoveSmb6 (
    IN BOOL fAddSmb6)
{

    HRESULT hr = S_OK;
    BOOL fInitCom = TRUE;

    // Initialize COM.
    //
    hr = CoInitializeEx( NULL,
            COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (RPC_E_CHANGED_MODE == hr) {
        // If we changed mode, then we won't uninitialize COM when we are done.
        //
        hr = S_OK;
        fInitCom = FALSE;
    }

    if (SUCCEEDED(hr)) {
        pAddOrRemoveSmb6(fAddSmb6);

        if (fInitCom) {
            CoUninitialize();
        }
    }
    else {
        NlsPutMsg(STDOUT, SMB_MESSAGE_13, hr);
// printf("Problem 0x%08x initializing COM library\n", hr);

    }
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\lib\host.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    host.c

Abstract:

    etc/hosts parser

Author:

    Jiandong Ruan

Revision History:

    Feb-15-2001     First functional version

--*/

#include "precomp.h"
#include "fileio.h"
#include "debug.h"

#define IS_VALID_HOSTNAME_CHAR(ch)                          \
    (((ch) >= 'a' && (ch) <= 'z') || ((ch) == '.') ||       \
    ((ch) >= 'A' && (ch) <= 'Z') ||                         \
    ((ch) >= '0' && (ch) <= '9') ||                         \
    ((ch) == '_') || ((ch) == '-'))


#define IS_VALID_IPADDR_CHAR(ch)                            \
    (((ch) >= '0' && (ch) <= '9') ||                        \
     ((ch) >= 'a' && (ch) <= 'f') ||                        \
     ((ch) >= 'A' && (ch) <= 'F') ||                        \
     ((ch) == '.') || ((ch) == ':'))

#define ISSPACE(ch)                                         \
    (((ch) == ' ') || ((ch) == '\t'))

#define ISNEWLINE(ch)                                       \
    (((ch) == '\r') || ((ch) == '\n'))

#define NEXT_LINE()                                         \
    do {                                                    \
        while (ch != EOF && !ISNEWLINE(ch)) {               \
            ch = Smb_fgetc(fp);                             \
        }                                                   \
        while (ISNEWLINE(ch)) {                             \
            ch = Smb_fgetc(fp);                             \
        }                                                   \
    } while (0)

#define SKIP_SPACE()                                        \
    do {                                                    \
        while (ISSPACE(ch)) {                               \
            ch = Smb_fgetc(fp);                             \
        }                                                   \
    } while(0)

#define SKIP_EMPTY_LINE()                                   \
    do {                                                    \
        while (ISNEWLINE(ch)) {                             \
            ch = Smb_fgetc(fp);                             \
        }                                                   \
    } while(0)

#define SMB_MAX_HOST_NAME_SIZE      256 
#define SMB_MAX_IPADDR_SIZE         40

BOOL
SmbLookupHost(
    WCHAR               *host,
    PSMB_IP_ADDRESS     ipaddr
    )
{
    PSMB_FILE   fp;
    int         ch;
    int         addr_size, name_size;
    CHAR        addr[SMB_MAX_IPADDR_SIZE];
    CHAR        name[SMB_MAX_HOST_NAME_SIZE];
    UNICODE_STRING  ucHost;
    ANSI_STRING     oemHost, oemName, oemAddr;
    NTSTATUS        status;

    //
    // We need to test it in user mode. PAGED_CODE() import KeGetCurrentIrql() which
    // cannot be provided by user mode
    //
    //PAGED_CODE();

    fp = NULL;
    oemHost.Buffer = NULL;

    fp = Smb_fopen(L"\\SystemRoot\\System32\\drivers\\etc\\hosts", L"r");
    if (fp == NULL) {
        return FALSE;
    }

    RtlInitUnicodeString(&ucHost, host);
    status = RtlUnicodeStringToAnsiString(&oemHost, &ucHost, TRUE);
    BAIL_OUT_ON_ERROR(status);

    ch = Smb_fgetc(fp);
    while(ch != EOF) {

        SKIP_EMPTY_LINE();

        SKIP_SPACE();

        if (ch == '#') {
            //
            // This is comment, skip to the next line
            //
            NEXT_LINE();
            continue;
        }

        if (ch == EOF) {
            break;
        }

        //
        // Parse this entry
        //      ipaddr  host-name
        //


        //
        // parse the ipaddr
        //
        addr_size = 0;
        while (IS_VALID_IPADDR_CHAR(ch)) {
            addr[addr_size++] = (CHAR)ch;
            ch = Smb_fgetc(fp);
            if (addr_size >= SMB_MAX_IPADDR_SIZE) {
                break;
            }
        }
        if (addr_size >= SMB_MAX_IPADDR_SIZE || !ISSPACE(ch)) {
            NEXT_LINE();
            continue;
        }
        addr[addr_size] = '\0';

        //
        // parse the host-name
        //
        SKIP_SPACE();
        name_size = 0;
        while (IS_VALID_HOSTNAME_CHAR(ch)) {
            name[name_size++] = (CHAR)ch;
            ch = Smb_fgetc(fp);
            if (name_size >= SMB_MAX_IPADDR_SIZE) {
                break;
            }
        }

        if (name_size >= SMB_MAX_HOST_NAME_SIZE || (ch != EOF && !ISSPACE(ch) && ch != '#' && !ISNEWLINE(ch))) {
            NEXT_LINE();
            continue;
        }

        name[name_size] = '\0';

        //
        // Compare
        //
        RtlInitAnsiString(&oemName, name);
        if (RtlCompareString(&oemName, &oemHost, TRUE) == 0) {
            UNICODE_STRING  ucAddr;

            RtlInitAnsiString(&oemAddr, addr);
            status = RtlAnsiStringToUnicodeString(&ucAddr, &oemAddr, TRUE);
            BAIL_OUT_ON_ERROR(status);

            //
            // Check if it is an IPv6 format
            //
            if (inet_addr6W(ucAddr.Buffer, &ipaddr->ip6)) {
                RtlFreeUnicodeString(&ucAddr);
                RtlFreeAnsiString(&oemHost);
                Smb_fclose(fp);
                ipaddr->sin_family = SMB_AF_INET6;
                return TRUE;
            }

            //
            // Check if it is an IPv4 format
            //
            ipaddr->ip4.sin4_addr = inet_addrW(ucAddr.Buffer);
            if (ipaddr->ip4.sin4_addr != INADDR_NONE) {
                RtlFreeUnicodeString(&ucAddr);
                RtlFreeAnsiString(&oemHost);
                Smb_fclose(fp);
                ipaddr->sin_family = SMB_AF_INET;
                return TRUE;
            }
            RtlFreeUnicodeString(&ucAddr);
        }
    }

cleanup:
    if (fp) {
        Smb_fclose(fp);
    }
    if (oemHost.Buffer) {
        RtlFreeAnsiString(&oemHost);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inc\types.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    types.c

Abstract:

    Data type definitions

Author:

    Jiandong Ruan

Revision History:

--*/

#ifndef __TYPES_H__
#define __TYPES_H__

//
// Memory Allocation Tag
//
#define TAG_SMB6_DEVICE         '6sbn'
#define TAG_TCP_DEVICE          'psbn'
#define TAG_CLIENT_OBJECT       'lsbn'
#define TAG_CONNECT_OBJECT      'csbn'
#define TAG_TDI_INFO_REQUEST    'tsbn'

#ifndef NETBIOS_NAME_SIZE
#define NETBIOS_NAME_SIZE   16
#endif

#define DD_SMB_EXPORT_NAME          L"\\Device\\NetbiosSmb"
#define DD_SMB_BIND_NAME            L"\\Device\\Smb_Bind"

#define SMB_TCP_PORT                445
#define SMB_UDP_PORT                445
#define SMB_ENDPOINT_NAME           "*SMBSERVER      "

typedef struct SMB_HEADER {
    ULONG      Length;
} SMB_HEADER, *PSMB_HEADER;
#define SMB_SESSION_HEADER_SIZE     (sizeof(SMB_HEADER))
#define SMB_MAX_SESSION_PACKET      (0x1ffffU)
#define SMB_HEADER_LENGTH_MASK      (0x1ffffU)

//
// SMB is a TDI provider as well as a TDI client.
//
#define MAJOR_TDI_VERSION 2
#define MINOR_TDI_VERSION 0
#define WC_SMB_TDI_PROVIDER_NAME            L"\\Device\\NetbiosSmb"
#define WC_SMB_TDI_CLIENT_NAME              L"SMB"

//
// These are used to identify the type of FILE_OBJECT.
//      SMB creates different objects as a result of client's calling ZwCreate.
// The object type is stored in the FILE_OBJECT->FsContext2.
//
// Since most other transports (for example TCP) is using 0, 1, 2, 3..., we'd
// better use some special values. (A buggy client can send any file objects
// to us. Using special values can help us detect such clients).
//
typedef enum {
    SMB_TDI_INVALID = 'IBMS',
    SMB_TDI_CONTROL = 'TBMS',           // The Control Object
    SMB_TDI_CLIENT  = 'LBMS',           // The Client Object
    SMB_TDI_CONNECT = 'CBMS'            // The Connection Object
} SMB_TDI_OBJECT;

struct _SMB_CLIENT_ELEMENT;
typedef struct _SMB_CLIENT_ELEMENT SMB_CLIENT_ELEMENT, *PSMB_CLIENT_ELEMENT;

typedef struct _SMB_TCP_INFO SMB_TCP_INFO, *PSMB_TCP_INFO;

//
// The data structure for SMB device
//
typedef struct _SMB_DEVICE {
    DEVICE_OBJECT   DeviceObject;

    ULONG           Tag;
    KSPIN_LOCK      Lock;

    // The connections in disassociated state
    LIST_ENTRY      UnassociatedConnectionList;
    LIST_ENTRY      ClientList;

    PSMB_CLIENT_ELEMENT SmbServer;

    LIST_ENTRY      PendingDeleteConnectionList;
    LIST_ENTRY      PendingDeleteClientList;

    //
    // The list of lower endpoints waiting for disconnect
    //      We need to maintain the same TdiDisconnectEvent handler
    //      semantics in SMB as in NBT4.
    //      In NBT4, a upper endpoint (ConnectObject) can be reused
    //      immediately after NBT4 call the client tdi disconnect
    //      handler. However, TCP doesn't allow its client to reuse
    //      the endpoint (our ConnectObject with TCP). An explicit
    //      TDI_DISCONNECT should be issued before we can do that.
    //
    //      Originally, SMB uses the same semantics as TCP does.
    //      However, SRV is not happy with this.
    //
    //      To use NBT4 semantics, we need a pending list here
    //      because we cannot issue TDI_DISCONNECT request at
    //      DISPATCH_LEVEL.
    //
    //  DelayedDisconnectList:
    //      The list of endpoints not processed by the disconnect worker.
    //      (TDI_DISCONNECT hasn't been issued to TCP).
    //  PendingDisconnectList:
    //      The list of endpoints waiting for disconnect completion
    //      (TDI_DISCONNECT has been issued to TCP, but TCP hasn't completed
    //      the request)
    //
    LIST_ENTRY      DelayedDisconnectList;
    LIST_ENTRY      PendingDisconnectList;

    //
    // FIN attack protection
    //
    LONG            PendingDisconnectListNumber;
    BOOL            FinAttackProtectionMode;
    LONG            EnterFAPM;      // The threshold entering the Fin Attack Protection Mode
    LONG            LeaveFAPM;      // The threshold leaving the Fin Attack Protection Mode
    KEVENT          PendingDisconnectListEmptyEvent;
    BOOL            DisconnectWorkerRunning;

    //
    // Synch attack protection
    //
    LONG            MaxBackLog;     // The threshold which will trigger the reaper for aborting connections

    //
    // SMB worker thread is running
    //
    LONG            ConnectionPoolWorkerQueued;

    UCHAR           EndpointName[NETBIOS_NAME_SIZE];

    //
    // TDI device registration handle
    //
    HANDLE          DeviceRegistrationHandle;

    USHORT          Port;

    //
    // TCP4 info
    //
    SMB_TCP_INFO    Tcp4;

    //
    // TCP6 info
    //
    SMB_TCP_INFO    Tcp6;

    //
    // Binding info
    //
    PWSTR           ClientBinding;
    PWSTR           ServerBinding;
} SMB_DEVICE, *PSMB_DEVICE;

//
// This data structure is used to keep track of PnP of IP devices
//  SMB device is registered when the first IPv6 address is added and
//  deregistered when the last IPv6 address is removed. We need to keep
//  track the PnP events.
//
typedef struct {
    SMB_OBJECT;

    UNICODE_STRING      AdapterName;
    BOOL                AddressPlumbed;
    SMB_IP_ADDRESS      PrimaryIpAddress;
    ULONG               InterfaceIndex;

    //
    // Is outbound enabled on this adapter?
    //
    BOOL                EnableOutbound;

    //
    // Is inbound enabled on this adapter?
    //
    BOOL                EnableInbound;
} SMB_TCP_DEVICE, *PSMB_TCP_DEVICE;

typedef struct {
    KSPIN_LOCK          Lock;
    ERESOURCE           Resource;

    BOOL                Unloading;

    DWORD               IPAddressNumber;
    DWORD               IPv4AddressNumber;
    DWORD               IPv6AddressNumber;
    DWORD               IPDeviceNumber;
    LIST_ENTRY          PendingDeleteIPDeviceList;
    LIST_ENTRY          IPDeviceList;

    PDRIVER_OBJECT      DriverObject;

    PSMB_DEVICE         SmbDeviceObject;

        // Our handle with TDI
    DWORD               ProviderReady;
    HANDLE              TdiProviderHandle;
    HANDLE              TdiClientHandle;

        // FileSystem process
    PEPROCESS           FspProcess;

        // SMBv6\Parameters
    HANDLE              ParametersKey;

        // SMBv6
    HANDLE              LinkageKey;

#ifndef NO_LOOKASIDE_LIST
    //
    // The lookaside list for connection object
    //
    NPAGED_LOOKASIDE_LIST   ConnectObjectPool;
    BOOL                    ConnectObjectPoolInitialized;

    //
    // The lookaside list for TCP Context
    //
    NPAGED_LOOKASIDE_LIST   TcpContextPool;
    BOOL                    TcpContextPoolInitialized;
#endif

    //
    // Used Irps. This will save us a lot of time for debugging.
    // We need a separate spinlock to avoid deadlock.
    //
    KSPIN_LOCK          UsedIrpsLock;
    LIST_ENTRY          UsedIrps;

    //
    // DNS query timeout and the max # of resolvers.
    //
    DWORD               DnsTimeout;
    LONG                DnsMaxResolver;

    //
    // EnableNagling
    //
    BOOL                EnableNagling;

    //
    // IPv6 Address Object protect level
    // set by registry Key: IPv6Protection
    //
    ULONG uIPv6Protection;

    //
    // set by registry key: IPv6EnableOutboundGlobal
    // TRUE: allow connection goes to global IPv6 outbound address
    // FALSE: skip the global IPv6 address when doing TDI_CONNECT
    //
    BOOL bIPv6EnableOutboundGlobal;

    BOOL                Tcp6Available;
    BOOL                Tcp4Available;

#if DBG
    ULONG               DebugFlag;
#endif
} SMBCONFIG;

//
// Thread service
//
__inline NTSTATUS
SmbCreateWorkerThread(
    IN PKSTART_ROUTINE  worker,
    IN PVOID            context,
    OUT PETHREAD        *pThread
    )
{
    NTSTATUS    status;
    HANDLE      hThread;

    status = PsCreateSystemThread(
                    &hThread,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    worker,
                    context
                    );
    if (status == STATUS_SUCCESS) {
        status = ObReferenceObjectByHandle(
                        hThread,
                        0,
                        0,
                        KernelMode,
                        pThread,
                        NULL
                        );
        ASSERT(status == STATUS_SUCCESS);
        status = ZwClose(hThread);
        ASSERT(status == STATUS_SUCCESS);
        status = STATUS_SUCCESS;
    }
    return status;
}

__inline void
WaitThread(
    IN PETHREAD thread
    )
{
    if (thread) {
        NTSTATUS        status;
        status = KeWaitForSingleObject(
                    thread,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );
        ASSERT(status == STATUS_SUCCESS);
    }
}

////////////////////////////////////////////////////////////////////////////////
// Client Object
////////////////////////////////////////////////////////////////////////////////
typedef struct _SMB_CLIENT_ELEMENT {
    SMB_OBJECT;

        // back link to the SMB_DEVICE object
    PSMB_DEVICE     Device;

        // Connections associated with this address object
    LIST_ENTRY      AssociatedConnection;

        // Listening Connections
    LIST_ENTRY      ListenHead;

        // Connections in connected state
    LIST_ENTRY      ActiveConnection;

        // Pending in TCP for accept completion
    LIST_ENTRY      PendingAcceptConnection;
    LONG            PendingAcceptNumber;

    UCHAR           EndpointName[NETBIOS_NAME_SIZE];

    //
    // The client TDI event handler
    //
    PTDI_IND_CONNECT    evConnect;
    PVOID               ConEvContext;

    PTDI_IND_DISCONNECT evDisconnect;
    PVOID               DiscEvContext;

    PTDI_IND_ERROR      evError;
    PVOID               ErrorEvContext;

    PTDI_IND_RECEIVE    evReceive;
    PVOID               RcvEvContext;
} SMB_CLIENT_ELEMENT, *PSMB_CLIENT_ELEMENT;

void __inline
SmbReferenceClient(PSMB_CLIENT_ELEMENT ob, SMB_REF_CONTEXT ctx)
{
    SmbReferenceObject((PSMB_OBJECT)ob, ctx);
}

void __inline
SmbDereferenceClient(PSMB_CLIENT_ELEMENT ob, SMB_REF_CONTEXT ctx)
{
    SmbDereferenceObject((PSMB_OBJECT)ob, ctx);
}

////////////////////////////////////////////////////////////////////////////////
// Connection Object
////////////////////////////////////////////////////////////////////////////////
typedef enum {
    SMB_IDLE,
    SMB_CONNECTING,
    SMB_CONNECTED,
    SMB_DISCONNECTING
} SMB_CONNECT_STATE;

#ifdef ENABLE_RCV_TRACE
//
// SMB_TRACE_RCV is a built-in tracing for the tdi receive event handler
//
#define SMB_MAX_TRACE_SIZE  32
typedef struct _SMB_TRACE_RCV {
    DWORD   Head;
    struct {
        ULONG       ln;
        ULONG       id;
    } Locations[SMB_MAX_TRACE_SIZE];
} SMB_TRACE_RCV, *PSMB_TRACE_RCV;

void __inline
SmbInitTraceRcv(PSMB_TRACE_RCV t) {
    t->Head = (DWORD)(-1);
    RtlZeroMemory(t->Locations, sizeof(t->Locations));
}

void __inline
SmbPushTraceRcv(PSMB_TRACE_RCV t, ULONG ln, ULONG id) {
    DWORD   Head;

    Head = InterlockedIncrement(&t->Head);

    Head %= SMB_MAX_TRACE_SIZE;
    //t->Locations[Head].fn = fn;
    t->Locations[Head].ln = ln;
    t->Locations[Head].id = id;
}

#   define PUSH_LOCATION(a, b)      SmbPushTraceRcv(&a->TraceRcv, __LINE__, b)
#else
#   define PUSH_LOCATION(a, b)
#   define SmbInitTraceRcv(a)
#endif

typedef enum {
    //
    // Not disconnected yet. This state is for debug purpose
    //
    SMB_DISCONNECT_NONE,

    //
    // Disconnected because SMB's disconnect event handler is called by transport.
    //
    SMB_DISCONNECT_FROM_TRANSPORT,

    //
    // Disconnect as requested by the client 
    //
    SMB_DISCONNECT_FROM_CLIENT,

    //
    // Disconnect by SMB upon fatal error on receive path
    //
    SMB_DISCONNECT_RECEIVE_FAILURE
} SMB_DISCONNECT_SOURCE;

typedef enum {

    SMB_PENDING_CONNECT = 0,
    SMB_PENDING_ACCEPT,
    SMB_PENDING_RECEIVE,
    SMB_PENDING_DISCONNECT,
    SMB_PENDING_SEND,

    SMB_PENDING_MAX
} SMB_PENDING_REQUEST_TYPE;

typedef struct _SMB_CONNECT {
    SMB_OBJECT;

    SMB_CONNECT_STATE   State;

        // back link to the SMB_DEVICE object
    PSMB_DEVICE Device;

        // The client's connection context
    CONNECTION_CONTEXT  ClientContext;
    PSMB_CLIENT_ELEMENT ClientObject;

    PTCPSEND_DISPATCH   FastSend;

        // If we're the originator, the TCP address object will be associated
        // with only one TCP connection object. After the connection is closed,
        // we should close both the TCP connection object and address object.
        //
        // If we're not the originator, the TCP address object (port 445) can be
        // associated with many TCP connection object. After the connection is closed
        // we shouldn't close the address object.
    BOOL                Originator;
    PSMB_TCP_CONTEXT    TcpContext;

    //
    // TODO: can we remove the following field since we should be able to query
    //       it from TCP?
    //
    CHAR                RemoteName[NETBIOS_NAME_SIZE];
    SMB_IP_ADDRESS      RemoteIpAddress;

    //
    // In NBT4, we encountered a lot of cases which required us to find out the reason
    // for the disconnection. Adding the following field will make the life easier.
    //
    SMB_DISCONNECT_SOURCE   DisconnectOriginator;

    // Irp for pending connect, disconnect, close requests.
    PIRP        PendingIRPs[SMB_PENDING_MAX];

    //
    // Pending Receive Request
    //  TDI_RECEIVE requests in this queue are cancellable.
    //
    LIST_ENTRY  RcvList;

    //
    // Statistics
    //
    ULONGLONG   BytesReceived;
    ULONGLONG   BytesSent;

    //
    // Bytes left in TCP
    //
    LONG        BytesInXport;

    //
    // Length of current session packet
    //
    LONG        CurrentPktLength;

    //
    // Remaining bytes in the current session packet
    //
    LONG        BytesRemaining;

    //
    // SMB header
    //  is created so that we don't have to handle the error case.
    //
    KDPC        SmbHeaderDpc;
    BOOL        DpcRequestQueued;
    LONG        HeaderBytesRcved;   // # of bytes has been received for the Header
    SMB_HEADER  SmbHeader;

    PIRP        ClientIrp;
    PMDL        ClientMdl;
    LONG        ClientBufferSize;
    LONG        FreeBytesInMdl;
    PMDL        PartialMdl;

    //
    // The rcv handler for current state
    //
    PRECEIVE_HANDLER    StateRcvHandler;

#ifdef ENABLE_RCV_TRACE
    SMB_TRACE_RCV       TraceRcv;
#endif

#ifdef NO_ZERO_BYTE_INDICATE
    //
    // We need to ask RDR change their receive handler code in blackcomb.
    // SRV is doing what we like it to do: allow any byte indicaion
    // (just like what tcpip6 does to us).
    //
#define MINIMUM_RDR_BUFFER  128
    LONG        BytesInIndicate;

    //
    // In order to use driver verifier to capture buffer overrun,
    // put this at the end.
    //
    BYTE        IndicateBuffer[MINIMUM_RDR_BUFFER];
#endif // NO_ZERO_BYTE_INDICATE
} SMB_CONNECT, *PSMB_CONNECT;

void SmbReuseConnectObject(PSMB_CONNECT ConnectObject);

void __inline
SmbReferenceConnect(PSMB_CONNECT ob, SMB_REF_CONTEXT ctx)
{
    SmbReferenceObject((PSMB_OBJECT)ob, ctx);
}

void __inline
SmbDereferenceConnect(PSMB_CONNECT ob, SMB_REF_CONTEXT ctx)
{
    SmbDereferenceObject((PSMB_OBJECT)ob, ctx);
}

//
// Lightweighted dpc routine
// Although
//      KeInsertQueueDpc does work if the dpc has already been queued.
//      KeRemoveQueueDpc does work if the dpc has already been removed.
// they are expensive (acquiring several spinlock and do some other checking)
//
void __inline
SmbQueueSessionHeaderDpc(PSMB_CONNECT ConnectObject)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(ConnectObject->DpcRequestQueued == FALSE);

    KeInsertQueueDpc(&ConnectObject->SmbHeaderDpc, NULL, NULL);
    ConnectObject->DpcRequestQueued = TRUE;
    SmbReferenceConnect(ConnectObject, SMB_REF_DPC);
}

void __inline
SmbRemoveSessionHeaderDpc(PSMB_CONNECT ConnectObject)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (ConnectObject->DpcRequestQueued == TRUE) {
        KeRemoveQueueDpc(&ConnectObject->SmbHeaderDpc);
        SmbDereferenceConnect(ConnectObject, SMB_REF_DPC);
        ConnectObject->DpcRequestQueued = FALSE;
    }
}

void __inline
SaveDisconnectOriginator(
    PSMB_CONNECT ConnectObject, 
    SMB_DISCONNECT_SOURCE   src
    )
{
    if (ConnectObject->DisconnectOriginator == SMB_DISCONNECT_NONE) {
        ConnectObject->DisconnectOriginator = src;
    }
    if (!ConnectObject->Originator && ConnectObject->RemoteIpAddress.sin_family == SMB_AF_INET6) {
        FreeNetbiosNameForIp6Address(ConnectObject->RemoteIpAddress.ip6.sin6_addr_bytes);
        ConnectObject->RemoteIpAddress.sin_family = SMB_AF_INVALID_INET6;
    }
}

void __inline
ResetDisconnectOriginator(PSMB_CONNECT ConnectObject) {
    ConnectObject->DisconnectOriginator = SMB_DISCONNECT_NONE;
}

BOOL __inline
IsAssociated(PSMB_CONNECT ConnectObject) {
    return (ConnectObject->ClientObject != NULL);
}

BOOL __inline
IsDisAssociated(PSMB_CONNECT ConnectObject) {
    return (ConnectObject->ClientObject == NULL);
}

BOOL __inline
IsConnected(PSMB_CONNECT ConnectObject) {
    return (ConnectObject->State == SMB_CONNECTED);
}

BOOL __inline
IsDisconnected(PSMB_CONNECT ConnectObject) {
    return (ConnectObject->State == SMB_IDLE);
}

BOOL __inline
IsBusy(PSMB_CONNECT ConnectObject) {
    int i;

    for (i = 0; i < SMB_PENDING_MAX; i++) {
        if (ConnectObject->PendingIRPs[i] != NULL) {
            return TRUE;
        }
    }
    return FALSE;
}

extern BOOL EntryIsInList(PLIST_ENTRY ListHead, PLIST_ENTRY SearchEntry);


extern SMBCONFIG SmbCfg;

#define IsTcp6Available()     (SmbCfg.Tcp6Available)

#define ALIGN(x)    ROUND_UP_COUNT(x, ALIGN_WORST)

#define SMB_ACQUIRE_SPINLOCK(ob,Irql) KeAcquireSpinLock(&(ob)->Lock,&Irql)
#define SMB_RELEASE_SPINLOCK(ob,Irql) KeReleaseSpinLock(&(ob)->Lock,Irql)
#define SMB_ACQUIRE_SPINLOCK_DPC(ob)      KeAcquireSpinLockAtDpcLevel(&(ob)->Lock)
#define SMB_RELEASE_SPINLOCK_DPC(ob)      KeReleaseSpinLockFromDpcLevel(&(ob)->Lock)

#define SMB_MIN(x,y)    (((x) < (y))?(x):(y))


#ifdef NO_LOOKASIDE_LIST
PSMB_CONNECT __inline
_new_ConnectObject(void)
{
    return ExAllocatePoolWithTag(NonPagedPool, sizeof(SMB_CONNECT), CONNECT_OBJECT_POOL_TAG);
}

void __inline
_delete_ConnectObject(PSMB_CONNECT ConnectObject)
{
    ExFreePool(ConnectObject);
}

PSMB_TCP_CONTEXT __inline
_new_TcpContext(void)
{
    return ExAllocatePoolWithTag(NonPagedPool, sizeof(SMB_TCP_CONTEXT), TCP_CONTEXT_POOL_TAG);
}

void __inline
_delete_TcpContext(PSMB_TCP_CONTEXT TcpCtx)
{
    ExFreePool(TcpCtx);
}
#else
PSMB_CONNECT __inline
_new_ConnectObject(void)
{
    return ExAllocateFromNPagedLookasideList(&SmbCfg.ConnectObjectPool);
}

void __inline
_delete_ConnectObject(PSMB_CONNECT ConnectObject)
{
    ExFreeToNPagedLookasideList(&SmbCfg.ConnectObjectPool, ConnectObject);
}

PSMB_TCP_CONTEXT __inline
_new_TcpContext(void)
{
    return ExAllocateFromNPagedLookasideList(&SmbCfg.TcpContextPool);
}

void __inline
_delete_TcpContext(PSMB_TCP_CONTEXT TcpCtx)
{
    ExFreeToNPagedLookasideList(&SmbCfg.TcpContextPool, TcpCtx);
}
#endif  // NO_LOOKASIDE_LIST

PIRP
SmbAllocIrp(
    CCHAR   StackSize
    );

VOID
SmbFreeIrp(
    PIRP    Irp
    );

//
// Registry Key
//
#define SMB_REG_IPV6_PROTECTION_DEFAULT             PROTECTION_LEVEL_RESTRICTED
#define SMB_REG_IPV6_PROTECTION                     L"IPv6Protection"
#define SMB_REG_IPV6_ENABLE_OUTBOUND_GLOBAL         L"IPv6EnableOutboundGlobal"

#define SMB_REG_INBOUND_LOW             L"InboundLow"
#define SMB_REG_INBOUND_LOW_DEFAULT     128
#define SMB_REG_INBOUND_LOW_MIN         50
#define SMB_REG_INBOUND_MID             L"InboundMid"
#define SMB_REG_INBOUND_HIGH            L"InboundHigh"

#define SMB_REG_ENTER_FAPM              L"EnterFAPM"      // Threshold for entering FIN Attack Protection Mode
#define SMB_REG_LEAVE_FAPM              L"LeaveFAPM"      // Threshold for leaving FIN Attack Protection Mode

#define SMB_REG_ENABLE_NAGLING          L"EnableNagling"
#define SMB_REG_DNS_TIME_OUT            L"DnsTimeout"
#define SMB_REG_DNS_TIME_OUT_DEFAULT    8000                // 8 seconds
#define SMB_REG_DNS_TIME_OUT_MIN        1000                // 1 seconds
#define SMB_REG_DNS_MAX_RESOLVER        L"DnsMaxResolver"
#define SMB_REG_DNS_RESOLVER_DEFAULT    2
#define SMB_REG_DNS_RESOLVER_MIN        1

#define SMB_ONE_MILLISECOND             (10000)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\install\smbstat.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    smbstat.c

Abstract:

    Platform independent utility functions

Author:

    Jiandong Ruan

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <tdi.h>
#include "ip6util.h"
#include "smbioctl.h"
#include <nls.h>
#include "localmsg.h"

HANDLE
OpenSmb(LPWSTR Name);

NTSTATUS
SmbstatStop(HANDLE);

NTSTATUS
SmbstatStart(HANDLE);

void AddOrRemoveSmb6(BOOL fAddIpv6);
BOOL IsSmb6Installed();

NTSTATUS
SmbstatEnableNagling(HANDLE);

NTSTATUS
SmbstatDisableNagling(HANDLE);

NTSTATUS
SmbSetIPv6ProtectionLevel(
    HANDLE  hSmb,
    PNBSMB_IPV6_PROTECTION_PARAM pNbParam
    );

void _cdecl main(void)
{
    LPWSTR  CommandLine;
    int     Argc;
    LPWSTR  *Argv;
    HANDLE  handle;

    setlocale(LC_ALL, "");

    CommandLine = GetCommandLineW();
    if (NULL == CommandLine) {
        exit (1);
    }
    Argv = CommandLineToArgvW(CommandLine, &Argc);

    if (Argc < 2) {
        exit (1);
    }
    if (!IsSmb6Installed()) {
        if (_wcsicmp(Argv[1], L"install") == 0) {
            AddOrRemoveSmb6 (TRUE);
        }
        NlsPutMsg(STDOUT, SMB_MESSAGE_16);
        NlsPutMsg(STDOUT, SMB_MESSAGE_17, Argv[0]);
        exit (0);
    }

    if (_wcsicmp(Argv[1], L"uninstall") == 0) {
        AddOrRemoveSmb6 (FALSE);
        exit (0);
    }

    handle = OpenSmb(DD_SMB6_EXPORT_NAME);
    if (handle == NULL) {
        exit(1);
    }

    if (_wcsicmp(Argv[1], L"EnableNagling") == 0) {
        SmbstatEnableNagling(handle);
    } else if (_wcsicmp(Argv[1], L"DisableNagling") == 0) {
        SmbstatDisableNagling(handle);
    } else if (_wcsicmp(Argv[1], L"Stop") == 0) {
        SmbstatStop(handle);
    } else if (_wcsicmp(Argv[1], L"Start") == 0) {
        SmbstatStart(handle);
    } else if (_wcsicmp(Argv[1], L"IPv6ProtectionLevel") == 0) {
        if (Argc < 4) {
            fprintf(stderr, "Usage: %s IPv6ProtectionLevel <InboundLevel> <OutgoundFlag>\n", Argv[0]);
            fprintf(stderr, "\tInboundLevel: inbound protection level (valid value=10, 20, or 30)\n");
            fprintf(stderr, "\tOutboundFlag: outbound flag for skipping global IPv6 address\n"); 
        } else {
            NBSMB_IPV6_PROTECTION_PARAM NbParam = { 0 };

            NbParam.uIPv6ProtectionLevel = _wtoi(Argv[2]);
            NbParam.bIPv6EnableOutboundGlobal = _wtoi(Argv[3]);
            SmbSetIPv6ProtectionLevel(handle, &NbParam);
        }
    }

    NtClose(handle);
}

HANDLE
OpenSmb(
    LPWSTR Name
    )
{
    UNICODE_STRING      ucName;
    OBJECT_ATTRIBUTES   ObAttr;
    HANDLE              StreamHandle;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            status;

    RtlInitUnicodeString(&ucName, Name);

    InitializeObjectAttributes(
            &ObAttr,
            &ucName,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );
    status = NtCreateFile (
            &StreamHandle,
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
            &ObAttr,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0
            );
    if (status != STATUS_SUCCESS) {
        return NULL;
    }
    return StreamHandle;
}

NTSTATUS
CallDriver(
    HANDLE  hSmb,
    DWORD   Ioctl,
    PVOID   OutputBuffer,
    ULONG   OutputLength,
    PVOID   InputBuffer,
    ULONG   InputLength
    )
{
    NTSTATUS    status;
    IO_STATUS_BLOCK iosb;

    status = NtDeviceIoControlFile(
            hSmb,
            NULL,
            NULL,
            NULL,
            &iosb,
            Ioctl,
            InputBuffer,
            InputLength,
            OutputBuffer,
            OutputLength
            );
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                hSmb,
                TRUE,
                NULL
                );
        if (NT_SUCCESS(status)) {
            status = iosb.Status;
        }
    }

    return status; }

NTSTATUS
SmbstatEnableNagling(
    HANDLE  hSmb
    )
{
    NTSTATUS    status;

    status = CallDriver(
            hSmb,
            IOCTL_SMB_ENABLE_NAGLING,
            NULL,
            0,
            NULL,
            0
            );
    if (status != STATUS_SUCCESS) {
        printf ("SmbStop: return 0x%08lx\n", status);
    }
    return status;
}

NTSTATUS
SmbstatDisableNagling(
    HANDLE  hSmb
    )
{
    NTSTATUS    status;

    status = CallDriver(
            hSmb,
            IOCTL_SMB_DISABLE_NAGLING,
            NULL,
            0,
            NULL,
            0
            );
    if (status != STATUS_SUCCESS) {
        printf ("SmbStop: return 0x%08lx\n", status);
    }
    return status;
}

NTSTATUS
SmbstatStart(
    HANDLE  hSmb
    )
{
    NTSTATUS    status;

    status = CallDriver(
            hSmb,
            IOCTL_SMB_START,
            NULL,
            0,
            NULL,
            0
            );
    if (status != STATUS_SUCCESS) {
        printf ("SmbStop: return 0x%08lx\n", status);
    }
    return status;
}

NTSTATUS
SmbstatStop(
    HANDLE  hSmb
    )
{
    NTSTATUS    status;

    status = CallDriver(
            hSmb,
            IOCTL_SMB_STOP,
            NULL,
            0,
            NULL,
            0
            );
    if (status != STATUS_SUCCESS) {
        printf ("SmbStop: return 0x%08lx\n", status);
    }
    return status;
}

NTSTATUS
SmbSetIPv6ProtectionLevel(
    HANDLE  hSmb,
    PNBSMB_IPV6_PROTECTION_PARAM pNbParam
    )
{
    NTSTATUS    status;

    printf("Level %d\n", pNbParam->uIPv6ProtectionLevel);
    printf("Flag %d\n", pNbParam->bIPv6EnableOutboundGlobal);
    status = CallDriver(
            hSmb,
            IOCTL_SMB_SET_IPV6_PROTECTION_LEVEL,
            NULL,
            0,
            pNbParam,
            sizeof(pNbParam[0])
            );
    if (status != STATUS_SUCCESS) {
        printf ("SmbSetIPv6ProtectionLevel: return 0x%08lx\n", status);
    }
    return status;
}



void
ausage(void)
{
    NlsPutMsg(STDOUT, SMB_MESSAGE_15);
    // printf("You do not have local Administrator privileges.\n");
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\inf\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d date -v 

$(O)\netsmb.inf: $(_INX)\netsmb.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\lib\fileio.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    fileio.c

Abstract:

    A set of function similar to fopen, fclose and fgetc

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "fileio.tmh"

#pragma alloc_text(PAGE, Smb_fopen)
#pragma alloc_text(PAGE, Smb_fclose)
#pragma alloc_text(PAGE, Smb_fgetc)

PSMB_FILE
Smb_fopen(
    PWCHAR  path,
    PWCHAR  mode
    )
{
    PSMB_FILE           fp;
    OBJECT_ATTRIBUTES   attr;
    UNICODE_STRING      ucPath;
    NTSTATUS            status;
    HANDLE              handle;
    IO_STATUS_BLOCK     iostatus;

    PAGED_CODE();

    //
    // Only readonly is supported
    //
    if (mode[0] != L'r' || mode[1] != L'\0') {
        SmbPrint(SMB_TRACE_DNS, ("Incorrect mode %d of %s\n", __LINE__, __FILE__));
        return NULL;
    }

    fp = (PSMB_FILE)ExAllocatePoolWithTag(
            PagedPool,
            sizeof(fp[0]),
            'pBMS'
            );
    if (fp == NULL) {
        SmbPrint(SMB_TRACE_DNS, ("Not enough memory %d of %s\n", __LINE__, __FILE__));
        return NULL;
    }

    RtlInitUnicodeString(&ucPath, path);
    InitializeObjectAttributes(
            &attr,
            &ucPath,
            OBJ_CASE_INSENSITIVE| OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    handle = NULL;
    status = ZwCreateFile(
            &handle,
            SYNCHRONIZE | FILE_READ_DATA,
            &attr,
            &iostatus,
            0,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN,
            FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );
    if (handle == NULL) {
        SmbPrint(SMB_TRACE_DNS, ("ZwCreateFile return 0x%08lx %Z %d of %s\n",
                    status, &ucPath, __LINE__, __FILE__));
        ExFreePool(fp);
        return NULL;
    }
    RtlZeroMemory(fp, sizeof(fp[0]));

    fp->fd = handle;
    //
    // Make it look like we reach the end of lookahead buffer
    //
    fp->offset = fp->size = SMB_FILEIO_LOOKAHEAD_SIZE;

    return fp;
}

void
Smb_fclose(
    PSMB_FILE   fp
    )
{
    if (NULL == fp) {
        return;
    }

    if (fp->fd) {
        ZwClose(fp->fd);
    }

    ExFreePool(fp);
}

int
Smb_fgetc(
    PSMB_FILE   fp
    )
{
    NTSTATUS    status;
    IO_STATUS_BLOCK iosb;

    if (fp->offset < fp->size) {
        return fp->Buffer[fp->offset++];
    }

    //
    // EOF?
    //
    if (fp->size < SMB_FILEIO_LOOKAHEAD_SIZE) {
        return EOF;
    }

    status = ZwReadFile(
            fp->fd,
            NULL,
            NULL,
            NULL,
            &iosb,
            fp->Buffer,
            SMB_FILEIO_LOOKAHEAD_SIZE,
            NULL,
            NULL
            );
    if (status != STATUS_SUCCESS) {
        fp->offset = fp->size = 0;
        SmbPrint(SMB_TRACE_DNS, ("ZwReadFile return 0x%08lx %d of %s\n", status, __LINE__, __FILE__));
        return EOF;
    }

    fp->size = (int)iosb.Information;
    SmbPrint(SMB_TRACE_DNS, ("ZwReadFile read %d bytes %d of %s\n", fp->size, __LINE__,__FILE__));
    fp->offset = 0;
    if (fp->offset < fp->size) {
        return fp->Buffer[fp->offset++];
    }
    return EOF;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\kdext\smbkd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    smbkd.c

Abstract:

    Smb kd extension (To be finished)

Author:

    Jiandong Ruan

Notes:

Revision History:

    12-Mar-2001 jruan

--*/

#include <nt.h>
#include <ntrtl.h>

#define KDEXTMODE
#define KDEXT_64BIT

#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "winsock2.h"
#include "winsock.h"
#include <ws2tcpip.h>
#include "../inc/ip6util.h"
#include "../sys/drv/precomp.h"

#define PRINTF  dprintf

EXT_API_VERSION        ApiVersion = {
        (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff),
        EXT_API_VERSION_NUMBER64, 0
    };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                ChkTarget;

DECLARE_API(dumpcfg)
{
    ULONG64         SmbDeviceAddr, SmbServerAddr;
    ULONG64         ConfigPtr;
    ULONG           TcpCfgOffset;
    SYM_DUMP_PARAM  SymDump = { 0 };
    CHAR            *cfg_sym = "smb!SmbCfg";
    CHAR            *dns_sym = "smb!Dns";
    CHAR            *smbdev_sym = "smb!_SMB_DEVICE";
    CHAR            *smbsrv_sym = "smb!_SMB_CLIENT_ELEMENT";
    CHAR            *tcp_sym = "smb!_SMB_TCP_INFO";

    PRINTF ("dt %s\n", cfg_sym);
    SymDump.size  = sizeof(SYM_DUMP_PARAM);
    SymDump.sName = cfg_sym;
    Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);

    PRINTF ("dt %s\n", dns_sym);
    SymDump.size  = sizeof(SYM_DUMP_PARAM);
    SymDump.sName = dns_sym;
    Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);

    ConfigPtr = GetExpression(cfg_sym);
    InitTypeRead(ConfigPtr, smb!SMBCONFIG);
    SmbDeviceAddr = ReadField(SmbDeviceObject);
    PRINTF ("dt %s %16.16I64x\n", smbdev_sym, SmbDeviceAddr);
    SymDump.size  = sizeof(SYM_DUMP_PARAM);
    SymDump.sName = smbdev_sym;
    SymDump.addr  = SmbDeviceAddr;
    Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);

    PRINTF ("\n************ TCP Configuration ****************\n");
    if (GetFieldOffset("smb!_SMB_DEVICE", (LPSTR)"Tcp4", &TcpCfgOffset)) {
        PRINTF ("Cannot find the offset of smb!_SMB_CONNECT!TraceRcv\n");
        return;
    }
    PRINTF ("Dump IPv4 TCP configuration: dt %s %16.16I64x\n", tcp_sym, SmbDeviceAddr + TcpCfgOffset);
    SymDump.size  = sizeof(SYM_DUMP_PARAM);
    SymDump.sName = tcp_sym;
    SymDump.addr  = SmbDeviceAddr + TcpCfgOffset;
    Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);

    if (GetFieldOffset("smb!_SMB_DEVICE", (LPSTR)"Tcp6", &TcpCfgOffset)) {
        PRINTF ("Cannot find the offset of smb!_SMB_CONNECT!TraceRcv\n");
        return;
    }
    PRINTF ("Dump IPv6 TCP configuration: dt %s %16.16I64x\n", tcp_sym, SmbDeviceAddr + TcpCfgOffset);
    SymDump.size  = sizeof(SYM_DUMP_PARAM);
    SymDump.sName = tcp_sym;
    SymDump.addr  = SmbDeviceAddr + TcpCfgOffset;
    Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);

    InitTypeRead(SmbDeviceAddr, smb!_SMB_DEVICE);
    SmbServerAddr = ReadField(SmbServer);
    if (SmbServerAddr) {
        PRINTF ("\n************ Smb Server Client Element ****************\n");
        PRINTF ("dt %s %16.16I64x\n", smbsrv_sym, SmbServerAddr);
        SymDump.size  = sizeof(SYM_DUMP_PARAM);
        SymDump.sName = smbsrv_sym;
        SymDump.addr  = SmbServerAddr;
        Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);
    }
}

__inline
ULONG
read_list_entry(
    ULONG64 addr,
    PLIST_ENTRY64 List
    )
{
    if (InitTypeRead(addr, LIST_ENTRY)) {
        return 1;
    }
    List->Flink = ReadField(Flink);
    List->Blink = ReadField(Blink);
    return 0;
}

#define READLISTENTRY   read_list_entry 

/*++
    Call callback for each entry in the list
 --*/
typedef BOOL (*LIST_FOR_EACH_CALLBACK)(ULONG64 address, PVOID);
int
ListForEach(ULONG64 address, int maximum, PVOID pContext, LIST_FOR_EACH_CALLBACK callback)
{
    LIST_ENTRY64    list;
    int             i;

    if (READLISTENTRY(address, &list)) {
        PRINTF ("Failed to read memory 0x%I64lx\n", address);
        return (-1);
    }
    if (list.Flink == address) {
        return (-1);
    }

    if (maximum < 0) {
        maximum = 1000000;
    }
    for (i = 0; i < maximum && (list.Flink != address); i++) {
        /*
         * Allow user to break us.
         */
        if (CheckControlC()) {
            break;
        }
        callback(list.Flink, pContext);
        if (READLISTENTRY(list.Flink, &list)) {
            PRINTF ("Failed to read memory 0x%I64lx\n", list.Flink);
            return (-1);
        }
    }
    return i;
}

#define MAX_LIST_ELEMENTS 4096

LPSTR Extensions[] = {
    "SMB6 debugger extensions",
    0
};

LPSTR LibCommands[] = {
    "help -- print out these messages",
    "tracercv -- dump the trace log for TDI receive handler",
    "srvmap   -- dump IPv6-NetBIOS name mapping (only for SRV)",
    "dumpcfg  -- dump smb common global information",
    "clients  -- dump the client list",
    "client   -- dump a client",
    "interface -- dump a interface",
    0
};

DECLARE_API(help)
{
    int i;

    for( i=0; Extensions[i]; i++ )
        PRINTF( "   %s\n", Extensions[i] );

    for( i=0; LibCommands[i]; i++ )
        PRINTF( "   %s\n", LibCommands[i] );
    return;
}

DECLARE_API(version)
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    PRINTF ( "NETBT: %s extension dll (build %d) debugging %s kernel (build %d)\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

#define MIN(x,y)  ((x) < (y) ? (x) : (y))

DECLARE_API(interface)
{
    CHAR            *smbsrv_sym = "smb!SMB_TCP_DEVICE";
    SYM_DUMP_PARAM  SymDump = { 0 };
    ULONG64         addr;

    addr = GetExpression(args);
    PRINTF ("****** dt %s %16.16I64x\n", smbsrv_sym, addr);
    SymDump.size  = sizeof(SYM_DUMP_PARAM);
    SymDump.sName = smbsrv_sym;
    SymDump.addr  = addr;
    Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);
    PRINTF("\n");
}

DECLARE_API(tracercv)
{
    ULONG64 addr;
    ULONG   tag, head, i;
    ULONG   traceoffset;
    SMB_TRACE_RCV   traces;
    CHAR            fn[512];

    if (*args == 0) {
        PRINTF ("tracercv connect_object\n");
        return;
    }

    addr = GetExpression(args);
    if (0 == addr) {
        PRINTF ("tracercv connect_object\n");
        return;
    }

    InitTypeRead(addr, smb!_SMB_CONNECT);
    tag = (ULONG)ReadField(Tag);
    if (tag != TAG_CONNECT_OBJECT) {
        PRINTF ("Incorrect tag: 0x%08lx\n", tag);
        return;
    }

#if 0
    if (GetFieldOffset("smb!_SMB_CONNECT", (LPSTR)"TraceRcv", &traceoffset)) {
        PRINTF ("Cannot find the offset of smb!_SMB_CONNECT!TraceRcv\n");
        return;
    }
#endif
    if (GetFieldData(addr, "smb!_SMB_CONNECT", "TraceRcv", sizeof(SMB_TRACE_RCV), &traces)) {
        PRINTF ("Cannot find the smb!_SMB_CONNECT!TraceRcv\n");
        return;
    }
    head = ((traces.Head + 1) % SMB_MAX_TRACE_SIZE);
    for (i = head; i < SMB_MAX_TRACE_SIZE; i++) {
        if (traces.Locations[i].id) {
            break;
        }
    }

    for (; i < SMB_MAX_TRACE_SIZE; i++) {
        if (traces.Locations[i].id == 0) {
            PRINTF ("Invalid trace Id: index=%3d, line=%d\n", i, traces.Locations[i].ln);
            continue;
        }
        PRINTF ("%3d: Id=0x%08lx at line %d\n",
                i - head + 1, traces.Locations[i].id, traces.Locations[i].ln);
    }
    for (i = 0; i < head; i++) {
        if (traces.Locations[i].id == 0) {
            PRINTF ("Invalid trace Id: index=%3d, line=%d\n", i, traces.Locations[i].ln);
            continue;
        }
        PRINTF ("%3d: Id=0x%08lx at line %d\n",
                SMB_MAX_TRACE_SIZE - head + i + 1, traces.Locations[i].id, traces.Locations[i].ln);
    }
}

BOOL
clientlist_callback(ULONG64 addr, const int *bkt)
{
    static  ULONG   addr_offset = (ULONG)(-1);
    CHAR            *smbsrv_sym = "smb!_SMB_CLIENT_ELEMENT";
    SYM_DUMP_PARAM  SymDump = { 0 };

    if (addr_offset == (ULONG)(-1)) {
        if (GetFieldOffset(smbsrv_sym, (LPSTR)"Linkage", &addr_offset)) {
            PRINTF ("Please fix your symbols\n");
            return FALSE;
        }
    }

    addr -= addr_offset;
    PRINTF ("****** dt %s %16.16I64x\n", smbsrv_sym, addr);
    SymDump.size  = sizeof(SYM_DUMP_PARAM);
    SymDump.sName = smbsrv_sym;
    SymDump.addr  = addr;
    Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);
    PRINTF("\n");
    return TRUE;
}

DECLARE_API(clients)
{
    ULONG64 ConfigPtr = 0, SmbDeviceAddr = 0;
    ULONG   ClientListOffset;
    CHAR    *cfg_sym = "smb!SmbCfg";

    ConfigPtr = GetExpression(cfg_sym);
    InitTypeRead(ConfigPtr, smb!SMBCONFIG);
    SmbDeviceAddr = ReadField(SmbDeviceObject);

    if (GetFieldOffset("smb!_SMB_DEVICE", (LPSTR)"ClientList", &ClientListOffset)) {
        PRINTF ("Cannot find the offset of smb!_SMB_CONNECT!TraceRcv\n");
        return;
    }
    PRINTF ("Dump client list\n");
    ListForEach(SmbDeviceAddr + ClientListOffset, -1, NULL, (LIST_FOR_EACH_CALLBACK)clientlist_callback);
}

BOOL
connect_callback(ULONG64 addr, const int *bkt)
{
    static  ULONG   addr_offset = (ULONG)(-1);
    CHAR            *cnt_sym = "smb!_SMB_CONNECT";
    SYM_DUMP_PARAM  SymDump = { 0 };

    if (addr_offset == (ULONG)(-1)) {
        if (GetFieldOffset(cnt_sym, (LPSTR)"Linkage", &addr_offset)) {
            PRINTF ("Please fix your symbols\n");
            return FALSE;
        }
    }

    addr -= addr_offset;
    PRINTF ("****** dt %s %16.16I64x\n", cnt_sym, addr);
    SymDump.size  = sizeof(SYM_DUMP_PARAM);
    SymDump.sName = cnt_sym;
    SymDump.addr  = addr;
    Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);
    PRINTF("\n");
    return TRUE;
}

DECLARE_API(client)
{
    ULONG64 addr;
    ULONG   addr_offset, assoc_offset, active_offset;
    CHAR    *smbsrv_sym = "smb!_SMB_CLIENT_ELEMENT";

    if (*args == 0) {
        PRINTF ("tracercv connect_object\n");
        return;
    }
    if (GetFieldOffset(smbsrv_sym, (LPSTR)"Linkage", &addr_offset)) {
        PRINTF ("Please fix your symbols\n");
        return;
    }
    if (GetFieldOffset(smbsrv_sym, (LPSTR)"AssociatedConnection", &assoc_offset)) {
        PRINTF ("Please fix your symbols\n");
        return;
    }
    if (GetFieldOffset(smbsrv_sym, (LPSTR)"ActiveConnection", &active_offset)) {
        PRINTF ("Please fix your symbols\n");
        return;
    }

    addr = GetExpression(args);
    clientlist_callback(addr + addr_offset, NULL);

    PRINTF ("Dump associated connections\n");
    ListForEach(addr + assoc_offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)connect_callback);
    PRINTF ("Dump Active connections\n");
    ListForEach(addr + active_offset, -1, NULL, (LIST_FOR_EACH_CALLBACK)connect_callback);
}

BOOL
srvmap_callback(ULONG64 addr, const int *bkt)
{
    static  ULONG   addr_offset = (ULONG)(-1);
    struct  sockaddr_in6 addr_in6 = { 0 };
    LONG    RefCount;
    DWORD   SerialNumber, dwError;
    CHAR    host[64];

    if (addr_offset == (ULONG)(-1)) {
        if (GetFieldOffset("smb!SMB_IPV6_NETBIOS", (LPSTR)"Linkage", &addr_offset)) {
            PRINTF ("Please fix your symbols\n");
            return FALSE;
        }
    }

    addr -= addr_offset;
    if (InitTypeRead(addr, smb!SMB_IPV6_NETBIOS)) {
        PRINTF ("Please fix your symbols\n");
        return FALSE;
    }
    RefCount     = (LONG)ReadField(RefCount);
    SerialNumber = (DWORD)ReadField(Serial);
    if (GetFieldData(addr, "smb!SMB_IPV6_NETBIOS", "IpAddress", 16, &addr_in6.sin6_addr)) {
        PRINTF ("Please fix your symbols\n");
        return FALSE;
    }
    addr_in6.sin6_family = AF_INET6;
    dwError = inet_ntoa6(host, sizeof(host), (PSMB_IP6_ADDRESS)&addr_in6.sin6_addr);
    if (dwError == 0) {
        return FALSE;
    }

    PRINTF ("%03d\t< %16.16I64x >  *SMBSER%08x  | %-40s | %02d\n",
            *bkt, addr, SerialNumber, host, RefCount);
    return TRUE;
}

DECLARE_API(srvmap)
{
    ULONG64         addr = 0;
    ULONG64         hashtbl_addr = 0;
    ULONG64         buckets_addr = 0;
    ULONG64         sizeof_list  = 0;
    int             i, bucket_number = 0;
    SYM_DUMP_PARAM  SymDump = { 0 };
    CHAR            *mapping_sym = "smb!SmbIPv6Mapping";
    CHAR            *hash_sym = "smb!SMB_HASH_TABLE";

    addr = GetExpression(mapping_sym);
    if (0 == addr) {
        PRINTF ("Please fix your symbols\n");
        return;
    }

    //
    // dump the mapping structure
    //
    PRINTF ("dt %s\n", mapping_sym);
    SymDump.size  = sizeof(SYM_DUMP_PARAM);
    SymDump.sName = mapping_sym;
    Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);

    //
    // dump the hash table
    //
    InitTypeRead(addr, smb!SMB_IPV6_NETBIOS_TABLE);
    hashtbl_addr = ReadField(HashTable);
    if (0 == hashtbl_addr) {
        PRINTF ("Please fix your symbols\n");
        return;
    }
    if (GetFieldOffset(hash_sym, (LPSTR)"Buckets", (LONG*)&buckets_addr)) {
        PRINTF ("Please fix your symbols\n");
        return;
    }
    buckets_addr += hashtbl_addr;
    PRINTF ("dt %s %16.16I64x\n", hash_sym, hashtbl_addr);
    SymDump.size  = sizeof(SYM_DUMP_PARAM);
    SymDump.sName = hash_sym;
    SymDump.addr  = hashtbl_addr;
    Ioctl(IG_DUMP_SYMBOL_INFO, &SymDump, SymDump.size);

    InitTypeRead(hashtbl_addr, smb!SMB_HASH_TABLE);
    bucket_number = (int)ReadField(NumberOfBuckets);
    if (0 >= bucket_number) {
        PRINTF ("Please fix your symbols\n");
        return;
    }

    //
    // dump each bucket
    //
    sizeof_list = GetTypeSize ("LIST_ENTRY");
    if (0 == sizeof_list) {
        PRINTF ("Please fix your symbols\n");
        return;
    }
    PRINTF ("[Bkt#]\t<     Address      >  <     Name    >  |                IPv6 Address              | RefC\n");
    PRINTF ("================================================================================================\n");
    for (i = 0; i < bucket_number; i++) {
        ListForEach(buckets_addr + i * sizeof_list, -1, &i, (LIST_FOR_EACH_CALLBACK)srvmap_callback);
    }
}

//
// Standard Functions
//
DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    WSADATA wsaData;

    switch (dwReason) {
    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_PROCESS_DETACH:
        WSAStartup(MAKEWORD(2, 0), &wsaData);
        break;

    case DLL_PROCESS_ATTACH:
        WSACleanup();
        break;
    }

    return TRUE;
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;

    return;
}

VOID
CheckVersion(VOID)
{
    return;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\lib\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <tdi.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <svcguid.h>

#include "ip6util.h"
#include "smbioctl.h"

#define DNS_MAX_RESOLVER    2

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\smbsvc\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <tdi.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#include "ip6util.h"
#include "smbioctl.h"
#include "svclib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\connect.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    connect.c

Abstract:

    Implement the session setup/shutdown (TDI_CONNECT and TDI_DISCONNECT)

Author:

    Jiandong Ruan

Revision History:

--*/
#include "precomp.h"
#include "connect.tmh"

NTSTATUS
FindTdiAddress(
    PVOID   TdiAddress,
    ULONG   TdiAddressLength,
    USHORT  AddressType,
    PVOID   *AddressFound,
    PULONG  AddressLength
    );

void
SmbGetHostCompletion(
    PSMB_GETHOST_CONTEXT    Context
    );

VOID
SmbStartTcpSession (
    PSMB_CONNECT_CONTEXT    pSmbConnectContext
    );

void
SmbStartTcpSessionCompletion(
    PSMB_CONNECT_CONTEXT    Context
    );

NTSTATUS
SmbQueueStartTcpSession (
    IN PSMB_CONNECT_CONTEXT pSmbConnectContext
    );

NTSTATUS
SmbCheckConnect(
    PSMB_CONNECT    ConnectObject
    )
/*++

Routine Description:

    This function checks if a connection object is in a valid state
    for making a connection.

Arguments:

Return Value:

--*/
{
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    if (IsDisAssociated(ConnectObject)) {
        ASSERT(0);
        return STATUS_INVALID_HANDLE;
    }

    if (IsBusy(ConnectObject)) {
        return STATUS_DEVICE_BUSY;
    }

    if (!IsDisconnected(ConnectObject)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Don't allow SRV to make outbound connection
    //
    if (ConnectObject->ClientObject == ConnectObject->Device->SmbServer) {
        ASSERT(0);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (ConnectObject->TcpContext) {
        ASSERT(0);
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
SmbConnect(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
/*++

Routine Description:

    TDI_CONNECT

    Note:
    Starting from Whistler, RDR always send us a TDI_NETBIOS_UNICODE_EX address. Support for
    other address type is postponed. TDI_NETBIOS_UNICODE_EX is a superset of TDI_NETBIOS and
    TDI_NETBIOS_EX.

Arguments:

Return Value:

Note:
    Since it is inconvinient to clean up TCP connection (it requires PASSIVE_LEVEL),
    we don't cleanup it. We still keep the TCP connection even though we got an error.
    The cleanup of TCP connections will be postponed until the client call TDI_DISCONNECT,
    TDI_DISASSOCIATE_ADDRESS or close the connection.

--*/
{
    DWORD                   Size = 0;
    PSMB_GETHOST_CONTEXT    Context = NULL;
    PIO_STACK_LOCATION      IrpSp = NULL;
    KIRQL                   Irql;
    PSMB_CONNECT            ConnectObject = NULL;
    NTSTATUS                status;
    ULONG                   AddressLength;
    PTDI_REQUEST_KERNEL     pRequestKernel = NULL;
    UNICODE_STRING          RemoteName;
    PTDI_ADDRESS_NETBIOS_UNICODE_EX pUnicodeAddress = NULL;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ConnectObject = SmbVerifyAndReferenceConnect(IrpSp->FileObject, SMB_REF_CONNECT);
    if (NULL == ConnectObject) {
        ASSERT(0);
        return STATUS_INVALID_HANDLE;
    }
    pRequestKernel  = (PTDI_REQUEST_KERNEL)&IrpSp->Parameters;

    SmbTrace (SMB_TRACE_CONNECT, ("TDI_CONNECT: pIrp %p ConnectOb %p", Irp, ConnectObject));
    SmbPrint (SMB_TRACE_CONNECT, ("TDI_CONNECT: %p\n", ConnectObject));

    //
    // Mark ConnectObject pending
    //
    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    status = SmbCheckConnect(ConnectObject);
    if (STATUS_SUCCESS != status) {
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        SmbTrace (SMB_TRACE_CONNECT, ("TDI_CONNECT: %p %!status!", ConnectObject, status));

        ASSERT(status != STATUS_PENDING);
        SmbDereferenceConnect(ConnectObject, SMB_REF_CONNECT);
        return status;
    }

    IoMarkIrpPending(Irp);

    SmbReuseConnectObject(ConnectObject);
    ConnectObject->State = SMB_CONNECTING;
    ConnectObject->PendingIRPs[SMB_PENDING_CONNECT] = Irp;
    ConnectObject->Originator = TRUE;

    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    //
    // Get remote name
    //
    status = FindTdiAddress(
            pRequestKernel->RequestConnectionInformation->RemoteAddress,
            pRequestKernel->RequestConnectionInformation->RemoteAddressLength,
            TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX,
            &pUnicodeAddress,
            &AddressLength
            );
    if (status != STATUS_SUCCESS || AddressLength < sizeof(TDI_ADDRESS_NETBIOS_UNICODE_EX)) {
        status = STATUS_INVALID_ADDRESS_COMPONENT;
        SmbTrace (SMB_TRACE_CONNECT, ("TDI_CONNECT: %p %!status!", ConnectObject, status));
        goto cleanup;
    }

    //
    // We support only NBT_READWRITE buffer type
    //
    if (pUnicodeAddress->NameBufferType != NBT_READWRITE) {
        status = STATUS_INVALID_ADDRESS_COMPONENT;
        SmbTrace (SMB_TRACE_CONNECT, ("TDI_CONNECT: %p %!status!", ConnectObject, status));
        goto cleanup;
    }
    if (pUnicodeAddress->RemoteName.Buffer != pUnicodeAddress->RemoteNameBuffer) {
        status = STATUS_INVALID_ADDRESS_COMPONENT;
        SmbTrace (SMB_TRACE_CONNECT, ("TDI_CONNECT: %p %!status!", ConnectObject, status));
        goto cleanup;
    }
    if (pUnicodeAddress->RemoteName.MaximumLength < sizeof(WCHAR)) {
        ASSERT(0);
        status = STATUS_INVALID_ADDRESS_COMPONENT;
        SmbTrace (SMB_TRACE_CONNECT, ("TDI_CONNECT: %p %!status!", ConnectObject, status));
        goto cleanup;
    }
    if (AddressLength < pUnicodeAddress->RemoteName.MaximumLength + sizeof(TDI_ADDRESS_NETBIOS_UNICODE_EX) - 2) {
        ASSERT(0);
        status = STATUS_INVALID_ADDRESS_COMPONENT;
        SmbTrace (SMB_TRACE_CONNECT, ("TDI_CONNECT: %p %!status!", ConnectObject, status));
        goto cleanup;
    }

    //
    // Do DNS name resolution
    //
    Size = ALIGN(sizeof(SMB_GETHOST_CONTEXT)) + DNS_NAME_BUFFER_LENGTH * sizeof(WCHAR);
    Context = (PSMB_GETHOST_CONTEXT)ExAllocatePoolWithTag(
            NonPagedPool,
            Size,
            'hBMS'
            );
    if (NULL == Context) {
        status = STATUS_NO_MEMORY;
        SmbTrace (SMB_TRACE_CONNECT, ("TDI_CONNECT: %p %!status!", ConnectObject, status));
        goto cleanup;
    }

    SmbInitAsyncContext(
            (PSMB_ASYNC_CONTEXT)Context,
            (PSMB_TDI_COMPLETION)SmbGetHostCompletion,
            ConnectObject,
            SmbCfg.DnsTimeout
            );

    Context->pUnicodeAddress = pUnicodeAddress;
    Context->FQDN.Buffer = (WCHAR*)(((PUCHAR)Context) + ALIGN(sizeof(SMB_GETHOST_CONTEXT)));
    Context->FQDN.Length = 0;
    Context->FQDN.MaximumLength = DNS_NAME_BUFFER_LENGTH * sizeof(WCHAR);
    RemoteName = pUnicodeAddress->RemoteName;

    SmbTrace (SMB_TRACE_CONNECT, ("%p: Resolving %Z",   ConnectObject, &RemoteName));
    SmbPrint (SMB_TRACE_CONNECT, ("%p: Resolving %Z\n", ConnectObject, &RemoteName));
    SmbAsyncGetHostByName(&RemoteName, Context);
    return STATUS_PENDING;

cleanup:
    ASSERT (NULL == Context);
    SmbSessionCompleteRequest(
            ConnectObject,
            STATUS_BAD_NETWORK_PATH,
            0
            );
    return STATUS_PENDING;
}

BOOL
IsSmbBoundToOutgoingInterface4(
    ULONG           DestIp
    )
{
    NTSTATUS        status;
    ULONG           Metric, OutgoingIfIndex;
    KIRQL           Irql;
    PIP4FASTQUERY   FastQuery = NULL;
    PLIST_ENTRY     entry = NULL;
    PSMB_TCP_DEVICE pIf = NULL;
    BOOL            found = FALSE;

    FastQuery = SmbCfg.SmbDeviceObject->Tcp4.FastQuery;
    if (NULL == FastQuery) {
        return TRUE;
    }

    if (INVALID_INTERFACE_INDEX == SmbCfg.SmbDeviceObject->Tcp4.LoopbackInterfaceIndex) {
        status = ((PIP4FASTQUERY)(FastQuery))(ntohl(INADDR_LOOPBACK), &OutgoingIfIndex, &Metric);
        if (status == STATUS_SUCCESS) {
            SmbCfg.SmbDeviceObject->Tcp4.LoopbackInterfaceIndex = OutgoingIfIndex;
            SmbPrint(SMB_TRACE_TCP, ("Loopback Interface Index = %d\n", OutgoingIfIndex));
            SmbTrace(SMB_TRACE_TCP, ("Loopback Interface Index = %d", OutgoingIfIndex));
        } else {
            SmbPrint(SMB_TRACE_TCP, ("Query loopback Interface Index returns 0x%08lx\n", status));
            SmbTrace(SMB_TRACE_TCP, ("Query loopback Interface Index returns %!status!", status));
            SmbCfg.SmbDeviceObject->Tcp4.LoopbackInterfaceIndex = INVALID_INTERFACE_INDEX;
        }
    }

    status = (FastQuery)(DestIp, &OutgoingIfIndex, &Metric);
    if (STATUS_SUCCESS != status || OutgoingIfIndex == INVALID_INTERFACE_INDEX) {
        //
        // TCP cannot find a route, return TRUE anyway
        //
        return TRUE;
    }

    if (OutgoingIfIndex == SmbCfg.SmbDeviceObject->Tcp4.LoopbackInterfaceIndex) {
        //
        // This is a local address
        //
        return TRUE;
    }

    //
    // This is a remote address
    //
    found = FALSE;
    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    entry = SmbCfg.IPDeviceList.Flink;
    while(entry != &SmbCfg.IPDeviceList) {
        pIf = CONTAINING_RECORD(entry, SMB_TCP_DEVICE, Linkage);
        entry = entry->Flink;

        if (pIf->InterfaceIndex != OutgoingIfIndex) {
            continue;
        }
        if (pIf->PrimaryIpAddress.sin_family == SMB_AF_INET && pIf->PrimaryIpAddress.ip4.sin4_addr) {
            found = pIf->EnableOutbound;
            break;
        }
    }
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);
    return found;
}

VOID
SmbCompleteConnectAttempts (
    PSMB_CONNECT_CONTEXT    pSmbConnectContext
    )
/*++

Routine Description:

    Complete the connect attempts

Arguments:

Return Value:

--*/
{
    PSMB_GETHOST_CONTEXT    pSmbGetHostContext = pSmbConnectContext->pSmbGetHostContext;
    PSMB_CONNECT            ConnectObject = (PSMB_CONNECT)pSmbGetHostContext->ClientContext;
    NTSTATUS                status = pSmbConnectContext->status;

    //
    // Set the proper status
    //
    if (pSmbConnectContext->usCurrentIP >= pSmbGetHostContext->ipaddr_num && 
        STATUS_INSUFFICIENT_RESOURCES != status) {
        status = STATUS_BAD_NETWORK_PATH;
    }

    SmbSessionCompleteRequest(ConnectObject, status, 0);

    ExFreePool(pSmbGetHostContext);
    ExFreePool(pSmbConnectContext);
}


VOID
SmbDelayedStartTcpSession (
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PVOID            pContext
    )
{
    PSMB_CONNECT_CONTEXT    pSmbConnectContext = pContext;

    PAGED_CODE();

    IoFreeWorkItem (pSmbConnectContext->pIoWorkItem);
    pSmbConnectContext->pIoWorkItem = NULL;

    SmbStartTcpSession (pSmbConnectContext);
}


void
SmbStartTcpSessionCompletion(
    PSMB_CONNECT_CONTEXT    pSmbConnectContext
    )
/*++

Routine Description:

    This routine will be called after TCP level session setup is finished.

Arguments:

Return Value:

--*/
{
    PSMB_GETHOST_CONTEXT    pSmbGetHostContext = pSmbConnectContext->pSmbGetHostContext;
    PSMB_CONNECT            ConnectObject = (PSMB_CONNECT)pSmbConnectContext->ClientContext;
    KIRQL                   Irql = 0;
    PSMB_TCP_CONTEXT        pTcpContext = NULL;
    NTSTATUS                status = STATUS_SUCCESS;

    SmbTrace (SMB_TRACE_CONNECT, ("TcpSession Complete: %p %!status!", ConnectObject, pSmbConnectContext->status));
    SmbPrint (SMB_TRACE_CONNECT, ("TcpSession Complete: %p %08lx\n", ConnectObject, pSmbConnectContext->status));

    switch (pSmbConnectContext->status) {
    case STATUS_SUCCESS:
    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_CANCELLED:
        goto done;
    }

    //
    // Advance to the next IP address
    //
    pSmbConnectContext->usCurrentIP++;
    if (pSmbConnectContext->usCurrentIP >= pSmbGetHostContext->ipaddr_num) {
        goto done;
    }

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    pTcpContext = ConnectObject->TcpContext;
    ConnectObject->TcpContext = NULL;
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
    SmbDelayedDestroyTcpContext (pTcpContext);

    status = SmbQueueStartTcpSession(pSmbConnectContext);

    if (STATUS_SUCCESS != status) {
        pSmbConnectContext->status = status;
        goto done;
    }
    return;

done:
    SmbCompleteConnectAttempts (pSmbConnectContext);
}

NTSTATUS
SmbQueueStartTcpSession (
    IN PSMB_CONNECT_CONTEXT pSmbConnectContext
    )
{
    PIO_WORKITEM pIoWorkItem = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    pIoWorkItem = IoAllocateWorkItem ((PDEVICE_OBJECT)SmbCfg.SmbDeviceObject);
    if (NULL == pIoWorkItem) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    pSmbConnectContext->pIoWorkItem = pIoWorkItem;
    IoQueueWorkItem (
        pIoWorkItem,
        SmbDelayedStartTcpSession,
        DelayedWorkQueue,
        pSmbConnectContext
        );

done:

    return status;
}


VOID
SmbStartTcpSession (
    PSMB_CONNECT_CONTEXT    pSmbConnectContext
    )
{
    PSMB_GETHOST_CONTEXT    pSmbGetHostContext = pSmbConnectContext->pSmbGetHostContext;
    PSMB_CONNECT            ConnectObject = (PSMB_CONNECT)pSmbGetHostContext->ClientContext;
    NTSTATUS                status = STATUS_SUCCESS;
    PSMB_TCP_CONTEXT        TcpContext = NULL;
    USHORT                  Port;
    PSMB_IP_ADDRESS         pSmbIpAddress = NULL;
    BOOLEAN                 bTryAllocateResource = FALSE;
    KIRQL                   Irql = 0;

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    ASSERT (ConnectObject->TcpContext == NULL);

    for (
        TcpContext = NULL, bTryAllocateResource = FALSE;
        pSmbConnectContext->usCurrentIP < pSmbGetHostContext->ipaddr_num;
        pSmbConnectContext->usCurrentIP++
        ) {

        pSmbIpAddress = &pSmbGetHostContext->ipaddr[pSmbConnectContext->usCurrentIP];
        switch (pSmbIpAddress->sin_family) {
        case SMB_AF_INET:
            if (SmbCfg.Tcp4Available &&
                IsSmbBoundToOutgoingInterface4(pSmbIpAddress->ip4.sin4_addr)) {

                TcpContext = SmbAllocateOutbound(&ConnectObject->Device->Tcp4);
                Port = ConnectObject->Device->Tcp4.Port;
                ConnectObject->FastSend = ConnectObject->Device->Tcp4.FastSend;
                bTryAllocateResource = TRUE;

                SmbTrace (SMB_TRACE_CONNECT, ("%p: try %d-th IP address: %!ipaddr!",
                            ConnectObject,
                            pSmbConnectContext->usCurrentIP + 1,
                            pSmbIpAddress->ip4.sin4_addr));
                SmbPrint (SMB_TRACE_CONNECT, ("%p: try %d-th IP address: IPv4\n",
                            ConnectObject,
                            pSmbConnectContext->usCurrentIP + 1));
            } else {
                SmbTrace (SMB_TRACE_CONNECT, ("%p: skip %d-th IP address: %!ipaddr!",
                            ConnectObject,
                            pSmbConnectContext->usCurrentIP + 1,
                            pSmbIpAddress->ip4.sin4_addr));
                SmbPrint (SMB_TRACE_CONNECT, ("%p: skip %d-th IP address: IPv4\n",
                            ConnectObject,
                            pSmbConnectContext->usCurrentIP + 1));

            }
            break;

        case SMB_AF_INET6:
            if (SmbCfg.Tcp6Available &&
                    (SmbCfg.bIPv6EnableOutboundGlobal ||
                     SMB_IS_ADDRESS_ALLOWED(pSmbIpAddress->ip6.sin6_addr_bytes))) {

                TcpContext = SmbAllocateOutbound(&ConnectObject->Device->Tcp6);
                Port = ConnectObject->Device->Tcp6.Port;
                ConnectObject->FastSend = ConnectObject->Device->Tcp6.FastSend;
                bTryAllocateResource = TRUE;

                SmbTrace (SMB_TRACE_CONNECT, ("%p: try %d-th IP address: %!IPV6ADDR!",
                            ConnectObject,
                            pSmbConnectContext->usCurrentIP + 1,
                            (PVOID)pSmbIpAddress->ip6.sin6_addr
                            ));

            } else {
                SmbTrace (SMB_TRACE_CONNECT, ("%p: skip %d-th IP address: %!IPV6ADDR!",
                            ConnectObject,
                            pSmbConnectContext->usCurrentIP + 1,
                            (PVOID)pSmbIpAddress->ip6.sin6_addr
                            ));
            }
            break;

        default:
            ASSERT (0);
            break;
        }

        if (NULL != TcpContext) {
            break;
        }
    }
     
    if (NULL == TcpContext) {
        status = (bTryAllocateResource)? STATUS_INSUFFICIENT_RESOURCES: STATUS_BAD_NETWORK_PATH;
        goto cleanup;
    }

    ASSERT (pSmbConnectContext->usCurrentIP < pSmbGetHostContext->ipaddr_num);

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    ConnectObject->TcpContext = TcpContext;
    ConnectObject->StateRcvHandler = WaitingHeader;
    ConnectObject->HeaderBytesRcved = 0;
    TcpContext->Connect.pLastUprCnt = TcpContext->Connect.UpperConnect = ConnectObject;
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    //
    // TBD: SmbAsyncConnect should honor the timeout
    //
    SmbInitAsyncContext(
            (PSMB_ASYNC_CONTEXT)pSmbConnectContext,
            (PSMB_TDI_COMPLETION)SmbStartTcpSessionCompletion,
            ConnectObject,
            5000        // 5 seconds timeout. It is not honored by SmbAysncConnect
            );
    ConnectObject->RemoteIpAddress = pSmbIpAddress[0];

    pSmbConnectContext->TcpConnect = TcpContext->Connect;
    SmbAsyncConnect(
        pSmbIpAddress,
        Port,
        pSmbConnectContext
        );

    return;

cleanup:
    ASSERT (pSmbConnectContext->usCurrentIP >= pSmbGetHostContext->ipaddr_num);
    ASSERT (status != STATUS_SUCCESS);

    pSmbConnectContext->status = status;
    SmbCompleteConnectAttempts (pSmbConnectContext);
}

void
SmbGetHostCompletion(
    PSMB_GETHOST_CONTEXT    Context
    )
/*++

Routine Description:

    This routine will be called after we get a result for dns name resolution

Arguments:

Return Value:

--*/
{
    PSMB_CONNECT            ConnectObject = (PSMB_CONNECT)Context->ClientContext;
    NTSTATUS                status = Context->status;
    PSMB_CONNECT_CONTEXT    pSmbConnectContext = NULL;

    ASSERT(NULL != ConnectObject);
    SmbTrace (SMB_TRACE_CONNECT, ("%p: name resolution completed with %!status!", ConnectObject, status));
    SmbPrint (SMB_TRACE_CONNECT, ("%p: name resolution completed with %08lx\n",   ConnectObject, status));
    if (STATUS_SUCCESS != status) {
        if (status != STATUS_CANCELLED) {
            status = STATUS_BAD_NETWORK_PATH;
        }
        goto cleanup;
    }

    pSmbConnectContext = (PSMB_CONNECT_CONTEXT)ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(SMB_CONNECT_CONTEXT),
            'sBMS'
            );
    if (NULL == pSmbConnectContext) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    RtlZeroMemory (pSmbConnectContext, sizeof(SMB_CONNECT_CONTEXT));
    pSmbConnectContext->ClientContext      = ConnectObject;
    pSmbConnectContext->usCurrentIP        = 0;
    pSmbConnectContext->pSmbGetHostContext = Context;
    pSmbConnectContext->pIoWorkItem        = NULL;

    SmbTrace (SMB_TRACE_CONNECT, ("%p: find %d IP address",   ConnectObject, Context->ipaddr_num));
    SmbPrint (SMB_TRACE_CONNECT, ("%p: find %d IP address\n", ConnectObject, Context->ipaddr_num));
    status = SmbQueueStartTcpSession(pSmbConnectContext);
    if (STATUS_SUCCESS != status) {
        goto cleanup;
    }
    return;

cleanup:
    if (NULL != Context) {
        ExFreePool(Context);
    }
    if (NULL != pSmbConnectContext) {
        ExFreePool(pSmbConnectContext);
    }
    SmbSessionCompleteRequest(ConnectObject, status, 0);
}


NTSTATUS
DisconnDone(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PSMB_TCP_CONTEXT TcpContext
    )
{
    KIRQL       Irql;
    PSMB_DEVICE SmbDevice;

    SmbDevice = SmbCfg.SmbDeviceObject;

    ASSERT(TcpContext->DisconnectIrp == Irp);
    SMB_ACQUIRE_SPINLOCK(SmbDevice, Irql);
    ASSERT(EntryIsInList(&SmbDevice->PendingDisconnectList, &TcpContext->Linkage));
    RemoveEntryList(&TcpContext->Linkage);
    InitializeListHead(&TcpContext->Linkage);
    SmbDevice->PendingDisconnectListNumber--;
    ASSERT(SmbDevice->PendingDisconnectListNumber >= 0);
    TcpContext->DisconnectIrp = NULL;
    if (IsListEmpty(&SmbDevice->PendingDisconnectList)) {
        KeSetEvent(&SmbDevice->PendingDisconnectListEmptyEvent, 0, FALSE);
        ASSERT(SmbDevice->PendingDisconnectListNumber == 0);
    }
    SMB_RELEASE_SPINLOCK(SmbDevice, Irql);

    if (Irp->IoStatus.Status == STATUS_SUCCESS) {
        SmbFreeTcpContext(TcpContext);
    } else {
        SmbDelayedDestroyTcpContext(TcpContext);
    }

    SmbFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SmbAsynchTcpDisconnect(
    PSMB_TCP_CONTEXT        TcpContext,
    ULONG                   Flags
    )
{
    PIRP                Irp;
    PFILE_OBJECT        FileObject;
    PDEVICE_OBJECT      DeviceObject;
    NTSTATUS            status;

    FileObject = TcpContext->Connect.ConnectObject;
    if (NULL == FileObject) {
        ASSERT (0);
        SmbTrace(SMB_TRACE_TCP, ("NULL FileObject !!!!"));
        return STATUS_INVALID_PARAMETER;
    }

    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    Irp = SmbAllocIrp(DeviceObject->StackSize);
    if (NULL == Irp) {
        SmbTrace(SMB_TRACE_TCP, ("no free IRP !!!!"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    TcpContext->DisconnectIrp = Irp;
    TdiBuildDisconnect(
            Irp,
            DeviceObject,
            FileObject,
            (PIO_COMPLETION_ROUTINE)DisconnDone,
            TcpContext,
            NULL,
            Flags,
            NULL,
            NULL
            );

    status = IoCallDriver(DeviceObject, Irp);

    SmbTrace (SMB_TRACE_CONNECT, ("return %!status!", status));
    return STATUS_PENDING;
}

VOID
SmbDelayedDisconnectTcp(
    IN PSMB_DEVICE      DeviceObject,
    IN PIO_WORKITEM     WorkItem
    )
{
    KIRQL       Irql;
    PLIST_ENTRY entry;
    NTSTATUS    status;
    ULONG       DisconnectFlag;

    PSMB_TCP_CONTEXT TcpContext;

    PAGED_CODE();

    ASSERT (DeviceObject->DisconnectWorkerRunning == TRUE);

    while(1) {
        SMB_ACQUIRE_SPINLOCK(DeviceObject, Irql);
        if (IsListEmpty(&DeviceObject->DelayedDisconnectList)) {
            SMB_RELEASE_SPINLOCK(DeviceObject, Irql);
            DeviceObject->DisconnectWorkerRunning = FALSE;
            break;
        }
        entry = RemoveHeadList(&DeviceObject->DelayedDisconnectList);
        InsertTailList(&DeviceObject->PendingDisconnectList, entry);
        DeviceObject->PendingDisconnectListNumber++;
        SMB_RELEASE_SPINLOCK(DeviceObject, Irql);

        TcpContext = CONTAINING_RECORD(entry, SMB_TCP_CONTEXT, Linkage);

        //
        // FIN attacking detection and protection
        // The idea is couting the disconnect request pending in TCP.
        // If we found extraodinary high number of disconnect request pending
        // in TCP, use abort instead of graceful disconnect for the remaining
        // disconnect request.
        //
        ASSERT(DeviceObject->EnterFAPM > DeviceObject->LeaveFAPM);
        ASSERT(DeviceObject->LeaveFAPM > 0);
        if (DeviceObject->PendingDisconnectListNumber >= DeviceObject->EnterFAPM) {
            DeviceObject->FinAttackProtectionMode = TRUE;
        }
        if (DeviceObject->PendingDisconnectListNumber <= DeviceObject->LeaveFAPM) {
            DeviceObject->FinAttackProtectionMode = FALSE;
        }
        if (DeviceObject->FinAttackProtectionMode) {
            DisconnectFlag = TDI_DISCONNECT_ABORT;
        } else {
            DisconnectFlag = TDI_DISCONNECT_RELEASE;
        }
        status = SmbAsynchTcpDisconnect(TcpContext, DisconnectFlag);
        if (status == STATUS_PENDING) {
            continue;
        }

        //
        // Should be out of resources. Put it back to the DelayedDisconnectList and
        // wait for the next round. (Resource may be available at that time)
        //
        ASSERT(status == STATUS_INSUFFICIENT_RESOURCES);
        SMB_ACQUIRE_SPINLOCK(DeviceObject, Irql);
        RemoveEntryList(entry);
        InsertTailList(&DeviceObject->DelayedDisconnectList, entry);
        SMB_RELEASE_SPINLOCK(DeviceObject, Irql);
    }
    IoFreeWorkItem(WorkItem);

    SMB_ACQUIRE_SPINLOCK(DeviceObject, Irql);
    if (IsListEmpty(&DeviceObject->PendingDisconnectList)) {
        KeSetEvent(&DeviceObject->PendingDisconnectListEmptyEvent, 0, FALSE);
        ASSERT(DeviceObject->PendingDisconnectListNumber == 0);
    } else {
        KeResetEvent(&DeviceObject->PendingDisconnectListEmptyEvent);
    }
    SMB_RELEASE_SPINLOCK(DeviceObject, Irql);
}

NTSTATUS
SmbQueueDisconnectWorkItem(
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_TCP_CONTEXT TcpContext
    )
{
    PIO_WORKITEM     WorkItem;

    //
    // The DeviceObject's spinlock should be held
    //
    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    InsertTailList(&DeviceObject->DelayedDisconnectList, &TcpContext->Linkage);

    //
    // Be nice to others!!! Don't start too many worker threads
    //
    if (!DeviceObject->DisconnectWorkerRunning) {

        //
        // This is not a critical error.
        // Since we have queued the Tcp endpoint in our list, we can
        // handle the termporarily out of resource.
        // If the resource is temporarily unavailable, we can fire another
        // work item the next time this routine is called. The only downside
        // is that the disconnecting could be delayed for longer time.
        //
        WorkItem = IoAllocateWorkItem(&DeviceObject->DeviceObject);
        if (NULL == WorkItem) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        DeviceObject->DisconnectWorkerRunning = TRUE;
        IoQueueWorkItem(
                WorkItem,
                (PIO_WORKITEM_ROUTINE)SmbDelayedDisconnectTcp,
                DelayedWorkQueue,
                WorkItem
                );
    }
    return STATUS_SUCCESS;
}

VOID
SmbDisconnectCleanup(
    IN PSMB_DEVICE          DeviceObject,
    IN PSMB_CLIENT_ELEMENT  ClientObject,
    IN PSMB_CONNECT         ConnectObject,
    IN PSMB_TCP_CONTEXT     TcpContext,
    IN DWORD                dwFlag,
    IN BOOL                 bWait
    )
/*++

Routine Description:

    Cleanup the connection object.

Arguments:

Return Value:

--*/
{
    PIRP        PendingIrp = NULL;
    LIST_ENTRY  PendingIrpList = { NULL };
    KIRQL       Irql = 0;
    NTSTATUS    status = STATUS_SUCCESS;

    ASSERT(ConnectObject->TcpContext == NULL);
    ASSERT(ClientObject != NULL);

    //
    // Grab the global lock to synchronize with TdiAcceptCompletion
    //
    SMB_ACQUIRE_SPINLOCK(DeviceObject, Irql);
    SMB_ACQUIRE_SPINLOCK_DPC(ClientObject);
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);

    KeRemoveQueueDpc(&ConnectObject->SmbHeaderDpc);
    ConnectObject->State = SMB_IDLE;
    ConnectObject->DpcRequestQueued = FALSE;

    //
    // If the TDI_ACCEPT is still pending, remove it now.
    // TBD: wait for the completion of TDI accept
    //
    if (ConnectObject->PendingIRPs[SMB_PENDING_ACCEPT]) {

        ConnectObject->PendingIRPs[SMB_PENDING_ACCEPT] = NULL;
        ASSERT (EntryIsInList(&ClientObject->PendingAcceptConnection, &ConnectObject->Linkage));

        //
        // This has to be non NULL so that we can set TcpContext->Connect.UpperConenct to NULL
        // below and synchronize with TdiAcceptCompletion
        //
        ASSERT (TcpContext);
        ASSERT (ClientObject->PendingAcceptNumber > 0);
        ASSERT (ClientObject == SmbCfg.SmbDeviceObject->SmbServer);
        ASSERT (!ConnectObject->Originator);

        ClientObject->PendingAcceptNumber--;
        SmbDereferenceConnect(ConnectObject, SMB_REF_CONNECT);

    } else {
        ASSERT (!EntryIsInList(&ClientObject->PendingAcceptConnection, &ConnectObject->Linkage));
    }

    RemoveEntryList(&ConnectObject->Linkage);
    InsertTailList(&ClientObject->AssociatedConnection, &ConnectObject->Linkage);

    if (NULL != TcpContext) {
        TcpContext->Connect.UpperConnect = NULL;
        if (!bWait) {
            if (TcpContext->Address.AddressHandle == NULL) {
                SmbQueueDisconnectWorkItem (ConnectObject->Device, TcpContext);
            } else {
                //
                // For outbound request, we got to destroy it because
                // TCP doesn't support reusing.
                //
                SmbDelayedDestroyTcpContext(TcpContext);
            }
            TcpContext = NULL;
        }
    }

    //
    // Move all the pending Irps to another linked list
    // REVIEW: what to do with the PendingIRPs[SMB_PENDING_RECEIVE]?
    //
    InitializeListHead (&PendingIrpList);
    if (NULL != ConnectObject->ClientIrp && !ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE]) {
        InsertTailList (&PendingIrpList, &ConnectObject->ClientIrp->Tail.Overlay.ListEntry);
        ConnectObject->ClientIrp = NULL;
    }

    while (!IsListEmpty(&ConnectObject->RcvList)) {
        PLIST_ENTRY entry;

        entry = RemoveHeadList(&ConnectObject->RcvList);
        PendingIrp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);
        InsertTailList (&PendingIrpList, &PendingIrp->Tail.Overlay.ListEntry);
    }
    InitializeListHead (&ConnectObject->RcvList);

    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    SMB_RELEASE_SPINLOCK_DPC(ClientObject);
    SMB_RELEASE_SPINLOCK(DeviceObject, Irql);

    //
    // We have disassociate all the pending IRPs from the ConnectObject.
    // The ConnectObject can be reused from now on. Now we complete all
    // the pending IRPs.
    //
    while (!IsListEmpty(&PendingIrpList)) {
        PLIST_ENTRY entry;

        entry = RemoveHeadList(&PendingIrpList);
        PendingIrp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

        IoAcquireCancelSpinLock(&Irql);
        IoSetCancelRoutine(PendingIrp, NULL);
        IoReleaseCancelSpinLock(Irql);

        PendingIrp->IoStatus.Status      = STATUS_CONNECTION_RESET;
        PendingIrp->IoStatus.Information = 0;
        
        IoCompleteRequest(PendingIrp, IO_NETWORK_INCREMENT);
    }

    //
    // Handling the synchronous disconnect case
    //
    if (NULL != TcpContext) {
        ASSERT (bWait);

        ASSERT (dwFlag == TDI_DISCONNECT_RELEASE || dwFlag == TDI_DISCONNECT_ABORT);

        //
        // Issue synchronous disconnection
        //
        status = SmbTcpDisconnect(
                TcpContext,
                1000,               // 1 second time out
                dwFlag
                );
        if (STATUS_SUCCESS != status || TcpContext->Address.AddressHandle != NULL) {
            SmbDelayedDestroyTcpContext(TcpContext);
        } else {
            SmbFreeTcpContext(TcpContext);
        }
    }
}

NTSTATUS
SmbDoDisconnect(
    PSMB_CONNECT    ConnectObject
    )
{
    PSMB_TCP_CONTEXT    TcpContext = NULL;
    PSMB_CLIENT_ELEMENT ClientObject = NULL;
    KIRQL               Irql;
    NTSTATUS            status;

    PAGED_CODE();

    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);

    TcpContext   = ConnectObject->TcpContext;
    ClientObject = ConnectObject->ClientObject;
    ConnectObject->TcpContext = NULL;
    ConnectObject->State = SMB_IDLE;

    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    SmbPrint(SMB_TRACE_CALL, ("DoDisconnect: Connect %p\n", ConnectObject));
    SaveDisconnectOriginator(ConnectObject, SMB_DISCONNECT_FROM_CLIENT);

    if (NULL != TcpContext) {
        ASSERT (NULL != ClientObject);

        //
        // Wait for the tcp-layer disconnect completion since
        // the disconnection is generated by our clients.
        //
        SmbDisconnectCleanup(ConnectObject->Device, ClientObject,
                            ConnectObject, TcpContext, TDI_DISCONNECT_RELEASE, TRUE);

        ASSERT(ConnectObject->State == SMB_IDLE);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SmbDisconnect(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
/*++

Routine Description:

    TDI_DISCONNECT
        To be implement.

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION      IrpSp = NULL;
    PSMB_CONNECT            ConnectObject = NULL;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ConnectObject = SmbVerifyAndReferenceConnect(IrpSp->FileObject, SMB_REF_DISCONNECT);
    if (NULL == ConnectObject) {
        ASSERT(0);
        return STATUS_INVALID_HANDLE;
    }

    SmbTrace (SMB_TRACE_CONNECT, ("TDI_DISCONNECT: pIrp %p ConnOb %p", Irp, ConnectObject));

    SmbDoDisconnect(ConnectObject);

    SmbDereferenceConnect(ConnectObject, SMB_REF_DISCONNECT);
    return STATUS_SUCCESS;
}

void
SmbSessionCompleteRequest(
    PSMB_CONNECT    ConnectObject,
    NTSTATUS        status,
    DWORD           information
    )
/*++

Routine Description:

    Complete a pending session request and cleanup the connection

    Note: we don't cleanup the Tcp level connection here since we could be
          called at DISPATCH_LEVEL. Instead, we leave tcp connections alive.
          the cleanup will be done when the client actually disassociate or
          close the connection.

          We can reuse the tcp connection if the client reattempt to make
          another connection.

Arguments:

--*/
{
    PIRP    Irp = NULL;
    KIRQL   Irql;
    PIO_STACK_LOCATION  IrpSp = NULL;
    PSMB_CLIENT_ELEMENT ClientObject = NULL;
    PSMB_TCP_CONTEXT    TcpContext = NULL;

    SmbTrace (SMB_TRACE_CONNECT, ("complete TDI_CONNECT: %p %!status!", ConnectObject, status));
    SmbPrint (SMB_TRACE_CONNECT, ("complete TDI_CONNECT: %p %08lx\n", ConnectObject, status));

    ClientObject = ConnectObject->ClientObject;
    ASSERT(NULL != ClientObject);
    if (NULL == ClientObject && status == STATUS_SUCCESS) {
        status = STATUS_INTERNAL_ERROR;
    }

    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    if (ClientObject) {
        SMB_ACQUIRE_SPINLOCK_DPC(ClientObject);
    }
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);
    Irp = ConnectObject->PendingIRPs[SMB_PENDING_CONNECT];
    ConnectObject->PendingIRPs[SMB_PENDING_CONNECT] = NULL;
    if (status == STATUS_SUCCESS) {
        ConnectObject->State = SMB_CONNECTED;
        RemoveEntryList(&ConnectObject->Linkage);
        InsertTailList(&ClientObject->ActiveConnection, &ConnectObject->Linkage);
        TcpContext = NULL;
    } else {
        ConnectObject->State = SMB_IDLE;
        TcpContext = ConnectObject->TcpContext;
        ConnectObject->TcpContext = NULL;
        if (TcpContext) {
            TcpContext->Connect.UpperConnect = NULL;
        }
    }
    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    if (ClientObject) {
        SMB_RELEASE_SPINLOCK_DPC(ClientObject);
    }
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    if (STATUS_CONNECTION_ACTIVE == status) {
        //
        // RDR could bugcheck if returning STATUS_CONNECTION_ACTIVE
        //
        ASSERT(0);
        status = STATUS_BAD_NETWORK_PATH;
    }

    //
    // Don't call SmbFreeOutbound() because the Tcp endpoint could be
    // in some inconsistent state which prohibit from being reused.
    // Simply destroy it!!!
    //
    SmbDelayedDestroyTcpContext(TcpContext);

    ASSERT (STATUS_PENDING != status);

    IoAcquireCancelSpinLock(&Irql);
    IoSetCancelRoutine(Irp, NULL);
    IoReleaseCancelSpinLock(Irql);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = information;

    SmbDereferenceConnect(ConnectObject, SMB_REF_CONNECT);
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    SmbTrace (SMB_TRACE_CONNECT, ("complete TDI_CONNECT: pIrp %p ConnOb %p %!status!",
                                Irp, ConnectObject, status));
}

NTSTATUS
FindTdiAddress(
    PVOID   TdiAddress,
    ULONG   TdiAddressLength,
    USHORT  AddressType,
    PVOID   *AddressFound,
    PULONG  AddressLength
    )
/*++

Routine Description:

    This routine search for a particular type of TDI address in a big compound address.

Arguments:

Return Value:

    STATUS_SUCCESS  if we find one
    Otherwise       fail

--*/
{
#define TA_ADDRESS_HEADER_SIZE      (FIELD_OFFSET(TA_ADDRESS,Address))
    int                 i;
    DWORD               RemainingBufferLength;
    PTA_ADDRESS         pAddress = NULL;
    TRANSPORT_ADDRESS UNALIGNED  *pTransportAddr = NULL;

    PAGED_CODE();

    pTransportAddr = (PTRANSPORT_ADDRESS)TdiAddress;
    if (TdiAddressLength < sizeof(pTransportAddr->TAAddressCount)) {
        return STATUS_UNSUCCESSFUL;
    }
    RemainingBufferLength = TdiAddressLength - sizeof(pTransportAddr->TAAddressCount);
    pAddress = (PTA_ADDRESS)pTransportAddr->Address;

    for (i = 0; i < pTransportAddr->TAAddressCount; i++) {
        //
        // First, make sure we can safely access pAddress->AddressLength
        //
        if (RemainingBufferLength < TA_ADDRESS_HEADER_SIZE) {
            return STATUS_INVALID_ADDRESS_COMPONENT;
        }
        RemainingBufferLength -= TA_ADDRESS_HEADER_SIZE;
        if (RemainingBufferLength < pAddress->AddressLength) {
            return STATUS_INVALID_ADDRESS_COMPONENT;
        }

        if (AddressType == pAddress->AddressType) {
            *AddressFound = pAddress->Address;
            *AddressLength = pAddress->AddressLength;
            return STATUS_SUCCESS;
        }

        RemainingBufferLength -= pAddress->AddressLength;
        pAddress = (PTA_ADDRESS)(((PUCHAR)pAddress) + pAddress->AddressLength + TA_ADDRESS_HEADER_SIZE);
    }
    return STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\debug.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Platform independent utility functions

Author:

    Jiandong Ruan

Revision History:

--*/
#include "precomp.h"
#include "debug.tmh"

#if DBG
BOOL
EntryIsInList(PLIST_ENTRY ListHead, PLIST_ENTRY SearchEntry)
/*++

Routine Description:

    This routine search SearchEntry in the list ListHead.
    NOTE: proper lock should be held before calling this function.

Arguments:

    ListHead    the head of the list
    SearchEntry the entry to be searched

Return Value:

    TRUE        if the entry is in the list
    FALSE       otherwise

--*/
{
    PLIST_ENTRY Entry;
    KIRQL       Irql;

    Irql = KeGetCurrentIrql();

    if (Irql < DISPATCH_LEVEL) {
        KdPrint (("Spin lock should be held before calling IsEntryList\n"));
        DbgBreakPoint();
        return FALSE;
    }

    Entry = ListHead->Flink;
    while(Entry != ListHead) {
        if (Entry == SearchEntry) {
            return TRUE;
        }
        Entry = Entry->Flink;
    }

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\smbsvc\smbsvc.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    smbsvc.c

Abstract:

    This the user-mode proxy for the kernel mode DNS resolver.

    features:
        1. Multi-threaded
            NBT4 use a single-threaded design. The DNS name resolution is a performance blocker.
            When a connection request is being served by LmhSvc, all the other requests requiring
            DNS resolution will be blocked.
        2. IPv6 and IPv4 compatiable
        3. can be run either as a service or standalone executable (for debug purpose)
           When started as service, debug spew is sent to debugger.
           When started as a standalong executable, the debug spew is sent to either
           the console or debugger. smbhelper.c contain the _main for the standardalone
           executable.

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include <lm.h>
#include <netevent.h>
#include <ws2tcpip.h>
#include <mstcpip.h>
#include <ipexport.h>
#include <winsock2.h>
#include <icmpapi.h>
#include "ping6.h"


static  HANDLE          hService;
static  SERVICE_STATUS  SvcStatus;

DWORD
SmbsvcUpdateStatus(
    VOID
    )
{
    DWORD   Error = ERROR_SUCCESS;

    if (NULL == hService) {
        return ERROR_SUCCESS;
    }
    SvcStatus.dwCheckPoint++;
    if (!SetServiceStatus(hService, &SvcStatus)) {
        Error = GetLastError();
    }
    return Error;
}

VOID
SvcCtrlHandler(
    IN DWORD controlcode
    )
{
    ULONG   i;

    switch (controlcode) {
    case SERVICE_CONTROL_STOP:
        SvcStatus.dwCurrentState = SERVICE_STOP_PENDING;
        SmbsvcUpdateStatus();

        SmbStopService(SmbsvcUpdateStatus);

        SvcStatus.dwCurrentState = SERVICE_STOPPED;
        SvcStatus.dwCheckPoint   = 0;
        SvcStatus.dwWaitHint     = 0;
        /* fall through */

    case SERVICE_CONTROL_INTERROGATE:
        SmbsvcUpdateStatus();
        break;

    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_SHUTDOWN:
    default:
        ASSERT(0);
        break;
    }
}

VOID
ServiceMain (
    IN DWORD argc,
    IN LPTSTR *argv
    )
{
    DWORD   Error;

#if DBG
    SmbSetTraceRoutine(DbgPrint);
#endif

    hService = RegisterServiceCtrlHandler(L"SmbSvc", SvcCtrlHandler);
    if (hService == NULL) {
        return;
    }
    SvcStatus.dwServiceType             = SERVICE_WIN32;
    SvcStatus.dwCurrentState            = SERVICE_START_PENDING;
    SvcStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP;
    SvcStatus.dwWin32ExitCode           = 0;
    SvcStatus.dwServiceSpecificExitCode = 0;
    SvcStatus.dwCheckPoint              = 0;
    SvcStatus.dwWaitHint                = 20000;         // 20 seconds
    SmbsvcUpdateStatus();

    Error = SmbStartService(0, SmbsvcUpdateStatus);
    if (ERROR_SUCCESS != Error) {
        SvcStatus.dwCurrentState = SERVICE_STOPPED;
    } else {
        SvcStatus.dwCurrentState = SERVICE_RUNNING;
    }
    SmbsvcUpdateStatus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\lib\ip6util.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ip6util.c

Abstract:

    Some IP6 utilities

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"

#ifndef isxdigit_W
#define isxdigit_W(x)     \
    ((x >= L'0' && x <= L'9') ||    \
    (x >= L'a' && x <= L'f') ||    \
    (x >= L'A' && x <= L'F'))
#endif

#ifndef isdigit_W
#define isdigit_W(x)      (x >= L'0' && x <= L'9')
#endif

ULONG __inline
xdigit2hex(WCHAR ch)
{
    ASSERT(isxdigit_W(ch));

    if (ch <= L'9') {
        return (ch - L'0');
    } else if (ch >= L'A' && ch <= L'F') {
        return (ch - L'A') + 10;
    } else {
        return (ch - L'a') + 10;
    }
}

BOOL
inet_addr6W(
    IN WCHAR                *str,
    IN OUT PSMB_IP6_ADDRESS addr
    )
/*++

Routine Description:

    Convert an unicode string into a IP6 address (network order).

    The L(3) grammar of the IP6 address:

            start: head COLON COLON tail
            head: hexs
            tail: hexs
            hexs: hex COLON hexs
                |
            COLON: ':'

    A 5-state automata is used to parse the string,
            states: {S, A, B, C, D}
            Starting state: S
            Accepting state: {S, B, C}

    state transition rules:
            S ==> S on a hex digit
            S ==> A on a COLON

            A ==> S on a hex digit
            A ==> B on a COLON

            B ==> C on a hex digit

            C ==> C on a hex digit
            C ==> D on a COLON

            D ==> C on a hex digit

Arguments:

    str     The unicode string containing the IP6 address
    addr    The output IP6 address

Return Value:

    TRUE    if the string is accepted by the automata and an IP6 address (network order)
            is return in the 'addr'
    FALSE   if the string is rejected by the automata
            result in 'addr' is undetermined.

--*/
{
    enum { STATE_S, STATE_A, STATE_B, STATE_C, STATE_D } state;
    int     i, num, tail;
    ULONG   hex;
    WCHAR   ch;

    state = STATE_S;

    addr->sin6_scope_id = 0;

    num = 0;
    tail = 0;
    hex  = 0;
    while ((ch = *str++)) {
        if (ch == '%') {
            break;
        }
        if (!isxdigit_W(ch) && ch != L':') {
            return FALSE;
        }

        switch(state) {
        case STATE_S:
            if (L':' == ch) {
                state = STATE_A;
            } else {
                hex <<= 4;
                hex |= xdigit2hex(ch);
                if (hex > 0xFFFFU) {
                    return FALSE;
                }
            }
            break;

        case STATE_A:
            if (L':' == ch) {
                state = STATE_B;
            } else {
                if (num >= 8) {
                    return FALSE;
                }
                addr->sin6_addr[num++] = htons((USHORT)hex);
                hex = xdigit2hex(ch);
                state = STATE_S;
            }
            break;

        case STATE_B:
            if (L':' == ch) {
                return FALSE;
            }
            if (num >= 8) {
                return FALSE;
            }
            addr->sin6_addr[num++] = htons((USHORT)hex);
            tail = num;
            hex = xdigit2hex(ch);
            state = STATE_C;
            break;

        case STATE_C:
            if (L':' == ch) {
                state = STATE_D;
            } else {
                hex <<= 4;
                hex |= xdigit2hex(ch);
                if (hex > 0xFFFFU) {
                    return FALSE;
                }
            }
            break;

        case STATE_D:
            if (L':' == ch) {
                return FALSE;
            }
            if (num >= 8) {
                return FALSE;
            }
            addr->sin6_addr[num++] = htons((USHORT)hex);
            hex = xdigit2hex(ch);
            state = STATE_C;
            break;
        }
    }

    //
    // Reject it since it ends up with a rejecting state.
    //
    if (state == STATE_A || state == STATE_D) {
        return FALSE;
    }

    if (num >= 8) {
        return FALSE;
    }
    addr->sin6_addr[num++] = htons((USHORT)hex);

    if (state == STATE_B) {
        for (i = num; i < 8; i++) {
            addr->sin6_addr[i] = 0;
        }
        return TRUE;
    } else if (state == STATE_S) {
        return (8 == num);
    }

    ASSERT (state == STATE_C);

    ASSERT(tail <= num);
    for (i = num - 1; i >= tail; i--) {
        addr->sin6_addr[8 - num + i] = addr->sin6_addr[i];
    }
    for (i = tail; i < 8 - num + tail; i++) {
        addr->sin6_addr[i] = 0;
    }

    //
    // Parse the scope ID
    //
    if (ch == '%') {
        LONG    scope_id;

        scope_id = 0;
        while ((ch = *str++)) {
            if (!isdigit_W(ch)) {
                return FALSE;
            }
            scope_id = scope_id * 10 + (ch - L'0');
        }
        addr->sin6_scope_id = scope_id;
    }
    return TRUE;
}

BOOL
inet_ntoa6W(
    OUT WCHAR           *Buffer,
    IN  DWORD           Size,
    IN PSMB_IP6_ADDRESS addr
    )
{
    USHORT  ch, tmp;
    int     i, tail, len, curtail, curlen;
    DWORD   j, k;

    tail = 8;
    len = 0;
    curtail = curlen = 0;
    for (i = 0; i < 8; i++) {
        if (0 == addr->sin6_addr[i]) {
            curlen++;
        } else {
            if (curlen > len) {
                tail = curtail;
                len  = curlen;
            }
            curtail = i + 1;
            curlen  = 0;
        }
    }
    if (curlen > len) {
        tail = curtail;
        len  = curlen;
    }

    j = 0;
    for (i = 0; i < tail; i++) {
        ch = htons(addr->sin6_addr[i]);
        if (ch) {
            k = 4;
            while (0 == (ch & 0xf000)) {
                ch <<= 4;
                k--;
            }
        } else {
            k = 1;
        }
        while (j < Size) {
            tmp = (ch & 0xf000) >> 12;
            ch <<= 4;
            if (tmp < 10) {
                Buffer[j] = L'0' + tmp;
            } else {
                Buffer[j] = L'A' + (tmp - 10);
            }
            j++;
            k--;
            if (k == 0) {
                break;
            }
        }
        if (k) {
            Buffer[Size-1] = L'\0';
            return FALSE;
        }

        if (i != tail - 1) {
            if (j < Size) {
                Buffer[j++] = L':';
            } else {
                Buffer[Size-1] = L'\0';
                return FALSE;
            }
        }
    }

    if (tail == 8) {
        if (j < Size) {
            Buffer[j] = L'\0';
            return TRUE;
        } else {
            Buffer[Size-1] = L'\0';
            return FALSE;
        }
    }

    if (j < Size) {
        Buffer[j++] = L':';
    } else {
        Buffer[Size-1] = L'\0';
        return FALSE;
    }

    if (tail + len >= 8) {
        if (j < Size) {
            Buffer[j++] = L':';
        } else {
            Buffer[Size-1] = L'\0';
            return FALSE;
        }
    }

    for (i = tail + len; i < 8; i++) {
        if (j < Size) {
            Buffer[j++] = L':';
        } else {
            Buffer[Size-1] = L'\0';
            return FALSE;
        }

        ch = htons(addr->sin6_addr[i]);
        if (ch) {
            k = 4;
            while (0 == (ch & 0xf000)) {
                ch <<= 4;
                k--;
            }
        } else {
            k = 1;
        }
        while (j < Size) {
            tmp = (ch & 0xf000) >> 12;
            ch <<= 4;
            if (tmp < 10) {
                Buffer[j] = L'0' + tmp;
            } else {
                Buffer[j] = L'A' + (tmp - 10);
            }
            j++;
            k--;
            if (k == 0) {
                break;
            }
        }
        if (k) {
            Buffer[Size-1] = L'\0';
            return FALSE;
        }
    }

    if (j < Size) {
        Buffer[j] = L'\0';
        return TRUE;
    } else {
        Buffer[Size-1] = L'\0';
        return FALSE;
    }
}

BOOL
inet_ntoa6(
    OUT CHAR            *Buffer,
    IN  DWORD           Size,
    IN PSMB_IP6_ADDRESS addr
    )
{
    DWORD   i;
    WCHAR   wBuf[40];

    if (!inet_ntoa6W(wBuf, 40, addr)) {
        return FALSE;
    }

    //
    // Don't call Rtl routine to convert
    // Unicode into Oem because we may
    // run at DISPATCH level
    //
    // For this particular case, we can
    // simply do type-cast coping.
    //
    for (i = 0; i < Size; i++) {
        Buffer[i] = (BYTE)(wBuf[i]);
        if (wBuf[i] == 0) {
            return TRUE;
        }
    }

    //
    // Buffer is too small
    //
    Buffer[Size-1] = 0;
    return FALSE;
}

/*********************************************************************************
 * inet_addr        Copy from winsocket
 *********************************************************************************/

/*
 * Internet address interpretation routine.
 * All the network library routines call this
 * routine to interpret entries in the data bases
 * which are expected to be an address.
 * The value returned is in network order.
 */
unsigned long PASCAL
inet_addrW(
    IN WCHAR *cp
    )

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    cp - A character string representing a number expressed in the
        Internet standard "." notation.

Return Value:

    If no error occurs, inet_addr() returns an in_addr structure
    containing a suitable binary representation of the Internet address
    given.  Otherwise, it returns the value INADDR_NONE.

--*/

{
        register unsigned long val, base, n;
        register WCHAR c;
        unsigned long parts[4], *pp = parts;

again:
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, other=decimal.
         */
        val = 0; base = 10;
        if (*cp == L'0') {
                base = 8, cp++;
                if (*cp == L'x' || *cp == L'X')
                        base = 16, cp++;
        }
	
        while (c = *cp) {
                if (isdigit(c)) {
                        val = (val * base) + (c - L'0');
                        cp++;
                        continue;
                }
                if (base == 16 && isxdigit(c)) {
                        val = (val << 4) + (c + 10 - (islower(c) ? L'a' : L'A'));
                        cp++;
                        continue;
                }
                break;
        }
        if (*cp == L'.') {
                /*
                 * Internet format:
                 *      a.b.c.d
                 *      a.b.c   (with c treated as 16-bits)
                 *      a.b     (with b treated as 24 bits)
                 */
                /* GSS - next line was corrected on 8/5/89, was 'parts + 4' */
                if (pp >= parts + 3) {
                        return ((unsigned long) -1);
                }
                *pp++ = val, cp++;
                goto again;
        }
        /*
         * Check for trailing characters.
         */
        if (*cp && !isspace(*cp)) {
                return (INADDR_NONE);
        }
        *pp++ = val;
        /*
         * Concoct the address according to
         * the number of parts specified.
         */
        n = (unsigned long)(pp - parts);
        switch ((int) n) {

        case 1:                         /* a -- 32 bits */
                val = parts[0];
                break;

        case 2:                         /* a.b -- 8.24 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | (parts[1] & 0xffffff);
                break;

        case 3:                         /* a.b.c -- 8.8.16 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xffff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                        (parts[2] & 0xffff);
                break;

        case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xff) || (parts[3] > 0xff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
                break;

        default:
                return (INADDR_NONE);
        }
        val = htonl(val);
        return (val);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\fileio.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    fileio.c

Abstract:

    A set of function similar to fopen, fclose and fgetc

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "fileio.tmh"

#pragma alloc_text(PAGE, Smb_fopen)
#pragma alloc_text(PAGE, Smb_fclose)
#pragma alloc_text(PAGE, Smb_fgetc)

PSMB_FILE
Smb_fopen(
    PWCHAR  path,
    PWCHAR  mode
    )
{
    PSMB_FILE           fp;
    OBJECT_ATTRIBUTES   attr;
    UNICODE_STRING      ucPath;
    NTSTATUS            status;
    HANDLE              handle;
    IO_STATUS_BLOCK     iostatus;

    PAGED_CODE();

    //
    // Only readonly is supported
    //
    if (mode[0] != L'r' || mode[1] != L'\0') {
        SmbPrint(SMB_TRACE_DNS, ("Incorrect mode %d of %s\n", __LINE__, __FILE__));
        return NULL;
    }

    fp = (PSMB_FILE)ExAllocatePoolWithTag(
            PagedPool,
            sizeof(fp[0]),
            'pBMS'
            );
    if (fp == NULL) {
        SmbPrint(SMB_TRACE_DNS, ("Not enough memory %d of %s\n", __LINE__, __FILE__));
        return NULL;
    }

    RtlInitUnicodeString(&ucPath, path);
    InitializeObjectAttributes(
            &attr,
            &ucPath,
            OBJ_CASE_INSENSITIVE| OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );

    handle = NULL;
    status = ZwCreateFile(
            &handle,
            SYNCHRONIZE | FILE_READ_DATA,
            &attr,
            &iostatus,
            0,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN,
            FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0
            );
    if (handle == NULL) {
        SmbPrint(SMB_TRACE_DNS, ("ZwCreateFile return 0x%08lx %Z %d of %s\n",
                    status, &ucPath, __LINE__, __FILE__));
        ExFreePool(fp);
        return NULL;
    }
    RtlZeroMemory(fp, sizeof(fp[0]));

    fp->fd = handle;
    //
    // Make it look like we reach the end of lookahead buffer
    //
    fp->offset = fp->size = SMB_FILEIO_LOOKAHEAD_SIZE;

    return fp;
}

void
Smb_fclose(
    PSMB_FILE   fp
    )
{
    if (NULL == fp) {
        return;
    }

    if (fp->fd) {
        ZwClose(fp->fd);
    }

    ExFreePool(fp);
}

int
Smb_fgetc(
    PSMB_FILE   fp
    )
{
    NTSTATUS    status;
    IO_STATUS_BLOCK iosb;

    if (fp->offset < fp->size) {
        return fp->Buffer[fp->offset++];
    }

    //
    // EOF?
    //
    if (fp->size < SMB_FILEIO_LOOKAHEAD_SIZE) {
        return EOF;
    }

    status = ZwReadFile(
            fp->fd,
            NULL,
            NULL,
            NULL,
            &iosb,
            fp->Buffer,
            SMB_FILEIO_LOOKAHEAD_SIZE,
            NULL,
            NULL
            );
    if (status != STATUS_SUCCESS) {
        fp->offset = fp->size = 0;
        SmbPrint(SMB_TRACE_DNS, ("ZwReadFile return 0x%08lx %d of %s\n", status, __LINE__, __FILE__));
        return EOF;
    }

    fp->size = (int)iosb.Information;
    SmbPrint(SMB_TRACE_DNS, ("ZwReadFile read %d bytes %d of %s\n", fp->size, __LINE__,__FILE__));
    fp->offset = 0;
    if (fp->offset < fp->size) {
        return fp->Buffer[fp->offset++];
    }
    return EOF;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\conncache.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    conncache.c

Abstract:

    This module implement the cache for TCP connection object

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "conncache.tmh"

NTSTATUS
SmbInitTCP(
    PSMB_TCP_INFO TcpInfo
    );

PVOID
SmbQueryTcpHandler(
    IN  PFILE_OBJECT    FileObject
    );

VOID
SmbDestroyTcpContext(
    PSMB_TCP_CONTEXT    TcpCtx
    );

#pragma alloc_text(PAGE, SmbShutdownTCP)
#pragma alloc_text(PAGE, SmbQueryTcpHandler)
#pragma alloc_text(PAGE, SmbSendIoctl)
#pragma alloc_text(PAGE, SmbInitTCP)
#pragma alloc_text(PAGE, SmbInitTCP4)
#pragma alloc_text(PAGE, SmbInitTCP6)
#pragma alloc_text(PAGE, SmbAllocateOutbound)

PVOID
SmbQueryTcpHandler(
    IN  PFILE_OBJECT    FileObject
    )
/*++

Routine Description:

    (Lifted from NBT4)
    This routine iIOCTL queries for fast send entry
    With fast routine, we can directly call TCP and avoid the overhead with IO manager

Arguments:

    IN PFILE_OBJECT FileObject - Supplies the address object's file object.

Return Value:

    NULL    if fail
    otherwise the fast routine of the underlying transport.

--*/

{
    NTSTATUS            status;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpSp;
    IO_STATUS_BLOCK     iosb;
    PDEVICE_OBJECT      DeviceObject;
    PVOID               EntryPoint = NULL;
    IN  ULONG           IOControlCode;

    PAGED_CODE();

    IOControlCode = IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER;

    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    Irp = SmbAllocIrp(DeviceObject->StackSize);
    if (NULL == Irp) {
        return NULL;
    }

    //
    // Build IRP for sync io.
    //
    Irp->MdlAddress = NULL;

    Irp->Flags = (LONG)IRP_SYNCHRONOUS_API;
    Irp->RequestorMode = KernelMode;
    Irp->PendingReturned = FALSE;

    Irp->UserIosb = &iosb;

    Irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    Irp->AssociatedIrp.SystemBuffer = NULL;
    Irp->UserBuffer = NULL;

    Irp->Tail.Overlay.Thread = PsGetCurrentThread();
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    IrpSp = IoGetNextIrpStackLocation( Irp );
    IrpSp->FileObject = FileObject;
    IrpSp->DeviceObject = DeviceObject;

    IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    IrpSp->MinorFunction = 0;
    IrpSp->Parameters.DeviceIoControl.IoControlCode = IOControlCode;
    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = &EntryPoint;

    // Now submit the Irp to know if tcp supports fast path
    status = SubmitSynchTdiRequest(FileObject, Irp);
    Irp->UserIosb = NULL;
    SmbFreeIrp(Irp);

    if (!NT_SUCCESS(status)) {
        EntryPoint = NULL;
        SmbTrace (SMB_TRACE_TCP, ("return %!status!", status));
        SmbPrint (SMB_TRACE_TCP, ("SmbQueryTcpHandler return 0x%08lx\n", status));
    }

    return EntryPoint;
}

NTSTATUS
SmbSendIoctl(
    PFILE_OBJECT    FileObject,
    ULONG           Ioctl,
    PVOID           InBuf,
    ULONG           InBufSize,
    PVOID           OutBuf,
    ULONG           *OutBufSize
    )
{
    PDEVICE_OBJECT  DeviceObject;
    ULONG           OutBufSize2;
    PIRP            Irp;
    IO_STATUS_BLOCK iosb;
    NTSTATUS        status;
    KEVENT          Event;

    PAGED_CODE();

    if (NULL == FileObject) {
        SmbPrint(SMB_TRACE_TCP, ("SmbSendIoctl returns STATUS_INVALID_PARAMETER on NULL device object\n"));
        SmbTrace(SMB_TRACE_TCP, ("returns STATUS_INVALID_PARAMETER on NULL device object"));
        return STATUS_INVALID_PARAMETER;
    }
    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    if (NULL == OutBuf) {
        ASSERT(OutBufSize == NULL);
        OutBufSize2 = 0;
    } else {
        if (NULL == OutBufSize || 0 == *OutBufSize) {
            ASSERT(0);
            SmbPrint(SMB_TRACE_TCP, ("SmbSendIoctl returns STATUS_INVALID_PARAMETER\n"));
            SmbTrace(SMB_TRACE_TCP, ("returns STATUS_INVALID_PARAMETER"));
            return STATUS_INVALID_PARAMETER;
        }
        OutBufSize2 = *OutBufSize;
    }

    KeInitializeEvent(&Event, NotificationEvent, FALSE);
    Irp = IoBuildDeviceIoControlRequest(
            Ioctl,
            DeviceObject,
            InBuf,
            InBufSize,
            OutBuf,
            OutBufSize2,
            FALSE,
            &Event,
            &iosb
            );
    if (NULL == Irp) {
        SmbPrint(SMB_TRACE_TCP, ("SmbSendIoctl returns STATUS_INSUFFICIENT_RESOURCES\n"));
        SmbTrace(SMB_TRACE_TCP, ("returns STATUS_INSUFFICIENT_RESOURCES"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    IoGetNextIrpStackLocation(Irp)->FileObject = FileObject;
    status = IoCallDriver(DeviceObject, Irp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //
    if (!NT_SUCCESS(status)) {
        SmbPrint(SMB_TRACE_TCP, ("SmbSendIoctl: Failed to Submit Tdi Request, status = 0x%08lx\n", status));
        SmbTrace(SMB_TRACE_TCP, ("Failed to Submit Tdi Request, %!status!", status));
        return status;
    }

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject (
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
        if (status != STATUS_WAIT_0) {
            ASSERT(0);
            SmbTrace(SMB_TRACE_TCP, ("KeWaitForSingleObject return %!status!", status));
            return status;
        }

        status = iosb.Status;
        if (NT_SUCCESS(status) && OutBufSize) {
            *OutBufSize = (LONG)(iosb.Information);
        }
    }

    SmbPrint(SMB_TRACE_TCP, ("SmbSendIoctl returns status = 0x%08lx\n", status));
    SmbTrace(SMB_TRACE_TCP, ("returns %!status!", status));
    return (status);
}

NTSTATUS
SmbFakeFastQuery(
    IN   PSMB_IP6_ADDRESS   Address,
    OUT  PULONG             pIndex,
    OUT  PULONG             pMetric
    )
{
    return STATUS_NOT_SUPPORTED;
}

VOID
SmbReadTCPConf(
    IN HANDLE   hKey,
    PSMB_TCP_INFO TcpInfo
    )
{
    TcpInfo->InboundLow  = SmbReadULong (
                    hKey,
                    SMB_REG_INBOUND_LOW,
                    SMB_REG_INBOUND_LOW_DEFAULT,
                    SMB_REG_INBOUND_LOW_MIN
                    );
    TcpInfo->InboundMid  = SmbReadULong (
                    hKey,
                    SMB_REG_INBOUND_MID,
                    TcpInfo->InboundLow * 2,
                    TcpInfo->InboundLow * 2
                    );
    TcpInfo->InboundHigh  = SmbReadULong (
                    hKey,
                    SMB_REG_INBOUND_HIGH,
                    TcpInfo->InboundMid * 2,
                    TcpInfo->InboundMid * 2
                    );
}

NTSTATUS
SmbInitTCP(
    PSMB_TCP_INFO TcpInfo
    )
{
    PVOID           FastQuery;
    ULONG           Size;
    NTSTATUS        status;

    PAGED_CODE();

    //
    // Read registry
    //
    SmbReadTCPConf(SmbCfg.ParametersKey, TcpInfo);

    TcpInfo->InboundNumber = 0;
    InitializeListHead(&TcpInfo->InboundPool);
    InitializeListHead(&TcpInfo->DelayedDestroyList);

    KeInitializeSpinLock(&TcpInfo->Lock);

    TcpInfo->FastSend = SmbQueryTcpHandler(TcpInfo->TCPControlFileObject);
    Size = sizeof(FastQuery);
    status = SmbSendIoctl(
            TcpInfo->IPControlFileObject,
            IOCTL_IP_GET_BESTINTFC_FUNC_ADDR,
            NULL,
            0,
            &FastQuery,
            &Size
            );
    if (STATUS_SUCCESS == status) {
        ULONG   IfIndex, Metric;

        TcpInfo->FastQuery = (PVOID)FastQuery;
        status = ((PIP4FASTQUERY)(FastQuery))(ntohl(INADDR_LOOPBACK), &IfIndex, &Metric);
        if (status == STATUS_SUCCESS) {
            TcpInfo->LoopbackInterfaceIndex = IfIndex;
            SmbPrint(SMB_TRACE_TCP, ("Loopback Interface Index = %d\n", IfIndex));
            SmbTrace(SMB_TRACE_TCP, ("Loopback Interface Index = %d", IfIndex));
        } else {
            SmbPrint(SMB_TRACE_TCP, ("Query loopback Interface Index returns 0x%08lx\n", status));
            SmbTrace(SMB_TRACE_TCP, ("Query loopback Interface Index returns %!status!", status));
            TcpInfo->LoopbackInterfaceIndex = INVALID_INTERFACE_INDEX;
        }
    } else {
        //
        // TCP6 doesn't support fast query
        //
        ASSERT(TcpInfo->IpAddress.sin_family == SMB_AF_INET6);
        TcpInfo->FastQuery = (PVOID)SmbFakeFastQuery;
        TcpInfo->LoopbackInterfaceIndex = INVALID_INTERFACE_INDEX;
    }

    //
    // Initialize inbound
    //
    SmbInitTcpAddress(&TcpInfo->InboundAddressObject);
    status = SmbOpenTcpAddress(
            &TcpInfo->IpAddress,
            TcpInfo->Port,
            &TcpInfo->InboundAddressObject
            );
    BAIL_OUT_ON_ERROR(status);
    status = SmbSetTcpEventHandlers(
            TcpInfo->InboundAddressObject.AddressObject,
            TcpInfo->TdiEventContext
            );
    BAIL_OUT_ON_ERROR(status);

    return status;

cleanup:
    if (TcpInfo->InboundAddressObject.AddressHandle) {
        SmbCloseAddress(&TcpInfo->InboundAddressObject);
    }
    return status;
}

NTSTATUS
SmbInitTCP4(
    PSMB_TCP_INFO   TcpInfo,
    USHORT          Port,
    PVOID           TdiEventContext
    )
{
    NTSTATUS        status;
    UNICODE_STRING  ucName;

    PAGED_CODE();

    if (SmbCfg.Tcp4Available) {
        return STATUS_SUCCESS;
    }

    RtlZeroMemory(TcpInfo, sizeof(TcpInfo[0]));

    RtlInitUnicodeString(&ucName, DD_TCP_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(
            &ucName,
            FILE_READ_DATA| FILE_WRITE_DATA,
            &TcpInfo->TCPControlFileObject,
            &TcpInfo->TCPControlDeviceObject
            );
    BAIL_OUT_ON_ERROR(status);

    RtlInitUnicodeString(&ucName, DD_IP_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(
            &ucName,
            FILE_READ_DATA| FILE_WRITE_DATA,
            &TcpInfo->IPControlFileObject,
            &TcpInfo->IPControlDeviceObject
            );
    BAIL_OUT_ON_ERROR(status);

    TcpInfo->TcpStackSize = TcpInfo->TCPControlDeviceObject->StackSize;

    //
    // Bind to any address
    //
    TcpInfo->IpAddress.sin_family = SMB_AF_INET;
    TcpInfo->IpAddress.ip4.sin4_addr = htonl(INADDR_ANY);
    TcpInfo->Port = htons(Port);

    TcpInfo->TdiEventContext = TdiEventContext;

    status = SmbInitTCP(TcpInfo);
    BAIL_OUT_ON_ERROR(status);

    ASSERT (TcpInfo->LoopbackInterfaceIndex != INVALID_INTERFACE_INDEX);
    status = SmbSetTcpInfo (
            TcpInfo->InboundAddressObject.AddressObject,
            CO_TL_ENTITY,
            INFO_CLASS_PROTOCOL,
            AO_OPTION_IFLIST,
            INFO_TYPE_ADDRESS_OBJECT,
            (ULONG) TRUE
            );
    status = SmbSetTcpInfo (
            TcpInfo->InboundAddressObject.AddressObject,
            CO_TL_ENTITY,
            INFO_CLASS_PROTOCOL,
            AO_OPTION_ADD_IFLIST,
            INFO_TYPE_ADDRESS_OBJECT,
            TcpInfo->LoopbackInterfaceIndex
            );

    if (SmbCfg.SmbDeviceObject->DeviceObject.StackSize < SmbCfg.SmbDeviceObject->Tcp4.TcpStackSize + 1) {
        SmbCfg.SmbDeviceObject->DeviceObject.StackSize = SmbCfg.SmbDeviceObject->Tcp4.TcpStackSize + 1;
    }
    SmbCfg.Tcp4Available = TRUE;
    return STATUS_SUCCESS;

cleanup:
    if (TcpInfo->TCPControlFileObject) {
        ObDereferenceObject(TcpInfo->TCPControlFileObject);
        TcpInfo->TCPControlDeviceObject = NULL;
        TcpInfo->TCPControlFileObject   = NULL;
    }
    if (TcpInfo->IPControlFileObject) {
        ObDereferenceObject(TcpInfo->IPControlFileObject);
        TcpInfo->IPControlDeviceObject = NULL;
        TcpInfo->IPControlFileObject   = NULL;
    }
    SmbPrint(SMB_TRACE_TCP, ("SmbInitTCP4 returns 0x%08lx\n", status));
    SmbTrace(SMB_TRACE_TCP, ("returns %!status!", status));
    return status;
}

NTSTATUS
SmbInitTCP6(
    PSMB_TCP_INFO   TcpInfo,
    USHORT          Port,
    PVOID           TdiEventContext
    )
{
    NTSTATUS    status;
    UNICODE_STRING  ucName;

    PAGED_CODE();

    if (SmbCfg.Tcp6Available) {
        return STATUS_SUCCESS;
    }

    RtlZeroMemory(TcpInfo, sizeof(TcpInfo[0]));

    RtlInitUnicodeString(&ucName, DD_TCPV6_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(
            &ucName,
            FILE_READ_DATA| FILE_WRITE_DATA,
            &TcpInfo->TCPControlFileObject,
            &TcpInfo->TCPControlDeviceObject
            );
    BAIL_OUT_ON_ERROR(status);

    RtlInitUnicodeString(&ucName, DD_IPV6_DEVICE_NAME);
    status = IoGetDeviceObjectPointer(
            &ucName,
            FILE_READ_DATA| FILE_WRITE_DATA,
            &TcpInfo->IPControlFileObject,
            &TcpInfo->IPControlDeviceObject
            );
    BAIL_OUT_ON_ERROR(status);

    TcpInfo->TcpStackSize = TcpInfo->TCPControlDeviceObject->StackSize;

    //
    // Bind to any address
    //
    TcpInfo->IpAddress.sin_family = SMB_AF_INET6;
    ip6addr_getany(&TcpInfo->IpAddress.ip6);
    hton_ip6addr(&TcpInfo->IpAddress.ip6);
    TcpInfo->Port = htons(Port);

    TcpInfo->TdiEventContext = TdiEventContext;

    status = SmbInitTCP(TcpInfo);
    BAIL_OUT_ON_ERROR(status);

    if (SmbCfg.SmbDeviceObject->DeviceObject.StackSize < SmbCfg.SmbDeviceObject->Tcp6.TcpStackSize + 1) {
        SmbCfg.SmbDeviceObject->DeviceObject.StackSize = SmbCfg.SmbDeviceObject->Tcp6.TcpStackSize + 1;
    }
    SmbCfg.Tcp6Available = TRUE;
    return status;

cleanup:
    if (TcpInfo->TCPControlFileObject) {
        ObDereferenceObject(TcpInfo->TCPControlFileObject);
        TcpInfo->TCPControlDeviceObject = NULL;
        TcpInfo->TCPControlFileObject   = NULL;
    }
    if (TcpInfo->IPControlFileObject) {
        ObDereferenceObject(TcpInfo->IPControlFileObject);
        TcpInfo->IPControlDeviceObject = NULL;
        TcpInfo->IPControlFileObject   = NULL;
    }
    SmbPrint(SMB_TRACE_TCP, ("SmbInitTCP6 returns 0x%08lx\n", status));
    SmbTrace(SMB_TRACE_TCP, ("returns %!status!", status));
    return status;
}

VOID
SmbDestroyTcpContext(
    PSMB_TCP_CONTEXT    TcpCtx
    )
{
    NTSTATUS    localstatus;
    BOOL        Attached;

    PAGED_CODE();

    ATTACH_FSP(Attached);
    if (TcpCtx->Connect.ConnectHandle) {
        localstatus = SmbCloseTcpConnection(&TcpCtx->Connect);
        ASSERT(localstatus == STATUS_SUCCESS);
    }
    if (TcpCtx->Address.AddressHandle) {
        localstatus = SmbCloseAddress(&TcpCtx->Address);
        ASSERT(localstatus == STATUS_SUCCESS);
    }
    DETACH_FSP(Attached);
    SmbInitTcpContext(TcpCtx);
    _delete_TcpContext(TcpCtx);
}

VOID
SmbDelayedDestroyTcpContext(
    PSMB_TCP_CONTEXT    TcpCtx
    )
{
    KIRQL           Irql;
    PSMB_TCP_INFO   TcpInfo = NULL;

    if (NULL == TcpCtx) {
        return;
    }

    TcpInfo = TcpCtx->CacheOwner;

    SMB_ACQUIRE_SPINLOCK(TcpInfo, Irql);
    ASSERT(!EntryIsInList(&TcpInfo->InboundPool, &TcpCtx->Linkage));

    InsertTailList(&TcpInfo->DelayedDestroyList, &TcpCtx->Linkage);
    SMB_RELEASE_SPINLOCK(TcpInfo, Irql);

    SmbWakeupWorkerThread(SmbCfg.SmbDeviceObject);
}

NTSTATUS
SmbShutdownTCP(
    PSMB_TCP_INFO TcpInfo
    )
{
    BOOL        Attached;
    NTSTATUS    localstatus;
    PLIST_ENTRY entry;
    PSMB_TCP_CONTEXT    TcpCtx;

    PAGED_CODE();

    ASSERT(SmbCfg.Unloading);

    ATTACH_FSP(Attached);

    //
    // No lock is needed for shutdown
    //

    //
    // Clean up inbound
    //
    while (!IsListEmpty(&TcpInfo->InboundPool)) {

        entry = RemoveHeadList(&TcpInfo->InboundPool);
        TcpInfo->InboundNumber--;
        ASSERT ((TcpInfo->InboundNumber == 0 && IsListEmpty(&TcpInfo->InboundPool)) ||
                (TcpInfo->InboundNumber != 0 && !IsListEmpty(&TcpInfo->InboundPool)));

        TcpCtx = CONTAINING_RECORD(entry, SMB_TCP_CONTEXT, Linkage);
        ASSERT(TcpCtx->Address.AddressHandle == NULL);
        ASSERT(TcpCtx->Connect.ConnectHandle);

        SmbDestroyTcpContext(TcpCtx);
    }
    localstatus = SmbCloseAddress(&TcpInfo->InboundAddressObject);
    ASSERT(localstatus == STATUS_SUCCESS);

    DETACH_FSP(Attached);

    if (TcpInfo->TCPControlFileObject) {
        ObDereferenceObject(TcpInfo->TCPControlFileObject);
        TcpInfo->TCPControlDeviceObject = NULL;
        TcpInfo->TCPControlFileObject   = NULL;
    }
    if (TcpInfo->IPControlFileObject) {
        ObDereferenceObject(TcpInfo->IPControlFileObject);
        TcpInfo->IPControlDeviceObject = NULL;
        TcpInfo->IPControlFileObject   = NULL;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
SmbSynchConnCache(
    PSMB_TCP_INFO   TcpInfo,
    BOOL            Cleanup
    )
/*++

Routine Description:

    This routine bring the number of TCP connection object back to normal

Arguments:


Return Value:


--*/
{
    KIRQL               Irql;
    PLIST_ENTRY         entry;
    PSMB_TCP_CONTEXT    TcpCtx;
    NTSTATUS            status, localstatus;
    BOOL                Attached;
    LONG                Target;

    PAGED_CODE();

    ASSERT(TcpInfo->InboundNumber >= 0);

    ATTACH_FSP(Attached);

    Target = (Cleanup)?0: TcpInfo->InboundMid;
    if (Cleanup || TcpInfo->InboundNumber >= TcpInfo->InboundHigh) {
        //
        // Bring it back to Middle
        //
        while (!SmbCfg.Unloading) {

            SMB_ACQUIRE_SPINLOCK(TcpInfo, Irql);
            if (TcpInfo->InboundNumber <= Target) {
                SMB_RELEASE_SPINLOCK(TcpInfo, Irql);
                break;
            }
            ASSERT (!IsListEmpty(&TcpInfo->InboundPool));
            entry = RemoveHeadList(&TcpInfo->InboundPool);
            TcpInfo->InboundNumber--;
            ASSERT ((TcpInfo->InboundNumber == 0 && IsListEmpty(&TcpInfo->InboundPool)) ||
                    (TcpInfo->InboundNumber != 0 && !IsListEmpty(&TcpInfo->InboundPool)));
            SMB_RELEASE_SPINLOCK(TcpInfo, Irql);

            TcpCtx = CONTAINING_RECORD(entry, SMB_TCP_CONTEXT, Linkage);
            ASSERT(TcpCtx->Address.AddressHandle == NULL);
            ASSERT(TcpCtx->Connect.ConnectHandle);

            SmbDestroyTcpContext(TcpCtx);
        }
    }

    if (!Cleanup && TcpInfo->InboundNumber <= TcpInfo->InboundLow) {
        //
        // Bring it back to Middle
        //
        while(!SmbCfg.Unloading && TcpInfo->InboundNumber < TcpInfo->InboundMid) {
            TcpCtx = _new_TcpContext();
            if (NULL == TcpCtx) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto cleanup;
            }
            SmbInitTcpContext(TcpCtx);

            status = SmbOpenTcpConnection(
                    &TcpInfo->InboundAddressObject,
                    &TcpCtx->Connect,
                    &TcpCtx->Connect
                    );
            if (status != STATUS_SUCCESS) {
                _delete_TcpContext(TcpCtx);
                goto cleanup;
            }

            SMB_ACQUIRE_SPINLOCK(TcpInfo, Irql);
            InsertTailList(&TcpInfo->InboundPool, &TcpCtx->Linkage);
            TcpInfo->InboundNumber++;
            SMB_RELEASE_SPINLOCK(TcpInfo, Irql);
        }
    }

    status = STATUS_SUCCESS;

cleanup:
    while(1) {
        SMB_ACQUIRE_SPINLOCK(TcpInfo, Irql);
        if (IsListEmpty(&TcpInfo->DelayedDestroyList)) {
            SMB_RELEASE_SPINLOCK(TcpInfo, Irql);
            break;
        }
        entry = RemoveHeadList(&TcpInfo->DelayedDestroyList);
        SMB_RELEASE_SPINLOCK(TcpInfo, Irql);

        TcpCtx = CONTAINING_RECORD(entry, SMB_TCP_CONTEXT, Linkage);
        SmbDestroyTcpContext(TcpCtx);
    }

    DETACH_FSP(Attached);
    return status;
}

PSMB_TCP_CONTEXT
SmbAllocateOutbound(
    PSMB_TCP_INFO TcpInfo
    )
{
    PSMB_TCP_CONTEXT TcpCtx = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    NTSTATUS localstatus = STATUS_SUCCESS;

    PAGED_CODE();

    TcpCtx = _new_TcpContext();
    if (NULL == TcpCtx) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }
    SmbInitTcpContext(TcpCtx);

    status = SmbOpenTcpAddress(
            &TcpInfo->IpAddress,
            0,
            &TcpCtx->Address
            );
    if (STATUS_SUCCESS != status) {
        goto cleanup;
    }

    status = SmbSetTcpEventHandlers(
            TcpCtx->Address.AddressObject,
            TcpInfo->TdiEventContext
            );
    if (STATUS_SUCCESS != status) {
        localstatus = SmbCloseAddress(&TcpCtx->Address);
        ASSERT(localstatus == STATUS_SUCCESS);
        goto cleanup;
    }

    status = SmbOpenTcpConnection(
            &TcpCtx->Address,
            &TcpCtx->Connect,
            &TcpCtx->Connect
            );
    if (STATUS_SUCCESS != status) {
        localstatus = SmbCloseAddress(&TcpCtx->Address);
        ASSERT(localstatus == STATUS_SUCCESS);
        goto cleanup;
    }
    TcpCtx->CacheOwner = TcpInfo;

cleanup:

    if (STATUS_SUCCESS != status) {
        if (TcpCtx) {
            _delete_TcpContext(TcpCtx);
            TcpCtx = NULL;
        }
    }

    return TcpCtx;
}

VOID
SmbFreeOutbound(
    PSMB_TCP_CONTEXT    TcpCtx
    )
{
    SmbDelayedDestroyTcpContext(TcpCtx);
}

PSMB_TCP_CONTEXT
SmbAllocateInbound(
    PSMB_TCP_INFO TcpInfo
    )
{
    KIRQL       Irql;
    BOOL        WakeupWorker = TRUE;
    PLIST_ENTRY entry = NULL;
    PSMB_TCP_CONTEXT    TcpCtx = NULL;

    ASSERT(TcpInfo->InboundNumber >= 0);

    SMB_ACQUIRE_SPINLOCK(TcpInfo, Irql);
    if (TcpInfo->InboundNumber > 0) {
        entry = RemoveHeadList(&TcpInfo->InboundPool);
        TcpInfo->InboundNumber--;
        ASSERT ((TcpInfo->InboundNumber == 0 && IsListEmpty(&TcpInfo->InboundPool)) ||
                (TcpInfo->InboundNumber != 0 && !IsListEmpty(&TcpInfo->InboundPool)));
    }
    WakeupWorker = (TcpInfo->InboundNumber <= TcpInfo->InboundLow);
    SMB_RELEASE_SPINLOCK(TcpInfo, Irql);

    if (WakeupWorker) {
        SmbWakeupWorkerThread(SmbCfg.SmbDeviceObject);
    }
    if (entry == NULL) {
        return NULL;
    }

    TcpCtx = CONTAINING_RECORD(entry, SMB_TCP_CONTEXT, Linkage);
    TcpCtx->CacheOwner = TcpInfo;

    ASSERT(!ValidTcpAddress(&TcpCtx->Address));
    ASSERT(ValidTcpConnect(&TcpCtx->Connect));
    return TcpCtx;
}

VOID
SmbFreeInbound(
    PSMB_TCP_CONTEXT    TcpCtx
    )
{
    KIRQL           Irql;
    PSMB_TCP_INFO   TcpInfo;
    BOOL            WakeupWorker;

    if (NULL == TcpCtx) {
        return;
    }

    ASSERT(!ValidTcpAddress(&TcpCtx->Address));
    ASSERT(ValidTcpConnect(&TcpCtx->Connect));

    TcpInfo = TcpCtx->CacheOwner;
    ASSERT(TcpInfo->InboundNumber >= 0);

    SMB_ACQUIRE_SPINLOCK(TcpInfo, Irql);
    ASSERT(!EntryIsInList(&TcpInfo->InboundPool, &TcpCtx->Linkage));

    InsertTailList(&TcpInfo->InboundPool, &TcpCtx->Linkage);
    TcpInfo->InboundNumber++;
    WakeupWorker = (TcpInfo->InboundNumber >= TcpInfo->InboundHigh);
    SMB_RELEASE_SPINLOCK(TcpInfo, Irql);

    if (WakeupWorker) {
        SmbWakeupWorkerThread(SmbCfg.SmbDeviceObject);
    }
}

VOID
SmbFreeTcpContext(
    PSMB_TCP_CONTEXT    TcpCtx
    )
{
    if (NULL == TcpCtx) {
        return;
    }

    if (TcpCtx->Address.AddressHandle) {
        SmbFreeOutbound(TcpCtx);
    } else {
        SmbFreeInbound(TcpCtx);
    }
}

VOID
PoolWorker(
    IN PSMB_DEVICE      DeviceObject,
    IN PIO_WORKITEM     WorkItem
    )
{
    NTSTATUS    status;

    PAGED_CODE();

    IoFreeWorkItem(WorkItem);

    //
    // Allow to fire anoter thread
    //
    InterlockedExchange(&DeviceObject->ConnectionPoolWorkerQueued, FALSE);

    if (SmbCfg.Unloading) {
        return;
    }

    if (SmbCfg.Tcp6Available) {
        status = SmbSynchConnCache(&DeviceObject->Tcp6,
                DeviceObject->DeviceRegistrationHandle == NULL);
    }
    if (SmbCfg.Tcp4Available) {
        status = SmbSynchConnCache(&DeviceObject->Tcp4,
                DeviceObject->DeviceRegistrationHandle == NULL);
    }
}

NTSTATUS
SmbWakeupWorkerThread(
    IN PSMB_DEVICE      DeviceObject
    )
{
    PIO_WORKITEM    WorkItem;
    LONG            Queued;

    Queued = InterlockedExchange(&DeviceObject->ConnectionPoolWorkerQueued, TRUE);

    if (Queued == FALSE) {

        WorkItem = IoAllocateWorkItem(&DeviceObject->DeviceObject);
        if (NULL == WorkItem) {
            InterlockedExchange(&DeviceObject->ConnectionPoolWorkerQueued, FALSE);
            //
            // This is not a critical error.
            //
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        IoQueueWorkItem(
                WorkItem,
                (PIO_WORKITEM_ROUTINE)PoolWorker,
                DelayedWorkQueue,
                WorkItem
                );
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\lib\smbsvc.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    smbsvc.c

Abstract:

    This the user-mode proxy for the kernel mode DNS resolver.

    features:
        1. Multi-threaded
            NBT4 use a single-threaded design. The DNS name resolution is a performance blocker.
            When a connection request is being served by LmhSvc, all the other requests requiring
            DNS resolution will be blocked.
        2. IPv6 and IPv4 compatiable
        3. can be run either as a service or standalone executable (for debug purpose)
           When started as service, debug spew is sent to debugger.
           When started as a standalong executable, the debug spew is sent to either
           the console or debugger. smbhelper.c contain the _main for the standardalone
           executable.

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"

#include "smbtrace.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <tdi.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#include <mstcpip.h>
#include <ipexport.h>
#include <winsock2.h>
#include <icmpapi.h>
#include "svclib.h"
#include "ping6.h"

#include "smbsvc.tmh"

#if DBG
//
// In order to disable the compiler optimization,
// don't use static on SmbDebug.
// (When static is used, compiler may find that
// SmbDebug isn't changed in this module, it will
// remove the "if (SmbDebug)" )
//
static int (*SmbDbgPrint)(char *fmt,...) = NULL;
#   define KDPRINT(y)       \
    do {                    \
        int (*MyDbgPrint)(char *fmt,...) = SmbDbgPrint;     \
        if (NULL != MyDbgPrint) {     \
            MyDbgPrint y;  \
            MyDbgPrint(": %d of %s\n", __LINE__, __FILE__);  \
        }                   \
    } while(0)

#else
#   define KDPRINT(y)
#endif

static HANDLE OpenSmb(LPWSTR Name);

#define DEFAULT_RECV_SIZE          (0x2000)         // Icmp recv buffer size
#define DEFAULT_TTL                 32
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             2000L           // default timeout set to 2 secs.

static HANDLE  hTerminateEvent;

static BYTE    SendBuffer[] = "SMBEcho";
static IP_OPTION_INFORMATION SendOpts = {
    DEFAULT_TTL, DEFAULT_TOS, 0, 0, NULL
};

#ifdef __USE_GETADDRINFO__
//
// Please use getaddrinfo whenever it has a UNICODE version
//
VOID
ReturnAllIPAddress(
    PSMB_DNS_BUFFER dns,
    struct addrinfo *res
    )
{
    SOCKET_ADDRESS     SelectedAddr;
    struct addrinfo *p = res;
    BOOL                bFoundIPv4 = FALSE;

    for (p = res; p; p = p->ai_next) {

        if (p->ai_family == PF_INET6) {

            //
            // Save the last slot for IPv4 address
            //
            if (!bFoundIPv4 && dns->IpAddrsNum == SMB_MAX_IPADDRS_PER_HOST - 1) {
                continue;
            }

            //
            // Skip all the multicast address
            //
            if (IN6_IS_ADDR_MULTICAST(&((struct sockaddr_in6*)p->ai_addr)->sin6_addr)) {
                continue;
            }

            //
            // Only allow supported addresses in
            //
            if (!(dns->RequestType & SMB_DNS_AAAA_GLOBAL) &&
                   !SMB_IS_ADDRESS_ALLOWED(((struct sockaddr_in6*)p->ai_addr)->sin6_addr.u.Byte)) {
                continue;
            }

            SelectedAddr.lpSockdddr = p->ai_addr;
            SelectedAddr.iSockaddrLength = sizeof (sockaddr_in6);

        } else if (p->ai_family == PF_INET) {

            SelectedAddr.lpSockdddr = p->ai_addr;
            SelectedAddr.iSockaddrLength = sizeof (sockaddr_in);
            bFoundIPv4 = TRUE;

        } else {
            ASSERT (0);
            continue;
        }

        SmbReturnIPAddress (dns, &SelectedAddr);
    }

    return p;
}

VOID
SmbGetHostByName(
    PSMB_DNS_BUFFER dns
    )
{
    struct  addrinfo    hints = {0};
    struct  addrinfo    *res;
    CHAR    nodename[DNS_NAME_BUFFER_LENGTH];

    KDPRINT(("Resolving %ws", dns->Name));

    dns->Resolved = FALSE;
    dns->IpAddrsNum = 0;

    if (WideCharToMultiByte(
            CP_THREAD_ACP,
            WC_NO_BEST_FIT_CHARS,
            dns->Name,
            dns->NameLen,
            nodename,
            DNS_NAME_BUFFER_LENGTH,
            NULL,
            NULL
            ) == 0) {
        KDPRINT(("WideCharToMultiByte return %d", GetLastError()));
        return;
    }
    hints.ai_family = 0;
    hints.ai_flags  = AI_CANONNAME;
    hints.ai_socktype = SOCK_STREAM;

    if (getaddrinfo(nodename, NULL, &hints, &res)) {
        KDPRINT(("getaddrinfo return %d", GetLastError()));
        return;
    }
    if (NULL == res) {
        //
        // This should not happen since getaddrinfo returns success above
        //
        ASSERT(0);
        return;
    }

    dns->NameLen = MultiByteToWideChar(
                CP_THREAD_ACP,
                MB_ERR_INVALID_CHARS,
                res->ai_canonname,
                -1,
                dns->Name,
                DNS_NAME_BUFFER_LENGTH
                );
    if (0 == dns->NameLen) {
        KDPRINT(("MultiByteToWideChar return %d", GetLastError()));
    }
    dns->Resolved = TRUE;

    ReturnAllIPAddress(dns, res);
    freeaddrinfo(res);
}
#else

VOID
SmbCopyDnsName(
    IN OUT PSMB_DNS_BUFFER dns,
    IN WCHAR               *name
    )
/*++

Routine Description:

    This routine update the Name and NameLen field of dns.
    If the input name is too long, nothing will happen

Arguments:

Return Value:

--*/
{
    int len;

    if (NULL == name) {
        return;
    }

    len = wcslen(name) + 1;
    if ( len > DNS_NAME_BUFFER_LENGTH ) {
        return;
    }

    memcpy (dns->Name, name, len * sizeof(WCHAR));
    dns->NameLen = len - 1;
    KDPRINT(("DNS name is updated with %ws", dns->Name));

    SmbTrace(SMB_TRACE_DNS, ("\tFQDN %ws", dns->Name));
}

VOID
SmbReturnIPAddress (
    IN OUT PSMB_DNS_BUFFER dns,
    IN PSOCKET_ADDRESS     pSelectedAddr
    )
{
    struct sockaddr_in  *pv4addr = NULL;
    struct sockaddr_in6 *pv6addr = NULL;
    PSMB_IP_ADDRESS     pSmbIpAddress = NULL;
#ifdef DBG
    CHAR                name_buffer[48];
#endif

    //
    // Update the return buffer (returned to the kernel mode driver)
    //
    dns->Resolved = TRUE;
    if (dns->IpAddrsNum >= SMB_MAX_IPADDRS_PER_HOST) {
        return;
    }
    pSmbIpAddress = &dns->IpAddrsList[dns->IpAddrsNum];
    dns->IpAddrsNum++;

    if (pSelectedAddr->lpSockaddr->sa_family == AF_INET) {

        pSmbIpAddress->sin_family = SMB_AF_INET;
        pv4addr = (struct sockaddr_in*)(pSelectedAddr->lpSockaddr);
        RtlCopyMemory(&pSmbIpAddress->ip4.sin4_addr, &pv4addr->sin_addr, sizeof(pv4addr->sin_addr));

        SmbTrace(SMB_TRACE_DNS, ("\treturn %!ipaddr!", pv4addr->sin_addr.S_un.S_addr));
    } else {

        pSmbIpAddress->sin_family = SMB_AF_INET6;
        pv6addr = (struct sockaddr_in6*)(pSelectedAddr->lpSockaddr);
        RtlCopyMemory(pSmbIpAddress->ip6.sin6_addr, &pv6addr->sin6_addr, sizeof(pv6addr->sin6_addr));
        pSmbIpAddress->ip6.sin6_scope_id = pv6addr->sin6_scope_id;

        SmbTrace(SMB_TRACE_DNS, ("\treturn %!IPV6ADDR!", &pv6addr->sin6_addr));
    }
}

int
SortIPAddrs(
    IN      int                     af,
    OUT     LPVOID                  Addrs,
    IN      u_int                   NumAddrs,
    IN      u_int                   width,
    OUT     SOCKET_ADDRESS_LIST **  pAddrlist
    )
/*++

Routine Description:

    Lifted from %SDXROOT%\net\sockets\winsock2\ws2_32\src\addrinfo.cpp

    Sort addresses of the same family.
    A wrapper around a sort Ioctl.
    If the Ioctl isn't implemented, the sort is a no-op.

Arguments:

Return Value:

--*/
{
    DWORD           status = NO_ERROR;
    DWORD           bytesReturned = 0;
    DWORD           size = 0;
    DWORD           i = 0;
    PSOCKADDR       paddr = NULL;
    UINT            countAddrs = NumAddrs;
    LPSOCKET_ADDRESS_LIST   paddrlist = NULL;

    //
    //  build SOCKET_ADDRESS_LIST
    //      - allocate
    //      - fill in with pointers into SOCKADDR array
    //

    size = FIELD_OFFSET( SOCKET_ADDRESS_LIST, Address[countAddrs] );
    paddrlist = (SOCKET_ADDRESS_LIST *)LocalAlloc(LMEM_FIXED, size);
    if ( !paddrlist ) {
        status = WSA_NOT_ENOUGH_MEMORY;
        goto Done;
    }

    for ( i=0; i<countAddrs; i++ ) {
        paddr = (PSOCKADDR) (((PBYTE)Addrs) + i * width);
        paddrlist->Address[i].lpSockaddr      = paddr;
        paddrlist->Address[i].iSockaddrLength = width;
    }
    paddrlist->iAddressCount = countAddrs;

    //
    //  sort if multiple addresses and able to open socket
    //      - open socket of desired type for sort
    //      - sort, if sort fails just return unsorted
    //

    if ( countAddrs > 1 ) {
        SOCKET    s = INVALID_SOCKET;

        s = socket( af, SOCK_DGRAM, 0 );
        if ( s == INVALID_SOCKET ) {
            goto Done;
        }

        status = WSAIoctl(
                    s,
                    SIO_ADDRESS_LIST_SORT,
                    (LPVOID)paddrlist,
                    size,
                    (LPVOID)paddrlist,
                    size,
                    & bytesReturned,
                    NULL,
                    NULL );

        closesocket(s);
        status = NO_ERROR;
    }

Done:
    if ( status == NO_ERROR ) {
        *pAddrlist = paddrlist;
    }

    return status;
}


typedef enum {
    SMB_DNS_UNRESOLVED = 0,
    SMB_DNS_BUFFER_TOO_SMALL,
    SMB_DNS_RESOLVED,
    SMB_DNS_REACHABLE
} SMB_DNS_STATUS;

typedef struct {
    union {
        SOCKADDR_IN     *pV4Addrs;
        SOCKADDR_IN6    *pV6Addrs;
        PVOID           pAddrs;
    };
    u_int           NumSlots;
    u_int           NumAddrs;
} SMB_ADDR_LIST, *PSMB_ADDR_LIST;

int
SaveV6Address(
    IN      struct in6_addr *   NewAddr,
    IN OUT PSMB_ADDR_LIST       pSmbAddrList
    )
/*++

Routine Description:

    Save an address into our array of addresses,
    possibly growing the array.

Arguments:

Return Value:

    Returns FALSE on failure. (Couldn't grow array.)

--*/
{
    SOCKADDR_IN6 *addr6 = NULL;
    DWORD        dwSize = 0;
    DWORD        dwNewSlots = 0;
    SOCKADDR_IN6 *NewAddrs = NULL;
    USHORT       ServicePort = 0;


    //
    //  add another sockaddr to array if not enough space
    //

    if (pSmbAddrList->NumSlots == pSmbAddrList->NumAddrs) {

        if (pSmbAddrList->pV6Addrs) {
            ASSERT (pSmbAddrList->NumSlots);
            dwNewSlots = 2 * pSmbAddrList->NumSlots;
            dwSize = dwNewSlots * sizeof (SOCKADDR_IN6);
            NewAddrs = (SOCKADDR_IN6 *) LocalReAlloc(pSmbAddrList->pV6Addrs, dwSize, LMEM_ZEROINIT);
        } else {
            dwNewSlots = SMB_MAX_IPADDRS_PER_HOST;
            dwSize = dwNewSlots * sizeof (SOCKADDR_IN6);
            NewAddrs = (SOCKADDR_IN6 *) LocalAlloc(LPTR, dwSize);
        }

        if (NewAddrs == NULL)
            return FALSE;

        pSmbAddrList->pV6Addrs   = NewAddrs;
        pSmbAddrList->NumSlots = dwNewSlots;
    }

    //  fill in IP6 sockaddr

    addr6 = pSmbAddrList->pV6Addrs + (pSmbAddrList->NumAddrs++);
    addr6->sin6_family = AF_INET6;
    addr6->sin6_port = ServicePort;

    memcpy(&addr6->sin6_addr, NewAddr, sizeof(*NewAddr));

    return TRUE;
}


int
SaveV4Address(
    IN      struct in_addr *    NewAddr,
    IN OUT  PSMB_ADDR_LIST      pSmbAddrList
    )
/*++

Routine Description:

    Save an address into our array of addresses,
    possibly growing the array.

Arguments:

Return Value:

    Returns FALSE on failure. (Couldn't grow array.)

--*/
{
    SOCKADDR_IN  *addr = NULL;
    DWORD        dwSize = 0;
    DWORD        dwNewSlots = 0;
    SOCKADDR_IN  *NewAddrs = NULL;
    USHORT       ServicePort = 0;


    //
    //  add another sockaddr to array if not enough space
    //

    if (pSmbAddrList->NumSlots == pSmbAddrList->NumAddrs) {
        if (pSmbAddrList->pV4Addrs) {
            ASSERT (pSmbAddrList->NumSlots);
            dwNewSlots = 2 * pSmbAddrList->NumSlots;
            dwSize = dwNewSlots * sizeof (SOCKADDR_IN);
            NewAddrs = (SOCKADDR_IN *) LocalReAlloc(pSmbAddrList->pV4Addrs, dwSize, LMEM_ZEROINIT);
        } else {
            dwNewSlots = SMB_MAX_IPADDRS_PER_HOST;
            dwSize = dwNewSlots * sizeof (SOCKADDR_IN);
            NewAddrs = (SOCKADDR_IN *) LocalAlloc(LPTR, dwSize);
        }
        if (NewAddrs == NULL)
            return FALSE;

        pSmbAddrList->pV4Addrs   = NewAddrs;
        pSmbAddrList->NumSlots = dwNewSlots;
    }

    //  fill in IP sockaddr

    addr = pSmbAddrList->pV4Addrs + (pSmbAddrList->NumAddrs++);
    addr->sin_family = AF_INET;
    addr->sin_port = ServicePort;

    memcpy(&addr->sin_addr, NewAddr, sizeof(*NewAddr));

    return TRUE;
}


VOID
CleanupAddrList (
    IN OUT PSMB_ADDR_LIST      pSmbAddrList
    )
{
    if (pSmbAddrList->pAddrs) {
        LocalFree (pSmbAddrList->pAddrs);
        pSmbAddrList->pAddrs = NULL;
    }

    RtlZeroMemory (pSmbAddrList, sizeof(SMB_ADDR_LIST));
}

typedef struct {
    SMB_ADDR_LIST           V4AddrList;
    SMB_ADDR_LIST           V6AddrList;

    LPSOCKET_ADDRESS_LIST   pSortedV4AddrList;
    LPSOCKET_ADDRESS_LIST   pSortedV6AddrList;
} SMB_DNS_RESULT, *PSMB_DNS_RESULT;

VOID
CleanupDnsResult (
    IN OUT PSMB_DNS_RESULT  pSmbDnsResult
    )
{
    CleanupAddrList (&pSmbDnsResult->V4AddrList);
    CleanupAddrList (&pSmbDnsResult->V6AddrList);

    if (pSmbDnsResult->pSortedV4AddrList) {
        LocalFree (pSmbDnsResult->pSortedV4AddrList);
        pSmbDnsResult->pSortedV4AddrList = NULL;
    }
    if (pSmbDnsResult->pSortedV6AddrList) {
        LocalFree (pSmbDnsResult->pSortedV6AddrList);
        pSmbDnsResult->pSortedV6AddrList = NULL;
    }
}

#define SMB_INIT_WSA_SIZE   (sizeof(WSAQUERYSETW) + 2048)

//
// use WSALookupXXXX APIs since we don't have a UNICODE version of getaddrinfo
//
DWORD
LookupDns(
    IN WCHAR * pwchName,
    IN GUID * pgProvider,
    IN OUT PSMB_DNS_BUFFER dns,
    IN OUT PSMB_DNS_RESULT pSmbDnsResult
    )
/*++

Routine Description:

Arguments:

Return Value:

    WINERROR

--*/
{
    PCSADDR_INFO        pcsadr = NULL;
    struct sockaddr_in  *pv4addr = NULL;
    struct sockaddr_in6 *pv6addr = NULL;
    DWORD               dwError = ERROR_SUCCESS;
    HANDLE              hRnR = NULL;
    DWORD               i = 0;
    PWSAQUERYSETW pwsaq = NULL;
    DWORD dwSize = 0;
    DWORD dwCurrentSize = 0;
#ifdef DBG
    CHAR                name_buffer[48];
#endif

    //
    // Allocate the memory and setup the request
    //

    dwSize = dwCurrentSize = SMB_INIT_WSA_SIZE;
    pwsaq = (PWSAQUERYSETW)LocalAlloc(LPTR, dwSize);
    if (NULL == pwsaq) {
        SmbTrace(SMB_TRACE_DNS, ("\tOut of memory"));
        goto cleanup;
    }

    pwsaq->dwSize = sizeof(*pwsaq);
    pwsaq->lpszServiceInstanceName = pwchName;
    pwsaq->lpServiceClassId = pgProvider;
    pwsaq->dwNameSpace = NS_DNS;

    //
    // Start the lookup
    //
    dwError = WSALookupServiceBeginW (pwsaq, LUP_RETURN_NAME| LUP_RETURN_ADDR, &hRnR);
    if (dwError != NO_ERROR) {
        dwError = GetLastError();
        SmbTrace(SMB_TRACE_DNS, ("Error: %!winerr!", dwError));
        goto cleanup;
    }

    while(1) {

        dwSize = dwCurrentSize;
        dwError = WSALookupServiceNextW (hRnR, 0, &dwSize, pwsaq);
        if (dwError != NO_ERROR) {
            dwError = GetLastError();
            SmbTrace(SMB_TRACE_DNS, ("Error: %!winerr!", dwError));

            if (dwError != WSAEFAULT) {
                break;
            }

            if (dwSize <= SMB_INIT_WSA_SIZE) {
                ASSERT(0);
                SmbTrace(SMB_TRACE_DNS, ("\tInvalid buffer size %d returned by DNS", dwSize));
                break;
            }

            //
            // Realloc the buffer using the suggested size
            //
            LocalFree(pwsaq);
            pwsaq = NULL;
            pwsaq = (PWSAQUERYSETW)LocalAlloc(LPTR, dwSize);
            if (NULL == pwsaq) {
                SmbTrace(SMB_TRACE_DNS, ("\tOut of memory"));
                goto cleanup;
            }
            dwCurrentSize = dwSize;
            continue;
        }

        //
        // Pick up the canonical name
        //
        SmbCopyDnsName(dns, pwsaq->lpszServiceInstanceName);

        for (i = 0, pcsadr = pwsaq->lpcsaBuffer; i < pwsaq->dwNumberOfCsAddrs; i++, pcsadr++) {

            switch (pcsadr->RemoteAddr.lpSockaddr->sa_family) {
            case AF_INET:
                if (pcsadr->RemoteAddr.iSockaddrLength >= sizeof(struct sockaddr_in)) {
                    pv4addr = (struct sockaddr_in*)(pcsadr->RemoteAddr.lpSockaddr);
                    SaveV4Address (&pv4addr->sin_addr, &pSmbDnsResult->V4AddrList);
                    SmbTrace(SMB_TRACE_DNS, ("\t%!ipaddr!", pv4addr->sin_addr.S_un.S_addr));
                }
                break;

            case AF_INET6:
                if (pcsadr->RemoteAddr.iSockaddrLength >= sizeof(struct sockaddr_in6)) {
                    pv6addr = (struct sockaddr_in6*)(pcsadr->RemoteAddr.lpSockaddr);

                    //
                    // Skip all the multicast address
                    //
                    if (IN6_IS_ADDR_MULTICAST(&pv6addr->sin6_addr)) {
                        SmbTrace(SMB_TRACE_DNS, ("\tSkip %!IPV6ADDR!", &pv6addr->sin6_addr));
                        continue;
                    }

                    if (!(dns->RequestType & SMB_DNS_AAAA_GLOBAL) &&
                            !SMB_IS_ADDRESS_ALLOWED(pv6addr->sin6_addr.u.Byte)) {
                        SmbTrace(SMB_TRACE_DNS, ("\tSkip %!IPV6ADDR!", &pv6addr->sin6_addr));
                        continue;
                    }

                    SaveV6Address (&pv6addr->sin6_addr, &pSmbDnsResult->V6AddrList);
                    SmbTrace(SMB_TRACE_DNS, ("\t%!IPV6ADDR!", &pv6addr->sin6_addr));
                }
                break;

            default:
                KDPRINT(("Skip non-IP address"));
                break;
            }

        }

    }

    WSALookupServiceEnd(hRnR);
    hRnR = NULL;

cleanup:

    if (NULL != hRnR) {
        WSALookupServiceEnd(hRnR);
        hRnR = NULL;
    }

    LocalFree(pwsaq);       // LocalFree can handle NULL case
    pwsaq = NULL;

    return dwError;
}

static GUID guidHostnameV6 = SVCID_DNS_TYPE_AAAA;
static GUID guidHostnameV4 = SVCID_DNS_TYPE_A;

VOID
SmbGetHostByName(
    PSMB_DNS_BUFFER dns
    )
/*++

Routine Description:

    Resolve the name through DNS.

Arguments:

Return Value:

--*/
{
    DWORD dwError = 0;
    int i;
    SMB_DNS_RESULT  SmbDnsResult = { 0 };

    dns->Resolved = FALSE;
    dns->IpAddrsNum = 0;

    if (dns->NameLen > DNS_MAX_NAME_LENGTH) {

        SmbTrace(SMB_TRACE_DNS, ("Error: name too long %d", dns->NameLen));
        KDPRINT(("Receive invalid request"));
        goto cleanup;
    }
    dns->Name[dns->NameLen] = L'\0';

    SmbTrace(SMB_TRACE_DNS, ("Resolving %ws", dns->Name));

    if (dns->RequestType & SMB_DNS_AAAA_GLOBAL) {
        dns->RequestType |= SMB_DNS_AAAA;
        SmbTrace(SMB_TRACE_DNS, ("\tGlobal IPv6 Address is on"));
    }

    if (dns->RequestType & SMB_DNS_AAAA) {
        KDPRINT(("Looking for AAAA record for %ws", dns->Name));
        SmbTrace(SMB_TRACE_DNS, ("\tLookup AAAA record"));

        dwError = LookupDns(dns->Name, &guidHostnameV6, dns, &SmbDnsResult);

        SmbTrace(SMB_TRACE_DNS, ("\tFound %d IPv6 address", SmbDnsResult.V6AddrList.NumAddrs));

        if (SmbDnsResult.V6AddrList.NumAddrs > 0) {
            SortIPAddrs(
                AF_INET6,
                (LPVOID)SmbDnsResult.V6AddrList.pAddrs,
                SmbDnsResult.V6AddrList.NumAddrs,
                sizeof(SOCKADDR_IN6),
                &SmbDnsResult.pSortedV6AddrList
                );
        }

    }

    if (dns->RequestType & SMB_DNS_A) {
        KDPRINT(("Looking for A record for %ws", dns->Name));
        SmbTrace(SMB_TRACE_DNS, ("\tLookup A record"));

        dwError = LookupDns(dns->Name, &guidHostnameV4, dns, &SmbDnsResult);

        SmbTrace(SMB_TRACE_DNS, ("\tFound %d IPv4 address", SmbDnsResult.V4AddrList.NumAddrs));

        if (SmbDnsResult.V4AddrList.NumAddrs > 0) {
            SortIPAddrs(
                AF_INET,
                (LPVOID)SmbDnsResult.V4AddrList.pAddrs,
                SmbDnsResult.V4AddrList.NumAddrs,
                sizeof(SOCKADDR_IN),
                &SmbDnsResult.pSortedV4AddrList
                );
        }

    }

cleanup:

    if (SmbDnsResult.pSortedV6AddrList) {
        for (i = 0; i < SmbDnsResult.pSortedV6AddrList->iAddressCount; i++) {
            SmbReturnIPAddress (dns, &SmbDnsResult.pSortedV6AddrList->Address[i]);
        }
    }

    if (SmbDnsResult.pSortedV4AddrList) {
        //
        // Make sure we have an IPv4 address to failover
        //
        if (dns->IpAddrsNum >= SMB_MAX_IPADDRS_PER_HOST &&
            SmbDnsResult.pSortedV4AddrList->iAddressCount > 0) {
            dns->IpAddrsNum = SMB_MAX_IPADDRS_PER_HOST / 2;
            SmbTrace(SMB_TRACE_DNS, ("\tTruncate IPv6 address to give room to IPv4"));
        }

        for (i = 0; i < SmbDnsResult.pSortedV4AddrList->iAddressCount; i++) {
            SmbReturnIPAddress (dns, &SmbDnsResult.pSortedV4AddrList->Address[i]);
        }
    }

    SmbTrace(SMB_TRACE_DNS, ("\tNum of IP address returned: %d", dns->IpAddrsNum));

    CleanupDnsResult (&SmbDnsResult);
}
#endif      // __USE_GETADDRINFO__



DWORD
SmbGetHostThread(
    LPVOID  ctx
    )
{
    NTSTATUS    status;
    DWORD   Error;
    HANDLE  WaitObject[2];
    SMB_DNS_BUFFER  Dns;
    IO_STATUS_BLOCK iosb;

#define TERMINATE_EVENT     (WAIT_OBJECT_0)
#define IO_EVENT            (WAIT_OBJECT_0+1)

    SmbTrace(SMB_TRACE_DNS, ("Thread start: detecting NetbiosSmb driver"));
    WaitObject[TERMINATE_EVENT] = hTerminateEvent;

    while(1) {
        DWORD dwLocalError = ERROR_SUCCESS;

        WaitObject[IO_EVENT] = OpenSmb(DD_SMB6_EXPORT_NAME);
        if (WaitObject[IO_EVENT] != NULL) {
            break;
        }

        Error = GetLastError();

        //
        // Wait for 60 seconds and try again
        //
        dwLocalError = WaitForSingleObject(hTerminateEvent, 60000);
        if (dwLocalError != WAIT_TIMEOUT) {
            return Error;
        }
    }

    SmbTrace(SMB_TRACE_DNS, ("Thread start: NetbiosSmb driver detected"));

    while (1) {
        status = NtDeviceIoControlFile(
                      WaitObject[IO_EVENT],    // Handle
                      NULL,                    // Wait Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      IOCTL_SMB_DNS,           // IoControlCode
                      &Dns,                    // InputBuffer
                      sizeof(Dns),             // InputBufferSize
                      &Dns,                    // OutputBuffer
                      sizeof(Dns)              // OutputBufferSize
                      );
        if (status == STATUS_PENDING) {
            Error = WaitForMultipleObjects(
                    2,
                    WaitObject,
                    FALSE,
                    INFINITE
                    );
            if (Error == TERMINATE_EVENT) {
                IO_STATUS_BLOCK iosb2;

                KDPRINT(("Receive terminate event, cancelling request"));
                status = NtCancelIoFile(WaitObject[IO_EVENT], &iosb2);
                KDPRINT(("NtCancelIoFile: status 0x%08lx, iosb.Status 0x%08lx", status, iosb.Status));
                break;
            }
            ASSERT(Error == IO_EVENT);
            status = iosb.Status;
            ASSERT(status != STATUS_PENDING);
        }

        SmbTrace(SMB_TRACE_DNS, ("%!status!", status));

        //
        // Bail out immediately if the underlying driver tell us quota exceeded
        //
        if (status == STATUS_QUOTA_EXCEEDED) {
            KDPRINT(("NtDeviceIoControlFile: STATUS_QUOTA_EXCEEDED"));
            break;
        }

        if (status != STATUS_SUCCESS) {
            KDPRINT(("NtDeviceIoControlFile: status = 0x%08lx", status));
            Error = WaitForSingleObject(hTerminateEvent, 5000);
            if (Error == WAIT_OBJECT_0) {
                KDPRINT(("Receive terminate event"));
                break;
            }
            ASSERT(Error == WAIT_TIMEOUT);
        } else {
            ASSERT(iosb.Information == sizeof(Dns));
            SmbGetHostByName(&Dns);
        }
    }
    NtClose(WaitObject[IO_EVENT]);

    SmbTrace(SMB_TRACE_DNS, ("Thread exit"));

    KDPRINT(("Thread exit"));
    return ERROR_SUCCESS;
}

LONG    ThreadNumber;
HANDLE  hThread[DNS_MAX_RESOLVER];

VOID
SmbSetTraceRoutine(
    int (*trace)(char *,...)
    )
{
#if DBG
    SmbDbgPrint = trace;
#endif
}

DWORD
SmbStartService(
    LONG                    NumWorker,
    SMBSVC_UPDATE_STATUS    HeartBeating
    )
{
    WSADATA WsaData;
    int     i;
    DWORD   Error = ERROR_SUCCESS;

    if (NumWorker > DNS_MAX_RESOLVER || NumWorker < 0) {
        SmbTrace(SMB_TRACE_DNS, ("Error: %d worker threads", NumWorker));
        return ERROR_INVALID_PARAMETER;
    }
    if (NumWorker == 0) {
        NumWorker = DNS_MAX_RESOLVER;
    }
    SmbTrace(SMB_TRACE_DNS, ("Starting %d worker threads", NumWorker));

    if (WSAStartup(MAKEWORD(2, 0), &WsaData) == SOCKET_ERROR) {
        Error = WSAGetLastError();
        KDPRINT (("Failed to startup Winsock2"));
        SmbTrace(SMB_TRACE_DNS, ("Error: %!winerr!", Error));
        return Error;
    }

    hTerminateEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == hTerminateEvent) {
        Error = GetLastError();
        KDPRINT(("Create hTerminateEvent returns %d", Error));
        SmbTrace(SMB_TRACE_DNS, ("Error: %!winerr!", Error));
        return Error;
    }

    if (NULL != HeartBeating) {
        HeartBeating();
    }

    Error = ERROR_SUCCESS;
    for (i = 0; i < NumWorker; i++) {
        hThread[i] = CreateThread(
                NULL,
                8192,
                (LPTHREAD_START_ROUTINE)SmbGetHostThread,
                NULL,
                0,
                NULL
                );
        if (NULL != HeartBeating) {
            HeartBeating();
        }
        if (NULL == hThread[i]) {
            Error = GetLastError();
            KDPRINT(("CreateThread returns %d", Error));
            SmbTrace(SMB_TRACE_DNS, ("Error: %!winerr!", Error));
            break;
        }
    }

    ThreadNumber = i;
    if (i > 0) {
        Error = ERROR_SUCCESS;
    }
    SmbTrace(SMB_TRACE_DNS, ("Thread Num: %d: %!winerr!", ThreadNumber, Error));
    return Error;
}

VOID
SmbStopService(
    SMBSVC_UPDATE_STATUS    HeartBeating
    )
{
    DWORD   Error;
    LONG    i;

    SmbTrace(SMB_TRACE_DNS, ("Stop request received"));
    if (NULL == hTerminateEvent) {
        SmbTrace(SMB_TRACE_DNS, ("Already Stopped"));
        return;
    }

    SmbTrace(SMB_TRACE_DNS, ("Stopping"));
    KDPRINT(("Send terminate event"));
    SetEvent(hTerminateEvent);

    do {
        Error = WaitForMultipleObjects(
                ThreadNumber,
                hThread,
                TRUE,
                1000
                );
        if (NULL != HeartBeating) {
            HeartBeating();
        }
    } while(Error == WAIT_TIMEOUT);
    for (i = 0; i < ThreadNumber; i++) {
        CloseHandle(hThread[i]);
        hThread[i] = NULL;
    }
    ThreadNumber = 0;
    CloseHandle(hTerminateEvent);
    hTerminateEvent = NULL;
    if (NULL != HeartBeating) {
        HeartBeating();
    }
    SmbTrace(SMB_TRACE_DNS, ("Stopped"));
}

HANDLE
OpenSmb(
    LPWSTR Name
    )
{
    UNICODE_STRING      ucName;
    OBJECT_ATTRIBUTES   ObAttr;
    HANDLE              StreamHandle;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            status;

    RtlInitUnicodeString(&ucName, Name);

    InitializeObjectAttributes(
            &ObAttr,
            &ucName,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );
    status = NtCreateFile (
            &StreamHandle,
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
            &ObAttr,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0
            );
    if (status != STATUS_SUCCESS) {
        SetLastError(RtlNtStatusToDosError(status));
        KDPRINT(("Open device %ws: status = 0x%08lx", Name, status));
        return NULL;
    }
    SetLastError(ERROR_SUCCESS);
    return StreamHandle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\dgram.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    dgram.c

Abstract:

    Datagram service

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "dgram.tmh"


NTSTATUS
SmbSendDatagram(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    PAGED_CODE();

    SmbTrace(SMB_TRACE_CALL, ("Entering SmbSendDatagram\n"));
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
SmbReceiveDatagram(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    PAGED_CODE();

    SmbTrace(SMB_TRACE_CALL, ("Entering SmbReceiveDatagram\n"));
    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\dns.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    dns.c

Abstract:

    This module implements a simple DNSv6 resolver

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "dns.tmh"

VOID
SmbDnsTimeout(
    PKDPC                   Dpc,
    PSMB_GETHOST_CONTEXT    Context,
    PVOID                   Unused1,
    PVOID                   Unused2
    );

PIRP __inline
SmbDnsPopResolver(
    VOID
    )
{
    PIRP    Irp;

    ASSERT(Dns.ResolverNumber >= 0);
    if (Dns.ResolverNumber <= 0) {
        return NULL;
    }

    Dns.ResolverNumber--;
    Irp = Dns.ResolverList[Dns.ResolverNumber];
    Dns.ResolverList[Dns.ResolverNumber] = NULL;

    SmbTrace(SMB_TRACE_DNS, ("remove DNS Irp %p, # of resolvers=%d", Irp, Dns.ResolverNumber));
    SmbPrint(SMB_TRACE_DNS, ("remove DNS Irp %p, # of resolvers=%d\n", Irp, Dns.ResolverNumber));
    ASSERT(Irp != NULL);
    return Irp;
}

NTSTATUS __inline
SmbDnsPushResolver(
    PIRP    Irp
    )
{
    ASSERT(SmbCfg.DnsMaxResolver >= 1 && SmbCfg.DnsMaxResolver <= DNS_MAX_RESOLVER);

    if (Dns.ResolverNumber >= SmbCfg.DnsMaxResolver) {
        return STATUS_QUOTA_EXCEEDED;
    }

    ASSERT(IsListEmpty(&Dns.WaitingServerList));
    IoMarkIrpPending(Irp);
    Dns.ResolverList[Dns.ResolverNumber] = Irp;
    Dns.ResolverNumber++;

    SmbTrace(SMB_TRACE_DNS, ("queue DNS Irp %p, # of resolvers=%d", Irp, Dns.ResolverNumber));
    SmbPrint(SMB_TRACE_DNS, ("queue DNS Irp %p, # of resolvers=%d\n", Irp, Dns.ResolverNumber));

    return STATUS_SUCCESS;
}

NTSTATUS
SmbInitDnsResolver(
    VOID
    )
{
    PAGED_CODE();

    RtlZeroMemory(&Dns, sizeof(Dns));

    KeInitializeSpinLock(&Dns.Lock);
    InitializeListHead(&Dns.WaitingServerList);
    InitializeListHead(&Dns.BeingServedList);
    Dns.NextId = 1;

    return STATUS_SUCCESS;
}

VOID
SmbShutdownDnsResolver(
    VOID
    )
{
    LONG    i;
    PIRP    Irp;
    KIRQL   Irql;

    SMB_ACQUIRE_SPINLOCK(&Dns, Irql);
    while (Irp = SmbDnsPopResolver()) {
        SMB_RELEASE_SPINLOCK_DPC(&Dns);
        Irp->IoStatus.Status = STATUS_SYSTEM_SHUTDOWN;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        SMB_ACQUIRE_SPINLOCK_DPC(&Dns);
    }
    SMB_RELEASE_SPINLOCK(&Dns, Irql);
}

VOID
SmbPassupDnsRequest(
    IN PUNICODE_STRING      Name,
    IN PSMB_GETHOST_CONTEXT Context,
    IN PIRP                 DnsIrp,
    IN KIRQL                Irql
    )
{
    PSMB_DNS_BUFFER     DnsBuffer;

    //
    // Spinlock should be held
    //
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    InsertTailList(&Dns.BeingServedList, &Context->Linkage);
    DnsBuffer = (PSMB_DNS_BUFFER)MmGetSystemAddressForMdlSafe(DnsIrp->MdlAddress, HighPagePriority);
    ASSERT(DnsBuffer);
    Context->Id = DnsBuffer->Id = Dns.NextId++;

    if (0 == Dns.NextId) {
        Dns.NextId = 1;
    }
    SmbTrace(SMB_TRACE_DNS, ("pass up DNS request: Irp %p, # of resolvers=%d", DnsIrp, Dns.ResolverNumber));
    SmbPrint(SMB_TRACE_DNS, ("pass up DNS request: Irp %p, # of resolvers=%d\n", DnsIrp, Dns.ResolverNumber));

    ASSERT(Name->Length <= sizeof(DnsBuffer->Name));
    RtlCopyMemory(DnsBuffer->Name, Name->Buffer, Name->Length);
    DnsBuffer->Name[Name->Length/sizeof(WCHAR)] = L'\0';
    DnsBuffer->NameLen = (Name->Length/sizeof(WCHAR)) + 1;
    DnsBuffer->Resolved = FALSE;
    DnsBuffer->IpAddrsNum = 0;
    DnsBuffer->RequestType = 0;
    if (SmbCfg.Tcp6Available) {
        DnsBuffer->RequestType |= SMB_DNS_AAAA;
        if (SmbCfg.bIPv6EnableOutboundGlobal) {
            DnsBuffer->RequestType |= SMB_DNS_AAAA_GLOBAL;
        }
    }
    if (SmbCfg.Tcp4Available) {
        DnsBuffer->RequestType |= SMB_DNS_A;
    }
    SMB_RELEASE_SPINLOCK(&Dns, Irql);

    DnsIrp->IoStatus.Status      = STATUS_SUCCESS;
    DnsIrp->IoStatus.Information = sizeof(DnsBuffer[0]);
    IoCompleteRequest(DnsIrp, IO_NETWORK_INCREMENT);
}

VOID
SmbCancelConnectAtDns(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             Irp
    );

BOOL
LookupLocalName(
    IN PUNICODE_STRING  Name,
    IN PSMB_IP_ADDRESS  ipaddr
    )
/*++

Routine Description:

    Lookup the name in local client list. If it is found,
    return a loopback IP address in ipaddr.

    TO BE FINISHED.

Arguments:

Return Value:

    TRUE    if it is found

--*/
{
    OEM_STRING  oemName;
    CHAR        NbName[NETBIOS_NAME_SIZE+1];
    KIRQL       Irql;
    NTSTATUS    status;
    PLIST_ENTRY entry;
    PSMB_CLIENT_ELEMENT client;
    BOOL        found = FALSE;

    PAGED_CODE();

    if (Name->Length > NETBIOS_NAME_SIZE * sizeof(WCHAR)) {
        return FALSE;
    }

    oemName.Buffer = NbName;
    oemName.MaximumLength = NETBIOS_NAME_SIZE + 1;
    status = RtlUpcaseUnicodeStringToOemString(&oemName, Name, FALSE);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    if (oemName.Length > NETBIOS_NAME_SIZE) {
        return FALSE;
    }

    ASSERT(oemName.Buffer == NbName);
    //
    // Pad the name with SPACEs
    //
    if (oemName.Length < NETBIOS_NAME_SIZE) {
        RtlFillMemory(oemName.Buffer + oemName.Length, NETBIOS_NAME_SIZE - oemName.Length, ' ');
        oemName.Length = NETBIOS_NAME_SIZE;
    }
    ASSERT(oemName.Length == NETBIOS_NAME_SIZE);

    found = FALSE;
    SMB_ACQUIRE_SPINLOCK(SmbCfg.SmbDeviceObject, Irql);
    entry = SmbCfg.SmbDeviceObject->ClientList.Flink;
    while (entry != &SmbCfg.SmbDeviceObject->ClientList) {
        client = CONTAINING_RECORD(entry, SMB_CLIENT_ELEMENT, Linkage);
        if (RtlEqualMemory(client->EndpointName, oemName.Buffer, oemName.Length)) {
            found = TRUE;
        }

        entry = entry->Flink;
    }
    SMB_RELEASE_SPINLOCK(SmbCfg.SmbDeviceObject, Irql);

    if (found) {
        if (IsTcp6Available()) {
            ipaddr->sin_family = SMB_AF_INET6;
            ip6addr_getloopback(&ipaddr->ip6);
            hton_ip6addr(&ipaddr->ip6);
        } else {
            ipaddr->sin_family = SMB_AF_INET;
            ipaddr->ip4.sin4_addr = htonl(INADDR_ANY);
        }
    }

    return found;
}

void SmbAsyncGetHostByName(
    IN PUNICODE_STRING      Name,
    IN PSMB_GETHOST_CONTEXT Context
    )
{
    KIRQL   Irql, CancelIrql;
    PIRP    DnsIrp = NULL, ClientIrp = NULL;

    PAGED_CODE();

    SmbPrint(SMB_TRACE_CALL, ("SmbAsyncGetHostByName %Z\n", Name));

    SmbAsyncStartTimer((PSMB_ASYNC_CONTEXT)Context, (PKDEFERRED_ROUTINE)SmbDnsTimeout);
    if (inet_addr6W(Name->Buffer, &Context->ipaddr[0].ip6)) {
        Context->ipaddr_num        = 1;
        Context->ipaddr[0].sin_family = SMB_AF_INET6;
        Context->status            = STATUS_SUCCESS;
        Context->FQDN.Length       = 0;
        Context->FQDN.Buffer[0]    = 0;
        SmbAsyncCompleteRequest((PSMB_ASYNC_CONTEXT)Context);
        return;
    }

    Context->ipaddr[0].ip4.sin4_addr = inet_addrW(Name->Buffer);
    if (Context->ipaddr[0].ip4.sin4_addr != 0 && Context->ipaddr[0].ip4.sin4_addr != (ULONG)(-1)) {
        Context->ipaddr_num        = 1;
        Context->ipaddr[0].sin_family = SMB_AF_INET;
        Context->status            = STATUS_SUCCESS;
        Context->FQDN.Length       = 0;
        Context->FQDN.Buffer[0]    = 0;
        SmbAsyncCompleteRequest((PSMB_ASYNC_CONTEXT)Context);
        return;
    }

    if (LookupLocalName(Name, &Context->ipaddr[0])) {
        Context->ipaddr_num        = 1;
        Context->status            = STATUS_SUCCESS;
        Context->FQDN.Length       = 0;
        Context->FQDN.Buffer[0]    = 0;
        SmbAsyncCompleteRequest((PSMB_ASYNC_CONTEXT)Context);
        return;
    }

    //
    // The name is too long
    //
    if (Name->Length + sizeof(WCHAR) > Context->FQDN.MaximumLength) {
        Context->status = STATUS_INVALID_PARAMETER;
        SmbAsyncCompleteRequest((PSMB_ASYNC_CONTEXT)Context);
        return;
    }

    //
    // It is not a IP address string, go to DNS resolver, to be implemented
    //
    ClientIrp = ((PSMB_CONNECT)Context->ClientContext)->PendingIRPs[SMB_PENDING_CONNECT];
    ASSERT(ClientIrp);

    SMB_ACQUIRE_SPINLOCK(&Dns, Irql);
    IoAcquireCancelSpinLock(&CancelIrql);
    if (ClientIrp->Cancel) {
        IoReleaseCancelSpinLock(CancelIrql);
        SMB_RELEASE_SPINLOCK(&Dns, Irql);

        //
        // Already cancelled
        //
        Context->status = STATUS_CANCELLED;
        SmbAsyncCompleteRequest((PSMB_ASYNC_CONTEXT)Context);
        return;
    }

    IoSetCancelRoutine(ClientIrp, SmbCancelConnectAtDns);

    DnsIrp = SmbDnsPopResolver();
    if (NULL == DnsIrp) {
        RtlCopyMemory(Context->FQDN.Buffer, Name->Buffer, Name->Length);
        Context->FQDN.Length = Name->Length;
        Context->FQDN.Buffer[Name->Length/sizeof(WCHAR)] = L'\0';
        InsertTailList(&Dns.WaitingServerList, &Context->Linkage);
        IoReleaseCancelSpinLock(CancelIrql);
        SMB_RELEASE_SPINLOCK(&Dns, Irql);
        return;
    }

    IoSetCancelRoutine(DnsIrp, NULL);
    IoReleaseCancelSpinLock(CancelIrql);

    //
    // This guy will complete the Irp and release the spinlock!!!
    //
    SmbPassupDnsRequest(Name, Context, DnsIrp, Irql);
}

VOID
SmbCancelDns(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             Irp
    )
{
    KIRQL   Irql;
    LONG    i;
    BOOL    Found = FALSE;

    //
    // Avoid deadlock, we need to release the spinlock first
    //
    SmbTrace(SMB_TRACE_DNS, ("Cancel DNS Irp %p", Irp));
    SmbPrint(SMB_TRACE_DNS, ("Cancel DNS Irp %p\n", Irp));
    IoSetCancelRoutine(Irp, NULL);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // After the cancel spinlock is released, the IRP can be completed
    // Check if it is still in our pending list
    //
    SMB_ACQUIRE_SPINLOCK(&Dns, Irql);
    for (i = 0; i < Dns.ResolverNumber; i++) {
        if (Dns.ResolverList[i] == Irp) {
            Dns.ResolverNumber--;
            Dns.ResolverList[i] = Dns.ResolverList[Dns.ResolverNumber];
            Dns.ResolverList[Dns.ResolverNumber] = NULL;
            Found = TRUE;
            break;
        }
    }
    SMB_RELEASE_SPINLOCK(&Dns, Irql);

    if (Found) {
        Irp->IoStatus.Status      = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        SmbTrace(SMB_TRACE_DNS, ("Complete Cancel DNS Irp %p", Irp));
        SmbPrint(SMB_TRACE_DNS, ("Complete Cancel DNS Irp %p\n", Irp));
    }
}

PSMB_GETHOST_CONTEXT
SmbDnsLookupGethostCtx(
    PLIST_ENTRY queue,
    PIRP        Irp
    )
{
    PLIST_ENTRY         entry;
    PIRP                ClientIrp;
    PSMB_GETHOST_CONTEXT Context;

    //
    // Spinlock should be held
    //
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    entry = queue->Flink;
    while (entry != queue) {
        Context = CONTAINING_RECORD(entry, SMB_GETHOST_CONTEXT, Linkage);
        ClientIrp = ((PSMB_CONNECT)Context->ClientContext)->PendingIRPs[SMB_PENDING_CONNECT];
        if (ClientIrp == Irp) {
            return Context;
        }
        entry = entry->Flink;
    }
    return NULL;
}

VOID
SmbCancelConnectAtDns(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             Irp
    )
{
    PSMB_GETHOST_CONTEXT Context;
    KIRQL               Irql;

    //
    // Avoid deadlock, we need to release the spinlock first
    //
    SmbTrace(SMB_TRACE_OUTBOUND, ("Cancel Connect Irp %p", Irp));
    SmbPrint(SMB_TRACE_OUTBOUND, ("Cancel Connect Irp %p\n", Irp));

    IoSetCancelRoutine(Irp, NULL);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    SMB_ACQUIRE_SPINLOCK(&Dns, Irql);
    Context = SmbDnsLookupGethostCtx(&Dns.BeingServedList, Irp);
    if (NULL == Context) {
        Context = SmbDnsLookupGethostCtx(&Dns.WaitingServerList, Irp);
    }
    if (NULL == Context) {
        SMB_RELEASE_SPINLOCK(&Dns, Irql);
        //
        // This could happen. The DNS name resolution request could completed just before
        // we acquire the spinlock Dns.Lock
        //
        // This ASSERT can be removed after we investigates one such case.
        //
        // ASSERT(0);       Hit in the 04/03/2001 stress
        SmbTrace(SMB_TRACE_OUTBOUND, ("Internal error: Cancel Connect Irp %p", Irp));
        SmbPrint(SMB_TRACE_OUTBOUND, ("Internal error: Cancel Connect Irp %p\n", Irp));
        return;
    }

    RemoveEntryList(&Context->Linkage);
    InitializeListHead(&Context->Linkage);
    SMB_RELEASE_SPINLOCK(&Dns, Irql);

    Context->status = STATUS_CANCELLED;
    SmbAsyncCompleteRequest((PSMB_ASYNC_CONTEXT)Context);
}

VOID
SmbDnsTimeout(
    PKDPC                   Dpc,
    PSMB_GETHOST_CONTEXT    Context,
    PVOID                   Unused1,
    PVOID                   Unused2
    )
{
    KIRQL   Irql;
    BOOL    Found;

    //
    // Be careful on the operations on the Context before we're sure it
    // is still in the linked list.
    // It could be completed and freed.
    //
    SMB_ACQUIRE_SPINLOCK(&Dns, Irql);

    //
    // Note: &Context->Linkage is safe since it doesn't access the
    //       storage allocated for Context!!!
    //
    Found = EntryIsInList(&Dns.BeingServedList, &Context->Linkage);
    if (!Found) {
        Found = EntryIsInList(&Dns.WaitingServerList, &Context->Linkage);
    }
    if (Found) {
        //
        // We're safe
        //
        RemoveEntryList(&Context->Linkage);
        InitializeListHead(&Context->Linkage);
    }
    SMB_RELEASE_SPINLOCK(&Dns, Irql);

    if (Found) {
        Context->status = STATUS_BAD_NETWORK_PATH;
        SmbAsyncCompleteRequest((PSMB_ASYNC_CONTEXT)Context);
    }
}

NTSTATUS
SmbNewResolver(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    KIRQL       Irql, CancelIrql;
    NTSTATUS    status;
    PIO_STACK_LOCATION  IrpSp;
    ULONG       Size;
    PSMB_DNS_BUFFER     DnsBuffer;
    PLIST_ENTRY         entry;
    PSMB_GETHOST_CONTEXT Context;
    PIRP                ClientIrp;

    if (NULL == Irp->MdlAddress) {
        return STATUS_INVALID_PARAMETER;
    }
    Size = MmGetMdlByteCount(Irp->MdlAddress);
    if (Size < sizeof(SMB_DNS_BUFFER)) {
        return STATUS_INVALID_PARAMETER;
    }
    DnsBuffer = (PSMB_DNS_BUFFER)MmGetSystemAddressForMdlSafe(Irp->MdlAddress, HighPagePriority);
    if (NULL == DnsBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    SMB_ACQUIRE_SPINLOCK(&Dns, Irql);
    if (!IsListEmpty(&Dns.BeingServedList) && DnsBuffer->Id) {
        //
        // Complete the pending DNS request being served by this resolver
        //
        entry = Dns.BeingServedList.Flink;
        while (entry != &Dns.BeingServedList) {
            Context = CONTAINING_RECORD(entry, SMB_GETHOST_CONTEXT, Linkage);
            if (Context->Id == DnsBuffer->Id) {
                break;
            }
            entry = entry->Flink;
        }
        if (entry != &Dns.BeingServedList) {
            RemoveEntryList(&Context->Linkage);
            InitializeListHead(&Context->Linkage);
            SMB_RELEASE_SPINLOCK(&Dns, Irql);
            ClientIrp = ((PSMB_CONNECT)Context->ClientContext)->PendingIRPs[SMB_PENDING_CONNECT];
            ASSERT(ClientIrp);

            IoAcquireCancelSpinLock(&CancelIrql);
            IoSetCancelRoutine(ClientIrp, NULL);
            IoReleaseCancelSpinLock(CancelIrql);

            if (ClientIrp->Cancel) {
                Context->status = STATUS_CANCELLED;
            } else {
                if (DnsBuffer->Resolved) {
                    USHORT  BytesToCopy;

                    Context->status     = STATUS_SUCCESS;
                    Context->ipaddr_num = DnsBuffer->IpAddrsNum;
                    if (Context->ipaddr_num > SMB_MAX_IPADDRS_PER_HOST) {
                        ASSERT (0);
                        Context->ipaddr_num = SMB_MAX_IPADDRS_PER_HOST;
                    }
                    RtlCopyMemory (Context->ipaddr, DnsBuffer->IpAddrsList,
                                    Context->ipaddr_num * sizeof(Context->ipaddr[0]));

                    if (DnsBuffer->NameLen) {
                        //
                        // Return the FQDN to RDR
                        //
                        Context->pUnicodeAddress->NameBufferType = NBT_WRITTEN;

                        BytesToCopy = (USHORT)DnsBuffer->NameLen * sizeof(WCHAR);
                        if (BytesToCopy > Context->pUnicodeAddress->RemoteName.MaximumLength) {
                            BytesToCopy = Context->pUnicodeAddress->RemoteName.MaximumLength - sizeof(WCHAR);
                        }

                        RtlCopyMemory(Context->pUnicodeAddress->RemoteName.Buffer,
                                        DnsBuffer->Name, BytesToCopy);
                        Context->pUnicodeAddress->RemoteName.Buffer[BytesToCopy/sizeof(WCHAR)] = L'\0';
                        Context->pUnicodeAddress->RemoteName.Length = BytesToCopy;
                    }
                } else {
                    Context->status = STATUS_BAD_NETWORK_PATH;
                }
            }

            //
            // Is it better to start another thread?
            //  Risk: if the connection setup is stucked in tcpip,
            //        this thread won't be able to serve other DNS requests
            //
            SmbAsyncCompleteRequest((PSMB_ASYNC_CONTEXT)Context);

            SMB_ACQUIRE_SPINLOCK(&Dns, Irql);
        }
    }

    if (IsListEmpty(&Dns.WaitingServerList)) {
        //
        // We need to queue the IRP, setup the cancel routine.
        //
        IoAcquireCancelSpinLock(&CancelIrql);
        if (Irp->Cancel) {
            IoReleaseCancelSpinLock(CancelIrql);
            SMB_RELEASE_SPINLOCK(&Dns, Irql);
            SmbTrace(SMB_TRACE_DNS, ("DNS Irp %p is cancelled", Irp));
            SmbPrint(SMB_TRACE_DNS, ("DNS Irp %p is cancelled\n", Irp));
            return STATUS_CANCELLED;
        }
        IoSetCancelRoutine(Irp, SmbCancelDns);
        IoReleaseCancelSpinLock(CancelIrql);

        status = SmbDnsPushResolver(Irp);
        if (NT_SUCCESS(status)) {
            status = STATUS_PENDING;
        } else {
            IoAcquireCancelSpinLock(&CancelIrql);
            IoSetCancelRoutine(Irp, NULL);
            IoReleaseCancelSpinLock(CancelIrql);
        }
        SMB_RELEASE_SPINLOCK(&Dns, Irql);
        return status;
    }

    //
    // We have another guy to be served
    //
    Context = CONTAINING_RECORD(Dns.WaitingServerList.Flink, SMB_GETHOST_CONTEXT, Linkage);
    RemoveEntryList(&Context->Linkage);
    InitializeListHead(&Context->Linkage);

    IoMarkIrpPending(Irp);

    //
    // This guy will complete the Irp and release the spinlock!!!
    //
    SmbPassupDnsRequest(&Context->FQDN, Context, Irp, Irql);

    //
    // Avoid double completion
    //
    return STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\global.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    global.c

Abstract:

    Platform independent utility functions

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"

SMBCONFIG   SmbCfg;
SMBDNS      Dns;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\ip2netbios.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ip2netbios.c

Abstract:

    Generate a Netbios name for IPv6 address
    srv.sys cannot handle IPv6 address. It always expect a 15 characters Netbios name.
    This is a temporary solution. The utilmate solution should be in srv.

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"

struct SMB_IPV6_NETBIOS_TABLE {
    PSMB_HASH_TABLE HashTable;
    DWORD           SerialNumber;

#ifndef NO_LOOKASIDE_LIST
    NPAGED_LOOKASIDE_LIST   LookasideList;
    BOOL                    LookasideListInitialized;
#endif
} SmbIPv6Mapping;

typedef struct {
    LIST_ENTRY  Linkage;
    BYTE        IpAddress[16];
    LONG        RefCount;
    DWORD       Serial;
} SMB_IPV6_NETBIOS, *PSMB_IPV6_NETBIOS;
#define SMB_IPV6_NETBIOS_TAG    'MBMS'

#ifdef NO_LOOKASIDE_LIST
PSMB_IPV6_NETBIOS __inline SMB_NEW_MAPPING(VOID)
{
    return ExAllocatePoolWithTag(NonPagedPool, sizeof(SMB_IPV6_NETBIOS), SMB_IPV6_NETBIOS_TAG);
}

VOID __inline SMB_FREE_MAPPING(PSMB_IPV6_NETBIOS mapping)
{
    ExFreePool(mapping);
}
#else
PSMB_IPV6_NETBIOS __inline SMB_NEW_MAPPING(VOID)
{
    return ExAllocateFromNPagedLookasideList(&SmbIPv6Mapping.LookasideList);
}

VOID __inline SMB_FREE_MAPPING(PSMB_IPV6_NETBIOS mapping)
{
    ExFreeToNPagedLookasideList(&SmbIPv6Mapping.LookasideList, mapping);
}
#endif

static PVOID __inline
SmbIPv6MapGetIpAddress(
    PLIST_ENTRY  entry
    )
{
    PSMB_IPV6_NETBIOS   mapping = NULL;

    mapping = CONTAINING_RECORD(entry, SMB_IPV6_NETBIOS, Linkage);
    return mapping->IpAddress;
}

static int
SmbCompareIPv6Address(
    PLIST_ENTRY entry,
    BYTE        ip6[16]
    )
{
    return memcmp(SmbIPv6MapGetIpAddress(entry), ip6, 16);
}

static DWORD
SmbHashIPv6(BYTE ip6[16])
{
    DWORD   sum = 0;
    int     i;

    for (sum = 0, i = 0; i < 16; i++) {
        sum += ip6[i];
    }

    return sum;
}

static VOID
SmbOnAddMapping(
    PLIST_ENTRY entry
    )
{
    PSMB_IPV6_NETBIOS   mapping = NULL;

    mapping = CONTAINING_RECORD(entry, SMB_IPV6_NETBIOS, Linkage);
    mapping->Serial = InterlockedIncrement(&SmbIPv6Mapping.SerialNumber);
    mapping->RefCount = 1;
}

static VOID
SmbOnDelMapping(
    PLIST_ENTRY entry
    )
{
    PSMB_IPV6_NETBIOS   mapping = NULL;

    mapping = CONTAINING_RECORD(entry, SMB_IPV6_NETBIOS, Linkage);
    ASSERT(mapping->RefCount == 0);
    SMB_FREE_MAPPING(mapping);
}

static LONG
SmbReferenceMapping(
    PLIST_ENTRY entry
    )
{
    PSMB_IPV6_NETBIOS   mapping = NULL;
    LONG                RefCount;

    mapping = CONTAINING_RECORD(entry, SMB_IPV6_NETBIOS, Linkage);
    RefCount = InterlockedIncrement(&mapping->RefCount);
    ASSERT(RefCount > 1);
    return RefCount;
}

static LONG
SmbDereferenceMapping(
    PLIST_ENTRY entry
    )
{
    PSMB_IPV6_NETBIOS   mapping = NULL;
    LONG                RefCount;

    mapping = CONTAINING_RECORD(entry, SMB_IPV6_NETBIOS, Linkage);
    RefCount = InterlockedDecrement(&mapping->RefCount);
    ASSERT(RefCount >= 0);
    return RefCount;
}

NTSTATUS
SmbInitIPv6NetbiosMappingTable(
    VOID
    )
{
    NTSTATUS    status = STATUS_SUCCESS;

    RtlZeroMemory(&SmbIPv6Mapping, sizeof(SmbIPv6Mapping));

    SmbIPv6Mapping.HashTable =
                SmbCreateHashTable(
                        256,
                        SmbHashIPv6,
                        SmbIPv6MapGetIpAddress,
                        SmbCompareIPv6Address,
                        SmbOnAddMapping,
                        SmbOnDelMapping,
                        SmbReferenceMapping,
                        SmbDereferenceMapping
                        );
    if (NULL == SmbIPv6Mapping.HashTable) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error;
    }

    SmbIPv6Mapping.SerialNumber = 0;

#ifndef NO_LOOKASIDE_LIST
    ExInitializeNPagedLookasideList(
            &SmbIPv6Mapping.LookasideList,
            NULL,
            NULL,
            0,
            sizeof(SMB_IPV6_NETBIOS),
            SMB_IPV6_NETBIOS_TAG,
            0
            );
    SmbIPv6Mapping.LookasideListInitialized = TRUE;
#endif

error:
    return status;
}

VOID
SmbShutdownIPv6NetbiosMappingTable(
    VOID
    )
{
    SmbDestroyHashTable(SmbIPv6Mapping.HashTable);
    SmbIPv6Mapping.HashTable = NULL;
#ifndef NO_LOOKASIDE_LIST
    if (SmbIPv6Mapping.LookasideListInitialized) {
        ExDeleteNPagedLookasideList(&SmbIPv6Mapping.LookasideList);
        SmbIPv6Mapping.LookasideListInitialized = FALSE;
    }
#endif
}

#define xdigit2asc(x)   ((CHAR)(((x) < 10)?((x)+'0'):((x)+'0' + 'a' - '9' - 1)))

static void
UlongToHex(
    ULONG   x,
    CHAR    *Buffer
    )
{
    Buffer[0] = xdigit2asc((x >> 28) & 0xf);
    Buffer[1] = xdigit2asc((x >> 24) & 0xf);
    Buffer[2] = xdigit2asc((x >> 20) & 0xf);
    Buffer[3] = xdigit2asc((x >> 16) & 0xf);
    Buffer[4] = xdigit2asc((x >> 12) & 0xf);
    Buffer[5] = xdigit2asc((x >> 8) & 0xf);
    Buffer[6] = xdigit2asc((x >> 4) & 0xf);
    Buffer[7] = xdigit2asc(x & 0xf);
    Buffer[8] = 0;
}

BOOL
GetNetbiosNameFromIp6Address(BYTE ip6[16], CHAR SmbName[16])
{
    PSMB_IPV6_NETBIOS   NewMapping = NULL;
    PLIST_ENTRY FoundEntry = NULL, NewEntry = NULL;

    NewMapping = SMB_NEW_MAPPING();
    if (NULL == NewMapping) {
        return FALSE;
    }

    NewEntry = &NewMapping->Linkage;
    RtlCopyMemory(NewMapping->IpAddress, ip6, 16);
    FoundEntry = SmbAddToHashTable(SmbIPv6Mapping.HashTable, NewEntry);
    if (FoundEntry != NewEntry) {
        SMB_FREE_MAPPING(NewMapping);
        NewMapping = NULL;
        NewEntry   = NULL;
    }

    NewMapping = CONTAINING_RECORD(FoundEntry, SMB_IPV6_NETBIOS, Linkage);
    RtlCopyMemory(SmbName, "*SMBSERVER   ", 7);
    UlongToHex(NewMapping->Serial, SmbName + 7);
    return TRUE;
}

VOID
FreeNetbiosNameForIp6Address(BYTE ip6[16])
{
    SmbRemoveFromHashTable(SmbIPv6Mapping.HashTable, ip6);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\ioctl.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    I/O Control of SMB6 device

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "nb30.h"
#include "ioctl.tmh"

#pragma alloc_text(PAGE, SmbCreateControl)

NTSTATUS
SmbCreateControl(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    PIO_STACK_LOCATION  IrpSp;

    PAGED_CODE();

    SmbPrint(SMB_TRACE_CALL, ("Enter SmbCreateControl\n"));
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    IrpSp->FileObject->FsContext  = NULL;
    IrpSp->FileObject->FsContext2 = UlongToPtr(SMB_TDI_CONTROL);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbCloseControl(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
#pragma alloc_text(PAGE, SmbCloseControl)
{
    PIO_STACK_LOCATION  IrpSp;

    PAGED_CODE();

    SmbPrint(SMB_TRACE_CALL, ("Enter SmbCloseControl\n"));
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT (IrpSp->FileObject->FsContext2 == UlongToPtr(SMB_TDI_CONTROL));
    return STATUS_SUCCESS;
}

NTSTATUS
SmbQueryProviderCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    This routine handles the completion event when the Query Provider
    Information completes.  This routine must decrement the MaxDgramSize
    and max send size by the respective NBT header sizes.

Arguments:

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PTDI_PROVIDER_INFO      Provider;

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        ASSERT(0);
        return STATUS_SUCCESS;
    }

    Provider = (PTDI_PROVIDER_INFO)MmGetMdlVirtualAddress(Irp->MdlAddress);
    Provider->ServiceFlags = TDI_SERVICE_MESSAGE_MODE |
                             TDI_SERVICE_CONNECTION_MODE |
                             TDI_SERVICE_CONNECTIONLESS_MODE |
                             TDI_SERVICE_ERROR_FREE_DELIVERY |
                             TDI_SERVICE_BROADCAST_SUPPORTED |
                             TDI_SERVICE_MULTICAST_SUPPORTED |
                             TDI_SERVICE_DELAYED_ACCEPTANCE |
                             TDI_SERVICE_ROUTE_DIRECTED |
                             TDI_SERVICE_FORCE_ACCESS_CHECK;
    Provider->MinimumLookaheadData = 128;

    //
    // Adjust maximum session packet size
    //
    if (Provider->MaxSendSize > SMB_SESSION_HEADER_SIZE) {
        if (Provider->MaxSendSize > (0x1ffff + SMB_SESSION_HEADER_SIZE)) {
            Provider->MaxSendSize = 0x1ffff;
        } else {
            Provider->MaxSendSize -= SMB_SESSION_HEADER_SIZE;
        }
    } else {
        Provider->MaxSendSize = 0;
    }

    //
    // SMB device doesn't support datagram
    //
    Provider->MaxDatagramSize = 0;
    SmbPrint(SMB_TRACE_CALL, ("SmbQueryProviderCompletion: Complete IRP %p\n", Irp));
    return STATUS_SUCCESS;
}

NTSTATUS
SmbQueryTcpProviderInfo(
    PFILE_OBJECT        ControlFileObject,
    PIRP                Irp,
    PTDI_PROVIDER_INFO  TcpProvider
    )
{
    PMDL        Mdl, SavedMdl;
    NTSTATUS    status;

    TcpProvider->MaxSendSize = SMB_MAX_SESSION_PACKET;
    if (NULL == ControlFileObject) {
        return STATUS_INVALID_PARAMETER;
    }
    Mdl = IoAllocateMdl(TcpProvider, sizeof(TDI_PROVIDER_INFO), FALSE, FALSE, NULL);
    if (NULL == Mdl) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    MmBuildMdlForNonPagedPool(Mdl);

    SavedMdl = Irp->MdlAddress;
    TdiBuildQueryInformation(
            Irp,
            IoGetRelatedDeviceObject(ControlFileObject),
            ControlFileObject,
            NULL,
            NULL,
            TDI_QUERY_PROVIDER_INFO,
            Mdl
            );
    status = SubmitSynchTdiRequest (ControlFileObject, Irp);
    Irp->MdlAddress = SavedMdl;
    if (status == STATUS_SUCCESS) {
        if (TcpProvider->MaxSendSize > SMB_SESSION_HEADER_SIZE) {
            if (TcpProvider->MaxSendSize > (0x1ffff + SMB_SESSION_HEADER_SIZE)) {
                TcpProvider->MaxSendSize = 0x1ffff;
            } else {
                TcpProvider->MaxSendSize -= SMB_SESSION_HEADER_SIZE;
            }
        } else {
            TcpProvider->MaxSendSize = 0;
        }
        SmbPrint(SMB_TRACE_TCP, ("SmbQueryTcpProviderInfo returns MaxSendSize = %d bytes\n",
                                TcpProvider->MaxSendSize));
        SmbTrace(SMB_TRACE_TCP, ("returns MaxSendSize = %d bytes", TcpProvider->MaxSendSize));
    } else {
        SmbPrint(SMB_TRACE_TCP, ("SmbQueryTcpProviderInfo returns status = 0x%08lx\n", status));
        SmbTrace(SMB_TRACE_TCP, ("returns %!status!", status));
    }

    IoFreeMdl(Mdl);
    return status;
}

NTSTATUS
SmbQueryProviderInfo(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PTDI_PROVIDER_INFO  TcpProvider = NULL, Provider = NULL;
    DWORD               BytesCopied = 0;

    if (NULL == Irp->MdlAddress) {
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    TcpProvider = (PTDI_PROVIDER_INFO)ExAllocatePoolWithTag(
            NonPagedPool, sizeof(TDI_PROVIDER_INFO), '6BMS');
    Provider = (PTDI_PROVIDER_INFO)ExAllocatePoolWithTag(
            NonPagedPool, sizeof(TDI_PROVIDER_INFO), '6BMS');
    if (NULL == TcpProvider || NULL == Provider) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    status = STATUS_UNSUCCESSFUL;
    RtlZeroMemory(Provider, sizeof(TDI_PROVIDER_INFO));

    //
    // Set SMB-specific information
    //
    Provider->Version               = 0x0200;
    Provider->MaxSendSize           = SMB_MAX_SESSION_PACKET;
    Provider->MaxConnectionUserData = 0;
    Provider->MaxDatagramSize       = 0;
    Provider->ServiceFlags = TDI_SERVICE_MESSAGE_MODE |
                             TDI_SERVICE_CONNECTION_MODE |
                             TDI_SERVICE_CONNECTIONLESS_MODE |
                             TDI_SERVICE_ERROR_FREE_DELIVERY |
                             TDI_SERVICE_BROADCAST_SUPPORTED |
                             TDI_SERVICE_MULTICAST_SUPPORTED |
                             TDI_SERVICE_DELAYED_ACCEPTANCE |
                             TDI_SERVICE_ROUTE_DIRECTED |
                             TDI_SERVICE_FORCE_ACCESS_CHECK;
    Provider->MinimumLookaheadData  = 128;
    Provider->MaximumLookaheadData  = SMB_MAX_SESSION_PACKET;

    //
    // Query TCP4 info
    //
    if (SmbCfg.Tcp4Available) {
        status = SmbQueryTcpProviderInfo(Device->Tcp4.TCPControlFileObject, Irp, TcpProvider);
        if (status == STATUS_SUCCESS) {
            if (Provider->MaxSendSize > TcpProvider->MaxSendSize) {
                Provider->MaxSendSize = TcpProvider->MaxSendSize;
            }
        }
    }

    //
    // Query TCP6 info
    //
    if (SmbCfg.Tcp6Available) {
        status = SmbQueryTcpProviderInfo(Device->Tcp6.TCPControlFileObject, Irp, TcpProvider);
        if (status == STATUS_SUCCESS) {
            if (Provider->MaxSendSize > TcpProvider->MaxSendSize) {
                Provider->MaxSendSize = TcpProvider->MaxSendSize;
            }
        }
    }

    BytesCopied = 0;
    status = TdiCopyBufferToMdl (Provider, 0, sizeof(TDI_PROVIDER_INFO),
                        Irp->MdlAddress, 0, &BytesCopied);

cleanup:
    if (NULL != TcpProvider) {
        ExFreePool(TcpProvider);
        TcpProvider = NULL;
    }
    if (NULL != Provider) {
        ExFreePool(Provider);
        Provider = NULL;
    }
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = (status != STATUS_SUCCESS)? 0: BytesCopied;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return status;
}

NTSTATUS
SmbQueryAdapterStatus(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
/*++

Routine Description:

    Return the local adapter status

Arguments:


Return Value:

    NTSTATUS.
    Note: this routine should complete the IRP because
          the caller doesn't complete it.

    Smb device is netbiosless. We don't need to return
    name cache as we do in legacy NetBT devices.

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    DWORD           Size = 0, BytesCopied = 0;
    ADAPTER_STATUS  as = { 0 };
    
    if (NULL == Irp->MdlAddress) {
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    Size = MmGetMdlByteCount (Irp->MdlAddress);
    if (Size < sizeof(ADAPTER_STATUS)) {
        status = STATUS_BUFFER_TOO_SMALL;
        goto cleanup;
    }

    RtlZeroMemory(&as, sizeof(ADAPTER_STATUS));
    as.rev_major    = 0x03;
    as.adapter_type = 0xFE;     // pretend it is an ethernet adapter
    as.name_count   = 0;        // Smb device won't return the name cache
    as.max_cfg_sess = (USHORT)0xffff;
    as.max_sess     = (USHORT)0xffff;
    as.free_ncbs    = (USHORT)0xffff;
    as.max_cfg_ncbs = (USHORT)0xffff;
    as.max_ncbs     = (USHORT)0xffff;
    as.max_dgram_size    = 0;   // Smb device doesn't support datagram
    as.max_sess_pkt_size = 0xffff;

    BytesCopied = 0;
    status = TdiCopyBufferToMdl (&as, 0, sizeof(ADAPTER_STATUS),
                        Irp->MdlAddress, 0, &BytesCopied);

cleanup:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = (status != STATUS_SUCCESS)? 0: BytesCopied;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return status;
}

NTSTATUS
SmbQueryPeerInfo(
    PSMB_CONNECT            ConnectObject,
    PNBT_ADDRESS_PAIR_INFO  AddressPair,
    DWORD                   Size,
    DWORD                   *BytesCopied
    )
{
    KIRQL                   Irql = 0;
    NBT_ADDRESS_PAIR_INFO   ap = { 0 };
    DWORD                   RequiredSize = 0;

    *BytesCopied = 0;

    RtlZeroMemory(&ap, sizeof(ap));
    ap.ActivityCount = 1;
    ap.AddressPair.TAAddressCount = 2;

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    if (NULL == ConnectObject->TcpContext) {
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        return STATUS_CONNECTION_DISCONNECTED;
    }

    //
    // Fill IP address
    //
    if (SMB_AF_INET == ConnectObject->RemoteIpAddress.sin_family) {
        ap.AddressPair.AddressIP.AddressLength = TDI_ADDRESS_LENGTH_IP;
        ap.AddressPair.AddressIP.AddressType   = TDI_ADDRESS_TYPE_IP;
        ap.AddressPair.AddressIP.Address.in_addr = ConnectObject->RemoteIpAddress.ip4.sin4_addr;
        RequiredSize = sizeof(ap) +
            sizeof(ap.AddressPair.AddressIP.Address) - 
            sizeof(ap.AddressPair.AddressIP.AddressIp6);
    } else {
        ap.AddressPair.AddressIP.AddressLength = TDI_ADDRESS_LENGTH_IP6;
        ap.AddressPair.AddressIP.AddressType   = TDI_ADDRESS_TYPE_IP6;
        RtlCopyMemory(
            ap.AddressPair.AddressIP.AddressIp6.sin6_addr,
            ConnectObject->RemoteIpAddress.ip6.sin6_addr,
            sizeof(ap.AddressPair.AddressIP.AddressIp6.sin6_addr)
            );
        ap.AddressPair.AddressIP.AddressIp6.sin6_scope_id = ConnectObject->RemoteIpAddress.ip6.sin6_scope_id;
        RequiredSize = sizeof(ap);
    }

    //
    // Fill Netbios address
    //
    ap.AddressPair.AddressNetBIOS.AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ap.AddressPair.AddressNetBIOS.AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
    ap.AddressPair.AddressNetBIOS.Address.NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    RtlCopyMemory(
                ap.AddressPair.AddressNetBIOS.Address.NetbiosName,
                ConnectObject->RemoteName,
                NETBIOS_NAME_SIZE
                );
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    if (Size > sizeof(ap)) {
        Size = sizeof(ap);
    }

    RtlCopyMemory(AddressPair, &ap, Size);
    *BytesCopied = Size;

    //
    // note: STATUS_BUFFER_OVERFLOW can pass NT_SUCCESS(status)
    //
    return (Size < RequiredSize)? STATUS_BUFFER_OVERFLOW: STATUS_SUCCESS;
}

NTSTATUS
SmbQueryAddressInfo(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    PSMB_CONNECT        ConnectObject = NULL;
    PIO_STACK_LOCATION  IrpSp = NULL;
    NTSTATUS            status = STATUS_SUCCESS;
    DWORD               BytesCopied = 0;

    if (NULL == Irp->MdlAddress) {
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }
    SmbPrint(SMB_TRACE_CALL, ("Client needs changes to use IP6 address %d of %s\n",
                            __LINE__, __FILE__));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ConnectObject = SmbVerifyAndReferenceConnect(IrpSp->FileObject, SMB_REF_TDI);
    if (NULL == ConnectObject) {
        ASSERT(0);
        status = STATUS_NOT_SUPPORTED;
        goto cleanup;
    }

    status = SmbQueryPeerInfo(ConnectObject,
            (PNBT_ADDRESS_PAIR_INFO)MmGetMdlVirtualAddress(Irp->MdlAddress),
            MmGetMdlByteCount (Irp->MdlAddress),
            &BytesCopied
            );
    SmbDereferenceConnect(ConnectObject, SMB_REF_TDI);

cleanup:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = (status != STATUS_SUCCESS)? 0: BytesCopied;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return status;
}

NTSTATUS
SmbQueryConnectionInfo(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  IrpSp = NULL;
    PSMB_CONNECT        ConnectObject = NULL;
    PDEVICE_OBJECT      DeviceObject = NULL;
    PFILE_OBJECT        TcpConnObject = NULL;
    KIRQL               Irql = 0;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ConnectObject = SmbVerifyAndReferenceConnect(IrpSp->FileObject, SMB_REF_TDI);
    if (NULL == ConnectObject) {
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    if (NULL == ConnectObject->TcpContext) {
        TcpConnObject = NULL;
        DeviceObject = NULL;
    } else {
        TcpConnObject = ConnectObject->TcpContext->Connect.ConnectObject;
        ASSERT(TcpConnObject != NULL);
        ObReferenceObject(TcpConnObject);
        DeviceObject = IoGetRelatedDeviceObject(TcpConnObject);
    }
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    if (NULL == TcpConnObject) {
        SmbDereferenceConnect(ConnectObject, SMB_REF_TDI);
        status = STATUS_INVALID_PARAMETER;
        goto cleanup;
    }

    TdiBuildQueryInformation(
            Irp,
            DeviceObject,
            TcpConnObject,
            NULL, NULL,
            TDI_QUERY_CONNECTION_INFO,
            Irp->MdlAddress
            );

    status = IoCallDriver(DeviceObject, Irp);

    SmbDereferenceConnect(ConnectObject, SMB_REF_TDI);
    ObDereferenceObject(TcpConnObject);
    SmbPrint(SMB_TRACE_CALL, ("TCP returns 0x%08lx for TDI_QUERY_CONNECTION_INFO "
                    "%d of %s\n", status, __LINE__, __FILE__));
    return status;

cleanup:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return status;
}

NTSTATUS
SmbQueryInformation(
    PSMB_DEVICE Device,
    PIRP        Irp,
    BOOL        *bComplete
    )
{
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION   Query = NULL;
    PIO_STACK_LOCATION                      IrpSp = NULL;
    NTSTATUS                status = STATUS_NOT_SUPPORTED;

    *bComplete = TRUE;

    SmbPrint(SMB_TRACE_CALL, ("Entering SmbQueryInformation IRP %p\n", Irp));
    SmbTrace(SMB_TRACE_CALL, ("Entering SmbQueryInformation"));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    Query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)(&IrpSp->Parameters);

    switch(Query->QueryType) {
    case TDI_QUERY_BROADCAST_ADDRESS:
        //
        // Smb device doesn't support broadcast
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        ASSERT(0);
        break;

    case TDI_QUERY_PROVIDER_INFO:
        *bComplete = FALSE;
        return SmbQueryProviderInfo(Device, Irp);

    case TDI_QUERY_ADAPTER_STATUS:
        if (Query->RequestConnectionInformation && 
            Query->RequestConnectionInformation->RemoteAddress) {
            //
            // Smb device doesn't support quering remote machine status
            //
            status = STATUS_NOT_SUPPORTED;
            break;
        }
        *bComplete = FALSE;
        return SmbQueryAdapterStatus(Device, Irp);

    case TDI_QUERY_CONNECTION_INFO:
        *bComplete = FALSE;
        return SmbQueryConnectionInfo(Device, Irp);

    case TDI_QUERY_FIND_NAME:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case TDI_QUERY_ADDRESS_INFO:
        *bComplete = FALSE;
        return SmbQueryAddressInfo(Device, Irp);

    case TDI_QUERY_SESSION_STATUS:
    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    SmbPrint(SMB_TRACE_CALL, ("SmbQueryInformatoin: unsupported query type 0x%08lx\n",
                            Query->QueryType));
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
SmbSetEventHandler(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    PIO_STACK_LOCATION  IrpSp;
    NTSTATUS            status;
    KIRQL               Irql;
    PSMB_CLIENT_ELEMENT ClientObject;
    PTDI_REQUEST_KERNEL_SET_EVENT   TdiEvent;

    PAGED_CODE();
    SmbPrint(SMB_TRACE_CALL, ("Entering SmbSetEventHandler\n"));
    SmbTrace(SMB_TRACE_CALL, ("Entering SmbSetEventHandler"));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    ClientObject = SmbVerifyAndReferenceClient(IrpSp->FileObject, SMB_REF_TDI);
    if (NULL == ClientObject) {
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }

    TdiEvent = (PTDI_REQUEST_KERNEL_SET_EVENT)&IrpSp->Parameters;

    status = STATUS_SUCCESS;

    SMB_ACQUIRE_SPINLOCK(ClientObject, Irql);
    switch(TdiEvent->EventType) {
    case TDI_EVENT_CONNECT:
        ClientObject->evConnect = TdiEvent->EventHandler;
        ClientObject->ConEvContext = TdiEvent->EventContext;
        SmbPrint(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiConnectHandler\n"));
        SmbTrace(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiConnectHandler"));
        break;

    case TDI_EVENT_DISCONNECT:
        ClientObject->evDisconnect = TdiEvent->EventHandler;
        ClientObject->DiscEvContext = TdiEvent->EventContext;
        SmbPrint(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiDisconnectHandler\n"));
        SmbTrace(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiDisconnectHandler"));
        break;

    case TDI_EVENT_RECEIVE:
        ClientObject->evReceive = TdiEvent->EventHandler;
        ClientObject->RcvEvContext = TdiEvent->EventContext;
        SmbPrint(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiReceiveHandler\n"));
        SmbTrace(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiReceiveHandler"));
        break;

    case TDI_EVENT_ERROR:
        ClientObject->evError = TdiEvent->EventHandler;
        ClientObject->ErrorEvContext = TdiEvent->EventContext;
        SmbPrint(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiErrorHandler\n"));
        SmbTrace(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiErrorHandler"));
        break;

    case TDI_EVENT_RECEIVE_DATAGRAM:
        SmbPrint(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiReceiveDatagram (unsupported)\n"));
        SmbTrace(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiReceiveDatagram (unsupported)"));
        break;

    case TDI_EVENT_RECEIVE_EXPEDITED:
        SmbPrint(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiReceiveExpedited (unsupported)\n"));
        SmbTrace(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiReceiveExpedited (unsupported)"));
        break;

    case TDI_EVENT_SEND_POSSIBLE:
        SmbPrint(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiSendPossible (unsupported)\n"));
        SmbTrace(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set TdiSendPossible (unsupported)"));
        break;

    default:
        //status = STATUS_NOT_SUPPORTED;
        SmbPrint(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set unsupported TDI event handler %lx\n",
                    TdiEvent->EventType));
        SmbTrace(SMB_TRACE_CALL, ("SmbSetEventHandler: Client set upsupported TDI event handler %lx",
                    TdiEvent->EventType));
        ASSERT (0);
    }
    SMB_RELEASE_SPINLOCK(ClientObject, Irql);

    ASSERT(status != STATUS_PENDING);
    SmbDereferenceClient(ClientObject, SMB_REF_TDI);
    return status;
}

NTSTATUS
SmbSetInformation(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    PAGED_CODE();

    SmbPrint(SMB_TRACE_CALL, ("Entering SmbSetInformation\n"));
    SmbTrace(SMB_TRACE_CALL, ("Entering SmbSetInformation"));
    ASSERT(0);
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
SmbClientSetTcpInfo(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    PIO_STACK_LOCATION  IrpSp;
    PVOID               InfoBuffer;
    ULONG               InfoBufferLength;
    PSMB_CONNECT        ConnectObject;
    PFILE_OBJECT        TcpConnObject;
    KIRQL               Irql;
    NTSTATUS            status;

    if (Irp->RequestorMode != KernelMode) {
        return STATUS_ACCESS_DENIED;
    }

    // BREAK_WHEN_TAKE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    InfoBuffer       = Irp->AssociatedIrp.SystemBuffer;
    InfoBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    ConnectObject = SmbVerifyAndReferenceConnect(IrpSp->FileObject, SMB_REF_TDI);
    if (NULL == ConnectObject) {
        return STATUS_INVALID_PARAMETER;
    }

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    if (NULL == ConnectObject->TcpContext) {
        TcpConnObject = NULL;
    } else {
        TcpConnObject = ConnectObject->TcpContext->Connect.ConnectObject;
        ASSERT(TcpConnObject != NULL);
        ObReferenceObject(TcpConnObject);
    }
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
    SmbDereferenceConnect(ConnectObject, SMB_REF_TDI);

    if (NULL == TcpConnObject) {
        return STATUS_INVALID_PARAMETER;
    }

    status = SmbSendIoctl(
            TcpConnObject,
            IOCTL_TCP_SET_INFORMATION_EX,
            InfoBuffer,
            InfoBufferLength,
            NULL,
            NULL
            );
    if (!NT_SUCCESS(status)) {
        SmbPrint(SMB_TRACE_TCP, ("SmbClientSetTcpInfo: SetTcpInfo FAILed <0x%x> InfoBuffer=%p Length=%d\n",
            status, InfoBuffer, InfoBufferLength));
        SmbTrace(SMB_TRACE_TCP, ("FAILed %!status! InfoBuffer=%p Length=%d",
            status, InfoBuffer, InfoBufferLength));
    }

    ObDereferenceObject(TcpConnObject);
    return status;
}

NTSTATUS
IoctlSetIPv6Protection(
    PSMB_DEVICE pDeviceObject,
    PIRP pIrp,
    PIO_STACK_LOCATION  pIrpSp
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD dwInputBufferLength = 0;
    PNBSMB_IPV6_PROTECTION_PARAM pInput = NULL;
    ULONG uOldIPv6Protection = 0;

    dwInputBufferLength = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    pInput = pIrp->AssociatedIrp.SystemBuffer;
    if (dwInputBufferLength < sizeof(NBSMB_IPV6_PROTECTION_PARAM) || NULL == pInput) {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto error;
    }

    SmbTrace(SMB_TRACE_IOCTL, ("uIPv6Protection: input %d", pInput->uIPv6ProtectionLevel));

    if (SmbCfg.uIPv6Protection != pInput->uIPv6ProtectionLevel) {

        uOldIPv6Protection = SmbCfg.uIPv6Protection;
        SmbCfg.uIPv6Protection = pInput->uIPv6ProtectionLevel;

        ntStatus = SmbSetInboundIPv6Protection(pDeviceObject);
        SmbTrace(SMB_TRACE_IOCTL, ("Change IPv6 Protection for inbound return %!status!", ntStatus));

        if (ntStatus != STATUS_SUCCESS) {
            NTSTATUS LocalStatus = STATUS_SUCCESS;

            SmbCfg.uIPv6Protection = uOldIPv6Protection;
            LocalStatus = SmbSetInboundIPv6Protection(pDeviceObject);
            SmbTrace(SMB_TRACE_IOCTL, ("Restore to the old settings on failure. Restore status %!status!",
                            LocalStatus));
        }

    }

    if (ntStatus == STATUS_SUCCESS) {
        SmbCfg.bIPv6EnableOutboundGlobal = pInput->bIPv6EnableOutboundGlobal;
    }

error:
    SmbTrace(SMB_TRACE_IOCTL, ("%!status!", ntStatus));
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\driver2.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    Driver.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the
    SMB Transport and other routines that are specific to the NT implementation
    of a driver.

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "ip2netbios.h"

#include "driver2.tmh"

BOOL
IsNetBTSmbEnabled(
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
NotifyNetBT(
    IN DWORD dwNetBTAction
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SmbDriverEntry)
#pragma alloc_text(INIT, IsNetBTSmbEnabled)
#pragma alloc_text(PAGE, NotifyNetBT)
#pragma alloc_text(PAGE, SmbDispatchCleanup)
#pragma alloc_text(PAGE, SmbDispatchClose)
#pragma alloc_text(PAGE, SmbDispatchCreate)
#pragma alloc_text(PAGE, SmbDispatchDevCtrl)
#pragma alloc_text(PAGE, SmbDispatchPnP)
#pragma alloc_text(PAGE, SmbUnload)
#endif

NTSTATUS
NotifyNetBT(
    IN DWORD dwNetBTAction
    )
{
    UNICODE_STRING      uncWinsDeviceName = { 0 };
    PFILE_OBJECT        pWinsFileObject = NULL;
    PDEVICE_OBJECT      pWinsDeviceObject = NULL;
    PIRP                pIrp = NULL;
    IO_STATUS_BLOCK     IoStatusBlock = { 0 };
    KEVENT              Event = { 0 };
    NTSTATUS            status = STATUS_UNSUCCESSFUL;

    PAGED_CODE();

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Notify NetBT to destroy its NetbiosSmb
    //
    RtlInitUnicodeString(&uncWinsDeviceName, L"\\Device\\NetBt_Wins_Export");
    status = IoGetDeviceObjectPointer(
                    &uncWinsDeviceName,
                    SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
                    &pWinsFileObject,
                    &pWinsDeviceObject
                    );
    if (STATUS_SUCCESS != status) {
        goto error;
    }
    pIrp = IoBuildDeviceIoControlRequest (
                    IOCTL_NETBT_ENABLE_DISABLE_NETBIOS_SMB,
                    pWinsDeviceObject,
                    &dwNetBTAction,
                    sizeof(dwNetBTAction),
                    NULL,
                    0,
                    FALSE,
                    &Event,
                    &IoStatusBlock
                    );
    if (NULL == pIrp) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error;
    }

    status = IoCallDriver(pWinsDeviceObject, pIrp);
    if (STATUS_PENDING == status) {
        ASSERT (0);
        KeWaitForSingleObject(
                        &Event,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL
                        );
        status = IoStatusBlock.Status;
    }

error:
    if (pWinsFileObject != NULL) {
        ObDereferenceObject(pWinsFileObject);
        pWinsFileObject = NULL;
    }
    return status;
}

BOOL
IsNetBTSmbEnabled(
    IN PUNICODE_STRING RegistryPath
    )
{
    OBJECT_ATTRIBUTES   ObAttr = { 0 };
    NTSTATUS            status = STATUS_SUCCESS;
    HANDLE              hRootKey = NULL;
    HANDLE              hKey = NULL;
    UNICODE_STRING      uncParams = { 0 };
    BOOL                fUseSmbFromNetBT = FALSE;

    PAGED_CODE();

    //
    // Construct the registry path for the HKLM\System\CCS\Services
    //
    uncParams = RegistryPath[0];
    while(uncParams.Length > 0 && uncParams.Buffer[uncParams.Length/sizeof(WCHAR) - 1] != L'\\') {
        uncParams.Length -= sizeof(WCHAR);
    }
    uncParams.Length -= sizeof(WCHAR);

    InitializeObjectAttributes (
            &ObAttr,
            &uncParams,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );
    status = ZwOpenKey (&hRootKey, KEY_READ | KEY_WRITE, &ObAttr);
    BAIL_OUT_ON_ERROR(status);

    RtlInitUnicodeString(&uncParams, L"NetBT");
    InitializeObjectAttributes (
            &ObAttr,
            &uncParams,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            hRootKey,
            NULL
            );
    status = ZwOpenKey(&hKey, KEY_READ | KEY_WRITE, &ObAttr);
    ZwClose(hRootKey);
    hRootKey = hKey;
    hKey     = NULL;
    BAIL_OUT_ON_ERROR(status);

    fUseSmbFromNetBT = TRUE;
    //
    // From now on, an error means NetBT's Smb enabled
    //
    RtlInitUnicodeString(&uncParams, L"Parameters");
    InitializeObjectAttributes (
            &ObAttr,
            &uncParams,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            hRootKey,
            NULL
            );
    status = ZwOpenKey (&hKey, KEY_READ | KEY_WRITE, &ObAttr);
    ZwClose(hRootKey);
    hRootKey = hKey;
    hKey     = NULL;
    BAIL_OUT_ON_ERROR(status);

    fUseSmbFromNetBT = !(SmbReadULong(hRootKey, L"UseNewSmb", 0, 0));
    if (fUseSmbFromNetBT) {
        goto cleanup;
    }

    status = NotifyNetBT(NETBT_DISABLE_NETBIOS_SMB);
    status = STATUS_SUCCESS;

cleanup:
    if (hRootKey != NULL) {
        ZwClose(hRootKey);
    }
    if (hKey != NULL) {
        ZwClose(hKey);
    }
    return fUseSmbFromNetBT;
}

static KTIMER DelayedInitTimer;
static KDPC DelayedInitDpc;
static WORK_QUEUE_ITEM DelayedInitWorkItem;

static VOID
SmbDelayedInitRtn(
    PVOID pvUnused1
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    status = SmbInitTdi();
    ObDereferenceObject(&(SmbCfg.SmbDeviceObject->DeviceObject));
}

static VOID
SmbDelayedInitTimeoutRtn(
    IN PKDPC Dpc,
    IN PVOID Ctx,
    IN PVOID SystemArg1,
    IN PVOID SystemArg2
    )
{
    ExInitializeWorkItem(&DelayedInitWorkItem, SmbDelayedInitRtn, NULL);
    ExQueueWorkItem(&DelayedInitWorkItem, DelayedWorkQueue);
}

static NTSTATUS
SmbDelayedInitTdi(
    DWORD dwDelayedTime
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    LARGE_INTEGER DueTime = { 0 };

    KeInitializeTimer(&DelayedInitTimer);
    KeInitializeDpc(&DelayedInitDpc, SmbDelayedInitTimeoutRtn, NULL);
    DueTime.QuadPart = UInt32x32To64(dwDelayedTime,(LONG)10000);
    DueTime.QuadPart = -DueTime.QuadPart;
    ObReferenceObject(&(SmbCfg.SmbDeviceObject->DeviceObject));
    KeSetTimer(&DelayedInitTimer, DueTime, &DelayedInitDpc);
    return status;
}

NTSTATUS
SmbDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath,
    IN OUT PDEVICE_OBJECT *SmbDevice
    )

/*++

Routine Description:

    This is the initialization routine for the SMB device driver.
    This routine creates the device object for the SMB
    device and calls a routine to perform other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS            status;

    PAGED_CODE();

    RtlZeroMemory(&SmbCfg, sizeof(SmbCfg));
    if (SmbDevice) {
        *SmbDevice = NULL;
    }

    SmbCfg.DriverObject = DriverObject;
    InitializeListHead(&SmbCfg.IPDeviceList);
    InitializeListHead(&SmbCfg.PendingDeleteIPDeviceList);
    KeInitializeSpinLock(&SmbCfg.UsedIrpsLock);
    InitializeListHead(&SmbCfg.UsedIrps);
    KeInitializeSpinLock(&SmbCfg.Lock);

    SmbCfg.FspProcess =(PEPROCESS)PsGetCurrentProcess();

    status = ExInitializeResourceLite(&SmbCfg.Resource);
    BAIL_OUT_ON_ERROR(status);

    status = SmbInitRegistry(RegistryPath);
    BAIL_OUT_ON_ERROR(status);

#if DBG
    if (SmbReadULong(SmbCfg.ParametersKey, L"Break", 0, 0)) {
        DbgBreakPoint();
    }
    SmbCfg.DebugFlag = SmbReadULong(SmbCfg.ParametersKey, L"DebugFlag", 0, 0);
#endif

#ifdef STANDALONE_SMB
    if (IsNetBTSmbEnabled(RegistryPath)) {
        SmbPrint(SMB_TRACE_PNP, ("Abort the initialization of SMB since NetBT's Smb device is enabled\n"));
        SmbTrace(SMB_TRACE_PNP, ("Abort the initialization of SMB since NetBT's Smb device is enabled"));
        return STATUS_UNSUCCESSFUL;
    }
#endif

    SmbCfg.EnableNagling = SmbReadULong (
                    SmbCfg.ParametersKey,
                    SMB_REG_ENABLE_NAGLING,
                    0,                  // Disabled by default
                    0
                    );
    SmbCfg.DnsTimeout = SmbReadULong (
                    SmbCfg.ParametersKey,
                    SMB_REG_DNS_TIME_OUT,
                    SMB_REG_DNS_TIME_OUT_DEFAULT,
                    SMB_REG_DNS_TIME_OUT_MIN
                    );
    SmbCfg.DnsMaxResolver = SmbReadLong (
                    SmbCfg.ParametersKey,
                    SMB_REG_DNS_MAX_RESOLVER,
                    SMB_REG_DNS_RESOLVER_DEFAULT,
                    SMB_REG_DNS_RESOLVER_MIN
                    );
    if (SmbCfg.DnsMaxResolver > DNS_MAX_RESOLVER) {
        SmbCfg.DnsMaxResolver = DNS_MAX_RESOLVER;
    }

    SmbCfg.uIPv6Protection = SmbReadULong(
                    SmbCfg.ParametersKey,
                    SMB_REG_IPV6_PROTECTION,
                    SMB_REG_IPV6_PROTECTION_DEFAULT,
                    0
                    );

    SmbCfg.bIPv6EnableOutboundGlobal = SmbReadULong(
                    SmbCfg.ParametersKey,
                    SMB_REG_IPV6_ENABLE_OUTBOUND_GLOBAL,
                    FALSE,          // default value
                    0
                    );

#ifndef NO_LOOKASIDE_LIST
    //
    // Initialize Lookaside Lists
    //
    ExInitializeNPagedLookasideList(
            &SmbCfg.ConnectObjectPool,
            NULL,
            NULL,
            0,
            sizeof(SMB_CONNECT),
            CONNECT_OBJECT_POOL_TAG,
            0
            );
    SmbCfg.ConnectObjectPoolInitialized = TRUE;
    ExInitializeNPagedLookasideList(
            &SmbCfg.TcpContextPool,
            NULL,
            NULL,
            0,
            sizeof(SMB_TCP_CONTEXT),
            TCP_CONTEXT_POOL_TAG,
            0
            );
    SmbCfg.TcpContextPoolInitialized = TRUE;
#endif

#ifdef STANDALONE_SMB
    TdiInitialize();
#endif

    status = SmbCreateSmbDevice(&SmbCfg.SmbDeviceObject, SMB_TCP_PORT, SMB_ENDPOINT_NAME);
    BAIL_OUT_ON_ERROR(status);
    status = SmbInitDnsResolver();
    BAIL_OUT_ON_ERROR(status);
    status = SmbInitIPv6NetbiosMappingTable();
    BAIL_OUT_ON_ERROR(status);

#ifdef STANDALONE_SMB
    status = SmbDelayedInitTdi(1000);
    BAIL_OUT_ON_ERROR(status);
#endif

    if (SmbDevice) {
        *SmbDevice = &(SmbCfg.SmbDeviceObject->DeviceObject);
    }
    return (status);

cleanup:
    SmbUnload(DriverObject);
    return status;
}


//----------------------------------------------------------------------------
NTSTATUS
SmbDispatchCleanup(
    IN PSMB_DEVICE      Device,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This is the SMB driver's dispatch function for IRP_MJ_CLEANUP
    requests.

    This function is called when the last reference to the handle is closed.
    Hence, an NtClose() results in an IRP_MJ_CLEANUP first, and then an
    IRP_MJ_CLOSE.  This function runs down all activity on the object, and
    when the close comes in the object is actually deleted.

Arguments:

    device    - ptr to device object for target device
    pIrp       - ptr to I/O request packet

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  IrpSp;

    PAGED_CODE();

    if (SmbCfg.Unloading) {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(IrpSp->MajorFunction == IRP_MJ_CLEANUP);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
SmbDispatchClose(
    IN PSMB_DEVICE   Device,
    IN PIRP          Irp
    )

/*++

Routine Description:

    This is the SMB driver's dispatch function for IRP_MJ_CLOSE
    requests.  This is called after Cleanup (above) is called.

Arguments:

    device  - ptr to device object for target device
    pIrp     - ptr to I/O request packet

Return Value:

    an NT status code.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    PAGED_CODE();

    if (SmbCfg.Unloading) {
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto cleanup;
    }
    ASSERT(Device == SmbCfg.SmbDeviceObject);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(IrpSp->MajorFunction == IRP_MJ_CLOSE);

    switch(PtrToUlong(IrpSp->FileObject->FsContext2)) {
    case SMB_TDI_CONTROL:
        status = SmbCloseControl(Device, Irp);
        break;

    case SMB_TDI_CLIENT:
        status = SmbCloseClient(Device, Irp);
        break;

    case SMB_TDI_CONNECT:
        status = SmbCloseConnection(Device, Irp);
        break;

    default:
        status = STATUS_SUCCESS;
    }

    ASSERT(status != STATUS_PENDING);

cleanup:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return status;
}

PFILE_FULL_EA_INFORMATION
SmbFindInEA(
    IN PFILE_FULL_EA_INFORMATION    eabuf,
    IN PCHAR                        wanted
    );
#pragma alloc_text(PAGE, SmbFindInEA)

PFILE_FULL_EA_INFORMATION
SmbFindInEA(
    IN PFILE_FULL_EA_INFORMATION    eabuf,
    IN PCHAR                        wanted
    )
/*++

Routine Description:

    This function check for the "Wanted" string in the Ea structure and
    returns a pointer to the extended attribute structure
    representing the given extended attribute name.

Arguments:

Return Value:

    pointer to the extended attribute structure, or NULL if not found.

--*/

{
    PAGED_CODE();

    while(1) {
        if (strncmp(eabuf->EaName, wanted, eabuf->EaNameLength) == 0) {
            return eabuf;
        }

        if (0 == eabuf->NextEntryOffset) {
            return NULL;
        }
        eabuf = (PFILE_FULL_EA_INFORMATION) ((PUCHAR)eabuf + eabuf->NextEntryOffset);
    }
}


NTSTATUS
SmbDispatchCreate(
    IN PSMB_DEVICE      Device,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This is the SMB driver's dispatch function for IRP_MJ_CREATE
    requests.  It is called as a consequence of one of the following:

        a. TdiOpenConnection("\Device\Smb_Elnkii0"),
        b. TdiOpenAddress("\Device\Smb_Elnkii0"),

Arguments:

    Device - ptr to device object being opened
    pIrp    - ptr to I/O request packet
    pIrp->Status => return status
    pIrp->MajorFunction => IRP_MD_CREATE
    pIrp->MinorFunction => not used
    pIrp->FileObject    => ptr to file obj created by I/O system. SMB fills in FsContext
    pIrp->AssociatedIrp.SystemBuffer => ptr to EA buffer with address of obj to open(Netbios Name)
    pIrp->Parameters.Create.EaLength => length of buffer specifying the Xport Addr.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  IrpSp;
    PFILE_FULL_EA_INFORMATION   ea, wanted_ea;

    PAGED_CODE();

    if (SmbCfg.Unloading) {
        SmbPrint(SMB_TRACE_PNP, ("DispatchCreate: Smb is unloading\n"));
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto cleanup;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ASSERT(Device == SmbCfg.SmbDeviceObject);
    ASSERT(IrpSp->MajorFunction == IRP_MJ_CREATE);

    ea = Irp->AssociatedIrp.SystemBuffer;
    if (NULL == ea || KernelMode != Irp->RequestorMode) {
        status = SmbCreateControl(Device, Irp);
    } else if (NULL != (wanted_ea = SmbFindInEA(ea, TdiConnectionContext))) {
        // Not allow to pass in both a connection request and a transport address request
        ASSERT(!SmbFindInEA(ea, TdiTransportAddress));
        status = SmbCreateConnection(Device, Irp, wanted_ea);
    } else if (NULL != (wanted_ea = SmbFindInEA(ea, TdiTransportAddress))) {
        // Not allow to pass in both a connection request and a transport address request
        ASSERT(!SmbFindInEA(ea, TdiConnectionContext));
        status = SmbCreateClient(Device, Irp, wanted_ea);
    } else {
        status = STATUS_INVALID_EA_NAME;
    }

cleanup:
    ASSERT(status != STATUS_PENDING);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return(status);
}

NTSTATUS
SmbDispatchDevCtrl(
    IN PSMB_DEVICE      Device,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This is the SMB driver's dispatch function for all
    IRP_MJ_DEVICE_CONTROL requests.

Arguments:

    device - ptr to device object for target device
    pIrp    - ptr to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  IrpSp;

    if (SmbCfg.Unloading) {
        SmbPrint(SMB_TRACE_PNP, ("DispatchDevCtrl: Smb is unloading\n"));
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto cleanup;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    switch(IrpSp->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_SMB_START:
        SmbTrace(SMB_TRACE_IOCTL, ("IOCTL_SMB_START"));
        SmbPrint(SMB_TRACE_IOCTL, ("IOCTL_SMB_START\n"));
        status = SmbTdiRegister(Device);
        break;

    case IOCTL_SMB_STOP:
        SmbTrace(SMB_TRACE_IOCTL, ("IOCTL_SMB_STOP"));
        SmbPrint(SMB_TRACE_IOCTL, ("IOCTL_SMB_STOP\n"));
        status = SmbTdiDeregister(Device);
        break;

    case IOCTL_SMB_DNS:
        status = SmbNewResolver(Device, Irp);
        break;

    case IOCTL_SMB_ENABLE_NAGLING:
        SmbTrace(SMB_TRACE_IOCTL, ("IOCTL_SMB_ENABLE_NAGLING"));
        SmbPrint(SMB_TRACE_IOCTL, ("IOCTL_SMB_ENABLE_NAGLING\n"));
        SmbCfg.EnableNagling = TRUE;
        status = STATUS_SUCCESS;
        TODO("Turn on nagling for each connection in the pool");
        break;

    case IOCTL_SMB_DISABLE_NAGLING:
        SmbTrace(SMB_TRACE_IOCTL, ("IOCTL_SMB_DISABLE_NAGLING"));
        SmbPrint(SMB_TRACE_IOCTL, ("IOCTL_SMB_DISABLE_NAGLING\n"));
        SmbCfg.EnableNagling = FALSE;
        status = STATUS_SUCCESS;
        TODO("Turn off nagling for each connection in the pool");
        break;

    case IOCTL_SMB_SET_IPV6_PROTECTION_LEVEL:
        //
        // Set IPv6 Protection level
        //
        status = IoctlSetIPv6Protection(Device, Irp, IrpSp);
        break;

    case IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER:
        SmbTrace(SMB_TRACE_IOCTL, ("IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER"));
        SmbPrint(SMB_TRACE_IOCTL, ("IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER\n"));
        if (Irp->RequestorMode != KernelMode) {
            //
            // There is no point for usermode application to query FastSend
            //
            status = STATUS_ACCESS_DENIED;
            break;
        }

        (PVOID)(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer) = (PVOID)SmbSend;
        status = STATUS_SUCCESS;
        break;

        //
        // Legacy NetBT stuff
        // The following Ioctl is used by the Rdr/Srv to add/remove addresses from the SmbDevice
        //
    case IOCTL_NETBT_SET_SMBDEVICE_BIND_INFO:
        status = SmbSetBindingInfo(Device, Irp);
        break;

        //
        // Used by Srv service
        //
    case IOCTL_NETBT_SET_TCP_CONNECTION_INFO:
        status = SmbClientSetTcpInfo(Device, Irp);
        break;

        //
        // Who is going to use this?
        //
    case IOCTL_NETBT_GET_CONNECTIONS:
        status = STATUS_NOT_SUPPORTED;
        break;

    default:
        status = STATUS_NOT_SUPPORTED;
        break;
    }

cleanup:
    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    }
    return status;
}

NTSTATUS
SmbDispatchInternalCtrl(
    IN PSMB_DEVICE      Device,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This is the driver's dispatch function for all
    IRP_MJ_INTERNAL_DEVICE_CONTROL requests.

Arguments:

    device - ptr to device object for target device
    pIrp    - ptr to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
    PIO_STACK_LOCATION  IrpSp = NULL;
    BOOL                bShouldCompleteIrp = TRUE;

    if (SmbCfg.Unloading) {
        SmbPrint(SMB_TRACE_PNP, ("DispatchIntDevCtrl: Smb is unloading\n"));
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto cleanup;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch(IrpSp->MinorFunction) {
    case TDI_ACCEPT:
        status = SmbAccept(Device, Irp);
        break;
    case TDI_LISTEN:
        status = SmbListen(Device, Irp);
        break;
    case TDI_ASSOCIATE_ADDRESS:
        status = SmbAssociateAddress(Device, Irp);
        break;
    case TDI_DISASSOCIATE_ADDRESS:
        status = SmbDisAssociateAddress(Device, Irp);
        break;
    case TDI_CONNECT:
        status = SmbConnect(Device, Irp);
        break;
    case TDI_DISCONNECT:
        status = SmbDisconnect(Device, Irp);
        break;
    case TDI_SEND:
        status = SmbSend(Device, Irp);
        break;
    case TDI_RECEIVE:
        status = SmbReceive(Device, Irp);
        break;
    case TDI_SEND_DATAGRAM:
        status = SmbSendDatagram(Device, Irp);
        break;
    case TDI_RECEIVE_DATAGRAM:
        status = SmbReceiveDatagram(Device, Irp);
        break;
    case TDI_QUERY_INFORMATION:
        status = SmbQueryInformation(Device, Irp, &bShouldCompleteIrp);
        break;
    case TDI_SET_EVENT_HANDLER:
        status = SmbSetEventHandler(Device, Irp);
        break;
    case TDI_SET_INFORMATION:
        status = SmbSetInformation(Device, Irp);
        break;

#if DBG
        //
        // 0x7f is a request by the Redir to put a "magic bullet" out
        // on the wire, to trigger the Network General Sniffer.
        //
    case 0x7f:
#endif
    default:
        status = STATUS_NOT_SUPPORTED;
        break;
    }

cleanup:
    if (status != STATUS_PENDING && bShouldCompleteIrp) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    } else {
        //
        // Don't mark IRP pending here because it could have been completed.
        //
    }
    return(status);
} // SmbDispatchInternalCtrl


NTSTATUS
SmbQueryTargetDeviceRelationForConnection(
    PSMB_CONNECT    ConnectObject,
    PIRP            Irp
    )
{
    PFILE_OBJECT        TcpFileObject = NULL;
    PDEVICE_OBJECT      TcpDeviceObject = NULL;
    PIO_STACK_LOCATION  IrpSp = NULL, IrpSpNext = NULL;
    KIRQL               Irql;
    NTSTATUS            status = STATUS_CONNECTION_INVALID;

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    if (NULL == ConnectObject->TcpContext) {
        TcpFileObject = NULL;
    } else {
        TcpFileObject = ConnectObject->TcpContext->Connect.ConnectObject;
        ASSERT(TcpFileObject != NULL);

        TcpDeviceObject = IoGetRelatedDeviceObject (TcpFileObject);
        if (NULL == TcpDeviceObject) {
            TcpFileObject = NULL;
        } else {
            ObReferenceObject(TcpFileObject);
        }
    }
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
    SmbDereferenceConnect(ConnectObject, SMB_REF_TDI);

    if (NULL == TcpFileObject) {
        status = STATUS_CONNECTION_INVALID;
        goto cleanup;
    }

    //
    // Simply pass the Irp on by to the Transport, and let it
    // fill in the info
    //
    IrpSp     = IoGetCurrentIrpStackLocation(Irp);
    IrpSpNext = IoGetNextIrpStackLocation (Irp);
    *IrpSpNext = *IrpSp;

    IoSetCompletionRoutine (Irp, NULL, NULL, FALSE, FALSE, FALSE);
    IrpSpNext->FileObject = TcpFileObject;
    IrpSpNext->DeviceObject = TcpDeviceObject;

    status = IoCallDriver(TcpDeviceObject, Irp);
    ObDereferenceObject(TcpFileObject);

    //
    // Irp could be completed. Don't access it anymore
    //

    return status;

cleanup:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return status;
}

NTSTATUS
SmbDispatchPnP(
    IN PSMB_DEVICE  Device,
    IN PIRP         Irp
    )
{
    PIO_STACK_LOCATION  IrpSp = NULL;
    PSMB_CLIENT_ELEMENT ClientObject = NULL;
    PSMB_CONNECT        ConnectObject = NULL;
    NTSTATUS            status = STATUS_INVALID_DEVICE_REQUEST;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MinorFunction) {
    case IRP_MN_QUERY_DEVICE_RELATIONS:
        if (IrpSp->Parameters.QueryDeviceRelations.Type==TargetDeviceRelation) {

            ConnectObject = SmbVerifyAndReferenceConnect(IrpSp->FileObject, SMB_REF_TDI);
            ClientObject  = SmbVerifyAndReferenceClient(IrpSp->FileObject, SMB_REF_TDI);

            if (ConnectObject != NULL) {

                ASSERT(ClientObject == NULL);
                return SmbQueryTargetDeviceRelationForConnection(ConnectObject, Irp);

            } else if (ClientObject != NULL) {

                SmbDereferenceClient(ClientObject, SMB_REF_TDI);
                status = STATUS_NOT_SUPPORTED;

            } else {

                ASSERT (0);

            }
        }

        break;

    default:
        break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return status;
}


VOID
SmbUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the SMB driver's dispatch function for Unload requests

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None

--*/

{
    PAGED_CODE();

    SmbCfg.Unloading = TRUE;

    if (NULL == SmbCfg.DriverObject) {
        return;
    }

#ifdef STANDALONE_SMB
    SmbShutdownTdi();
#endif

    SmbShutdownRegistry();

    SmbShutdownDnsResolver();
    SmbShutdownIPv6NetbiosMappingTable();

    SmbDestroySmbDevice(SmbCfg.SmbDeviceObject);
    SmbCfg.SmbDeviceObject = NULL;

#ifndef NO_LOOKASIDE_LIST
    if (SmbCfg.ConnectObjectPoolInitialized) {
        ExDeleteNPagedLookasideList(&SmbCfg.ConnectObjectPool);
        SmbCfg.ConnectObjectPoolInitialized = FALSE;
    }
    if (SmbCfg.TcpContextPoolInitialized) {
        ExDeleteNPagedLookasideList(&SmbCfg.TcpContextPool);
        SmbCfg.TcpContextPoolInitialized = FALSE;
    }
#endif

    SmbCfg.DriverObject = NULL;
    ExDeleteResourceLite(&SmbCfg.Resource);
    NotifyNetBT(NETBT_RESTORE_NETBIOS_SMB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\hash.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Abstract Data Type: Hash

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "hash.h"

typedef struct SMB_HASH_TABLE {
    KSPIN_LOCK      Lock;
    DWORD           NumberOfBuckets;
    PSMB_HASH       HashFunc;       // Hash function
    PSMB_HASH_CMP   CmpFunc;        // Compare function
    PSMB_HASH_DEL   DelFunc;        // Delete function: called before an entry is removed from the hash table
    PSMB_HASH_ADD   AddFunc;        // Add function: called before an entry is added into the hash table
    PSMB_HASH_REFERENCE     RefFunc;
    PSMB_HASH_DEREFERENCE   DerefFunc;
    PSMB_HASH_GET_KEY GetKeyFunc;
    LIST_ENTRY      Buckets[0];
} SMB_HASH_TABLE, *PSMB_HASH_TABLE;

VOID __inline
SmbLockHashTable(
    PSMB_HASH_TABLE HashTbl,
    KIRQL           *Irql
    )
{
    KeAcquireSpinLock(&HashTbl->Lock, Irql);
}


VOID __inline
SmbUnlockHashTable(
    PSMB_HASH_TABLE HashTbl,
    KIRQL           Irql
    )
{
    KeReleaseSpinLock(&HashTbl->Lock, Irql);
}


PSMB_HASH_TABLE
SmbCreateHashTable(
    DWORD           NumberOfBuckets,
    PSMB_HASH       HashFunc,
    PSMB_HASH_GET_KEY   GetKeyFunc,
    PSMB_HASH_CMP   CmpFunc,
    PSMB_HASH_ADD   AddFunc,                // optional
    PSMB_HASH_DEL   DelFunc,                // optional
    PSMB_HASH_REFERENCE     RefFunc,        // optional
    PSMB_HASH_DEREFERENCE   DerefFunc       // optional
    )
{
    PSMB_HASH_TABLE HashTbl = NULL;
    DWORD           i, Size = 0;

    //
    // To avoid overflow below, set a upperbound on the number of buckets
    // 65536 is large enough!!!
    //
    if (0 == NumberOfBuckets || NumberOfBuckets >= 0x10000) {
        goto error;
    }

    if (NULL == HashFunc || NULL == CmpFunc || NULL == GetKeyFunc) {
        goto error;
    }

    //
    // Allocate memory
    //
    Size = sizeof(SMB_HASH_TABLE) + sizeof(LIST_ENTRY)*NumberOfBuckets;
    HashTbl = ExAllocatePoolWithTag(NonPagedPool, Size, 'HBMS');
    if (NULL == HashTbl) {
        goto error;
    }
    RtlZeroMemory(HashTbl, Size);

    //
    // Initialize
    //
    KeInitializeSpinLock(&HashTbl->Lock);
    HashTbl->NumberOfBuckets = NumberOfBuckets;
    HashTbl->HashFunc = HashFunc;
    HashTbl->CmpFunc  = CmpFunc;
    HashTbl->GetKeyFunc = GetKeyFunc;
    HashTbl->DelFunc  = DelFunc;
    HashTbl->AddFunc  = AddFunc;
    HashTbl->RefFunc  = RefFunc;
    HashTbl->DerefFunc  = DerefFunc;
    for (i = 0; i < NumberOfBuckets; i++) {
        InitializeListHead(&HashTbl->Buckets[i]);
    }

error:
    return HashTbl;
}

VOID
SmbDestroyHashTable(
    PSMB_HASH_TABLE HashTbl
    )
{
    KIRQL   Irql = 0;
    DWORD   i = 0;
    PLIST_ENTRY entry = NULL;

    if (NULL == HashTbl) {
        goto error;
    }

    for (i = 0; i < HashTbl->NumberOfBuckets; i++) {
        SmbLockHashTable(HashTbl, &Irql);
        while(!IsListEmpty(&HashTbl->Buckets[i])) {
            entry = RemoveHeadList(&HashTbl->Buckets[i]);
            InitializeListHead(entry);
            SmbUnlockHashTable(HashTbl, Irql);
            if (HashTbl->DelFunc) {
                HashTbl->DelFunc(entry);
            }
            SmbLockHashTable(HashTbl, &Irql);
        }
        SmbUnlockHashTable(HashTbl, Irql);
    }
    ExFreePool(HashTbl);

error:
    return;
}

PLIST_ENTRY
SmbLookupLockedHashTable(
    PSMB_HASH_TABLE HashTbl,
    PVOID           Key,
    DWORD           Hash
    )
/*++

Routine Description:

    Look up hash table
    Note: spinlock should held

Arguments:

Return Value:
    NULL    Not found

--*/
{
    PLIST_ENTRY pHead = NULL, FoundEntry = NULL;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    ASSERT (Hash < HashTbl->NumberOfBuckets);
    pHead = HashTbl->Buckets[Hash].Flink;
    while(pHead != &HashTbl->Buckets[Hash]) {
        if (HashTbl->CmpFunc(pHead, Key) == 0) {
            FoundEntry = pHead;
            break;
        }
        pHead = pHead->Flink;
    }

    return FoundEntry;
}

PLIST_ENTRY
SmbLookupHashTable(
    PSMB_HASH_TABLE HashTbl,
    PVOID           Key
    )
{
    DWORD       dwHash = 0;
    KIRQL       Irql = 0;
    PLIST_ENTRY FoundEntry = NULL;

    dwHash = HashTbl->HashFunc(Key) % HashTbl->NumberOfBuckets;

    SmbLockHashTable(HashTbl, &Irql);
    FoundEntry = SmbLookupLockedHashTable(HashTbl, Key, dwHash);
    SmbUnlockHashTable(HashTbl, Irql);

    return FoundEntry;
}

PLIST_ENTRY
SmbLookupHashTableAndReference(
    PSMB_HASH_TABLE HashTbl,
    PVOID           Key
    )
{
    DWORD       dwHash = 0;
    KIRQL       Irql = 0;
    PLIST_ENTRY FoundEntry = NULL;

    if (NULL == HashTbl->RefFunc) {
        return NULL;
    }
    dwHash = HashTbl->HashFunc(Key) % HashTbl->NumberOfBuckets;

    SmbLockHashTable(HashTbl, &Irql);
    FoundEntry = SmbLookupLockedHashTable(HashTbl, Key, dwHash);
    if (FoundEntry) {
        LONG    RefCount = 0;

        RefCount = HashTbl->RefFunc(FoundEntry);
        ASSERT(RefCount > 1);
    }
    SmbUnlockHashTable(HashTbl, Irql);

    return FoundEntry;
}

PLIST_ENTRY
SmbAddToHashTable(
    PSMB_HASH_TABLE HashTbl,
    PLIST_ENTRY     Entry
    )
/*++

Routine Description:

    Add the entry into hash table if it isn't in the hash table
    Otherwise, increase the RefCount of the existing entry if RefFunc is set

Arguments:

Return Value:

--*/
{
    DWORD       dwHash = 0;
    KIRQL       Irql = 0;
    PVOID       Key = NULL;
    PLIST_ENTRY FoundEntry = NULL;

    Key    = HashTbl->GetKeyFunc(Entry);
    dwHash = HashTbl->HashFunc(Key) % HashTbl->NumberOfBuckets;

    SmbLockHashTable(HashTbl, &Irql);
    FoundEntry = SmbLookupLockedHashTable(HashTbl, Key, dwHash);
    if (NULL == FoundEntry) {
        if (HashTbl->AddFunc) {
            HashTbl->AddFunc(Entry);
        }
        InsertTailList(&HashTbl->Buckets[dwHash], Entry);
        FoundEntry = Entry;
    } else {
        if (HashTbl->RefFunc) {
            HashTbl->RefFunc(FoundEntry);
        }
    }
    SmbUnlockHashTable(HashTbl, Irql);
    return FoundEntry;
}

PLIST_ENTRY
SmbRemoveFromHashTable(
    PSMB_HASH_TABLE HashTbl,
    PLIST_ENTRY     Key
    )
/*++

Routine Description:

    Decrement the refcount of the entry. If the refoucne is zero, delete it.

Arguments:

Return Value:

--*/
{
    DWORD       dwHash = 0;
    KIRQL       Irql = 0;
    PLIST_ENTRY FoundEntry = NULL;

    dwHash = HashTbl->HashFunc(Key) % HashTbl->NumberOfBuckets;

    SmbLockHashTable(HashTbl, &Irql);
    FoundEntry = SmbLookupLockedHashTable(HashTbl, Key, dwHash);
    if (FoundEntry) {
        if (HashTbl->DerefFunc) {
            LONG    RefCount;

            RefCount = HashTbl->DerefFunc(FoundEntry);
            ASSERT(RefCount >= 0);
            if (RefCount) {
                FoundEntry = NULL;
            }
        }

        if (FoundEntry) {
            RemoveEntryList(FoundEntry);
            InitializeListHead(FoundEntry);
            if (HashTbl->DelFunc) {
                HashTbl->DelFunc(FoundEntry);
            }
        }
    }
    SmbUnlockHashTable(HashTbl, Irql);

    return FoundEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\init.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Initialization

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "init.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SmbInitRegistry)
#pragma alloc_text(PAGE, SmbShutdownRegistry)
#pragma alloc_text(PAGE, SmbInitTdi)
#pragma alloc_text(PAGE, SmbShutdownTdi)
#pragma alloc_text(INIT, SmbCreateSmbDevice)
#pragma alloc_text(PAGE, SmbDestroySmbDevice)
#endif

NTSTATUS
SmbInitRegistry(
    IN PUNICODE_STRING  RegistryPath
    )
{
    OBJECT_ATTRIBUTES   ObAttr;
    NTSTATUS            status;
    HANDLE              hKey = NULL;
    UNICODE_STRING      uncParams;
    ULONG               Disposition;

    PAGED_CODE();

    InitializeObjectAttributes (
            &ObAttr,
            RegistryPath,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );
    status = ZwOpenKey (
            &hKey,
            KEY_READ | KEY_WRITE,
            &ObAttr
            );
    BAIL_OUT_ON_ERROR(status);

    RtlInitUnicodeString(&uncParams, L"Parameters");
    InitializeObjectAttributes (
            &ObAttr,
            &uncParams,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            hKey,
            NULL
            );
    status = ZwCreateKey(
            &SmbCfg.ParametersKey,
            KEY_READ | KEY_WRITE,
            &ObAttr,
            0,
            NULL,
            0,
            &Disposition
            );
    BAIL_OUT_ON_ERROR(status);

    RtlInitUnicodeString(&uncParams, L"Linkage");
    InitializeObjectAttributes (
            &ObAttr,
            &uncParams,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            hKey,
            NULL
            );
    status = ZwCreateKey(
            &SmbCfg.LinkageKey,
            KEY_READ | KEY_WRITE,
            &ObAttr,
            0,
            NULL,
            0,
            &Disposition
            );
    BAIL_OUT_ON_ERROR(status);
    ZwClose(hKey);
    hKey = NULL;
    return status;

cleanup:
    if (SmbCfg.LinkageKey) {
        ZwClose(SmbCfg.LinkageKey);
        SmbCfg.LinkageKey = NULL;
    }
    if (SmbCfg.ParametersKey) {
        ZwClose(SmbCfg.ParametersKey);
        SmbCfg.ParametersKey = NULL;
    }
    if (hKey) {
        ZwClose(hKey);
    }
    SmbTrace(SMB_TRACE_ERRORS, ("returns %!status!", status));
    return status;
}

VOID
SmbShutdownRegistry(
    VOID
    )
{
    PAGED_CODE();

    if (SmbCfg.ParametersKey) {
        ZwClose(SmbCfg.ParametersKey);
        SmbCfg.ParametersKey = NULL;
    }
    if (SmbCfg.LinkageKey) {
        ZwClose(SmbCfg.LinkageKey);
        SmbCfg.LinkageKey = NULL;
    }
}

#ifdef STANDALONE_SMB
NTSTATUS
SmbInitTdi(
    VOID
    )
{
    UNICODE_STRING              ucSmbClientName;
    UNICODE_STRING              ucSmbProviderName;
    TDI_CLIENT_INTERFACE_INFO   TdiClientInterface;
    NTSTATUS                    status;

    PAGED_CODE();

    RtlInitUnicodeString(&ucSmbProviderName, WC_SMB_TDI_PROVIDER_NAME);
    status = TdiRegisterProvider (&ucSmbProviderName, &SmbCfg.TdiProviderHandle);
    if (NT_SUCCESS (status)) {
        //
        // Register our Handlers with TDI
        //
        RtlInitUnicodeString(&ucSmbClientName, WC_SMB_TDI_CLIENT_NAME);
        RtlZeroMemory(&TdiClientInterface, sizeof(TdiClientInterface));

        TdiClientInterface.MajorTdiVersion      = MAJOR_TDI_VERSION;
        TdiClientInterface.MinorTdiVersion      = MINOR_TDI_VERSION;
        TdiClientInterface.ClientName           = &ucSmbClientName;
        TdiClientInterface.AddAddressHandlerV2  = SmbAddressArrival;
        TdiClientInterface.DelAddressHandlerV2  = SmbAddressDeletion;
        TdiClientInterface.BindingHandler       = SmbBindHandler;
        TdiClientInterface.PnPPowerHandler      = NULL;

        status = TdiRegisterPnPHandlers (&TdiClientInterface, sizeof(TdiClientInterface), &SmbCfg.TdiClientHandle);
        if (!NT_SUCCESS (status)) {
            TdiDeregisterProvider (SmbCfg.TdiProviderHandle);
            SmbCfg.TdiProviderHandle = NULL;
        }
    }

    return status;
}

VOID
SmbShutdownTdi(
    VOID
    )
{
    NTSTATUS    status;

    PAGED_CODE();

    if (SmbCfg.TdiClientHandle) {
        status = TdiDeregisterPnPHandlers(SmbCfg.TdiClientHandle);
        SmbCfg.TdiClientHandle = NULL;
    }
    if (SmbCfg.TdiProviderHandle) {
        status = TdiDeregisterProvider(SmbCfg.TdiProviderHandle);
        SmbCfg.TdiProviderHandle = NULL;
    }
}
#else
VOID
SmbSetTdiHandles(
    HANDLE  ProviderHandle,
    HANDLE  ClientHandle
    )
{
    SmbCfg.TdiClientHandle   = ClientHandle;
    SmbCfg.TdiProviderHandle = ProviderHandle;
}
#endif

NTSTATUS
SmbBuildDeviceAcl(
    OUT PACL * DeviceAcl
    )
/*++

Routine Description:

    (Lifted from SMB - SmbBuildDeviceAcl)
    This routine builds an ACL which gives Administrators, LocalService and NetworkService
    principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/
{
    PGENERIC_MAPPING GenericMapping;
    PSID AdminsSid, ServiceSid, NetworkSid;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&AccessMask, GenericMapping);

    AdminsSid = SeExports->SeAliasAdminsSid;
    ServiceSid = SeExports->SeLocalServiceSid;
    NetworkSid = SeExports->SeNetworkServiceSid;

    AclLength = sizeof(ACL) +
        3 * sizeof(ACCESS_ALLOWED_ACE) +
        RtlLengthSid(AdminsSid) +
        RtlLengthSid(ServiceSid) +
        RtlLengthSid(NetworkSid) -
        3 * sizeof(ULONG);

    NewAcl = ExAllocatePoolWithTag(PagedPool, AclLength, 'ABMS');

    if (NewAcl == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION);

    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }
    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    AdminsSid
                                    );

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }

    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    ServiceSid
                                    );

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }

    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    NetworkSid
                                    );

    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return (Status);
    }

    *DeviceAcl = NewAcl;

    return (STATUS_SUCCESS);
}

NTSTATUS
SmbCreateAdminSecurityDescriptor(PDEVICE_OBJECT dev)
/*++

Routine Description:

    (Lifted from NETBT - SmbCreateAdminSecurityDescriptor)
    This routine creates a security descriptor which gives access
    only to Administrtors and LocalService. This descriptor is used
    to access check raw endpoint opens and exclisive access to transport
    addresses.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL rawAcl = NULL;
    NTSTATUS status;
    CHAR buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR localSecurityDescriptor = (PSECURITY_DESCRIPTOR) buffer;
    SECURITY_INFORMATION securityInformation = DACL_SECURITY_INFORMATION;

    //
    // Build a local security descriptor with an ACL giving only
    // administrators and service access.
    //
    status = SmbBuildDeviceAcl(&rawAcl);

    if (!NT_SUCCESS(status)) {
        SmbPrint(SMB_TRACE_PNP, ("SMB: Unable to create Raw ACL, error: 0x%08lx\n", status));
        return (status);
    }

    (VOID) RtlCreateSecurityDescriptor(
                                       localSecurityDescriptor,
                                       SECURITY_DESCRIPTOR_REVISION
                                       );

    (VOID) RtlSetDaclSecurityDescriptor(
                                        localSecurityDescriptor,
                                        TRUE,
                                        rawAcl,
                                        FALSE
                                        );

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(
                                         NULL,
                                         &securityInformation,
                                         localSecurityDescriptor,
                                         &dev->SecurityDescriptor,
                                         PagedPool,
                                         IoGetFileObjectGenericMapping()
                                         );

    if (!NT_SUCCESS(status)) {
        SmbPrint(SMB_TRACE_PNP, ("SMB: SeSetSecurity failed: 0x%08lx\n", status));
    }

    ExFreePool(rawAcl);
    return (status);
}


NTSTATUS
SmbCreateSmbDevice(
    PSMB_DEVICE     *ppDevice,
    USHORT          Port,
    UCHAR           EndpointName[NETBIOS_NAME_SIZE]
    )
{
    PSMB_DEVICE     DeviceObject;
    NTSTATUS        status;
    UNICODE_STRING  ExportName, ucName;

    DeviceObject = NULL;
    *ppDevice = NULL;

    RtlInitUnicodeString(&ExportName, DD_SMB6_EXPORT_NAME);
    status = IoCreateDevice(
            SmbCfg.DriverObject,
            sizeof(SMB_DEVICE) - sizeof(DEVICE_OBJECT),
            &ExportName,
            FILE_DEVICE_NETWORK,
            FILE_DEVICE_SECURE_OPEN,
            FALSE,
            (PDEVICE_OBJECT*)&DeviceObject
            );
    BAIL_OUT_ON_ERROR(status);

    DeviceObject->Tag = TAG_SMB6_DEVICE;
    KeInitializeSpinLock(&DeviceObject->Lock);
    InitializeListHead(&DeviceObject->UnassociatedConnectionList);
    InitializeListHead(&DeviceObject->ClientList);
    InitializeListHead(&DeviceObject->PendingDeleteConnectionList);
    InitializeListHead(&DeviceObject->PendingDeleteClientList);

    DeviceObject->ClientBinding = NULL;
    DeviceObject->ServerBinding = NULL;

    //
    // initialization for FIN attack protection
    //
    DeviceObject->FinAttackProtectionMode = FALSE;
    DeviceObject->LeaveFAPM = SmbReadLong (SmbCfg.ParametersKey, SMB_REG_LEAVE_FAPM, 50, 5);
    DeviceObject->EnterFAPM = SmbReadLong (SmbCfg.ParametersKey, SMB_REG_ENTER_FAPM,
                                                400, DeviceObject->LeaveFAPM + 50);
    ASSERT(DeviceObject->EnterFAPM > DeviceObject->LeaveFAPM);
    if (DeviceObject->LeaveFAPM >= DeviceObject->EnterFAPM) {
        DeviceObject->EnterFAPM = 2 * DeviceObject->LeaveFAPM;
    }
    if (DeviceObject->LeaveFAPM >= DeviceObject->EnterFAPM) {
        //
        // This means overflow above
        //
        DeviceObject->LeaveFAPM = 50;
        DeviceObject->EnterFAPM = 400;
    }

    //
    // initialization for synch attack protection
    //
    DeviceObject->MaxBackLog = SmbReadLong(SmbCfg.ParametersKey, L"MaxBackLog", 1000, 100);

    InitializeListHead(&DeviceObject->DelayedDisconnectList);

    InitializeListHead(&DeviceObject->DelayedDisconnectList);
    InitializeListHead(&DeviceObject->PendingDisconnectList);
    DeviceObject->PendingDisconnectListNumber = 0;
    KeInitializeEvent(&DeviceObject->PendingDisconnectListEmptyEvent,
                        NotificationEvent, TRUE);
    DeviceObject->DisconnectWorkerRunning = FALSE;

    DeviceObject->ConnectionPoolWorkerQueued = FALSE;

    DeviceObject->SmbServer = NULL;
    RtlCopyMemory(DeviceObject->EndpointName, EndpointName, NETBIOS_NAME_SIZE);
    ASSERT(DeviceObject->EndpointName[NETBIOS_NAME_SIZE-1] == 0x20);

    DeviceObject->Port = Port;
    SmbCfg.Tcp4Available = FALSE;
    SmbCfg.Tcp6Available = FALSE;

    SmbCreateAdminSecurityDescriptor(&DeviceObject->DeviceObject);

    *ppDevice = DeviceObject;
    return status;

cleanup:
    if (DeviceObject) {
        if (SmbCfg.Tcp4Available) {
            SmbShutdownTCP(&DeviceObject->Tcp4);
            SmbCfg.Tcp4Available = FALSE;
        }
        if (SmbCfg.Tcp6Available) {
            SmbShutdownTCP(&DeviceObject->Tcp6);
            SmbCfg.Tcp6Available = FALSE;
        }
        IoDeleteDevice((PDEVICE_OBJECT)DeviceObject);
    }
    return status;
}

NTSTATUS
SmbDestroySmbDevice(
    PSMB_DEVICE     pDevice
    )
{
    NTSTATUS    status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(SmbCfg.Unloading);

    if (NULL == pDevice) {
        return STATUS_SUCCESS;
    }

    SmbTdiDeregister(pDevice);

    status = KeWaitForSingleObject(
            &pDevice->PendingDisconnectListEmptyEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
    ASSERT(status == STATUS_WAIT_0);

    ASSERT(IsListEmpty(&pDevice->DelayedDisconnectList));
    ASSERT(IsListEmpty(&pDevice->PendingDisconnectList) && pDevice->PendingDisconnectListNumber == 0);
    ASSERT(IsListEmpty(&pDevice->PendingDeleteConnectionList));
    ASSERT(IsListEmpty(&pDevice->PendingDeleteClientList));

    if (SmbCfg.Tcp4Available) {
        status = SmbShutdownTCP(&pDevice->Tcp4);
        ASSERT(status == STATUS_SUCCESS);
        SmbCfg.Tcp4Available = FALSE;
    }
    if (SmbCfg.Tcp6Available) {
        status = SmbShutdownTCP(&pDevice->Tcp6);
        ASSERT(status == STATUS_SUCCESS);
        SmbCfg.Tcp6Available = FALSE;
    }
    ASSERT(status == STATUS_SUCCESS);

    SmbShutdownPnP();

    if (pDevice->ClientBinding) {
        ExFreePool(pDevice->ClientBinding);
        pDevice->ClientBinding = NULL;
    }
    if (pDevice->ServerBinding) {
        ExFreePool(pDevice->ServerBinding);
        pDevice->ServerBinding = NULL;
    }
    IoDeleteDevice((PDEVICE_OBJECT)pDevice);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\ntpnp.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ntpnp.c

Abstract:

    Plug & Play

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "ntpnp.tmh"

#define TL_INSTANCE 0

ULONG
SmbGetInterfaceIndex(
    IN PUNICODE_STRING  ucName
    );

ULONG
SmbGetInterfaceIndexV4(
    IN PUNICODE_STRING  ucName
    );

ULONG
SmbGetInterfaceIndexV6(
    IN PUNICODE_STRING  ucName
    );

NTSTATUS
SmbBatchedSetBindingInfo(
    PSMB_DEVICE     Device,
    ULONG           RequestType,
    PWSTR           MultiSZBindList
    );

#pragma alloc_text(PAGE, SmbBindHandler)
#pragma alloc_text(PAGE, SmbGetInterfaceIndex)
#pragma alloc_text(PAGE, SmbGetInterfaceIndexV6)
#pragma alloc_text(PAGE, SmbGetInterfaceIndexV4)

NTSTATUS
SmbDeviceAdd(
    PUNICODE_STRING pDeviceName
    );

NTSTATUS
SmbDeviceDel(
    PUNICODE_STRING pDeviceName
    );

NTSTATUS
SmbUpcaseUnicodeStringNP(
    IN OUT  PUNICODE_STRING dest,
    IN      PUNICODE_STRING src
    )
{
    NTSTATUS    status;

    dest->MaximumLength = src->MaximumLength;
    dest->Buffer = ExAllocatePoolWithTag(NonPagedPool, dest->MaximumLength, SMB_TCP_DEVICE_POOL_TAG);
    if (NULL == dest->Buffer) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    status = RtlUpcaseUnicodeString(dest, src, FALSE);
    if (STATUS_SUCCESS != status) {
        ExFreePool(dest->Buffer);
        dest->Buffer = NULL;
    }
    return status;
}

PSMB_TCP_DEVICE
SmbFindAndReferenceInterface(
    PUNICODE_STRING Name
    )
/*++

Routine Description:

    Find the IPv6 interfaces in IPDeviceList
    SpinLock should be held while calling this function.

Arguments:

    Name    the device name
            the buffer should be non-paged

Return Value:

    NULL        if we cannot find it
    non-NULL    otherwise

--*/
{
    PSMB_TCP_DEVICE pIf = NULL;
    PLIST_ENTRY     Entry = NULL;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

    SmbPrint(SMB_TRACE_PNP, ("SmbFindDevice: looking for %Z\n", Name));
    Entry = SmbCfg.IPDeviceList.Flink;
    while(Entry != &SmbCfg.IPDeviceList) {
        pIf = CONTAINING_RECORD(Entry, SMB_TCP_DEVICE, Linkage);

        //
        // We can safely call RtlEqualMemory since both buffers are non-paged and resident.
        //
        SmbPrint(SMB_TRACE_PNP, ("SmbFindDevice: compare with %Z\n", &pIf->AdapterName));
        if (pIf->AdapterName.Length == Name->Length &&
            RtlEqualMemory(pIf->AdapterName.Buffer, Name->Buffer, Name->Length)) {
            SmbReferenceObject((PSMB_OBJECT)pIf, SMB_REF_FIND);
            return pIf;
        }

        Entry = Entry->Flink;
    }

    return NULL;
}

VOID
SmbIp6AddressArrival(
    PTDI_ADDRESS_IP6    Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
{
    UNICODE_STRING  ucName;
    NTSTATUS        status;
    PSMB_TCP_DEVICE pIf;
    KIRQL           Irql;
    BOOL            NotifyClient = FALSE;

    PAGED_CODE();

    SmbTrace(SMB_TRACE_PNP, ("%!IPV6ADDR! for %Z", (PVOID)&(Addr->sin6_addr), pDeviceName));

    SmbInitTCP6(&SmbCfg.SmbDeviceObject->Tcp6, SmbCfg.SmbDeviceObject->Port, SmbCfg.SmbDeviceObject);

    status = SmbUpcaseUnicodeStringNP(&ucName, pDeviceName);
    BAIL_OUT_ON_ERROR(status);

    KeAcquireSpinLock(&SmbCfg.Lock, &Irql);
    pIf = SmbFindAndReferenceInterface(&ucName);
    KeReleaseSpinLock(&SmbCfg.Lock, Irql);
    if (NULL == pIf) {
        goto cleanup;
    }

    if (!pIf->AddressPlumbed) {
        pIf->PrimaryIpAddress.sin_family = SMB_AF_INET6;

        RtlCopyMemory(pIf->PrimaryIpAddress.ip6.sin6_addr,
                Addr->sin6_addr,
                sizeof(pIf->PrimaryIpAddress.ip6.sin6_addr));
        pIf->PrimaryIpAddress.ip6.sin6_scope_id = Addr->sin6_scope_id;
        pIf->AddressPlumbed = TRUE;
        NotifyClient = (0 == SmbCfg.IPAddressNumber);
        SmbCfg.IPAddressNumber++;
        SmbCfg.IPv6AddressNumber++;

        //
        // Don't use SmbPrint to print a WSTR at DISPATCH_LEVEL. Only SmbTrace is usable
        //
        SmbTrace(SMB_TRACE_PNP, ("New IPv6 address %!IPV6ADDR! for %Z", (PVOID)&(Addr->sin6_addr), &ucName));
    }
    pIf->InterfaceIndex = SmbGetInterfaceIndex(&pIf->AdapterName);
    SmbDereferenceObject((PSMB_OBJECT)pIf, SMB_REF_FIND);

    //
    // Query the loopback interface index if it hasn't been done
    //
    if (SmbCfg.SmbDeviceObject->Tcp6.LoopbackInterfaceIndex == INVALID_INTERFACE_INDEX) {
        if (SmbCfg.SmbDeviceObject->Tcp6.FastQuery) {
            SMB_IP6_ADDRESS     loopback;
            ULONG   IfIndex, Metric;

            ip6addr_getloopback(&loopback);
            hton_ip6addr(&loopback);
            status = ((PIP6FASTQUERY)(SmbCfg.SmbDeviceObject->Tcp6.FastQuery))(&loopback, &IfIndex, &Metric);
            if (status == STATUS_SUCCESS) {
                SmbCfg.SmbDeviceObject->Tcp6.LoopbackInterfaceIndex = IfIndex;
                SmbPrint(SMB_TRACE_TCP, ("Loopback Interface Index = %d\n", IfIndex));
                SmbTrace(SMB_TRACE_TCP, ("Loopback Interface Index = %d", IfIndex));
            } else {
                SmbPrint(SMB_TRACE_TCP, ("Query loopback Interface Index returns 0x%08lx\n", status));
                SmbTrace(SMB_TRACE_TCP, ("Query loopback Interface Index returns %!status!", status));
            }
        }
    }

    if (NotifyClient) {
        SmbPrint(SMB_TRACE_PNP, ("Registraion: Notify Client\n"));
        SmbTdiRegister(SmbCfg.SmbDeviceObject);
    }

cleanup:
    if (ucName.Buffer) {
        ExFreePool(ucName.Buffer);
    }
}

VOID
SmbIp6AddressDeletion(
    PTDI_ADDRESS_IP6    Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
{
    UNICODE_STRING  ucName;
    NTSTATUS        status;
    PSMB_TCP_DEVICE pIf;
    KIRQL           Irql;
    BOOL            NotifyClient = FALSE;

    PAGED_CODE();

    SmbTrace(SMB_TRACE_PNP, ("%!IPV6ADDR! for %Z", (PVOID)&(Addr->sin6_addr), pDeviceName));

    status = SmbUpcaseUnicodeStringNP(&ucName, pDeviceName);
    BAIL_OUT_ON_ERROR(status);

    KeAcquireSpinLock(&SmbCfg.Lock, &Irql);
    pIf = SmbFindAndReferenceInterface(&ucName);
    KeReleaseSpinLock(&SmbCfg.Lock, Irql);
    if (NULL == pIf) {
        goto cleanup;
    }

    if (pIf->AddressPlumbed &&
                RtlEqualMemory(pIf->PrimaryIpAddress.ip6.sin6_addr,
                                Addr->sin6_addr,
                                sizeof(pIf->PrimaryIpAddress.ip6.sin6_addr))) {
        pIf->AddressPlumbed = FALSE;
        SmbCfg.IPAddressNumber--;
        SmbCfg.IPv6AddressNumber--;
        NotifyClient = (0 == SmbCfg.IPAddressNumber);

        //
        // Don't use SmbPrint to print a WSTR at DISPATCH_LEVEL. Only SmbTrace is usable
        //
        SmbTrace(SMB_TRACE_PNP, ("Delete IPv6 address %!IPV6ADDR! for %Z", (PVOID)&(Addr->sin6_addr), &ucName));
    }
    SmbDereferenceObject((PSMB_OBJECT)pIf, SMB_REF_FIND);

    if (NotifyClient) {
        SmbPrint(SMB_TRACE_PNP, ("Deregistraion: Notify Client\n"));
        SmbTdiDeregister(SmbCfg.SmbDeviceObject);
    }

cleanup:
    if (ucName.Buffer) {
        ExFreePool(ucName.Buffer);
    }
}

VOID
SmbIp4AddressArrival(
    PTDI_ADDRESS_IP     Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
{
    UNICODE_STRING  ucName;
    NTSTATUS        status;
    PSMB_TCP_DEVICE pIf;
    KIRQL           Irql;
    BOOL            NotifyClient = FALSE;
    CHAR            Buffer[16];

    Inet_ntoa_nb(Addr->in_addr, Buffer);
    Buffer[15] =0;

    SmbPrint(SMB_TRACE_PNP, ("SmbIp4AddressArrival: %s %Z\n", Buffer, pDeviceName));
    SmbTrace(SMB_TRACE_PNP, ("%!ipaddr! %Z", Addr->in_addr, pDeviceName));

    SmbInitTCP4(&SmbCfg.SmbDeviceObject->Tcp4, SmbCfg.SmbDeviceObject->Port, SmbCfg.SmbDeviceObject);

    if (INADDR_NONE == Addr->in_addr) {
        return;
    }

    status = SmbUpcaseUnicodeStringNP(&ucName, pDeviceName);
    BAIL_OUT_ON_ERROR(status);

    KeAcquireSpinLock(&SmbCfg.Lock, &Irql);
    pIf = SmbFindAndReferenceInterface(&ucName);
    KeReleaseSpinLock(&SmbCfg.Lock, Irql);
    if (NULL == pIf) {
        goto cleanup;
    }

    if (!pIf->AddressPlumbed) {
        pIf->PrimaryIpAddress.sin_family = SMB_AF_INET;

        pIf->PrimaryIpAddress.ip4.sin4_addr = Addr->in_addr;
        pIf->AddressPlumbed = TRUE;
        NotifyClient = (0 == SmbCfg.IPAddressNumber);
        SmbCfg.IPAddressNumber++;
        SmbCfg.IPv4AddressNumber++;

        //
        // Don't use SmbPrint to print a WSTR at DISPATCH_LEVEL. Only SmbTrace is usable
        //
        SmbTrace(SMB_TRACE_PNP, ("New IPv4 address %s for %Z", Buffer, &ucName));
    }
    pIf->InterfaceIndex = SmbGetInterfaceIndex(&pIf->AdapterName);
    SmbDereferenceObject((PSMB_OBJECT)pIf, SMB_REF_FIND);

    //
    // Query the loopback interface index if it hasn't been done
    //
    if (SmbCfg.SmbDeviceObject->Tcp4.LoopbackInterfaceIndex == INVALID_INTERFACE_INDEX) {
        if (SmbCfg.SmbDeviceObject->Tcp4.FastQuery) {
            ULONG   IfIndex, Metric;

            status = ((PIP4FASTQUERY)(SmbCfg.SmbDeviceObject->Tcp4.FastQuery))(
                                    ntohl(INADDR_LOOPBACK), &IfIndex, &Metric);
            if (status == STATUS_SUCCESS) {
                SmbCfg.SmbDeviceObject->Tcp4.LoopbackInterfaceIndex = IfIndex;
                SmbPrint(SMB_TRACE_TCP, ("Loopback Interface Index = %d\n", IfIndex));
                SmbTrace(SMB_TRACE_TCP, ("Loopback Interface Index = %d", IfIndex));
            } else {
                SmbPrint(SMB_TRACE_TCP, ("Query loopback Interface Index returns 0x%08lx\n", status));
                SmbTrace(SMB_TRACE_TCP, ("Query loopback Interface Index returns %!status!", status));
            }
        }
    }

    if (NotifyClient) {
        SmbPrint(SMB_TRACE_PNP, ("Registraion: Notify Client\n"));
        SmbTdiRegister(SmbCfg.SmbDeviceObject);
    }

cleanup:
    if (ucName.Buffer) {
        ExFreePool(ucName.Buffer);
    }
}

VOID
SmbIp4AddressDeletion(
    PTDI_ADDRESS_IP     Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
{
    UNICODE_STRING  ucName;
    NTSTATUS        status;
    PSMB_TCP_DEVICE pIf;
    KIRQL           Irql;
    BOOL            NotifyClient = FALSE;
    CHAR            Buffer[16];

    Inet_ntoa_nb(Addr->in_addr, Buffer);
    Buffer[15] =0;

    SmbPrint(SMB_TRACE_PNP, ("SmbIp4AddressDeletion: %s %Z\n", Buffer, pDeviceName));
    SmbTrace(SMB_TRACE_PNP, ("%!ipaddr! %Z", Addr->in_addr, pDeviceName));
    if (INADDR_NONE == Addr->in_addr) {
        return;
    }

    status = SmbUpcaseUnicodeStringNP(&ucName, pDeviceName);
    BAIL_OUT_ON_ERROR(status);

    KeAcquireSpinLock(&SmbCfg.Lock, &Irql);
    pIf = SmbFindAndReferenceInterface(&ucName);
    KeReleaseSpinLock(&SmbCfg.Lock, Irql);
    if (NULL == pIf) {
        goto cleanup;
    }

    if (pIf->AddressPlumbed && pIf->PrimaryIpAddress.ip4.sin4_addr == Addr->in_addr) {
        pIf->AddressPlumbed = FALSE;
        SmbCfg.IPAddressNumber--;
        SmbCfg.IPv4AddressNumber--;
        NotifyClient = (0 == SmbCfg.IPAddressNumber);

        //
        // Don't use SmbPrint to print a WSTR at DISPATCH_LEVEL. Only SmbTrace is usable
        //
        SmbTrace(SMB_TRACE_PNP, ("Delete IPv4 address %s for %Z", Buffer, &ucName));
    }
    SmbDereferenceObject((PSMB_OBJECT)pIf, SMB_REF_FIND);

    if (NotifyClient) {
        SmbPrint(SMB_TRACE_PNP, ("Deregistraion: Notify Client\n"));
        SmbTdiDeregister(SmbCfg.SmbDeviceObject);
    }

cleanup:
    if (ucName.Buffer) {
        ExFreePool(ucName.Buffer);
    }
}

VOID
SmbAddressArrival(
    PTA_ADDRESS         Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
{
    PAGED_CODE();

    switch (Addr->AddressType) {
    case TDI_ADDRESS_TYPE_IP6:
        SmbIp6AddressArrival ((PTDI_ADDRESS_IP6)Addr->Address, pDeviceName, Context);
        break;

    case TDI_ADDRESS_TYPE_IP:
        SmbIp4AddressArrival ((PTDI_ADDRESS_IP)Addr->Address, pDeviceName, Context);
        break;

    default:
        goto cleanup;
    }

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Change the binding
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite (&SmbCfg.Resource, TRUE);
    SmbBatchedSetBindingInfo (SmbCfg.SmbDeviceObject, SMB_CLIENT, SmbCfg.SmbDeviceObject->ClientBinding);
    SmbBatchedSetBindingInfo (SmbCfg.SmbDeviceObject, SMB_SERVER, SmbCfg.SmbDeviceObject->ServerBinding);
    ExReleaseResourceLite (&SmbCfg.Resource);
    KeLeaveCriticalRegion ();

cleanup:
    return;
}

VOID
SmbAddressDeletion(
    PTA_ADDRESS         Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
{
    PAGED_CODE();

    switch (Addr->AddressType) {
    case TDI_ADDRESS_TYPE_IP6:
        SmbIp6AddressDeletion ((PTDI_ADDRESS_IP6)Addr->Address, pDeviceName, Context);
        break;

    case TDI_ADDRESS_TYPE_IP:
        SmbIp4AddressDeletion ((PTDI_ADDRESS_IP)Addr->Address, pDeviceName, Context);
        break;

    default:
        goto cleanup;
    }

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Change the binding
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite (&SmbCfg.Resource, TRUE);
    SmbBatchedSetBindingInfo (SmbCfg.SmbDeviceObject, SMB_CLIENT, SmbCfg.SmbDeviceObject->ClientBinding);
    SmbBatchedSetBindingInfo (SmbCfg.SmbDeviceObject, SMB_SERVER, SmbCfg.SmbDeviceObject->ServerBinding);
    ExReleaseResourceLite (&SmbCfg.Resource);
    KeLeaveCriticalRegion ();

cleanup:
    return;
}

VOID
SmbBindHandler(
    TDI_PNP_OPCODE  PnPOpCode,
    PUNICODE_STRING pDeviceName,
    PWSTR           MultiSZBindList
    )
{
    NTSTATUS        status;
    UNICODE_STRING  ucIPDevice;

    PAGED_CODE();

    if (SmbCfg.Unloading) {
        return;
    }

    switch(PnPOpCode) {
    case TDI_PNP_OP_ADD:
        status = SmbDeviceAdd(pDeviceName);
        SmbTrace(SMB_TRACE_PNP, ("return %!status! for %Z", status, pDeviceName));
        SmbPrint(SMB_TRACE_PNP, ("SmbDeviceAdd return 0x%08lx for %Z\n", status, pDeviceName));
        break;

    case TDI_PNP_OP_DEL:
        status = SmbDeviceDel(pDeviceName);
        SmbTrace(SMB_TRACE_PNP, ("SmbDeviceDel return %!status! for %Z", status, pDeviceName));
        SmbPrint(SMB_TRACE_PNP, ("SmbDeviceDel return 0x%08lx for %Z\n", status, pDeviceName));
        break;

    case TDI_PNP_OP_PROVIDERREADY:
        SmbTrace(SMB_TRACE_PNP, ("Provider %Z is ready", pDeviceName));
        SmbPrint(SMB_TRACE_PNP, ("Provider %Z is ready\n", pDeviceName));

        RtlInitUnicodeString(&ucIPDevice, DD_IPV6_DEVICE_NAME);
        if (RtlEqualUnicodeString(pDeviceName, &ucIPDevice, TRUE)) {
            SmbInitTCP6(&SmbCfg.SmbDeviceObject->Tcp6, SmbCfg.SmbDeviceObject->Port, SmbCfg.SmbDeviceObject);
            if (!SmbCfg.ProviderReady++) {
                TdiProviderReady(SmbCfg.TdiProviderHandle);
            }
        } else {
            RtlInitUnicodeString(&ucIPDevice, DD_IP_DEVICE_NAME);
            if (RtlEqualUnicodeString(pDeviceName, &ucIPDevice, TRUE)) {
                SmbInitTCP4(&SmbCfg.SmbDeviceObject->Tcp4, SmbCfg.SmbDeviceObject->Port, SmbCfg.SmbDeviceObject);
                if (!SmbCfg.ProviderReady++) {
                    TdiProviderReady(SmbCfg.TdiProviderHandle);
                }
            }
        }
        break;

    case TDI_PNP_OP_UPDATE:
    case TDI_PNP_OP_NETREADY:
        /* Nothing to do */
        break;

    default:
        ASSERT(0);
    }
}

VOID
SmbShutdownPnP(
    VOID
    )
{
    PLIST_ENTRY     entry;
    PSMB_TCP_DEVICE pIf;

    PAGED_CODE();

    ASSERT(SmbCfg.Unloading);

    while(!IsListEmpty(&SmbCfg.IPDeviceList)) {
        entry = RemoveHeadList(&SmbCfg.IPDeviceList);
        InsertTailList(&SmbCfg.PendingDeleteIPDeviceList, entry);

        pIf = CONTAINING_RECORD(entry, SMB_TCP_DEVICE, Linkage);

        ASSERT(pIf->RefCount == 1);
        SmbDereferenceObject((PSMB_OBJECT)pIf, SMB_REF_CREATE);
    }
    ASSERT(IsListEmpty(&SmbCfg.PendingDeleteIPDeviceList));
}

NTSTATUS
CheckRegistryBinding(
    PUNICODE_STRING pDeviceName
    )
/*++

Routine Description:

    This routine read in the HKLM\System\CCS\Services\SMB6\Linkage\Bind and check if pDeviceName is in the 
    binding list.

Arguments:

Return Value:

    STATUS_SUCCESS  if pDeviceName is in the binding list
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS    status;
    DWORD       length;
    DWORD       type;
    WCHAR       *pBindingList = NULL;
    WCHAR       *pStart = NULL;
    WCHAR       *pEnd;
    UNICODE_STRING  ucName;

    PAGED_CODE();

    length       = 0;
    type         = REG_MULTI_SZ;
    pBindingList = NULL;

    status = SmbReadRegistry(
            SmbCfg.LinkageKey,
            L"Bind",
            &type,
            &length,
            &pBindingList
            );
    BAIL_OUT_ON_ERROR(status);

    pStart = pBindingList;
    pEnd = (WCHAR*)(((PUCHAR)pBindingList) + length);

    while (*pBindingList && pBindingList < pEnd) {
        RtlInitUnicodeString(&ucName, pBindingList);

        if (RtlEqualUnicodeString(&ucName, pDeviceName, TRUE)) {
            ExFreePool(pStart);
            return STATUS_SUCCESS;
        }

        pBindingList += (ucName.Length / sizeof(WCHAR)) + 1;
    }

cleanup:
    if (pStart) {
        ExFreePool(pStart);
    }
    return STATUS_UNSUCCESSFUL;
}

ULONG
SmbGetInterfaceIndexV4(
    IN PUNICODE_STRING  ucName
    )
{
    PIP_INTERFACE_INFO      IpInfo;
    ULONG                   Size;
    ULONG                   Index;
    LONG                    Entries;
    LONG                    i;
    NTSTATUS                status;
    UNICODE_STRING          ucIpDeviceName;

    PAGED_CODE();

    Entries = SmbCfg.IPDeviceNumber;
    do {
        Size = Entries * sizeof(IP_ADAPTER_INDEX_MAP) + sizeof(ULONG);
        IpInfo = (PIP_INTERFACE_INFO)ExAllocatePoolWithTag(NonPagedPool, Size, '6BMS');
        if (NULL == IpInfo) {
            SmbTrace(SMB_TRACE_TCP, ("out of memory"));
            return INVALID_INTERFACE_INDEX;
        }

        status = SmbSendIoctl(
                SmbCfg.SmbDeviceObject->Tcp4.IPControlFileObject,
                IOCTL_IP_INTERFACE_INFO,
                NULL,
                0,
                IpInfo,
                &Size
                );
        if (STATUS_BUFFER_OVERFLOW != status) {
            break;
        }

        ExFreePool(IpInfo);
        IpInfo = NULL;
        Entries += 2;
    } while(Entries < 128);

    if (!NT_SUCCESS(status)) {
        ExFreePool(IpInfo);
        IpInfo = NULL;
        return INVALID_INTERFACE_INDEX;
    }

    Index = INVALID_INTERFACE_INDEX;
    for (i = 0; i < IpInfo->NumAdapters; i++) {
        RtlInitUnicodeString(&ucIpDeviceName, IpInfo->Adapter[i].Name);
        if (RtlEqualUnicodeString(ucName, &ucIpDeviceName, TRUE)) {
            Index = IpInfo->Adapter[i].Index;
            break;
        }
    }

    ExFreePool(IpInfo);
    IpInfo = NULL;
    return Index;
}

ULONG
SmbGetInterfaceIndexV6(
    IN PUNICODE_STRING  ucName
    )
{
    PAGED_CODE();

    return INVALID_INTERFACE_INDEX;
}

ULONG
SmbGetInterfaceIndex(
    IN PUNICODE_STRING  ucName
    )
{
    ULONG   Index;

    PAGED_CODE();

#if 0
    Index = SmbGetInterfaceIndexV4(ucName);
    SmbPrint(SMB_TRACE_TCP, ("IPV4: returns InterfaceIndex 0x%04lx for %Z\n", Index, ucName));
    SmbTrace(SMB_TRACE_TCP, ("IPV4: returns InterfaceIndex 0x%04lx for %Z", Index, ucName));
    if (Index != INVALID_INTERFACE_INDEX) {
        return Index;
    }

    Index = SmbGetInterfaceIndexV6(ucName);
    SmbPrint(SMB_TRACE_TCP, ("IPV6: returns InterfaceIndex 0x%04lx for %Z\n", Index, ucName));
    SmbTrace(SMB_TRACE_TCP, ("IPV6: returns InterfaceIndex 0x%04lx for %Z", Index, ucName));
#else
    //
    // we have to use the following logic due to a compiler bug
    // Hack!!!
    //
    if (ucName->Length >= 28 && ucName->Buffer[13] == L'6') {
        Index = SmbGetInterfaceIndexV6(ucName);
        SmbPrint(SMB_TRACE_TCP, ("IPV6: returns InterfaceIndex 0x%04lx for %Z\n", Index, ucName));
        SmbTrace(SMB_TRACE_TCP, ("IPV6: returns InterfaceIndex 0x%04lx for %Z", Index, ucName));
    } else {
        Index = SmbGetInterfaceIndexV4(ucName);
        SmbPrint(SMB_TRACE_TCP, ("IPV4: returns InterfaceIndex 0x%04lx for %Z\n", Index, ucName));
        SmbTrace(SMB_TRACE_TCP, ("IPV4: returns InterfaceIndex 0x%04lx for %Z", Index, ucName));
    }
#endif
    return Index;
}

VOID
SmbDeleteTcpDevice(PSMB_TCP_DEVICE pIf)
{
    KIRQL   Irql;

    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);

    ASSERT(EntryIsInList(&SmbCfg.PendingDeleteIPDeviceList, &pIf->Linkage));
    RemoveEntryList(&pIf->Linkage);
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    ExFreePool(pIf);

    SmbPrint(SMB_TRACE_CALL, ("SmbDeleteTcpDevice: free tcp device %p\n", pIf));
}


NTSTATUS
SmbDeviceAdd(
    PUNICODE_STRING pDeviceName
    )
{
    KIRQL           Irql;
    PLIST_ENTRY     Entry = NULL;
    PSMB_TCP_DEVICE pIf = NULL;
    PSMB_TCP_DEVICE pNewIf = NULL;
    DWORD           Size;
    NTSTATUS        status = STATUS_SUCCESS;

    pNewIf = NULL;

    SmbPrint(SMB_TRACE_PNP, ("SmbDeviceAdd: %Z\n", pDeviceName));
    SmbTrace(SMB_TRACE_PNP, ("%Z", pDeviceName));

/*
    No need to check it since TDI has already done it before calling us

    status = CheckRegistryBinding(pDeviceName);
    BAIL_OUT_ON_ERROR(status);
*/

    Size = ALIGN(sizeof(SMB_TCP_DEVICE)) + pDeviceName->MaximumLength;
    pNewIf = ExAllocatePoolWithTag(NonPagedPool, Size, SMB_TCP_DEVICE_POOL_TAG);
    if (pNewIf == NULL) {
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory(pNewIf, Size);

    SmbInitializeObject((PSMB_OBJECT)pNewIf, TAG_TCP_DEVICE, (PSMB_OBJECT_CLEANUP)SmbDeleteTcpDevice);

    pNewIf->AdapterName.Length = 0;
    pNewIf->AdapterName.MaximumLength = pDeviceName->MaximumLength;
    pNewIf->AdapterName.Buffer = (WCHAR*)((PUCHAR)pNewIf + ALIGN(sizeof(SMB_TCP_DEVICE)));
    InitializeListHead(&pNewIf->Linkage);

    status = RtlUpcaseUnicodeString(&pNewIf->AdapterName, pDeviceName, FALSE);
    BAIL_OUT_ON_ERROR(status);

    KeAcquireSpinLock(&SmbCfg.Lock, &Irql);
    Entry = SmbCfg.IPDeviceList.Flink;
    while(Entry != &SmbCfg.IPDeviceList) {
        pIf = CONTAINING_RECORD(Entry, SMB_TCP_DEVICE, Linkage);

        //
        // We can safely call RtlEqualMemory since both buffers are non-paged and resident.
        //
        if (pIf->AdapterName.Length == pNewIf->AdapterName.Length &&
            RtlEqualMemory(pIf->AdapterName.Buffer, pNewIf->AdapterName.Buffer, pNewIf->AdapterName.Length)) {
            ExFreePool(pNewIf);
            pNewIf = NULL;
            break;
        }

        Entry = Entry->Flink;
    }

    if (pNewIf) {
        SmbCfg.IPDeviceNumber++;
        InsertTailList(&SmbCfg.IPDeviceList, &pNewIf->Linkage);
        SmbTrace(SMB_TRACE_PNP, ("Add device %Z", &pNewIf->AdapterName));
        SmbPrint(SMB_TRACE_PNP, ("SmbDeviceAdd: Add %Z\n", &pNewIf->AdapterName));
    }
    KeReleaseSpinLock(&SmbCfg.Lock, Irql);

    SmbInitTCP4(&SmbCfg.SmbDeviceObject->Tcp4, SmbCfg.SmbDeviceObject->Port, SmbCfg.SmbDeviceObject);
    SmbInitTCP6(&SmbCfg.SmbDeviceObject->Tcp6, SmbCfg.SmbDeviceObject->Port, SmbCfg.SmbDeviceObject);

    return STATUS_SUCCESS;

cleanup:
    if (pNewIf) {
        ExFreePool(pNewIf);
    }
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
SmbDeviceDel(
    PUNICODE_STRING pDeviceName
    )
{
    KIRQL           Irql;
    UNICODE_STRING  ucName = { 0 };
    NTSTATUS        status = STATUS_SUCCESS;
    PSMB_TCP_DEVICE pIf = NULL;

    SmbPrint(SMB_TRACE_PNP, ("SmbDeviceDel: %Z\n", pDeviceName));
    SmbTrace(SMB_TRACE_PNP, ("%Z", pDeviceName));

    ucName.MaximumLength = pDeviceName->MaximumLength;
    ucName.Buffer = ExAllocatePoolWithTag(NonPagedPool, ucName.MaximumLength, SMB_TCP_DEVICE_POOL_TAG);
    if (NULL == ucName.Buffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = RtlUpcaseUnicodeString(&ucName, pDeviceName, FALSE);
    BAIL_OUT_ON_ERROR(status);

    KeAcquireSpinLock(&SmbCfg.Lock, &Irql);
    pIf = SmbFindAndReferenceInterface(&ucName);
    KeReleaseSpinLock(&SmbCfg.Lock, Irql);
    if (NULL == pIf) {
        status = STATUS_NOT_FOUND;
        goto cleanup;
    }

    SmbDereferenceObject((PSMB_OBJECT)pIf, SMB_REF_FIND);

    SmbCfg.IPDeviceNumber--;
    RemoveEntryList(&pIf->Linkage);
    InsertTailList(&SmbCfg.PendingDeleteIPDeviceList, &pIf->Linkage);
    SmbPrint(SMB_TRACE_PNP, ("Delete device %Z\n", &ucName));
    SmbTrace(SMB_TRACE_PNP, ("Delete %Z", &ucName));

    SmbDereferenceObject((PSMB_OBJECT)pIf, SMB_REF_CREATE);

cleanup:
    if (ucName.Buffer) {
        ExFreePool(ucName.Buffer);
    }
    return status;
}

NTSTATUS
SmbTdiRegister(
    IN PSMB_DEVICE  DeviceObject
    )
{
    UNICODE_STRING  ExportName = { 0 };
    NTSTATUS        status = STATUS_SUCCESS;

    PAGED_CODE();

    status = STATUS_SUCCESS;
    if (NULL == DeviceObject->DeviceRegistrationHandle) {
        RtlInitUnicodeString(&ExportName, DD_SMB6_EXPORT_NAME);
        status = TdiRegisterDeviceObject(&ExportName, &DeviceObject->DeviceRegistrationHandle);
        SmbTrace(SMB_TRACE_PNP, ("TdiRegisterDeviceObject returns %!status!", status));
        SmbPrint(SMB_TRACE_PNP, ("TdiRegisterDeviceObject returns 0x%08lx\n", status));

        //
        // Don't use SmbWakeupWorkerThread. This should be handled synchronously
        //
        if (SmbCfg.Tcp6Available) {
            SmbReadTCPConf(SmbCfg.ParametersKey, &DeviceObject->Tcp6);
            status = SmbSynchConnCache(&DeviceObject->Tcp6, FALSE);
            SmbTrace(SMB_TRACE_PNP, ("SmbSynchConnCache (TCP6) returns %!status!", status));
            SmbPrint(SMB_TRACE_PNP, ("SmbSynchConnCache (TCP6) returns 0x%08lx\n", status));
        }

        if (SmbCfg.Tcp4Available) {
            SmbReadTCPConf(SmbCfg.ParametersKey, &DeviceObject->Tcp4);
            status = SmbSynchConnCache(&DeviceObject->Tcp4, FALSE);
            SmbTrace(SMB_TRACE_PNP, ("SmbSynchConnCache (TCP4) returns %!status!", status));
            SmbPrint(SMB_TRACE_PNP, ("SmbSynchConnCache (TCP4) returns 0x%08lx\n", status));
        }
    }

    return status;
}

NTSTATUS
SmbTdiDeregister(
    IN PSMB_DEVICE  DeviceObject
    )
{
    HANDLE          RegHandle;
    NTSTATUS        status;

    PAGED_CODE();

    RegHandle = InterlockedExchangePointer(&DeviceObject->DeviceRegistrationHandle, NULL);
    SmbPrint(SMB_TRACE_PNP, ("SmbTdiDeregister: RegHandle = %p\n", RegHandle));

    status = STATUS_SUCCESS;
    if (RegHandle) {
        status = TdiDeregisterDeviceObject(RegHandle);
        SmbTrace(SMB_TRACE_PNP, ("TdiDeregisterDeviceObject returns %!status!", status));
        SmbPrint(SMB_TRACE_PNP, ("TdiDeregisterDeviceObject returns 0x%08lx\n", status));

        //
        // Don't use SmbWakeupWorkerThread. This should be handled synchronously
        //
        if (SmbCfg.Tcp6Available) {
            status = SmbSynchConnCache(&DeviceObject->Tcp6, TRUE);
            SmbTrace(SMB_TRACE_PNP, ("SmbSynchConnCache (TCP6) returns %!status!", status));
            SmbPrint(SMB_TRACE_PNP, ("SmbSynchConnCache (TCP6) returns 0x%08lx\n", status));
        }

        if (SmbCfg.Tcp4Available) {
            status = SmbSynchConnCache(&DeviceObject->Tcp4, TRUE);
            SmbTrace(SMB_TRACE_PNP, ("SmbSynchConnCache (TCP4) returns %!status!", status));
            SmbPrint(SMB_TRACE_PNP, ("SmbSynchConnCache (TCP4) returns 0x%08lx\n", status));
        }
    }

    return status;
}

VOID
GetMultiSZInfo(
    WCHAR   *str,
    LONG    *cnt_ret,
    LONG    *size_ret
    )
{
    LONG    cnt, size, len;
    WCHAR   *p;

    cnt = 0;
    size = 0;
    p = str;
    while (*p) {
        cnt ++;
        SmbPrint(SMB_TRACE_PNP, ("%d. %ws\n", cnt, p));
        SmbTrace(SMB_TRACE_PNP, ("%d. %ws", cnt, p));
        len = wcslen(p) + 1;
        p += len;
        size += len;
    }
    size++;

    SmbPrint(SMB_TRACE_PNP, ("Total number=%d, Total Length=%d\n", cnt, size));
    SmbTrace(SMB_TRACE_PNP, ("Total number=%d, Total Length=%d", cnt, size));

    if (NULL != cnt_ret) {
        *cnt_ret = cnt;
    }
    if (NULL != size_ret) {
        *size_ret = size;
    }
}

PWSTR
DuplicateMultiSZString(
    IN PWSTR    str
    )
{
    LONG    size;
    PVOID   buffer;

    GetMultiSZInfo(str, NULL, &size);
    if (0 == size) {
        SmbPrint(SMB_TRACE_PNP, ("GetMultiSZInfo return error!!!\n"));
        return NULL;
    }

    size *= sizeof(WCHAR);
    buffer = ExAllocatePoolWithTag(NonPagedPool, size, '2BMS');
    if (NULL == buffer) {
        SmbPrint(SMB_TRACE_PNP, ("Cannot allocate %d bytes memory from NonPagedPool\n", size));
        return NULL;
    }

    RtlCopyMemory(buffer, str, size);
    return buffer;
}

PUNICODE_STRING
SeparateMultiSZ(
    WCHAR   *str,
    LONG    *num
    )
{
    PUNICODE_STRING uc_strs;
    LONG            i, cnt, size, len;
    WCHAR           *p;
    PVOID           *buffer;
    UNICODE_STRING  ucName;

    PAGED_CODE();

    GetMultiSZInfo(str, &cnt, &len);
    if (cnt == 0 || len == 0) {
        SmbPrint(SMB_TRACE_PNP, ("GetMultiSZInfo return error!!!\n"));
        return NULL;
    }

    size = len * sizeof(WCHAR) + cnt * sizeof (UNICODE_STRING);
    uc_strs = (PUNICODE_STRING)ExAllocatePoolWithTag(NonPagedPool, size, '1BMS');
    if (NULL == uc_strs) {
        SmbPrint(SMB_TRACE_PNP, ("Cannot allocate %d bytes memory from NonPagedPool\n", size));
        return NULL;
    }

    //
    // Make a uppercase copy of str
    //
    p = (WCHAR*)(uc_strs + cnt);
    for (i = 0; i < len; i++) {
        p[i] = RtlUpcaseUnicodeChar(str[i]);
    }

    p = (WCHAR*)(uc_strs + cnt);
    for (i = 0; (i < cnt) && (*p); i++) {
        RtlInitUnicodeString(&ucName, p);
        p += (ucName.Length/sizeof(WCHAR)) + 1;
        uc_strs[i] = ucName;
    }

    ASSERT (i == cnt);
    if (NULL != num) {
        *num = cnt;
    }
    return uc_strs;
}

NTSTATUS
SmbSetTcpInfo(
    IN PFILE_OBJECT FileObject,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG ToiId,
    IN ULONG ToiType,
    IN ULONG InfoBufferValue
    )
{
    NTSTATUS                        status;
    ULONG                           BufferLength;
    PTCP_REQUEST_SET_INFORMATION_EX TcpInfo;
    TCPSocketOption                 *SockOption;

    PAGED_CODE();

    BufferLength = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(TCPSocketOption);
    TcpInfo = (PTCP_REQUEST_SET_INFORMATION_EX)ExAllocatePoolWithTag(NonPagedPool, BufferLength, '2BMS');
    if (NULL == TcpInfo) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(TcpInfo, BufferLength);
    SockOption = (TCPSocketOption *) (&TcpInfo->Buffer[0]);

    TcpInfo->ID.toi_entity.tei_entity  = Entity;
    TcpInfo->ID.toi_entity.tei_instance = TL_INSTANCE;
    TcpInfo->ID.toi_class              = Class;
    TcpInfo->BufferSize                = sizeof (TCPSocketOption);

    //
    // Set the Configured values
    //
    TcpInfo->ID.toi_id                 = ToiId;
    TcpInfo->ID.toi_type               = ToiType;
    SockOption->tso_value              = InfoBufferValue;

    status = SmbSendIoctl(
            FileObject,
            IOCTL_TCP_SET_INFORMATION_EX,
            TcpInfo,
            BufferLength,
            NULL,
            NULL
            );
    if (!NT_SUCCESS(status)) {
        SmbPrint(SMB_TRACE_TCP, ("SmbSetTcpInfo: SetTcpInfo FAILed <0x%x>, Id=<0x%x>, Type=<0x%x>, Value=<0x%x>\n",
            status, ToiId, ToiType, InfoBufferValue));
        SmbTrace(SMB_TRACE_TCP, ("FAILed %!status!, Id=<0x%x>, Type=<0x%x>, Value=<0x%x>\n",
            status, ToiId, ToiType, InfoBufferValue));
    }

    ExFreePool (TcpInfo);

    return status;
}

#ifdef STANDALONE_SMB
    #define NETBT_PREFIX            L"\\DEVICE\\SMB_"
#else
    #define NETBT_PREFIX            L"\\DEVICE\\NETBT_"
#endif
#define DEVICE_PREFIX           L"\\DEVICE\\"

NTSTATUS
SmbSetDeviceBindingInfo(
    PSMB_DEVICE Device,
    PNETBT_SMB_BIND_REQUEST SmbRequest
    )
/*++

Routine Description:

    Set the binding information for one IPv4 device

Arguments:

Return Value:

--*/
{
    UNICODE_STRING          ucName;
    PSMB_TCP_DEVICE         pIf;
    KIRQL                   Irql;
    ULONG                   Operation;
    NTSTATUS                status;
    SHORT                   NbtPrefixSize, DevPrefixSize;

    if (NULL == SmbRequest->pDeviceName) {
        return STATUS_UNSUCCESSFUL;
    }
    if (SmbRequest->PnPOpCode != TDI_PNP_OP_ADD && SmbRequest->PnPOpCode != TDI_PNP_OP_DEL) {
        return STATUS_UNSUCCESSFUL;
    }
    status = SmbUpcaseUnicodeStringNP(&ucName, SmbRequest->pDeviceName);
    if (STATUS_SUCCESS != status) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Remove the NetBT prefix
    //
    NbtPrefixSize = wcslen(NETBT_PREFIX) * sizeof(WCHAR);
    DevPrefixSize = wcslen(DEVICE_PREFIX) * sizeof(WCHAR);
    ASSERT(DevPrefixSize < NbtPrefixSize);
    if (RtlEqualMemory(ucName.Buffer, NETBT_PREFIX, NbtPrefixSize)) {
        RtlMoveMemory((BYTE*)(ucName.Buffer) + DevPrefixSize,
                      (BYTE*)(ucName.Buffer) + NbtPrefixSize,
                      ucName.MaximumLength - NbtPrefixSize
                      );
        ucName.Length -= NbtPrefixSize - DevPrefixSize;
    }

    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    pIf = SmbFindAndReferenceInterface(&ucName);
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);
    ExFreePool(ucName.Buffer);

    if (NULL == pIf) {
        return STATUS_UNSUCCESSFUL;
    }

    if (SmbRequest->RequestType == SMB_CLIENT) {
        pIf->EnableOutbound = (SmbRequest->PnPOpCode == TDI_PNP_OP_ADD);
        SmbDereferenceObject((PSMB_OBJECT)pIf, SMB_REF_FIND);
        return STATUS_SUCCESS;
    }

    //
    // Inbound
    //
    if (SmbRequest->PnPOpCode == TDI_PNP_OP_ADD) {
        pIf->EnableInbound = TRUE;
        Operation = AO_OPTION_ADD_IFLIST;
    } else {
        pIf->EnableInbound = FALSE;
        Operation = AO_OPTION_DEL_IFLIST;
    }

    if (pIf->PrimaryIpAddress.sin_family == SMB_AF_INET &&
            pIf->PrimaryIpAddress.ip4.sin4_addr != 0 &&
            pIf->InterfaceIndex != INVALID_INTERFACE_INDEX) {
        status = SmbSetTcpInfo (
                Device->Tcp4.InboundAddressObject.AddressObject,
                CO_TL_ENTITY,
                INFO_CLASS_PROTOCOL,
                Operation,
                INFO_TYPE_ADDRESS_OBJECT,
                pIf->InterfaceIndex
                );
        SmbPrint(SMB_TRACE_PNP, ("SmbSetTcpInfo return 0x%08lx for %Z\n", status, &pIf->AdapterName));
        SmbTrace(SMB_TRACE_PNP, ("SmbSetTcpInfo return %!status! for %Z", status, &pIf->AdapterName));
    }

    SmbDereferenceObject((PSMB_OBJECT)pIf, SMB_REF_FIND);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbBatchedSetBindingInfo(
    PSMB_DEVICE     Device,
    ULONG           RequestType,
    PWSTR           MultiSZBindList
    )
/*++

Routine Description:

    Set binding info for a set of IPv4 device

    Note: the input is a list of IPv4 device which SMB device should be bound to.
          The implication is that SMB should be unbound from the device which
          is not in the input list!!!
          We got to support this in order to maintain compatibility

Arguments:

Return Value:

--*/
{
    LONG                    i, j, cnt, ip4device_cnt;
    SHORT                   NbtPrefixSize, DevPrefixSize;
    PUNICODE_STRING         uc_strs;
    KIRQL                   Irql;
    PLIST_ENTRY             entry;
    PSMB_TCP_DEVICE         pIf, *pIfSnapshot;
    NTSTATUS                status;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    if (NULL == MultiSZBindList) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Separate the MutiSZ string
    //
    uc_strs = SeparateMultiSZ(MultiSZBindList, &cnt);
    if (NULL == uc_strs) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Remove the NetBT prefix
    //
    NbtPrefixSize = wcslen(NETBT_PREFIX) * sizeof(WCHAR);
    DevPrefixSize = wcslen(DEVICE_PREFIX) * sizeof(WCHAR);
    ASSERT(DevPrefixSize < NbtPrefixSize);

    SmbTrace(SMB_TRACE_PNP, ("Number of bindings: %d", cnt));
    SmbPrint(SMB_TRACE_PNP, ("Number of bindings: %d\n", cnt));
    for (i = 0; i < cnt; i++) {
        if (RtlEqualMemory(uc_strs[i].Buffer, NETBT_PREFIX, NbtPrefixSize)) {
            RtlMoveMemory((BYTE*)(uc_strs[i].Buffer) + DevPrefixSize,
                          (BYTE*)(uc_strs[i].Buffer) + NbtPrefixSize,
                          uc_strs[i].MaximumLength - NbtPrefixSize
                          );
            uc_strs[i].Length -= NbtPrefixSize - DevPrefixSize;
        }
        SmbTrace(SMB_TRACE_PNP, ("\t%d. bind to %Z", i + 1, uc_strs + i));
        SmbPrint(SMB_TRACE_PNP, ("\t%d. bind to %Z\n", i + 1, uc_strs + i));
    }

    //
    // Handle the SMB_CLIENT request
    //
    if (RequestType == SMB_CLIENT) {
        SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
        entry = SmbCfg.IPDeviceList.Flink;
        while(entry != &SmbCfg.IPDeviceList) {
            pIf = CONTAINING_RECORD(entry, SMB_TCP_DEVICE, Linkage);
            entry = entry->Flink;

            pIf->EnableOutbound = FALSE;
            for (i = 0; i < cnt; i++) {
                if (pIf->AdapterName.Length == uc_strs[i].Length &&
                    RtlEqualMemory(pIf->AdapterName.Buffer, uc_strs[i].Buffer, uc_strs[i].Length)) {

                    pIf->EnableOutbound = TRUE;
                    SmbTrace(SMB_TRACE_PNP, ("Enable outbound on %Z", &pIf->AdapterName));
                }
            }
        }
        SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

        ExFreePool(uc_strs);
        return STATUS_SUCCESS;
    }

    ASSERT(RequestType == SMB_SERVER);

    //
    // A little bit more complex for server
    // The linked list could be modified while calling into TCP because
    // we cannot hold lock while calling other components.
    //

    //
    // Make a snapshot and reference them
    //
    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    ip4device_cnt = SmbCfg.IPAddressNumber;
    if (ip4device_cnt == 0) {
        SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);
        ExFreePool(uc_strs);
        return STATUS_UNSUCCESSFUL;
    }

    pIfSnapshot = (PSMB_TCP_DEVICE*)ExAllocatePoolWithTag(
                            NonPagedPool,
                            sizeof(PSMB_TCP_DEVICE)*ip4device_cnt,
                            SMB_TCP_DEVICE_POOL_TAG
                            );
    if (NULL == pIfSnapshot) {
        SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);
        ExFreePool(uc_strs);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0, entry = SmbCfg.IPDeviceList.Flink;
            (i < ip4device_cnt) && entry != &SmbCfg.IPDeviceList;
            entry = entry->Flink
            ) {

        pIf = CONTAINING_RECORD(entry, SMB_TCP_DEVICE, Linkage);
        if (pIf->PrimaryIpAddress.sin_family == SMB_AF_INET &&
                pIf->PrimaryIpAddress.ip4.sin4_addr != 0 &&
                pIf->InterfaceIndex != INVALID_INTERFACE_INDEX) {
            SmbReferenceObject((PSMB_OBJECT)pIf, SMB_REF_FIND);
            pIfSnapshot[i] = pIf;
            i++;
        }
    }
    ASSERT (i <= ip4device_cnt);
    ip4device_cnt = i;
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    for (i = 0; i < ip4device_cnt; i++) {
        pIf = pIfSnapshot[i];

        pIf->EnableInbound = FALSE;
        for (j = 0; j < cnt; j++) {
            if (pIf->AdapterName.Length == uc_strs[j].Length &&
                RtlEqualMemory(pIf->AdapterName.Buffer, uc_strs[j].Buffer, uc_strs[j].Length)) {

                pIf->EnableInbound = TRUE;
                SmbTrace(SMB_TRACE_PNP, ("Enable inbound on %Z", &pIf->AdapterName));
            }
        }

        status = SmbSetTcpInfo (
                Device->Tcp4.InboundAddressObject.AddressObject,
                CO_TL_ENTITY,
                INFO_CLASS_PROTOCOL,
                pIf->EnableInbound? AO_OPTION_ADD_IFLIST: AO_OPTION_DEL_IFLIST,
                INFO_TYPE_ADDRESS_OBJECT,
                pIf->InterfaceIndex
                );
        SmbPrint(SMB_TRACE_PNP, ("SmbSetTcpInfo return 0x%08lx for %Z\n", status, &pIf->AdapterName));
        SmbTrace(SMB_TRACE_PNP, ("SmbSetTcpInfo return %!status! for %Z", status, &pIf->AdapterName));

        SmbDereferenceObject((PSMB_OBJECT)pIf, SMB_REF_FIND);
    }
    ExFreePool(uc_strs);
    ExFreePool(pIfSnapshot);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbSetBindingInfo(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
{
    PIO_STACK_LOCATION      IrpSp;
    PNETBT_SMB_BIND_REQUEST SmbRequest;
    NTSTATUS                status;
    PWSTR                   MultiSZBindList;

    PAGED_CODE();

    if (Irp->RequestorMode != KernelMode) {
        return STATUS_ACCESS_DENIED;
    }

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(NETBT_SMB_BIND_REQUEST)) {
        return STATUS_UNSUCCESSFUL;
    }
    SmbRequest = (PNETBT_SMB_BIND_REQUEST)Irp->AssociatedIrp.SystemBuffer;
    if (SmbRequest->RequestType != SMB_CLIENT && SmbRequest->RequestType != SMB_SERVER) {
        return STATUS_INVALID_PARAMETER;
    }

    if (NULL == SmbRequest->MultiSZBindList) {
        return SmbSetDeviceBindingInfo(Device, SmbRequest);
    }

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(&SmbCfg.Resource, TRUE);

    MultiSZBindList = DuplicateMultiSZString(SmbRequest->MultiSZBindList);
    if (NULL != MultiSZBindList) {

        //
        // Update the binding list
        //
        if (SMB_CLIENT == SmbRequest->RequestType) {
            if (Device->ClientBinding) {
                ExFreePool(Device->ClientBinding);
            }
            Device->ClientBinding = MultiSZBindList;
        } else if (SMB_SERVER == SmbRequest->RequestType) {
            if (Device->ServerBinding) {
                ExFreePool(Device->ServerBinding);
            }
            Device->ServerBinding = MultiSZBindList;
        }

    } else {
        //
        // Out of resource is not severe error. Simply ignore it.
        //
    }

    status = SmbBatchedSetBindingInfo(Device, SmbRequest->RequestType, SmbRequest->MultiSZBindList);
    ExReleaseResourceLite(&SmbCfg.Resource);
    KeLeaveCriticalRegion();

    return status;
}

NTSTATUS
SmbSetInboundIPv6Protection(
    IN PSMB_DEVICE pDeviceObject
    )
/*++

Routine Description:

    This routine set the TCP/IPv6 listening protection level
    IPv6 stack support 3 level of protection:
    PROTECTION_LEVEL_RESTRICTED: intranet scenario
        allow connection requests from local address only
    PROTECTION_LEVEL_DEFAULT: default level
    PROTECTION_LEVEL_UNRESTRICTED: for peer to peer connection

Arguments:

Return Value:

--*/
{
    KIRQL Irql = 0;
    PFILE_OBJECT pIPv6AO = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG uIPv6ProtectionLevel = 0;

    SMB_ACQUIRE_SPINLOCK(pDeviceObject, Irql);
    pIPv6AO = pDeviceObject->Tcp6.InboundAddressObject.AddressObject;
    if (pIPv6AO == NULL) {
        SMB_RELEASE_SPINLOCK(pDeviceObject, Irql);
        goto error;
    }
    ObReferenceObject(pIPv6AO);
    SMB_RELEASE_SPINLOCK(pDeviceObject, Irql);

    uIPv6ProtectionLevel = SmbCfg.uIPv6Protection;

    ntStatus = SmbSetTcpInfo (
                pIPv6AO,
                CL_TL_ENTITY,
                INFO_CLASS_PROTOCOL,
                AO_OPTION_PROTECT,
                INFO_TYPE_ADDRESS_OBJECT,
                uIPv6ProtectionLevel
                );
    ObDereferenceObject(pIPv6AO);
    SmbTrace(SMB_TRACE_PNP, ("IPv6Protection Level = %d: %!status!", uIPv6ProtectionLevel, ntStatus));
 
error:
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\name.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    name.c

Abstract:

    Local Address

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "name.tmh"

//#pragma alloc_text(PAGE, SmbCreateClient)
//#pragma alloc_text(PAGE, SmbCloseClient)

#define TA_ADDRESS_HEADER_SIZE      (FIELD_OFFSET(TA_ADDRESS,Address))

VOID
SmbDeleteClient(PSMB_CLIENT_ELEMENT ob)
{
    KIRQL   Irql;

    SMB_ACQUIRE_SPINLOCK(ob->Device, Irql);
    ASSERT(EntryIsInList(&ob->Device->PendingDeleteClientList, &ob->Linkage));
    RemoveEntryList(&ob->Linkage);
    SMB_RELEASE_SPINLOCK(ob->Device, Irql);

    ExFreePool(ob);

    SmbPrint(SMB_TRACE_CALL, ("SmbDeleteClient: free Client %p\n", ob));
}

NTSTATUS
SmbCreateClient(
    IN PSMB_DEVICE  Device,
    IN PIRP         Irp,
    PFILE_FULL_EA_INFORMATION   ea
    )
{
    TRANSPORT_ADDRESS UNALIGNED     *pTransportAddr;
    PTA_ADDRESS                     pAddress;
    PTDI_ADDRESS_NETBIOS            pNetbiosAddr;
    PTDI_ADDRESS_NETBIOS_EX         pNetbiosAddrEx;
    PTDI_ADDRESS_NETBIOS_UNICODE_EX pUnicodeEx;
    PSMB_CLIENT_ELEMENT             ClientObject;
    PIO_STACK_LOCATION              IrpSp;
    UNICODE_STRING                  ucName;

    int                             i;
    DWORD                           RemainingBufferLength;
    CHAR                            Name[NETBIOS_NAME_SIZE + 1];
    USHORT                          NameType;
    OEM_STRING                      OemString;
    KIRQL                           Irql;

    PAGED_CODE();

    SmbPrint(SMB_TRACE_CALL, ("Enter SmbCreateClient\n"));
    pTransportAddr = (PTRANSPORT_ADDRESS)(((PUCHAR)ea->EaName) + ea->EaNameLength + 1);
    RemainingBufferLength = ea->EaValueLength;
    if (RemainingBufferLength < sizeof(TA_NETBIOS_ADDRESS)) {
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    RemainingBufferLength -= sizeof(pTransportAddr->TAAddressCount);
    pAddress = (PTA_ADDRESS)pTransportAddr->Address;

    for (i = 0; i < pTransportAddr->TAAddressCount; i++) {
        //
        // First, make sure we can safely access pAddress->AddressLength
        //
        if (RemainingBufferLength < TA_ADDRESS_HEADER_SIZE) {
            return STATUS_INVALID_ADDRESS_COMPONENT;
        }
        RemainingBufferLength -= TA_ADDRESS_HEADER_SIZE;
        if (RemainingBufferLength < pAddress->AddressLength) {
            return STATUS_INVALID_ADDRESS_COMPONENT;
        }

        if (TDI_ADDRESS_TYPE_NETBIOS == pAddress->AddressType) {

            if (pAddress->AddressLength < sizeof(TDI_ADDRESS_NETBIOS)) {
                return STATUS_INVALID_ADDRESS_COMPONENT;
            }

            pNetbiosAddr = (PTDI_ADDRESS_NETBIOS)pAddress->Address;
            RtlCopyMemory(Name, pNetbiosAddr->NetbiosName, NETBIOS_NAME_SIZE);
            NameType = pNetbiosAddr->NetbiosNameType;
            break;

        } else if (TDI_ADDRESS_TYPE_NETBIOS_EX == pAddress->AddressType) {

            if (pAddress->AddressLength < sizeof(TDI_ADDRESS_NETBIOS_EX)) {
                return STATUS_INVALID_ADDRESS_COMPONENT;
            }
            pNetbiosAddrEx = (PTDI_ADDRESS_NETBIOS_EX)pAddress->Address;
            RtlCopyMemory(Name, pNetbiosAddrEx->EndpointName, NETBIOS_NAME_SIZE);
            NameType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;
            break;

        } else if (TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX == pAddress->AddressType) {

            if (pAddress->AddressLength < sizeof(TDI_ADDRESS_NETBIOS_UNICODE_EX)) {
                return STATUS_INVALID_ADDRESS_COMPONENT;
            }
            pUnicodeEx = (PTDI_ADDRESS_NETBIOS_UNICODE_EX)pAddress->Address;
            OemString.Buffer = Name;
            OemString.Length = 0;
            OemString.MaximumLength = sizeof(Name);

            ucName = pUnicodeEx->EndpointName;
            RtlUpcaseUnicodeStringToOemString(&OemString, &ucName, FALSE);
            NameType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;
            break;

        }

        RemainingBufferLength -= pAddress->AddressLength;
        pAddress = (PTA_ADDRESS)(((PUCHAR)pAddress) + pAddress->AddressLength + TA_ADDRESS_HEADER_SIZE);
    }
    if (i >= pTransportAddr->TAAddressCount) {
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    //
    // We have the name and name type
    //
    Name[NETBIOS_NAME_SIZE] = 0;

    ClientObject = ExAllocatePoolWithTag(NonPagedPool, sizeof(ClientObject[0]), CLIENT_OBJECT_POOL_TAG);
    if (NULL == ClientObject) {
        return STATUS_NO_MEMORY;
    }

    SmbInitializeObject((PSMB_OBJECT)ClientObject, TAG_CLIENT_OBJECT, (PSMB_OBJECT_CLEANUP)SmbDeleteClient);

    ClientObject->Device = Device;

    RtlCopyMemory(ClientObject->EndpointName, Name, NETBIOS_NAME_SIZE);

    KeInitializeSpinLock(&ClientObject->Lock);
    InitializeListHead(&ClientObject->ListenHead);
    InitializeListHead(&ClientObject->AssociatedConnection);
    InitializeListHead(&ClientObject->ActiveConnection);
    InitializeListHead(&ClientObject->PendingAcceptConnection);
    ClientObject->PendingAcceptNumber = 0;

    ClientObject->evConnect = NULL;
    ClientObject->ConEvContext = NULL;

    ClientObject->evDisconnect = NULL;
    ClientObject->DiscEvContext = NULL;

    ClientObject->evError = NULL;
    ClientObject->ErrorEvContext = NULL;

    ClientObject->evReceive = NULL;
    ClientObject->RcvEvContext = NULL;

    SMB_ACQUIRE_SPINLOCK(Device, Irql);
    if (RtlEqualMemory(Device->EndpointName, ClientObject->EndpointName, NETBIOS_NAME_SIZE)) {
        if (Device->SmbServer) {
            ExFreePool(ClientObject);
            SMB_RELEASE_SPINLOCK(Device, Irql);
            SmbPrint(SMB_TRACE_CALL, ("SmbCreateClient: Duplicate server\n"));

            return STATUS_ACCESS_DENIED;
        }
        SmbPrint(SMB_TRACE_CALL, ("SmbCreateClient: Server comes in\n"));
        Device->SmbServer = ClientObject;
    }
    InsertTailList(&Device->ClientList, &ClientObject->Linkage);
    SMB_RELEASE_SPINLOCK(Device, Irql);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    IrpSp->FileObject->FsContext  = ClientObject;
    IrpSp->FileObject->FsContext2 = UlongToPtr(SMB_TDI_CLIENT);

    SmbPrint(SMB_TRACE_CALL, ("SmbCreateClient: new Client %p\n", ClientObject));

    return STATUS_SUCCESS;
}

NTSTATUS
SmbCloseClient(
    IN PSMB_DEVICE  Device,
    IN PIRP         Irp
    )
{
    PIO_STACK_LOCATION  IrpSp;
    KIRQL               Irql;
    PSMB_CLIENT_ELEMENT ClientObject;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    if (IrpSp->FileObject->FsContext2 != UlongToPtr(SMB_TDI_CLIENT)) {
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }

    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    IrpSp->FileObject->FsContext2 = UlongToPtr(SMB_TDI_INVALID);
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    if (NULL == IrpSp->FileObject->FsContext) {
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }

    ClientObject = (PSMB_CLIENT_ELEMENT)IrpSp->FileObject->FsContext;

    SMB_ACQUIRE_SPINLOCK(Device, Irql);

    ASSERT(EntryIsInList(&Device->ClientList, &ClientObject->Linkage));

    if (RtlEqualMemory(Device->EndpointName, ClientObject->EndpointName, NETBIOS_NAME_SIZE)) {
        ASSERT(Device->SmbServer);
        Device->SmbServer = NULL;
        SmbPrint(SMB_TRACE_CALL, ("SmbCloseClient: Server leaves\n"));
    }
    RemoveEntryList(&ClientObject->Linkage);
    InsertTailList(&Device->PendingDeleteClientList, &ClientObject->Linkage);

    SMB_RELEASE_SPINLOCK(Device, Irql);

    SmbDereferenceClient(ClientObject, SMB_REF_CREATE);
    IrpSp->FileObject->FsContext = NULL;

    SmbPrint(SMB_TRACE_CALL, ("SmbCloseClient: close Client %p\n", ClientObject));
    return STATUS_SUCCESS;
}

PSMB_CLIENT_ELEMENT
SmbVerifyAndReferenceClient(
    PFILE_OBJECT    FileObject,
    SMB_REF_CONTEXT ctx
    )
{
    PSMB_CLIENT_ELEMENT ClientObject;
    KIRQL               Irql;

    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    if (FileObject->FsContext2 != UlongToPtr(SMB_TDI_CLIENT)) {
        ClientObject = NULL;
    } else {
        ClientObject = (PSMB_CLIENT_ELEMENT)FileObject->FsContext;
        SmbReferenceClient(ClientObject, ctx);
    }
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    return ClientObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\send.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    send.c

Abstract:

    Implement TDI_SEND

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "send.tmh"

PMDL
SmbAllocateNetBuffer(
    ULONG uNumOfBytes
    )
{
    PVOID pvBuf = NULL;
    PVOID pvMappedBuf = NULL;
    PMDL pMdl = NULL;

    pvBuf = ExAllocatePoolWithTag(
                NonPagedPool,
                uNumOfBytes,
                NBT_HEADER_TAG
                );
    if (NULL == pvBuf) {
        goto error;
    }

    pMdl = IoAllocateMdl(pvBuf, uNumOfBytes, FALSE, FALSE, NULL);
    if (NULL == pMdl) {
        ExFreePool(pvBuf);
        goto error;
    }

    MmBuildMdlForNonPagedPool(pMdl);

    //
    // Verify the mapped system address == pvBuf
    // SmbFreeNetBuffer depends on this assumption.
    //

    pvMappedBuf = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
    if (pvMappedBuf != pvBuf) {
        ExFreePool(pvBuf);
        IoFreeMdl(pMdl);
        ASSERT(0);
        pMdl = NULL;
    }

error:
    return pMdl;
}

VOID
SmbFreeNetBuffer(
    PMDL pMdl
    )
{
    PVOID pvBuf = NULL;

    if (NULL == pMdl) {
        goto error;
    }

    pvBuf = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
    if (NULL != pvBuf) {
        ExFreePool(pvBuf);
        pvBuf = NULL;
    }

    IoFreeMdl(pMdl);
    pMdl = NULL;

error:
    return;
}

NTSTATUS
SmbSendCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSMB_CONNECT ConnectObject
    )
/*++

Routine Description:

    This the completion routine of sending a packet

Arguments:

Return Value:

--*/
{
    PMDL    Mdl;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    Mdl = Irp->MdlAddress;

    if (Mdl->MdlFlags & MDL_NETWORK_HEADER) {
        (PUCHAR)Mdl->MappedSystemVa += SMB_SESSION_HEADER_SIZE;
        Mdl->ByteOffset += SMB_SESSION_HEADER_SIZE;
        Mdl->ByteCount -= SMB_SESSION_HEADER_SIZE;
    } else {
        ASSERT(NULL != Mdl->Next);
        Irp->MdlAddress = Mdl->Next;

        ASSERT(MmGetMdlByteCount(Mdl) == SMB_SESSION_HEADER_SIZE);
        SmbFreeNetBuffer(Mdl);
        Mdl = NULL;
    }

    if (Irp->IoStatus.Status == STATUS_SUCCESS && Irp->IoStatus.Information >= SMB_SESSION_HEADER_SIZE) {
        SmbPrint(SMB_TRACE_TCP, ("SmbSendCompletion: Send %d bytes\n", Irp->IoStatus.Information));
        Irp->IoStatus.Information -= SMB_SESSION_HEADER_SIZE;
        ConnectObject->BytesSent += (ULONG)(Irp->IoStatus.Information);
    } else {
        Irp->IoStatus.Information = 0;
        SmbPrint(SMB_TRACE_TCP, ("SmbSendCompletion: status=0x%08lx\n", Irp->IoStatus.Status));
        ASSERT (Irp->IoStatus.Status != STATUS_CONNECTION_ACTIVE);
    }

    ConnectObject->PendingIRPs[SMB_PENDING_SEND] = NULL;
    SmbDereferenceConnect(ConnectObject, SMB_REF_SEND);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbSend(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
/*++

Routine Description:

    TDI_SEND
    RDR/SRV is using backfill mode only at this time. So non-backfill mode is postponed.

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION          IrpSp = NULL;
    NTSTATUS                    status = STATUS_UNSUCCESSFUL;
    PTDI_REQUEST_KERNEL_SEND    TdiRequest = NULL;
    PMDL                        Mdl = NULL;
    PSMB_CONNECT                ConnectObject = NULL;
    PULONG                      SmbHdr = NULL;
    PDEVICE_OBJECT              DeviceObject = NULL;
    PFILE_OBJECT                FileObject = NULL;
    DWORD                       SendLength = 0;
    KIRQL                       Irql;
    PMDL pMdlNbtHdr = NULL;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    TdiRequest = (PTDI_REQUEST_KERNEL_SEND)&IrpSp->Parameters;
    Mdl = Irp->MdlAddress;
    if (NULL == Mdl) {
        return STATUS_INVALID_PARAMETER;
    }

    SendLength = TdiRequest->SendLength;
    if (SendLength > SMB_MAX_SESSION_PACKET) {
        //
        // Shouldn't happen, in case ......
        //
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }

    ConnectObject = SmbVerifyAndReferenceConnect(IrpSp->FileObject, SMB_REF_SEND);
    if (NULL == ConnectObject) {
        ASSERT(0);
        return STATUS_INVALID_HANDLE;
    }

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    if (ConnectObject->State != SMB_CONNECTED || ConnectObject->TcpContext == NULL) {
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        SmbDereferenceConnect(ConnectObject, SMB_REF_SEND);
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    FileObject = ConnectObject->TcpContext->Connect.ConnectObject;
    ASSERT(FileObject != NULL);
    ConnectObject->PendingIRPs[SMB_PENDING_SEND] = Irp;

    //
    // Reference the FileObject in case that it is closed and freed.
    //
    ObReferenceObject(FileObject);
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    DeviceObject = IoGetRelatedDeviceObject(FileObject);

    if (Mdl->MdlFlags & MDL_NETWORK_HEADER) {

        //
        // Backfill mode
        //

        (PUCHAR)Mdl->MappedSystemVa -= SMB_SESSION_HEADER_SIZE;
        Mdl->ByteOffset -= SMB_SESSION_HEADER_SIZE;
        Mdl->ByteCount  += SMB_SESSION_HEADER_SIZE;
        SmbHdr = (PULONG)Mdl->MappedSystemVa;
        *SmbHdr = htonl(SendLength);

    } else {

        //
        // we need to attach our own header
        //

        pMdlNbtHdr = SmbAllocateNetBuffer(SMB_SESSION_HEADER_SIZE);
        if (NULL == pMdlNbtHdr) {
            ConnectObject->PendingIRPs[SMB_PENDING_SEND] = NULL;
            SmbDereferenceConnect(ConnectObject, SMB_REF_SEND);
            ObDereferenceObject(FileObject);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ASSERT(0 == (pMdlNbtHdr->MdlFlags & MDL_NETWORK_HEADER));
        SmbHdr = (PULONG)pMdlNbtHdr->MappedSystemVa;
        *SmbHdr = htonl(SendLength);
        pMdlNbtHdr->Next = Irp->MdlAddress;
        Irp->MdlAddress = pMdlNbtHdr;
    }

    TdiBuildSend(
            Irp,
            DeviceObject,
            FileObject,
            (PVOID)SmbSendCompletion,
            ConnectObject,
            Irp->MdlAddress,
            0,
            SendLength + 4
            );
    IoMarkIrpPending(Irp);
    if (ConnectObject->FastSend) {
        IoSetNextIrpStackLocation(Irp);
        status = ConnectObject->FastSend(Irp, IoGetCurrentIrpStackLocation(Irp));
        SmbPrint(SMB_TRACE_TCP, ("SmbSend: FastSend %d bytes IoCallDriver return 0x%08lx\n", SendLength + 4, status));
    } else {
        status = IoCallDriver(DeviceObject, Irp);
        SmbPrint(SMB_TRACE_TCP, ("SmbSend: Send %d bytes IoCallDriver return 0x%08lx\n", SendLength + 4, status));
    }
    ObDereferenceObject(FileObject);

    return STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\registry.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Implement registry functions

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "registry.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbQueryValueKey)
#pragma alloc_text(PAGE, SmbReadULong)
#endif

PKEY_VALUE_FULL_INFORMATION
SmbQueryValueKey(
    HANDLE  hKey,
    LPWSTR  ValueStringName
    )
/*++

Routine Description:

    This function retrieves the full information for the specified key.
    It allocates local memory for the returned information.

Arguments:

    Key : registry handle to the key where the value is.

    ValueStringName : name of the value string.

Return Value:

    NULL if out of resource or error. Otherwise, the pointer to the full information

--*/
{
    DWORD           BytesNeeded, BytesAllocated;
    NTSTATUS        status;
    UNICODE_STRING  KeyName;
    PKEY_VALUE_FULL_INFORMATION Buffer;

    PAGED_CODE();

    RtlInitUnicodeString(&KeyName, ValueStringName);

    Buffer = NULL;
    BytesAllocated = 0;
    BytesNeeded    = 240;
    while(1) {
        ASSERT(Buffer == NULL);

        Buffer = (PKEY_VALUE_FULL_INFORMATION)ExAllocatePoolWithTag(PagedPool, BytesNeeded, SMB_POOL_REGISTRY);
        if (Buffer == NULL) {
            SmbTrace(SMB_TRACE_REGISTRY, ("(Out of memory)"));
            return NULL;
        }
        BytesAllocated = BytesNeeded;

        status = ZwQueryValueKey(
                        hKey,
                        &KeyName,
                        KeyValueFullInformation,
                        Buffer,
                        BytesAllocated,
                        &BytesNeeded
                        );
        if (status == STATUS_SUCCESS) {
            break;
        }

        ASSERT(Buffer);
        ExFreePool(Buffer);
        Buffer = NULL;
        if (BytesNeeded == 0 || (status != STATUS_BUFFER_TOO_SMALL && status != STATUS_BUFFER_OVERFLOW)) {
            SmbTrace(SMB_TRACE_REGISTRY, ("return %!status! BytesAllocated=%d BytsNeeded=%d %ws",
                                    status, BytesAllocated, BytesNeeded, ValueStringName));
            SmbPrint(SMB_TRACE_REGISTRY, ("SmbQueryValueKey return 0x%08lx BytesAllocated=%d BytsNeeded=%d %ws\n",
                                    status, BytesAllocated, BytesNeeded, ValueStringName));
            return NULL;
        }
    }

    ASSERT (status == STATUS_SUCCESS);
    ASSERT (Buffer);
    return Buffer;
}

LONG
SmbReadLong(
    IN HANDLE   hKey,
    IN WCHAR    *KeyName,
    IN LONG     DefaultValue,
    IN LONG     MinimumValue
    )
{
    PKEY_VALUE_FULL_INFORMATION KeyInfo;
    LONG                        Value;

    PAGED_CODE();

    ASSERT (DefaultValue >= MinimumValue);

    Value = DefaultValue;
    if (Value < MinimumValue) {
        Value = MinimumValue;
    }

    KeyInfo = SmbQueryValueKey(hKey, KeyName);
    if (KeyInfo == NULL) {
        return Value;
    }

    if (KeyInfo->Type == REG_DWORD && KeyInfo->DataLength == sizeof(ULONG)) {
        RtlCopyMemory(&Value, (PCHAR)KeyInfo + KeyInfo->DataOffset, sizeof(ULONG));
        if (Value < MinimumValue) {
            Value = MinimumValue;
        }
    }
    ExFreePool(KeyInfo);
    return Value;
}

ULONG
SmbReadULong(
    IN HANDLE   hKey,
    IN WCHAR    *KeyName,
    IN ULONG    DefaultValue,
    IN ULONG    MinimumValue
    )
{
    PKEY_VALUE_FULL_INFORMATION KeyInfo;
    ULONG                       Value;

    PAGED_CODE();

    ASSERT (DefaultValue >= MinimumValue);

    Value = DefaultValue;
    if (Value < MinimumValue) {
        Value = MinimumValue;
    }

    KeyInfo = SmbQueryValueKey(hKey, KeyName);
    if (KeyInfo == NULL) {
        return Value;
    }

    if (KeyInfo->Type == REG_DWORD && KeyInfo->DataLength == sizeof(ULONG)) {
        RtlCopyMemory(&Value, (PCHAR)KeyInfo + KeyInfo->DataOffset, sizeof(ULONG));
        if (Value < MinimumValue) {
            Value = MinimumValue;
        }
    }
    ExFreePool(KeyInfo);
    return Value;
}

NTSTATUS
SmbReadRegistry(
    IN HANDLE   Key,
    IN LPWSTR   ValueStringName,
    IN OUT DWORD *Type,
    IN OUT DWORD *Size,
    IN OUT PVOID *Buffer
    )
/*++

Routine Description:

    Read a regisry value

Arguments:

    Key                 The registry handle under which the registry key resides.
    ValueStringName     The name of registry key
    Type                The data type of the registry key
                Type == NULL        The caller is not interested in the data type
                Type != NULL        The caller want to receive the data type
                *Type != REG_NONE   The caller can receive the value as any data type.

    Size                The size (# of bytes) of the registry value.
                Size == NULL        The caller is not interested in the data size
                Size != NULL        The caller want to know the data size.
                Size != NULL && *Buffer != NULL
                                    The caller has provided a buffer. *Size is the size of
                                    caller-supplied buffer.
    Buffer              The output buffer
                *Buffer == NULL     The caller doesn't provide any buffer. This function
                                    should allocate a buffer. The caller is responsible to
                                    free the buffer.
                *Buffer != NULL     The caller provides a buffer. The size of buffer is specified
                                    in *Size;

Return Value:

    STATUS_SUCCESS  success
    other           failure

--*/
{
    PKEY_VALUE_FULL_INFORMATION KeyInfo;

    ASSERT (Buffer);
    if (Buffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }
    // ASSERT (*Buffer ==> Size && *Size);
    ASSERT (!(*Buffer) || (Size && *Size));
    if ((*Buffer) && !(Size && *Size)) {
        return STATUS_INVALID_PARAMETER;
    }

    if ((NULL == *Buffer) && Size && *Size) {
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }

    KeyInfo = SmbQueryValueKey(
            Key,
            ValueStringName
            );
    if (NULL == KeyInfo) {
        return STATUS_UNSUCCESSFUL;
    }

    if (Type && *Type != REG_NONE) {
        if (KeyInfo->Type != *Type) {
            ExFreePool(KeyInfo);
            return STATUS_UNSUCCESSFUL;
        }
    }

    if (NULL == *Buffer) {
        *Buffer = ExAllocatePoolWithTag(PagedPool, KeyInfo->DataLength, SMB_POOL_REGISTRY);
        if (NULL == *Buffer) {
            ExFreePool(KeyInfo);
            return STATUS_NO_MEMORY;
        }
    } else {
        if (*Size < KeyInfo->DataLength) {
            ExFreePool(KeyInfo);

            *Size = KeyInfo->DataLength;
            return STATUS_BUFFER_TOO_SMALL;
        }
    }

    //
    // From now on, we cannot fail
    //
    if (Size) {
        *Size = KeyInfo->DataLength;
    }

    if (Type) {
        *Type = KeyInfo->Type;
    }
    RtlCopyMemory(*Buffer, ((PUCHAR)KeyInfo) + KeyInfo->DataOffset, KeyInfo->DataLength);

    ExFreePool(KeyInfo);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\receive.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    Implement the TDI_RECEIVE for session service

Author:

    Jiandong Ruan

Revision History:

--*/
#include "precomp.h"
#include "receive.tmh"

VOID
SmbCancelReceive(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      IrpSp;
    PSMB_CONNECT            ConnectObject;
    PLIST_ENTRY             Entry;
    PIRP                    RcvIrp;
    KIRQL                   Irql;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if (IrpSp->FileObject->FsContext2 != UlongToPtr(SMB_TDI_CONNECT)) {
        ASSERT(0);
        return;
    }
    ConnectObject = (PSMB_CONNECT)IrpSp->FileObject->FsContext;

    IoSetCancelRoutine(Irp, NULL);
    IoReleaseCancelSpinLock(Irp->CancelIrql);
    SmbTrace(SMB_TRACE_TCP, ("Cancel Receive Irp %p ConnectObject=%p ClientObject=%p",
                            Irp, ConnectObject, ConnectObject->ClientObject));

    PUSH_LOCATION(ConnectObject, 0x800000);

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    Entry = ConnectObject->RcvList.Flink;
    while (Entry != &ConnectObject->RcvList) {
        RcvIrp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
        if (RcvIrp == Irp) {
            RemoveEntryList(Entry);
            InitializeListHead(Entry);
            SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

            Irp->IoStatus.Status      = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

            PUSH_LOCATION(ConnectObject, 0x800010);

            SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
            return;
        }
        Entry = Entry->Flink;
    }
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    ASSERT(0);
}

NTSTATUS
SmbPullDataFromXport(
    PSMB_CONNECT ConnectObject
    )
{
    return STATUS_SUCCESS;
}

int SmbReceivePassNumber = 0;

NTSTATUS
SmbReceive(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
/*++

Routine Description:

    TDI_RECEIVE

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION  IrpSp = NULL;
    PSMB_CONNECT        ConnectObject = NULL;
    KIRQL               Irql;
    NTSTATUS            status = STATUS_PENDING;
    LONG                BytesTaken, ClientBufferSize;
    PDEVICE_OBJECT      TcpDeviceObject = NULL;
    PFILE_OBJECT        TcpFileObject = NULL;

    PTDI_REQUEST_KERNEL_RECEIVE ClientRcvParams;

    //
    // Since I never see this code path covered in my test,
    // I put an assert here to get a chance to take a look
    // when it is really taken.
    //
    // Srv.sys does call this function.
    SmbReceivePassNumber++;

    SmbPrint(SMB_TRACE_CALL, ("SmbReceive\n"));
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ClientRcvParams = (PTDI_REQUEST_KERNEL_RECEIVE)&IrpSp->Parameters;

    ConnectObject = SmbVerifyAndReferenceConnect(IrpSp->FileObject, SMB_REF_RECEIVE);
    if (NULL == ConnectObject) {
        ASSERT(0);
        return STATUS_INVALID_HANDLE;
    }
    PUSH_LOCATION(ConnectObject, 0x900000);

    if (ConnectObject->State != SMB_CONNECTED) {
        PUSH_LOCATION(ConnectObject, 0x900020);
        ASSERT(0);
        SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Sanity check
    //
    ClientBufferSize = ClientRcvParams->ReceiveLength;
    if ((ClientRcvParams->ReceiveFlags & (TDI_RECEIVE_EXPEDITED | TDI_RECEIVE_PEEK)) ||
         Irp->MdlAddress == NULL || ClientBufferSize == 0) {
        Irp->IoStatus.Status      = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
        return status;
    }

    PUSH_LOCATION(ConnectObject, 0x900030);

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    if (NULL == ConnectObject->TcpContext) {
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        return STATUS_CONNECTION_RESET;
    }

    if (ConnectObject->StateRcvHandler != SmbPartialRcv || ConnectObject->ClientIrp != NULL) {
        BREAK_WHEN_TAKE();

        //
        // Queue the IRP
        //
        IoAcquireCancelSpinLock(&Irp->CancelIrql);
        if (!Irp->Cancel) {
            IoMarkIrpPending(Irp);
            status = STATUS_PENDING;
            InsertTailList(&ConnectObject->RcvList, &Irp->Tail.Overlay.ListEntry);
            IoSetCancelRoutine(Irp, SmbCancelReceive);
            PUSH_LOCATION(ConnectObject, 0x900040);

        } else {
            status = STATUS_CANCELLED;
            PUSH_LOCATION(ConnectObject, 0x900050);
        }
        IoReleaseCancelSpinLock(Irp->CancelIrql);
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

        if (status != STATUS_PENDING) {
            PUSH_LOCATION(ConnectObject, 0x900060);
            SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
        }
        return status;
    }

    //
    // Client has backlog either in us or in TCP
    //

    ASSERT(ConnectObject->BytesRemaining > 0);
    ASSERT(ConnectObject->BytesRemaining <= ConnectObject->CurrentPktLength);

    ConnectObject->ClientIrp = Irp;
    ConnectObject->ClientMdl = Irp->MdlAddress;
    ConnectObject->ClientBufferSize = ClientBufferSize;
    ConnectObject->FreeBytesInMdl = ConnectObject->ClientBufferSize;

    //
    // First, we need to copy the remaining data in the IndicateBuffer if any
    //
    if (ConnectObject->BytesInIndicate > 0) {
        PUSH_LOCATION(ConnectObject, 0x900070);
        // BREAK_WHEN_TAKE();

        BytesTaken = 0;
        IoMarkIrpPending(Irp);
        status = SmbFillIrp(ConnectObject, ConnectObject->IndicateBuffer,
                            ConnectObject->BytesInIndicate, &BytesTaken);
        ASSERT(BytesTaken <= ConnectObject->BytesInIndicate);
        ConnectObject->BytesInIndicate -= BytesTaken;

        if (status == STATUS_SUCCESS) {
            PUSH_LOCATION(ConnectObject, 0x900080);
            if (ConnectObject->BytesInIndicate) {
                PUSH_LOCATION(ConnectObject, 0x900090);

                //
                // The buffer is too small
                //
                ASSERT(ConnectObject->ClientIrp == NULL);
                ASSERT(ConnectObject->ClientMdl == NULL);

                RtlMoveMemory(
                        ConnectObject->IndicateBuffer + BytesTaken,
                        ConnectObject->IndicateBuffer,
                        ConnectObject->BytesInIndicate
                        );
            }

            //
            // The IRP has been completed by SmbFillIrp. Returning STATUS_PENDING to avoid
            // double completion
            //
            status = STATUS_PENDING;
            goto cleanup;
        }

        ASSERT (status == STATUS_MORE_PROCESSING_REQUIRED);
    }

    ASSERT (ConnectObject->BytesInIndicate == 0);
    ASSERT (ConnectObject->ClientIrp);
    ASSERT (ConnectObject->ClientMdl);
    ASSERT (IsValidPartialRcvState(ConnectObject));

    SmbPrepareReceiveIrp(ConnectObject);

    TcpFileObject   = ConnectObject->TcpContext->Connect.ConnectObject;
    TcpDeviceObject = IoGetRelatedDeviceObject(TcpFileObject);
    ObReferenceObject(TcpFileObject);
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE] = ConnectObject->ClientIrp;
    IoMarkIrpPending(Irp);
    status = IoCallDriver(TcpDeviceObject, ConnectObject->ClientIrp);
    ObDereferenceObject(TcpFileObject);

    return STATUS_PENDING;

cleanup:
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\session.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    session.c

Abstract:

    Implement TDI_ASSOCIATE_ADDRESS, TDI_DISASSOCIATE_ADDRESS, Create connection/ Close Connection

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "session.tmh"

NTSTATUS
DisAssociateAddress(
    PSMB_CONNECT    ConnectObject
    );

PSMB_CONNECT
SmbVerifyAndReferenceConnect(
    PFILE_OBJECT    FileObject,
    SMB_REF_CONTEXT ctx
    )
{
    PSMB_CONNECT    ConnectObject;
    KIRQL           Irql;

    //
    // Rdr could issue request at DISPATCH level, we'd better use spinlock instead of resource lock.
    //
    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    if (FileObject->FsContext2 != UlongToPtr(SMB_TDI_CONNECT)) {
        ConnectObject = NULL;
    } else {
        ConnectObject = (PSMB_CONNECT)FileObject->FsContext;
        SmbReferenceConnect(ConnectObject, ctx);
    }
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    return ConnectObject;
}

VOID
SmbDeleteConnect(PSMB_CONNECT ob)
/*++

Routine Description:

    Kill a ConnectObject
    This routine will be called when the last reference is removed from the ob.

Arguments:

Return Value:

--*/
{
    KIRQL   Irql;

    SMB_ACQUIRE_SPINLOCK(ob->Device, Irql);
    ASSERT(EntryIsInList(&ob->Device->PendingDeleteConnectionList, &ob->Linkage));
    RemoveEntryList(&ob->Linkage);
    SMB_RELEASE_SPINLOCK(ob->Device, Irql);

    if (ob->PartialMdl) {
        IoFreeMdl(ob->PartialMdl);
        ob->PartialMdl = NULL;
    }

    SmbPrint(SMB_TRACE_CALL, ("SmbDeleteConnect: free connect %p\n", ob));
    _delete_ConnectObject(ob);
}

void
SmbReuseConnectObject(PSMB_CONNECT ConnectObject)
{
    int i;

    for (i = 0; i < SMB_PENDING_MAX; i++) {
        ASSERT (ConnectObject->PendingIRPs[i] == NULL);
        ConnectObject->PendingIRPs[i] = NULL;
    }

    ConnectObject->BytesReceived = 0;
    ConnectObject->BytesSent     = 0;
    ConnectObject->BytesInXport  = 0;
    ConnectObject->CurrentPktLength = 0;
    ConnectObject->BytesRemaining   = 0;
    ConnectObject->ClientIrp     = NULL;
    ConnectObject->ClientMdl     = NULL;
    ConnectObject->DpcRequestQueued = FALSE;
    ConnectObject->BytesInIndicate  = 0;
    ConnectObject->HeaderBytesRcved = 0;
    ConnectObject->ClientBufferSize = 0;
    ConnectObject->FreeBytesInMdl   = 0;
    ConnectObject->StateRcvHandler  = WaitingHeader;
    ConnectObject->HeaderBytesRcved = 0;

    ResetDisconnectOriginator(ConnectObject);
#ifdef ENABLE_RCV_TRACE
    SmbInitTraceRcv(&ConnectObject->TraceRcv);
#endif
}

NTSTATUS
SmbCreateConnection(
    PSMB_DEVICE Device,
    PIRP        Irp,
    PFILE_FULL_EA_INFORMATION   ea
    )
/*++

Routine Description:

    Create a ConnectObject

Arguments:

Return Value:

--*/
{
    CONNECTION_CONTEXT  ClientContext;
    PSMB_CONNECT        ConnectObject;
    PIO_STACK_LOCATION  IrpSp;
    KIRQL               Irql;

    PAGED_CODE();

    SmbPrint(SMB_TRACE_CALL, ("Enter SmbCreateConnection\n"));
    if (ea->EaValueLength < sizeof(ClientContext)) {
        ASSERT (0);
        return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    RtlCopyMemory(&ClientContext, ((PUCHAR)ea->EaName) + ea->EaNameLength + 1, sizeof(ClientContext));

    ConnectObject = _new_ConnectObject();
    if (NULL == ConnectObject) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(ConnectObject, sizeof(ConnectObject[0]));

    SmbInitializeObject((PSMB_OBJECT)ConnectObject, TAG_CONNECT_OBJECT, (PSMB_OBJECT_CLEANUP)SmbDeleteConnect);
    KeInitializeDpc(&ConnectObject->SmbHeaderDpc, (PKDEFERRED_ROUTINE)SmbGetHeaderDpc, ConnectObject);

    //
    // Reserved resource for getting smb header so that we don't need to worry about
    // the annoying insufficient error later.
    //
    ASSERT(ConnectObject->PartialMdl == NULL);
    ConnectObject->PartialMdl = IoAllocateMdl(
            &ConnectObject->IndicateBuffer,     // fake address.
            SMB_MAX_SESSION_PACKET,
            FALSE,
            FALSE,
            NULL
            );
    if (ConnectObject->PartialMdl == NULL) {
        _delete_ConnectObject(ConnectObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ConnectObject->Device = Device;

    KeInitializeSpinLock(&ConnectObject->Lock);
    ConnectObject->ClientContext = ClientContext;
    ConnectObject->ClientObject  = NULL;
    ConnectObject->TcpContext    = NULL;
    InitializeListHead(&ConnectObject->RcvList);

    ConnectObject->State = SMB_IDLE;

    ConnectObject->BytesReceived = 0;
    ConnectObject->BytesSent = 0;
    ConnectObject->BytesInXport = 0;
    ConnectObject->CurrentPktLength = 0;
    ConnectObject->BytesRemaining = 0;

    SmbInitTraceRcv(&ConnectObject->TraceRcv);

    SMB_ACQUIRE_SPINLOCK(Device, Irql);
    InsertTailList(&Device->UnassociatedConnectionList, &ConnectObject->Linkage);
    SMB_RELEASE_SPINLOCK(Device, Irql);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    IrpSp->FileObject->FsContext  = ConnectObject;
    IrpSp->FileObject->FsContext2 = UlongToPtr(SMB_TDI_CONNECT);

    SmbPrint(SMB_TRACE_CALL, ("Leave SmbCreateConnection: new Connect %p\n", ConnectObject));
    return STATUS_SUCCESS;
}

NTSTATUS
SmbAssociateAddress(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
/*++

Routine Description:

    TDI_ASSOCIATE_ADDRESS

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PSMB_CONNECT            ConnectObject = NULL;
    PSMB_CLIENT_ELEMENT     ClientObject = NULL;
    HANDLE                  AddressHandle;
    PFILE_OBJECT            AddressObject = NULL;
    NTSTATUS                status;
    KIRQL                   Irql;
    extern POBJECT_TYPE     *IoFileObjectType;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    AddressHandle = ((PTDI_REQUEST_KERNEL_ASSOCIATE)(&IrpSp->Parameters))->AddressHandle;
    if (NULL == AddressHandle) {
        ASSERT(0);
        return STATUS_INVALID_HANDLE;
    }

    ConnectObject = SmbVerifyAndReferenceConnect(IrpSp->FileObject, SMB_REF_ASSOCIATE);
    if (NULL == ConnectObject) {
        ASSERT(0);
        return STATUS_INVALID_HANDLE;
    }

    SmbPrint(SMB_TRACE_CALL, ("SmbAssociateAddress: connect %p\n", ConnectObject));

    status = ObReferenceObjectByHandle(
            AddressHandle,
            FILE_READ_DATA,
            *IoFileObjectType,
            Irp->RequestorMode,
            &AddressObject,
            NULL
            );
    BAIL_OUT_ON_ERROR(status);
    ClientObject = SmbVerifyAndReferenceClient(AddressObject, SMB_REF_ASSOCIATE);
    if (NULL == ClientObject) {
        ASSERT(0);
        SmbDereferenceConnect(ConnectObject, SMB_REF_ASSOCIATE);
        return STATUS_INVALID_HANDLE;
    }

    ASSERT(ConnectObject->TcpContext == NULL);

    //
    // We need to hold acqure 3 locks here because we need to
    //      1. remove ConnectObject from Device->UnassociatedConnectionList
    //      2. insert ConnectObject into ClientObject->AssociatedConnectionList
    //      3. update ConnectObject->ClientObject
    //
    SMB_ACQUIRE_SPINLOCK(Device, Irql);
    SMB_ACQUIRE_SPINLOCK_DPC(ClientObject);
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);

    if (IsAssociated(ConnectObject)) {
        status = STATUS_INVALID_HANDLE;
        goto cleanup1;
    }

    ASSERT(EntryIsInList(&Device->UnassociatedConnectionList, &ConnectObject->Linkage));
    ASSERT(EntryIsInList(&Device->ClientList, &ClientObject->Linkage));

    ConnectObject->ClientObject = ClientObject;
    RemoveEntryList(&ConnectObject->Linkage);
    InsertTailList(&ClientObject->AssociatedConnection, &ConnectObject->Linkage);

    status = STATUS_SUCCESS;

    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    SMB_RELEASE_SPINLOCK_DPC(ClientObject);
    SMB_RELEASE_SPINLOCK(Device, Irql);

    SmbDereferenceConnect(ConnectObject, SMB_REF_ASSOCIATE);

    //
    // We're done, release the reference
    //
    ObDereferenceObject(AddressObject);
    return status;

cleanup1:
    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    SMB_RELEASE_SPINLOCK_DPC(ClientObject);
    SMB_RELEASE_SPINLOCK(Device, Irql);

cleanup:
    if (AddressObject) {
        ObDereferenceObject(AddressObject);
        AddressObject = NULL;
    }
    if (ConnectObject) SmbDereferenceConnect(ConnectObject, SMB_REF_ASSOCIATE);
    if (ClientObject)  SmbDereferenceClient(ClientObject, SMB_REF_ASSOCIATE);
    return status;
}

NTSTATUS
DisAssociateAddress(
    PSMB_CONNECT    ConnectObject
    )
/*++

Routine Description:

    This routine do the disassociation stuff. It can be called from
        1. TDI_DISASSOCIATE_ADDRESS
        2. SmbCloseConnection

Arguments:

Return Value:

--*/
{
    KIRQL               Irql;
    PSMB_CLIENT_ELEMENT ClientObject;
    PSMB_DEVICE         Device;

    PAGED_CODE();

    SmbDoDisconnect(ConnectObject);

    if (SMB_IDLE != ConnectObject->State) {
        ASSERT(0);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ClientObject = InterlockedExchangePointer(&ConnectObject->ClientObject, NULL);
    if (NULL == ClientObject) {
        return STATUS_SUCCESS;
    }

    //
    // Remove the ConnectObject from the list in ClientObject
    //
    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    SMB_ACQUIRE_SPINLOCK_DPC(ClientObject);
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);

    ASSERT (EntryIsInList(&ClientObject->AssociatedConnection, &ConnectObject->Linkage));
    ASSERT (ConnectObject->TcpContext == NULL);

    ConnectObject->ClientObject = NULL;

    //
    // Disassociate the ConnectObject with the ClientObject
    //
    RemoveEntryList(&ConnectObject->Linkage);
    InitializeListHead(&ConnectObject->Linkage);
    Device = ConnectObject->Device;

    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    SMB_RELEASE_SPINLOCK_DPC(ClientObject);
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    //
    // Put the ConnectObject back into the Device->UnassociatedConnectionList
    //
    SMB_ACQUIRE_SPINLOCK(Device, Irql);
    InsertTailList(&Device->UnassociatedConnectionList, &ConnectObject->Linkage);
    SMB_RELEASE_SPINLOCK(Device, Irql);

    SmbDereferenceClient(ClientObject, SMB_REF_ASSOCIATE);

    return STATUS_SUCCESS;
}

NTSTATUS
SmbDisAssociateAddress(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
/*++

Routine Description:

    TDI_DISASSOCIATE_ADDRESS

Arguments:

Return Value:

    STATUS_INVALID_HANDLE           If the connection FileObject is corrupted.

    STATUS_INVALID_DEVICE_REQUEST   the connection object is not in assocated state or
                                    it is not in disconnected state (SMB_IDLE).

    STATUS_SUCCESS                  success

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PSMB_CONNECT            ConnectObject;
    NTSTATUS                status;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    ConnectObject = SmbVerifyAndReferenceConnect(IrpSp->FileObject, SMB_REF_ASSOCIATE);
    if (NULL == ConnectObject) {
        ASSERT(0);
        return STATUS_INVALID_HANDLE;
    }

    SmbPrint(SMB_TRACE_CALL, ("SmbDisAssociateAddress: connect %p\n", ConnectObject));

    if (IsDisAssociated(ConnectObject)) {
        ASSERT(0);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    status = DisAssociateAddress(ConnectObject);

    ASSERT(status != STATUS_PENDING);
    SmbDereferenceConnect(ConnectObject, SMB_REF_ASSOCIATE);
    return status;
}

NTSTATUS
SmbListen(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
/*++

Routine Description:

    TDI_LISTEN
        SRV is not using this. Postpone the implementation.

Arguments:

Return Value:

--*/
{
    SmbPrint(SMB_TRACE_CALL, ("SmbListen\n"));
    ASSERT(0);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbAccept(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
/*++

Routine Description:

    TDI_ACCEPT
        SRV is not using this. Postpone the implementation.

Arguments:

Return Value:

--*/
{
    SmbPrint(SMB_TRACE_CALL, ("SmbAccept\n"));
    ASSERT(0);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbCloseConnection(
    PSMB_DEVICE Device,
    PIRP        Irp
    )
/*++

Routine Description:

    This routine close a connection.

    A connection should be in disconnected state before it can be closed.

    Note: it is unnecessary for a TDI client to disassociate the connection
          endpoint from its associated transport address before making a
          close-connection-endpoint request. If necessary, we should simulate
          the effects of a disassociation. 

Arguments:

Return Value:

    STATUS_INVALID_HANDLE           If the connection FileObject is corrupted.

    STATUS_INVALID_DEVICE_REQUEST   the connection object is not in disconnected state.

    STATUS_SUCCESS                  Success

--*/
{
    PIO_STACK_LOCATION  IrpSp;
    KIRQL               Irql;
    PSMB_CONNECT        ConnectObject;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if (IrpSp->FileObject->FsContext2 != UlongToPtr(SMB_TDI_CONNECT)) {
        ASSERT (0);
        return STATUS_INTERNAL_ERROR;
    }

    //
    // Invalidate FsContext2 so that the object cannot be used anymore.
    //
    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    IrpSp->FileObject->FsContext2 = UlongToPtr(SMB_TDI_INVALID);
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    if (NULL == IrpSp->FileObject->FsContext) {
        ASSERT(0);
        return STATUS_INVALID_HANDLE;
    }

    ConnectObject = (PSMB_CONNECT)IrpSp->FileObject->FsContext;

    SmbPrint(SMB_TRACE_CALL, ("SmbCloseConnection: Connect %p\n", ConnectObject));

    DisAssociateAddress(ConnectObject);

    SMB_ACQUIRE_SPINLOCK(Device, Irql);

    ASSERT(EntryIsInList(&Device->UnassociatedConnectionList, &ConnectObject->Linkage));

    RemoveEntryList(&ConnectObject->Linkage);
    InsertTailList(&Device->PendingDeleteConnectionList, &ConnectObject->Linkage);

    SMB_RELEASE_SPINLOCK(Device, Irql);

    SmbDereferenceConnect(ConnectObject, SMB_REF_CREATE);

    IrpSp->FileObject->FsContext = NULL;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\sources.inc ===
SOURCES=\
    ..\session.c \
    ..\connect.c \
    ..\receive.c \
    ..\send.c \
    ..\registry.c \
    ..\ioctl.c \
    ..\name.c \
    ..\dgram.c \
    ..\global.c \
    ..\util.c \
    ..\ntpnp.c \
    ..\sock.c \
    ..\dns.c \
    ..\fileio.c \
    ..\tdihndlr.c \
    ..\tdircv.c \
    ..\conncache.c \
    ..\driver2.c \
    ..\hash.c \
    ..\ip2netbios.c \
    ..\init.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\sock.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    sock.c

Abstract:

    Pseudo-socket

Author:

    Jiandong Ruan

Revision History:

    Feb-14-2001     First functional version
    Feb-16-2001     Support IPv4

--*/

#include "precomp.h"
#include "sock.tmh"

NTSTATUS
SmbOpenAddress(
    IN  PUNICODE_STRING     ucDevice,
    IN  PSMB_IP_ADDRESS     addr,
    IN  USHORT              port,
    IN OUT PSMB_TCP_ADDRESS context
    );

NTSTATUS
TdiOpenConnection(
    IN HANDLE               hAddress,
    IN OUT PSMB_TCP_CONNECT Connect,
    IN PVOID                ConnectionContext
    );

NTSTATUS
TdiAssociateConnection(
    IN PSMB_TCP_ADDRESS Address,
    IN PSMB_TCP_CONNECT Connect
    );

NTSTATUS
TdiSetEventHandler(
    PFILE_OBJECT    FileObject,
    ULONG           EventType,
    PVOID           EventHandler,
    PVOID           Context
    );

#pragma alloc_text(PAGE, SmbOpenTcpAddress)
#pragma alloc_text(PAGE, SmbOpenUdpAddress)
#pragma alloc_text(PAGE, SmbOpenAddress)
#pragma alloc_text(PAGE, SmbCloseAddress)
#pragma alloc_text(PAGE, SmbSetTcpEventHandlers)
#pragma alloc_text(PAGE, TdiAssociateConnection)
#pragma alloc_text(PAGE, TdiOpenConnection)
#pragma alloc_text(PAGE, TdiSetEventHandler)

NTSTATUS
SmbSynchTdiCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    This routine doesn't free the IRP. It just signal an event to allow
    the synchronous part of the SMB driver to proceed.

Arguments:


Return Value:


--*/
{
    KeSetEvent((PKEVENT)Context, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SubmitSynchTdiRequest (
    IN PFILE_OBJECT FileObject,
    IN PIRP         Irp
    )

/*++

Routine Description:

    This routine submits a request to TDI and waits for it to complete.

Arguments:

    IN PFILE_OBJECT FileObject - Connection or Address handle for TDI request
    IN PIRP Irp - TDI request to submit.

Return Value:

    NTSTATUS - Final status of request.

--*/

{
    KEVENT      Event;
    NTSTATUS    status;

    PAGED_CODE();

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    // set the address of the routine to be executed when the IRP
    // finishes.  This routine signals the event and allows the code
    // below to continue (i.e. KeWaitForSingleObject)
    //
    IoSetCompletionRoutine(
            Irp,
            (PIO_COMPLETION_ROUTINE)SmbSynchTdiCompletion,
            &Event,
            TRUE,
            TRUE,
            TRUE
            );
    status = IoCallDriver(IoGetRelatedDeviceObject(FileObject), Irp);

    //
    //  If it failed immediately, return now, otherwise wait.
    //
    if (!NT_SUCCESS(status)) {
        SmbPrint(SMB_TRACE_TCP, ("SubmitSynchTdiRequest: Failed to Submit Tdi Request, status = 0x%08lx\n", status));
        SmbTrace(SMB_TRACE_TCP, ("Failed to Submit Tdi Request, %!status!", status));
        return status;
    }

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject (
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
        if (status != STATUS_WAIT_0) {
            ASSERT(0);
            SmbTrace(SMB_TRACE_TCP, ("KeWaitForSingleObject return %!status!", status));
            return status;
        }

        status = Irp->IoStatus.Status;
    }

    SmbPrint(SMB_TRACE_TCP, ("SubmitSynchTdiRequest returns status = 0x%08lx\n", status));
    SmbTrace(SMB_TRACE_TCP, ("returns %!status!", status));
    return (status);
}


PVOID
SmbPrepareTdiAddress(
    IN  PSMB_IP_ADDRESS     addr,               // network order
    IN  USHORT              port,               // network order
    OUT USHORT              *pAddrSize
    )
/*++

Routine Description:

    This function set up an ipaddr in TDI format.

Arguments:

Return Value:

--*/
{
    PTA_IP6_ADDRESS     pIP6Addr = NULL;
    PTA_IP_ADDRESS      pIP4Addr = NULL;
    PVOID               pAddr = NULL;
    USHORT              IpAddrSize;

    if (addr->sin_family == SMB_AF_INET) {
        IpAddrSize = sizeof(TA_IP_ADDRESS);
    } else if (addr->sin_family == SMB_AF_INET6) {
        IpAddrSize = sizeof(TA_IP6_ADDRESS);
    } else {
        SmbTrace(SMB_TRACE_TCP, ("Invalid IP address family"));
        return NULL;
    }

    pAddr = ExAllocatePoolWithTag(NonPagedPool, IpAddrSize, 'jBMS');
    if(NULL == pAddr) {
        return NULL;
    }

    //
    // Setup the IP address
    //
    RtlZeroMemory(pAddr, IpAddrSize);
    if (addr->sin_family == SMB_AF_INET) {
        pIP4Addr = (PTA_IP_ADDRESS)pAddr;

        pIP4Addr->TAAddressCount = 1;
        pIP4Addr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        pIP4Addr->Address[0].AddressLength = sizeof(pIP4Addr->Address[0].Address[0]);
        pIP4Addr->Address[0].Address[0].sin_port = port;
        pIP4Addr->Address[0].Address[0].in_addr  = addr->ip4.sin4_addr;
    } else {
        pIP6Addr = (PTA_IP6_ADDRESS)pAddr;

        pIP6Addr->TAAddressCount = 1;
        pIP6Addr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP6;
        pIP6Addr->Address[0].AddressLength = sizeof(pIP6Addr->Address[0].Address[0]);
        pIP6Addr->Address[0].Address[0].sin6_port = port;
        RtlCopyMemory(pIP6Addr->Address[0].Address[0].sin6_addr, addr->ip6.sin6_addr, sizeof(addr->ip6.sin6_addr));
        pIP6Addr->Address[0].Address[0].sin6_flowinfo = 0;
        pIP6Addr->Address[0].Address[0].sin6_scope_id = addr->ip6.sin6_scope_id;
    }

    *pAddrSize = IpAddrSize;
    return pAddr;
}

NTSTATUS
SmbPrepareEaBuffer(
    IN  PSMB_IP_ADDRESS         addr,
    IN  USHORT                  port,
    PFILE_FULL_EA_INFORMATION   *pEaBuffer,
    USHORT                      *pEaBufferSize
    )
{
    PTA_IP6_ADDRESS     pIP6Addr = NULL;
    PTA_IP_ADDRESS      pIP4Addr = NULL;
    PVOID               pAddr = NULL;
    USHORT              IpAddrSize;
    USHORT              EaBufferSize;
    PFILE_FULL_EA_INFORMATION   EaBuffer = NULL;

    *pEaBuffer     = NULL;
    *pEaBufferSize = 0;

    pAddr = SmbPrepareTdiAddress(addr, port, &IpAddrSize);
    if (NULL == pAddr) {
        return STATUS_NO_MEMORY;
    }

    //
    // Allocate Ea buffer for holding the TdiTransportAddress and the IP6 address
    //
    EaBufferSize = sizeof(FILE_FULL_EA_INFORMATION) +
                    TDI_TRANSPORT_ADDRESS_LENGTH +
                    IpAddrSize;
    EaBuffer = (PFILE_FULL_EA_INFORMATION)ExAllocatePoolWithTag(NonPagedPool, EaBufferSize, 'jBMS');
    if(NULL == EaBuffer) {
        ExFreePool(pAddr);
        return STATUS_NO_MEMORY;
    }

    //
    // Setup the ea buffer
    //
    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags           = 0;
    EaBuffer->EaNameLength    = TDI_TRANSPORT_ADDRESS_LENGTH;
    EaBuffer->EaValueLength   = IpAddrSize;
    RtlCopyMemory(EaBuffer->EaName, TdiTransportAddress, EaBuffer->EaNameLength + 1);
    RtlCopyMemory((PUCHAR)EaBuffer->EaName + EaBuffer->EaNameLength + 1, pAddr, IpAddrSize);

    ExFreePool(pAddr);
    *pEaBuffer     = EaBuffer;
    *pEaBufferSize = EaBufferSize;
    return STATUS_SUCCESS;
}

NTSTATUS
SmbOpenAddress(
    IN  PUNICODE_STRING     ucDevice,
    IN  PSMB_IP_ADDRESS     addr,
    IN  USHORT              port,
    IN OUT PSMB_TCP_ADDRESS context
    )
/*++

Routine Description:

    Open a Tcp/Udp address

Arguments:

    ucDevice    The device name of TCP or UDP

    addr        The local address to be opened (network order)

    port        The local port to be opened (network order)
                We will claim for exclusive ownership for a non-zero port
                This happens when SMB device open 445 port (for listening).
                For outbound connection request, SMB use 0 port which means
                TCP will pick up a proper port # for us.

    context     The TCP context used to receive the opened address object

Return Value:

    STATUS_SUCCES
    failed

--*/
{
    OBJECT_ATTRIBUTES   AddrAttr = { 0 };
    NTSTATUS            status = STATUS_SUCCESS;
    USHORT              EaBufferSize = 0;
    PFILE_FULL_EA_INFORMATION   EaBuffer = NULL;
    IO_STATUS_BLOCK     IoStatusBlock = { 0 };
    HANDLE              AddrHandle = NULL;
    PFILE_OBJECT        AddrFileObject = NULL;

    PAGED_CODE();

    if (context->AddressHandle || context->AddressObject) {
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }

    AddrHandle = NULL;
    AddrFileObject = NULL;

    status = SmbPrepareEaBuffer(addr, port, &EaBuffer, &EaBufferSize);
    BAIL_OUT_ON_ERROR(status);

    //
    // Open address with the transport
    //
    InitializeObjectAttributes(
            &AddrAttr,
            ucDevice,
            OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
            NULL,
            NULL
            );
    status = ZwCreateFile(
            &AddrHandle,
            GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
            &AddrAttr,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            (port)? 0: FILE_SHARE_READ | FILE_SHARE_WRITE,  // Claim exclusive ownership for SMB port
            FILE_OPEN_IF,
            0,
            EaBuffer,
            EaBufferSize
            );

    ExFreePool(EaBuffer);
    EaBuffer = NULL;

    SmbPrint(SMB_TRACE_TCP, ("ZwCreateFile returns status 0x%08lx\n", status));
    BAIL_OUT_ON_ERROR(status);
    status = IoStatusBlock.Status;
    BAIL_OUT_ON_ERROR(status);

    status = ObReferenceObjectByHandle(
            AddrHandle,
            0,
            NULL,
            KernelMode,
            &AddrFileObject,
            NULL
            );
    BAIL_OUT_ON_ERROR(status);

    ObDereferenceObject(AddrFileObject);
    context->AddressHandle = AddrHandle;
    context->AddressObject = AddrFileObject;
    context->DeviceObject  = IoGetRelatedDeviceObject(AddrFileObject);
 
    SmbTrace(SMB_TRACE_TCP, ("%!status!", status));
    return status;

cleanup:
    if (NULL != EaBuffer) {
        ExFreePool(EaBuffer);
        EaBuffer = NULL;
    }
    if (AddrHandle) {
        ZwClose(AddrHandle);
    }
    SmbTrace(SMB_TRACE_TCP, ("%!status!", status));
    return status;
}

NTSTATUS
SmbCloseAddress(
    IN OUT PSMB_TCP_ADDRESS context
    )
{
    NTSTATUS status;

    PAGED_CODE();

    if (NULL == context->AddressHandle ||
        NULL == context->AddressObject ||
        NULL == context->DeviceObject) {
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }

    status = ZwClose(context->AddressHandle);
    if (status == STATUS_SUCCESS) {
        context->AddressHandle = NULL;
        context->AddressObject = NULL;
        context->DeviceObject  = NULL;
    } else {
        ASSERT (0);
    }

    return status;
}

NTSTATUS
SmbOpenTcpAddress(
    IN  PSMB_IP_ADDRESS     addr,
    IN  USHORT              port,
    IN OUT PSMB_TCP_ADDRESS context
    )
{
    UNICODE_STRING  ucName = { 0 };
    NTSTATUS        status = STATUS_SUCCESS;
    NTSTATUS LocStatus = STATUS_SUCCESS;
    ULONG uIPv6ProtectionLevel = SmbCfg.uIPv6Protection;

    PAGED_CODE();

    if (addr->sin_family == SMB_AF_INET) {
        RtlInitUnicodeString(&ucName, DD_TCP_DEVICE_NAME);
    } else if (addr->sin_family == SMB_AF_INET6) {
        RtlInitUnicodeString(&ucName, DD_TCPV6_DEVICE_NAME);
    } else {
        return STATUS_INVALID_PARAMETER;
    }

    status = SmbOpenAddress(&ucName, addr, port, context);
    BAIL_OUT_ON_ERROR(status);

    if (addr->sin_family == SMB_AF_INET6) {
        LocStatus = SmbSetTcpInfo (
                context->AddressObject,
                CL_TL_ENTITY,
                INFO_CLASS_PROTOCOL,
                AO_OPTION_PROTECT,
                INFO_TYPE_ADDRESS_OBJECT,
                uIPv6ProtectionLevel
                );

        SmbTrace(SMB_TRACE_TCP, ("Set IPv6Protection Level %d on AddrOb %p %!status!",
                uIPv6ProtectionLevel, context->AddressObject, LocStatus));
    }

cleanup:
    return status;
}

NTSTATUS
SmbOpenUdpAddress(
    IN  PSMB_IP_ADDRESS     addr,
    IN  USHORT              port,
    IN OUT PSMB_TCP_ADDRESS context
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    UNICODE_STRING  ucName;
    NTSTATUS        status;

    PAGED_CODE();

    if (addr->sin_family == SMB_AF_INET) {
        RtlInitUnicodeString(&ucName, DD_UDP_DEVICE_NAME);
    } else if (addr->sin_family == SMB_AF_INET6) {
        RtlInitUnicodeString(&ucName, DD_UDPV6_DEVICE_NAME);
    } else {
        return STATUS_INVALID_PARAMETER;
    }

    status = SmbOpenAddress(&ucName, addr, port, context);
    BAIL_OUT_ON_ERROR(status);

cleanup:
    return status;
}

NTSTATUS
SmbSetTcpEventHandlers(
    PFILE_OBJECT    AddressObject,
    PVOID           Context
    )
{
    NTSTATUS    status;

    PAGED_CODE();

    status = TdiSetEventHandler(
            AddressObject,
            TDI_EVENT_CONNECT,
            SmbTdiConnectHandler,
            Context
            );
    BAIL_OUT_ON_ERROR(status);

    status = TdiSetEventHandler(
            AddressObject,
            TDI_EVENT_DISCONNECT,
            SmbTdiDisconnectHandler,
            Context
            );
    BAIL_OUT_ON_ERROR(status);

    status = TdiSetEventHandler(
            AddressObject,
            TDI_EVENT_RECEIVE,
            SmbTdiReceiveHandler,
            Context
            );
    BAIL_OUT_ON_ERROR(status);

cleanup:
    return status;
}

NTSTATUS
TdiOpenConnection(
    IN HANDLE               hAddress,
    IN OUT PSMB_TCP_CONNECT Connect,
    IN PVOID                ConnectionContext
    )
/*++

Routine Description:

    Open a TCP connection.

Arguments:


Return Value:


--*/
{
    UNICODE_STRING              RelativeDeviceName = { 0, 0, NULL };
    USHORT                      EaBufferSize;
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    OBJECT_ATTRIBUTES           ObAttr;
    HANDLE                      ConnectHandle;
    PFILE_OBJECT                ConnectObject;
    IO_STATUS_BLOCK             IoStatusBlock;
    NTSTATUS                    status;

    ConnectHandle = NULL;
    EaBuffer = NULL;

    PAGED_CODE();

    //
    // Open the connection object with TCP
    //
    InitializeObjectAttributes(
            &ObAttr,
            &RelativeDeviceName,
            OBJ_KERNEL_HANDLE,
            hAddress,     // Use a relative file handle
            NULL
            );
    EaBufferSize = sizeof(FILE_FULL_EA_INFORMATION) +
                    TDI_CONNECTION_CONTEXT_LENGTH +
                    sizeof(CONNECTION_CONTEXT);
    EaBuffer = (PFILE_FULL_EA_INFORMATION)
                    ExAllocatePoolWithTag(NonPagedPool, EaBufferSize, 'xBMS');
    if (NULL == EaBuffer) {
        return STATUS_NO_MEMORY;
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags           = 0;
    EaBuffer->EaNameLength    = TDI_CONNECTION_CONTEXT_LENGTH;
    EaBuffer->EaValueLength   = sizeof(CONNECTION_CONTEXT);
    RtlCopyMemory(EaBuffer->EaName, TdiConnectionContext, EaBuffer->EaNameLength + 1);

    ASSERT(sizeof(PVOID) == sizeof(CONNECTION_CONTEXT));
    RtlCopyMemory(
            (PUCHAR)EaBuffer->EaName + EaBuffer->EaNameLength + 1,
            &ConnectionContext,
            sizeof(CONNECTION_CONTEXT)
            );
    status = ZwCreateFile(
            &ConnectHandle,
            GENERIC_READ | GENERIC_WRITE,
            &ObAttr,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            0,
            FILE_CREATE,
            0,
            EaBuffer,
            EaBufferSize
            );
    ExFreePool(EaBuffer);
    EaBuffer = NULL;

    SmbPrint(SMB_TRACE_TCP, ("ZwCreateFile returns status 0x%08lx\n", status));
    BAIL_OUT_ON_ERROR(status);
    status = IoStatusBlock.Status;
    BAIL_OUT_ON_ERROR(status);

    status = ObReferenceObjectByHandle(
            ConnectHandle,
            0,
            NULL,
            KernelMode,
            &ConnectObject,
            NULL
            );
    BAIL_OUT_ON_ERROR(status);
    ObDereferenceObject(ConnectObject);

    Connect->ConnectHandle = ConnectHandle;
    Connect->ConnectObject = ConnectObject;

    if (SmbCfg.EnableNagling) {
        status = SmbSetTcpInfo(
                ConnectObject,
                CO_TL_ENTITY,
                INFO_CLASS_PROTOCOL,
                TCP_SOCKET_NODELAY,
                INFO_TYPE_CONNECTION,
                FALSE
                );
    } else {
        status = SmbSetTcpInfo(
                ConnectObject,
                CO_TL_ENTITY,
                INFO_CLASS_PROTOCOL,
                TCP_SOCKET_NODELAY,
                INFO_TYPE_CONNECTION,
                TRUE
                );
    }
    if (STATUS_SUCCESS != status) {
        SmbPrint(SMB_TRACE_TCP, ("Nagling: <0x%x> EnableNagling=%d\n",
                status, SmbCfg.EnableNagling));
        SmbTrace(SMB_TRACE_TCP, ("Nagling: %!status! EnableNagling=%d",
                status, SmbCfg.EnableNagling));
        status = STATUS_SUCCESS;
    }
    return status;

cleanup:
    if (NULL != EaBuffer) {
        ExFreePool(EaBuffer);
        EaBuffer = NULL;
    }
    if (ConnectHandle) {
        ZwClose(ConnectHandle);
    }
    return status;
}

NTSTATUS
TdiAssociateConnection(
    IN PSMB_TCP_ADDRESS Address,
    IN PSMB_TCP_CONNECT Connect
    )
{
    PIRP        Irp;
    NTSTATUS    status;

    PAGED_CODE();

    ASSERT(Address->DeviceObject == IoGetRelatedDeviceObject(Connect->ConnectObject));

    Irp = SmbAllocIrp(Address->DeviceObject->StackSize);
    if (Irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    TdiBuildAssociateAddress(
            Irp,
            Address->DeviceObject,
            Connect->ConnectObject,
            NULL,
            NULL,
            Address->AddressHandle
            );
    status = SubmitSynchTdiRequest(Connect->ConnectObject, Irp);
    SmbFreeIrp(Irp);

    SmbTrace (SMB_TRACE_TCP, ("return %!status!", status));
    SmbPrint (SMB_TRACE_TCP, ("TdiAssociateConnection return 0x%08lx\n", status));
    return status;
}

NTSTATUS
SmbOpenTcpConnection(
    IN PSMB_TCP_ADDRESS Address,
    IN OUT PSMB_TCP_CONNECT Connect,
    IN PVOID                ConnectionContext
    )
/*++

Routine Description:

    Open a TCP connection and associate it with the Address

Arguments:


Return Value:


--*/
{
    NTSTATUS        status;
    SMB_TCP_CONNECT LocalConnect;

    if (NULL == Connect || Connect->ConnectHandle || Connect->ConnectObject) {
        ASSERT (0);
        return STATUS_INVALID_PARAMETER;
    }
    if (NULL == Address->AddressHandle ||
        NULL == Address->AddressObject ||
        NULL == Address->DeviceObject) {
        ASSERT (0);
        return STATUS_INVALID_PARAMETER;
    }

    status = TdiOpenConnection(
            Address->AddressHandle,
            &LocalConnect,
            ConnectionContext
            );
    BAIL_OUT_ON_ERROR(status);

    status = TdiAssociateConnection(
            Address,
            &LocalConnect
            );
    if (status != STATUS_SUCCESS) {
        ZwClose(LocalConnect.ConnectHandle);
    } else {
        *Connect = LocalConnect;
    }

cleanup:
    return status;
}

NTSTATUS
SmbCloseTcpConnection(
    IN OUT PSMB_TCP_CONNECT Connect
    )
{
    NTSTATUS    status;

    if (NULL == Connect->ConnectHandle || NULL == Connect->ConnectObject) {
        ASSERT(0);
        return STATUS_INVALID_PARAMETER;
    }

    status = ZwClose(Connect->ConnectHandle);
    if (STATUS_SUCCESS == status) {
        Connect->ConnectHandle = NULL;
        Connect->ConnectObject = NULL;
    }
    return status;
}

NTSTATUS
TdiConnectComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PSMB_CONNECT_CONTEXT Context
    )
{
    PSMB_CONNECT    ConnectObject;

    ConnectObject = (PSMB_CONNECT)Context->ClientContext;

    ASSERT(Context->AsyncInternalContext);
    if (Context->AsyncInternalContext) {
        ExFreePool(Context->AsyncInternalContext);
        Context->AsyncInternalContext = NULL;
    }

    SmbTrace (SMB_TRACE_CONNECT, ("pIrp %p complete with %!status! info=%d",
                Irp, Irp->IoStatus.Status, (ULONG)(Irp->IoStatus.Information)));

    Context->status = Irp->IoStatus.Status;
    Context->Completion((PSMB_ASYNC_CONTEXT)Context);

    //
    // We're actully using the client's IRP. The Context->Completion will complete it.
    // Don't allow IO manager to proceed.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

void
SmbAsyncConnect(
    IN PSMB_IP_ADDRESS      ipaddr,
    IN USHORT               port,
    IN PSMB_CONNECT_CONTEXT Context
    )
{
    PIRP                        Irp = NULL;
    PDEVICE_OBJECT              DeviceObject = NULL;
    PSMB_CONNECT                ConnectObject = NULL;
    PTDI_CONNECTION_INFORMATION SendInfo = NULL;
    PTRANSPORT_ADDRESS          pAddr = NULL;
    USHORT                      IpAddrSize = 0;
    NTSTATUS                    status = STATUS_SUCCESS;

#if DBG
    if (ipaddr->sin_family == SMB_AF_INET6) {
        CHAR    target_ip[40];

        inet_ntoa6(target_ip, 40, &ipaddr->ip6);
        SmbPrint(SMB_TRACE_CALL, ("SmbAsyncConnect %s:%d\n", target_ip, ntohs(port)));
    }
#endif

    ConnectObject = (PSMB_CONNECT)Context->ClientContext;

    //
    // Use the client's IRP so that the client can cancel it
    //
    Irp = ConnectObject->PendingIRPs[SMB_PENDING_CONNECT];
    if (NULL == Irp) {
        ASSERT(0);
        SmbTrace(SMB_TRACE_CONNECT, ("Internal Error: Expect a non-NULL Pending Connect Irp"));
        Context->status = STATUS_INTERNAL_ERROR;
        Context->Completion((PSMB_ASYNC_CONTEXT)Context);
        return;
    }

    pAddr = SmbPrepareTdiAddress(ipaddr, port, &IpAddrSize);
    if (pAddr == NULL) {
        SmbTrace(SMB_TRACE_CONNECT, ("cannot prepare TA_IP_ADDRESS or TA_IP6_ADDRESS"));
        Context->status = STATUS_INTERNAL_ERROR;
        Context->Completion((PSMB_ASYNC_CONTEXT)Context);
        return;
    }

    SendInfo = ExAllocatePoolWithTag(NonPagedPool, sizeof(SendInfo[0]) + IpAddrSize, 'uBMS');
    if (NULL == SendInfo) {
        ExFreePool(pAddr);
        Context->status = STATUS_INSUFFICIENT_RESOURCES;
        Context->Completion((PSMB_ASYNC_CONTEXT)Context);
        return;
    }
    SendInfo->UserDataLength = 0;
    SendInfo->UserData       = NULL;
    SendInfo->OptionsLength  = 0;
    SendInfo->Options        = NULL;
    SendInfo->RemoteAddressLength = IpAddrSize;
    SendInfo->RemoteAddress       = (&SendInfo[1]);
    RtlCopyMemory(SendInfo->RemoteAddress, pAddr, IpAddrSize);
    ExFreePool(pAddr);
    pAddr = NULL;

    DeviceObject = IoGetRelatedDeviceObject(Context->TcpConnect.ConnectObject);

    Context->AsyncInternalContext = SendInfo;

    TdiBuildConnect(
            Irp,
            DeviceObject,
            Context->TcpConnect.ConnectObject,
            (PVOID)TdiConnectComplete,
            Context,
            NULL,                           // No timeout
            SendInfo,
            NULL
            );
    status = IoCallDriver(DeviceObject, Irp);

    SmbTrace (SMB_TRACE_CONNECT, ("pIrp %p return %!status!", Irp, status));
}

NTSTATUS
SmbTcpDisconnect(
    PSMB_TCP_CONTEXT TcpContext,
    LONG             TimeoutMilliseconds,
    ULONG            Flags
    )
{
    PIRP                Irp = NULL;
    PFILE_OBJECT        FileObject = NULL;
    PDEVICE_OBJECT      DeviceObject = NULL;
    LARGE_INTEGER       Timeout = { 0 };
    NTSTATUS            status = STATUS_SUCCESS;

    FileObject = TcpContext->Connect.ConnectObject;
    if (NULL == FileObject) {
        ASSERT (0);
        SmbTrace(SMB_TRACE_CONNECT, ("NULL FileObject !!!!"));
        return STATUS_INVALID_PARAMETER;
    }

    DeviceObject = IoGetRelatedDeviceObject(FileObject);
    Irp = SmbAllocIrp(DeviceObject->StackSize);
    if (NULL == Irp) {
        SmbTrace(SMB_TRACE_CONNECT, ("no free IRP !!!!"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Timeout.QuadPart = -Int32x32To64(TimeoutMilliseconds, SMB_ONE_MILLISECOND);
    TdiBuildDisconnect(
            Irp,
            DeviceObject,
            FileObject,
            NULL,
            NULL,
            &Timeout,
            Flags,
            NULL,
            NULL
            );

    status = SubmitSynchTdiRequest(FileObject, Irp);
    SmbFreeIrp(Irp);

    SmbTrace (SMB_TRACE_CONNECT, ("return %!status!", status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\tdihndlr.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    tdihndlr.c

Abstract:

    TDI event handlers

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "ip2netbios.h"
#include "tdihndlr.tmh"

NTSTATUS
TdiAcceptCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PSMB_TCP_CONNECT TcpConnect
    );

void
Inet_ntoa_nb(
    ULONG Address,
    PCHAR Buffer
    )
/*++

Routine Description:    (Lifted from NBT4 tdihndlr.c)

This routine converts an IP address into its "dotted quad" representation.  The IP address is
expected to be in network byte order. No attempt is made to handle the other dotted notions as
defined in in.h.  No error checking is done: all address values are permissible including 0
and -1.  The output string is blank padded to 16 characters to make the name look like a netbios
name.

The string representation is in ANSI, not UNICODE.

The caller must allocate the storage, which should be 16 characters.

Arguments:

    Address - IP address in network byte order
    Buffer - Pointer to buffer to receive string representation, ANSI

Return Value:

void

--*/

{
    ULONG i;
    UCHAR byte, c0, c1, c2;
    PCHAR p = Buffer;

    for (i = 0; i < 4; i++) {
        byte = (UCHAR) (Address & 0xff);

        c0 = byte % 10;
        byte /= 10;
        c1 = byte % 10;
        byte /= 10;
        c2 = byte;

        if (c2 != 0) {
            *p++ = c2 + '0';
            *p++ = c1 + '0';
        } else if (c1 != 0) {
            *p++ = c1 + '0';
        }
        *p++ = c0 + '0';

        if (i != 3)
            *p++ = '.';

        Address >>= 8;
    }

    // space pad up to 16 characters
    while (p < (Buffer + 16)) {
        *p++ = ' ';
    }
}


NTSTATUS
SmbTdiConnectHandler(
    IN PSMB_DEVICE      DeviceObject,
    IN LONG             RemoteAddressLength,
    IN PTRANSPORT_ADDRESS RemoteAddress,
    IN LONG             UserDataLength,
    IN PVOID            UserData,
    IN LONG             OptionsLength,
    IN PVOID            Options,
    OUT CONNECTION_CONTEXT  *ConnectionContext,
    OUT PIRP                *AcceptIrp
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PSMB_CLIENT_ELEMENT SmbServer = NULL;
    KIRQL               Irql;
    PTDI_IND_CONNECT    evConnect = NULL;
    PVOID               ConEvContext = NULL;
    NTSTATUS            status = STATUS_SUCCESS, client_status = STATUS_SUCCESS;
    PVOID               ClientConnectContext = NULL;
    PIRP                ClientAcceptIrp = NULL;
    PIO_STACK_LOCATION  IrpSp = NULL;
    PSMB_CONNECT        ConnectObject = NULL;
    PSMB_CLIENT_ELEMENT ClientObject = NULL;
    PSMB_TCP_CONTEXT    TcpContext = NULL;
    TA_NETBIOS_ADDRESS  TaAddr;
    PTCPSEND_DISPATCH   FastSend = NULL;
    BOOL                NetbiosNameAllocated = FALSE;

    UNREFERENCED_PARAMETER(UserDataLength);
    UNREFERENCED_PARAMETER(UserData);
    UNREFERENCED_PARAMETER(OptionsLength);
    UNREFERENCED_PARAMETER(Options);

    //
    // Some smoke checks before acquiring the lock
    //
    if (SmbCfg.Unloading) {
        status = STATUS_DELETE_PENDING;
        goto error;
    }

    if (RemoteAddressLength < sizeof(TA_IP_ADDRESS) &&
        RemoteAddressLength < sizeof(TA_IP6_ADDRESS)) {
        status = STATUS_INVALID_ADDRESS;
        goto error;
    }

    if (RemoteAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP &&
        RemoteAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP6) {
        status = STATUS_INVALID_ADDRESS_COMPONENT;
        goto error;
    }

    //
    // Prevent SmbServer to go away by referencing the SmbServer
    //
    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    SmbServer = DeviceObject->SmbServer;
    if (NULL == SmbServer) {
        SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);
        status = STATUS_REMOTE_NOT_LISTENING;
        goto error;
    }
    SmbReferenceClient(SmbServer, SMB_REF_CONNECT);
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    if (SmbServer->PendingAcceptNumber > DeviceObject->MaxBackLog) {
        status = STATUS_NETWORK_BUSY;
        goto error;
    }

    SMB_ACQUIRE_SPINLOCK(SmbServer, Irql);
    if (!IsListEmpty(&SmbServer->ListenHead)) {
        ASSERTMSG ("TDI_LISTEN isn't supported", 0);
        SMB_RELEASE_SPINLOCK(SmbServer, Irql);

        status = STATUS_NOT_SUPPORTED;
        goto error;
    }
    evConnect = SmbServer->evConnect;
    ConEvContext = SmbServer->ConEvContext;
    SMB_RELEASE_SPINLOCK(SmbServer, Irql);

    SmbTrace(SMB_TRACE_CONNECT, ("Receive connect request"));

    //
    // No Listen
    //
    if (NULL == evConnect || NULL == ConEvContext) {
        status = STATUS_REMOTE_NOT_LISTENING;
        goto error;
    }

    //
    // Srv expects a TDI_ADDRESS_NETBIOS
    //
    TaAddr.TAAddressCount = 1;
    TaAddr.Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS;
    TaAddr.Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    TaAddr.Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    TcpContext = NULL;
    if (RemoteAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP) {
        FastSend = DeviceObject->Tcp4.FastSend;
        TcpContext = SmbAllocateInbound(&DeviceObject->Tcp4);
        Inet_ntoa_nb(((PTA_IP_ADDRESS)RemoteAddress)->Address[0].Address[0].in_addr,
                TaAddr.Address[0].Address[0].NetbiosName);

        SmbPrint(SMB_TRACE_CONNECT, ("Connect request from %15.15s:%d\n",
                    TaAddr.Address[0].Address[0].NetbiosName,
                    htons(((PTA_IP_ADDRESS)RemoteAddress)->Address[0].Address[0].sin_port)
                    ));

        SmbTrace(SMB_TRACE_CONNECT, ("Connect request from %!ipaddr!:%!port!",
                    ((PTA_IP_ADDRESS)RemoteAddress)->Address[0].Address[0].in_addr,
                    ((PTA_IP_ADDRESS)RemoteAddress)->Address[0].Address[0].sin_port
                    ));

    } else {
        SmbTrace(SMB_TRACE_CONNECT, ("Connect request from %!IPV6ADDR!:%!port!",
                    (struct in6_addr*)&(((PTA_IP6_ADDRESS)RemoteAddress)->Address[0].Address[0].sin6_addr),
                    ((PTA_IP6_ADDRESS)RemoteAddress)->Address[0].Address[0].sin6_port
                    ));

        if (GetNetbiosNameFromIp6Address(((BYTE *)((PTA_IP6_ADDRESS)RemoteAddress)->Address[0].Address[0].sin6_addr),
                TaAddr.Address[0].Address[0].NetbiosName)) {

            NetbiosNameAllocated = TRUE;
            FastSend = DeviceObject->Tcp6.FastSend;
            TcpContext = SmbAllocateInbound(&DeviceObject->Tcp6);

            TODO("TdiConnectHandler: convert IP6 address into Netbios address");
        }

    }

    if (TcpContext == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error;
    }

    ClientConnectContext = NULL;
    ClientAcceptIrp = NULL;
    client_status = (*evConnect)(
            ConEvContext,
            sizeof(TaAddr),
            &TaAddr,
            0,
            NULL,
            0,
            NULL,
            &ClientConnectContext,
            &ClientAcceptIrp
            );

    SmbTrace(SMB_TRACE_CONNECT, ("evConnect: %!status! pIrp %p ClientContext %p",
                        client_status, ClientAcceptIrp, ClientConnectContext));

    if (client_status != STATUS_MORE_PROCESSING_REQUIRED) {
        SmbFreeInbound(TcpContext);
        goto error;
    }

    ASSERT(ClientAcceptIrp);
    if (NULL == ClientAcceptIrp) {
        status = STATUS_INVALID_PARAMETER;
        goto error;
    }

    IrpSp = IoGetCurrentIrpStackLocation(ClientAcceptIrp);
    ConnectObject = IrpSp->FileObject->FsContext;
    if (IrpSp->FileObject->FsContext2 != UlongToPtr(SMB_TDI_CONNECT) ||
                ConnectObject->State != SMB_IDLE ||
                NULL != ConnectObject->TcpContext ||
                NULL == (ClientObject = ConnectObject->ClientObject)) {
        ClientAcceptIrp->IoStatus.Status = STATUS_INVALID_HANDLE;
        ClientAcceptIrp->IoStatus.Information = 0;
        IoCompleteRequest(ClientAcceptIrp, IO_NETWORK_INCREMENT);

        SmbFreeInbound(TcpContext);

        ASSERT (0);

        status = STATUS_INTERNAL_ERROR;
        goto error;
    }

    ConnectObject->Originator = FALSE;
    ConnectObject->FastSend = FastSend;

    SmbReuseConnectObject(ConnectObject);

    //
    // Reset the disconnection originator informaiton
    //
    ResetDisconnectOriginator(ConnectObject);

    ASSERT (TcpContext->Address.AddressHandle == NULL);
    ASSERT (TcpContext->Address.AddressObject == NULL);
    ASSERT (TcpContext->Connect.ConnectHandle);
    ASSERT (TcpContext->Connect.ConnectObject);

    SMB_ACQUIRE_SPINLOCK(DeviceObject, Irql);
    ASSERT(ClientObject == SmbServer);
    SMB_ACQUIRE_SPINLOCK_DPC(ClientObject);
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);

    ASSERT(EntryIsInList(&ClientObject->AssociatedConnection, &ConnectObject->Linkage));
    ASSERT (ConnectObject->ClientContext == ClientConnectContext);

    //
    // Don't use SMB_CONNECTING because TCP4 could indicate the data before the AcceptCompletion
    // is called.
    //
    ConnectObject->State = SMB_CONNECTED;
    ConnectObject->TcpContext = TcpContext;
    TcpContext->Connect.pLastUprCnt = TcpContext->Connect.UpperConnect = ConnectObject;

    RtlCopyMemory(ConnectObject->RemoteName, TaAddr.Address[0].Address[0].NetbiosName, NETBIOS_NAME_SIZE);
    if (RemoteAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP) {
        ConnectObject->RemoteIpAddress.sin_family = SMB_AF_INET;
        ConnectObject->RemoteIpAddress.ip4.sin4_addr = 
                    ((PTA_IP_ADDRESS)RemoteAddress)->Address[0].Address[0].in_addr;
    } else {
        ConnectObject->RemoteIpAddress.sin_family = SMB_AF_INET6;
        RtlCopyMemory(ConnectObject->RemoteIpAddress.ip6.sin6_addr,
                ((PTA_IP6_ADDRESS)RemoteAddress)->Address[0].Address[0].sin6_addr,
                sizeof (ConnectObject->RemoteIpAddress.ip6.sin6_addr));
        ConnectObject->RemoteIpAddress.ip6.sin6_scope_id = 
                ((PTA_IP6_ADDRESS)RemoteAddress)->Address[0].Address[0].sin6_scope_id;
    }

    //
    // Move the conection from AssociatedConnection list into PendingAcceptConnection
    //
    RemoveEntryList(&ConnectObject->Linkage);
    InsertTailList(&ClientObject->PendingAcceptConnection, &ConnectObject->Linkage);
    ClientObject->PendingAcceptNumber++;
    ASSERT(ClientObject->PendingAcceptNumber > 0);

    ConnectObject->PendingIRPs[SMB_PENDING_ACCEPT] = ClientAcceptIrp;

    SmbReferenceConnect(ConnectObject, SMB_REF_CONNECT);
    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    SMB_RELEASE_SPINLOCK_DPC(ClientObject);
    SMB_RELEASE_SPINLOCK(DeviceObject, Irql);

    TdiBuildAccept(
            ClientAcceptIrp,
            IoGetRelatedDeviceObject(TcpContext->Connect.ConnectObject),
            TcpContext->Connect.ConnectObject,
            TdiAcceptCompletion,
            &TcpContext->Connect,
            NULL,
            NULL
            );

    *ConnectionContext = &TcpContext->Connect;
    *AcceptIrp = ClientAcceptIrp;

    IoSetNextIrpStackLocation(ClientAcceptIrp);
    SmbDereferenceClient(SmbServer, SMB_REF_CONNECT);

    SmbTrace(SMB_TRACE_CONNECT, ("return STATUS_MORE_PROCESSING_REQUIRED to TCP/IP pIrp %p ClientContext %p",
                        (*AcceptIrp), (*ConnectionContext)));

    return(STATUS_MORE_PROCESSING_REQUIRED);

error:
    SmbTrace(SMB_TRACE_CONNECT, ("Refuse the connection: status=%!status! client status=%!status!",
                    status, client_status));

    if (NetbiosNameAllocated) {
        FreeNetbiosNameForIp6Address(((BYTE *)((PTA_IP6_ADDRESS)RemoteAddress)->Address[0].Address[0].sin6_addr));
    }

    if (SmbServer) {
        SmbDereferenceClient(SmbServer, SMB_REF_CONNECT);
    }
    return STATUS_CONNECTION_REFUSED;
}


NTSTATUS
TdiAcceptCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PSMB_TCP_CONNECT TcpConnect
    )
{
    PSMB_CONNECT        ConnectObject;
    PSMB_CLIENT_ELEMENT ClientObject;
    KIRQL               Irql;
    PSMB_TCP_CONTEXT    TcpContext;

    //
    // For performance consideration: check it before acquiring a lock:
    // This will allow SmbSynchAttackDetection and SmbSynchAttackCleanup
    // to run concurrently most of the time.
    //
    if (NULL == TcpConnect->UpperConnect) {
        goto cleanup2;
    }

    //
    // Grab the global lock to synchronize with the DoDisconnect
    //

    SMB_ACQUIRE_SPINLOCK (SmbCfg.SmbDeviceObject, Irql);
    ConnectObject = (PSMB_CONNECT)TcpConnect->UpperConnect;
    if (NULL == ConnectObject) {
        goto cleanup;
    }

    ClientObject = ConnectObject->ClientObject;
    ASSERT (NULL != ClientObject);
    ASSERT (NULL != ConnectObject->ClientObject);
    ASSERT (TcpConnect == &ConnectObject->TcpContext->Connect);

    SMB_ACQUIRE_SPINLOCK_DPC(ClientObject);
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);

    ASSERT (ConnectObject->PendingIRPs[SMB_PENDING_ACCEPT] == Irp);
    ConnectObject->PendingIRPs[SMB_PENDING_ACCEPT] = NULL;

    ASSERT (EntryIsInList(&ClientObject->PendingAcceptConnection, &ConnectObject->Linkage));
    ASSERT (ClientObject->PendingAcceptNumber > 0);

    RemoveEntryList(&ConnectObject->Linkage);
    ClientObject->PendingAcceptNumber--;

    SmbTrace(SMB_TRACE_CONNECT, ("TDI_ACCEPT pIrp %p complete with %!status!",
                        Irp, Irp->IoStatus.Status));

    //
    // The connection could have been disconnected when TCP completes the accepting IRP!!!
    // Only move it to active list if it hasn't been disconnected.
    //
    if (Irp->IoStatus.Status != STATUS_SUCCESS || ConnectObject->State != SMB_CONNECTED) {
        // BREAK_WHEN_TAKE();

        TcpContext = ConnectObject->TcpContext;
        ConnectObject->TcpContext = NULL;
        SmbDelayedDestroyTcpContext(TcpContext);

        InsertTailList(&ClientObject->AssociatedConnection, &ConnectObject->Linkage);
        ConnectObject->State = SMB_IDLE;
        if (Irp->IoStatus.Status == STATUS_SUCCESS) {
            Irp->IoStatus.Status = STATUS_CONNECTION_RESET;
        }
        if (ConnectObject->RemoteIpAddress.sin_family == SMB_AF_INET6) {
            FreeNetbiosNameForIp6Address(ConnectObject->RemoteIpAddress.ip6.sin6_addr_bytes);
            ConnectObject->RemoteIpAddress.sin_family = SMB_AF_INVALID_INET6;
        }
    } else {
        InsertTailList(&ClientObject->ActiveConnection, &ConnectObject->Linkage);
    }
    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    SMB_RELEASE_SPINLOCK_DPC(ClientObject);

cleanup:
    SMB_RELEASE_SPINLOCK(SmbCfg.SmbDeviceObject, Irql);
    if (ConnectObject) {
        SmbDereferenceConnect(ConnectObject, SMB_REF_CONNECT);
    }

cleanup2:
    return STATUS_SUCCESS;
}

NTSTATUS
TdiSetEventHandler(
    PFILE_OBJECT    FileObject,
    ULONG           EventType,
    PVOID           EventHandler,
    PVOID           Context
    )
{
    PIRP        Irp;
    KEVENT      Event;
    NTSTATUS    status;
    PDEVICE_OBJECT  DeviceObject;

    PAGED_CODE();

    DeviceObject  = IoGetRelatedDeviceObject(FileObject);

    Irp = SmbAllocIrp(DeviceObject->StackSize);
    if (Irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent(&Event, NotificationEvent, FALSE);
    TdiBuildSetEventHandler(
            Irp,
            DeviceObject,
            FileObject,
            SmbSynchTdiCompletion,
            &Event,
            EventType,
            EventHandler,
            Context
            );

    status = IoCallDriver(DeviceObject, Irp);
    if (!NT_SUCCESS(status)) {
        SmbFreeIrp(Irp);
        return status;
    }

    if (status == STATUS_PENDING) {
        status = KeWaitForSingleObject(
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );
        ASSERT(status == STATUS_WAIT_0);
        status = Irp->IoStatus.Status;
    }
    SmbFreeIrp(Irp);
    return status;
}

NTSTATUS 
SmbTdiDisconnectHandler (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_TCP_CONNECT TcpConnect,
    IN LONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    )
{
    KIRQL           Irql;
    NTSTATUS        status;
    PSMB_CONNECT    ConnectObject;

    //
    // Reference the connection object make sure it won't go away
    //
    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    ConnectObject = (PSMB_CONNECT)TcpConnect->UpperConnect;
    if (NULL == ConnectObject) {
        SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);
        return STATUS_SUCCESS;
    }
    SmbReferenceConnect(ConnectObject, SMB_REF_DISCONNECT);
    SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);

    SmbTrace (SMB_TRACE_CONNECT, ("TCP Disconnect Indication: ConnOb %p Flag %d",
                        ConnectObject, DisconnectFlags));

    status = CommonDisconnectHandler(DeviceObject, ConnectObject, DisconnectFlags);
    SmbDereferenceConnect(ConnectObject, SMB_REF_DISCONNECT);
    return status;
}

NTSTATUS 
CommonDisconnectHandler (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            DisconnectFlags
    )
{
    PSMB_CLIENT_ELEMENT     ClientObject;
    KIRQL                   Irql;
    PTDI_IND_DISCONNECT     evDisConnect;
    PVOID                   DiscEvContext;
    PVOID                   ClientContext;
    PSMB_TCP_CONTEXT        TcpContext;
    NTSTATUS                status;

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);

    ClientObject = ConnectObject->ClientObject;
    if (NULL == ClientObject) {
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        return STATUS_SUCCESS;
    }

    SmbTrace(SMB_TRACE_CONNECT, ("receive disconnection indication for %p", ConnectObject));

    TcpContext = ConnectObject->TcpContext;
    ConnectObject->TcpContext = NULL;

    if (NULL == TcpContext) {
        ASSERT(ConnectObject->State == SMB_IDLE);
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        return STATUS_SUCCESS;
    }
    ASSERT(ConnectObject->State == SMB_CONNECTED || ConnectObject->State == SMB_CONNECTING);
    ConnectObject->State = SMB_IDLE;

    SaveDisconnectOriginator(ConnectObject, SMB_DISCONNECT_FROM_TRANSPORT);

    evDisConnect  = ClientObject->evDisconnect;
    DiscEvContext = ClientObject->DiscEvContext;
    ClientContext = ConnectObject->ClientContext;
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    //
    // Cleanup the endpoint so that the client can reuse it
    //
    // Don't wait for the tcp-layer disconnect completion since
    // the disconnection isn't generated by our clients.
    //
    SmbDisconnectCleanup(DeviceObject, ClientObject, ConnectObject,
            TcpContext, TDI_DISCONNECT_ABORT, FALSE);

    //
    // Notify our client
    //
    if (evDisConnect) {
        status = (*evDisConnect)(
                DiscEvContext,
                ClientContext,
                0,
                NULL,
                0,
                NULL,
                DisconnectFlags
                );
        SmbTrace(SMB_TRACE_CONNECT, ("client returns %!status! for disconnect event", status));
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\smbstat.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    smbstat.c

Abstract:

    Platform independent utility functions

Author:

    Jiandong Ruan

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <tdi.h>
#include "smbioctl.h"

#define DD_SMB6_EXPORT_NAME          L"\\Device\\Smb6"

HANDLE
OpenSmb(LPWSTR Name);

NTSTATUS
SmbStop(HANDLE);

NTSTATUS
SmbStart(HANDLE);

void _cdecl main(void)
{
    LPWSTR  CommandLine;
    int     Argc;
    LPWSTR  *Argv;
    HANDLE  handle;

    setlocale(LC_ALL, "");

    CommandLine = GetCommandLineW();
    if (NULL == CommandLine) {
        exit (1);
    }
    Argv = CommandLineToArgvW(CommandLine, &Argc);

    handle = OpenSmb(DD_SMB6_EXPORT_NAME);
    if (handle == NULL) {
        exit(1);
    }

    SmbStop(handle);

    NtClose(handle);
}

HANDLE
OpenSmb(
    LPWSTR Name
    )
{
    UNICODE_STRING      ucName;
    OBJECT_ATTRIBUTES   ObAttr;
    HANDLE              StreamHandle;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            status;

    RtlInitUnicodeString(&ucName, Name);

    InitializeObjectAttributes(
            &ObAttr,
            &ucName,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );
    status = NtCreateFile (
            &StreamHandle,
            SYNCHRONIZE | GENERIC_EXECUTE,
            &ObAttr,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0
            );
    if (status != STATUS_SUCCESS) {
        return NULL;
    }
    return StreamHandle;
}

NTSTATUS
CallDriver(
    HANDLE  hSmb,
    DWORD   Ioctl,
    PVOID   OutputBuffer,
    ULONG   OutputLength,
    PVOID   InputBuffer,
    ULONG   InputLength
    )
{
    NTSTATUS    status;
    IO_STATUS_BLOCK iosb;

    status = NtDeviceIoControlFile(
            hSmb,
            NULL,
            NULL,
            NULL,
            &iosb,
            Ioctl,
            InputBuffer,
            InputLength,
            OutputBuffer,
            OutputLength
            );
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                hSmb,
                TRUE,
                NULL
                );
        if (NT_SUCCESS(status)) {
            status = iosb.Status;
        }
    }

    return status;
}

NTSTATUS
SmbStop(
    HANDLE  hSmb
    )
{
    NTSTATUS    status;

    status = CallDriver(
            hSmb,
            IOCTL_SMB_STOP,
            NULL,
            0,
            NULL,
            0
            );
    if (status != STATUS_SUCCESS) {
        printf ("SmbStop: return 0x%08lx\n", status);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\util.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Platform independent utility functions

Author:

    Jiandong Ruan

Revision History:

--*/
#include "precomp.h"
#include "util.tmh"

BOOL
EntryIsInList(PLIST_ENTRY ListHead, PLIST_ENTRY SearchEntry)
/*++

Routine Description:

    This routine search SearchEntry in the list ListHead.
    NOTE: proper lock should be held before calling this function.

Arguments:

    ListHead    the head of the list
    SearchEntry the entry to be searched

Return Value:

    TRUE        if the entry is in the list
    FALSE       otherwise

--*/
{
    PLIST_ENTRY Entry;
    KIRQL       Irql;

    Irql = KeGetCurrentIrql();

    if (Irql < DISPATCH_LEVEL) {
        ASSERT(0);
        return FALSE;
    }

    Entry = ListHead->Flink;
    while(Entry != ListHead) {
        if (Entry == SearchEntry) {
            return TRUE;
        }
        Entry = Entry->Flink;
    }

    return FALSE;
}

PIRP
SmbAllocIrp(
    CCHAR   StackSize
    )
{
    KIRQL   Irql = 0;
    PIRP    Irp = NULL;

    Irp = IoAllocateIrp(StackSize, FALSE);
    if (NULL == Irp) {
        return NULL;
    }

    KeAcquireSpinLock(&SmbCfg.UsedIrpsLock, &Irql);
    InsertTailList(&SmbCfg.UsedIrps, &Irp->ThreadListEntry);
    KeReleaseSpinLock(&SmbCfg.UsedIrpsLock, Irql);
    return Irp;
}

VOID
SmbFreeIrp(
    PIRP    Irp
    )
{
    KIRQL   Irql = 0;

    if (NULL == Irp) {
        ASSERT(0);
        return;
    }
    KeAcquireSpinLock(&SmbCfg.UsedIrpsLock, &Irql);
    ASSERT(EntryIsInList(&SmbCfg.UsedIrps, &Irp->ThreadListEntry));
    RemoveEntryList(&Irp->ThreadListEntry);
    KeReleaseSpinLock(&SmbCfg.UsedIrpsLock, Irql);

    //
    // Make the driver verifier happy
    //
    InitializeListHead(&Irp->ThreadListEntry);
    IoFreeIrp(Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\test\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <tdi.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#include "ip6util.h"
#include "smbioctl.h"
#include "svclib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\drv\precomp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    precompiled header file

Author:

    Jiandong Ruan

Revision History:

--*/

#include "smbtrace.h"

////////////////////////////////////////////////////////////////////////////////
//                          B U I L D    O P T I O N S
////////////////////////////////////////////////////////////////////////////////

//
// We have two directorys 'sys' and 'lib'. If you put this definition
// in the C_DEFINES of the "sources" file, you need to make sure the
// sys\sources and lib\sources has the same definition.
//
// We'd better to put them here
//

//
// RDR/SRV expect a minimum indication size.
//
#define NO_ZERO_BYTE_INDICATE

//
// Enable the feature for debugging the RefCount
//
#define REFCOUNT_DEBUG

//
// Enable the built-in tracing for TdiReceive event handler
// 
#define ENABLE_RCV_TRACE

//
// Using lookaside list prohibits driver verifier from capturing buffer overrun.
// We'd better turn it off at this development stage.
//
//#define NO_LOOKASIDE_LIST


////////////////////////////////////////////////////////////////////////////////
//                  I N C L U D E     F I L E S
////////////////////////////////////////////////////////////////////////////////
#include <stddef.h>

#include <ntosp.h>
#include <zwapi.h>
#include <ndis.h>
#include <cxport.h>
#include <ip.h>         // for IPRcvBuf
#include <ipinfo.h>     // for route-lookup defs
#include <tdi.h>
#include <ntddip.h>     // for \Device\Ip I/O control codes
#include <ntddip6.h>     // for \Device\Ip I/O control codes
#include <ntddtcp.h>    // for \Device\Tcp I/O control codes
#include <ipfltinf.h>   // for firewall defs
#include <ipfilter.h>   // for firewall defs
#include <tcpinfo.h>    // for TCP_CONN_*

#include <tdikrnl.h>
#include <tdiinfo.h>    // for CONTEXT_SIZE, TDIObjectID
#include <tdistat.h>    // for TDI status codes

#include <align.h>
#include <windef.h>

#include <tcpinfo.h>

#ifndef __SMB_KDEXT__
    #include <wmistr.h>
    #include <wmiguid.h>
    #include <wmilib.h>
    #include <wmikm.h>
    #include <evntrace.h>
#endif // __SMB_KDEXT__

#include "common.h"
#include "ip6util.h"
#include "smbioctl.h"
#include "smbtdi.h"
#include "debug.h"
#include "hash.h"
#include "ip2netbios.h"
#include "types.h"
#include "init.h"
#include "registry.h"
#include "ntpnp.h"
#include "ioctl.h"
#include "session.h"
#include "dgram.h"
#include "name.h"
#include "tdihndlr.h"
#include "fileio.h"
#include "dns.h"
#include "smb.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\drv\driver.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    Driver.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the
    SMB Transport and other routines that are specific to the NT implementation
    of a driver.

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"

#include "driver.tmh"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
SmbUnload2(
    IN PDRIVER_OBJECT DriverObject
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SmbUnload2)
#endif
//*******************  Pageable Routine Declarations ****************

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the SMB device driver.
    This routine creates the device object for the SMB
    device and calls a routine to perform other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS            status;

    PAGED_CODE();

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    status = SmbDriverEntry(DriverObject, RegistryPath, NULL);
    BAIL_OUT_ON_ERROR(status);

    DriverObject->MajorFunction[IRP_MJ_CREATE]                  = (PDRIVER_DISPATCH)SmbDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = (PDRIVER_DISPATCH)SmbDispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = (PDRIVER_DISPATCH)SmbDispatchInternalCtrl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 = (PDRIVER_DISPATCH)SmbDispatchCleanup;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = (PDRIVER_DISPATCH)SmbDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = (PDRIVER_DISPATCH)SmbDispatchPnP;
    DriverObject->DriverUnload                                  = SmbUnload2;

    return (status);

cleanup:
    SmbUnload2(DriverObject);
    return status;
}

VOID
SmbUnload2(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();

    SmbUnload(DriverObject);
    WPP_CLEANUP(DriverObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\tdircv.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    tdircv.c

Abstract:

    TDI receive event handlers

    TdiReceiveHandler is the only entry, which is called by TCP.

    TdiReceiveHandler acquires the spinlock and increase the refcount
    of the ConnectObject. Then it forward the control to the event
    handler for current receive state.

    The state event handler won't release the spinlock unless it's
    going to call functions outside our control, for example,
        IoCompleteionRequest and the client event handler.

Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"
#include "tdircv.tmh"

#if DBG
BOOL
IsValidWaitingHeaderState(
    IN PSMB_CONNECT     ConnectObject
    );
BOOL
IsValidIndicateState(
    IN PSMB_CONNECT     ConnectObject
    );
#endif

VOID
KillConnection(
    IN PSMB_CONNECT     ConnectObject
    );

NTSTATUS
IndicateToClient(
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu
    );

NTSTATUS
SmbNewMessage(
    IN PSMB_CONNECT     ConnectObject,
    IN LONG             BytesIndicated,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    );

NTSTATUS
SmbBuildPartialMdl(
    PMDL    SourceMdl,
    PMDL    DestMdl,
    LONG    Offset
    );

NTSTATUS
SmbClientRcvCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PSMB_CONNECT     ConnectObject
    );

#define TAKE(Bytes)                 \
    ASSERT((Bytes) <= BytesIndicated); \
    BytesIndicated -= (Bytes);        \
    BytesAvailable -= (Bytes);        \
    (PUCHAR)Tsdu   += (Bytes);        \
    *BytesTaken    += (Bytes)

#if DBG
DWORD
SmbGetMdlChainByteCount(
    IN PMDL Mdl
    )
/*++

Routine Description:

    This routine returns the total size of buffers described by the MDL chain.

Arguments:


Return Value:


--*/
{
    DWORD   Size;

    Size = 0;
    while(Mdl) {
        Size += MmGetMdlByteCount(Mdl);
        Mdl = Mdl->Next;
    }
    return Size;
}
#endif // DBG

PIRP
SmbNextReceiveRequest(
    IN PSMB_CONNECT     ConnectObject
    )
/*++

Routine Description:

    Get a client TDI_RECEIVE request queued in the pending list

Arguments:

Return Value:

    NULL    If there is no pending receive request
    PIRP    The client IRP pending in the RcvList

--*/
{
    PLIST_ENTRY     entry;
    PIRP            PendingIrp;
    KIRQL           Irql;

    if (IsListEmpty(&ConnectObject->RcvList)) {
        return NULL;
    }

    entry = RemoveHeadList(&ConnectObject->RcvList);

    PendingIrp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);
    IoAcquireCancelSpinLock(&Irql);
    IoSetCancelRoutine(PendingIrp, NULL);
    IoReleaseCancelSpinLock(Irql);
    return PendingIrp;
}

VOID
SmbCompleteReceiveRequest(
    IN PSMB_CONNECT     ConnectObject
    )
/*++

Routine Description:

    Complete the ConnectObject->ClientIrp

Arguments:

Return Value:

--*/
{
    PIRP                        ClientIrp = NULL;
    PIO_STACK_LOCATION          IrpSp = NULL;
    PTDI_REQUEST_KERNEL_RECEIVE ClientRcvParams = NULL;
    LONG                        BytesReceived = 0;

    ASSERT (NULL != ConnectObject->ClientIrp);
    ASSERT (NULL != ConnectObject->ClientMdl);
    ASSERT (0 == ConnectObject->BytesRemaining || 0 == ConnectObject->FreeBytesInMdl);
    ASSERT (ConnectObject->FreeBytesInMdl >= 0);

    BytesReceived = ConnectObject->ClientBufferSize - ConnectObject->FreeBytesInMdl;
    ASSERT (BytesReceived >= 0);

    PUSH_LOCATION(ConnectObject, 0x200000);

    ClientIrp = ConnectObject->ClientIrp;
    ConnectObject->ClientIrp = NULL;
    ConnectObject->ClientMdl = NULL;
    IrpSp = IoGetCurrentIrpStackLocation(ClientIrp);
    ClientRcvParams = (PTDI_REQUEST_KERNEL_RECEIVE)&IrpSp->Parameters;

    if (0 == ConnectObject->BytesRemaining) {

        ConnectObject->StateRcvHandler = WaitingHeader;
        ConnectObject->HeaderBytesRcved = 0;
        ClientRcvParams->ReceiveFlags |= TDI_RECEIVE_ENTIRE_MESSAGE;
        ClientIrp->IoStatus.Status = STATUS_SUCCESS;
        PUSH_LOCATION(ConnectObject, 0x200010);

    } else {

        ConnectObject->StateRcvHandler = SmbPartialRcv;
        ClientRcvParams->ReceiveFlags &= (~TDI_RECEIVE_ENTIRE_MESSAGE);
        ClientIrp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
        PUSH_LOCATION(ConnectObject, 0x200020);

    }

    ClientIrp->IoStatus.Information = BytesReceived;
    ConnectObject->BytesReceived   += BytesReceived;

    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    IoCompleteRequest(ClientIrp, IO_NETWORK_INCREMENT);
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);

    SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
}

NTSTATUS
SmbFillIrp(
    IN PSMB_CONNECT     ConnectObject,
    IN PVOID            Tsdu,
    IN LONG             BytesIndicated,
    OUT LONG            *BytesTaken
    )
/*++

Routine Description:


Arguments:


Return Value:

    STATUS_SUCCESS                  if the IRP has been completed
    STATUS_MORE_PROCESSING_REQUIRED if the IRP hasn't been completed. More data
                                    is needed to fill the IRP.
--*/
{
    LONG        BytesToCopy = 0, BytesCopied = 0;
    NTSTATUS    status;

    ASSERT(BytesIndicated > 0);

    ASSERT(BytesIndicated <= ConnectObject->BytesRemaining);

    BytesToCopy = SMB_MIN(ConnectObject->FreeBytesInMdl, BytesIndicated);
    BytesCopied = 0;
    status = TdiCopyBufferToMdl(
            Tsdu,
            0,
            BytesToCopy,
            ConnectObject->ClientMdl,
            ConnectObject->ClientBufferSize - ConnectObject->FreeBytesInMdl,
            &BytesCopied
            );
    ASSERT(status == STATUS_SUCCESS);
    *BytesTaken = BytesCopied;

    ConnectObject->FreeBytesInMdl -= BytesCopied;
    ConnectObject->BytesRemaining -= BytesCopied;

    if (ConnectObject->FreeBytesInMdl) {
        ASSERT (BytesIndicated == BytesCopied);
    }

    if (0 == ConnectObject->BytesRemaining || 0 == ConnectObject->FreeBytesInMdl) {
        ASSERTMSG("Hmm. Never see this", ConnectObject->BytesRemaining == 0);

        SmbCompleteReceiveRequest(ConnectObject);

        return STATUS_SUCCESS;
    }

    ASSERT (BytesIndicated == BytesCopied);
    ConnectObject->StateRcvHandler = SmbPartialRcv;
    ASSERT (ConnectObject->BytesInIndicate || IsValidPartialRcvState(ConnectObject));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SmbPrepareReceiveIrp(
    IN PSMB_CONNECT     ConnectObject
    )
{
    NTSTATUS    status;
    LONG        RcvLength;
    PIRP        ClientIrp = NULL;

    status = SmbBuildPartialMdl(
            ConnectObject->ClientMdl,
            ConnectObject->PartialMdl,
            ConnectObject->ClientBufferSize - ConnectObject->FreeBytesInMdl
            );
    ASSERT (STATUS_SUCCESS == status);

    ClientIrp = ConnectObject->ClientIrp;

    RcvLength = SMB_MIN(ConnectObject->BytesRemaining, ConnectObject->FreeBytesInMdl);
    ASSERT(RcvLength > 0);

    MmGetSystemAddressForMdlSafe(ConnectObject->PartialMdl, HighPagePriority);

    // ASSERT(ConnectObject->FreeBytesInMdl >= ConnectObject->BytesRemaining);

    TdiBuildReceive(
            ClientIrp,
            IoGetRelatedDeviceObject(ConnectObject->TcpContext->Connect.ConnectObject),
            ConnectObject->TcpContext->Connect.ConnectObject,
            (PVOID)SmbClientRcvCompletion,
            ConnectObject,
            ConnectObject->PartialMdl,
            TDI_RECEIVE_NORMAL,
            RcvLength
            );
    ConnectObject->StateRcvHandler = SmbPartialRcv;
    ASSERT (ConnectObject->BytesInIndicate || IsValidPartialRcvState(ConnectObject));
}

NTSTATUS
IndicateToClient(
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu
    )
/*++

Routine Description:

    This level indication handle the cooridination between SmbReceive and Receive
    Event Handler.

Arguments:


Return Value:


--*/
{
    NTSTATUS            status;
    PTDI_IND_RECEIVE    evReceive = NULL;
    PVOID               RcvEvContext = NULL;
    PIRP                ClientIrp = NULL;
    LONG                BytesToCopy = 0, BytesCopied = 0, ClientBytesTaken = 0;
    PIO_STACK_LOCATION          IrpSp = NULL;
    PTDI_REQUEST_KERNEL_RECEIVE ClientRcvParams = NULL;

    *BytesTaken = 0;

    ASSERT(ConnectObject->ClientMdl == NULL);
    ASSERT(ConnectObject->ClientIrp == NULL);

    PUSH_LOCATION(ConnectObject, 0x1000);

    ASSERT(BytesIndicated <= ConnectObject->BytesRemaining);
    ASSERT(BytesIndicated <= BytesAvailable);
    ASSERT(BytesAvailable <= ConnectObject->CurrentPktLength);

    ClientBytesTaken = 0;
    //
    // First fill pending requests if any.
    //
    while (NULL != (ClientIrp = SmbNextReceiveRequest(ConnectObject))) {
        PUSH_LOCATION(ConnectObject, 0x1010);

        BREAK_WHEN_TAKE();

        ConnectObject->ClientIrp = ClientIrp;
        ConnectObject->ClientMdl = ClientIrp->MdlAddress;

        IrpSp = IoGetCurrentIrpStackLocation(ClientIrp);
        ClientRcvParams = (PTDI_REQUEST_KERNEL_RECEIVE)&IrpSp->Parameters;
        ConnectObject->ClientBufferSize = (LONG)ClientRcvParams->ReceiveLength;
        ConnectObject->FreeBytesInMdl   = ConnectObject->ClientBufferSize;

        if (BytesIndicated == 0) {
            PUSH_LOCATION(ConnectObject, 0x1020);
            SmbPrepareReceiveIrp(ConnectObject);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        status = SmbFillIrp(ConnectObject, Tsdu, BytesIndicated, &ClientBytesTaken);
        TAKE(ClientBytesTaken);

        if (status != STATUS_SUCCESS) {
            ASSERT (status == STATUS_MORE_PROCESSING_REQUIRED);

            ASSERT (0 != ConnectObject->FreeBytesInMdl);
            ASSERT (IsValidPartialRcvState(ConnectObject));

            PUSH_LOCATION(ConnectObject, 0x1030);
            SmbPrepareReceiveIrp(ConnectObject);
            return status;
        }

        if (0 == ConnectObject->BytesRemaining) {
            ASSERT(0 == BytesIndicated);
            ASSERT (IsValidWaitingHeaderState(ConnectObject));
            PUSH_LOCATION(ConnectObject, 0x1040);
            return STATUS_SUCCESS;
        }

        ASSERT(BytesIndicated > 0);
    }

    ASSERT(BytesAvailable > 0);

    evReceive    = ConnectObject->ClientObject->evReceive;
    RcvEvContext = ConnectObject->ClientObject->RcvEvContext;
    if (evReceive == NULL) {
        PUSH_LOCATION(ConnectObject, 0x1050);
        return STATUS_SUCCESS;
    }

    ClientBytesTaken = 0;
    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    SmbPrint(SMB_TRACE_RECEIVE, ("Indication to the client: BytesIndicated=%d BytesAvailable=%d\n",
                BytesIndicated, BytesAvailable));
    status = (*evReceive) (
            RcvEvContext,
            ConnectObject->ClientContext,
            ReceiveFlags,
            (ULONG)BytesIndicated,
            (ULONG)BytesAvailable,
            (PULONG)&ClientBytesTaken,
            Tsdu,
            &ClientIrp
            );
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);

    if (status == STATUS_DATA_NOT_ACCEPTED) {
        ClientBytesTaken = 0;
        PUSH_LOCATION(ConnectObject, 0x1055);
    }

    //
    // The client could disconnect the connection after the spinlock is released
    //
    if (NULL == ConnectObject->TcpContext) {
        // BREAK_WHEN_TAKE();
        SMB_RELEASE_SPINLOCK_DPC(ConnectObject);

        if (status == STATUS_MORE_PROCESSING_REQUIRED && ClientIrp != NULL) {
            ClientIrp->IoStatus.Status      = STATUS_CONNECTION_RESET;
            ClientIrp->IoStatus.Information = 0;
            IoCompleteRequest(ClientIrp, IO_NETWORK_INCREMENT);
        }
        SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);
        PUSH_LOCATION(ConnectObject, 0x1060);
        ConnectObject->ClientIrp = NULL;
        ConnectObject->ClientMdl = NULL;
        return (*BytesTaken)? STATUS_SUCCESS: STATUS_DATA_NOT_ACCEPTED;
    }

    if (ClientBytesTaken > BytesIndicated) {
        PUSH_LOCATION(ConnectObject, 0x1070);

        //
        // Client takes too much data, try to recover
        //
        SmbPrint(SMB_TRACE_RECEIVE, ("IndicateToClient: Client takes too much data "
                    "Connect %p BytesTaken=%d, BytesIndicated=%d BytesAvailable=%d\n",
                ConnectObject, *BytesTaken, BytesIndicated, BytesAvailable));
        SmbTrace(SMB_TRACE_RECEIVE, ("Client takes too much data "
                    "Connect %p BytesTaken=%d, BytesIndicated=%d BytesAvailable=%d",
                ConnectObject, *BytesTaken, BytesIndicated, BytesAvailable));
        ASSERT (0);
        ClientBytesTaken = BytesIndicated;
    }

    TAKE(ClientBytesTaken);
    ConnectObject->BytesRemaining -= ClientBytesTaken;
    ConnectObject->BytesReceived  += ClientBytesTaken;

    //
    // Check if a whole message has been taken by the client
    //
    if (0 == ConnectObject->BytesRemaining) {
        ASSERT (status != STATUS_MORE_PROCESSING_REQUIRED);
        ASSERT(BytesIndicated == 0 && BytesAvailable == 0);
        ConnectObject->StateRcvHandler = WaitingHeader;
        ConnectObject->HeaderBytesRcved = 0;
        PUSH_LOCATION(ConnectObject, 0x1080);
        return status;
    }

    ConnectObject->StateRcvHandler = SmbPartialRcv;
    if (status != STATUS_MORE_PROCESSING_REQUIRED) {
        ASSERT (ClientIrp == NULL);

        PUSH_LOCATION(ConnectObject, 0x1090);
        SmbTrace(SMB_TRACE_RECEIVE, ("Client return %!status! for indication"
                    "Connect %p BytesTaken=%d, BytesIndicated=%d BytesAvailable=%d",
                status, ConnectObject, *BytesTaken, BytesIndicated, BytesAvailable));

        // BREAK_WHEN_TAKE();

        return status;
    }

    //
    // This partial receive case
    //
    ASSERT (ClientIrp != NULL);
    SmbReferenceConnect(ConnectObject, SMB_REF_RECEIVE);

    PUSH_LOCATION(ConnectObject, 0x10a0);

    IrpSp = IoGetCurrentIrpStackLocation(ClientIrp);
    ClientRcvParams = (PTDI_REQUEST_KERNEL_RECEIVE)&IrpSp->Parameters;

    ConnectObject->ClientIrp = ClientIrp;
    ConnectObject->ClientMdl = ClientIrp->MdlAddress;
    ConnectObject->ClientBufferSize = (LONG)ClientRcvParams->ReceiveLength;
    ConnectObject->FreeBytesInMdl = ConnectObject->ClientBufferSize;

    // ASSERT(ConnectObject->FreeBytesInMdl >= ConnectObject->BytesRemaining);

    if (0 != BytesIndicated) {
        PUSH_LOCATION(ConnectObject, 0x10b0);

        status = SmbFillIrp(ConnectObject, Tsdu, BytesIndicated, &ClientBytesTaken);
        TAKE(ClientBytesTaken);

        if (STATUS_SUCCESS == status) {
            return STATUS_SUCCESS;
        }

        ASSERT (status == STATUS_MORE_PROCESSING_REQUIRED);
        ASSERT(0 == BytesIndicated);
    }

    SmbPrepareReceiveIrp(ConnectObject);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SmbClientRcvCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PSMB_CONNECT     ConnectObject
    )
/*++

Routine Description:

    This routine handle the completion of a client's TDI_RECEIVE request

Arguments:

Return Value:

--*/
{
    KIRQL   Irql;
    LONG    Size;

    PUSH_LOCATION(ConnectObject, 0x2000);

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);

    ASSERT(Irp == ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE]);
    ASSERT(Irp == ConnectObject->ClientIrp);
    ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE] = NULL;

    if (Irp->IoStatus.Status != STATUS_SUCCESS) {
        PUSH_LOCATION(ConnectObject, 0x2010);

        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p status=%!status!",
                    ConnectObject, Irp->IoStatus.Status));

        ConnectObject->ClientIrp = NULL;
        ConnectObject->ClientMdl = NULL;

        KillConnection(ConnectObject);

        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
        return STATUS_SUCCESS;
    }

    Irp->MdlAddress = ConnectObject->ClientMdl;
    MmPrepareMdlForReuse(ConnectObject->PartialMdl);

    SmbPrint(SMB_TRACE_RECEIVE, ("RcvLength = %d\n", Irp->IoStatus.Information));

    Size = (LONG)(Irp->IoStatus.Information);
    ConnectObject->FreeBytesInMdl -= Size;
    ConnectObject->BytesRemaining -= Size;
    ConnectObject->BytesInXport   -= Size;
    if (ConnectObject->BytesInXport < 0) {
        PUSH_LOCATION(ConnectObject, 0x2020);
        ConnectObject->BytesInXport = 0;
    }

    ASSERT (ConnectObject->BytesRemaining >= 0);
    ASSERT (ConnectObject->FreeBytesInMdl >= 0);
    ASSERT (ConnectObject->BytesInXport >= 0);

    ASSERT(Size <= ConnectObject->CurrentPktLength);

    if (ConnectObject->FreeBytesInMdl && ConnectObject->BytesRemaining) {
        PUSH_LOCATION(ConnectObject, 0x2030);

        //
        // In most cases, there shouldn't be no more byte in transport
        //
        ASSERT(ConnectObject->BytesInXport == 0);
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

        //
        // We still need to fill the IRP
        //
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // Before complete the client's IRP, bump up the RefCount
    //
    SmbReferenceConnect(ConnectObject, SMB_REF_RECEIVE);

    //
    // Complete the client's Irp
    //
    SmbCompleteReceiveRequest(ConnectObject);

    //
    // Queue DPC if necessary after complete the client's IRP.
    // If we do it before, there could be a race condition
    //
    // We release the SPINLOCK in SmbCompleteReceiveRequest
    // and if the client's completion routine lower the IRQL,
    // the client coulde receive out-of-order messages
    //
    if (ConnectObject->BytesRemaining == 0 && ConnectObject->BytesInXport > 0) {
        PUSH_LOCATION(ConnectObject, 0x2060);
        //
        // Start an DPC to get the session header
        //
        SmbQueueSessionHeaderDpc(ConnectObject);
    }

    //
    // The ConnectObject should be still valid since we bump up
    // the RefCount above
    //
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
    SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SmbHeaderCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PSMB_CONNECT     ConnectObject
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL           Irql;
    NTSTATUS        status;
    LONG            BytesTaken, BytesRcved;
    PIRP            NewIrp = NULL;
    PDEVICE_OBJECT  TcpDeviceObject = NULL;
    PFILE_OBJECT    TcpFileObject = NULL;

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    PUSH_LOCATION(ConnectObject, 0x3000);
    if (NULL == ConnectObject->TcpContext) {
        PUSH_LOCATION(ConnectObject, 0x3010);
        BREAK_WHEN_TAKE();
        goto cleanup;
    }

    ASSERT(Irp == ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE]);
    ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE] = NULL;

    BytesRcved = (LONG)Irp->IoStatus.Information;
    if ((BytesRcved + ConnectObject->HeaderBytesRcved > SMB_SESSION_HEADER_SIZE) ||
                                (Irp->IoStatus.Status != STATUS_SUCCESS)) {
        PUSH_LOCATION(ConnectObject, 0x3020);
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p status=%!status!",
                    ConnectObject, Irp->IoStatus.Status));
        KillConnection(ConnectObject);
        goto cleanup;
    }

    if (ConnectObject->BytesInXport > BytesRcved) {
        PUSH_LOCATION(ConnectObject, 0x3040);
        ConnectObject->BytesInXport -= BytesRcved;
    } else {
        PUSH_LOCATION(ConnectObject, 0x3050);
        ConnectObject->BytesInXport = 0;
    }
    ConnectObject->HeaderBytesRcved += BytesRcved;
    if (ConnectObject->HeaderBytesRcved < SMB_SESSION_HEADER_SIZE) {
        ASSERT(ConnectObject->BytesInXport == 0);

        PUSH_LOCATION(ConnectObject, 0x3060);

        //
        // Wait for the transport to indicate the remaining bytes
        //
        goto cleanup;
    }

    status = SmbNewMessage(
            ConnectObject,
            0,
            &BytesTaken,
            NULL,
            &NewIrp
            );
    ASSERT(BytesTaken == 0);

    if (ConnectObject->CurrentPktLength == 0) {
        // BREAK_WHEN_TAKE();

        PUSH_LOCATION(ConnectObject, 0x3070);
        ASSERT(status == STATUS_SUCCESS);

        if (ConnectObject->BytesInXport > 0) {
            // BREAK_WHEN_TAKE();

            PUSH_LOCATION(ConnectObject, 0x3080);
            SmbQueueSessionHeaderDpc(ConnectObject);
        }
        goto cleanup;
    }

    if (status != STATUS_MORE_PROCESSING_REQUIRED) {
        PUSH_LOCATION(ConnectObject, 0x3090);

        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p status=%!status!",
                    ConnectObject, status));

        ASSERT(ConnectObject->ClientIrp == NULL);
        ASSERT(ConnectObject->ClientMdl == NULL);
        // ASSERT(!ConnectObject->Originator);
        BREAK_WHEN_TAKE();

        //
        // Client doesn't give us any IRP, let's waiting
        //
        goto cleanup;
    }

    ASSERT(IsValidPartialRcvState(ConnectObject) || IsValidIndicateState(ConnectObject));

    ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE] = NewIrp;

    //
    // Reference the file object while we still holding the spinlock
    //
    TcpFileObject   = ConnectObject->TcpContext->Connect.ConnectObject;
    TcpDeviceObject = IoGetRelatedDeviceObject(TcpFileObject);
    ObReferenceObject(TcpFileObject);
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    status = IoCallDriver(TcpDeviceObject, NewIrp);
    ObDereferenceObject(TcpFileObject);

    SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
    IoFreeMdl(Irp->MdlAddress);
    SmbFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;

cleanup:
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
    IoFreeMdl(Irp->MdlAddress);
    SmbFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SmbBuildPartialMdl(
    PMDL    SourceMdl,
    PMDL    DestMdl,
    LONG    Offset
    )
{
    LONG    TotalLength;
    PMDL    PartialMdl;
    PUCHAR  NewAddress;

    //
    // Find the 1st partial filled MDL
    //
    TotalLength = 0;
    PartialMdl = SourceMdl;
    do {
        if (TotalLength + (LONG)(MmGetMdlByteCount(PartialMdl)) > Offset) {
            break;
        }

        TotalLength += MmGetMdlByteCount(PartialMdl);
        PartialMdl = PartialMdl->Next;
    } while (PartialMdl);

    ASSERT(PartialMdl);
    if (PartialMdl == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    NewAddress = MmGetMdlVirtualAddress(PartialMdl);
    NewAddress += (Offset - TotalLength);
    IoBuildPartialMdl(PartialMdl, DestMdl, NewAddress, 0);
    DestMdl->Next = PartialMdl->Next;

    return STATUS_SUCCESS;
}

#ifdef NO_ZERO_BYTE_INDICATE
NTSTATUS
SmbClientRcvCompletionRdr(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PSMB_CONNECT     ConnectObject
    )
{
    KIRQL       Irql;
    NTSTATUS    status;
    LONG        BytesTaken, RcvLength, BytesCopied;

    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);

    ASSERT(Irp == ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE]);
    ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE] = NULL;

    PUSH_LOCATION(ConnectObject, 0x4000);

    if (Irp->IoStatus.Status != STATUS_SUCCESS) {
        PUSH_LOCATION(ConnectObject, 0x4010);

        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p status=%!status!",
                    ConnectObject, Irp->IoStatus.Status));

        KillConnection(ConnectObject);
        goto cleanup;
    }

    ASSERT(ConnectObject->BytesRemaining == ConnectObject->CurrentPktLength);

    if (ConnectObject->BytesInXport > (LONG)Irp->IoStatus.Information) {
        ConnectObject->BytesInXport -= (LONG)Irp->IoStatus.Information;
        PUSH_LOCATION(ConnectObject, 0x4020);
    } else {
        ConnectObject->BytesInXport = 0;
        PUSH_LOCATION(ConnectObject, 0x4030);
    }
    ConnectObject->BytesInIndicate += (LONG)(Irp->IoStatus.Information);

    //
    // If we didn't get enough bytes, bail out
    //
    if (ConnectObject->BytesInIndicate < MINIMUM_RDR_BUFFER &&
            ConnectObject->BytesInIndicate < ConnectObject->CurrentPktLength) {
        ASSERT(ConnectObject->BytesInXport == 0);

        PUSH_LOCATION(ConnectObject, 0x4040);
        goto cleanup;
    }

    ConnectObject->StateRcvHandler = SmbPartialRcv;
    status = IndicateToClient(
            ConnectObject->Device,
            ConnectObject,
            TDI_RECEIVE_NORMAL | TDI_RECEIVE_ENTIRE_MESSAGE,
            ConnectObject->BytesInIndicate,
            ConnectObject->CurrentPktLength,
            &BytesTaken,
            ConnectObject->IndicateBuffer
            );
    ASSERT(BytesTaken <= ConnectObject->BytesInIndicate);
    ConnectObject->BytesInIndicate -= BytesTaken;
    ASSERT(ConnectObject->BytesInIndicate >= 0);

    if (BytesTaken && ConnectObject->BytesInIndicate) {
        PUSH_LOCATION(ConnectObject, 0x4050);
        RtlMoveMemory(
                ConnectObject->IndicateBuffer + BytesTaken,
                ConnectObject->IndicateBuffer,
                ConnectObject->BytesInIndicate
                );
        ASSERT(STATUS_SUCCESS == status || STATUS_DATA_NOT_ACCEPTED == status);
    }

    if (status != STATUS_MORE_PROCESSING_REQUIRED) {
        PUSH_LOCATION(ConnectObject, 0x4060);
        if (ConnectObject->StateRcvHandler == WaitingHeader && ConnectObject->BytesInXport > 0) {
            ASSERT(ConnectObject->BytesRemaining == 0);
            SmbQueueSessionHeaderDpc(ConnectObject);
        }

        goto cleanup;
    }

    ASSERT(IsValidPartialRcvState(ConnectObject));

    ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE] = ConnectObject->ClientIrp;

    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
    status = IoCallDriver(
            IoGetRelatedDeviceObject(ConnectObject->TcpContext->Connect.ConnectObject),
            ConnectObject->ClientIrp
            );
    SmbPrint(SMB_TRACE_RECEIVE, ("IoCallDriver return 0x%08lx %d of %s\n", status, __LINE__, __FILE__));

    SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
    IoFreeMdl(Irp->MdlAddress);
    SmbFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;

cleanup:
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
    SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);

    IoFreeMdl(Irp->MdlAddress);
    SmbFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

PIRP
SmbPrepareIndicateIrp(
    IN PSMB_CONNECT     ConnectObject
    )
{
    PIRP    Irp = NULL;
    PMDL    Mdl = NULL;
    LONG    BytesToRcv = 0;

    ASSERT(ConnectObject->CurrentPktLength > 0);
    ASSERT(ConnectObject->CurrentPktLength == ConnectObject->BytesRemaining);
    ASSERT(ConnectObject->BytesInIndicate >= 0 && ConnectObject->BytesInIndicate < MINIMUM_RDR_BUFFER);
    ASSERT(ConnectObject->BytesInIndicate < ConnectObject->CurrentPktLength);

    BytesToRcv = SMB_MIN(MINIMUM_RDR_BUFFER - ConnectObject->BytesInIndicate,
                ConnectObject->CurrentPktLength - ConnectObject->BytesInIndicate);

    PUSH_LOCATION(ConnectObject, 0x6000);

    Mdl = IoAllocateMdl(
            ConnectObject->IndicateBuffer + ConnectObject->BytesInIndicate,
            BytesToRcv,
            FALSE,
            FALSE,
            NULL
            );
    Irp = SmbAllocIrp(ConnectObject->Device->DeviceObject.StackSize - 1);
    if (NULL == Mdl || NULL == Irp) {
        goto cleanup;
    }

    PUSH_LOCATION(ConnectObject, 0x6010);

    MmBuildMdlForNonPagedPool(Mdl);

    TdiBuildReceive(
            Irp,
            IoGetRelatedDeviceObject(ConnectObject->TcpContext->Connect.ConnectObject),
            ConnectObject->TcpContext->Connect.ConnectObject,
            (PVOID)SmbClientRcvCompletionRdr,
            ConnectObject,
            Mdl,
            TDI_RECEIVE_NORMAL,
            BytesToRcv
            );

    return Irp;

cleanup:
    PUSH_LOCATION(ConnectObject, 0x6020);

    BREAK_WHEN_TAKE();

    if (NULL != Irp) {
        SmbFreeIrp(Irp);
    }

    if (NULL != Mdl) {
        IoFreeMdl(Mdl);
    }

    KillConnection(ConnectObject);

    return NULL;
}
#endif

NTSTATUS
SmbNewMessage(
    IN PSMB_CONNECT     ConnectObject,
    IN LONG             BytesIndicated,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    )
/*++

Routine Description:

    This routine is called when we just receive a new message header

Arguments:

Return Value:

--*/
 
{
    LONG                BytesToIndicate, BytesCopied, RcvLength;
    NTSTATUS            status;

    *BytesTaken = 0;
    *Irp = NULL;

    ASSERT(ConnectObject->HeaderBytesRcved == SMB_SESSION_HEADER_SIZE);
    ConnectObject->HeaderBytesRcved = 0;

    ConnectObject->CurrentPktLength = (LONG)((htonl(ConnectObject->SmbHeader.Length)) & SMB_HEADER_LENGTH_MASK);
    ConnectObject->BytesRemaining = ConnectObject->CurrentPktLength;
    PUSH_LOCATION(ConnectObject, 0x7000);
    if (ConnectObject->CurrentPktLength == 0) {
        PUSH_LOCATION(ConnectObject, 0x7010);
        return STATUS_SUCCESS;
    }

    BytesToIndicate = SMB_MIN(BytesIndicated, ConnectObject->CurrentPktLength);

    //
    // Don't indicate ZERO byte to srv.sys. Like RDR, srv could access beyond
    // the indicated area in some corner case!!!
    //
#if 0
    if (BytesToIndicate < ConnectObject->CurrentPktLength &&
            ConnectObject->Originator && BytesToIndicate < MINIMUM_RDR_BUFFER) {
#endif
    if (BytesToIndicate < ConnectObject->CurrentPktLength &&
            BytesToIndicate < MINIMUM_RDR_BUFFER) {

        //
        // We need to indicate at least 128 bytes to RDR
        //

        ConnectObject->BytesInIndicate = 0;
        *Irp = SmbPrepareIndicateIrp(ConnectObject);
        if (NULL != *Irp) {
            ConnectObject->StateRcvHandler = Indicate;
            SmbReferenceConnect(ConnectObject, SMB_REF_RECEIVE);
            ASSERT(IsValidIndicateState(ConnectObject));
            PUSH_LOCATION(ConnectObject, 0x7030);
            return STATUS_MORE_PROCESSING_REQUIRED;
        } else {
            PUSH_LOCATION(ConnectObject, 0x7040);
            ASSERT(NULL == ConnectObject->TcpContext);
            return STATUS_DATA_NOT_ACCEPTED;
        }
    }

    ConnectObject->StateRcvHandler = SmbPartialRcv;
    status = IndicateToClient(
            ConnectObject->Device,
            ConnectObject,
            TDI_RECEIVE_NORMAL | TDI_RECEIVE_ENTIRE_MESSAGE,
            BytesToIndicate,
            ConnectObject->CurrentPktLength,
            BytesTaken,
            Tsdu
            );
    ASSERT(*BytesTaken <= BytesToIndicate);

    if (status != STATUS_MORE_PROCESSING_REQUIRED) {
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p status=%!status!",
                        ConnectObject, status));

        ASSERT(ConnectObject->ClientIrp == NULL);
        ASSERT(ConnectObject->ClientMdl == NULL);

        ASSERTMSG("Client doesn't return an IRP",
                status == STATUS_DATA_NOT_ACCEPTED ||
                ConnectObject->BytesRemaining == 0 ||
                ConnectObject->TcpContext == NULL);

        PUSH_LOCATION(ConnectObject, 0x7050);
        return status;
    }

    ASSERT (*BytesTaken == BytesToIndicate);
    ASSERT(IsValidPartialRcvState(ConnectObject));

    *Irp = ConnectObject->ClientIrp;
    PUSH_LOCATION(ConnectObject, 0x7080);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

#if DBG
BOOL
IsValidIndicateState(
    IN PSMB_CONNECT     ConnectObject
    )
{
    if (ConnectObject->BytesRemaining <= 0 || ConnectObject->BytesRemaining != ConnectObject->CurrentPktLength) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidIndicateState: Connect %p BytesRemaining=%d, PktLength=%d\n",
                ConnectObject, ConnectObject->BytesRemaining, ConnectObject->CurrentPktLength));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p BytesRemaining=%d, PktLength=%d",
                ConnectObject, ConnectObject->BytesRemaining, ConnectObject->CurrentPktLength));
        return FALSE;
    }
    if (ConnectObject->BytesInIndicate < 0 || ConnectObject->BytesInIndicate >= MINIMUM_RDR_BUFFER) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidIndicateState: Connect %p BytesInIndicate=%d\n",
                ConnectObject, ConnectObject->BytesInIndicate));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p BytesInIndicate=%d",
                ConnectObject, ConnectObject->BytesInIndicate));
        return FALSE;
    }
    if (NULL != ConnectObject->ClientIrp || NULL != ConnectObject->ClientMdl) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidIndicateState: Connect %p ClientIrp=%p, ClientMdl=%p\n",
                ConnectObject, ConnectObject->ClientIrp, ConnectObject->ClientMdl));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p ClientIrp=%p, ClientMdl=%p",
                ConnectObject, ConnectObject->ClientIrp, ConnectObject->ClientMdl));
        return FALSE;
    }
    if (ConnectObject->StateRcvHandler != Indicate) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidIndicateState: Connect %p Wrong handler\n", ConnectObject));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p Wrong handler", ConnectObject));
        return FALSE;
    }
    return TRUE;
}
#endif

NTSTATUS
Indicate(
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    )
{
    PIRP                        ClientIrp = NULL;
    PTDI_REQUEST_KERNEL_RECEIVE ClientRcvParams = NULL;
    PIO_STACK_LOCATION          IrpSp = NULL;
    NTSTATUS                    status;

    LONG    BytesToCopy = 0, BytesCopied = 0;
    LONG    BytesToRcv = 0, RcvLength = 0;
    LONG    ClientBytesTaken = 0;

    PUSH_LOCATION(ConnectObject, 0x8000);

    ASSERT(IsValidIndicateState(ConnectObject));
    SmbPrint(SMB_TRACE_RECEIVE, ("Indicate: Connect %p Indicate=%d Available=%d\n",
                ConnectObject, BytesIndicated, BytesAvailable));
    SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p Indicate=%d Available=%d",
                ConnectObject, BytesIndicated, BytesAvailable));

    *BytesTaken = 0;
    *Irp        = NULL;
    ASSERT (ConnectObject->BytesInIndicate <= ConnectObject->CurrentPktLength);

    BytesToCopy = SMB_MIN(MINIMUM_RDR_BUFFER - ConnectObject->BytesInIndicate,
                        ConnectObject->CurrentPktLength - ConnectObject->BytesInIndicate);
    BytesToCopy = SMB_MIN(BytesToCopy, BytesIndicated);
    RtlCopyMemory(ConnectObject->IndicateBuffer + ConnectObject->BytesInIndicate, Tsdu, BytesToCopy);
    TAKE(BytesToCopy);
    ConnectObject->BytesInIndicate += BytesToCopy;

    if (ConnectObject->BytesInIndicate < MINIMUM_RDR_BUFFER &&
            ConnectObject->BytesInIndicate < ConnectObject->CurrentPktLength) {

        PUSH_LOCATION(ConnectObject, 0x8010);

        //
        // After taking all the indicated bytes, the buffer is still not filled
        //

        ASSERT(BytesIndicated == 0);
        ConnectObject->BytesInXport = BytesAvailable;

        if (BytesAvailable > 0) {
            PUSH_LOCATION(ConnectObject, 0x8020);

            *Irp = SmbPrepareIndicateIrp(ConnectObject);
            if (NULL != *Irp) {
                PUSH_LOCATION(ConnectObject, 0x8030);
                SmbReferenceConnect(ConnectObject, SMB_REF_RECEIVE);
                return STATUS_MORE_PROCESSING_REQUIRED;
            } else {
                PUSH_LOCATION(ConnectObject, 0x8040);
                SmbReferenceConnect(ConnectObject, SMB_REF_RECEIVE);
                ASSERT(NULL == ConnectObject->TcpContext);
                return STATUS_DATA_NOT_ACCEPTED;
            }
        }
        return STATUS_SUCCESS;
    }

    //
    // We get a full message or at least 128 bytes
    //
    ASSERT (ConnectObject->BytesInIndicate == MINIMUM_RDR_BUFFER ||
            ConnectObject->BytesInIndicate == ConnectObject->CurrentPktLength);

    status = IndicateToClient(
            ConnectObject->Device,
            ConnectObject,
            TDI_RECEIVE_NORMAL | TDI_RECEIVE_ENTIRE_MESSAGE,
            ConnectObject->BytesInIndicate,
            ConnectObject->CurrentPktLength,
            &ClientBytesTaken,
            ConnectObject->IndicateBuffer
            );
    ASSERT(ClientBytesTaken <= ConnectObject->BytesInIndicate);
    ConnectObject->BytesInIndicate -= ClientBytesTaken;

    if (ConnectObject->BytesInIndicate) {
        RtlMoveMemory(
                ConnectObject->IndicateBuffer + ClientBytesTaken,
                ConnectObject->IndicateBuffer,
                ConnectObject->BytesInIndicate
                );
        PUSH_LOCATION(ConnectObject, 0x8050);
        ASSERT(STATUS_DATA_NOT_ACCEPTED == status || STATUS_SUCCESS == status);
    }

    if (status != STATUS_MORE_PROCESSING_REQUIRED) {
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p status=%!status!",
                    ConnectObject, status));
        PUSH_LOCATION(ConnectObject, 0x8060);
        return status;
    }

    ASSERT(IsValidPartialRcvState(ConnectObject));
    PUSH_LOCATION(ConnectObject, 0x8070);
    *Irp = ConnectObject->ClientIrp;
    return STATUS_MORE_PROCESSING_REQUIRED;
}

#if DBG
BOOL
IsValidPartialRcvState(
    IN PSMB_CONNECT     ConnectObject
    )
{
    if (ConnectObject->BytesInIndicate != 0) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidPartialRcvState: Connect %p BytesInIndicate=%d\n",
                ConnectObject, ConnectObject->BytesInIndicate));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p BytesInIndicate=%d",
                ConnectObject, ConnectObject->BytesInIndicate));
        return FALSE;
    }
    if (ConnectObject->BytesRemaining <= 0 || ConnectObject->BytesRemaining > ConnectObject->CurrentPktLength) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidPartialRcvState: Connect %p BytesRemaining=%d, PktLength=%d\n",
                ConnectObject, ConnectObject->BytesRemaining, ConnectObject->CurrentPktLength));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p BytesRemaining=%d, PktLength=%d",
                ConnectObject, ConnectObject->BytesRemaining, ConnectObject->CurrentPktLength));
        return FALSE;
    }
    if (NULL == ConnectObject->ClientIrp || NULL == ConnectObject->ClientMdl) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidPartialRcvState: Connect %p ClientIrp=%p, ClientMdl=%p\n",
                ConnectObject, ConnectObject->ClientIrp, ConnectObject->ClientMdl));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p ClientIrp=%p, ClientMdl=%p",
                ConnectObject, ConnectObject->ClientIrp, ConnectObject->ClientMdl));
        return FALSE;
    }
    /*
    if (ConnectObject->FreeBytesInMdl < ConnectObject->BytesRemaining) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidPartialRcvState: Connect %p BytesRemaining=%d, FreeBytesInMdl=%d\n",
                ConnectObject, ConnectObject->BytesRemaining, ConnectObject->FreeBytesInMdl));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p BytesRemaining=%d, FreeBytesInMdl=%d",
                ConnectObject, ConnectObject->BytesRemaining, ConnectObject->FreeBytesInMdl));
        return FALSE;
    }
    */
    if (ConnectObject->StateRcvHandler != SmbPartialRcv) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidPartialRcvState: Connect %p Wrong handler\n", ConnectObject));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p Wrong handler", ConnectObject));
        return FALSE;
    }
    if (ConnectObject->CurrentPktLength - ConnectObject->BytesRemaining < 
            ConnectObject->ClientBufferSize - ConnectObject->FreeBytesInMdl) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidPartialRcvState: Connect %p BytesRcved=%d BytesCopiedInMdl=%d\n",
                ConnectObject, ConnectObject->CurrentPktLength - ConnectObject->BytesRemaining,
                ConnectObject->ClientBufferSize - ConnectObject->FreeBytesInMdl));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p BytesRcved=%d BytesCopiedInMdl=%d",
                ConnectObject, ConnectObject->CurrentPktLength - ConnectObject->BytesRemaining,
                ConnectObject->ClientBufferSize - ConnectObject->FreeBytesInMdl));
        return FALSE;
    }
    return TRUE;
}
#endif

NTSTATUS
SmbPartialRcv(
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    )
{
    PIRP                        ClientIrp = NULL;
    PTDI_REQUEST_KERNEL_RECEIVE ClientRcvParams = NULL;
    PIO_STACK_LOCATION          IrpSp = NULL;
    LONG                        BytesToCopy = 0, BytesCopied = 0;
    NTSTATUS                    status;
    PLIST_ENTRY                 entry = NULL;

    PUSH_LOCATION(ConnectObject, 0x9000);
    *BytesTaken = 0;
    *Irp = NULL;
    if (ConnectObject->ClientIrp == NULL || ConnectObject->ClientMdl == NULL) {
        PUSH_LOCATION(ConnectObject, 0x9010);
        return STATUS_SUCCESS;
    }

    ASSERT(IsValidPartialRcvState(ConnectObject));
    SmbPrint(SMB_TRACE_RECEIVE, ("PartialRcv: Connect %p Indicate=%d Available=%d\n",
                ConnectObject, BytesIndicated, BytesAvailable));
    SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p Indicate=%d Available=%d",
                ConnectObject, BytesIndicated, BytesAvailable));

    while(1) {
        ClientIrp = ConnectObject->ClientIrp;

        BytesToCopy = SMB_MIN(ConnectObject->BytesRemaining, BytesIndicated);
        BytesToCopy = SMB_MIN(BytesToCopy, ConnectObject->FreeBytesInMdl);

        status = TdiCopyBufferToMdl(
                Tsdu,
                0,
                BytesToCopy,
                ConnectObject->ClientMdl,
                ConnectObject->ClientBufferSize - ConnectObject->FreeBytesInMdl,
                &BytesCopied
                );
        ASSERT(status == STATUS_SUCCESS);
        TAKE(BytesCopied);
        ConnectObject->BytesRemaining -= BytesCopied;
        ConnectObject->FreeBytesInMdl -= BytesCopied;

        if (ConnectObject->BytesRemaining != 0 && ConnectObject->FreeBytesInMdl != 0) {
            PUSH_LOCATION(ConnectObject, 0x9020);
            break;
        }

        ConnectObject->BytesInIndicate = 0;
        SmbCompleteReceiveRequest(ConnectObject);

        if (ConnectObject->BytesRemaining == 0) {
            //
            // Return if a full message
            //
            ASSERT (ConnectObject->StateRcvHandler == WaitingHeader);

            PUSH_LOCATION(ConnectObject, 0x9050);
            return STATUS_SUCCESS;
        }

        ClientIrp = SmbNextReceiveRequest(ConnectObject);
        if (NULL == ClientIrp) {
            PUSH_LOCATION(ConnectObject, 0x9060);
            return STATUS_SUCCESS;
        }

        ConnectObject->ClientIrp = ClientIrp;
        ConnectObject->ClientMdl = ClientIrp->MdlAddress;
        ASSERT(ConnectObject->ClientMdl == NULL);

        IrpSp     = IoGetCurrentIrpStackLocation(ClientIrp);
        ClientRcvParams = (PTDI_REQUEST_KERNEL_RECEIVE)&IrpSp->Parameters;
        ConnectObject->ClientBufferSize = (LONG)ClientRcvParams->ReceiveLength;
        ConnectObject->FreeBytesInMdl   = ConnectObject->ClientBufferSize;
        PUSH_LOCATION(ConnectObject, 0x9070);
    }

    ASSERT(BytesIndicated == 0);
    ASSERT(BytesAvailable >= 0);

    ConnectObject->BytesInXport = BytesAvailable;

    ASSERT(IsValidPartialRcvState(ConnectObject));

    if (BytesAvailable == 0) {
        PUSH_LOCATION(ConnectObject, 0x9080);
        return STATUS_SUCCESS;
    }

    SmbPrepareReceiveIrp(ConnectObject);
    *Irp = ConnectObject->ClientIrp;
    PUSH_LOCATION(ConnectObject, 0x9090);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

#if DBG
BOOL
IsValidWaitingHeaderState(
    IN PSMB_CONNECT     ConnectObject
    )
/*++

Routine Description:

    Teat if the invariant for WaitingHeader state is true or not

Arguments:

Return Value:

--*/
{
    if (ConnectObject->BytesRemaining != 0) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidWaitingHeaderState: Connect %p BytesRemaining=%d, PktLength=%d\n",
                ConnectObject, ConnectObject->BytesRemaining, ConnectObject->CurrentPktLength));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p BytesRemaining=%d, PktLength=%d",
                ConnectObject, ConnectObject->BytesRemaining, ConnectObject->CurrentPktLength));
        return FALSE;
    }
    if (ConnectObject->BytesInIndicate != 0) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidWaitingHeaderState: Connect %p BytesInIndicate=%d\n",
                ConnectObject, ConnectObject->BytesInIndicate));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p BytesInIndicate=%d",
                ConnectObject, ConnectObject->BytesInIndicate));
        return FALSE;
    }
    if (NULL != ConnectObject->ClientIrp || NULL != ConnectObject->ClientMdl) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidWaitingHeaderState: Connect %p ClientIrp=%p, ClientMdl=%p\n",
                ConnectObject, ConnectObject->ClientIrp, ConnectObject->ClientMdl));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p ClientIrp=%p, ClientMdl=%p",
                ConnectObject, ConnectObject->ClientIrp, ConnectObject->ClientMdl));
        return FALSE;
    }
    if (ConnectObject->StateRcvHandler != WaitingHeader) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidWaitingHeaderState: Connect %p Wrong handler\n",
                                ConnectObject));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p Wrong handler", ConnectObject));
        return FALSE;
    }
    if (ConnectObject->HeaderBytesRcved >= SMB_SESSION_HEADER_SIZE ||
            ConnectObject->HeaderBytesRcved < 0) {
        SmbPrint(SMB_TRACE_RECEIVE, ("IsValidWaitingHeaderState: Connect %p HeaderBytesRcved=%d\n",
                            ConnectObject, ConnectObject->HeaderBytesRcved));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p HeaderBytesRcved=%d",
                            ConnectObject, ConnectObject->HeaderBytesRcved));
        return FALSE;
    }
    return TRUE;
}
#endif

PIRP __inline
SmbPrepareSessionHeaderIrp(
    IN PSMB_CONNECT     ConnectObject
    )
{
    PMDL    Mdl = NULL;
    PIRP    Irp = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT (ConnectObject->HeaderBytesRcved >= 0);
    ASSERT (ConnectObject->HeaderBytesRcved < SMB_SESSION_HEADER_SIZE);

    PUSH_LOCATION(ConnectObject, 0xa010);
    Mdl = IoAllocateMdl(
            ((PUCHAR)(&ConnectObject->SmbHeader)) + ConnectObject->HeaderBytesRcved,
            SMB_SESSION_HEADER_SIZE - ConnectObject->HeaderBytesRcved,
            FALSE,
            FALSE,
            NULL
            );
    Irp = SmbAllocIrp(ConnectObject->Device->DeviceObject.StackSize - 1);
    if (NULL == Mdl || NULL == Irp) {
        goto cleanup;
    }

    PUSH_LOCATION(ConnectObject, 0xa020);
    MmBuildMdlForNonPagedPool(Mdl);

    TdiBuildReceive(
            Irp,
            IoGetRelatedDeviceObject(ConnectObject->TcpContext->Connect.ConnectObject),
            ConnectObject->TcpContext->Connect.ConnectObject,
            SmbHeaderCompletion,
            ConnectObject,
            Mdl,
            TDI_RECEIVE_NORMAL,
            SMB_SESSION_HEADER_SIZE - ConnectObject->HeaderBytesRcved
            );
    return Irp;

cleanup:
    PUSH_LOCATION(ConnectObject, 0xa030);
    BREAK_WHEN_TAKE();

    if (NULL != Irp) {
        SmbFreeIrp(Irp);
    }

    if (NULL != Mdl) {
        IoFreeMdl(Mdl);
    }

    KillConnection(ConnectObject);

    return NULL;
}

NTSTATUS
WaitingHeader(
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_CONNECT     ConnectObject,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    )
{
    LONG        ClientBytesTaken = 0;
    PIRP        ClientIrp = NULL;
    LONG        BytesToCopy;
    NTSTATUS    status;

    PUSH_LOCATION(ConnectObject, 0xb000);

    ASSERT(IsValidWaitingHeaderState(ConnectObject));
    SmbPrint(SMB_TRACE_RECEIVE, ("WaitingHeader: Connect %p Indicate=%d Available=%d\n",
                ConnectObject, BytesIndicated, BytesAvailable));
    SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p Indicate=%d Available=%d",
                ConnectObject, BytesIndicated, BytesAvailable));

    *BytesTaken = 0;
    *Irp        = NULL;

    ASSERT(IsValidWaitingHeaderState(ConnectObject));

    BytesToCopy = SMB_MIN((LONG)SMB_SESSION_HEADER_SIZE-ConnectObject->HeaderBytesRcved,
                                            BytesIndicated);

    if (BytesToCopy > 0) {
        PUSH_LOCATION(ConnectObject, 0xb020);

        //
        // A new message
        //
        RtlCopyMemory(
                (PUCHAR)(&ConnectObject->SmbHeader) + ConnectObject->HeaderBytesRcved,
                Tsdu,
                BytesToCopy
                );
        TAKE(BytesToCopy);
        ConnectObject->HeaderBytesRcved += BytesToCopy;

        ASSERT(ConnectObject->HeaderBytesRcved <= SMB_SESSION_HEADER_SIZE);
        if (ConnectObject->HeaderBytesRcved == SMB_SESSION_HEADER_SIZE) {
            status = SmbNewMessage(
                    ConnectObject,
                    BytesIndicated,
                    &ClientBytesTaken,
                    Tsdu,
                    &ClientIrp
                    );
            ASSERT(ClientBytesTaken <= BytesIndicated);
            TAKE(ClientBytesTaken);
            ConnectObject->BytesInXport = BytesAvailable;

            if (status == STATUS_MORE_PROCESSING_REQUIRED) {
                PUSH_LOCATION(ConnectObject, 0xb030);
                ASSERT(ClientIrp);
                *Irp = ClientIrp;
                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            if (status != STATUS_SUCCESS) {

                PUSH_LOCATION(ConnectObject, 0xb040);

                // BREAK_WHEN_TAKE();
                SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p status=%!status!",
                            ConnectObject, status));
                return status;
            }

            ASSERT(ClientBytesTaken == ConnectObject->CurrentPktLength || 0 == BytesIndicated);
            ASSERT(IsValidWaitingHeaderState(ConnectObject) || IsValidIndicateState(ConnectObject));
            return status;
        }
    }
   
    ASSERT(BytesIndicated == 0);
    ASSERT(ConnectObject->HeaderBytesRcved < SMB_SESSION_HEADER_SIZE);

    if (BytesAvailable > 0) {
        PUSH_LOCATION(ConnectObject, 0xb050);

        ConnectObject->BytesInXport = BytesAvailable;
        *Irp        = SmbPrepareSessionHeaderIrp(ConnectObject);
        if (*Irp) {
            PUSH_LOCATION(ConnectObject, 0xb060);
            SmbReferenceConnect(ConnectObject, SMB_REF_RECEIVE);
            return STATUS_MORE_PROCESSING_REQUIRED;
        } else {
            PUSH_LOCATION(ConnectObject, 0xb070);
            return STATUS_DATA_NOT_ACCEPTED;
        }
    }

    ASSERT(BytesAvailable == 0);
    return STATUS_SUCCESS;
}

NTSTATUS 
SmbTdiReceiveHandler (
    IN PSMB_DEVICE      DeviceObject,
    IN PSMB_TCP_CONNECT TcpConnect,
    IN ULONG            ReceiveFlags,
    IN LONG             BytesIndicated,
    IN LONG             BytesAvailable,
    OUT LONG            *BytesTaken,
    IN PVOID            Tsdu,
    OUT PIRP            *Irp
    )
/*++

Routine Description:

    This is the TDI receive event handler we register with TCP.

Arguments:


Return Value:


--*/
{
    PSMB_CONNECT    ConnectObject;
    KIRQL           Irql;
    NTSTATUS        status = STATUS_SUCCESS;

    *BytesTaken = 0;
    *Irp        = NULL;
    if (BytesAvailable == 0) {
        return STATUS_SUCCESS;
    }

    //
    // Reference the ConnectObject
    //
    SMB_ACQUIRE_SPINLOCK(&SmbCfg, Irql);
    ConnectObject = TcpConnect->UpperConnect;
    if (NULL == ConnectObject) {
        SMB_RELEASE_SPINLOCK(&SmbCfg, Irql);
        return STATUS_DATA_NOT_ACCEPTED;
    }
    SmbReferenceConnect(ConnectObject, SMB_REF_RECEIVE);
    SMB_RELEASE_SPINLOCK_DPC(&SmbCfg);

    SmbPrint(SMB_TRACE_RECEIVE, ("TdiReceiveHandler: Connect %p Indicate=%d Available=%d\n",
                ConnectObject, BytesIndicated, BytesAvailable));
    SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p Indicate=%d Available=%d",
                ConnectObject, BytesIndicated, BytesAvailable));

    //
    // Access is synchronized through the spinlock. We won't release the
    // spinlock unless we'll call IoCompleteRequest or Client's event
    // handler
    //
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);
    PUSH_LOCATION(ConnectObject, 0xc000);

    if (ConnectObject->State != SMB_CONNECTED) {
        // ASSERT(0);
        PUSH_LOCATION(ConnectObject, 0xc010);
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
        return STATUS_DATA_NOT_ACCEPTED;
    }

    //
    // An indication comes in while we have an IRP in TCP
    //
    if (ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE]) {
        BREAK_WHEN_TAKE();

        //
        // This might happen if the DPC routine was called
        //  The SmbHeaderDpc release the spin lock before calling IoCallDriver.
        //  Just in between, we get an indication!!!
        //
        ASSERT(ConnectObject->DpcRequestQueued);

        PUSH_LOCATION(ConnectObject, 0xc020);
        ConnectObject->BytesInXport = BytesAvailable;
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);

        return STATUS_DATA_NOT_ACCEPTED;
    }

    ASSERT(ConnectObject->DpcRequestQueued || ConnectObject->BytesInXport == 0);
    SmbRemoveSessionHeaderDpc(ConnectObject);

    while (BytesAvailable > 0) {
        LONG    ClientBytesTaken;
        PIRP    ClientIrp;

        ClientIrp = NULL;
        ClientBytesTaken = 0;
        status = (*ConnectObject->StateRcvHandler)(
                DeviceObject,
                ConnectObject,
                ReceiveFlags,
                BytesIndicated,
                BytesAvailable,
                &ClientBytesTaken,
                Tsdu,
                &ClientIrp
                );
        ASSERT(ClientBytesTaken <= BytesIndicated);
        TAKE(ClientBytesTaken);
        SmbPrint(SMB_TRACE_RECEIVE, ("TdiReceiveHandler: Connect %p Indicate=%d Available=%d"
                    " Taken=%d ClientTaken=%d status=0x%08lx\n",
                    ConnectObject, BytesIndicated, BytesAvailable, *BytesTaken, ClientBytesTaken, status));
        SmbTrace(SMB_TRACE_RECEIVE, ("Connect %p Indicate=%d Available=%d"
                    " Taken=%d ClientTaken=%d status=%!status!",
                    ConnectObject, BytesIndicated, BytesAvailable, *BytesTaken, ClientBytesTaken, status));

        if (status == STATUS_MORE_PROCESSING_REQUIRED) {
            PUSH_LOCATION(ConnectObject, 0xc030);
            ASSERT(ClientIrp);
            *Irp = ClientIrp;
            goto return_IRP_Exit;
        }

        if (status == STATUS_DATA_NOT_ACCEPTED || (status == STATUS_SUCCESS && ClientBytesTaken == 0)) {
            PUSH_LOCATION(ConnectObject, 0xc040);
            goto take_some_exit;
        }

        ASSERT(status == STATUS_SUCCESS);
        PUSH_LOCATION(ConnectObject, 0xc050);
    }

take_some_exit:
    PUSH_LOCATION(ConnectObject, 0xc060);
    ConnectObject->BytesInXport  = BytesAvailable;
    ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE] = NULL;

    //
    // If any bytes taken, the status should be STATUS_SUCCESS.
    // Although the client doesn't take any bytes, but we could consume the header.
    // Don't return what the client returns.
    //
    if (*BytesTaken) {
        PUSH_LOCATION(ConnectObject, 0xc070);
        status = STATUS_SUCCESS;
    }
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    ASSERT(ConnectObject->RefCount > 1);
    SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);
    return status;

return_IRP_Exit:
    PUSH_LOCATION(ConnectObject, 0xc080);
    ConnectObject->BytesInXport = BytesAvailable;
    ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE] = *Irp;
    SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

    ASSERT(ConnectObject->RefCount > 1);
    SmbDereferenceConnect(ConnectObject, SMB_REF_RECEIVE);

    IoSetNextIrpStackLocation(*Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SmbGetHeaderDpc(
    IN PKDPC Dpc,
    IN PSMB_CONNECT     ConnectObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    KIRQL           Irql;
    NTSTATUS        status;
    PIRP            Irp = NULL;
    PDEVICE_OBJECT  TcpDeviceObject = NULL;
    PFILE_OBJECT    TcpFileObject = NULL;

    PUSH_LOCATION(ConnectObject, 0xd000);

    ASSERT(&ConnectObject->SmbHeaderDpc == Dpc);
    SMB_ACQUIRE_SPINLOCK(ConnectObject, Irql);
    if (ConnectObject->State != SMB_CONNECTED) {
        PUSH_LOCATION(ConnectObject, 0xd010);
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        SmbDereferenceConnect(ConnectObject, SMB_REF_DPC);
        return;
    }

    if (!ConnectObject->DpcRequestQueued) {
        BREAK_WHEN_TAKE();

        PUSH_LOCATION(ConnectObject, 0xd020);
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

        //
        // The TdiReceiveHandler has been called. Bail out.
        //
        // Note: TCP could call our receive event handler when new data comes in.
        //
        return;
    }

    ASSERT(NULL == ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE]);
    ASSERT(ConnectObject->BytesInXport > 0);
    ASSERT(ConnectObject->StateRcvHandler == WaitingHeader);
    ASSERT(ConnectObject->BytesRemaining == 0);
    ASSERT(ConnectObject->HeaderBytesRcved == 0);

    Irp        = SmbPrepareSessionHeaderIrp(ConnectObject);
    if (NULL != Irp) {
        PUSH_LOCATION(ConnectObject, 0xd030);
        ConnectObject->PendingIRPs[SMB_PENDING_RECEIVE] = Irp;
        ConnectObject->DpcRequestQueued = FALSE;

        TcpFileObject = ConnectObject->TcpContext->Connect.ConnectObject;
        TcpDeviceObject = IoGetRelatedDeviceObject(TcpFileObject);

        //
        // Reference the file object while we still holding the spinlock
        //
        ObReferenceObject(TcpFileObject);
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);

        //
        // Don't exchange the following 2 statements, we should reference in
        // the context of SMB_REF_RECEIVE and then dereference the DPC context
        //
        SmbReferenceConnect(ConnectObject, SMB_REF_RECEIVE);
        SmbDereferenceConnect(ConnectObject, SMB_REF_DPC);

        status = IoCallDriver(TcpDeviceObject, Irp);

        //
        // Now we can dereference the TcpFileObject. It is the TCP's responsibility to
        // do the synchronization between the deletion of the file object and accessing it
        //
        ObDereferenceObject(TcpFileObject);
    } else {
        PUSH_LOCATION(ConnectObject, 0xd040);
        //
        // The connection should already have been killed
        //
        ASSERT(ConnectObject->TcpContext == NULL);
        SMB_RELEASE_SPINLOCK(ConnectObject, Irql);
        SmbDereferenceConnect(ConnectObject, SMB_REF_DPC);
    }
}

VOID
KillConnection(
    IN PSMB_CONNECT     ConnectObject
    )
/*++

Routine Description:

    Kill the connection immediately

    Note: the ConnectObject->SpinLock is held when this routine is called

Arguments:


Return Value:


--*/
{
    // BREAK_WHEN_TAKE();

    PUSH_LOCATION(ConnectObject, 0xe000);

    SaveDisconnectOriginator(ConnectObject, SMB_DISCONNECT_RECEIVE_FAILURE);
    if (ConnectObject->ClientObject == NULL) {
        PUSH_LOCATION(ConnectObject, 0xe010);
        return;
    }

    SmbReferenceConnect(ConnectObject, SMB_REF_DISCONNECT);

    SMB_RELEASE_SPINLOCK_DPC(ConnectObject);
    CommonDisconnectHandler(SmbCfg.SmbDeviceObject, ConnectObject, TDI_DISCONNECT_ABORT);
    SMB_ACQUIRE_SPINLOCK_DPC(ConnectObject);

    SmbDereferenceConnect(ConnectObject, SMB_REF_DISCONNECT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\sys\lib\precomp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    precompiled header file

Author:

    Jiandong Ruan

Revision History:

--*/

#define NEWSMB
#include "..\..\..\inc\nbttrace.h"

////////////////////////////////////////////////////////////////////////////////
//                          B U I L D    O P T I O N S
////////////////////////////////////////////////////////////////////////////////

//
// We have two directorys 'sys' and 'lib'. If you put this definition
// in the C_DEFINES of the "sources" file, you need to make sure the
// sys\sources and lib\sources has the same definition.
//
// We'd better to put them here
//

//
// RDR/SRV expect a minimum indication size.
//
#define NO_ZERO_BYTE_INDICATE

//
// Enable the feature for debugging the RefCount
//
#define REFCOUNT_DEBUG

//
// Enable the built-in tracing for TdiReceive event handler
// 
#define ENABLE_RCV_TRACE

//
// Using lookaside list prohibits driver verifier from capturing buffer overrun.
// We'd better turn it off at this development stage.
//
#define NO_LOOKASIDE_LIST


////////////////////////////////////////////////////////////////////////////////
//                  I N C L U D E     F I L E S
////////////////////////////////////////////////////////////////////////////////
#include <stddef.h>

#include <ntosp.h>
#include <zwapi.h>
#include <ndis.h>
#include <cxport.h>
#include <ip.h>         // for IPRcvBuf
#include <ipinfo.h>     // for route-lookup defs
#include <tdi.h>
#include <ntddip.h>     // for \Device\Ip I/O control codes
#include <ntddip6.h>     // for \Device\Ip I/O control codes
#include <ntddtcp.h>    // for \Device\Tcp I/O control codes
#include <ipfltinf.h>   // for firewall defs
#include <ipfilter.h>   // for firewall defs
#include <tcpinfo.h>    // for TCP_CONN_*

#include <tdikrnl.h>
#include <tdiinfo.h>    // for CONTEXT_SIZE, TDIObjectID
#include <tdistat.h>    // for TDI status codes

#include <align.h>
#include <windef.h>

#ifndef __SMB_KDEXT__
    #include <wmistr.h>
    #include <wmiguid.h>
    #include <wmilib.h>
    #include <wmikm.h>
    #include <evntrace.h>
#endif // __SMB_KDEXT__

#include "common.h"
#include "ip6util.h"
#include "smbioctl.h"
#include "smbtdi.h"
#include "debug.h"
#include "hash.h"
#include "ip2netbios.h"
#include "types.h"
#include "init.h"
#include "registry.h"
#include "ntpnp.h"
#include "ioctl.h"
#include "session.h"
#include "dgram.h"
#include "name.h"
#include "tdihndlr.h"
#include "fileio.h"
#include "dns.h"
#include "smb.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\test\csstress.c ===
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>

int addhost(char *host)
{
    struct  hostent *h;

    h = gethostbyname(host);
    if (h == NULL) {
        return (-1);
    }
    printf ("%s %s\n", inet_ntoa(*(struct in_addr*)(h->h_addr)), host);
    return 0;
}

int __cdecl main()
{
    char    host[18];
    WSADATA wsa;
    int     i;

    WSAStartup(0x0101, &wsa);

    addhost("localhost");
    addhost("csstress");
    addhost("DOMINATOR");

    strcpy(host, "CS_A");
    for (i = 0; i < 26; i++) {
        host[3] = 'A' + i;
        addhost(host);
    }
    strcpy(host, "STRESS_A");
    for (i = 0; i < 26; i++) {
        host[7] = 'A' + i;
        addhost(host);
    }

    addhost("CS_IA");
    addhost("CS_IAB");
    addhost("mixedds1c");
    addhost("mixedds2c");
    addhost("mixedds3c");
    addhost("mixedds4c");

    WSACleanup();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\test\ip6test.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ip6test.c

Abstract:

    test driver

Author:

    Jiandong Ruan

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "ip6util.h"

BOOL
SmbLookupHost(
    WCHAR               *host,
    PSMB_IP_ADDRESS     ipaddr
    );

struct {
    WCHAR   *src;
    WCHAR   *dest;
} test_cases[] = {
    { L"::1", L"::1" },
    { L"::", L"::" },

    { L"fe80::2b0:d0ff:fe1d:e082", L"fe80::2b0:d0ff:fe1d:e082" },

    { L"::0123", L"::123" },
    { L"0::0123", L"::123" },
    { L"::04567:0123", L"::4567:123" },
    { L"0::4567:0123", L"::4567:123" },
    { L"::089Ab:4567:0123", L"::89ab:4567:123" },
    { L"0::89Ab:4567:0123", L"::89ab:4567:123" },
    { L"::cDeF:089Ab:4567:0123", L"::cDeF:89ab:4567:123" },
    { L"0::0cDeF:089Ab:4567:0123", L"::cDeF:89ab:4567:123" },

    { L"0123::", L"123::" },
    { L"0123::0", L"123::" },
    { L"0123:4567::", L"123:4567::" },
    { L"0123:4567::0", L"123:4567::" },
    { L"0123:4567:89aB::", L"123:4567:89ab::" },
    { L"0123:4567:89aB::0", L"123:4567:89ab::" },
    { L"0123:4567:89aB:cDeF::", L"123:4567:89ab:cdef::" },
    { L"0123:4567:89aB:cDeF::0", L"123:4567:89ab:cdef::" },

    { L"0ea8::001", L"ea8::1" },
    { L"2ea8::001", L"2ea8::1" },

    { L"0:2ea8::f01", L"0:2ea8::f01" },
    { L"0:2ea8::0:f01", L"0:2ea8::f01" },
    { L"0:2ea8:0::f01", L"0:2ea8::f01" },
    { L"0:2ea8::f01:00", L"0:2ea8::f01:0" },

    { L"fedc::f01", L"fedc::f01" },
    { L"0fedc::f01", L"fedc::f01" },
    { L"0fedc::ba98:f01", L"fedc::ba98:f01" },
    { L"0FEDC::BA98:fffe:f01", L"fedc::ba98:fffe:f01" },
    { L"0fedc::0fffc:fffd:0fffe:f01", L"fedc::fffc:fffd:fffe:f01" },
    { L"0fedc:0fffc:fffd:0fffe::f01", L"fedc:fffc:fffd:fffe::f01" },
    { L"0fedc:0fffc:fffd::f01", L"fedc:fffc:fffd::f01" },
    { L"0fedc:0fffc::f01", L"fedc:fffc::f01" },

    { L"0ea8::0::001", NULL },
    { L"001fedc:001fffc::f01", NULL },
    { L"001fedc::001fffc::f01", NULL },
    { L"0fedc::0001ba98:fffd:0fffe:f01", NULL },
    { L"0fedc::ba98:001fffd:0fffe:f01", NULL },
    { L"0fedc::00ba98:fffd:0010000:f01", NULL }
};
#define CASE_NUMBER (sizeof(test_cases)/sizeof(test_cases[0]))

#define WSTR_LOOPBACK   L"::1"

void test_host_lookup(void);
void test_inet_functions(void);

void _cdecl main(void)
{
    test_inet_functions();
    test_host_lookup();
}

void test_inet_functions(void)
{
    WCHAR           Buffer[40];
    WCHAR           Buffer2[40];
    SMB_IP6_ADDRESS loopback, addr;
    int             i, j;
    UNICODE_STRING  uc1, uc2;

    ip6addr_getloopback(&loopback);
    hton_ip6addr(&loopback);

    //
    // Test inet_ntoa6W and inet_addr6W
    //
    if (inet_ntoa6W(Buffer, 40, &loopback) && wcscmp(Buffer, WSTR_LOOPBACK) != 0) {
        printf ("inet_ntoa6W on loopback: [failed]\n");
    }

    for (i = 0; i < CASE_NUMBER; i++) {
        if (inet_addr6W(test_cases[i].src, &addr)) {
            if (test_cases[i].dest == NULL) {
                printf ("inet_addr6W on %ws: [failed]\n", test_cases[i].src);
                printf ("\tExpected behavior: inet_addr6W should have returned FALSE\n");
                continue;
            }
            RtlInitUnicodeString(&uc2, test_cases[i].dest);
            uc1.Buffer = Buffer2;
            uc1.MaximumLength = sizeof(Buffer2);
            RtlUpcaseUnicodeString(&uc1, &uc2, FALSE);
            Buffer2[uc1.Length/sizeof(WCHAR)] = 0;

            if (!inet_ntoa6W(Buffer, 40, &addr)) {
                printf ("inet_ntoa6W on %-40ws: [failed]\n", test_cases[i].src);
                printf ("\tExpected behavior: inet_ntoa6W should have returned TRUE, %ws\n",
                        Buffer2);
                continue;
            }

            if (wcscmp(Buffer, Buffer2) != 0) {
                printf ("inet_addr6W and inet_ntoa6W on %-40ws [failed]\n", test_cases[i].src);
                printf ("\tinet_addr6W returns:\n");
                putchar('\t');
                putchar('\t');
                for (j = 0; j < 8; j++) {
                    if (j != 0) {
                        putchar(':');
                    }
                    printf ("%04x", htons(addr.sin6_addr[j]));
                }
                putchar('\n');
                printf ("\tinet_ntoa returns: %ws (Expected %ws)\n", Buffer, Buffer2);
            }
        } else {
            if (test_cases[i].dest != NULL) {
                printf ("inet_addr6W on %ws: [failed]\n", test_cases[i].src);
                printf ("\tExpected behavior: inet_addr6W should have returned TRUE\n");
                continue;
            }
        }
    }
}

void test_host_lookup(void)
{
    SMB_IP_ADDRESS  addr;
    FILE            *fp;
    int             i;
    WCHAR           Buffer[40], Buffer2[40];

    if (SmbLookupHost(L"localhost", &addr)) {
        if (!inet_ntoa6W(Buffer, 40, &addr.ip6)) {
            printf ("etc/hosts [failed]\n");
        }

        printf ("%ws localhost\n", Buffer);
    }

    wcscpy(Buffer2, L"::1");
    fp = fopen("hosts", "w+");
    if (fp == NULL) {
        printf ("failed to create file\n");
        return;
    }
    fprintf(fp, " # some comments    \n");
    fprintf(fp, "# some comments    \n");
    fprintf(fp, "# \t\tsome comments\n");
    fprintf(fp, "%ws    Jruan-Dev  # some comments", Buffer2);
    fclose(fp);

    if (SmbLookupHost(L"jruan-dev", &addr)) {
        if (!inet_ntoa6W(Buffer, 40, &addr.ip6)) {
            printf ("etc/hosts on %-40ws: [failed]\n", Buffer2);
            printf ("\tExpected behavior: inet_ntoa6W should have returned TRUE, %ws\n", Buffer2);
        } else {
            if (wcscmp(Buffer, Buffer2) != 0) {
                printf ("etc/hosts on [failed]\n");
                printf ("\tExpected: \"%ws\" Get \"%ws\"\n", Buffer2, Buffer);
            }
        }
    } else {
        printf ("etc/hosts [failed]\n");
    }
}

FILE*
Smb_fopen(
    PWCHAR  path,
    PWCHAR  mode
    )
{
    FILE    *fp;

    UNREFERENCED_PARAMETER(path);
    UNREFERENCED_PARAMETER(mode);

    fp = fopen ("hosts", "r");
    return fp;
}

void
Smb_fclose(
    FILE*   fp
    )
{
    if (fp) {
        fclose(fp);
    }
}

int
Smb_fgetc(
    FILE*   fp
    )
{
    return fgetc(fp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\test\smbhelper.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    smbhelper.c

Abstract:


Author:

    Jiandong Ruan

Revision History:

--*/

#include "precomp.h"

void _cdecl main(void)
{
    LPWSTR  CommandLine;
    int     ch;
    int     num;
    int     Argc;
    LPWSTR  *Argv;

    setlocale(LC_ALL, "");

    SmbSetTraceRoutine(printf);

    CommandLine = GetCommandLineW();
    if (NULL == CommandLine) {
        exit (1);
    }
    Argv = CommandLineToArgvW(CommandLine, &Argc);
    num = 1;
    if (Argc >= 2) {
        num = _wtoi(Argv[1]);
    }

    if (SmbStartService(num, NULL) != ERROR_SUCCESS) {
        exit(1);
    }
    do {
        ch = getchar();
    } while (ch != 'q' && ch != EOF);
    SmbStopService(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\smb\test\testsvc.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    testsvc.c

Abstract:

    the test driver for testing the functionality of SmbGetHostByName

Author:

    Jiandong Ruan

Revision History:

--*/


#include "precomp.h"

VOID
SmbGetHostByName(
    PSMB_DNS_BUFFER dns
    );

void _cdecl main(void)
{
    LPWSTR  CommandLine;
    WSADATA WsaData;
    int     Argc;
    LPWSTR  *Argv;
    HANDLE  handle;
    SMB_DNS_BUFFER dns;
    CHAR    Buffer[40];

    setlocale(LC_ALL, "");

    SmbSetTraceRoutine(printf);

    CommandLine = GetCommandLineW();
    if (NULL == CommandLine) {
        exit (1);
    }
    Argv = CommandLineToArgvW(CommandLine, &Argc);
    if (Argc < 2) {
        printf ("Usage %ws name\n", Argv[0]);
        exit (1);
    }

    if (WSAStartup(MAKEWORD(2, 0), &WsaData) == SOCKET_ERROR) {
        printf ("Failed to startup Winsock2\n");
        exit (1);
    }

    dns.Id = 1;
    wcscpy(dns.Name, Argv[1]);
    dns.NameLen = wcslen(Argv[1]) + 1;
    dns.Name[dns.NameLen - 1] = L'\0';
    SmbGetHostByName(&dns);
    if (dns.Resolved) {
        printf ("Canon Name: %ws\n", dns.Name);
        if (dns.IpAddrsList[0].sin_family == SMB_AF_INET6) {
            if (inet_ntoa6(Buffer, 40, &dns.IpAddrsList[0].ip6)) {
                printf ("\tIP6 Addr: %s\n", Buffer);
            } else {
                printf ("\tUnexpected failed\n");
            }
        } else {
            printf ("\tIP4 Addr: %s\n", inet_ntoa(*(struct in_addr*)(&dns.IpAddrsList[0].ip4.sin4_addr)));
        }
    } else {
        printf ("Cannot resolve %ws\n", dns.Name);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\hndlrs.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Hndlrs.c

Abstract:


    This file contains the Non OS specific implementation of handlers that are
    called for  Connects,Receives, Disconnects, and Errors.

    This file represents the TDI interface on the Bottom of NBT after it has
    been decoded into procedure call symantics from the Irp symantics used by
    NT.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

    Will Lees (wlees)    Sep 11, 1997
        Added support for message-only devices

--*/

#ifdef VXD

#define NTIndicateSessionSetup(pLowerConn,status) \
    DbgPrint("Skipping NTIndicateSessionSetup\n\r")

#endif //VXD

#include "precomp.h"
#include "ctemacro.h"
#include "hndlrs.tmh"

static __inline USHORT
GetRandomNumber(PULONG Seed)
{
    return (USHORT)((((*Seed) = (*Seed) * 214013L + 2531011L) >> 16) & 0x7fff);
}

__inline long
myntohl(long x)
{
    return((((x) >> 24) & 0x000000FFL) |
                        (((x) >>  8) & 0x0000FF00L) |
                        (((x) <<  8) & 0x00FF0000L));
}

VOID
ClearConnStructures (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  tCONNECTELE         *pConnectEle
    );

NTSTATUS
CompleteSessionSetup (
    IN  tCLIENTELE          *pClientEle,
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  tCONNECTELE         *pConnectEle,
    IN  PCTE_IRP            pIrp
    );

NTSTATUS
MakeRemoteAddressStructure(
    IN  PCHAR           pHalfAsciiName,
    IN  PVOID           pSourceAddr,
    IN  ULONG           lMaxNameSize,
    OUT PVOID           *ppRemoteAddress,
    OUT PULONG          pRemoteAddressLength,
    IN  ULONG           NumAddr
    );

VOID
AddToRemoteHashTbl (
    IN  tDGRAMHDR UNALIGNED  *pDgram,
    IN  ULONG                BytesIndicated,
    IN  tDEVICECONTEXT       *pDeviceContext
    );


VOID
DoNothingComplete (
    IN PVOID        pContext
    );

VOID
AllocLowerConn(
    IN  tDEVICECONTEXT *pDeviceContext,
    IN  PVOID          pDeviceSpecial
    );

VOID
GetIrpIfNotCancelled2(
    IN  tCONNECTELE     *pConnEle,
    OUT PIRP            *ppIrp
    );

//----------------------------------------------------------------------------
NTSTATUS
Inbound(
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer

    )
/*++

Routine Description:

    This routine is called to setup  inbound  session
    once the tcp connection is up.  The transport calls this routine with
    a session setup request pdu.

    In message-only mode, this routine may be called to cause a session to be set up even
    though the session request was not received over the wire.  A fake session request is
    crafted up and passed to this routine.  In this mode, we don't want to send session rejections
    back over the wire.

NOTE!!!
    // the LowerConn Lock is held prior to calling this routine

Arguments:

    pClientEle      - ptr to the connecition record for this session


Return Value:

    NTSTATUS - Status of receive operation

--*/
{

    NTSTATUS                 status = STATUS_SUCCESS;
    tCLIENTELE               *pClientEle;
    tSESSIONHDR UNALIGNED    *pSessionHdr;
    tLOWERCONNECTION         *pLowerConn;
    tCONNECTELE              *pConnectEle;
    CTELockHandle            OldIrq;
    PIRP                     pIrp;
    PLIST_ENTRY              pEntry;
    CONNECTION_CONTEXT       ConnectId;
    PTA_NETBIOS_ADDRESS      pRemoteAddress;
    ULONG                    RemoteAddressLength;
    tDEVICECONTEXT           *pDeviceContext;

    //
    // Verify that the DataSize >= sizeof (Sessionheader)
    // Bug# 126111
    //
    if (BytesIndicated < (sizeof(tSESSIONHDR)))
    {
        KdPrint (("Nbt.Inbound[1]: WARNING!!! Rejecting Request -- BytesIndicated=<%d> < <%d>\n",
            BytesIndicated, (sizeof(tSESSIONHDR))));
        NbtTrace(NBT_TRACE_INBOUND, ("Reject on pLowerConn %p: BytesIndicated %d < sizeof(tSESSIONHDR) bytes",
                        ConnectionContext, BytesIndicated));

        return (STATUS_INTERNAL_ERROR);
    }

    pSessionHdr = (tSESSIONHDR UNALIGNED *)pTsdu;

    // get the ptrs to the lower and upper connections
    //
    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;
    pConnectEle = pLowerConn->pUpperConnection;
    pDeviceContext = pLowerConn->pDeviceContext;

    //
    // fake out the transport so it frees its receive buffer (i.e. we
    // say that we accepted all of the data)
    //
    *BytesTaken = BytesIndicated;

    //
    // since we send keep alives on connections in the the inbound
    // state it is possible to get a keep alive, so just return in that
    // case
    //
    if (((tSESSIONHDR UNALIGNED *)pTsdu)->Type == NBT_SESSION_KEEP_ALIVE)
    {
        return(STATUS_SUCCESS);
    }

    //
    // Session ** INBOUND ** setup processing
    //
    if ((pSessionHdr->Type != NBT_SESSION_REQUEST) ||
        (BytesIndicated < (sizeof(tSESSIONHDR) + 2*(1+2*NETBIOS_NAME_SIZE+1))))
    {
        //
        // The Session Request packet is of the form:
        //  -- Session Header = 4 bytes
        //  -- Called name = 34+x (1 + 32 + 1(==ScopeLength) + x(==Scope))
        //  -- Calling name= 34+y (1 + 32 + 1(==ScopeLength) + y(==Scope))
        //
        CTESpinFreeAtDpc(pLowerConn);

        KdPrint(("Nbt.Inbound[2]: ERROR -- Bad Session PDU - Type=<%x>, BytesInd=[%d]<[%d], Src=<%x>\n",
            pSessionHdr->Type, BytesIndicated, (sizeof(tSESSIONHDR)+2*(1+2*NETBIOS_NAME_SIZE+1)),pLowerConn->SrcIpAddr));
        NbtTrace(NBT_TRACE_INBOUND, ("pLowerConn %p: bad Session PDU on %!ipaddr!",
                                            pLowerConn, pLowerConn->SrcIpAddr));

#ifdef _NETBIOSLESS
        status = STATUS_INTERNAL_ERROR;

        // In message-only mode, don't send session responses back over the wire
        if (!IsDeviceNetbiosless(pLowerConn->pDeviceContext))
#endif
        {
            RejectSession(pLowerConn, NBT_NEGATIVE_SESSION_RESPONSE, SESSION_UNSPECIFIED_ERROR, TRUE);
        }
        goto Inbound_Exit1;
    }

    // the LowerConn Lock is held prior to calling this routine, so free it
    // here since we need to get the joint lock first
    CTESpinFreeAtDpc(pLowerConn);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pLowerConn);

    // it is possible for the disconnect handler to run while the pLowerConn
    // lock is released above, to get the ConnEle  lock, and change the state
    // to disconnected.
    if (pLowerConn->State != NBT_SESSION_INBOUND)
    {
        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
#ifdef _NETBIOSLESS
        status = STATUS_CONNECTION_DISCONNECTED;
#endif
        NbtTrace(NBT_TRACE_INBOUND, ("pLowerConn %p: Incorrect state", pLowerConn));
        goto Inbound_Exit1;
    }

    CTESpinFreeAtDpc(pLowerConn);

    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.Inbound: In SessionSetupnotOS, connection state = %X\n",pLowerConn->State));

    status = FindSessionEndPoint(pTsdu,
                    ConnectionContext,
                    BytesIndicated,
                    &pClientEle,
                    &pRemoteAddress,
                    &RemoteAddressLength);

    if (status != STATUS_SUCCESS)
    {
        //
        // could not find the desired end point so send a negative session
        // response pdu and then disconnect
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NbtTrace(NBT_TRACE_INBOUND, ("pLowerConn %p: FindSessionEndPoint return %!status!", pLowerConn, status));

#ifdef _NETBIOSLESS
        // In message-only mode, don't send session responses back over the wire
        if (!IsDeviceNetbiosless(pLowerConn->pDeviceContext))
#endif
        {
            RejectSession(pLowerConn, NBT_NEGATIVE_SESSION_RESPONSE, status, TRUE);
        }

        KdPrint (("Nbt.Inbound[3]: WARNING!!! FindSessionEndPoint failed, Rejecting Request\n"));
        goto Inbound_Exit1;
    }

    //
    // we must first check for a valid LISTEN....
    //
    CTESpinLockAtDpc(pDeviceContext);
    CTESpinLockAtDpc(pClientEle);
    if (!IsListEmpty(&pClientEle->ListenHead))
    {
        tLISTENREQUESTS     *pListen;
        tLISTENREQUESTS     *pListenTarget ;

        //
        //  Find the first listen that matches the remote name else
        //  take a listen that specified '*'
        //
        pListenTarget = NULL;
        for ( pEntry  = pClientEle->ListenHead.Flink ;
              pEntry != &pClientEle->ListenHead ;
              pEntry  = pEntry->Flink )
        {
            pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);

            // in NT-land the pConnInfo structure is passed in , but the
            // remote address field is nulled out... so we need to check
            // both of these before going on to check the remote address.
            if (pListen->pConnInfo && pListen->pConnInfo->RemoteAddress)
            {

                if (CTEMemEqu(((PTA_NETBIOS_ADDRESS)pListen->pConnInfo->RemoteAddress)->
                        Address[0].Address[0].NetbiosName,
                        pRemoteAddress->Address[0].Address[0].NetbiosName,
                        NETBIOS_NAME_SIZE))
                {
                    pListenTarget = pListen;
                    break;
                }
            }
            else
            {
                //
                //  Specified '*' for the remote name, save this,
                //  look for listen on a real name - only save if it is
                //  the first * listen found
                //
                if (!pListenTarget)
                {
                    pListenTarget = pListen ;
                }
            }
        }

        if (pListenTarget)
        {
            PTA_NETBIOS_ADDRESS     pRemoteAddr;

            RemoveEntryList( &pListenTarget->Linkage );

            //
            // Fill in the remote machines name to return to the client
            //
            if ((pListenTarget->pReturnConnInfo) &&
                (pRemoteAddr = pListenTarget->pReturnConnInfo->RemoteAddress))
            {
                CTEMemCopy(pRemoteAddr,pRemoteAddress,RemoteAddressLength);
            }

            //
            // get the upper connection end point out of the listen and
            // hook the upper and lower connections together.
            //
            pConnectEle = (tCONNECTELE *)pListenTarget->pConnectEle;
            CHECK_PTR(pConnectEle);
            CTESpinLockAtDpc(pConnectEle);

            pLowerConn->pUpperConnection = pConnectEle;
            pConnectEle->pLowerConnId = pLowerConn;
            pConnectEle->pIrpRcv = NULL;

            //
            // Previously, the LowerConnection was in the SESSION_INBOUND state
            // hence we have to remove it from the WaitingForInbound Q and put
            // it on the active LowerConnection list!
            //
            ASSERT (pLowerConn->State == NBT_SESSION_INBOUND);
            RemoveEntryList (&pLowerConn->Linkage);
            InsertTailList (&pLowerConn->pDeviceContext->LowerConnection, &pLowerConn->Linkage);
            InterlockedDecrement (&pLowerConn->pDeviceContext->NumWaitingForInbound);
            //
            // Change the RefCount Context to Connected!
            //
            NBT_SWAP_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, REF_LOWC_CONNECTED, FALSE);

            //
            // put the upper connection on its active list
            //
            RemoveEntryList(&pConnectEle->Linkage);
            InsertTailList(&pConnectEle->pClientEle->ConnectActive, &pConnectEle->Linkage);

            //
            //  Save the remote name while we still have it
            //
            CTEMemCopy (pConnectEle->RemoteName,
                        pRemoteAddress->Address[0].Address[0].NetbiosName,
                        NETBIOS_NAME_SIZE ) ;

            //
            // since the lower connection now points to pConnectEle, increment
            // the reference count so we can't free pConnectEle memory until
            // the lower conn no longer points to it.
            ClearConnStructures(pLowerConn,pConnectEle);
            NBT_REFERENCE_CONNECTION (pConnectEle, REF_CONN_CONNECT);

            if (pListenTarget->Flags & TDI_QUERY_ACCEPT)
            {
                SET_STATE_UPPER (pConnectEle, NBT_SESSION_WAITACCEPT);
                SET_STATE_LOWER (pLowerConn, NBT_SESSION_WAITACCEPT);
                SET_STATERCV_LOWER (pLowerConn, NORMAL, RejectAnyData);
            }
            else
            {
                SET_STATE_UPPER (pConnectEle, NBT_SESSION_UP);
                SET_STATE_LOWER (pLowerConn, NBT_SESSION_UP);
                SET_STATERCV_LOWER (pLowerConn, NORMAL, Normal);
            }

            CTESpinFreeAtDpc(pConnectEle);
            CTESpinFreeAtDpc(pClientEle);
            CTESpinFreeAtDpc(pDeviceContext);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (pListenTarget->Flags & TDI_QUERY_ACCEPT)
            {
                IF_DBG(NBT_DEBUG_DISCONNECT)
                    KdPrint(("Nbt.Inbound: Completing Client's Irp to make client issue Accept\n"));

                //
                // complete the client listen irp, which will trigger him to
                // issue an accept, which should find the connection in the
                // WAIT_ACCEPT state, and subsequently cause a session response
                // to be sent.
#ifndef VXD
                // the irp can't get cancelled because the cancel listen routine
                // also grabs the Client spin lock and removes the listen from the
                // list..
                CTEIoComplete( pListenTarget->pIrp,STATUS_SUCCESS,0);
#else
                CTEIoComplete( pListenTarget->pIrp,STATUS_SUCCESS, (ULONG) pConnectEle);
#endif
            }
            else
            {
                IF_DBG(NBT_DEBUG_DISCONNECT)
                    KdPrint(("Nbt.Inbound: Calling CompleteSessionSetup to send session response PDU\n"));

                //
                // We need to send a session response PDU here, since
                // we do not have to wait for an accept in this case
                //
                CompleteSessionSetup(pClientEle, pLowerConn,pConnectEle, pListenTarget->pIrp);
            }

            CTEMemFree((PVOID)pRemoteAddress);
            CTEMemFree(pListenTarget);

            // now that we have notified the client, dereference it
            //
            NBT_DEREFERENCE_CLIENT(pClientEle);

            PUSH_LOCATION(0x60);
            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.Inbound: Accepted Connection by a Listen %X LowerConn=%X, BytesTaken=<%x>\n",
                    pConnectEle,pLowerConn, BytesAvailable));

            // fake out the transport so it frees its receive buffer (i.e. we
            // say that we accepted all of the data)
            *BytesTaken = BytesAvailable;
            status = STATUS_SUCCESS;
            goto Inbound_Exit1;
        }
    }
    CTESpinFreeAtDpc(pClientEle);
    CTESpinFreeAtDpc(pDeviceContext);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // No LISTEN, so check for an Event handler
    //
    if (!pClientEle->ConEvContext)
    {
        NbtTrace(NBT_TRACE_INBOUND, ("pLowerConn %p: No listener", pLowerConn));

#ifdef _NETBIOSLESS
        status = STATUS_REMOTE_NOT_LISTENING;

        // In message-only mode, don't send session responses back over the wire
        if (!IsDeviceNetbiosless(pLowerConn->pDeviceContext))
#endif
        {
            RejectSession(pLowerConn,
                          NBT_NEGATIVE_SESSION_RESPONSE, 
                          SESSION_NOT_LISTENING_ON_CALLED_NAME, 
                          TRUE);
        }

        // undo the reference done in FindEndpoint
        //
        NBT_DEREFERENCE_CLIENT(pClientEle);
        //
        // free the memory allocated for the Remote address data structure
        //
        CTEMemFree((PVOID)pRemoteAddress);

        KdPrint (("Nbt.Inbound[4]: WARNING!!! Rejecting Request -- No Listen or EventHandler\n"));
        goto Inbound_Exit1;
    }
#ifdef VXD
    else
    {
        ASSERT( FALSE ) ;
    }
#endif

    // now call the client's connect handler...
    pIrp = NULL;
#ifndef VXD         // VXD doesn't support event handlers

    status = (*pClientEle->evConnect)(pClientEle->ConEvContext,
                             RemoteAddressLength,
                             pRemoteAddress,
                             0,
                             NULL,
                             0,          // options length
                             NULL,       // Options
                             &ConnectId,
                             &pIrp
                             );
    NbtTrace(NBT_TRACE_INBOUND, ("pLowerConn %p: TDI_ACCEPT pIrp %p %!status! for %!NBTNAME!<%02x>",
                        pLowerConn, pIrp, status,
                        pRemoteAddress->Address[0].Address[0].NetbiosName,
                        (unsigned)pRemoteAddress->Address[0].Address[0].NetbiosName[15]
                        ));

    //
    // With the new TDI semantics is it illegal to return STATUS_EVENT_DONE
    // or STATUS_EVENT_PENDING from the connect event handler
    //
    ASSERT(status != STATUS_EVENT_PENDING);
    ASSERT(status != STATUS_EVENT_DONE);


    // now that we have notified the client, dereference it
    //
    NBT_DEREFERENCE_CLIENT(pClientEle);

    // Check the returned status codes..
    if (status == STATUS_MORE_PROCESSING_REQUIRED && pIrp != NULL)
    {
        PIO_STACK_LOCATION          pIrpSp;

        // the pConnEle ptr was stored in the FsContext value when the connection
        // was initially created.
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        pConnectEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;
        if (!NBT_VERIFY_HANDLE2 (pConnectEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
        {
            ASSERTMSG ("Nbt.Inbound: ERROR - Invalid Connection Handle\n", 0);
            status = STATUS_INTERNAL_ERROR;
        }
        else
        {
            //
            //  Save the remote name while we still have it
            //
            CHECK_PTR(pConnectEle);
            CTEMemCopy( pConnectEle->RemoteName,
                        pRemoteAddress->Address[0].Address[0].NetbiosName,
                        NETBIOS_NAME_SIZE ) ;

            // be sure the connection is in the correct state
            //
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            CTESpinLockAtDpc(pDeviceContext);
            CTESpinLockAtDpc(pClientEle);
            CTESpinLockAtDpc(pConnectEle);

            if (pConnectEle->state == NBT_ASSOCIATED)
            {
                //
                // Previously, the LowerConnection was in the SESSION_INBOUND state
                // hence we have to remove it from the WaitingForInbound Q and put
                // it on the active LowerConnection list!
                //
                ASSERT (pLowerConn->State == NBT_SESSION_INBOUND);
                RemoveEntryList (&pLowerConn->Linkage);
                InsertTailList (&pLowerConn->pDeviceContext->LowerConnection, &pLowerConn->Linkage);
                InterlockedDecrement (&pLowerConn->pDeviceContext->NumWaitingForInbound);
                //
                // Change the RefCount Context to Connected!
                //
                NBT_SWAP_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND,REF_LOWC_CONNECTED, FALSE);

                // since the lower connection now points to pConnectEle, increment
                // the reference count so we can't free pConnectEle memory until
                // the lower conn no longer points to it.
                //
                NBT_REFERENCE_CONNECTION (pConnectEle, REF_CONN_CONNECT);
                ClearConnStructures(pLowerConn,pConnectEle);
                SET_STATE_UPPER (pConnectEle, NBT_SESSION_UP);
                SET_STATE_LOWER (pLowerConn, NBT_SESSION_UP);
                SetStateProc (pLowerConn, Normal);

                RemoveEntryList(&pConnectEle->Linkage);
                InsertTailList(&pConnectEle->pClientEle->ConnectActive, &pConnectEle->Linkage);

                status = STATUS_SUCCESS;
            }
            else
            {
                status = STATUS_INTERNAL_ERROR;
            }

            CTESpinFreeAtDpc(pConnectEle);
            CTESpinFreeAtDpc(pClientEle);
            CTESpinFreeAtDpc(pDeviceContext);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (STATUS_SUCCESS == status)
            {
                CompleteSessionSetup(pClientEle,pLowerConn,pConnectEle,pIrp);
            }
        }
    }
    else
    {
        status = STATUS_DATA_NOT_ACCEPTED;
    }

    if (status != STATUS_SUCCESS)
    {
        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.Inbound: The client rejected in the inbound connection status = %X\n", status));

#ifdef _NETBIOSLESS
        // In message-only mode, don't send session responses back over the wire
        if (!IsDeviceNetbiosless(pLowerConn->pDeviceContext))
#endif
        {
            RejectSession(pLowerConn,
                          NBT_NEGATIVE_SESSION_RESPONSE,
                          SESSION_CALLED_NAME_PRESENT_NO_RESRC,
                          TRUE);
        }
    }
#endif
    //
    // free the memory allocated for the Remote address data structure
    //
    CTEMemFree((PVOID)pRemoteAddress);

Inbound_Exit1:
    // This spin lock is held by the routine that calls this one, and
    // freed when this routine starts, so we must regrab this lock before
    // returning
    //
    CTESpinLockAtDpc(pLowerConn);

#ifdef _NETBIOSLESS
    // In message only mode, return the real status
    return (IsDeviceNetbiosless(pLowerConn->pDeviceContext) ? status : STATUS_SUCCESS );
#else
    return(STATUS_SUCCESS);
#endif
}
//----------------------------------------------------------------------------
VOID
ClearConnStructures (
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  tCONNECTELE         *pConnectEle
    )
/*++

Routine Description:

    This routine sets various parts of the connection datastructures to
    zero, in preparation for a new connection.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    CHECK_PTR(pConnectEle);
#ifndef VXD
    pConnectEle->FreeBytesInMdl = 0;
    pConnectEle->CurrentRcvLen = 0;
    pLowerConn->BytesInIndicate = 0;
#endif
    pConnectEle->ReceiveIndicated = 0;
    pConnectEle->BytesInXport = 0;
    pConnectEle->BytesRcvd = 0;
    pConnectEle->TotalPcktLen = 0;
    pConnectEle->OffsetFromStart = 0;
    pConnectEle->pIrpRcv = NULL;
    pConnectEle->pIrp = NULL;
    pConnectEle->pIrpDisc = NULL;
    pConnectEle->pIrpClose = NULL;
    pConnectEle->DiscFlag = 0;
    pConnectEle->JunkMsgFlag = FALSE;
    pConnectEle->pLowerConnId = pLowerConn;
    InitializeListHead(&pConnectEle->RcvHead);

    pLowerConn->pUpperConnection = pConnectEle;
    SET_STATERCV_LOWER(pLowerConn, NORMAL, pLowerConn->CurrentStateProc);

    pLowerConn->BytesRcvd = 0;
    pLowerConn->BytesSent = 0;

}
//----------------------------------------------------------------------------
NTSTATUS
CompleteSessionSetup (
    IN  tCLIENTELE          *pClientEle,
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  tCONNECTELE         *pConnectEle,
    IN  PCTE_IRP            pIrp
    )
/*++

Routine Description:

    This routine is called to setup an outbound session
    once the tcp connection is up.  The transport calls this routine with
    a session setup response pdu.

    The pConnectEle + Joinlock are held when this routine is called.


Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS        status;
    CTELockHandle   OldIrq;

#ifdef _NETBIOSLESS
    // In message-only mode, don't send session responses back over the wire
    if (IsDeviceNetbiosless(pLowerConn->pDeviceContext))
    {
        status = STATUS_SUCCESS;
    }
    else
#endif
    {
        status = TcpSendSessionResponse(pLowerConn, NBT_POSITIVE_SESSION_RESPONSE, 0L);
    }

    if (NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.CompleteSessionSetup: Accepted ConnEle=%p LowerConn=%p\n",pConnectEle,pLowerConn));

        //
        // complete the client's accept Irp
        //
#ifndef VXD
        CTEIoComplete (pIrp, STATUS_SUCCESS, 0);
#else
        CTEIoComplete (pIrp, STATUS_SUCCESS, (ULONG)pConnectEle);
#endif
    }
    else
    {   //
        // if we have some trouble sending the Session response, then
        // disconnect the connection
        //
        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.CompleteSessionSetup: Could not send Session Response, status = %X\n", status));

        RejectSession(pLowerConn, NBT_NEGATIVE_SESSION_RESPONSE, SESSION_CALLED_NAME_PRESENT_NO_RESRC, TRUE);

        CTESpinLock(&NbtConfig.JointLock, OldIrq);
        RelistConnection(pConnectEle);
        CTESpinFree(&NbtConfig.JointLock, OldIrq);

        // Disconnect To Client - i.e. a negative Accept
        // this will get done when the disconnect indication
        // comes back from the transport
        //
        GetIrpIfNotCancelled(pConnectEle,&pIrp);
        if (pIrp)
        {
            CTEIoComplete(pIrp,STATUS_UNSUCCESSFUL,0);
        }
    }
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
Outbound (
    IN  PVOID               ReceiveEventContext,
    IN  PVOID               ConnectionContext,
    IN  USHORT              ReceiveFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *RcvBuffer

    )
/*++

Routine Description:

    This routine is called while seting up an outbound session
    once the tcp connection is up.  The transport calls this routine with
    a session setup response pdu .


Arguments:

    pClientEle      - ptr to the connection record for this session


Return Value:

    NTSTATUS - Status of receive operation

--*/
{

    tSESSIONHDR UNALIGNED    *pSessionHdr;
    tLOWERCONNECTION         *pLowerConn;
    CTELockHandle            OldIrq;
    PIRP                     pIrp;
    tTIMERQENTRY             *pTimerEntry;
    tCONNECTELE              *pConnEle;
    tDGRAM_SEND_TRACKING     *pTracker;
    tDEVICECONTEXT           *pDeviceContext;

    // get the ptr to the lower connection
    //
    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;
    pSessionHdr = (tSESSIONHDR UNALIGNED *)pTsdu;
    pDeviceContext = pLowerConn->pDeviceContext;

    NbtTrace(NBT_TRACE_OUTBOUND, ("pLowerConn %p pConnEle %p pDeviceContext %p BytesIndicated %d",
                        pLowerConn, pLowerConn->pUpperConnection, pDeviceContext, BytesIndicated));

    //
    // fake out the transport so it frees its receive buffer (i.e. we
    // say that we accepted all of the data)
    //
    *BytesTaken = BytesIndicated;
    //
    // since we send keep alives on connections in the the inbound
    // state it is possible to get a keep alive, so just return in that
    // case
    //
    if (((tSESSIONHDR UNALIGNED *)pTsdu)->Type == NBT_SESSION_KEEP_ALIVE)
    {
        NbtTrace(NBT_TRACE_OUTBOUND, ("Return success for NBT_SESSION_KEEP_ALIVE"));
        return(STATUS_SUCCESS);
    }

    // the LowerConn Lock is held prior to calling this routine, so free it
    // here since we need to get the joint lock first
    CTESpinFreeAtDpc(pLowerConn);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pLowerConn);

    //
    // it is possible for the disconnect handler to run while the pLowerConn
    // lock is released above, to get the ConnEle  lock, and change the state
    // to disconnected.
    //
    if ((!(pConnEle = pLowerConn->pUpperConnection)) ||
        (pConnEle->state != NBT_SESSION_OUTBOUND))
    {
        NbtTrace(NBT_TRACE_OUTBOUND, ("Reset outbound connection %p", pConnEle));

        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        RejectSession(pLowerConn,0,0,FALSE);
        goto ExitCode;
    }

    //
    // if no Connect Tracker, then SessionStartupCompletion has run and
    // the connection is about to be closed, so return.
    //
    if (!(pTracker = (tDGRAM_SEND_TRACKING *)pConnEle->pIrpRcv))
    {
        CTESpinFreeAtDpc(pLowerConn);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NbtTrace(NBT_TRACE_OUTBOUND, ("No tracker for pConnEle %p", pConnEle));
        goto ExitCode;
    }

    CHECK_PTR(pTracker);
    CHECK_PTR(pConnEle);

    pConnEle->pIrpRcv = NULL;

    //
    // Stop the timer started in SessionStartupCompletion to time the
    // Session Setup Response message - it is possible for this routine to
    // run before SessionStartupCompletion, in which case there will not be
    // any timer to stop.
    //
    if (pTimerEntry = pTracker->pTimer)
    {
        pTracker->pTimer = NULL;
        StopTimer(pTimerEntry,NULL,NULL);
    }

    if (pSessionHdr->Type == NBT_POSITIVE_SESSION_RESPONSE)
    {
        // zero out the number of bytes received so far, since this is  a new connection
        CHECK_PTR(pConnEle);
        pConnEle->BytesRcvd = 0;
        SET_STATE_UPPER (pConnEle, NBT_SESSION_UP);

        SET_STATE_LOWER (pLowerConn, NBT_SESSION_UP);
        SetStateProc( pLowerConn, Normal ) ;

        CTESpinFreeAtDpc(pLowerConn);

        GetIrpIfNotCancelled2(pConnEle,&pIrp);

        //
        // if SessionSetupContinue has run, it has set the refcount to zero
        //
        if (pTracker->RefConn == 0)
        {
            //
            // remove the reference done when FindNameOrQuery was called, or when
            // SessionSetupContinue ran
            //
            NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
            FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        }
        else
        {
            pTracker->RefConn--;
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // the assumption is that if the connect irp was cancelled then the
        // client should be doing a disconnect or close shortly thereafter, so
        // there is no error handling code here.
        if (pIrp)
        {
            //
            // complete the client's connect request Irp
            //
#ifndef VXD
            CTEIoComplete( pIrp, STATUS_SUCCESS, 0 ) ;
#else
            CTEIoComplete( pIrp, STATUS_SUCCESS, (ULONG)pConnEle ) ;
#endif
        }
    }
    else
    {
        ULONG       ErrorCode;
        ULONG       state;
        NTSTATUS    status = STATUS_SUCCESS;

        state = pConnEle->state;
        if ((NbtConfig.Unloading) ||
            (!NBT_REFERENCE_DEVICE(pDeviceContext, REF_DEV_OUTBOUND, TRUE)))
        {
            NbtTrace(NBT_TRACE_OUTBOUND, ("Outbound() gets called while unloading driver %x", state));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }


        // If the response is Retarget then setup another session
        // to the new Ip address and port number.
        //
        ErrorCode = (ULONG)((tSESSIONERROR *)pSessionHdr)->ErrorCode;

#ifdef MULTIPLE_WINS
        if ( (status == STATUS_SUCCESS) &&
             ( ((pSessionHdr->Type == NBT_RETARGET_SESSION_RESPONSE) &&
                (pConnEle->SessionSetupCount--))
                            ||
               ((NbtConfig.TryAllNameServers) &&
                (pSessionHdr->Type == NBT_NEGATIVE_SESSION_RESPONSE) &&
                pTracker->RemoteNameLength <= NETBIOS_NAME_SIZE &&      // Don't do it for DNS name
                (pTracker->ResolutionContextFlags != 0xFF))))    // Have not finished querying
        {
#else
        if (pSessionHdr->Type == NBT_RETARGET_SESSION_RESPONSE)
        {
            //
            // retry the session setup if we haven't already exceeded the
            // count
            //
            if (pConnEle->SessionSetupCount--)
            {
#endif
            PVOID                   Context=NULL;
            BOOLEAN                 Cancelled;

            SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);

            // for retarget the destination has specified an alternate
            // port to which the session should be established.
            if (pSessionHdr->Type == NBT_RETARGET_SESSION_RESPONSE)
            {
                pTracker->DestPort = ntohs(((tSESSIONRETARGET *)pSessionHdr)->Port);
                Context = ULongToPtr(ntohl(((tSESSIONRETARGET *)pSessionHdr)->IpAddress));

                NbtTrace(NBT_TRACE_OUTBOUND, ("Retarget to %!ipaddr!:%!port!",
                                            PtrToUlong(Context), (USHORT)(pTracker->DestPort)));
            }
            else
#ifndef MULTIPLE_WINS
            if (ErrorCode == SESSION_CALLED_NAME_NOT_PRESENT)
#endif
            {
                // to tell DelayedReconnect to use the current name(not a retarget)
                Context = NULL;
                NbtTrace(NBT_TRACE_OUTBOUND, ("Called Name Not Present"));
            }

            //
            // Unlink the lower and upper connections.
            //
            CHECK_PTR(pConnEle);
            CHECK_PTR(pLowerConn);
            NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);

            CTESpinFreeAtDpc(pLowerConn);

            //
            // put the pconnele back on the Client's ConnectHead if it
            // has not been cleanedup yet.
            //
            if (state != NBT_IDLE)
            {
                RelistConnection(pConnEle);
            }

            // if a disconnect comes down in this state we we will handle it.
            SET_STATE_UPPER (pConnEle, NBT_RECONNECTING);

            CHECK_PTR(pConnEle);

#ifdef MULTIPLE_WINS
            if (pSessionHdr->Type == NBT_RETARGET_SESSION_RESPONSE)
            {
                pConnEle->SessionSetupCount = 0;// only allow one retry
            }
#else
            pConnEle->SessionSetupCount = 0;// only allow one retry
#endif

            pIrp = pConnEle->pIrp;
            Cancelled = FALSE;

            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.Outbound: Attempt Reconnect, error=%X LowerConn %X\n", ErrorCode,pLowerConn));
#ifndef VXD
            // the irp can't be cancelled until the connection
            // starts up again - either when the Irp is in the transport
            // or when we set our cancel routine in SessionStartupCompletion
            //  This disconnect handler cannot complete the Irp because
            // we set the pConnEle state to NBT_ASSOCIATED above, with
            // the spin lock held, which prevents the Disconnect handler
            // from doing anything.
            IoAcquireCancelSpinLock(&OldIrq);
            if (pIrp && !pConnEle->pIrp->Cancel)
            {
                IoSetCancelRoutine(pIrp,NULL);
            }
            else
            {
                Cancelled = TRUE;
                NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p is cancelled", pIrp));
            }

            IoReleaseCancelSpinLock(OldIrq);
#endif

            if (!Cancelled)
            {
                //
                // The enqueuing can not fail because we have already
                // verified the device state earlier
                //
                NTQueueToWorkerThread(
                                &pTracker->WorkItemReconnect,
                                DelayedReConnect,
                                pTracker,
                                Context,
                                NULL,
                                pDeviceContext,
                                TRUE
                                );
            }

            // ...else The irp was already returned, since NtCancelSession
            // Must have already run, so just return
            NBT_DEREFERENCE_DEVICE(pDeviceContext, REF_DEV_OUTBOUND, TRUE);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            RejectSession(pLowerConn,0,0,FALSE);

            // remove the referenced added when the lower and upper
            // connections were attached in nbtconnect.
            //
            NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

            goto ExitCode;
#ifndef MULTIPLE_WINS
        }
#endif
        }

        // the connection will be disconnected by the Call to RejectSession
        // below, so set the state to Associated so the disconnect indication
        // handler will not complete the client's irp too
        //
        CHECK_PTR(pConnEle);
        SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
        pConnEle->pLowerConnId = NULL;

        CTESpinFreeAtDpc(pLowerConn);

        //
        // if nbtcleanupconnection has not been called yet, relist it.
        //
        if (state != NBT_IDLE)
        {
            RelistConnection(pConnEle);
        }

        IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.Outbound: Disconnecting... Failed connection Setup %X Lowercon %X\n",
            pConnEle,pLowerConn));

        GetIrpIfNotCancelled2(pConnEle,&pIrp);

        //
        // if SessionTimedOut has run, it has set the refcount to zero
        //
        if (pTracker->RefConn == 0)
        {
            //
            // remove the reference done when FindNameOrQuery was called, or when
            // SessionSetupContinue ran
            //
            if ((pTracker->pNameAddr->Verify == REMOTE_NAME) &&         // Remote names only!
                (pTracker->pNameAddr->NameTypeState & STATE_RESOLVED) &&
                (pTracker->pNameAddr->RefCount == 2))
            {
                //
                // If no one else is referencing the name, then delete it from
                // the hash table.
                //
                NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_REMOTE, TRUE);
            }
            NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
            FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        }
        else
        {
            pTracker->RefConn--;
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        if (status != STATUS_INVALID_DEVICE_REQUEST)
        {
            // this should cause a disconnect indication to come from the
            // transport which will close the connection to the transport
            //
            RejectSession(pLowerConn,0,0,FALSE);
            NBT_DEREFERENCE_DEVICE(pDeviceContext, REF_DEV_OUTBOUND, FALSE);
        }

        //
        // tell the client that the session setup failed and disconnect
        // the connection
        //
        if (pIrp)
        {
            status = STATUS_REMOTE_NOT_LISTENING;
            if (ErrorCode != SESSION_CALLED_NAME_NOT_PRESENT)
            {
                status = STATUS_BAD_NETWORK_PATH;
            }

            CTEIoComplete(pIrp, status, 0 ) ;
        }
    }

ExitCode:
    // the LowerConn Lock is held prior to calling this routine.  It is freed
    // at the start of this routine and held here again
    CTESpinLockAtDpc(pLowerConn);

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
VOID
GetIrpIfNotCancelled2(
    IN  tCONNECTELE     *pConnEle,
    OUT PIRP            *ppIrp
    )
/*++

Routine Description:

    This routine coordinates access to the Irp by getting the spin lock on
    the client, getting the Irp and clearing the irp in the structure.  The
    Irp cancel routines also check the pConnEle->pIrp and if null they do not
    find the irp, then they return without completing the irp.

    This version of the routine is called with NbtConfig.JointLock held.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    CTELockHandle   OldIrq;

    CTESpinLock(pConnEle,OldIrq);

    *ppIrp = pConnEle->pIrp;
    CHECK_PTR(pConnEle);
    pConnEle->pIrp = NULL;

    CTESpinFree(pConnEle,OldIrq);
}

//----------------------------------------------------------------------------
VOID
GetIrpIfNotCancelled(
    IN  tCONNECTELE     *pConnEle,
    OUT PIRP            *ppIrp
    )
/*++

Routine Description:

    This routine coordinates access to the Irp by getting the spin lock on
    the client, getting the Irp and clearing the irp in the structure.  The
    Irp cancel routines also check the pConnEle->pIrp and if null they do not
    find the irp, then they return without completing the irp.

    This version of the routine is called with NbtConfig.JointLock free.

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    CTELockHandle   OldIrq;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    GetIrpIfNotCancelled2(pConnEle,ppIrp);

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}
//----------------------------------------------------------------------------
NTSTATUS
RejectAnyData(
    IN PVOID                ReceiveEventContext,
    IN tLOWERCONNECTION     *pLowerConn,
    IN USHORT               ReceiveFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT PULONG              BytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *ppIrp
    )
/*++

Routine Description:

    This routine is the receive event indication handler when the connection
    is not up - i.e. nbt thinks no data should be arriving. We just eat the
    data and return.  This routine should not get called.


Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/

{
    NTSTATUS        status;

    //
    // take all of the data so that a disconnect will not be held up
    // by data still in the transport.
    //
    *BytesTaken = BytesAvailable;

    IF_DBG(NBT_DEBUG_DISCONNECT)
    KdPrint(("Nbt.RejectAnyData: Got Session Data in state %X, StateRcv= %X\n",pLowerConn->State,
              pLowerConn->StateRcv));

    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
VOID
RejectSession(
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               StatusCode,
    IN  ULONG               SessionStatus,
    IN  BOOLEAN             SendNegativeSessionResponse
    )
/*++

Routine Description:

    This routine sends a negative session response (if the boolean is set)
    and then disconnects the connection.
    Cleanup connection could have been called to disconnect the call,
    and it changes the state to disconnecting, so don't disconnected
    again if that is happening.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    CTELockHandle       OldIrq2;
    NTSTATUS            status;
    tCONNECTELE         *pConnEle;
    BOOLEAN             DerefConnEle=FALSE;

    //
    // There is no listen event handler so return a status code to
    // the caller indicating that this end is between "listens" and
    // that they should try the setup again in a few milliseconds.
    //
    IF_DBG(NBT_DEBUG_DISCONNECT)
    KdPrint(("Nbt.RejectSession: No Listen or Connect Handlr so Disconnect! LowerConn=%X Session Status=%X\n",
            pLowerConn,SessionStatus));

    if (SendNegativeSessionResponse)
    {
        status = TcpSendSessionResponse(pLowerConn,
                                        StatusCode,
                                        SessionStatus);
    }

    // need to hold this lock if we are to un connect the lower and upper
    // connnections
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    CTESpinLock(pLowerConn->pDeviceContext,OldIrq2);
    CTESpinLock(pLowerConn,OldIrq);

    CHECK_PTR(pLowerConn);
    if ((pLowerConn->State < NBT_DISCONNECTING) &&
        (pLowerConn->State > NBT_CONNECTING))
    {
        if (pLowerConn->State == NBT_SESSION_INBOUND)
        {
            //
            // Previously, the LowerConnection was in the SESSION_INBOUND state
            // hence we have to remove it from the WaitingForInbound Q and put
            // it on the active LowerConnection list!
            //
            RemoveEntryList (&pLowerConn->Linkage);
            InsertTailList (&pLowerConn->pDeviceContext->LowerConnection, &pLowerConn->Linkage);
            InterlockedDecrement (&pLowerConn->pDeviceContext->NumWaitingForInbound);
            //
            // Change the RefCount Context to Connected!
            //
            NBT_SWAP_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, REF_LOWC_CONNECTED, TRUE);
        }
        SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTING);
        SetStateProc( pLowerConn, RejectAnyData ) ;

        pConnEle = pLowerConn->pUpperConnection;
        if (pConnEle)
        {
            CHECK_PTR(pConnEle);
            DerefConnEle = TRUE;
            NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);
            SET_STATE_UPPER (pConnEle, NBT_DISCONNECTING);
        }

        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pLowerConn->pDeviceContext,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        SendTcpDisconnect((PVOID)pLowerConn);
    }
    else
    {
        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pLowerConn->pDeviceContext,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }

    if (DerefConnEle)
    {
        NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);
    }
}


//----------------------------------------------------------------------------
NTSTATUS
FindSessionEndPoint(
    IN  PVOID           pTsdu,
    IN  PVOID           ConnectionContext,
    IN  ULONG           BytesIndicated,
    OUT tCLIENTELE      **ppClientEle,
    OUT PVOID           *ppRemoteAddress,
    OUT PULONG          pRemoteAddressLength
    )
/*++

Routine Description:

    This routine attempts to find an end point on the node with the matching
    net bios name.  It is called at session setup time when a session request
    PDU has arrived.  The routine returns the Client Element ptr.
    The JointLock is held prior to calling this routine!

Arguments:


Return Value:

    NTSTATUS - Status of receive operation

--*/
{

    NTSTATUS                status;
    tCLIENTELE              *pClientEle;
    tLOWERCONNECTION        *pLowerConn;
    CHAR                    pName[NETBIOS_NAME_SIZE];
    PUCHAR                  pScope;
    tNAMEADDR               *pNameAddr;
    tADDRESSELE             *pAddressEle;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pHead;
    ULONG                   lNameSize;
    tSESSIONREQ UNALIGNED   *pSessionReq = (tSESSIONREQ UNALIGNED *)pTsdu;
    ULONG                   sType;
    CTELockHandle           OldIrq1;
    CTELockHandle           OldIrq2;
    PUCHAR                  pSrcName;
    BOOLEAN                 Found;

    // get the ptr to the lower connection, and from that get the ptr to the
    // upper connection block
    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;

    if (pSessionReq->Hdr.Type != NBT_SESSION_REQUEST)
    {
        KdPrint (("Nbt.FindSessionEndPoint: WARNING!!! Rejecting Request, pSessionReq->Hdr.Type=<%d>!=<%d>\n",
            pSessionReq->Hdr.Type, NBT_SESSION_REQUEST));
        return(SESSION_UNSPECIFIED_ERROR);
    }

    // get the called name out of the PDU
    status = ConvertToAscii ((PCHAR)&pSessionReq->CalledName,
                             BytesIndicated - FIELD_OFFSET(tSESSIONREQ,CalledName),
                             pName,
                             &pScope,
                             &lNameSize);

    if (!NT_SUCCESS(status))
    {
        KdPrint (("Nbt.FindSessionEndPoint: WARNING!!! Rejecting Request, ConvertToAscii FAILed!\n"));
        return(SESSION_UNSPECIFIED_ERROR);
    }


    // now try to find the called name in this node's Local table
    //

    //
    // in case a disconnect came in while the spin lock was released
    //
    if (pLowerConn->State != NBT_SESSION_INBOUND)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    pNameAddr = FindName (NBT_LOCAL,pName,pScope,&sType);

    if (!pNameAddr)
    {
        return(SESSION_CALLED_NAME_NOT_PRESENT);
    }

    // we got to here because the name has resolved to a name on this node,
    // so accept the Session setup.
    //
    pAddressEle = (tADDRESSELE *)pNameAddr->pAddressEle;

    // lock the address structure until we find a client on the list
    //
    CTESpinLock(pAddressEle,OldIrq1);

    if (IsListEmpty(&pAddressEle->ClientHead))
    {
        CTESpinFree(pAddressEle,OldIrq1);
        return(SESSION_NOT_LISTENING_ON_CALLED_NAME);
    }

    //
    // get the first client on the list that is bound to the same
    // devicecontext as the connection, with a listen posted, or a valid
    // Connect event handler setup -
    //
    Found = FALSE;
    pHead = &pAddressEle->ClientHead;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

        CTESpinLock(pClientEle,OldIrq2);
        if ((pClientEle->pDeviceContext == pLowerConn->pDeviceContext) &&
            (NBT_VERIFY_HANDLE(pClientEle, NBT_VERIFY_CLIENT)))     // Ensure that client is not going away!
        {
            //
            // if there is a listen posted or a Connect Event Handler
            // then allow the connect attempt to carry on, otherwise go to the
            // next client in the list
            //
            if ((!IsListEmpty(&pClientEle->ListenHead)) ||
                (pClientEle->ConEvContext))
            {
                Found = TRUE;
                break;
            }
        }
        CTESpinFree(pClientEle,OldIrq2);

        pEntry = pEntry->Flink;
    }

    if (!Found)
    {
        CTESpinFree(pAddressEle,OldIrq1);
        return(SESSION_NOT_LISTENING_ON_CALLED_NAME);
    }

    //
    // Ensure we are calculating the Max Buffer size (3rd parameter) properly
    // Bug# 126135
    //
    pSrcName = (PUCHAR)((PUCHAR)&pSessionReq->CalledName.NameLength + 1+lNameSize);
    status = MakeRemoteAddressStructure(
                        pSrcName,
                        0,
                        BytesIndicated-(FIELD_OFFSET(tSESSIONREQ,CalledName.NameLength)+1+lNameSize),
                        ppRemoteAddress,
                        pRemoteAddressLength,
                        1);

    if (!NT_SUCCESS(status))
    {
        CTESpinFree(pClientEle,OldIrq2);
        CTESpinFree(pAddressEle,OldIrq1);

        KdPrint (("Nbt.FindSessionEndPoint: WARNING!!! Rejecting Request, MakeRemoteAddressStructure FAILed!\n"));
        if (status == STATUS_INSUFFICIENT_RESOURCES)
        {
            return(SESSION_CALLED_NAME_PRESENT_NO_RESRC);
        }
        else
        {
            return(SESSION_UNSPECIFIED_ERROR);
        }
    }

    // prevent the client from disappearing before we can indicate to him
    //
    NBT_REFERENCE_CLIENT(pClientEle);

    CTESpinFree(pClientEle,OldIrq2);
    CTESpinFree(pAddressEle,OldIrq1);

    *ppClientEle = pClientEle;
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
MakeRemoteAddressStructure(
    IN  PCHAR           pHalfAsciiName,
    IN  PVOID           pSourceAddr,
    IN  ULONG           lMaxNameSize,
    OUT PVOID           *ppRemoteAddress,
    OUT PULONG          pRemoteAddressLength,
    IN  ULONG           NumAddr
    )
/*++

Routine Description:

    This routine makes up the remote addres structure with the netbios name
    of the source in it, so that the info can be passed to the client...what
    a bother to do this!

Arguments:



Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS            status;
    ULONG               lNameSize;
    CHAR                pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    PTA_NETBIOS_ADDRESS pRemoteAddress;

    // make up the remote address data structure to pass to the client
    status = ConvertToAscii(
                    pHalfAsciiName,
                    lMaxNameSize,
                    pName,
                    &pScope,
                    &lNameSize);

    if (!NT_SUCCESS(status))
    {
        KdPrint (("Nbt.MakeRemoteAddressStructure: WARNING!!! Rejecting Request, ConvertToAscii FAILed!\n"));
        return(status);
    }

    pRemoteAddress = (PTA_NETBIOS_ADDRESS)NbtAllocMem(
                                        NumAddr * sizeof(TA_NETBIOS_ADDRESS),NBT_TAG('2'));
    if (!pRemoteAddress)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pRemoteAddress->TAAddressCount = NumAddr;
    pRemoteAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pRemoteAddress->Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;
    CTEMemCopy(pRemoteAddress->Address[0].Address[0].NetbiosName, pName,NETBIOS_NAME_SIZE);

    *pRemoteAddressLength = FIELD_OFFSET(TA_NETBIOS_ADDRESS, Address[0].Address[0].NetbiosName[NETBIOS_NAME_SIZE]);

    //
    // Copy over the IP address also.
    //
    if (NumAddr == 2)
    {
        TA_ADDRESS          *pTAAddr;
        PTRANSPORT_ADDRESS  pSourceAddress;

        pSourceAddress = (PTRANSPORT_ADDRESS)pSourceAddr;

        pTAAddr = (TA_ADDRESS *) (((PUCHAR)pRemoteAddress)
                                + pRemoteAddress->Address[0].AddressLength
                                + FIELD_OFFSET(TA_NETBIOS_ADDRESS, Address[0].Address));

        pTAAddr->AddressLength = sizeof(TDI_ADDRESS_IP);
        pTAAddr->AddressType = TDI_ADDRESS_TYPE_IP;
        ((TDI_ADDRESS_IP UNALIGNED *)&pTAAddr->Address[0])->in_addr = ((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr;
        *pRemoteAddressLength += (FIELD_OFFSET(TA_ADDRESS, Address) + pTAAddr->AddressLength);
    }

    *ppRemoteAddress = (PVOID)pRemoteAddress;
//    *pRemoteAddressLength = sizeof(TA_NETBIOS_ADDRESS);
//    *pRemoteAddressLength = FIELD_OFFSET(TA_NETBIOS_ADDRESS, Address[0].Address[0]);

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
ConnectHndlrNotOs (
    IN PVOID                pConnectionContext,
    IN LONG                 RemoteAddressLength,
    IN PVOID                pRemoteAddress,
    IN int                  UserDataLength,
    IN VOID UNALIGNED       *pUserData,
    OUT CONNECTION_CONTEXT  *ppConnectionId
    )
/*++

Routine Description:

    This routine is the receive connect indication handler.

    It is called when a TCP connection is being setup for a NetBios session.
    It simply allocates a connection and returns that information to the
    transport so that the connect indication can be accepted.

Arguments:

    pClientEle      - ptr to the connecition record for this session


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    CTELockHandle       OldIrq;
    PLIST_ENTRY         pList;
    tLOWERCONNECTION    *pLowerConn;
    tDEVICECONTEXT      *pDeviceContext;
    PTRANSPORT_ADDRESS  pSrcAddress;
    NTSTATUS            Status;

    pDeviceContext = (tDEVICECONTEXT *)pConnectionContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pDeviceContext);

    // check that the source is an IP address
    //
    pSrcAddress = pRemoteAddress;
    if ((pSrcAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP) ||
        (IsListEmpty(&pDeviceContext->LowerConnFreeHead)) ||
        ((IsDeviceNetbiosless(pDeviceContext)) &&       // Bug # 282190
         (!pDeviceContext->NumServers)))
    {
        if (pSrcAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP) {
            NbtTrace(NBT_TRACE_INBOUND, ("Reject connection on pDeviceContext %p: %!ipaddr!",
                            pDeviceContext,
                            pDeviceContext->IpAddress));
        } else {
            NbtTrace(NBT_TRACE_INBOUND, ("Reject connection on pDeviceContext %p %!ipaddr! <== %!ipaddr!:%!port!",
                    pDeviceContext, pDeviceContext->IpAddress,
                    ((PTDI_ADDRESS_IP)&pSrcAddress->Address[0].Address[0])->in_addr,
                    ((PTDI_ADDRESS_IP)&pSrcAddress->Address[0].Address[0])->sin_port
                        ));
        }
        Status = STATUS_DATA_NOT_ACCEPTED;
    }
    else
    {
        //
        // get a free connection to the transport provider to accept this
        // incoming connnection on.
        //
        pList = RemoveHeadList(&pDeviceContext->LowerConnFreeHead);
        pLowerConn = CONTAINING_RECORD (pList,tLOWERCONNECTION,Linkage);
        pLowerConn->bDisconnectIrpPendingInTCP = FALSE;

        InterlockedDecrement (&pDeviceContext->NumFreeLowerConnections);

        //
        // Move the idle connection to the WaitingForInbound connection list
        //
        InsertTailList (&pDeviceContext->WaitingForInbound,pList);
        InterlockedIncrement (&pDeviceContext->NumWaitingForInbound);

        SET_STATE_LOWER (pLowerConn, NBT_SESSION_INBOUND);
        SET_STATERCV_LOWER (pLowerConn, NORMAL, Inbound);

        // increase the reference count because we are now connected.  Decrement
        // it when we disconnect.
        //
        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND);
        pLowerConn->bOriginator = FALSE;        // this end is NOT the originator

        // save the source clients IP address into the connection Structure
        // *TODO check if we need to do this or not
        //
        pLowerConn->SrcIpAddr = ((PTDI_ADDRESS_IP)&pSrcAddress->Address[0].Address[0])->in_addr;
        *ppConnectionId = (PVOID)pLowerConn;

        Status = STATUS_SUCCESS;
    }

    //
    // If there are less than 2 connections remaining, we allocate another one. The check
    // below is for 0 or 1 connection.
    // In order to protect ourselves from SYN ATTACKS, allocate NbtConfig.SpecialConnIncrement more now until
    // a certain (registry config) value is exhausted (NOTE this number is global and not
    // per device).
    //
    if (((pDeviceContext->NumFreeLowerConnections < NbtConfig.MinFreeLowerConnections) ||
         (pDeviceContext->NumFreeLowerConnections < (pDeviceContext->TotalLowerConnections/10))) &&
        (pDeviceContext->NumQueuedForAlloc < (2*NbtConfig.SpecialConnIncrement)))
    {
        KdPrint(("Nbt.ConnectHndlrNotOs: Queueing SpecialLowerConn: pDevice=<%p>, NumSpecialLowerConn=%d\n",
            pDeviceContext, pDeviceContext->NumSpecialLowerConn));
        NbtTrace(NBT_TRACE_INBOUND, ("pDeviceContext %p: Increase special lower connection to %d",
                        pDeviceContext, pDeviceContext->NumSpecialLowerConn));

#ifdef _PNP_POWER_
        if (!NbtConfig.Unloading)
#endif  // _PNP_POWER_
        {
            if (NT_SUCCESS (NTQueueToWorkerThread(
                            NULL,
                            DelayedAllocLowerConnSpecial,
                            NULL,
                            NULL,
                            NULL,
                            pDeviceContext,
                            TRUE)))
            {
                InterlockedExchangeAdd (&pDeviceContext->NumQueuedForAlloc, NbtConfig.SpecialConnIncrement);
            } else {
                NbtTrace(NBT_TRACE_INBOUND, ("Out of memory"));
            }
        }
    }

    CTESpinFreeAtDpc(pDeviceContext);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(Status);
}

//----------------------------------------------------------------------------
NTSTATUS
DisconnectHndlrNotOs (
    PVOID                EventContext,
    PVOID                ConnectionContext,
    ULONG                DisconnectDataLength,
    PVOID                pDisconnectData,
    ULONG                DisconnectInformationLength,
    PVOID                pDisconnectInformation,
    ULONG                DisconnectIndicators
    )
/*++

Routine Description:

    This routine is the receive disconnect indication handler. It is called
    by the transport when a connection disconnects.  It checks the state of
    the lower connection and basically returns a disconnect request to the
    transport, except in the case where there is an active session.  In this
    case it calls the the clients disconnect indication handler.  The client
    then turns around and calls NbtDisconnect(in some cases), which passes a disconnect
    back to the transport.  The transport won't disconnect until it receives
    a disconnect request from its client (NBT).  If the flag TDI_DISCONNECT_ABORT
    is set then there is no need to pass back a disconnect to the transport.

    Since the client doesn't always issue a disconnect (i.e. the server),
    this routine always turns around and issues a disconnect to the transport.
    In the disconnect done handling, the lower connection is put back on the
    free list if it is an inbound connection.  For out bound connection the
    lower and upper connections are left connected, since these will always
    receive a cleanup and close connection from the client (i.e. until the
    client does a close the lower connection will not be freed for outbound
    connections).

Arguments:

    pClientEle      - ptr to the connecition record for this session


Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS            status;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq2;
    CTELockHandle       OldIrq3;
    CTELockHandle       OldIrq4;
    tLOWERCONNECTION    *pLowerConn;
    tCONNECTELE         *pConnectEle;
    tCLIENTELE          *pClientEle;
    enum eSTATE         state, stateLower;
    BOOLEAN             CleanupLower=FALSE;
    PIRP                pIrp= NULL;
    PIRP                pIrpClose= NULL;
    PIRP                pIrpRcv= NULL;
    tDGRAM_SEND_TRACKING *pTracker;
    tTIMERQENTRY        *pTimerEntry;
    BOOLEAN             InsertOnList=FALSE;
    BOOLEAN             DisconnectIt=FALSE;
    BOOLEAN             bDisconnecting = FALSE;
    ULONG               StateRcv;
    COMPLETIONCLIENT    pCompletion;
    tDEVICECONTEXT      *pDeviceContext = NULL;

    pLowerConn = (tLOWERCONNECTION *)ConnectionContext;
    pConnectEle = pLowerConn->pUpperConnection;
    PUSH_LOCATION(0x63);

    CHECK_PTR(pLowerConn);
    IF_DBG(NBT_DEBUG_DISCONNECT)
    KdPrint(("Nbt.DisconnectHndlrNotOs: Disc Indication, LowerConn state = %X %X\n",
        pLowerConn->State,pLowerConn));

    NbtTrace(NBT_TRACE_DISCONNECT, ("Disconnection Indication: pLowerConn %p pConnEle %p",
                            pLowerConn, pConnectEle));

    // get the current state with the spin lock held to avoid a race condition
    // with the client disconnecting
    //
    if (pConnectEle)
    {
        CHECK_PTR(pConnectEle);
        if (!NBT_VERIFY_HANDLE2 (pConnectEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
        {
            ASSERTMSG ("Nbt.DisconnectHndlrNotOs: Disconnect indication after already disconnected!!\n", 0);
            return STATUS_UNSUCCESSFUL ;
        }

        //
        // We got a case where the ClientEle ptr was null. This shd not happen since the
        // connection shd be associated at this time.
        // Assert for that case to track this better.
        //
        pClientEle = pConnectEle->pClientEle;
        CHECK_PTR(pClientEle);
        if (!NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN))
        {
            ASSERTMSG ("Nbt.DisconnectHndlrNotOs: Bad Client Handle!!\n", 0);
            return STATUS_UNSUCCESSFUL ;
        }

        // need to hold the joint lock if unconnecting the lower and upper
        // connections.
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq4);

        CTESpinLock(pClientEle,OldIrq3);
        CTESpinLock(pConnectEle,OldIrq2);
        CTESpinLock(pLowerConn,OldIrq);

        NbtTrace(NBT_TRACE_DISCONNECT, ("Disconnection Indication: pLowerConn %p pConnEle %p"
                        " %!NBTNAME!<%02x> <==> %!NBTNAME!<%02x>",
                    pLowerConn, pConnectEle,
                    pClientEle->pAddress->pNameAddr->Name,
                    (unsigned)pClientEle->pAddress->pNameAddr->Name[15],
                    pConnectEle->RemoteName,
                    (unsigned)pConnectEle->RemoteName[15]
                    ));

        state = pConnectEle->state;
        stateLower = pLowerConn->State;

#ifdef VXD
        DbgPrint("DisconnectHndlrNotOs: pConnectEle->state = 0x") ;
        DbgPrintNum( (ULONG) state ) ;
        DbgPrint("pLowerConn->state = 0x") ; DbgPrintNum( (ULONG) stateLower ) ;
        DbgPrint("\r\n") ;
#endif

        if ((state > NBT_ASSOCIATED) && (state < NBT_DISCONNECTING))
        {

            PUSH_LOCATION(0x63);
            CHECK_PTR(pConnectEle);
            //
            // this irp gets returned to the client below in the case statement
            // Except in the connecting state where the transport still has
            // the irp. In that case we let SessionStartupContinue complete
            // the irp.
            //
            if ((pConnectEle->pIrp) && (state > NBT_CONNECTING))
            {
                pIrp = pConnectEle->pIrp;
                pConnectEle->pIrp = NULL;
            }

            //
            // if there is a receive irp, get it out of pConnEle since pConnEle
            // will be requeued and could get used again before we try to
            // complete this irp down below. Null the cancel routine if not
            // cancelled and just complete it below.
            //
            if (((state == NBT_SESSION_UP) || (state == NBT_SESSION_WAITACCEPT))
                && (pConnectEle->pIrpRcv))
            {
                CTELockHandle   OldIrql;

                pIrpRcv = pConnectEle->pIrpRcv;

#ifndef VXD
                IoAcquireCancelSpinLock(&OldIrql);
                //
                // if its already cancelled then don't complete it again
                // down below
                //
                if (pIrpRcv->Cancel)
                {
                    pIrpRcv = NULL;
                }
                else
                {
                    IoSetCancelRoutine(pIrpRcv,NULL);
                }
                IoReleaseCancelSpinLock(OldIrql);
#endif
                pConnectEle->pIrpRcv = NULL;
            }

            // This irp is used for DisconnectWait
            //
            if (pIrpClose = pConnectEle->pIrpClose)
            {
                pConnectEle->pIrpClose = NULL;
            }

#ifdef VXD
            if ( pLowerConn->StateRcv == PARTIAL_RCV &&
                 (pLowerConn->fOnPartialRcvList == TRUE) )
            {
                RemoveEntryList( &pLowerConn->PartialRcvList ) ;
                pLowerConn->fOnPartialRcvList = FALSE;
                InitializeListHead(&pLowerConn->PartialRcvList);
            }
#endif

            SET_STATE_UPPER (pConnectEle, NBT_ASSOCIATED);
            SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTING);
            NBT_DISASSOCIATE_CONNECTION (pConnectEle, pLowerConn);

            //
            // save whether it is a disconnect abort or disconnect release
            // in case the client does a disconnect wait and wants the
            // real disconnect status  i.e. they do not have a disconnect
            // indication handler
            //
            pConnectEle->DiscFlag = (UCHAR)DisconnectIndicators;

            //
            // pConnectEle is dereferenced below, now that the lower conn
            // no longer points to it.
            //
            InsertOnList = TRUE;
            DisconnectIt = TRUE;

            //
            // put pConnEle back on the list of idle connection for this
            // client
            //
            RemoveEntryList(&pConnectEle->Linkage);
            InsertTailList(&pClientEle->ConnectHead,&pConnectEle->Linkage);

            if (DisconnectIndicators == TDI_DISCONNECT_RELEASE)
            {
                // setting the state to disconnected will allow the DisconnectDone
                // routine in updsend.c to Delayedcleanupafterdisconnect, when the disconnect
                // completes (since we have been indicated)
                //
                SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTED);
            }
            else
            {
                // there is no disconnect completion to wait for ...since it
                // was an abortive disconnect indication
                // Change the state of the lower conn incase the client has
                // done a disconnect at the same time - we don't want DisconnectDone
                // to also Queue up DelayedCleanupAfterDisconnect
                //
                SET_STATE_LOWER (pLowerConn, NBT_IDLE);
            }
        }
        //
        // the lower connection just went from disconnecting to disconnected
        // so change the state - this signals the DisconnectDone routine to
        // cleanup the connection when the disconnect request completes.
        //
        if (stateLower == NBT_DISCONNECTING)
        {
            SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTED);
            bDisconnecting = pLowerConn->bDisconnectIrpPendingInTCP;
        }
        else if (stateLower == NBT_DISCONNECTED)
        {
            //
            // we get to here if the disconnect request Irp completes before the
            // disconnect indication comes back.  The disconnect completes
            // and checks the state, changing it to Disconnected if it
            // isn't already - see disconnectDone in udpsend.c.  Since
            // the disconnect indication and the disconnect completion
            // have occurred, cleanup the connection.
            //
            CleanupLower = TRUE;

            // this is just a precaution that may not be needed, so we
            // don't queue the cleanup twice...i.e. now that the lower state
            // is disconnected, we change it's state to idle incase the
            // transport hits us again with another disconnect indication.
            // QueueCleanup is called below based on the value in statelower
            SET_STATE_LOWER (pLowerConn, NBT_IDLE);
        }
        //
        // During the time window that a connection is being setup and TCP
        // completes the connect irp, we could get a disconnect indication.
        // the RefCount must be incremented here so that DelayedCleanupAfterDisconnect
        // does not delete the connection (i.e. it expects refcount >= 2).
        //
        if (stateLower <= NBT_CONNECTING)
        {
            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
        }

#if DBG
        if (bDisconnecting && (DisconnectIt || CleanupLower)) {
            ASSERT(pLowerConn->pIrp);
            KdPrint(("Nbt.DisconnectHndlrNotOs: Irp 0x%08lx\n", pLowerConn->pIrp));
        }
#endif
        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pConnectEle,OldIrq2);
        CTESpinFree(pClientEle,OldIrq3);
        CTESpinFree(&NbtConfig.JointLock,OldIrq4);
    }
    else
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq2);
        CTESpinLock(pLowerConn->pDeviceContext,OldIrq3);
        CTESpinLock(pLowerConn,OldIrq);
        stateLower = pLowerConn->State;
        state = NBT_IDLE;

        if ((stateLower > NBT_IDLE) && (stateLower < NBT_DISCONNECTING))
        {
            // flag so we send back a disconnect to the transport
            DisconnectIt = TRUE;

            if (stateLower == NBT_SESSION_INBOUND)
            {
                //
                // Previously, the LowerConnection was in the SESSION_INBOUND state
                // hence we have to remove it from the WaitingForInbound Q and put
                // it on the active LowerConnection list!
                //
                ASSERT (pLowerConn->State == NBT_SESSION_INBOUND);
                RemoveEntryList (&pLowerConn->Linkage);
                InsertTailList (&pLowerConn->pDeviceContext->LowerConnection, &pLowerConn->Linkage);
                InterlockedDecrement (&pLowerConn->pDeviceContext->NumWaitingForInbound);
                //
                // Change the RefCount Context to Connected!
                //
                NBT_SWAP_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, REF_LOWC_CONNECTED, TRUE);
            }
            //
            // set state so that DisconnectDone will cleanup the connection.
            //
            SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTED);
            //
            // for an abortive disconnect we will do a cleanup below, so
            // set the state to idle here
            //
            if (DisconnectIndicators != TDI_DISCONNECT_RELEASE)
            {
                SET_STATE_LOWER (pLowerConn, NBT_IDLE);
            }
        }
        else if (stateLower == NBT_DISCONNECTING)
        {
            // a Disconnect has already been initiated by this side so when
            // DisconnectDone runs it will cleanup
            //
            SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTED);
            bDisconnecting = pLowerConn->bDisconnectIrpPendingInTCP;
        }
        else if ( stateLower == NBT_DISCONNECTED )
        {
            CleanupLower = TRUE;
            SET_STATE_LOWER (pLowerConn, NBT_IDLE);
        }

        //
        // During the time window that a connection is being setup and TCP
        // completes the connect irp, we could get a disconnect indication.
        // the RefCount must be incremented here so that DelayedCleanupAfterDisconnect
        // does not delete the connection (i.e. it expects refcount >= 2).
        //
        if ((stateLower <= NBT_CONNECTING) &&
            (stateLower > NBT_IDLE))
        {
            NBT_REFERENCE_LOWERCONN(pLowerConn, REF_LOWC_CONNECTED);
        }

#if DBG
        if (bDisconnecting && (DisconnectIt || CleanupLower)) {
            ASSERT(pLowerConn->pIrp);
            KdPrint(("Nbt.DisconnectHndlrNotOs: Irp 0x%08lx\n", pLowerConn->pIrp));
        }
#endif

        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pLowerConn->pDeviceContext,OldIrq3);
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
    }

    StateRcv = pLowerConn->StateRcv;
    SetStateProc (pLowerConn, RejectAnyData);

    if (!bDisconnecting && DisconnectIt)
    {
        if (DisconnectIndicators == TDI_DISCONNECT_RELEASE)
        {
            // this disconnects the connection and puts the lowerconn back on
            // its free queue. Note that OutOfRsrcKill calls this routine too
            // with the DisconnectIndicators set to Abort, and the code correctly
            // does not attempt to disconnect the connection since the OutOfRsrc
            // routine had already disconnected it.
            //
            PUSH_LOCATION(0x6d);
            status = SendTcpDisconnect((PVOID)pLowerConn);
        }
        else
        {
            // this is an abortive disconnect from the transport, so there is
            // no need to send a disconnect request back to the transport.
            // So we set a flag that tells us later in the routine to close
            // the lower connection.
            //
            PUSH_LOCATION(0x69);
            CleanupLower = TRUE;
        }
    }

    //
    // for an orderly release, turn around and send a release to the transport
    // if there is no client attached to the lower connection. If there is a
    // client then we must pass the disconnect indication to the client and
    // wait for the client to do the disconnect.
    //
    //
    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.DisconnectHndlrNotOs: ConnEle=<%p>, state = %x\n", pConnectEle, state));

    switch (state)
    {
        case NBT_SESSION_INBOUND:
        case NBT_CONNECTING:

            // if an originator, then the upper and lower connections are
            // already associated, and there is a client irp to return.
            // (NBT_SESSION_CONNECTING only)
            //
            if (pIrp)
            {
                if (pLowerConn->bOriginator)
                {
                    CTEIoComplete(pIrp, STATUS_BAD_NETWORK_PATH, 0);
                }
                else
                {
                    // this could be an inbound call that could not send the
                    // session response correctly.
                    //
                    CTEIoComplete(pIrp, STATUS_UNSUCCESSFUL, 0);
                }
            }

            break;

        case NBT_SESSION_OUTBOUND:
            //
            //
            // Stop the timer started in SessionStartupCompletion to time the
            // Session Setup Response message
            //
            // NbtConnect stores the tracker in the IrpRcv ptr so that this
            // routine can access it
            //
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            CTESpinLock(pConnectEle,OldIrq2);

            //
            // check if anyone else has freed the tracker yet.
            //
            pTracker = (tDGRAM_SEND_TRACKING *)pConnectEle->pIrpRcv;
            CHECK_PTR(pTracker);
            if (pTracker)
            {
                //
                // We received a Disconnect from Tcp while waiting in
                // the Outbound state!
                //
                pConnectEle->pIrpRcv = NULL;
                pTimerEntry = pTracker->pTimer;
                pTracker->pTimer = NULL;

                CTESpinFree(pConnectEle,OldIrq2);

                //
                // if the timer has expired it will not cleanup because the state
                // will not be SESSION_OUTBOUND, since we changed it above to
                // disconnected.  So we always have to complete the irp and
                // call Delayedcleanupafterdisconnect below.
                //
                if (pTimerEntry)
                {
                    StopTimer(pTimerEntry,&pCompletion,NULL);
                }

                //
                // Check if the SessionStartupCompletion has run; if so, RefConn will be 0.
                // Else, decrement so that the tracker goes away when the session send completes.
                //
                if (pTracker->RefConn == 0)
                {
                    if ((pTracker->pNameAddr->Verify == REMOTE_NAME) &&         // Remote names only!
                        (pTracker->pNameAddr->NameTypeState & STATE_RESOLVED) &&
                        (pTracker->pNameAddr->RefCount == 2))
                    {
                        //
                        // If no one else is referencing the name, then delete it from
                        // the hash table.
                        //
                        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_REMOTE, TRUE);
                    }
                    NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                    FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
                }
                else
                {
                    pTracker->RefConn--;
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                }
            }
            else
            {
                CTESpinFree(pConnectEle,OldIrq2);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
            }


            if (pIrp)
            {
                CTEIoComplete(pIrp,STATUS_REMOTE_NOT_LISTENING,0);
            }

            break;

        case NBT_SESSION_WAITACCEPT:
        case NBT_SESSION_UP:

            if (pIrp)
            {
                CTEIoComplete(pIrp,STATUS_CANCELLED,0);
            }
            //
            // check for any RcvIrp that may be still around.  If the
            // transport has the Irp now then pIrpRcv = NULL. There should
            // be no race condition between completing it and CompletionRcv
            // setting pIrpRcv again as long as we cannot be indicated
            // for a disconnect during completion of a Receive. In any
            // case the access is coordinated using the Io spin lock io
            // IoCancelIrp - that routine will only complete the irp once,
            // then it nulls the completion routine.
            //
            if ((StateRcv == FILL_IRP) && pIrpRcv)
            {

                PUSH_LOCATION(0x6f);

                IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.DisconnectHndlrNotOs: Cancelling RcvIrp on Disconnect Indication!!!\n"));

                CTEIoComplete(pIrpRcv,STATUS_CANCELLED,0);
            }

            //
            // this is a disconnect for an active session, so just inform the client
            // and then it issues a Nbtdisconnect. We have already disconnected the
            // lowerconnection with the transport, so all that remains is
            // to cleanup for outgoing calls.
            //

            pClientEle = pConnectEle->pClientEle;

            // now call the client's disconnect handler...NBT always does
            // a abortive disconnect - i.e. the connection is closed when
            // the disconnect indication occurs and does not REQUIRE a
            // disconnect from the client to finish the job.( a disconnect
            // from the client will not hurt though.
            //
            PUSH_LOCATION(0x64);
            if ((pClientEle) &&
                (pClientEle->evDisconnect ) &&
                (!pIrpClose))
            {
                status = (*pClientEle->evDisconnect)(pClientEle->DiscEvContext,
                                            pConnectEle->ConnectContext,
                                            DisconnectDataLength,
                                            pDisconnectData,
                                            DisconnectInformationLength,
                                            pDisconnectInformation,
                                            TDI_DISCONNECT_ABORT);
                NbtTrace(NBT_TRACE_DISCONNECT, ("Client disconnect handler returns %!status!", status));
            }
            else if (pIrpClose)
            {
                //
                // the Client has issued a disconnect Wait irp, so complete
                // it now, indicating to them that a disconnect has occurred.
                //
                if (DisconnectIndicators == TDI_DISCONNECT_RELEASE)
                {
                    status = STATUS_GRACEFUL_DISCONNECT;
                }
                else
                {
                    status = STATUS_CONNECTION_RESET;
                }

                CTEIoComplete(pIrpClose,status,0);
            }

            //
            // return any rcv buffers that have been posted
            //
            CTESpinLock(pConnectEle,OldIrq);
            FreeRcvBuffers(pConnectEle,&OldIrq);
            CTESpinFree(pConnectEle,OldIrq);

            break;

        case NBT_DISCONNECTING:
            // the retry session setup code expects the state to change
            // to disconnected when the disconnect indication comes
            // from the wire
            SET_STATE_UPPER (pConnectEle, NBT_DISCONNECTED);

        case NBT_DISCONNECTED:
        case NBT_ASSOCIATED:
        case NBT_IDLE:

            //
            // catch all other cases here to be sure the connect irp gets
            // returned.
            //
            if (pIrp)
            {
                CTEIoComplete(pIrp,STATUS_CANCELLED,0);
            }
            break;

        default:
            ASSERTMSG("Nbt:Disconnect indication in unexpected state\n",0);

    }

    if (InsertOnList)
    {
        // undo the reference done when the NbtConnect Ran - this may cause
        // pConnEle to be deleted if the Client had issued an NtClose before
        // this routine ran. We only do this dereference if InsertOnList is
        // TRUE, meaning that we just "unhooked" the lower from the Upper.
        NBT_DEREFERENCE_CONNECTION (pConnectEle, REF_CONN_CONNECT);
    }


    // this either puts the lower connection back on its free
    // queue if inbound, or closes the connection with the transport
    // if out bound. (it can't be done at dispatch level).
    //
    if (!bDisconnecting && CleanupLower)
    {
        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.DisconnectHndlrNotOs: Calling Worker thread to Cleanup %X\n",pLowerConn));

        CTESpinLock(pLowerConn,OldIrq);

        if ( pLowerConn->pIrp )
        {
            PCTE_IRP    pIrp;

            pIrp = pLowerConn->pIrp;
            CHECK_PTR(pLowerConn);
            pLowerConn->pIrp = NULL ;

            CTESpinFree(pLowerConn,OldIrq);
            // this is the irp to complete when the disconnect completes - essentially
            // the irp requesting the disconnect.
            CTEIoComplete( pIrp, STATUS_SUCCESS, 0 ) ;
        }
        else
        {
            CTESpinFree(pLowerConn,OldIrq);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));
        ASSERT (pLowerConn->RefCount > 1);

        if (NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT))
        {
            pDeviceContext = pLowerConn->pDeviceContext;
        }

        status = NTQueueToWorkerThread(
                            &pLowerConn->WorkItemCleanUpAndWipeOut,
                            DelayedCleanupAfterDisconnect,
                            NULL,
                            pLowerConn,
                            NULL,
                            pDeviceContext,
                            TRUE);

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
VOID
DelayedCleanupAfterDisconnect(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused2,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
/*++

Routine Description:

    This routine handles freeing lowerconnection data structures back to the
    transport, by calling NTclose (outbound only) or by putting the connection
    back on the connection free queue (inbound only).  For the NT case this
    routine runs within the context of an excutive worker thread.

Arguments:



Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS            status;
    tLOWERCONNECTION    *pLowerConn;
    PIRP                pIrp=NULL;

    pLowerConn = (tLOWERCONNECTION*) pClientContext;

    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.DelayedCleanupAfterDisconnect: Originator= %X, pLowerConn=%X\n",
            pLowerConn->bOriginator,pLowerConn));

    //
    // DEBUG to catch upper connections being put on lower conn QUEUE
    //
    ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));
    ASSERT (pLowerConn->RefCount > 1);
    ASSERT (pLowerConn->pUpperConnection == NULL);

    if (!pLowerConn->bOriginator)
    {
        // ******** THIS WAS AN INCOMING CONNECTION *************

        //
        // Inbound lower connections just get put back on the queue, whereas
        // outbound connections simply get closed.
        //
        if (pLowerConn->SpecialAlloc)
        {
            //
            // Connections allocated due to SynAttack backlog measures are not re-allocated
            // If this was a special connection block, decrement the count of such connections
            //
            if (pDeviceContext)
            {
                InterlockedDecrement(&pDeviceContext->NumSpecialLowerConn);
                KdPrint(("Nbt.DelayedCleanupAfterDisconnect: pDevice=<%p>, NumSpecialLowerConn= %d\n",
                    pDeviceContext, pDeviceContext->NumSpecialLowerConn));
            }
        }
        else if (pDeviceContext)
        {
            //
            // Always close the connection and then Create another since there
            // could be a Rcv Irp in TCP still that will be returned at some
            // later time, perhaps after this connection gets reused again.
            // In that case the Rcv Irp could be lost.
            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.DelayedCleanupAfterDisconnect: LowerConn=<%x>, State=<%x>\n",
                    pLowerConn, pLowerConn->State));

            if (pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT) {
                DelayedAllocLowerConn (NULL, NULL, NULL, pDeviceContext);
            }
        }
    }

    // this deref removes the reference added when the connection
    // connnected.  When NbtDeleteLowerConn is called it dereferences
    // one more time which delete the memory.
    //
    CHECK_PTR (pLowerConn);
    ASSERT (pLowerConn->RefCount >= 2);
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED, FALSE);

    // this does a close on the lower connection, so it can go ahead
    // possibly before the disconnect has completed since the transport
    // will not complete the close until is completes the disconnect.
    //
    status = NbtDeleteLowerConn(pLowerConn);
}

//----------------------------------------------------------------------------
VOID
AllocLowerConn(
    IN  tDEVICECONTEXT *pDeviceContext,
    IN  PVOID          pDeviceSpecial
    )
/*++

Routine Description:

    Allocate a lowerconn block that will go on the lowerconnfreehead.

Arguments:

    pDeviceContext - the device context

Return Value:


--*/
{
    NTSTATUS             status;
    tLOWERCONNECTION    *pLowerConn;

    /*
     * This should be ok since NbtOpenAndAssocConnection call NbtTdiOpenConnection which is PAGEABLE.
     * Make sure we are at the right IRQL.
     */
    CTEPagedCode();
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    if (pDeviceContext->Verify != NBT_VERIFY_DEVCONTEXT) {
        ASSERT (pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT_DOWN);
        CTEExReleaseResource(&NbtConfig.Resource);
        return;
    }
    if (pDeviceSpecial)
    {
        status = NbtOpenAndAssocConnection(pDeviceContext, NULL, &pLowerConn, '0');
    }
    else
    {
        status = NbtOpenAndAssocConnection(pDeviceContext, NULL, NULL, '1');
    }
    CTEExReleaseResource(&NbtConfig.Resource);

    if (pDeviceSpecial)
    {
        //
        // Special lowerconn for Syn attacks
        //
        if (NT_SUCCESS(status))
        {
            pLowerConn->SpecialAlloc = TRUE;
            InterlockedIncrement(&pDeviceContext->NumSpecialLowerConn);
        }

        InterlockedDecrement(&pDeviceContext->NumQueuedForAlloc);
    }
}

//----------------------------------------------------------------------------
VOID
DelayedAllocLowerConn(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pDeviceSpecial,
    IN  PVOID                   pUnused3,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
/*++

Routine Description:

    If lowerconn couldn't be alloced in AllocLowerConn, an event is scheduled
    so that we can retry later.  Well, this is "later"!

Arguments:



Return Value:


--*/
{
    AllocLowerConn(pDeviceContext, pDeviceSpecial);
}

//----------------------------------------------------------------------------
VOID
DelayedAllocLowerConnSpecial(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pUnused2,
    IN  PVOID                   pUnused3,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
/*++

Routine Description:

    If lowerconn couldn't be alloced in AllocLowerConn, an event is scheduled
    so that we can retry later.  Well, this is "later"!

    This is for SYN-ATTACK, so we shd create more than one to beat the incoming
    requests. Create three at a time - this shd be controllable thru' registry.

Arguments:



Return Value:


--*/
{
    ULONG               i;

    if (pDeviceContext->Verify != NBT_VERIFY_DEVCONTEXT) {
        ASSERT (pDeviceContext->Verify == NBT_VERIFY_DEVCONTEXT_DOWN);
        return;
    }

    KdPrint(("Nbt.DelayedAllocLowerConnSpecial: Allocing spl. %d lowerconn...\n",
        NbtConfig.SpecialConnIncrement));

    //
    // Alloc SpecialConnIncrement number of more connections.
    //
    for (i=0; i<NbtConfig.SpecialConnIncrement; i++)
    {
        DelayedAllocLowerConn(NULL, pDeviceContext, NULL, pDeviceContext);
    }
}


//----------------------------------------------------------------------------
VOID
AddToRemoteHashTbl (
    IN  tDGRAMHDR UNALIGNED  *pDgram,
    IN  ULONG                BytesIndicated,
    IN  tDEVICECONTEXT       *pDeviceContext
    )
/*++

Routine Description:

    This routine adds the source address of an inbound datagram to the remote
    hash table so that it can be used for subsequent return sends to that node.

    This routine does not need to be called if the datagram message type is
    Broadcast datagram, since these are sends to the broadcast name '*' and
    there is no send caching this source name

Arguments:



Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    tNAMEADDR           *pNameAddr;
    CTELockHandle       OldIrq;
    UCHAR               pName[NETBIOS_NAME_SIZE];
    NTSTATUS            status;
    LONG                Length;
    ULONG               SrcIpAddr;
    PUCHAR              pScope;
    DWORD               dwTimeOutCount = 0;

    //
    // source ip addr should never be 0.  This is a workaround for UB's NBDD
    // which forwards the datagram, but client puts 0 in SourceIpAddr field
    // of the datagram, we cache 0 and then end up doing a broadcast when we
    // really meant to do a directed datagram to the sender.
    //
    SrcIpAddr = ntohl(pDgram->SrcIpAddr);
    if ((!SrcIpAddr) ||
        (!NT_SUCCESS (status = ConvertToAscii ((PCHAR)&pDgram->SrcName,
                                               (BytesIndicated - FIELD_OFFSET(tDGRAMHDR,SrcName)),
                                               pName,
                                               &pScope,
                                               &Length))))
    {
        return;
    }


    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (NbtConfig.InboundDgramNameCacheTimeOutCount > 1) {
        LONG            lRand = 0;
        LONG            lCurrent = 0;
        PLIST_ENTRY     pEntry = NULL;
        PLIST_ENTRY     pHead = NULL;
        tNAMEADDR       *pNameAddr = NULL;

        if (NbtConfig.NumNameCached >= NbtConfig.MaxNumNameCached) {

            lRand = ((GetRandomNumber(&NbtConfig.RandomNumberSeed)) % NbtConfig.pRemoteHashTbl->lNumBuckets);

            lCurrent = lRand;
            while (NbtConfig.NumNameCached >= NbtConfig.MaxNumNameCached) {

                //
                // Walk from the tail of the list since the oldest ones are at the end
                //
                pHead = &NbtConfig.pRemoteHashTbl->Bucket[lCurrent];
                pEntry = pHead->Blink;
                while (pEntry != pHead && NbtConfig.NumNameCached >= NbtConfig.MaxNumNameCached) {
                    pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
                    pEntry = pEntry->Blink;
                    if ((pNameAddr->NameTypeState & (STATE_RESOLVED | STATE_RELEASED)) &&
                            (pNameAddr->RefCount <= 1) &&
                            (pNameAddr->NameAddFlags & NAME_RESOLVED_BY_DGRAM_IN)) {
                        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                        pNameAddr = NULL;
                    }
                }

                lCurrent++;
                if (lCurrent >= NbtConfig.pRemoteHashTbl->lNumBuckets) {
                    lCurrent = 0;
                }

                if (lCurrent == lRand) {
                    break;
                }
            }

        }

        if (NbtConfig.NumNameCached >= NbtConfig.MaxNumNameCached) {
            //
            // Drop the current name if it is still too high
            //
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return;
        }
    }

    //
    // Add the name to the remote cache.
    //
    status = AddToHashTable(NbtConfig.pRemoteHashTbl,
                            pName,
                            pScope,
                            SrcIpAddr,
                            NBT_UNIQUE,     // always a unique address since you can't send from a group name
                            NULL,
                            &pNameAddr,
                            pDeviceContext,
                            NAME_RESOLVED_BY_DGRAM_IN);

    if (NT_SUCCESS(status))
    {
        //
        // we only want the name to be in the remote cache for the shortest
        // timeout allowed by the remote cache timer, so set the timeout
        // count to 1 which is 1-2 minutes.
        //

        // the name is already in the cache when Pending is returned,
        // so just update the ip address in case it is different.
        //
        if (status == STATUS_PENDING)
        {
            //
            // If the name is resolved then it is ok to overwrite the
            // ip address with the incoming one.  But if it is resolving,
            // then just let it continue resolving.
            //
            if ( (pNameAddr->NameTypeState & STATE_RESOLVED) &&
                 !(pNameAddr->NameTypeState & NAMETYPE_INET_GROUP))
            {
                pNameAddr->TimeOutCount = NbtConfig.InboundDgramNameCacheTimeOutCount;
                // only set the adapter mask for this adapter since we are
                // only sure that this adapter can reach the dest.
                pNameAddr->AdapterMask = pDeviceContext->AdapterMask;
            }
        }
        else
        {
            pNameAddr->TimeOutCount = NbtConfig.InboundDgramNameCacheTimeOutCount;
            //
            // change the state to resolved
            //
            pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
            pNameAddr->NameTypeState |= STATE_RESOLVED;
            pNameAddr->AdapterMask |= pDeviceContext->AdapterMask;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}

//----------------------------------------------------------------------------
NTSTATUS
DgramHndlrNotOs (
    IN  PVOID               ReceiveEventContext,
    IN  ULONG               SourceAddrLength,
    IN  PVOID               pSourceAddr,
    IN  ULONG               OptionsLength,
    IN  PVOID               pOptions,
    IN  ULONG               ReceiveDatagramFlags,
    IN  ULONG               BytesIndicated,
    IN  ULONG               BytesAvailable,
    OUT PULONG              pBytesTaken,
    IN  PVOID               pTsdu,
    OUT PVOID               *ppRcvBuffer,
    IN  tCLIENTLIST         **ppClientList
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler.

    It is called when an a datgram arrives from the network.  The code
    checks the type of datagram and then tries to route the datagram to
    the correct destination on the node.

    This procedure is called with the spin lock held on pDeviceContext.

Arguments:

    ppRcvbuffer will contain the IRP/NCB if only one client is listening,
        NULL if multiple clients are listening
    ppClientList will contain the list clients that need to be completed,
        NULL if only one client is listening



Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    NTSTATUS            LocStatus;
    tCLIENTELE          *pClientEle;
    tCLIENTELE          *pClientEleToDeref = NULL;
    tNAMEADDR           *pNameAddr;
    tADDRESSELE         *pAddress;
    ULONG               RetNameType;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    CHAR                pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    ULONG               lNameSize;
    ULONG               iLength = 0;
    ULONG               RemoteAddressLength;
    PVOID               pRemoteAddress;
    tDEVICECONTEXT      *pDeviceContext = (tDEVICECONTEXT *)ReceiveEventContext;
    tDGRAMHDR UNALIGNED *pDgram = (tDGRAMHDR UNALIGNED *)pTsdu;
    ULONG               lClientBytesTaken;
    ULONG               lDgramHdrSize;
    PIRP                pIrp;
    BOOLEAN             MoreClients;
    BOOLEAN             UsingClientBuffer;
    CTEULONGLONG        AdapterMask;
    ULONG               BytesIndicatedOrig;
    ULONG               BytesAvailableOrig;
    ULONG               Offset;

    //
    // We will be processing only directed or broadcast datagrams
    // Hence, there must be at least the header plus two half ascii names etc.
    // which all adds up to 82 bytes with no user data
    // ie. 14 + (1+32+1) + (1+32+1)     ==> Assuming 0 Scopelength + 0 UserData
    //
    if ((BytesIndicated  < 82) ||
        (pDgram->MsgType < DIRECT_UNIQUE) ||
        (pDgram->MsgType > BROADCAST_DGRAM))
    {
        KdPrint (("Nbt.DgramHndlrNotOs[1]: WARNING! Rejecting Dgram -- BytesIndicated=<%d>, MsgType=<0x%x>\n",
            BytesIndicated, pDgram->MsgType));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // First, find the end of the SourceName .. it should end in a 0 byte,
    // but use strnlen just to be safe!  (BUG # 114996)
    //
    // Then, find the destination name in the local name service tables
    //
    Offset = FIELD_OFFSET(tDGRAMHDR,SrcName.NetBiosName[0]);
    if ((!NT_SUCCESS (LocStatus = strnlen ((PCHAR)pDgram->SrcName.NetBiosName,
                                           BytesIndicated-Offset,
                                           &iLength)))              ||
        (BytesIndicated < (Offset+iLength+1+1+32+1))                ||
        (!NT_SUCCESS (status = ConvertToAscii ((PCHAR)&pDgram->SrcName.NetBiosName[iLength+1],
                                               BytesIndicated-(Offset+iLength+1),    // Bug#: 124441
                                               pName,
                                               &pScope,
                                               &lNameSize))))
    {
        KdPrint (("Nbt.DgramHndlrNotOs: WARNING!!! Rejecting Dgram -- strnlen-><%x>, ConvertToAscii-><%x>\n",
            LocStatus, status));
        KdPrint (("Nbt.DgramHndlrNotOs: iLength=<%d>, Half-Ascii Dest=<%p>, Ascii Dest=<%p>\n",
            iLength, &pDgram->SrcName.NetBiosName[iLength+1], pName));
//        ASSERT (0);
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // check length again, including scopes of names too. The Src
    // scope length is returned in iLength, which also includes the
    // half ascii length
    //
    if (BytesIndicated < ( 82                               // 14(Hdr) + 2 HalfAscii names (2*(1+32+1))
                          +(iLength-(2*NETBIOS_NAME_SIZE))  // Src ScopeLength
                          +(NbtConfig.ScopeLength-1)))      // Dest (ie Local) ScopeLength
    {
        KdPrint (("Nbt.DgramHndlrNoOs[2]: WARNING!!! Rejecting Dgram -- BytesIndicated=<%d> < <%d>\n",
            BytesIndicated, 82+(iLength-(2*NETBIOS_NAME_SIZE))+(NbtConfig.ScopeLength-1)));
        ASSERT (0);
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    status = STATUS_DATA_NOT_ACCEPTED;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // Check for the full name first instead of considering any name with a '*' as
    // the first char as a broadcast name (e.g. *SMBSERVER and *SMBDATAGRAM are not
    // b'cast names).
    //
    pNameAddr = FindName (NBT_LOCAL, pName, pScope, &RetNameType);

    //
    // If we failed above, it might be because the name could start with '*' and is a
    // bcast name.
    //
    if (!pNameAddr)
    {
        //
        // be sure the broadcast name has 15 zeroes after it
        //
        if (pName[0] == '*')
        {
            CTEZeroMemory(&pName[1],NETBIOS_NAME_SIZE-1);
            pNameAddr = FindName (NBT_LOCAL, pName, pScope, &RetNameType);
        }
    }

    // Change the pTsdu ptr to pt to the users data
    // -2 to account for the tNETBIOSNAME and +2 to add the length
    // bytes for both names, +1 for the null on the end of the first
    // name

    lDgramHdrSize   = sizeof(tDGRAMHDR) - 2 + 1+iLength+1 + 1+lNameSize;
    pTsdu           = (PVOID)((PUCHAR)pTsdu + lDgramHdrSize);
    BytesAvailableOrig  = BytesAvailable;
    BytesAvailable -= lDgramHdrSize;
    BytesIndicatedOrig = BytesIndicated;
    BytesIndicated -= lDgramHdrSize;

    //
    // If the name is in the local table and has an address element
    // associated with it AND the name is registered against
    // this adapter, then execute the code in the 'if' block
    //
    AdapterMask = pDeviceContext->AdapterMask;
    if ((pNameAddr) &&
        (pNameAddr->pAddressEle) &&
        (pNameAddr->AdapterMask & AdapterMask))
    {
        pAddress = pNameAddr->pAddressEle;

        // Need to hold Address lock to traverse ClientHead
        CTESpinLock(pAddress, OldIrq1);

        if (!IsListEmpty(&pAddress->ClientHead))
        {
            PLIST_ENTRY         pHead;
            PLIST_ENTRY         pEntry;

            //
            // Increment the reference count to prevent the
            // pAddress from disappearing in the window between freeing
            // the JOINT_LOCK and taking the ADDRESS_LOCK.  We also need to
            // keep the refcount if we are doing a multi client recv, since
            // Clientlist access pAddressEle when distributing the rcv'd dgram
            // in CompletionRcvDgram.
            //
            NBT_REFERENCE_ADDRESS (pAddress, REF_ADDR_DGRAM);

            *pBytesTaken = lDgramHdrSize;

            //
            // Check if there is more than one client that should receive this
            // datagram.  If so then pass down a new buffer to get it and
            // copy it to each client's buffer in the completion routine.
            //
            *ppRcvBuffer = NULL;
            MoreClients = FALSE;
            *ppClientList = NULL;

            pHead = &pAddress->ClientHead;
            pEntry = pHead->Flink;
            while (pEntry != pHead)
            {
                PTDI_IND_RECEIVE_DATAGRAM  EvRcvDgram;
                PVOID                      RcvDgramEvContext;
                PLIST_ENTRY                pRcvEntry;
                tRCVELE                    *pRcvEle;
                ULONG                      MaxLength;
                PLIST_ENTRY                pSaveEntry;

                pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

                // this client must be registered against this adapter to
                // get the data
                //
                if (!(pClientEle->pDeviceContext) ||
                    (pClientEle->pDeviceContext != pDeviceContext))
                {
                    pEntry = pEntry->Flink;
                    continue;
                }

#ifdef VXD
                //
                //  Move all of the RcvAnyFromAny Datagrams to this client's
                //  RcvDatagram list so they will be processed along with the
                //  outstanding datagrams for this client if this isn't a
                //  broadcast reception (RcvAnyFromAny dgrams
                //  don't receive broadcasts).  The first client will
                //  empty the list, which is ok.
                //
                if (*pName != '*')
                {
                    PLIST_ENTRY pDGEntry ;

                    while ( !IsListEmpty( &pDeviceContext->RcvDGAnyFromAnyHead ))
                    {
                        pDGEntry = RemoveHeadList(&pDeviceContext->RcvDGAnyFromAnyHead) ;
                        InsertTailList( &pClientEle->RcvDgramHead, pDGEntry ) ;
                    }
                }
#endif
                // check for datagrams posted to this name, and if not call
                // the recv event handler. NOTE: this assumes that the clients
                // use posted recv buffer OR and event handler, but NOT BOTH.
                // If two clients open the same name, one with a posted rcv
                // buffer and another with an event handler, the one with the
                // event handler will NOT get the datagram!
                //
                if (!IsListEmpty(&pClientEle->RcvDgramHead))
                {
                    MaxLength  = 0;
                    pSaveEntry = pEntry;
                    //
                    // go through all clients finding one that has a large
                    // enough buffer
                    //
                    while (pEntry != pHead)
                    {
                        pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

                        if (IsListEmpty(&pClientEle->RcvDgramHead))
                        {
                            continue;
                        }

                        pRcvEntry = pClientEle->RcvDgramHead.Flink;
                        pRcvEle   = CONTAINING_RECORD(pRcvEntry,tRCVELE,Linkage);

                        if (pRcvEle->RcvLength >= BytesAvailable)
                        {
                            pSaveEntry = pEntry;
                            break;
                        }
                        else
                        {
                            // keep the maximum rcv length around incase none
                            // is large enough
                            //
                            if (pRcvEle->RcvLength > MaxLength)
                            {
                                pSaveEntry = pEntry;
                                MaxLength = pRcvEle->RcvLength;
                            }
                            pEntry = pEntry->Flink;
                        }
                    }

                    //
                    // Get the buffer off the list
                    //
                    pClientEle = CONTAINING_RECORD(pSaveEntry,tCLIENTELE,Linkage);

                    pRcvEntry = RemoveHeadList(&pClientEle->RcvDgramHead);

                    *ppRcvBuffer = pRcvEle->pIrp;
#ifdef VXD
                    ASSERT( pDgram->SrcName.NameLength <= NETBIOS_NAME_SIZE*2) ;
                    LocStatus = ConvertToAscii(
                                        (PCHAR)&pDgram->SrcName,
                                        pDgram->SrcName.NameLength+1,
                                        ((NCB*)*ppRcvBuffer)->ncb_callname,
                                        &pScope,
                                        &lNameSize);

                    if ( !NT_SUCCESS(LocStatus) )
                    {
                        DbgPrint("ConvertToAscii failed\r\n") ;
                    }
#else //VXD

                    //
                    // put the source of the datagram into the return
                    // connection info structure.
                    //
                    if (pRcvEle->ReturnedInfo)
                    {
                        UCHAR   pSrcName[NETBIOS_NAME_SIZE];

                        Offset = FIELD_OFFSET(tDGRAMHDR,SrcName);   // Bug#: 124434
                        LocStatus = ConvertToAscii(
                                            (PCHAR)&pDgram->SrcName,
                                            BytesIndicatedOrig-Offset,
                                            pSrcName,
                                            &pScope,
                                            &lNameSize);

                        if (pRcvEle->ReturnedInfo->RemoteAddressLength >=
                            sizeof(TA_NETBIOS_ADDRESS))
                        {
                            TdiBuildNetbiosAddress(pSrcName,
                                                   FALSE,
                                                   pRcvEle->ReturnedInfo->RemoteAddress);
                        }
                    }

                    //
                    // Null out the cancel routine since we are passing the
                    // irp to the transport
                    //
                    IoAcquireCancelSpinLock(&OldIrq);
                    IoSetCancelRoutine(pRcvEle->pIrp,NULL);
                    IoReleaseCancelSpinLock(OldIrq);
#endif
                    CTEMemFree((PVOID)pRcvEle);

                    if (pAddress->MultiClients)
                    {
                        // the multihomed host always passes the above test
                        // so we need a more discerning test for it.
                        if (!NbtConfig.MultiHomed)
                        {
                            // if the list is more than one on it,
                            // then there are several clients waiting
                            // to receive this datagram, so pass down a buffer to
                            // get it.
                            //
                            MoreClients = TRUE;
                            status = STATUS_SUCCESS;

                            UsingClientBuffer = TRUE;

                            // this break will jump down below where we check if
                            // MoreClients = TRUE

                            //
                            // We will need to keep the Client around when CompletionRcvDgram executes!
                            // Bug#: 124675
                            //
                            NBT_REFERENCE_CLIENT(pClientEle);
                            //
                            // Increment the RefCount by 1 here since there will be
                            // an extra Dereference in CompletionRcvDgram
                            //
                            NBT_REFERENCE_ADDRESS (pAddress, REF_ADDR_MULTICLIENTS);
                            break;
                        }
                        else
                        {

                        }
                    }

                    status = STATUS_SUCCESS;

                    //
                    // jump to end of while to check if we need to buffer
                    // the datagram source address
                    // in the remote hash table
                    //
                    break;
                }
#ifdef VXD
                break;
#else
                EvRcvDgram        = pClientEle->evRcvDgram;
                RcvDgramEvContext = pClientEle->RcvDgramEvContext;

                // don't want to call the default handler since it just
                // returns data not accepted
                if (pClientEle->evRcvDgram != TdiDefaultRcvDatagramHandler)
                {
                    ULONG   NumAddrs;

                    // finally found a real event handler set by a client
                    if (pAddress->MultiClients)
//                        if (pEntry->Flink != pHead)
                    {
                        // if the next element in the list is not the head
                        // of the list then there are several clients waiting
                        // to receive this datagram, so pass down a buffer to
                        // get it.
                        //
                        MoreClients = TRUE;
                        UsingClientBuffer = FALSE;
                        status = STATUS_SUCCESS;

                        //
                        // We will need to keep the Client around when CompletionRcvDgram executes!
                        // Bug#: 124675
                        //
                        NBT_REFERENCE_CLIENT(pClientEle);
                        //
                        // Increment the RefCount by 1 here since there will be
                        // an extra Dereference out of the while loop
                        //
                        NBT_REFERENCE_ADDRESS (pAddress, REF_ADDR_MULTICLIENTS);
                        break;
                    }

                    //
                    // make up an address datastructure - subtracting the
                    // number of bytes skipped from the total length so
                    // convert to Ascii can not bug chk on bogus names.
                    //
                    if (pClientEle->ExtendedAddress)
                    {
                        NumAddrs = 2;
                    }
                    else
                    {
                        NumAddrs = 1;
                    }

                    LocStatus = MakeRemoteAddressStructure(
                                     (PCHAR)&pDgram->SrcName.NameLength,
                                     pSourceAddr,
                                     BytesIndicatedOrig - FIELD_OFFSET(tDGRAMHDR,SrcName.NameLength),
                                     &pRemoteAddress,                      // the end of the pdu.
                                     &RemoteAddressLength,
                                     NumAddrs);

                    if (!NT_SUCCESS(LocStatus))
                    {
                        CTESpinFree(pAddress, OldIrq1);
                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        if (pClientEleToDeref)
                        {
                            NBT_DEREFERENCE_CLIENT (pClientEleToDeref);
                        }
                        NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_DGRAM);
                        return(STATUS_DATA_NOT_ACCEPTED);
                    }

                    NBT_REFERENCE_CLIENT(pClientEle);
                    CTESpinFree(pAddress, OldIrq1);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);

                    if (pClientEleToDeref)
                    {
                        NBT_DEREFERENCE_CLIENT (pClientEleToDeref);
                    }
                    pClientEleToDeref = pClientEle;

                    pIrp = NULL;
                    lClientBytesTaken = 0;
                    LocStatus = (*EvRcvDgram)(RcvDgramEvContext,
                                        RemoteAddressLength,
                                        pRemoteAddress,
                                        OptionsLength,
                                        pOptions,
                                        ReceiveDatagramFlags,
                                        BytesIndicated,
                                        BytesAvailable,
                                        &lClientBytesTaken,
                                        pTsdu,
                                        &pIrp);

                    CTEMemFree((PVOID)pRemoteAddress);

                    CTESpinLock(&NbtConfig.JointLock,OldIrq);
                    CTESpinLock(pAddress, OldIrq1);

                    if (pIrp)
                    {
                        // the client has passed back an irp so pass it
                        // on the transport
                        *pBytesTaken += lClientBytesTaken;
                        *ppRcvBuffer = pIrp;

                        status = STATUS_SUCCESS;
                        break;
                    }
                    else
                    {
                        status = STATUS_DATA_NOT_ACCEPTED;
                    }
                }

                pEntry = pEntry->Flink;     // go to the next client in the list
#endif // VXD
            }// of While

            CTESpinFree(pAddress, OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (pClientEleToDeref)
            {
                NBT_DEREFERENCE_CLIENT (pClientEleToDeref);
            }
            NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_DGRAM);

            //
            // Cache the source address in the remote hash table so that
            // this node can send back to the source even if the name
            // is not yet in the name server yet. (only if not on the
            // same subnet)
            //
            if ((pDgram->MsgType != BROADCAST_DGRAM))
            {
                ULONG               SrcAddress;
                PTRANSPORT_ADDRESS  pSourceAddress;
                ULONG               SubnetMask;

                pSourceAddress = (PTRANSPORT_ADDRESS)pSourceAddr;
                SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);
                SubnetMask     = pDeviceContext->SubnetMask;
                //
                // - cache only if from off the subnet
                // - cache if not sent to 1E,1D,01 name and not from ourselves
                //
                // don't cache dgrams from ourselves, or datagrams to the
                // 1E name, 1D, or 01.
                //
                if (((SrcAddress & SubnetMask) !=
                    (pDeviceContext->IpAddress & SubnetMask))
                                ||
                    ((pName[NETBIOS_NAME_SIZE-1] != 0x1E) &&
                     (pName[NETBIOS_NAME_SIZE-1] != 0x1D) &&
                     (pName[NETBIOS_NAME_SIZE-1] != 0x01) &&
                     (!SrcIsUs(SrcAddress))))
                {
                    AddToRemoteHashTbl(pDgram,BytesIndicatedOrig,pDeviceContext);
                }
            }

            // alloc a block of memory to track where we are in the list
            // of clients so completionrcvdgram can send the dgram to the
            // other clients too.
            //
            if (MoreClients)
            {
                tCLIENTLIST     *pClientList;

                if (pClientList = (tCLIENTLIST *)NbtAllocMem(sizeof(tCLIENTLIST),NBT_TAG('4')))
                {
                    CTEZeroMemory (pClientList, sizeof(tCLIENTLIST));

                    //
                    // Set fProxy field to FALSE since the client list is for
                    // real as versus the PROXY case
                    //
                    pClientList->fProxy = FALSE;

                    // save some context information so we can pass the
                    // datagram to the clients - none of the clients have
                    // recvd the datagram yet.
                    //
                    *ppClientList            = (PVOID)pClientList;
                    pClientList->pAddress    = pAddress;
                    pClientList->pClientEle  = pClientEle; // used for VXD case
                    pClientList->fUsingClientBuffer = UsingClientBuffer;
                    pClientList->ReceiveDatagramFlags = ReceiveDatagramFlags;

                    // make up an address datastructure
                    // Bug # 452211 -- since one of the clients may have the Extended
                    // addressing field set, create an extended address
                    //
                    LocStatus = MakeRemoteAddressStructure(
                                   (PCHAR)&pDgram->SrcName.NameLength,
                                   pSourceAddr,
                                   BytesIndicatedOrig -FIELD_OFFSET(tDGRAMHDR,SrcName.NameLength),// set a max number of bytes so we don't go beyond
                                   &pRemoteAddress,                      // the end of the pdu.
                                   &RemoteAddressLength,
                                   2);
                    if (NT_SUCCESS(LocStatus))
                    {
                        pClientList->pRemoteAddress = pRemoteAddress;
                        pClientList->RemoteAddressLength = RemoteAddressLength;
                        return(STATUS_SUCCESS);
                    }
                    else
                    {
                        *ppClientList = NULL;
                        CTEMemFree(pClientList);
                        status = STATUS_DATA_NOT_ACCEPTED;
                    }
                }
                else
                {
                    status = STATUS_DATA_NOT_ACCEPTED;
                }

                //
                // We failed, so Dereference the Client + Address we had
                // reference earlier for multiple clients
                //
                NBT_DEREFERENCE_CLIENT (pClientEle);
                NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_MULTICLIENTS);
            }
        }
        else
        {
            CTESpinFree(pAddress, OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            status = STATUS_DATA_NOT_ACCEPTED;

            IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.DgramHndlrNotOs: No client attached to the Address %16.16s<%X>\n",
                        pAddress->pNameAddr->Name,pAddress->pNameAddr->Name[15]));
        }
    }
    else
    {

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        status = STATUS_DATA_NOT_ACCEPTED;
    }

#ifdef PROXY_NODE
    IF_PROXY(NodeType)
    {
        ULONG               SrcAddress;
        PTRANSPORT_ADDRESS  pSourceAddress;

        pSourceAddress = (PTRANSPORT_ADDRESS)pSourceAddr;
        SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);

        //
        // check name in the remote name table.  If it is there, it is
        // an internet group and is in the resolved state, send the
        // datagram to all the members except self.  If it is in the
        // resolving state, just return. The fact that we got a
        // datagram send for  an internet group name still in the
        // resolving state indicates that there is a DC on the subnet
        // that responded to the  query for the group received
        // earlier. This means that the DC will respond (unless it
        // goes down) to this datagram send. If the DC is down, the
        // client node will retry.
        //
        // Futures: Queue the Datagram if the name is in the resolving
        //  state.
        //
        // If Flags are zero then it is a non fragmented Bnode send.  There
        // is not point in doing datagram distribution for P,M,or H nodes
        // can they can do their own.
        //
        if (((pDgram->Flags & SOURCE_NODE_MASK) == 0) &&
            (pName[0] != '*') &&
           (!SrcIsUs(SrcAddress)))
        {
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            pNameAddr = FindName (NBT_REMOTE, pName, pScope, &RetNameType);
            if (pNameAddr)
            {
                //
                // We have the name in the RESOLVED state.
                //
                //
                // If the name is an internet group, do datagram distribution
                // function
                // Make sure we don't distribute a datagram that has been
                // sent to us by another proxy.  In other words, distribute
                // the datagram only if we got it first-hand from original node
                //
                if ((pNameAddr->NameTypeState & NAMETYPE_INET_GROUP) &&
                    ((((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr) == pDgram->SrcIpAddr))
                {
                    //
                    // If BytesAvailable != BytesIndicated, it means that
                    // that we don't have the entire datagram.  We need to
                    // get it
                    if (BytesAvailableOrig != BytesIndicatedOrig)
                    {
                        tCLIENTLIST     *pClientList;

                        //
                        // Do some simulation to fake the caller of this fn
                        // (TdiRcvDatagramHndlr) into thinking that there are
                        // multiple clients.  This will result in
                        // TdiRcvDatagramHndlr function getting all bytes
                        // available from TDI and calling
                        // ProxyDoDgramDist to do the datagram distribution
                        //
                        if (pClientList = (tCLIENTLIST *)NbtAllocMem(sizeof(tCLIENTLIST),NBT_TAG('5')))
                        {
                            CTEZeroMemory (pClientList, sizeof(tCLIENTLIST));

                            //
                            // save some context information in the Client List
                            // data structure
                            //
                            *ppClientList = (PVOID)pClientList;
                            //
                            // Set fProxy field to TRUE since the client list
                            // not for real
                            //
                            pClientList->fProxy          = TRUE;

                            //
                            // Make use of the following fields to pass the
                            // information we would need in the
                            // CompletionRcvDgram
                            //
                            pClientList->pAddress = (tADDRESSELE *)pNameAddr;
                            pClientList->pRemoteAddress  = pDeviceContext;

                            status = STATUS_DATA_NOT_ACCEPTED;
                        }
                        else
                        {
                           status = STATUS_UNSUCCESSFUL;
                        }

                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                    } // end of if (we do not have the entire datagram)
                    else
                    {
                        //
                        // Increment the reference count so that this name
                        // does not disappear on us after we free the spin lock.
                        //
                        // DgramSendCleanupTracker will decrement the count
                        //
                        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_SEND_DGRAM);
                        //
                        //We have the entire datagram.
                        //
                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        (VOID)ProxyDoDgramDist(pDgram,
                                               BytesIndicatedOrig,
                                               pNameAddr,
                                               pDeviceContext);

                        status = STATUS_DATA_NOT_ACCEPTED;
                    }

                }  // end of if (if name is an internet group name)
                else
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);

            }  // end of if (Name is there in remote hash table)
            else
            {
                tNAMEADDR   *pResp;

                //
                // the name is not in the cache, so try to get it from
                // WINS
                //
                status = FindOnPendingList(pName,NULL,TRUE,NETBIOS_NAME_SIZE,&pResp);
                if (!NT_SUCCESS(status))
                {
                    //
                    // cache the name and contact the name
                    // server to get the name to IP mapping
                    //
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                    status = RegOrQueryFromNet(
                              FALSE,          //means it is a name query
                              pDeviceContext,
                              NULL,
                              lNameSize,
                              pName,
                              pScope);
                }
                else
                {
                    //
                    // the name is on the pending list doing a name query
                    // now, so ignore this name query request
                    //
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                }
                status = STATUS_DATA_NOT_ACCEPTED;
            }
        }
    }
    END_PROXY
#endif

    return(status);
}

#ifdef PROXY_NODE
//----------------------------------------------------------------------------
NTSTATUS
ProxyDoDgramDist(
    IN  tDGRAMHDR   UNALIGNED   *pDgram,
    IN  DWORD                   DgramLen,
    IN  tNAMEADDR               *pNameAddr,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
/*++

Routine Description:


Arguments:

    ppRcvbuffer will contain the IRP/NCB if only one client is listening,
        NULL if multiple clients are listening
    ppClientList will contain the list clients that need to be completed,
        NULL if only one client is listening

Return Value:

    NTSTATUS - Status of receive operation

Called By:

     DgramHdlrNotOs, CompletionRcvDgram in tdihndlr.c

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    tDGRAMHDR               *pMyBuff;

    //
    // get a buffer for tracking Dgram Sends
    //
    status = GetTracker(&pTracker, NBT_TRACKER_PROXY_DGRAM_DIST);
    if (!NT_SUCCESS(status))
    {
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_SEND_DGRAM, FALSE);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Allocate a buffer and copy the contents of the datagram received
    // into it.  We do this because SndDgram may not have finished by the
    // time we return.
    //
    if (!(pMyBuff = (tDGRAMHDR *) NbtAllocMem(DgramLen,NBT_TAG('6'))))
    {
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_SEND_DGRAM, FALSE);
        FreeTracker (pTracker, RELINK_TRACKER);
        return STATUS_INSUFFICIENT_RESOURCES ;
    }

    CTEMemCopy(pMyBuff, (PUCHAR)pDgram, DgramLen);

    //
    // fill in the tracker data block
    // note that the passed in transport address must stay valid till this
    // send completes
    //
    CHECK_PTR(pTracker);
    pTracker->SendBuffer.pDgramHdr = (PVOID)pMyBuff;
    pTracker->SendBuffer.HdrLength = DgramLen;
    pTracker->SendBuffer.pBuffer   = NULL;
    pTracker->SendBuffer.Length    = 0;
    pTracker->pNameAddr            = pNameAddr;
    pTracker->pDeviceContext       = (PVOID)pDeviceContext;
    pTracker->p1CNameAddr          = NULL;
    //
    // so DgramSendCleanupTracker does not decrement the bytes allocated
    // to dgram sends, since we did not increment the count when we allocated
    // the dgram buffer above.
    //
    pTracker->AllocatedLength      = 0;

    pTracker->pClientIrp           = NULL;
    pTracker->pClientEle           = NULL;

    KdPrint(("Nbt.ProxyDoDgramDist: Name is %16.16s(%X)\n", pNameAddr->Name,
                pNameAddr->Name[15]));

    //
    // Send the datagram to each IP address in the Internet group
    //
    //
    DatagramDistribution(pTracker,pNameAddr);

    return(STATUS_SUCCESS);
}
#endif

//----------------------------------------------------------------------------
NTSTATUS
NameSrvHndlrNotOs (
    IN tDEVICECONTEXT           *pDeviceContext,
    IN PVOID                    pSrcAddress,
    IN tNAMEHDR UNALIGNED       *pNameSrv,
    IN ULONG                    uNumBytes,
    IN BOOLEAN                  fBroadcast
    )
/*++

Routine Description:

    This routine is the receive datagram event indication handler.

    It is called when an a datgram arrives from the network.  The code
    checks the type of datagram and then tries to route the datagram to
    the correct destination on the node.

    This procedure is called with the spin lock held on pDeviceContext.

Arguments:



Return Value:

    NTSTATUS - Status of receive operation

--*/
{
    USHORT              OpCodeFlags;
    NTSTATUS            status;

    // it appears that streams can pass a null data pointer some times
    // and crash nbt...and zero length for the bytes
    if (uNumBytes < sizeof(ULONG))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    OpCodeFlags = pNameSrv->OpCodeFlags;

    //Pnodes always ignore Broadcasts since they only talk to the NBNS unless
    // this node is also a proxy
    if ( ( ((NodeType) & PNODE)) && !((NodeType) & PROXY) )
    {
        if (OpCodeFlags & FL_BROADCAST)
        {
            return(STATUS_DATA_NOT_ACCEPTED);
        }
    }


    // decide what type of name service packet it is by switching on the
    // NM_Flags portion of the word
    switch (OpCodeFlags & NM_FLAGS_MASK)
    {
        case OP_QUERY:
            status = QueryFromNet(
                            pDeviceContext,
                            pSrcAddress,
                            pNameSrv,
                            uNumBytes,      // >= NBT_MINIMUM_QUERY (== 50)
                            OpCodeFlags,
                            fBroadcast);
            break;

        case OP_REGISTRATION:
            //
            // we can get either a registration request or a response
            //
            // is this a request or a response? - if bit is set its a Response

            if (OpCodeFlags & OP_RESPONSE)
            {
                // then this is a response to a previous reg. request
                status = RegResponseFromNet(
                                pDeviceContext,
                                pSrcAddress,
                                pNameSrv,
                                uNumBytes,      // >= NBT_MINIMUM_REGRESPONSE (== 62)
                                OpCodeFlags);
            }
            else
            {
                //
                // check if someone else is trying to register a name
                // owned by this node.  Pnodes rely on the Name server to
                // handle this...hence the check for Pnode
                //
                if (!(NodeType & PNODE))
                {
                    status = CheckRegistrationFromNet(pDeviceContext,
                                                      pSrcAddress,
                                                      pNameSrv,
                                                      uNumBytes);   // >= NBT_MINIMUM_REGREQUEST (== 68)
                }
            }
            break;

        case OP_RELEASE:
            //
            // handle other nodes releasing their names by deleting any
            // cached info
            //
            status = NameReleaseFromNet(
                            pDeviceContext,
                            pSrcAddress,
                            pNameSrv,
                            uNumBytes);         // >= NBT_MINIMUM_REGRESPONSE (== 62)
            break;

        case OP_WACK:
            if (!(NodeType & BNODE))
            {
                // the TTL in the  WACK tells us to increase our timeout
                // of the corresponding request, which means we must find
                // the transaction
                status = WackFromNet(pDeviceContext,
                                     pSrcAddress,
                                     pNameSrv,
                                     uNumBytes);    // >= NBT_MINIMUM_WACK (== 58)
            }
            break;

        case OP_REFRESH:
        case OP_REFRESH_UB:

            break;

        default:
            IF_DBG(NBT_DEBUG_HNDLRS)
                KdPrint(("Nbt.NameSrvHndlrNotOs: Unknown Name Service Pdu type OpFlags = %X\n",
                        OpCodeFlags));
            break;


    }

    return(STATUS_DATA_NOT_ACCEPTED);
}

VOID
DoNothingComplete (
    IN PVOID        pContext
    )
/*++

Routine Description:

    This routine is the completion routine for TdiDisconnect while we are
    retrying connects.  It does nothing.

    This is required because you can't have a NULL TDI completion routine.

--*/
{
    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\inbound.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Inbound.c

Abstract:


    This file implements the inbound name service pdu handling.  It handles
    name queries from the network and Registration responses from the network.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"
#include "ctemacro.h"

#include "inbound.tmh"

NTSTATUS
DecodeNodeStatusResponse(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  ULONG               Length,
    IN  PUCHAR              pName,
    IN  ULONG               lNameSize,
    IN  tIPADDRESS          SrcIpAddress
    );

NTSTATUS
SendNodeStatusResponse(
    IN  tNAMEHDR UNALIGNED  *pInNameHdr,
    IN  ULONG               Length,
    IN  PUCHAR              pName,
    IN  ULONG               lNameSize,
    IN  tIPADDRESS          SrcIpAddress,
    IN  USHORT              SrcPort,
    IN  tDEVICECONTEXT      *pDeviceContext
    );

NTSTATUS
UpdateNameState(
    IN  tADDSTRUCT UNALIGNED    *pAddrStruct,
    IN  tNAMEADDR               *pNameAddr,
    IN  ULONG                   Length,
#ifdef MULTIPLE_WINS
    IN  PULONG                  pContextFlags,
#endif
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  BOOLEAN                 SrcIsNameServer,
    IN  tDGRAM_SEND_TRACKING    *Context,
    IN  CTELockHandle           OldIrq1
    );
NTSTATUS
ChkIfValidRsp(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  tNAMEADDR       *pNameAddr
    );

NTSTATUS
ChooseBestIpAddress(
    IN  tADDSTRUCT UNALIGNED    *pAddrStruct,
    IN  ULONG                   Len,
    IN  tDEVICECONTEXT          *pDeviceContext,
    OUT tDGRAM_SEND_TRACKING    *pTracker,
    OUT tIPADDRESS              *pIpAddress,
    IN  BOOLEAN                 fReturnAddrList
    );

NTSTATUS
GetNbFlags(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNameSize,
    IN  LONG                lNumBytes,
    OUT USHORT              *pRegType
    );

VOID
PrintHexString(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  ULONG                lNumBytes
    );

ULONG
MakeList(
    IN  tDEVICECONTEXT            *pDeviceContext,
    IN  ULONG                     CountAddrs,
    IN  tADDSTRUCT UNALIGNED      *pAddrStruct,
    IN  tIPADDRESS                *pAddrArray,
    IN  ULONG                     SizeOfAddrArray,
    IN  BOOLEAN                   IsSubnetMatch
    );

BOOL
IsBrowserName(
	IN PCHAR pName
	);


#if DBG
#define KdPrintHexString(pHdr,NumBytes)     \
    PrintHexString(pHdr,NumBytes)
#else
#define KdPrintHexString(pHdr,NumBytes)
#endif


//----------------------------------------------------------------------------
BOOLEAN
IsRemoteAddress(
    IN tNAMEADDR    *pNameAddr,
    IN tIPADDRESS   IpAddress
    )
{
    ULONG   i;

    for (i=0; i<pNameAddr->RemoteCacheLen; i++)
    {
        if (pNameAddr->pRemoteIpAddrs[i].IpAddress == IpAddress)
        {
            return TRUE;
        }
    }

    return FALSE;
}


//----------------------------------------------------------------------------
NTSTATUS
QueryFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags,
    IN  BOOLEAN             fBroadcast
    )
/*++

Routine Description:

    This routine handles both name query requests and responses.  For Queries
    it checks if the name is registered on this node.  If this node is a proxy
    it then forwards a name query onto the Name Server, adding the name to the
    remote proxy cache...

Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS                status;
    LONG                    lNameSize;
    CHAR                    pName[NETBIOS_NAME_SIZE];
    PUCHAR                  pScope;
    tNAMEADDR               *pNameAddr;
    tTIMERQENTRY            *pTimer;
    COMPLETIONCLIENT        pClientCompletion;
#ifdef MULTIPLE_WINS
    tDGRAM_SEND_TRACKING    *Context;
    ULONG                   AddrStructLength;
    USHORT                  RdLength;       // The length field in the packet
#else
    PVOID                   Context;
#endif
    PTRANSPORT_ADDRESS      pSourceAddress;
    tIPADDRESS              SrcAddress;
    CTELockHandle           OldIrq1;
    tQUERYRESP  UNALIGNED   *pQuery;
    USHORT                  SrcPort;
    tIPADDRESS              IpAddr;
    tADDSTRUCT UNALIGNED    *pAddrs;
    tIPADDRESS              *pFailedAddresses;
    ULONG                   i, j, CountAddrs, InterfaceContext;
    tQUERY_ADDRS            *pQueryAddrs = NULL;
    LONG                    MinimumBytes;

    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);


    SrcPort = ntohs(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->sin_port);


#ifdef VXD
    //
    // is this a response from a DNS server?  if yes then handle it
    // appropriately
    //
    if (SrcPort == NBT_DNSSERVER_UDP_PORT)
    {
        USHORT  TransactionId;
        TransactionId = ntohs(pNameHdr->TransactId);
        if ( TransactionId >= DIRECT_DNS_NAME_QUERY_BASE )
        {
            ProcessDnsResponseDirect( pDeviceContext,
                                      pSrcAddress,
                                      pNameHdr,
                                      lNumBytes,
                                      OpCodeFlags );
        }
        else
        {
            ProcessDnsResponse( pDeviceContext,
                                pSrcAddress,
                                pNameHdr,
                                lNumBytes,
                                OpCodeFlags );
        }

       return(STATUS_DATA_NOT_ACCEPTED);
    }
#endif

    //
    // check the pdu size for errors - be sure the name is long enough for
    // the scope on this machine.
    //
    if (lNumBytes < (NBT_MINIMUM_QUERY + NbtConfig.ScopeLength - 1))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Name Query PDU TOO short = %X,Src= %X\n",lNumBytes,SrcAddress));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // get the name out of the network pdu and pass to routine to check
    // local table *TODO* this assumes just one name in the Query response...
    status = ConvertToAscii ((PCHAR) &pNameHdr->NameRR,
                             (lNumBytes-1) - FIELD_OFFSET(tNAMEHDR,NameRR), // -1 for QUEST_STATUS
                             pName,
                             &pScope,
                             &lNameSize);

    if (!NT_SUCCESS(status))
    {
//        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.QueryFromNet: WARNING!!! Rejecting Request -- ConvertToAscii FAILed\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }


    // check if this is a request or a response pdu

    //
    // *** RESPONSE ***
    //
    if (OpCodeFlags & OP_RESPONSE)
    {
        if (!(OpCodeFlags & FL_AUTHORITY))
        {
            // *** Redirect Response from Wins ***

            //
            // This is a redirect response telling us to go to another
            // name server, which we do not support, so just return
            // *TODO*
            //
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        //
        // check if this is a node status request, since is looks very similar
        // to a name query, except that the NBSTAT field is 0x21 instead of
        // 0x20
        //
        pQuery = (tQUERYRESP *) &pNameHdr->NameRR.NetBiosName[lNameSize];
        if ( ((PUCHAR)pQuery)[1] == QUEST_STATUS )
        {
            //
            // *** This is an AdapterStatus response! ***
            //
            tNODESTATUS *pNodeStatus = (tNODESTATUS *)&pNameHdr->NameRR.NetBiosName[lNameSize];

            //
            // Bug# 125627
            // Check for valid Pdu data + Size
            // The PDU is of the form:
            // tNAMEHDR --> TransactionId   ==> Offset=0, Length=2 bytes
            //                  :
            //          --> NameRR.NetbiosName  ==> Offset=13, Length = lNameSize
            //          --> NodeStatusResponse  ==> Offset=13+lNameSize, Length >=11
            //          --> NodeName[i]         ==> Offset=13+lNameSize+11+(i*NBT_NODE_NAME_SIZE)
            //
            MinimumBytes =  FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize + 11;
            if ((lNumBytes < MinimumBytes) ||       // so that we can read in "pNodeStatus->NumNames"
                (lNumBytes < (MinimumBytes + pNodeStatus->NumNames*NBT_NODE_NAME_SIZE)))
            {
                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint (("Nbt.QueryFromNet: WARNING Bad AdapterStatusResp size -- lNumBytes=<%d> < <%d>\n",
                        lNumBytes, (MinimumBytes + pNodeStatus->NumNames*NBT_NODE_NAME_SIZE)));
                ASSERT(0);
                return(STATUS_DATA_NOT_ACCEPTED);
            }

            status = DecodeNodeStatusResponse(pNameHdr, lNumBytes, pName, lNameSize, SrcAddress);
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        //
        // *** We are processing a Name Query response! ***
        //

        //
        // check the Query response pdu size before dereferencing it!
        // The PDU is of the form:
        // tNAMEHDR --> TransactionId   ==> Offset=0, Length=2 bytes
        //                  :
        //          --> NameRR.NetbiosName  ==> Offset=13, Length = lNameSize
        //          --> QueryResponse       ==> Offset=13+lNameSize, Length >=10
        //
        //
        if (IS_POS_RESPONSE(OpCodeFlags))
        {
            MinimumBytes = 13 + lNameSize + 16;
        }
        else
        {
            MinimumBytes = 13 + lNameSize + 10;     // Upto Length field only
        }

        if (lNumBytes < MinimumBytes)
        {
            KdPrint (("Nbt.QueryFromNet:  WARNING -- Bad QueryResp size, lNumBytes=<%d>, lNameSize=<%d>\n",
                lNumBytes, lNameSize));
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        pAddrs = (tADDSTRUCT *) &pQuery->Flags;
        RdLength = ntohs(pQuery->Length);
        AddrStructLength = lNumBytes - (ULONG)((ULONG_PTR)&pQuery->Flags - (ULONG_PTR)pNameHdr);
        if (RdLength < AddrStructLength) {
            AddrStructLength = RdLength;
        }
        CountAddrs = AddrStructLength / tADDSTRUCT_SIZE;

        //
        // Call into IP to determine the outgoing interface for each address returned
        //
        if ((NbtConfig.ConnectOnRequestedInterfaceOnly) &&
            (!(ntohs(pAddrs[0].NbFlags) & FL_GROUP)) &&
            (CountAddrs && ((CountAddrs*tADDSTRUCT_SIZE) == AddrStructLength)) &&
            (pQueryAddrs = (tQUERY_ADDRS *) NbtAllocMem(CountAddrs*sizeof(tQUERY_ADDRS),NBT_TAG2('13'))))
        {
            CTEZeroMemory(pQueryAddrs, CountAddrs*sizeof(tQUERY_ADDRS));
            for (i = 0; i < CountAddrs; i++)
            {
                pQueryAddrs[i].IpAddress = pAddrs[i].IpAddr;
                pDeviceContext->pFastQuery(pAddrs[i].IpAddr,&pQueryAddrs[i].Interface,&pQueryAddrs[i].Metric);
            }
        }

        //
        // call this routine to find the name, since it does not interpret the
        // state of the name as does FindName()
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        status = FindOnPendingList(pName,pNameHdr,FALSE,NETBIOS_NAME_SIZE,&pNameAddr);
        if (NT_SUCCESS(status))
        {
            pQuery = (tQUERYRESP *)&pNameHdr->NameRR.NetBiosName[lNameSize];
            // remove any timer block and call the completion routine

            if ((pTimer = pNameAddr->pTimer))
            {
                ULONG                   Flags;
                tDGRAM_SEND_TRACKING    *pTracker;
                tDEVICECONTEXT          *pDevContext;
                USHORT                  NSOthersIndex, NSOthersLeft;
                ULONG                   ContextFlags;

                pTracker = (tDGRAM_SEND_TRACKING *)pTimer->Context;
                Flags = pTracker->Flags;

                //
                // Since this Wins server was able to respond, set the last responsive
                // pointer
                //
                if ((SrcIsNameServer(SrcAddress,SrcPort)) &&
                    (pTracker->Flags & NBT_NAME_SERVER_OTHERS))
                {
                    pTracker->pDeviceContext->lLastResponsive = pTracker->NSOthersIndex;
                }
                //
                // If this is not a response to a request sent by the PROXY code
                // and
                // MSNode && Error Response code && Src is NameServer && Currently
                // resolving with the name server, then switch to broadcast
                // ... or if it is a Pnode or Mnode and EnableLmHost or
                // ResolveWithDns is on, then
                // let the timer expire again, and try Lmhost.
                //
                if (
#ifdef PROXY_NODE
                     pNameAddr->ProxyReqType == NAMEREQ_REGULAR &&
#endif
                     (IS_NEG_RESPONSE(OpCodeFlags)))

                {
                    if ((NodeType & (PNODE | MNODE | MSNODE)) &&
                        (Flags & (NBT_NAME_SERVER | NBT_NAME_SERVER_BACKUP)))
                    {
                        // this should let MsnodeCompletion try the
                        // backup WINS or broadcast processing next
                        //
                        pTracker->Flags |= WINS_NEG_RESPONSE;
                        ExpireTimer (pTimer, &OldIrq1);
                    }
                    else
                    {
                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                    }

                    if (pQueryAddrs)
                    {
                        CTEFreeMem (pQueryAddrs);
                    }
                    return(STATUS_DATA_NOT_ACCEPTED);
                }

                //
                // Check if any of the addresses that came over the net
                // belong to the set of failed addresses that we are tracking
                //
                if (pNameAddr->pTracker)    // pTracker will be NULL for Proxy requests
                {
                    if (pQueryAddrs)
                    {
                        //
                        // Go through the list of addresses to see which ones can be
                        // reached through this Device
                        //
                        InterfaceContext = pNameAddr->pTracker->pDeviceContext->IPInterfaceContext;
                        for (i=0; i<CountAddrs; i++)
                        {
                            if (pQueryAddrs[i].Interface != InterfaceContext)
                            {
                                CountAddrs--;
                                if (CountAddrs)
                                {
                                    pQueryAddrs[i].Interface = pQueryAddrs[CountAddrs].Interface;
                                    pAddrs[i] = pAddrs[CountAddrs];   // Copy the last entry
                                }

                                pAddrs[CountAddrs].IpAddr = 0;  // Set the last address entry to 0
                                i--;
                            }
                        }

                        CTEFreeMem (pQueryAddrs);
                        pQueryAddrs = NULL;
                    }

                    AddrStructLength = CountAddrs * tADDSTRUCT_SIZE;

                    //
                    // We have now removed all the irrelevant entries
                    // See if we also need to filter out any bad (known) addresses
                    //
                    if ((pNameAddr->pTracker->pFailedIpAddresses) && (pTimer->ClientCompletion))
                    {
                        pFailedAddresses = pNameAddr->pTracker->pFailedIpAddresses;
                        if ((CountAddrs*tADDSTRUCT_SIZE) == AddrStructLength)
                        {
                            //
                            // If some of these addresses had failed earlier, they should be purged
                            //
                            i = 0;
                            while ((i < MAX_FAILED_IP_ADDRESSES) && (pFailedAddresses[i]))
                            {
                                for (j = 0; j < CountAddrs; j++)
                                {
                                    if (pFailedAddresses[i] == (ULONG) ntohl(pAddrs[j].IpAddr))
                                    {
                                        pAddrs[j] = pAddrs[CountAddrs-1];   // Copy the last entry
                                        pAddrs[CountAddrs-1].IpAddr = 0;    // Set the last entry to 0
                                        CountAddrs--;
                                        j--;                                // Now, read this new IP address
                                    }
                                }
                                i++;
                            }

                        }
                    }

                    if (0 == (AddrStructLength = CountAddrs*tADDSTRUCT_SIZE))
                    {
                        //
                        // No new addresses were found -- consider this a negative response
                        //
                        if ((NodeType & (PNODE | MNODE | MSNODE)) &&
                            (pTracker->Flags & (NBT_NAME_SERVER | NBT_NAME_SERVER_BACKUP)))
                        {
                            // this should let MsnodeCompletion try the
                            // backup WINS or broadcast
                            // processing when the timer times out.
                            //
                            pTracker->Flags |= WINS_NEG_RESPONSE;
                            ExpireTimer (pTimer, &OldIrq1);
                        }
                        else
                        {
                            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                        }

                        return(STATUS_DATA_NOT_ACCEPTED);
                    }

                    //
                    // save the Tracker's essential info since the call to StopTimer could
                    // free pTracker
                    //
                    pNameAddr->pTracker->ResolutionContextFlags = pTracker->Flags;
                    pNameAddr->pTracker->NSOthersIndex = pTracker->NSOthersIndex;
                    pNameAddr->pTracker->NSOthersLeft = pTracker->NSOthersLeft;
                }
                else if (pQueryAddrs)
                {
                    CTEFreeMem (pQueryAddrs);
                    pQueryAddrs = NULL;
                }

                CHECK_PTR(pNameAddr);
                pDevContext = pTracker->pDeviceContext;

                //
                // this routine puts the timer block back on the timer Q, and
                // handles race conditions to cancel the timer when the timer
                // is expiring.
                //
                pNameAddr->pTimer = NULL;
                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE);     // Since StopTimer can Deref name!
                status = StopTimer(pTimer,&pClientCompletion,&Context);
                LOCATION(0x42);
                //
                // we need to synchronize removing the name from the list
                // with MsNodeCompletion
                //
                if (pClientCompletion)
                {
                    LOCATION(0x41);
                    //
                    // Remove from the pending list
                    RemoveEntryList(&pNameAddr->Linkage);
                    InitializeListHead(&pNameAddr->Linkage);

                    // check the name query response ret code to see if the name
                    // query succeeded or not.
                    if (IS_POS_RESPONSE(OpCodeFlags))
                    {
                        BOOLEAN ResolvedByWins;

                        LOCATION(0x40);
                        //
                        // Keep track of how many names are resolved by WINS and
                        // keep a list of names not resolved by WINS
                        //
                        if (!(ResolvedByWins = SrcIsNameServer(SrcAddress,SrcPort)))
                        {
                             SaveBcastNameResolved(pName);
                        }

                        IncrementNameStats(NAME_QUERY_SUCCESS, ResolvedByWins);
#ifdef PROXY_NODE
                        // Set flag if the node queries is a PNODE
                        //
                        IF_PROXY(NodeType)
                        {
                            pNameAddr->fPnode = (pNameHdr->NameRR.NetBiosName[lNameSize+QUERY_NBFLAGS_OFFSET]
                                                &  NODE_TYPE_MASK) == PNODE_VAL_IN_PKT;

                            IF_DBG(NBT_DEBUG_PROXY)
                                KdPrint(("QueryFromNet: POSITIVE RESPONSE to name query - %16.16s(%X)\n",
                                    pNameAddr->Name, pNameAddr->Name[15]));
                        }

#endif
                        pNameAddr->AdapterMask |= pDevContext->AdapterMask;

                        IpAddr = ((tADDSTRUCT UNALIGNED *)&pQuery->Flags)->IpAddr;

                        status = UpdateNameState((tADDSTRUCT *)&pQuery->Flags,
                                             pNameAddr,
                                             AddrStructLength,
                                             &ContextFlags,
                                             pDevContext,
                                             SrcIsNameServer(SrcAddress,SrcPort),
                                             (tDGRAM_SEND_TRACKING *)Context,
                                             OldIrq1);
                        //
                        // since pNameAddr can be freed in UpdateNameState do not
                        // access it here
                        //
                        pNameAddr = NULL;
                        // status = STATUS_SUCCESS;
                    }
                    else   // negative query response received
                    {

                        LOCATION(0x3f);
                        //
                        // Release the name.  It will get dereferenced by the
                        // cache timeout function (RemoteHashTimeout).
                        //
                        pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                        pNameAddr->NameTypeState |= STATE_RELEASED;
                        //
                        // the proxy maintains a negative cache of names that
                        // do not exist in WINS.  These are timed out by
                        // the remote hash timer just as the resolved names
                        // are timed out.
                        //
                        if (!(NodeType & PROXY))
                        {
                            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                        }
                        else if (pNameAddr->ProxyReqType != NAMEREQ_PROXY_REGISTRATION)
                        {
                            //
                            // Add to cache as negative name entry
                            //
                            AddToHashTable (NbtConfig.pRemoteHashTbl,
                                            pNameAddr->Name,
                                            NbtConfig.pScope,
                                            pNameAddr->IpAddress,
                                            0,
                                            pNameAddr,
                                            NULL,
                                            pDevContext,
                                            (USHORT) (SrcIsNameServer(SrcAddress,SrcPort) ?
                                                      NAME_RESOLVED_BY_WINS:NAME_RESOLVED_BY_BCAST));
                            //
                            // this could delete the name so do not reference after this point
                            //
                        }

                        status = STATUS_BAD_NETWORK_PATH;
                    }

                    //
                    // Set the backup name server to be the main name server
                    // since we got a response from it.
                    // Bug# 95280: Do this only if the Primary Wins is down!
                    //
                    if ( (!(Flags & WINS_NEG_RESPONSE)) &&
                         ((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr
                            == (ULONG)(htonl(pDeviceContext->lBackupServer)))
                    {
                        // switching the backup and the primary nameservers in
                        // the config data structure since we got a name
                        // registration response from the backup
                        //
                        SwitchToBackup(pDeviceContext);
                    }

                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                    // the completion routine has not run yet, so run it
                    //
#ifdef VXD
                    //
                    // chicago only has 4k of stack (yes, it's the operating system of 1995)
                    // schedule an event to make this tcp connection later to reduce stack usage
                    //
                    CTEQueueForNonCritNonDispProcessing( DelayedSessEstablish,
                                                         (tDGRAM_SEND_TRACKING *)Context,
                                                         (PVOID)status,
                                                         pClientCompletion,
                                                         pDeviceContext);
#else
                    //
                    // If pending is returned, we have submitted the check-for-addr request to lmhsvc.
                    //
                    if (status != STATUS_PENDING)
                    {
                        CompleteClientReq(pClientCompletion, (tDGRAM_SEND_TRACKING *)Context, status);
                    }
#endif
                    return(STATUS_DATA_NOT_ACCEPTED);
                }
                else
                {
                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                }
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }
        else if (!NbtConfig.MultiHomed)
        {

            // *** Name Query reponse ==> Name not on Pending list ***

            //
            // it is possible for two multihomed machines connected on two subnets
            // to respond on both subnets to a name query.  Therefore the querying
            // multihomed machine will ultimately receive two name query responses
            // each with a different ip address and think that a name conflict has
            // occurred when it hasn't.  There is no way to detect this case
            // so just disable the conflict detection code below. Conflicts will
            // still be detected by WINS and by the node owning the name if someone
            // else tries to get the name, but conflicts will no longer be detected
            // by third parties that have the name in their cache.
            // (Currently this case will be handled only if we are not multi-homed!)
            //
            //
            // This code implements a Conflict timer for name
            // queries. Look at name query response, and then send
            // name conflict demands to the subsequent responders.
            // There is no timer involved, and this node will always respond
            // negatively to name query responses sent to it, for names
            // it has in its remote cache, if the timer has been stopped.
            // ( meaning that one response has been successfully received ).

            //
            //  The name is not in the NameQueryPending list, so check the
            //  remote table.
            //
            status = FindInHashTable(NbtConfig.pRemoteHashTbl,
                                    pName,
                                    pScope,
                                    &pNameAddr);

            // check the src IP address and compare it to the one in the
            // remote hash table
            // Since it is possible for the name server to send a response
            // late, do not accidently respond to those as conflicts.
            // Since a bcast query of a group name will generally result in
            // multiple responses, each with a different address, ignore
            // this case.
            // Also, ignore if the name is a preloaded lmhosts entry (though
            // can't think of an obvious case where we would receive a response
            // when a name is preloaded!)
            //
            if (NT_SUCCESS(status) &&
                !(pNameAddr->NameTypeState & PRELOADED) &&
                (!IsRemoteAddress(pNameAddr, SrcAddress)) &&
                (pNameAddr->NameTypeState & NAMETYPE_UNIQUE) &&
                (pNameAddr->NameTypeState & STATE_RESOLVED) &&
                (!IsNameServerForDevice (SrcAddress, pDeviceContext)))
            {
                //
                // Reference the name so that it doesn't disappear when
                // we are dereferencing it below!   Bug# 233464
                //
                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_RESPONSE);

                //
                // a different node is responding to the name query
                // so tell them to buzz off.
                //
                status = UdpSendResponse(
                            lNameSize,
                            pNameHdr,
                            pNameAddr,
                            (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                            pDeviceContext,
                            CONFLICT_ERROR,
                            eNAME_REGISTRATION_RESPONSE,
                            OldIrq1);

                //
                // remove the name from the remote cache so the next time
                // we need to talk to it we do a name query
                //
                CTESpinLock(&NbtConfig.JointLock,OldIrq1);

                // set the name to the released state so that multiple
                // conflicting responses don't come in and decrement the
                // reference count to zero - in the case where some other
                // part of NBT is still using the name, that part of NBT
                // should do the final decrement - i.e. a datagram send to this
                // name.
                pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                pNameAddr->NameTypeState |= STATE_RELEASED;

                //
                // don't deref if someone else is using it now...
                //
                if (pNameAddr->RefCount == 2)
                {
                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                }
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_RESPONSE, TRUE);
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }

        if (pQueryAddrs)
        {
            CTEFreeMem (pQueryAddrs);
            pQueryAddrs = NULL;
        }

        return(STATUS_DATA_NOT_ACCEPTED);

    }
    else        // *** REQUEST ***
    {
        NTSTATUS    Locstatus;

        //
        // check the pdu size for errors
        //
        if (lNumBytes < (FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize + 4))
        {
//            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint (("Nbt.QueryFromNet[2]: WARNING!!! Rejecting Request -- lNumBytes=<%d> < <%d>\n",
                    lNumBytes, (FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize + 4)));
            ASSERT(0);
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);

        // call this routine
        // to see if the name is in the local table.
        //
        status = FindInHashTable(NbtConfig.pLocalHashTbl,
                                pName,
                                pScope,
                                &pNameAddr);
        pQuery = (tQUERYRESP *)&pNameHdr->NameRR.NetBiosName[lNameSize];
        if (NT_SUCCESS(status) &&
            ((pNameAddr->NameTypeState & STATE_RESOLVED) ||
            (pNameAddr->NameTypeState & STATE_RESOLVING)))
        {
            //
            // check if this is a node status request, since is looks very similar
            // to a name query, except that the NBSTAT field is 0x21 instead of
            // 0x20
            //
            if ( ((PUCHAR)pQuery)[1] == QUEST_STATUS )
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                //
                // Reply only if this was not broadcast to us.
                //
                if (!fBroadcast)
                {
                    Locstatus = SendNodeStatusResponse(pNameHdr,
                                                    lNumBytes,
                                                    pName,
                                                    lNameSize,
                                                    SrcAddress,
                                                    SrcPort,
                                                    pDeviceContext);
                }
                else
                {
                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint(("NBT: Bcast nodestatus req.- dropped\n"));
                }
            }
            else
            {
                //
                // check if this message came from Us or it is not
                // a broadcast since WINS on this machine could send it.
                // Note: this check must be AFTER the check for a node status request
                // since we can send node status requests to ourselves.
                //
                if ((!SrcIsUs(SrcAddress)) ||
                    (!(OpCodeFlags & FL_BROADCAST)
#ifndef VXD
                     && pWinsInfo
#endif
                    ))
                {
                    //
                    // build a positive name query response pdu
                    //
                    Locstatus = UdpSendResponse(
                                    lNameSize,
                                    pNameHdr,
                                    pNameAddr,
                                    (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                                    pDeviceContext,
                                    0,
                                    eNAME_QUERY_RESPONSE,
                                    OldIrq1);
                }
                else
                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            }

            return(STATUS_DATA_NOT_ACCEPTED);
        } else if (((PUCHAR)pQuery)[1] == QUEST_STATUS && !fBroadcast &&
                RtlCompareMemory(pName, NBT_BROADCAST_NAME, NETBIOS_NAMESIZE) == NETBIOS_NAMESIZE) {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            Locstatus = SendNodeStatusResponse(pNameHdr,
                                                lNumBytes,
                                                pName,
                                                lNameSize,
                                                SrcAddress,
                                                SrcPort,
                                                pDeviceContext);
            return(STATUS_DATA_NOT_ACCEPTED);
        }
        else if ( !(OpCodeFlags & FL_BROADCAST) )
        {
            // Build a negative response if this query was directed rather than
            // broadcast (since we do not want to Nack all broadcasts!)

            // check that it is not a node status request...
            //
            pQuery = (tQUERYRESP *)&pNameHdr->NameRR.NetBiosName[lNameSize];
            if ( ((PUCHAR)pQuery)[1] == QUEST_NETBIOS )
            {
                Locstatus = UdpSendResponse(
                                lNameSize,
                                pNameHdr,
                                NULL,
                                (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                                pDeviceContext,
                                0,
                                eNAME_QUERY_RESPONSE,
                                OldIrq1);
            }
            else
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            }

            return(STATUS_DATA_NOT_ACCEPTED);
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

#ifdef PROXY_NODE

        //
        // check if this message came from Us !! (and return if so)
        //
        if (SrcIsUs(SrcAddress))
        {
            return(STATUS_DATA_NOT_ACCEPTED);
        }
        pQuery = (tQUERYRESP *)&pNameHdr->NameRR.NetBiosName[lNameSize];

        IF_PROXY(NodeType)
        {
            // check that it is not a node status request...
            if (((PUCHAR)pQuery)[1] == QUEST_NETBIOS )
            {
                //
                // We have a broadcast name query request for a name that
                // is not in our local name table.  If we are a proxy we need
                // to resolve the query if not already resolved and respond
                // with the address(es) to the node that sent the query.
                //
                // Note: We will respond only if the address that the name
                // resolves to is not on our subnet. For our own subnet addresses
                // the node that has the address will respond.
                //
                CTESpinLock(&NbtConfig.JointLock,OldIrq1);
                //
                // call this routine which looks for names without regard
                // to their state
                //
                status = FindInHashTable(NbtConfig.pRemoteHashTbl,
                                pName,
                                pScope,
                                &pNameAddr);

                if (!NT_SUCCESS(status))
                {
                    status = FindOnPendingList(pName,pNameHdr,TRUE,NETBIOS_NAME_SIZE,&pNameAddr);
                    if (!NT_SUCCESS(status))
                    {
                        //
                        // cache the name and contact the name
                        // server to get the name to IP mapping
                        //
                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                        status = RegOrQueryFromNet(
                                  FALSE,          //means it is a name query
                                  pDeviceContext,
                                  pNameHdr,
                                  lNameSize,
                                  pName,
                                  pScope);

                         return(STATUS_DATA_NOT_ACCEPTED);
                    }
                    else
                    {
                        //
                        // the name is on the pending list doing a name query
                        // now, so ignore this name query request
                        //
                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                        return(STATUS_DATA_NOT_ACCEPTED);

                    }
                }
                else
                {

                   //
                   // The name can be in the RESOLVED, RESOLVING or RELEASED
                   // state.
                   //


                   //
                   // If in the RELEASED state, its reference count has to be
                   // > 0
                   //
                   //ASSERT(pNameAddr->NameTypeState & (STATE_RESOLVED | STATE_RESOLVING) || (pNameAddr->NameTypeState & STATE_RELEASED) && (pNameAddr->RefCount > 0));

                   //
                   // Send a response only if the name is in the RESOLVED state
                   //
                   if (pNameAddr->NameTypeState & STATE_RESOLVED)
                   {

                     //
                     // The PROXY sends a response if the address of the
                     // node queries is not on the  same subnet as the
                     // node doing the query (or as us). It also responds
                     // if the name is a group name or if it belongs to
                     // a Pnode. Note: In theory there is no reason to
                     // respond for group names since a member of the group
                     // on the subnet will respond with their address if they
                     // are alive - if they are B or M nodes - perhaps
                     // the fPnode bit is not set correctly for groups, so
                     // therefore always respond in case all the members
                     // are pnodes.
                     //

                     //
                     // If we have multiple network addresses in the same
                     // broadcast area, then this test won't be sufficient
                     //
                     if (
                         ((SrcAddress & pDeviceContext->SubnetMask)
                                   !=
                         (pNameAddr->IpAddress & pDeviceContext->SubnetMask))
                                   ||
                         (pNameAddr->fPnode)
                                   ||
                         !(pNameAddr->NameTypeState & NAMETYPE_UNIQUE)
                        )
                     {
                          IF_DBG(NBT_DEBUG_PROXY)
                          KdPrint(("QueryFromNet: QUERY SATISFIED by PROXY CACHE -- name is %16.16s(%X); %s entry ; Address is (%d)\n",
                            pNameAddr->Name,pNameAddr->Name[15], (pNameAddr->NameTypeState & NAMETYPE_UNIQUE) ? "UNIQUE" : "INET_GROUP",
                            pNameAddr->IpAddress));
                          //
                          //build a positive name query response pdu
                          //
                          // UdpSendQueryResponse frees the spin lock
                          //
                          status = UdpSendResponse(
                                        lNameSize,
                                        pNameHdr,
                                        pNameAddr,
                                        (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                                        pDeviceContext,
                                        0,
                                        eNAME_QUERY_RESPONSE,
                                        OldIrq1);

                          return(STATUS_DATA_NOT_ACCEPTED);
                     }
                   }
                   else
                   {
                      IF_DBG(NBT_DEBUG_PROXY)
                      KdPrint(("QueryFromNet: REQUEST for Name %16.16s(%X) in %s state\n", pNameAddr->Name, pNameAddr->Name[15],( pNameAddr->NameTypeState & STATE_RELEASED ? "RELEASED" : "RESOLVING")));
                   }

                   CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                   return(STATUS_DATA_NOT_ACCEPTED);
                }
             }

        }  // end of proxy code
#endif

    } // end of else (it is a name query request)

    return(STATUS_DATA_NOT_ACCEPTED);
}

//----------------------------------------------------------------------------
NTSTATUS
RegResponseFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes,
    IN  USHORT              OpCodeFlags
    )
/*++

Routine Description:

    This routine handles name registration responses from the net (i.e. from
    the name server most of the time since a broadcast name registration passes
    when there is no response.

***
    The response could be from an NBT node when it notices that the name
    registration is for a name that it has already claimed - i.e. the node
    is sending a NAME_CONFLICT_DEMAND - in this case the Rcode in the PDU
    will be CFT_ERR = 7.

Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS            status;
    ULONG               lNameSize;
    CHAR                pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    tNAMEADDR           *pNameAddr;           //Get rid of this later. Use pNameAddr
    tTIMERQENTRY        *pTimer;
    COMPLETIONCLIENT    pClientCompletion;
    PVOID               Context;
    PTRANSPORT_ADDRESS  pSourceAddress;
    CTELockHandle       OldIrq1;
    ULONG               SrcAddress;
    SHORT               SrcPort;


    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);
    SrcPort     = ntohs(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->sin_port);
    //
    // be sure the Pdu is at least a minimum size
    //
    if (lNumBytes < (NBT_MINIMUM_REGRESPONSE + NbtConfig.ScopeLength -1))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Registration Response TOO short = %X, Src = %X\n",
            lNumBytes,SrcAddress));
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("%.*X\n",lNumBytes/sizeof(ULONG),pNameHdr));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // if Wins is locally attached then we will get registrations from
    // ourselves!!
    //
    if (SrcIsUs(SrcAddress)
#ifndef VXD
        && !pWinsInfo
#endif
                          )
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // get the name out of the network pdu and pass to routine to check
    // local table *TODO* this assumes just one name in the Query response...
    // We need to handle group lists from the WINS server
    status = ConvertToAscii(
                    (PCHAR)&pNameHdr->NameRR,
                    lNumBytes - FIELD_OFFSET(tNAMEHDR,NameRR),
                    pName,
                    &pScope,
                    &lNameSize);

    if (!NT_SUCCESS(status))
    {
//        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.RegResponseFromNet: WARNING!!! Rejecting Request -- ConvertToAscii FAILed\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    status = FindInHashTable(NbtConfig.pLocalHashTbl,
                            pName,
                            pScope,
                            &pNameAddr);
    if (NT_SUCCESS(status) &&
        (pNameAddr->AdapterMask & pDeviceContext->AdapterMask))
    {
        NTSTATUS    Localstatus;

        //
        // check the state of the name since this could be a registration
        // response or a name conflict demand
        //
        switch (pNameAddr->NameTypeState & NAME_STATE_MASK)
        {
        case STATE_CONFLICT:

            //
            // We only allow this state if we are currently trying to
            // get ourselves out of a Conflict scenario
            // We need to distinguish from the case where the name is
            // in conflict due to being dereferenced out
            //
            if (!pNameAddr->pAddressEle)
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                break;
            }
        case STATE_RESOLVING:
        case STATE_RESOLVED:

            if (IS_POS_RESPONSE(OpCodeFlags))
            {
                if (OpCodeFlags & FL_RECURAVAIL)
                {
                    // turn on the refreshed bit in NextRefresh now
                    // (when the timer completion routine is called)
                    // only count names registered, not REFRESHES too!
                    //
                    if (pNameAddr->NameTypeState & STATE_RESOLVING)
                    {
                        IncrementNameStats(NAME_REGISTRATION_SUCCESS,
                                           SrcIsNameServer(SrcAddress,SrcPort));
                    }
                    status = STATUS_SUCCESS;
                }
                else
                {
                    //
                    // in this case the name server is telling this node
                    // to do an end node challenge on the name.  However
                    // this node does not have the code to do a challenge
                    // so assume that this is a positive registration
                    // response.
                    //
                    status = STATUS_SUCCESS;
                }
            }
            else if (!SrcIsNameServer(SrcAddress,SrcPort) && pNameAddr->pTimer == NULL) {
                //
                // 05/17/00 Fix "a malicious user can flush a cache entry by sending a unsolicited negative response"
                // Drop the response if it is not from a name server and runs out of time
                //
                status = STATUS_DATA_NOT_ACCEPTED;
                KdPrint(("Waring: discard a timeout registration response from a non-namesever\n"));
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                NbtLogEvent (EVENT_NBT_DUPLICATE_NAME, SrcAddress, 0x105);
                break;
            }
            else if ((OpCodeFlags & FL_RCODE) >= FL_NAME_ACTIVE)
            {
                // if we are multihomed, then we only allow the name server
                // to send Name Active errors, since in normal operation this node
                // could generate two different IP address for the same name
                // query and confuse another client node into sending a Name
                // Conflict. So jump out if a name conflict has been received
                // from another node.
                //
                if ((NbtConfig.MultiHomed) &&
                    ((OpCodeFlags & FL_RCODE) == FL_NAME_CONFLICT))
                {
                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                    break;
                }

                if (!IS_MESSENGER_NAME(pNameAddr->Name))
                {
                    //
                    // We need to Q this event to a Worker thread since it
                    // requires the name to be converted to Unicode
                    //
                    NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT);
                    status = NTQueueToWorkerThread(
                                    NULL,
                                    DelayedNbtLogDuplicateNameEvent,
                                    (PVOID) pNameAddr,
                                    IntToPtr(SrcAddress),
                                    IntToPtr(0x101),
                                    pDeviceContext,
                                    TRUE);
                    if (!NT_SUCCESS(status))
                    {
                        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT, TRUE);
                        NbtLogEvent (EVENT_NBT_DUPLICATE_NAME, SrcAddress, 0x101);
                    }
                }

                status = STATUS_DUPLICATE_NAME;

                //
                // if the name is resolved and we get a negative response
                // then mark the name as in the conflict state so it can't
                // be used for any new sessions and this node will no longer
                // defend it.
                //
                if (pNameAddr->NameTypeState & STATE_RESOLVED)
                {
                    pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                    pNameAddr->NameTypeState |= STATE_CONFLICT;
                    pNameAddr->ConflictMask |= pDeviceContext->AdapterMask;
                }
            }
            else
            {
                //
                // we got some kind of WINS server failure ret code
                // so just ignore it and assume the name registration
                // succeeded.
                //
                status = STATUS_SUCCESS;
            }

            // remove any timer block and call the completion routine
            // if the name is in the Resolving state only
            //
            LOCATION(0x40);
            if ((pTimer = pNameAddr->pTimer))
            {
                tDGRAM_SEND_TRACKING    *pTracker;
                USHORT                  SendTransactId;
                tDEVICECONTEXT          *pDevContext;

                // check the transaction id to be sure it is the same as the one
                // sent.
                //
                LOCATION(0x41);
                pTracker = (tDGRAM_SEND_TRACKING *)pTimer->Context;
                SendTransactId = pTracker->TransactionId;
                pDevContext = pTracker->pDeviceContext;

                if (pNameHdr->TransactId != SendTransactId)
                {
                    LOCATION(0x42);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                    return(STATUS_DATA_NOT_ACCEPTED);
                }
                LOCATION(0x43);

                CHECK_PTR(pNameAddr);
                //
                // This could be either a Refresh or a name registration.  In
                // either case, stop the timer and call the completion routine
                // for the client.(below).
                //
                pNameAddr->pTimer = NULL;
                Localstatus = StopTimer(pTimer,&pClientCompletion,&Context);


                // check if it is a response from the name server
                // and a M, or P or MS node, since we will need to send
                // refreshes to the name server for these node types
                //
                pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;

                // only accept pdus from the name server to change the Ttl.
                // The first check passes the case where WINS is on this machine
                //
                if (
#ifndef VXD
                    (pWinsInfo && (SrcIsUs (SrcAddress))) ||
#endif
                    (SrcAddress == pDeviceContext->lNameServerAddress))
                {
                    if (!(NodeType & BNODE) &&
                        (status == STATUS_SUCCESS) &&
                        (IS_POS_RESPONSE(OpCodeFlags)))
                    {
                        SetupRefreshTtl(pNameHdr,pNameAddr,lNameSize);
                        // a name refresh response if in the resolved state
                    }
                }
                else if ( SrcAddress == pDeviceContext->lBackupServer)
                {
                    // switching the backup and the primary nameservers in
                    // the config data structure since we got a name
                    // registration response from the backup
                    //
                    SwitchToBackup(pDeviceContext);

                    if (!(NodeType & BNODE) &&
                        (status == STATUS_SUCCESS) &&
                        (IS_POS_RESPONSE(OpCodeFlags)))
                    {

                        SetupRefreshTtl(pNameHdr,pNameAddr,lNameSize);

                    }
                }

                //
                // mark name as refreshed if we got through to WINS Ok
                //
                if ((pClientCompletion) && (IS_POS_RESPONSE(OpCodeFlags)))
                {
                    pNameAddr->RefreshMask |= pDevContext->AdapterMask;
                }

                CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                // the completion routine has not run yet, so run it - this
                // is the Registration Completion routine and we DO want it to
                // run to mark the entry refreshed (NextRefresh)
                if (pClientCompletion)
                {
                    LOCATION(0x44);
                    (*pClientCompletion)(Context,status);
                }

            }
            else
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            }

        break;


        default:
            //
            // if multiple (neg)registration responses are received, subsequent ones
            // after the first will go through this path because the state of
            // the name will have been changed by the first to CONFLICT
            //
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }


    }
    else
    {
          CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    } // end of else block (If name is not in local table)

    return(STATUS_DATA_NOT_ACCEPTED);
}

//----------------------------------------------------------------------------
NTSTATUS
CheckRegistrationFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    )
/*++

Routine Description:

    This routine handles name registrations from the network that are
    potentially duplicates of names in the local name table. It compares
    name registrations against its local table and defends any attempts to
    take a name that is owned by this node. This routine handles name registration
    REQUESTS.

Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS            status;
    ULONG               lNameSize;
    CHAR                pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    tNAMEADDR           *pNameAddr;
    tTIMERQENTRY        *pTimer;
    PTRANSPORT_ADDRESS  pSourceAddress;
    USHORT              RegType;
    CTELockHandle       OldIrq1;
    ULONG               SrcAddress;

    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);
    //
    // check the pdu size for errors
    //
    if (lNumBytes < (NBT_MINIMUM_REGREQUEST + (NbtConfig.ScopeLength-1)))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt:Registration Request TOO short = %X,Src = %X\n", lNumBytes,SrcAddress));
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("%.*X\n",lNumBytes/sizeof(ULONG),pNameHdr));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // check if this message came from Us !! (and return if so)
    //

    if (SrcIsUs(SrcAddress))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // get the name out of the network pdu and pass to routine to check
    // local table *TODO* this assumes just one name in the Query response...
    status = ConvertToAscii(
                    (PCHAR)&pNameHdr->NameRR,
                    lNumBytes - FIELD_OFFSET(tNAMEHDR,NameRR),
                    pName,
                    &pScope,
                    &lNameSize);

    if (!NT_SUCCESS(status))
    {
//        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.CheckRegistrationFromNet: WARNING! Rejecting Request -- ConvertToAscii FAILed\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    status = FindInHashTable(NbtConfig.pLocalHashTbl,
                            pName,
                            pScope,
                            &pNameAddr);


    if (NT_SUCCESS(status))
    {
        // don't defend the broadcast name
        if ((pName[0] == '*') ||
            (STATUS_SUCCESS != GetNbFlags (pNameHdr, lNameSize, lNumBytes, &RegType)))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
//            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint (("Nbt.CheckRegistrationFromNet: WARNING! Rejecting Request -- GetNbFlags FAILed\n"));
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        // we defend against anyone trying to take a unique name, or anyone
        // trying to register a unique name for a group name we have. - if
        // the name is registered on this adapter
        //
        if (((pNameAddr->NameTypeState & NAMETYPE_UNIQUE) ||
           ((pNameAddr->NameTypeState & NAMETYPE_GROUP) &&
            ((RegType & FL_GROUP) == 0)))  &&
            (pNameAddr->AdapterMask & pDeviceContext->AdapterMask))
        {

            //
            // check the state of the name since this could be registration
            // for the same name while we are registering the name.  If another
            // node claims the name at the same time, then cancel the name
            // registration.
            //
            switch (pNameAddr->NameTypeState & NAME_STATE_MASK)
            {

                case STATE_RESOLVING:

                    CHECK_PTR(pNameAddr);
                    // remove any timer block and call the completion routine
                    if ((pTimer = pNameAddr->pTimer))
                    {
                        COMPLETIONCLIENT    pClientCompletion;
                        PVOID               Context;

                        pNameAddr->pTimer = NULL;
                        status = StopTimer(pTimer,&pClientCompletion,&Context);
                        if (pClientCompletion)
                        {
                            if (!IS_MESSENGER_NAME(pNameAddr->Name))
                            {
                                //
                                // We need to Q this event to a Worker thread since it
                                // requires the name to be converted to Unicode
                                //
                                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT);
                                status = NTQueueToWorkerThread(
                                                NULL,
                                                DelayedNbtLogDuplicateNameEvent,
                                                (PVOID) pNameAddr,
                                                IntToPtr(SrcAddress),
                                                IntToPtr(0x102),
                                                pDeviceContext,
                                                TRUE);
                                if (!NT_SUCCESS(status))
                                {
                                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT, TRUE);
                                    NbtLogEvent (EVENT_NBT_DUPLICATE_NAME, SrcAddress, 0x102);
                                }
                            }
                            status = STATUS_DUPLICATE_NAME; // CHANGE the state of the entry

                            // the completion routine has not run yet, so run it
                            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                            (*pClientCompletion)(Context,status);
                            CTESpinLock(&NbtConfig.JointLock,OldIrq1);
                        }
                    }
                    break;

                case STATE_RESOLVED:
                    //
                    // We must defend our name against this Rogue attempting to steal
                    // our Name! ( unless the name is "*")
                    //
                    status = UdpSendResponse(
                                lNameSize,
                                pNameHdr,
                                pNameAddr,
                                (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                                pDeviceContext,
                                REGISTRATION_ACTIVE_ERR,
                                eNAME_REGISTRATION_RESPONSE,
                                OldIrq1);

                    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
                    break;

            }


        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }
    else
    {
        //
        // NOTE: We have the Joint Lock
        //

        //
        // The name is not in the local name table, so check if the proxy is
        // on and if we want the proxy to check name registrations.  The
        // trouble with checking name registrations is that the proxy code
        // only does a name query, so it will fail any node that is trying
        // to change its address such as a RAS client coming in on a downlevel
        // NT machine that only does broadcast name registrations.  If
        // that same user had previously dialled in on a WINS supporting RAS
        // machine, their address would be in WINS, then dialling in on the
        // downlevel machine would find that 'old' registration and deny
        // the new one ( even though it is the same machine just changing
        // its ip address).
        //

#ifdef PROXY_NODE

        if ((NodeType & PROXY) &&
            (NbtConfig.EnableProxyRegCheck))
        {

            BOOLEAN fResp = (BOOLEAN)FALSE;

            //
            // If name is RESOLVED in the remote table, has a different
            // address than the node claiming the name, is not on the
            // same subnet or is a Pnode then send a negative name
            // registration response
            //

            //
            // call this routine to find the name, since it does not
            // interpret the state of the name as does FindName()
            //
            status = FindInHashTable(NbtConfig.pRemoteHashTbl,
                             pName,
                             pScope,
                             &pNameAddr);

            if (!NT_SUCCESS(status))
            {
                //
                // We  need to send a query to WINS to
                // see if the name is already taken or not.
                //
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                status = RegOrQueryFromNet(
                                  TRUE,    //means it is a reg. from the net
                                  pDeviceContext,
                                  pNameHdr,
                                  lNameSize,
                                  pName,
                                  pScope
                                           );
                return(STATUS_DATA_NOT_ACCEPTED);
            }

            //
            // If the name is in the RESOLVED state, we need to determine
            // whether we should respond or not.  For a name that is not
            // the RESOLVED state, the decision is simple. We don't respond
            if (pNameAddr->NameTypeState & STATE_RESOLVED)
            {

                ULONG IPAdd;

                if (STATUS_SUCCESS != GetNbFlags(pNameHdr, lNameSize, lNumBytes, &RegType))
                {
                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);
//                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint (("Nbt.CheckRegistrationFromNet[2]: WARNING! Rejecting Request -- GetNbFlags FAILed\n"));
                    return (STATUS_DATA_NOT_ACCEPTED);
                }
                //
                // If a unique name is being registered but our cache shows
                // the name to be a group name (normal or internet), we
                // send a negative name registration response.
                //
                // If a node on the same subnet has responded negatively also,
                // it is ok.  It is possible that WINS/NBNS has old
                // information but there is no easy way to determine the
                // network address of the node that registered the group.
                // (For a normal group, there could have been several
                // nodes that registered it -- their addresses are not stored
                // by WINS.
                //
                if (!(RegType  & FL_GROUP) &&
                    !(pNameAddr->NameTypeState & NAMETYPE_UNIQUE))
                {
                    fResp = TRUE;
                }
                else
                {
                    tGENERALRR UNALIGNED         *pResrcRecord;

                    // get the Ip address out of the Registration request
                    pResrcRecord = (tGENERALRR *) &pNameHdr->NameRR.NetBiosName[lNameSize];

                    IPAdd  = ntohl(pResrcRecord->IpAddress);
                    //
                    // If a group name is being registered but our cache shows
                    // the name to be a unique name (normal or internet) or
                    // if a UNIQUE name is being registered but clashes with
                    // a unique name with a different address, we check if the
                    // the addresses belong to the same subnet.  If they do, we
                    // don't respond, else we send a negative registration
                    // response.
                    //
                    // Note: We never respond to a group registration
                    // that clashes with a group name in our cache.
                    //
                    if (((RegType & FL_GROUP)
                                      &&
                        (pNameAddr->NameTypeState & NAMETYPE_UNIQUE))
                                      ||
                        (!(RegType & FL_GROUP)
                                      &&
                        (pNameAddr->NameTypeState & NAMETYPE_UNIQUE)
                                      &&
                         IPAdd != pNameAddr->IpAddress))
                    {
                        IF_DBG(NBT_DEBUG_PROXY)
                        KdPrint(("CheckReg:Subnet Mask = (%x)\nIPAdd=(%x)\npNameAddr->IPAdd = (%x)\npNameAddr->fPnode=(%d)\nIt is %s name %16.16s(%X)\nRegType Of Name Recd is %x\n---------------\n",
                        pDeviceContext->SubnetMask, IPAdd, pNameAddr->IpAddress,
                        pNameAddr->fPnode,
                        pNameAddr->NameTypeState & NAMETYPE_GROUP ? "GROUP" : "UNIQUE",
                        pName, pName[15], RegType));
                        //
                        // Are the querying node and the queried node on the
                        // same subnet ?
                        //
                        if (((IPAdd & pDeviceContext->SubnetMask)
                                       !=
                              (pNameAddr->IpAddress & pDeviceContext->SubnetMask))
                                       ||
                              (pNameAddr->fPnode))
                        {
                            fResp = TRUE;
                        }
                    }
                }

                //
                // If a negative response needs to be sent, send it now
                //
                if (fResp)
                {

                    IF_DBG(NBT_DEBUG_PROXY)
                    KdPrint(("CheckRegistrationFromNet: Sending a negative name registration response for name %16.16s(%X) to node with address (%d)\n",
                    pNameAddr->Name, pNameAddr->Name[15], IPAdd));

                    //
                    // a different node is responding to the name query
                    // so tell them to buzz off.
                    //
                    status = UdpSendResponse(
                                lNameSize,
                                pNameHdr,
                                pNameAddr,
                                (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                                pDeviceContext,
                                REGISTRATION_ACTIVE_ERR,
                                eNAME_REGISTRATION_RESPONSE,
                                OldIrq1);

                    return(STATUS_DATA_NOT_ACCEPTED);

                }
            } // end of if (NAME is in the RESOLVED state)
        }
#endif
         CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }
    return(STATUS_DATA_NOT_ACCEPTED);
}

//----------------------------------------------------------------------------
NTSTATUS
NameReleaseFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    )
/*++

Routine Description:

    This routine handles name releases that arrive from the Net.  The idea
    is to delete the name from the remote cache if it exists there so that
    this node does not erroneously use that cached information anymore.

Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS                status;
    LONG                    lNameSize;
    CHAR                    pName[NETBIOS_NAME_SIZE];
    PUCHAR                  pScope;
    tNAMEADDR               *pNameAddr;
    PTRANSPORT_ADDRESS      pSourceAddress;
    CTELockHandle           OldIrq1;
    USHORT                  OpCodeFlags;
    tTIMERQENTRY            *pTimer;
    ULONG                   SrcAddress;
    ULONG                   Flags;
    USHORT                  SendTransactId;
    tDGRAM_SEND_TRACKING    *pTracker;
    BOOLEAN                 bLocalTable;
    tGENERALRR UNALIGNED    *pRemainder;
    USHORT                  SrcPort;
    ULONG                   Rcode;

    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress     = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);
    SrcPort     = ntohs(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->sin_port);

    //
    // check if we should not release our names on demand
    //
    if (NbtConfig.NoNameReleaseOnDemand) {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // check the pdu size for errors
    //
    if (lNumBytes < (NBT_MINIMUM_REGRESPONSE + NbtConfig.ScopeLength -1))
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Release Request/Response TOO short = %X, Src = %X\n",lNumBytes,
            SrcAddress));
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("%.*X\n",lNumBytes/sizeof(ULONG),pNameHdr));

        return(STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // check if this message came from Us !!
    //
    if (SrcIsUs(SrcAddress))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // get the name out of the network pdu and pass to routine to check
    status = ConvertToAscii(
                    (PCHAR)&pNameHdr->NameRR,
                    lNumBytes - FIELD_OFFSET(tNAMEHDR,NameRR),
                    pName,
                    &pScope,
                    &lNameSize);

    if (!NT_SUCCESS(status))
    {
//        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.NameReleaseFromNet: WARNING!!! Rejecting Request -- ConvertToAscii FAILed\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    OpCodeFlags = pNameHdr->OpCodeFlags;

    pSourceAddress = (PTRANSPORT_ADDRESS)pSrcAddress;
    SrcAddress = ntohl(((PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0])->in_addr);


    //
    // *** RESPONSE ***
    //
    if (OpCodeFlags & OP_RESPONSE)
    {
        //
        // call this routine to find the name, since it does not interpret the
        // state of the name as does FindName()
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        status = FindInHashTable(NbtConfig.pLocalHashTbl,
                                pName,
                                pScope,
                                &pNameAddr);
        if (!NT_SUCCESS(status))
        {
           CTESpinFree(&NbtConfig.JointLock,OldIrq1);
           return(STATUS_DATA_NOT_ACCEPTED);
        }

        // Get the Timer block
        if (!(pTimer = pNameAddr->pTimer))
        {
           CTESpinFree(&NbtConfig.JointLock,OldIrq1);
           return(STATUS_DATA_NOT_ACCEPTED);
        }

        //
        // the name server is responding to a name release request
        //
        // check the transaction id to be sure it is the same as the one
        // sent.
        //
        pTracker       = (tDGRAM_SEND_TRACKING *)pTimer->Context;
        SendTransactId = pTracker->TransactionId;
        if (pNameHdr->TransactId != SendTransactId)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        // for MS & M nodes if there is a response from the name server,
        // then switch to broadcast name release.
        //
        //
        switch (NodeType & NODE_MASK)
        {
            case MNODE:
            case MSNODE:

                if (SrcIsNameServer(SrcAddress,SrcPort))
                {
                    Flags = pTracker->Flags;

                    if (Flags & NBT_NAME_SERVER)
                    {
                        //
                        // the next timeout will then switch to broadcast name
                        // release.
                        //
                        pTimer->Retries = 1;
                    }
                }

                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                return(STATUS_DATA_NOT_ACCEPTED);

            case PNODE:
                //
                //
                // this routine puts the timer block back on the timer Q, and
                // handles race conditions to cancel the timer when the timer
                // is expiring.
                //
                if ((pTimer = pNameAddr->pTimer))
                {
                    COMPLETIONCLIENT        pClientCompletion;
                    PVOID                   Context;

                    CHECK_PTR(pNameAddr);
                    pNameAddr->pTimer = NULL;
                    status = StopTimer(pTimer,&pClientCompletion,&Context);

                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                    // the completion routine has not run yet, so run it
                    if (pClientCompletion)
                    {
                        (*pClientCompletion)(Context,STATUS_SUCCESS);
                    }
                }
                else
                {
                    CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                }

                return(STATUS_DATA_NOT_ACCEPTED);

            case BNODE:
            default:
                //
                // normally there should be no response to a name release
                // from a Bnode, but if there is, ignore it.
                //
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                return(STATUS_DATA_NOT_ACCEPTED);
        }
    }
    else
    {
        //
        //  It is a RELEASE REQUEST - so decide if the name should be removed
        //  from the remote or local table
        //

        // check for errors Bug# 125651 (NBT_MINIMUM_REGREQUEST == 68)
        //
        // Check for valid PDU size:
        //  lNumBytes >= 12 + [1+lNameSize] + 22(sizeof(tGENERALRR))
        // Check for Overflow error during comparisons with local names:
        //  lNumBytes >= 12 + [1+32(EncodedNetBios name)+Scope(==1 if NULL Scope)] + 22
        //
        if ((lNumBytes < ((NBT_MINIMUM_REGREQUEST-33) + lNameSize)) ||
            (lNumBytes < (NBT_MINIMUM_REGREQUEST + (NbtConfig.ScopeLength-1))))
        {
//            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint (("Nbt.NameReleaseFromNet[2]: WARNING!!! Rejecting Request -- lNumBytes<%d> < <%d>\n",
                    lNumBytes, (NBT_MINIMUM_REGREQUEST + (NbtConfig.ScopeLength-1))));
            return(STATUS_DATA_NOT_ACCEPTED);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);

        // check the REMOTE hash table for the name...
        //
        status = FindInHashTable(NbtConfig.pRemoteHashTbl,
                                 pName,
                                 pScope,
                                 &pNameAddr);
        bLocalTable = FALSE;
        if (!NT_SUCCESS(status))
        {
            //
            // check the LOCAL name table for the name since the name server
            // could be doing the equivalent of a name conflict demand
            //
            status = FindInHashTable(NbtConfig.pLocalHashTbl,
                                     pName,
                                     pScope,
                                     &pNameAddr);
            bLocalTable = TRUE;
        }

        if (NT_SUCCESS(status))
        {
            // check if the address being released corresponds to the one in
            // the table - if not then ignore the release request - since someone
            // else presumably tried to get the name, was refused and now is
            // sending a name release request.
            //
            pRemainder = (tGENERALRR *)&pNameHdr->NameRR.NetBiosName[lNameSize];
            if (pNameAddr->IpAddress != (ULONG)ntohl(pRemainder->IpAddress))
            {
                status = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            //
            // This name is neither in our local or remote hash table, so don't
            // process any further!
            // Bug#: 144944
            //
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            return(STATUS_DATA_NOT_ACCEPTED);
        }


        if (NT_SUCCESS(status))
        {

            //
            // Don't remove group names, since a single group member
            // releasing the name does not matter.  Group names time
            // out of the Remote table.
            //
            if (pNameAddr->NameTypeState & NAMETYPE_UNIQUE)
            {
                switch (pNameAddr->NameTypeState & NAME_STATE_MASK)
                {

                    case STATE_RESOLVING:
                        //
                        // stop any timer that may be going
                        //
                        CHECK_PTR(pNameAddr);
                        //
                        // Local table means that it is a name registration
                        // and we must avoid calling CompleteClientReq
                        //
                        if (pTimer = pNameAddr->pTimer)
                        {
                            COMPLETIONCLIENT        pClientCompletion;
                            PVOID                   pContext;

                            pNameAddr->pTimer = NULL;
                            status = StopTimer(pTimer,&pClientCompletion,&pContext);
                            // this will complete the irp(s) back to the clients
                            if (pClientCompletion)
                            {
                                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                                if (bLocalTable)
                                {
                                    (*pClientCompletion) (pContext,STATUS_DUPLICATE_NAME);
                                }
                                else
                                {
                                    CompleteClientReq (pClientCompletion, pContext, STATUS_TIMEOUT);
                                }
                                CTESpinLock(&NbtConfig.JointLock,OldIrq1);
                            }
                        }

                        break;

                    case STATE_RESOLVED:
                        // dereference the name if it is in the remote table,
                        // this should change the state to RELEASED.  For the
                        // local table just change the state to CONFLICT, since
                        // the local client still thinks it has the name open,
                        // however in the conflict state the name cannot be use
                        // to place new sessions and this node will not respond
                        // to name queries for the name.
                        //
                        if (!bLocalTable)
                        {
                            //
                            // if this is a pre-loaded name, just leave it alone
                            //
                            if (!(pNameAddr->NameTypeState & PRELOADED))
                            {
                                //
                                // if someone is still using the name, do not
                                // dereference it, since that would leave the
                                // ref count at 1, and allow RemoteHashTimeout
                                // code to remove it before the client using
                                // the name is done with it. Once the client is
                                // done with it (i.e. a connect request), they
                                // will deref it , setting the ref count to 1 and
                                // it will be suitable for reuse.
                                //
                                if (pNameAddr->RefCount > 1)
                                {
                                    pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                                    pNameAddr->NameTypeState |= STATE_RELEASED;
                                }
                                else
                                {
                                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                                }
                            }
                        }
                        else
                        {
                            pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                            pNameAddr->NameTypeState |= STATE_CONFLICT;
                            pNameAddr->ConflictMask |= pDeviceContext->AdapterMask;
                            NbtLogEvent (EVENT_NBT_NAME_RELEASE, SrcAddress, 0x103);
                        }
                        break;

                    default:
                        break;
                }
            }


            //
            // tell WINS that the name released ok
            //
            Rcode = 0;
        }
        else
        {
            Rcode = NAME_ERROR;
        }

        //
        // Only respond if not a broadcast...
        //
        if (!(OpCodeFlags & FL_BROADCAST))
        {
            status = UdpSendResponse(
                            lNameSize,
                            pNameHdr,
                            NULL,
                            (PTDI_ADDRESS_IP)&pSourceAddress->Address[0].Address[0],
                            pDeviceContext,
                            Rcode,
                            eNAME_RELEASE,
                            OldIrq1);
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        }
    } // end of Release Request processing

    return (STATUS_DATA_NOT_ACCEPTED);
}

//----------------------------------------------------------------------------
NTSTATUS
WackFromNet(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pSrcAddress,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNumBytes
    )
/*++

Routine Description:

    This routine handles Wait Acks from the name server. It finds the corresponding
    name service transaction and changes the timeout of that transaction according
    to the TTL field in the WACK.

Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS            status;
    ULONG               lNameSize;
    CHAR                pName[NETBIOS_NAME_SIZE];
    PUCHAR              pScope;
    tNAMEADDR           *pNameAddr;
    CTELockHandle       OldIrq1;
    ULONG               Ttl;
    tTIMERQENTRY        *pTimerEntry;

    //
    // check the pdu size for errors
    //
    if (lNumBytes < (NBT_MINIMUM_WACK + NbtConfig.ScopeLength -1))
    {
        KdPrint(("Nbt:WACK TOO short = %X\n",lNumBytes));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    // get the name out of the network pdu and pass to routine to check
    status = ConvertToAscii(
                    (PCHAR)&pNameHdr->NameRR,
                    lNumBytes - FIELD_OFFSET(tNAMEHDR,NameRR),
                    pName,
                    &pScope,
                    &lNameSize);

    if (!NT_SUCCESS(status))
    {
//        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.WackFromNet: WARNING!!! Rejecting Request -- ConvertToAscii FAILed\n"));
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

#ifdef VXD
    if ( FindContextDirect(    pNameHdr->TransactId ) != NULL )
    {
        status = STATUS_SUCCESS;
    }
    else
    {
#endif // VXD
        status = FindInHashTable(NbtConfig.pLocalHashTbl,
                                    pName,
                                    pScope,
                                    &pNameAddr);
#ifdef VXD
    }
#endif // VXD

    if (NT_SUCCESS(status))
    {
        Ttl = *(ULONG UNALIGNED *)((ULONG_PTR)&pNameHdr->NameRR.NetBiosName[0]
                                   + lNameSize
                                   + FIELD_OFFSET(tQUERYRESP,Ttl) );
        Ttl = ntohl(Ttl);

        if (pTimerEntry = pNameAddr->pTimer)
        {

           // convert seconds to milliseconds and put into the DeltaTime
           // field so that when the next timeout occurs it changes the timer
           // value to this new one.  Depending on how many timeouts are left
           // this could cause the client to wait several times the WACK timeout
           // value.  For example a Name query nominally has two retries, so if
           // the WACK returns before the first retry then the total time waited
           // will be 2*Ttl. This is not a problem since the real reason for
           // the timeout is to prevent waiting forever for a dead name server.
           // If the server returns a WACK it is not dead and the chances are
           // that it will return a response before the timeout anyway.
           //
           // The timeout routine checks if TIMER_RETIMED is set and restarts
           // the timeout without any processing if that is true ( and clears
           // the flag too).
           //
           Ttl *= 1000;
           if (Ttl > pTimerEntry->DeltaTime)
           {
               pTimerEntry->DeltaTime = Ttl;
               pTimerEntry->Flags |= TIMER_RETIMED;
           }

        }

    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    return(STATUS_DATA_NOT_ACCEPTED);
}

//----------------------------------------------------------------------------
VOID
SetupRefreshTtl(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  tNAMEADDR           *pNameAddr,
    IN  LONG                lNameSize
    )
/*++

Routine Description:

    This routine handles name refresh timeouts.  It looks at the Ttl in the
    registration response and determines if the Node's refresh timeout should
    be lengthened or shortened.  To do this both the Ttl and the name associated
    with the Ttl are kept in the Config structure.  If the Ttl becomes longer
    for the shortest names Ttl, then all the names use the longer value.

Arguments:

Return Value:

    NTSTATUS - success or not - failure means no response to net

--*/
{
    NTSTATUS        status;
    ULONG           Ttl;
    tTIMERQENTRY    *pTimerQEntry;

    // the Ttl in the pdu is in seconds.  We need to convert it to milliseconds
    // to use for our timer.  This limits the timeout value to about 50 days
    // ( 2**32 / 3600/24/1000  - milliseconds converted to days.)
    //
    Ttl = *(ULONG UNALIGNED *) ((PUCHAR)&pNameHdr->NameRR.NetBiosName[0]
                                + lNameSize
                                + FIELD_OFFSET(tQUERYRESP,Ttl));

    Ttl = ntohl(Ttl);

    // the Ttl value may overflow the value we can store in Milliseconds,
    // check for this case, and if it happens, use the longest timeout possible
    // that still runs refresh, - i.e. NBT_MAXIMUM_TTL disables refresh
    // altogether, so use NBT_MAXIMUM_TTL-1).
    if (Ttl >= 0xFFFFFFFF/1000)
    {
        Ttl = NBT_MAXIMUM_TTL - 1;
    }
    else
    {
        Ttl *= 1000;        // convert to milliseconds
    }

    // a zero Ttl means infinite, so set time the largest timeout
    //
    if (Ttl == 0)
    {
        Ttl = NBT_MAXIMUM_TTL;       // set very large number which turns off refreshes
    }
    else
    if (Ttl < NBT_MINIMUM_TTL)
    {
        Ttl = NBT_MINIMUM_TTL;
    }

    // Set the Ttl for the name record
    //
    pNameAddr->Ttl = Ttl;

    //
    // decide what to do about the existing timer....
    // If the new timeout is shorter, then cancel the
    // current timeout and start another one.
    //
    if (Ttl < NbtConfig.MinimumTtl)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt:Shortening Refresh Ttl from %d to %d\n",
                    NbtConfig.MinimumTtl, Ttl));

        NbtConfig.MinimumTtl = (ULONG)Ttl;
        //
        // don't allow the stop timer routine to call the completion routine
        // for the timer.
        //
        if (pTimerQEntry = NbtConfig.pRefreshTimer)
        {
            CHECK_PTR(pTimerQEntry);
            pTimerQEntry->TimeoutRoutine = NULL;
            status = StopTimer(pTimerQEntry,NULL,NULL);
        }

        // keep the timeout for checking refreshes to about 10 minutes
        // max. (MAX_REFRESH_CHECK_INTERVAL).  If the refresh interval
        // is less than 80 minutes then always use a refresh divisor of
        // 8 - this allows the initial default ttl of 16 minutes to result
        // in retries every 2 minutes.
        //
        NbtConfig.RefreshDivisor = NbtConfig.MinimumTtl/MAX_REFRESH_CHECK_INTERVAL;
        if (NbtConfig.RefreshDivisor < REFRESH_DIVISOR)
        {
            NbtConfig.RefreshDivisor = REFRESH_DIVISOR;
        }

        //
        // start the timer
        //
        status = StartTimer(RefreshTimeout,
                            Ttl/NbtConfig.RefreshDivisor,
                            NULL,            // context value
                            NULL,            // context2 value
                            NULL,
                            NULL,
                            NULL,           // This Timer is a global timer
                            &NbtConfig.pRefreshTimer,
                            0,
                            TRUE);
#if DBG
        if (!NT_SUCCESS(status))
        {
            KdPrint(("Nbt:Failed to start a new timer for refresh\n"));
        }
#endif

    }
    else
    if (Ttl > NbtConfig.MinimumTtl)
    {
        tHASHTABLE  *pHashTable;
        LONG        i;
        PLIST_ENTRY pHead,pEntry;

    // PUT this code back in again, since it is possible that the name
    // server could miss registering a name due to being busy and if we
    // lengthen the timeout here then that name will not get into wins for
    // a very long time.

        // the shortest Ttl got longer, check if there is another shortest
        // Ttl by scanning the local name table.
        //
        pHashTable = NbtConfig.pLocalHashTbl;
        for (i=0;i < pHashTable->lNumBuckets ;i++ )
        {
            pHead = &pHashTable->Bucket[i];
            pEntry = pHead->Flink;
            while (pEntry != pHead)
            {
                pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
                //
                // Find a valid name with a lower TTL if possible
                //
                if ((pNameAddr->Name[0] != '*') &&
                    ((pNameAddr->NameTypeState & STATE_RESOLVED)) &&
                    (pNameAddr->Ttl < (ULONG)Ttl) &&
                    (!IsBrowserName(pNameAddr->Name)) && 
                    (!(pNameAddr->NameTypeState & NAMETYPE_QUICK)))
                {
                    if (pNameAddr->Ttl >= NBT_MINIMUM_TTL)
                    {
                        NbtConfig.MinimumTtl = pNameAddr->Ttl;
                    }
                    return;
                }
                pEntry = pEntry->Flink;
            }
        }

        //
        // if we get to here then there is no shorter ttl, so use the new
        // ttl received from the WINS as the ttl.  The next time the refresh
        // timer expires it will restart with this new ttl
        //
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Lengthening Refresh Ttl from %d to %d\n",
                    NbtConfig.MinimumTtl, Ttl));

        NbtConfig.MinimumTtl = Ttl;

        // keep the timeout for checking refreshes to about 10 minutes
        // max. (MAX_REFRESH_CHECK_INTERVAL).  If the refresh interval
        // is less than 80 minutes then always use a refresh divisor of
        // 8 - this allows the initial default ttl of 16 minutes to result
        // in retries every 2 minutes.
        //
        NbtConfig.RefreshDivisor = NbtConfig.MinimumTtl/MAX_REFRESH_CHECK_INTERVAL;
        if (NbtConfig.RefreshDivisor < REFRESH_DIVISOR)
        {
            NbtConfig.RefreshDivisor = REFRESH_DIVISOR;
        }

    }


}

//----------------------------------------------------------------------------
NTSTATUS
DecodeNodeStatusResponse(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  ULONG               Length,
    IN  PUCHAR              pName,
    IN  ULONG               lNameSize,
    IN  tIPADDRESS          SrcIpAddress
    )
/*++

Routine Description:

    This routine handles putting the node status response pdu into the clients
    MDL.

Arguments:


Return Value:

    none

--*/
{
    NTSTATUS                status;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pNext;
    tNODESTATUS UNALIGNED   *pNodeStatus;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq2;
    tDGRAM_SEND_TRACKING    *pTracker;
    tTIMERQENTRY            *pTimer;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   pClientContext;
    BOOL                    MatchFound=FALSE;
    tIPADDRESS              IpAddress;
    PVOID                   pBuffer;

    // first find the originating request in the NodeStatus list
    CTESpinLock(&NbtConfig.JointLock,OldIrq2);
    CTESpinLock(&NbtConfig,OldIrq);

    pEntry = pHead = &NbtConfig.NodeStatusHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pTracker = CONTAINING_RECORD(pEntry,tDGRAM_SEND_TRACKING,Linkage);
        ASSERT (NBT_VERIFY_HANDLE (pTracker, NBT_VERIFY_TRACKER));
        ASSERT (pTracker->TrackerType == NBT_TRACKER_SEND_NODE_STATUS);

        if (!(pTimer = pTracker->pTimer))
        {
            continue;
        }

        MatchFound = FALSE;

        //
        // find who sent the request originally
        //
        if (pTracker->Flags & REMOTE_ADAPTER_STAT_FLAG)
        {
            IpAddress = Nbt_inet_addr(pTracker->pNameAddr->Name, REMOTE_ADAPTER_STAT_FLAG);
        }
        else
        {
            IpAddress = 0;
        }

        if ((CTEMemEqu(pName,pTracker->pNameAddr->Name,NETBIOS_NAME_SIZE)) ||
            ((IpAddress==SrcIpAddress)&&(IpAddress!=0)))
        {
            //
            // if we directed node status request to an ipaddr without knowing
            // its netbios name, then name is stored as "*      ".
            //
            if ((pName[0] == '*') && (IpAddress == 0) && (pTracker->pNameAddr->pIpAddrsList))
            {
                int  i=0;

                //
                // SrcIpAddress may not match the ipaddr to which we sent if
                // remote host is multihomed: so search whole list of all
                // ipaddrs for that host
                //
                ASSERT(pTracker->pNameAddr->pIpAddrsList);

                while(pTracker->pNameAddr->pIpAddrsList[i])
                {
                    if (pTracker->pNameAddr->pIpAddrsList[i++] == SrcIpAddress)
                    {
                        MatchFound = TRUE;
                        break;
                    }
                }
            }
            else
            {
                MatchFound = TRUE;
            }
        }

        if (MatchFound)
        {
            RemoveEntryList(pEntry);
            InitializeListHead (&pTracker->Linkage);    // in case the Timeout routine is running

            // this is the amount of data left, that we do not want to go
            // beyond, otherwise the system will bugcheck
            //
            Length -= FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize;
            pNodeStatus = (tNODESTATUS *)&pNameHdr->NameRR.NetBiosName[lNameSize];

            CTESpinFree(&NbtConfig,OldIrq);

            status = StopTimer(pTimer,&pClientCompletion,&pClientContext);
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);

            if (pClientCompletion)
            {
                tDGRAM_SEND_TRACKING    *pClientTracker = (tDGRAM_SEND_TRACKING *) pClientContext;

                pClientTracker->RemoteIpAddress = SrcIpAddress;
                pClientTracker->pNodeStatus     = pNodeStatus;
                pClientTracker->NodeStatusLen   = Length;

                (*pClientCompletion) (pClientContext, STATUS_SUCCESS);

            }

            CTESpinLock(&NbtConfig.JointLock,OldIrq2);
            CTESpinLock(&NbtConfig,OldIrq);
            break;
        }
    }

    CTESpinFree(&NbtConfig,OldIrq);
    CTESpinFree(&NbtConfig.JointLock,OldIrq2);

    return(STATUS_UNSUCCESSFUL);
}


//----------------------------------------------------------------------------
typedef enum    _dest_type {
    IP_ADDR,
    DNS,
    NETBIOS
} DEST_TYPE;

DEST_TYPE
GetDestType(
    IN tDGRAM_SEND_TRACKING *pClientTracker
    )

/*++
Routine Description:

    Classifies name passed in as an IP addr/Netbios name/Dns name

Arguments:

Return Value:
    DEST_TYPE

--*/
{
    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("Nbt.GetDestType: Name=<%16.16s:%x>\n",
            pClientTracker->pDestName, pClientTracker->pDestName[15]));

    if (Nbt_inet_addr(pClientTracker->pDestName, 0))
    {
        return  IP_ADDR;
    }
    else if (pClientTracker->RemoteNameLength > NETBIOS_NAME_SIZE)
    {
        return DNS;
    }
    else
    {
        return NETBIOS;
    }
}

//----------------------------------------------------------------------------
VOID
ExtractServerNameCompletion(
    IN  tDGRAM_SEND_TRACKING    *pClientTracker,
    IN  NTSTATUS                status
    )
/*++
Routine Description:

    This Routine searches for the server name (name ending with 0x20) from the
    list of names returned by node status response, and adds that name to the
    remote hash table.

Arguments:

    pNodeStatus      Node status response from the remote host
    pClientContext   Tracker for the seutp phase
    IpAddress        Ip address of the node that just responded

Return Value:

    none

--*/

{

    ULONG                   i;
    UCHAR                   NodeFlags, NameExtension;
    PCHAR                   pName;
    PCHAR                   pBestName = NULL;
    tSESSIONREQ             *pSessionReq;
    PUCHAR                  pCopyTo;
    DEST_TYPE               DestType;
    ULONG                   TrackerFlags;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   pClientContext;
    tNODESTATUS UNALIGNED   *pNodeStatus = pClientTracker->pNodeStatus;
    tIPADDRESS              IpAddress = pClientTracker->RemoteIpAddress;
    BOOL                    bForce20NameLookup = FALSE;
    tDEVICECONTEXT          *pDeviceContext = NULL;

    ASSERT (NBT_VERIFY_HANDLE (pClientTracker, NBT_VERIFY_TRACKER));

    if (STATUS_SUCCESS == status)
    {
        status = STATUS_REMOTE_NOT_LISTENING;

        DestType = GetDestType(pClientTracker);
        TrackerFlags = pClientTracker->Flags;

        NameExtension = pClientTracker->pDestName[NETBIOS_NAME_SIZE-1];
        //
        // If the not a Netbios name, and the 16th character is ASCII,
        // then look for the Server name
        //
        if ((DestType != NETBIOS) &&
            (NameExtension > 0x20 ) &&
            (NameExtension < 0x7f ))
        {
            NameExtension = SPECIAL_SERVER_SUFFIX;
        }

        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("ExtractSrvName: DestType: %d\n", DestType));

        bForce20NameLookup = FALSE;

again:
        if (bForce20NameLookup) {
            DestType = DNS;
            NameExtension = 0x20;
        }

        for(i =0; i<pNodeStatus->NumNames; i++)
        {
            pName = &pNodeStatus->NodeName[i].Name[0];
            NodeFlags = pNodeStatus->NodeName[i].Flags;

            //
            // make sure it's a unique name (for connects only, for dgram sends, group names are fine)
            // and is not in conflict or released
            //
            if ((NodeFlags & (NODE_NAME_CONFLICT | NODE_NAME_RELEASED)) ||
                !(((TrackerFlags & SESSION_SETUP_FLAG) && !(NodeFlags & GROUP_STATUS)) ||
                  (TrackerFlags & (DGRAM_SEND_FLAG | REMOTE_ADAPTER_STAT_FLAG))))
            {
                continue;
            }

            if ((DestType == IP_ADDR) || (DestType == DNS))
            {
                if (pName[NETBIOS_NAME_SIZE-1] != NameExtension)
                {
                    continue;
                }

                //
                // For IP addresses and DNS names, we map the 0x20 name to the corresp 0x0 name
                // for datagram sends.
                //
                if (pClientTracker->Flags & DGRAM_SEND_FLAG)
                {
                    IF_DBG(NBT_DEBUG_NETBIOS_EX)
                        KdPrint(("ExtractServerName: Mapping 0x20 name to 0x0\n"));

                    pName[NETBIOS_NAME_SIZE-1] = 0x0;
                }
            }
            //
            // For Netbios names (resolved via DNS), we match the 16th byte exactly
            //
            else  if (pName[NETBIOS_NAME_SIZE-1] != pClientTracker->pDestName[NETBIOS_NAME_SIZE-1])
            {
                continue;
            }

            pDeviceContext = GetDeviceFromInterface(ntohl(IpAddress), TRUE);
            status = STATUS_SUCCESS;
            break;     // found the name: done with the for loop
        }

        if (!NT_SUCCESS(status) && !bForce20NameLookup &&
                NameExtension > 0x20 && NameExtension < 0x7f &&
                pClientTracker->RemoteNameLength == NETBIOS_NAME_SIZE) {

            // It might be a FQDN that is exactly the same size as NETBIOS_NAME_SIZE
            // better check again with that assumption.

            bForce20NameLookup = TRUE;
            goto again;
        }

        if (NT_SUCCESS(status))
        {
            //
            // fix up the connection tracker to point to the right name, now
            // that we know the server name to connect to
            //

            //
            // The FIND_NAME_FLAG was set to indicate that this is not a session setup attempt so
            // we can avoid the call to ConvertToHalfAscii.
            //
            if (!(pClientTracker->Flags & FIND_NAME_FLAG))
            {
                if (pClientTracker->Flags & SESSION_SETUP_FLAG)
                {
                    CTEMemCopy(pClientTracker->SendBuffer.pBuffer,pName,NETBIOS_NAME_SIZE);
                    CTEMemCopy(pClientTracker->pConnEle->RemoteName,pName,NETBIOS_NAME_SIZE);
#ifdef VXD
                    CTEMemCopy(&pClientTracker->pClientIrp->ncb_callname[0],pName,NETBIOS_NAME_SIZE);
#endif // VXD
                    pSessionReq = pClientTracker->SendBuffer.pDgramHdr;

                    //
                    // overwrite the Dest HalfAscii name in the Session Pdu with the correct name
                    //
                    pCopyTo = ConvertToHalfAscii((PCHAR)&pSessionReq->CalledName.NameLength,
                                                pName,
                                                NbtConfig.pScope,
                                                NbtConfig.ScopeLength);
                }
                else if (pClientTracker->Flags & DGRAM_SEND_FLAG)
                {
                    PCHAR       pCopyTo;
                    tDGRAMHDR   *pDgramHdr;

                    //
                    // Overwrite the dest name, so SendDgramContinue can find the name
                    // in the caches.
                    //
                    CTEMemCopy(pClientTracker->pDestName,pName,NETBIOS_NAME_SIZE);

                    //
                    // Copy over the actual dest name in half-ascii
                    // This is immediately after the SourceName; so offset the
                    // dest by the length of the src name.
                    //
                    pDgramHdr = pClientTracker->SendBuffer.pDgramHdr;
                    pCopyTo = (PVOID)&pDgramHdr->SrcName.NameLength;

                    IF_DBG(NBT_DEBUG_NETBIOS_EX)
                        KdPrint(("pCopyTo:%lx\n", pCopyTo));

                    pCopyTo += 1 +                          // Length field
                               2 * NETBIOS_NAME_SIZE +     // actual name in half-ascii
                               NbtConfig.ScopeLength;     // length of scope

                    IF_DBG(NBT_DEBUG_NETBIOS_EX)
                        KdPrint(("pCopyTo:%lx\n", pCopyTo));

                    ConvertToHalfAscii (pCopyTo, pName, NbtConfig.pScope, NbtConfig.ScopeLength);

                    IF_DBG(NBT_DEBUG_NETBIOS_EX)
                        KdPrint(("Copied the remote name for dgram sends\n"));
                }
            }
            else
            {
                KdPrint(("ExtractServerName: Find name going on\n"));
            }

            //
            // Add this server name to the remote hashtable
            // if Nameaddr can't be added, it means an entry already exists
            // Get that entry and update its ipaddr.
            //
            LockAndAddToHashTable (NbtConfig.pRemoteHashTbl,
                                   pName,
                                   NbtConfig.pScope,
                                   IpAddress,
                                   NBT_UNIQUE,
                                   NULL,
                                   NULL,
                                   pDeviceContext,
                                   (USHORT) ((TrackerFlags & NBT_DNS_SERVER) ?
                                       NAME_RESOLVED_BY_DNS | NAME_RESOLVED_BY_ADAP_STAT:
                                       NAME_RESOLVED_BY_ADAP_STAT));
        }
    }

    if (pDeviceContext)
    {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, FALSE);
    }

    pClientCompletion = pClientTracker->CompletionRoutine;
    pClientContext = pClientTracker;    // Use this same tracker as the context

    CompleteClientReq(pClientCompletion, pClientContext, status);
}



//----------------------------------------------------------------------------
VOID
CopyNodeStatusResponseCompletion(
    IN  tDGRAM_SEND_TRACKING    *pClientTracker,
    IN  NTSTATUS                status
    )
/*++
Routine Description:

    This Routine copies data received from the net node status response to
    the client's irp.  It is called from inbound.c when a node status response
    comes in from the wire.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    none

--*/

{
    ULONG                   NumNames;
    ULONG                   i;
    PADAPTER_STATUS         pAdapterStatus = NULL;
    PNAME_BUFFER            pNameBuffer;
    ULONG                   BuffSize;
    ULONG                   AccumLength;
    PUCHAR                  pAscii;
    UCHAR                   Flags;
    ULONG                   DataLength;
    ULONG                   DestSize ;
    tSTATISTICS UNALIGNED   *pStatistics;
    ULONG                   SrcIpAddress;
    ULONG                   TotalLength;
    tNODESTATUS             *pNodeStat;
    COMPLETIONCLIENT        pClientCompletion;
    PIRP                    pIrp;
    tNAMEADDR               *pNameAddr;
    CTELockHandle           OldIrq, OldIrq1;

    CHECK_PTR(pClientTracker);
    SrcIpAddress            = pClientTracker->RemoteIpAddress;
    TotalLength             = pClientTracker->NodeStatusLen;
    pClientTracker->NodeStatusLen = 0;
    pNodeStat               = (tNODESTATUS *) pClientTracker->pNodeStatus;
    pClientTracker->pNodeStatus   = NULL;
    pIrp                    = pClientTracker->ClientContext;

    ASSERT (NBT_VERIFY_HANDLE (pClientTracker, NBT_VERIFY_TRACKER));
    ASSERT (pClientTracker->TrackerType == NBT_TRACKER_ADAPTER_STATUS);

    pClientTracker->pDeviceContext = NULL;  // Can be set below if we need add the name to the cache

    if (STATUS_SUCCESS == status)
    {
        //
        // Bug# 125629:
        // We have already verified in QueryFromNet (just before calling
        // DecodeNodeStatusResponse) that the NodeStatus structure is
        // large enough to cover the NumNames field + it has the number of
        // names specified in that field
        //
        NumNames = pNodeStat->NumNames;
        BuffSize = sizeof(ADAPTER_STATUS) + NumNames*sizeof(NAME_BUFFER);

        // sanity check that we are not allocating more than 64K for this stuff
        if (BuffSize > 0xFFFF)
        {
            status = STATUS_UNSUCCESSFUL;
            goto ExitRoutine;
        }

        pAdapterStatus = NbtAllocMem((USHORT)BuffSize,NBT_TAG('9'));
        if (!pAdapterStatus)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto ExitRoutine;
        }

        // Fill out the adapter status structure with zeros first
        CTEZeroMemory((PVOID)pAdapterStatus,BuffSize);

        // get the source MAC address from the statistics portion of the pdu
        //
        if (TotalLength >= (NumNames*sizeof(tNODENAME) + sizeof(tSTATISTICS)))
        {
            pStatistics = (tSTATISTICS UNALIGNED *)((PUCHAR)&pNodeStat->NodeName[0] + NumNames*sizeof(tNODENAME));

            CTEMemCopy(&pAdapterStatus->adapter_address[0], &pStatistics->UnitId[0], sizeof(tMAC_ADDRESS));
        }

        pAdapterStatus->rev_major = 0x03;
        pAdapterStatus->adapter_type = 0xFE;    // pretend it is an ethernet adapter

        //
        // get the ptr to the statistics field if there is one in the pdu
        //
        AccumLength = NumNames * sizeof(tNODENAME) +
                      FIELD_OFFSET(tNODESTATUS, NodeName) + sizeof(USHORT) +
                      FIELD_OFFSET( tSTATISTICS, SessionDataPacketSize ) ;

        if (AccumLength <= TotalLength)
        {
            //
            // there is a whole statistics portion to the adapter status command,
            // so we can get the session pdu size out of it.
            //
            pAdapterStatus->max_sess = ntohs((USHORT)*((PUCHAR)pNodeStat + AccumLength - sizeof(USHORT)));
        }

        // get the address of the name buffer at the end of the adapter status
        // structure so we can copy the names into this area.
        pNameBuffer = (NAME_BUFFER *) ((ULONG_PTR)pAdapterStatus + sizeof(ADAPTER_STATUS));

        // set the AccumLength to the start of the node name array in the buffer
        // so we can count through the buffer and be sure not to run off the end
        //
        AccumLength = FIELD_OFFSET(tNODESTATUS, NodeName);

        //
        // We need to determine the outgoing Device for the remote machine, in
        // case we need to add any names below.
        //
        pClientTracker->pDeviceContext = GetDeviceFromInterface (htonl(SrcIpAddress), TRUE);

        for(i =0; i< NumNames; i++)
        {
            AccumLength += sizeof(tNODENAME);
            if (AccumLength > TotalLength)
            {
                    //
                    //  The remote buffer is incomplete, what else can we do?
                    //
                    status = STATUS_UNSUCCESSFUL;
                    goto ExitCleanup;
            }
            pAdapterStatus->name_count++ ;
            pAscii = (PCHAR)&pNodeStat->NodeName[i].Name[0];
            Flags = pNodeStat->NodeName[i].Flags;

            pNameBuffer->name_flags = (Flags & GROUP_STATUS) ? GROUP_NAME : UNIQUE_NAME;

            //
            // map the name states
            //
            if (Flags & NODE_NAME_CONFLICT)
            {
                if (Flags & NODE_NAME_RELEASED)
                    pNameBuffer->name_flags |= DUPLICATE_DEREG;
                else
                    pNameBuffer->name_flags |= DUPLICATE;
            }
            else if (Flags & NODE_NAME_RELEASED)
            {
                pNameBuffer->name_flags |= DEREGISTERED;
            }
            else
            {
                pNameBuffer->name_flags |= REGISTERED;
            }

            pNameBuffer->name_num = (UCHAR)i+1;
            CTEMemCopy(pNameBuffer->name,pAscii,NETBIOS_NAME_SIZE);

            //
            // If the name is the 0x20 name, see if we can add it to the remote hashtable
            // (only if the name is not already there)!
            //
            if ((pAscii[NETBIOS_NAME_SIZE-1] == 0x20) &&
                ((Flags & (NODE_NAME_CONFLICT | NODE_NAME_RELEASED)) == 0))
            {
                NbtAddEntryToRemoteHashTable (pClientTracker->pDeviceContext,
                                              NAME_RESOLVED_BY_ADAP_STAT,
                                              pAscii,
                                              SrcIpAddress,
                                              NbtConfig.RemoteTimeoutCount*60,  // from minutes to secs
                                              UNIQUE_STATUS);
            }

            pNameBuffer++;
        }

        //
        //  Reduce the name count if we can't fit the buffer
        //
#ifdef VXD
        DestSize = ((NCB*)pIrp)->ncb_length ;
#else
        DestSize = MmGetMdlByteCount( pIrp->MdlAddress ) ;
#endif

        CHECK_PTR(pAdapterStatus);
        if ( BuffSize > DestSize )
        {
            if ( DestSize < sizeof( ADAPTER_STATUS ))
            {
                pAdapterStatus->name_count = 0 ;
            }
            else
            {
                pAdapterStatus->name_count = (WORD) (DestSize- sizeof(ADAPTER_STATUS)) / sizeof(NAME_BUFFER) ;
            }
        }

        //
        //  Copy the built adapter status structure
        //
#ifdef VXD
        if ( BuffSize > DestSize )
        {
            status = STATUS_BUFFER_OVERFLOW ;
            BuffSize = DestSize ;
        }
        else
        {
            status = STATUS_SUCCESS ;
        }

        CTEMemCopy(((NCB*)pIrp)->ncb_buffer, pAdapterStatus, BuffSize);
        ((NCB*)pIrp)->ncb_length = (WORD) BuffSize;     //  Set here to be compatible with NT
#else
        status = TdiCopyBufferToMdl (pAdapterStatus, 0, BuffSize, pIrp->MdlAddress, 0, &DataLength);
        pIrp->IoStatus.Information = DataLength;
        pIrp->IoStatus.Status = status;
#endif
    }

ExitCleanup:
    if (pAdapterStatus)
    {
        CTEMemFree((PVOID)pAdapterStatus);
    }

ExitRoutine:

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // the tracker block was unlinked in DecodeNodeStatusResponse,
    // and its header was freed when the send completed, so just relink
    // it here - this deref should do the relink.
    //

    if (pIrp)
    {
        if (status == STATUS_SUCCESS ||
            status == STATUS_BUFFER_OVERFLOW )  // Only partial data copied
        {
            // -1 means the receive length is already set in the irp
            CTEIoComplete(pIrp,status,0xFFFFFFFF);
        }
        else
        {
            //
            // failed to get the adapter status, so
            // return failure status to the client.
            //
            CTEIoComplete(pIrp,STATUS_IO_TIMEOUT,0);
        }
    }

    if (pClientTracker->pDeviceContext)
    {
        NBT_DEREFERENCE_DEVICE (pClientTracker->pDeviceContext, REF_DEV_OUT_FROM_IP, TRUE);
    }

    NBT_DEREFERENCE_TRACKER (pClientTracker, TRUE);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}

//----------------------------------------------------------------------------
NTSTATUS
SendNodeStatusResponse(
    IN  tNAMEHDR UNALIGNED  *pInNameHdr,
    IN  ULONG               Length,
    IN  PUCHAR              pName,
    IN  ULONG               lNameSize,
    IN  tIPADDRESS          SrcIpAddress,
    IN  USHORT              SrcPort,
    IN  tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine handles putting the node status response pdu into the clients
    MDL.

Arguments:


Return Value:

    none

--*/
{
    NTSTATUS                status;
    PUCHAR                  pScope;
    PUCHAR                  pInScope;
    ULONG                   Position;
    ULONG                   CountNames;
    ULONG                   BuffSize;
    tNODESTATUS UNALIGNED   *pNodeStatus;
    tNAMEHDR                *pNameHdr;
    CTELockHandle           OldIrq2;
    ULONG                   i;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    tADDRESSELE             *pAddressEle;
    tNAMEADDR               *pNameAddr;
    tDGRAM_SEND_TRACKING    *pTracker;
    ULONG                   InScopeLength;
    tSTATISTICS UNALIGNED   *pStatistics;
    tNODENAME UNALIGNED     *pNode;
    CTEULONGLONG            AdapterMask;
    ULONG                   Len;

    if (Length > sizeof(tNAMEHDR) + lNameSize - 1 + sizeof(ULONG))
    {
        return(STATUS_DATA_NOT_ACCEPTED);
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq2);

    // verify that the requesting node is in the same scope as this node, so
    // get a ptr to the scope, which starts 16*2 (32) bytes into the
    // netbios name in the pdu.
    //
    pInScope = (PUCHAR)&pInNameHdr->NameRR.NetBiosName[(NETBIOS_NAME_SIZE <<1)];
    pScope = NbtConfig.pScope;

    Position = sizeof(tNAMEHDR) - sizeof(tNETBIOS_NAME) +1 + (NETBIOS_NAME_SIZE <<1);

    // check the scope length
    InScopeLength = Length - Position - sizeof(ULONG);
    if (InScopeLength != NbtConfig.ScopeLength)
    {
        status = STATUS_DATA_NOT_ACCEPTED;
        goto ErrorExit;
    }

    // compare scopes for equality and avoid running off the end of the pdu
    //
    i= 0;
    while (i < NbtConfig.ScopeLength)
    {
        if (*pInScope != *pScope)
        {
            status = STATUS_DATA_NOT_ACCEPTED;
            goto ErrorExit;
        }
        i++;
        pInScope++;
        pScope++;
    }

    // get the count of names, excluding '*...' which we do not send...
    //
    CountNames = CountLocalNames(&NbtConfig);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt:Node Status Response, with %d names\n",CountNames));

    // this is only a byte field, so only allow up to 255 names.
    if (CountNames > 255)
    {
        CountNames = 255;
    }


    // Allocate Memory for the adapter status

    // - ULONG for the Nbstat and IN that are part of Length.  CountNames-1
    // because there is one name in sizeof(tNODESTATUS) already
    //
    BuffSize = Length + sizeof(tNODESTATUS) - sizeof(ULONG) + (CountNames-1)*sizeof(tNODENAME)
                    +  sizeof(tSTATISTICS);

    pNameHdr = (tNAMEHDR *)NbtAllocMem((USHORT)BuffSize,NBT_TAG('A'));
    if (!pNameHdr)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // copy the request to the response and change a few bits around
    //
    CTEMemCopy((PVOID)pNameHdr,(PVOID)pInNameHdr,Length);
    pNameHdr->OpCodeFlags = OP_RESPONSE | FL_AUTHORITY;
    pNameHdr->QdCount = 0;
    pNameHdr->AnCount = 1;

    pNodeStatus = (tNODESTATUS UNALIGNED *)&pNameHdr->NameRR.NetBiosName[lNameSize];
    pNodeStatus->Ttl = 0;

    pNode = (tNODENAME UNALIGNED *)&pNodeStatus->NodeName[0];
    AdapterMask = pDeviceContext->AdapterMask;

    i = 0;
    pEntry = pHead = &NbtConfig.AddressHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);

        pNameAddr = pAddressEle->pNameAddr;

        pNode->Flags = (pAddressEle->NameType == NBT_UNIQUE) ? UNIQUE_STATUS : GROUP_STATUS;

        // all names have this one set
        //
        pNode->Flags |= NODE_NAME_ACTIVE;
        switch (pNameAddr->NameTypeState & NAME_STATE_MASK)
        {
            default:
            case STATE_RESOLVED:
                break;

            case STATE_CONFLICT:
                pNode->Flags |= NODE_NAME_CONFLICT;
                break;

            case STATE_RELEASED:
                pNode->Flags |= NODE_NAME_RELEASED;
                break;

            case STATE_RESOLVING:
                // don't count these names.
                continue;

        }

        switch (NodeType & NODE_MASK)
        {
            case BNODE:
                pNode->Flags |= STATUS_BNODE;
                break;

            case MSNODE:
            case MNODE:
                pNode->Flags |= STATUS_MNODE;
                break;

            case PNODE:
                pNode->Flags |= STATUS_PNODE;
        }

        CHECK_PTR(pNode);

        // Copy the name in the pdu
        CTEMemCopy((PVOID)&pNode->Name[0], (PVOID)pNameAddr->Name, NETBIOS_NAME_SIZE);
        pNode->Resrved = 0;

        // check for the permanent name...and add it too
        //
        if (pNameAddr->NameTypeState & NAMETYPE_QUICK)
        {
            //
            // the permanent name is added as a Quick Add in the name table
            // do not put the permanent name into the response
            //
            continue;
        }
        else if ((pNameAddr->Name[0] == '*') ||
                 (pNameAddr->NameTypeState & STATE_RESOLVING) ||
                 (!(pNameAddr->AdapterMask & AdapterMask)))
        {
            //
            // do not put the broadcast name into the response, since neither
            // NBF or WFW NBT puts it there.

            // Also, to not respond with resolving names, or names that are
            // not registered on this adapter (multihomed case)
            //
            continue;
        }

        i++;
        pNode++;
        CHECK_PTR(pNode);

        if (i >= CountNames)
        {
            break;
        }
    }

    CHECK_PTR(pNameHdr);
    CHECK_PTR(pNodeStatus);

    //
    // set the count of names in the response packet
    //
    pNodeStatus->NumNames = (UCHAR)i;

    Len = i*sizeof(tNODENAME) + 1 + sizeof(tSTATISTICS); //+1 for NumNames Byte
    pNodeStatus->Length = (USHORT)htons(Len);

    // fill in some of the statistics fields which occur after the name table
    // in the PDU
    //
    pStatistics = (tSTATISTICS UNALIGNED *)((PUCHAR)&pNodeStatus->NodeName[0] + i*sizeof(tNODENAME));

    CTEZeroMemory((PVOID)pStatistics,sizeof(tSTATISTICS));

    //
    // put the MAC address in the response
    //
    CTEMemCopy(&pStatistics->UnitId[0], &pDeviceContext->MacAddress.Address[0], sizeof(tMAC_ADDRESS));
    //
    // Now send the node status message
    //
    status = GetTracker(&pTracker, NBT_TRACKER_NODE_STATUS_RESPONSE);

    CTESpinFree(&NbtConfig.JointLock,OldIrq2);

    if (!NT_SUCCESS(status))
    {
        CTEMemFree((PVOID)pNameHdr);
    }
    else
    {
        CHECK_PTR(pTracker);
        pTracker->SendBuffer.HdrLength = BuffSize;
        pTracker->SendBuffer.pDgramHdr = (PVOID)pNameHdr;
        pTracker->SendBuffer.pBuffer = NULL;
        pTracker->SendBuffer.Length = 0;
        pTracker->pDeviceContext = pDeviceContext;

        status = UdpSendDatagram(pTracker,
                                 SrcIpAddress,
                                 QueryRespDone, // this routine frees memory and puts the tracker back
                                 pTracker,
                                 SrcPort, // NBT_NAMESERVICE_UDP_PORT 31343 - reply to port request came on...
                                 NBT_NAME_SERVICE);
    }

    return(status);

ErrorExit:

    CTESpinFree(&NbtConfig.JointLock,OldIrq2);


    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
UpdateNameState(
    IN  tADDSTRUCT UNALIGNED    *pAddrStruct,
    IN  tNAMEADDR               *pNameAddr,
    IN  ULONG                   Len,
#ifdef MULTIPLE_WINS
    IN  PULONG                  pContextFlags,
#endif
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  BOOLEAN                 NameServerIsSrc,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  CTELockHandle           OldIrq1
    )
/*++

Routine Description:

    This routine handles putting a list of names into the hash table when
    a response is received that contains one or more than one ip address.

Arguments:


Return Value:

    none

--*/
{

    ULONG           i, CountAddrs;
    tIPADDRESS      *pIpList;
    ULONG           ExtraNames;
    NTSTATUS        status = STATUS_SUCCESS;
    CTELockHandle   OldIrq;
    USHORT          NameAddFlags = (NameServerIsSrc ? NAME_RESOLVED_BY_WINS : NAME_RESOLVED_BY_BCAST);

    //
    // put all of the addresses into a list that is pointed to by the pNameAddr record
    // Terminate it with -1 (0 means a broadcast address)
    //
    ASSERT(pNameAddr->pIpAddrsList == NULL);

    CountAddrs = Len / tADDSTRUCT_SIZE;
    if ((CountAddrs > NBT_MAX_INTERNET_GROUP_ADDRS)|| // probably a badly formated packet (max value=1000)
        (CountAddrs*tADDSTRUCT_SIZE != Len) ||
        (!(pNameAddr->pIpAddrsList = NbtAllocMem(sizeof(tIPADDRESS)*(1+CountAddrs),NBT_TAG('8')))))
    {
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
        return (STATUS_UNSUCCESSFUL);
    }

    /*
     * Replace broadcast address -1 (0xffffffff) with 0 because -1 is reserved as terminator
     */
    for (i = 0; i < CountAddrs; i++) {
        pNameAddr->pIpAddrsList[i] =  (pAddrStruct[i].IpAddr == (tIPADDRESS)(-1))? 0: htonl(pAddrStruct[i].IpAddr);
    }
    pNameAddr->pIpAddrsList[CountAddrs] = (tIPADDRESS)(-1);

    // a pos. response to a previous query, so change the state in the
    // hash table to RESOLVED
    CHECK_PTR(pNameAddr);
    if (pNameAddr->NameTypeState & STATE_RESOLVING)
    {
        pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
        pNameAddr->NameTypeState |= STATE_RESOLVED;

        // check if a group name...
        //
        if (ntohs(pAddrStruct->NbFlags) & FL_GROUP)
        {
            pNameAddr->NameTypeState &= ~NAME_TYPE_MASK;

            // It is difficult to differentiate nameserver responses from
            // single node responses, when a single ip address is returned.
            // It could be the name server returning an Inet Group with one
            // entry or another node simply responding with its address.
            //
            // If the response is just a single broadcast address, we store
            // it as type NAMETYPE_GROUP, otherwise we should store it as
            // NAMETYPE_INET_GROUP -- we should remove the check for NameServer
            // since it does not always work for muti-homed, or cluster Wins servers
            //
            // WINS puts -1 to say it's a groupname
            //
            if ((CountAddrs == 1) &&
                (pAddrStruct->IpAddr == (ULONG)-1))
            {
                // using zero here tells the UdpSendDatagramCode to
                // send to the subnet broadcast address when talking to
                // that address.
                //
                // For Bnodes store the Address of the node that responded
                // to the group name query, since we do allow sessions to
                // group names for BNODES since they can resolve the name to
                // and IP address, whereas other nodes cannot.
                //
                // store the ipaddr regardless of nodetype.  We don't know if this info will be
                // used to setup a session or send a datagram.  We do check NameTypeState
                // while setting up session, so no need to filter out NodeType info here.

                ASSERT(pAddrStruct->IpAddr == (ULONG)-1);
                pNameAddr->IpAddress = 0;
                pNameAddr->NameTypeState |= NAMETYPE_GROUP;
            }
            else
            {
                NameAddFlags |= NAME_ADD_INET_GROUP;
                pNameAddr->NameTypeState |= NAMETYPE_INET_GROUP;
            }
        }
        else
        {
            if (CountAddrs > 1)
            {
                tIPADDRESS              IpAddress;
                NBT_WORK_ITEM_CONTEXT   *pContext;

                // the name query response contains several ip addresses for
                // a multihomed host, so pick an address that matches one of
                // our subnet masks
                //
                // Do the old thing for datagram sends/name queries.
                //
#ifndef VXD
                if ((NbtConfig.TryAllAddr) &&
                    (pTracker) &&
                    (pTracker->Flags & SESSION_SETUP_FLAG))
                {
                    if (NT_SUCCESS(status = ChooseBestIpAddress(pAddrStruct,
                                                                Len,
                                                                pDeviceContext,
                                                                pTracker,
                                                                &IpAddress,
                                                                TRUE)))
                    {
                        //
                        // At this point, pTracker->IPList contains the sorted list of destination
                        // IP addresses. Submit this list to the lmhsvc service to ping each and
                        // return which is reachable.
                        //
                        pContext = (NBT_WORK_ITEM_CONTEXT *) NbtAllocMem (sizeof(NBT_WORK_ITEM_CONTEXT), NBT_TAG('H'));
                        if (pContext)
                        {
                            pContext->pTracker = NULL;              // no query tracker
                            pContext->pClientContext = pTracker;    // the client tracker
                            pContext->ClientCompletion = SessionSetupContinue;
                            pContext->pDeviceContext = pTracker->pDeviceContext;
                            StartLmHostTimer(pContext, TRUE);
                            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                            IF_DBG(NBT_DEBUG_NAMESRV)
                                KdPrint(("Nbt.UpdateNameState: Kicking off CheckAddr : %lx\n", pAddrStruct));

                            status = NbtProcessLmhSvcRequest(pContext, NBT_PING_IP_ADDRS);
                            CTESpinLock(&NbtConfig.JointLock,OldIrq1);

                            if (NT_SUCCESS(status))
                            {
                                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE); // PendingQ name
                                ASSERT (status == STATUS_PENDING);
                                return (status);    // shd be STATUS_PENDING
                            }

                            CTEFreeMem (pContext);
                            KdPrint(("Nbt.UpdateNameState: ERROR %lx -- NbtProcessLmhSvcRequest\n", status));
                        }
                        else
                        {
                           KdPrint(("Nbt.UpdateNameState: ERROR -- Couldn't alloc mem for pContext\n"));
                        }

                        //
                        // We failed above, but we still the addresses that were returned, so
                        // just pick up the first Ip address!
                        //
                        pNameAddr->IpAddress = IpAddress;
                        status = STATUS_SUCCESS;
                    }
                    else
                    {
                        KdPrint(("Nbt.UpdateNameState: ERROR -- ChooseBestIpAddress returned %lx\n", status));
                    }
                }
                else
#endif
                {

                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint(("Nbt:Choosing best IP addr...\n"));

                    if (NT_SUCCESS (status = ChooseBestIpAddress(pAddrStruct,Len,pDeviceContext,
                                                                 pTracker, &IpAddress, FALSE)))
                    {
                        pNameAddr->IpAddress = IpAddress;
                    }
#ifdef MULTIPLE_WINS
#ifdef VXD
                    //
                    // This is a hack to make VNBT work for multi-homed machines since
                    // currently we don't ping the addresses as in the case of NT above
                    // to find a good address
                    //
                    // Reset the ContextFlags so that we re-query the same server to make
                    // sure we try all the addresses
                    //
                    if (pTracker)
                    {
                        *pContextFlags = pTracker->ResolutionContextFlags;
                    }
#endif  // VXD
#endif  // MULTIPLE_WINS
                }
            }
            else
            {
                // it is already set to a unique address...since that is the default
                // when the name is queried originally.

                pNameAddr->IpAddress = ntohl(pAddrStruct->IpAddr);
            }
        }
    }

    if (NT_SUCCESS(status))
    {
        AddToHashTable (NbtConfig.pRemoteHashTbl,
                        pNameAddr->Name,
                        NbtConfig.pScope,
                        pNameAddr->IpAddress,
                        0,
                        pNameAddr,
                        NULL,
                        pDeviceContext,
                        NameAddFlags);
    }
    else
    {
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
    }

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
ULONG
MakeList(
    IN  tDEVICECONTEXT            *pDeviceContext,
    IN  ULONG                     CountAddrs,
    IN  tADDSTRUCT UNALIGNED      *pAddrStruct,
    IN  tIPADDRESS                *pAddrArray,
    IN  ULONG                     SizeOfAddrArray,
    IN  BOOLEAN                   IsSubnetMatch
    )
/*++

Routine Description:

    This routine gets a list of ip addresses that match the network number
    This can either be the subnet number or the network number depending
    on the boolean IsSubnetMatch

Arguments:


Return Value:

    none

--*/
{
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    tDEVICECONTEXT          *pTmpDevContext;
    ULONG                   MatchAddrs = 0;
    tADDSTRUCT UNALIGNED    *pAddrs;
    ULONG                   i;
    ULONG                   IpAddr, NetworkNumber, NetworkNumberInIpAddr;
    UCHAR                    IpAddrByte;

    pHead = &NbtConfig.DeviceContexts;
    pEntry = pHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pAddrs = pAddrStruct;

        pTmpDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
        //
        // DeviceContext is non-null, if a check has to be made on a specific
        // DeviceContext.  Otherwise it's null (i.e. check all DeviceContexts)
        //
        if (pDeviceContext)
        {
            if (pTmpDevContext != pDeviceContext)
            {
                continue;
            }
        }

        //
        // Check whether the Caller requested a Subnet or Network number match,
        // and if they are 0 for this Device, go to the next device
        //
        if (IsSubnetMatch)
        {
            NetworkNumber = pTmpDevContext->SubnetMask & pTmpDevContext->IpAddress;
        }
        else
        {
            NetworkNumber = pTmpDevContext->NetMask;
        }

        //
        // If the Subnet Mask or Network Mask is 0, then there is no use
        // proceeding further since the Device is probably not up
        //
        if (!NetworkNumber)
        {
            continue;
        }

        // extract the ipaddress from each address structure
        for ( i = 0 ; i < CountAddrs; i++ )
        {

            NetworkNumberInIpAddr = IpAddr = ntohl(pAddrs->IpAddr);

            if (IsSubnetMatch)
            {
                if (((pTmpDevContext->SubnetMask & IpAddr) == NetworkNumber) &&
                    (MatchAddrs < SizeOfAddrArray/sizeof(ULONG)))
                {
                    // put the ipaddress into a list incase multiple match
                    // and we want to select one randomly
                    //
                    pAddrArray[MatchAddrs++] = IpAddr;

                }
                pAddrs++;
            }
            else
            {
                IpAddrByte = ((PUCHAR)&IpAddr)[3];
                if ((IpAddrByte & 0x80) == 0)
                {
                    // class A address - one byte netid
                      NetworkNumberInIpAddr &= 0xFF000000;
                }
                else if ((IpAddrByte & 0xC0) ==0x80)
                {
                    // class B address - two byte netid
                    NetworkNumberInIpAddr &= 0xFFFF0000;
                }
                else if ((IpAddrByte & 0xE0) ==0xC0)
                {
                    // class C address - three byte netid
                    NetworkNumberInIpAddr &= 0xFFFFFF00;
                }

                if ((NetworkNumberInIpAddr == NetworkNumber) &&
                    (MatchAddrs < SizeOfAddrArray/sizeof(ULONG)))
                {
                    // put the ipaddress into a list incase multiple match
                    // and we want to select one randomly
                    //
                    pAddrArray[MatchAddrs++] = IpAddr;

                }
                pAddrs++;
            }
        }
    }

    return(MatchAddrs);
}
//----------------------------------------------------------------------------
NTSTATUS
ChooseBestIpAddress(
    IN  tADDSTRUCT UNALIGNED    *pAddrStruct,
    IN  ULONG                   Len,
    IN  tDEVICECONTEXT          *pDeviceContext,
    OUT tDGRAM_SEND_TRACKING    *pTracker,
    OUT tIPADDRESS              *pIpAddress,
    IN  BOOLEAN                 fReturnAddrList
    )
/*++

Routine Description:

    This routine gets a list of ip addresses and attempts to pick one of them
    as the best address.  This occurs when WINS returns a list of addresses
    for a multihomed host and we want want the one that is on a subnet
    corresponding to one of the network cards.  Failing to match on
    subnet mask, results in a random selection from the addresses.

Arguments:


Return Value:

    none

--*/
{

    ULONG           CountAddrs, NextAddr, MatchAddrs = 0;
    ULONG           i, j, Random;
    tIPADDRESS      MatchAddrArray[60];
    tADDSTRUCT      temp;
    CTESystemTime   TimeValue;

    // one or more addresses were returned,
    // so pick one that is best
    //
    CountAddrs = Len / tADDSTRUCT_SIZE;

    if (CountAddrs*tADDSTRUCT_SIZE == Len)
    {
        //
        // Randomize all of the addresses!
        //
        for (i=CountAddrs-1; i>0; i--)
        {
            CTEQuerySystemTime(TimeValue);
            Random = RandomizeFromTime(TimeValue, (i+1));
            ASSERT (Random < CountAddrs);

            if (Random != i)
            {
                //
                // Exchange the address at Random with i!
                //
                temp = pAddrStruct[Random];
                pAddrStruct[Random] = pAddrStruct[i];
                pAddrStruct[i] = temp;
            }
        }

        //
        // First check if any addresses are on the same subnet as this
        // devicecontext.
        //
        MatchAddrs = MakeList(pDeviceContext,
                              CountAddrs,
                              pAddrStruct,
                              MatchAddrArray,
                              sizeof(MatchAddrArray),
                              TRUE);

        //
        // if none of the ipaddrs is on the same subnet as this DeviceContext,
        // try other DeviceContexts
        //
        if (!MatchAddrs)
        {
            MatchAddrs = MakeList(NULL,
                                  CountAddrs,
                                  pAddrStruct,
                                  MatchAddrArray,
                                  sizeof(MatchAddrArray),
                                  TRUE);
        }

        // if none of the addresses match the subnet address of any of the
        // DeviceContexts, then go through the same checks looking for matches
        // that have the same network number as the Device this name was resolved on.
        // Bug # 212432
        //
        if (!MatchAddrs)
        {
            MatchAddrs = MakeList(pDeviceContext,
                                  CountAddrs,
                                  pAddrStruct,
                                  MatchAddrArray,
                                  sizeof(MatchAddrArray),
                                  FALSE);
        }

        //
        // if none of the addresses match the subnet address of any of the
        // DeviceContexts, then go through the same check looking for matches
        // that have the same network number for any connected device.
        //
        if (!MatchAddrs)
        {
            MatchAddrs = MakeList(NULL,
                                  CountAddrs,
                                  pAddrStruct,
                                  MatchAddrArray,
                                  sizeof(MatchAddrArray),
                                  FALSE);
        }
    }
    else
    {
        // the pdu length is not an even multiple of the tADDSTRUCT data
        // structure
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // We had already randomized the list earlier, so now just pick up
    // the first address for the IpAddress value!
    //
    if (MatchAddrs)
    {
        *pIpAddress = MatchAddrArray[0];
    }
    else // No match
    {
        *pIpAddress = htonl(pAddrStruct[0].IpAddr);
    }

    //
    // See if the Caller requested only 1 IP address
    //
    if (!fReturnAddrList)
    {
        return (STATUS_SUCCESS);
    }

    //
    // Move all addresses which matched any of the Subnets or Network numbers
    // to the top of the list (if no matches, then we will copy the whole list as is)
    //
    if (MatchAddrs)
    {
        //
        // Sort the IP addr list on basis of best IP addr. in MatchAddrArray
        //
        // NOTE: this is not a strictly sorted list (the actual sort might be too expensive),
        // instead we take all the addresses that match the subnet mask (say) and
        // clump the remaining ones in the same group. This way we ensure that whatever
        // we chose as the best address is still given preference as compared to the
        // other addresses.
        //

        //
        // NextAddr is the index of the next Address in AddrStruct which can be switched
        //
        NextAddr = 0;
        for (i=0; i<MatchAddrs; i++)   // for each address which matched the Net/Subnet masks
        {
            //
            // SWAP(pAddrStruct[NextAddr], pAddrStruct[Index(MatchAddrArray[i])]);
            //
            for (j=NextAddr; j<CountAddrs; j++)
            {
                if (pAddrStruct[j].IpAddr == (ULONG)ntohl(MatchAddrArray[i]))
                {
                    if (j != NextAddr)      // Swap if indices are different
                    {
                        IF_DBG(NBT_DEBUG_NAMESRV)
                            KdPrint(("Nbt.ChooseBestIpAddress: Swap Address[%d]=<%x> <=> Address[%d]=<%x>\n",
                                NextAddr, pAddrStruct[NextAddr].IpAddr, j, pAddrStruct[j].IpAddr));

                        temp = pAddrStruct[NextAddr];
                        pAddrStruct[NextAddr] = pAddrStruct[j];
                        pAddrStruct[j] = temp;
                    }
                    NextAddr++;             // Fill in next Address
                    break;
                }
            }

            if (NextAddr >= CountAddrs)
            {
                break;
            }
        }
    }

    //
    // We will have to return the list of IP addresses in the
    // Tracker's IpList field, so ensure that pTracker is valid
    //
    if (!pTracker)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Now copy all the addresses into the Tracker's IP List
    //
    pTracker->IpList = NbtAllocMem(sizeof(ULONG)*(1+CountAddrs),NBT_TAG('8'));
    if (!pTracker->IpList)
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    for (j=0; j<CountAddrs; j++)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.ChooseBestIpAddress: pAddrStruct[%d/%d]: %lx\n", (j+1), CountAddrs, pAddrStruct[j].IpAddr));
        pTracker->IpList[j] = pAddrStruct[j].IpAddr;
    }
    pTracker->IpList[CountAddrs] = 0;
    pTracker->NumAddrs = CountAddrs;

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

#ifdef MULTIPLE_WINS
BOOLEAN
IsNameServerForDevice(
    IN  ULONG               SrcAddress,
    IN  tDEVICECONTEXT      *pDevContext
    )
/*++

Routine Description:

    This function checks the src address against this adapter's name server
    addresses to see if it is a name server.

Arguments:


Return Value:

    BOOLEAN - TRUE or FALSE

--*/
{
    int             i;

    if ((pDevContext->lNameServerAddress == SrcAddress) ||
        (pDevContext->lBackupServer == SrcAddress))
    {
        return(TRUE);
    }

    for (i=0; i < pDevContext->lNumOtherServers; i++)
    {
        if (pDevContext->lOtherServers[i] == SrcAddress)
        {
            return (TRUE);
        }
    }

    return (FALSE);
}
//----------------------------------------------------------------------------
#endif


BOOLEAN
SrcIsNameServer(
    IN  ULONG                SrcAddress,
    IN  USHORT               SrcPort
    )
/*++

Routine Description:

    This function checks the src address against all adapters' name server
    address to see if it came from a name server.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_UNSUCCESSFUL


--*/
{
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;
    tDEVICECONTEXT  *pDevContext;

    pHead = &NbtConfig.DeviceContexts;
    pEntry = pHead->Flink;

    if (SrcPort == NbtConfig.NameServerPort)
    {
        while (pEntry != pHead)
        {
            pDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);

#ifdef MULTIPLE_WINS
            if (IsNameServerForDevice(SrcAddress, pDevContext))
#else
            if ((pDevContext->lNameServerAddress == SrcAddress) ||
                (pDevContext->lBackupServer == SrcAddress))
#endif
            {
                return(TRUE);
            }
            pEntry = pEntry->Flink;
        }
    }
#ifndef VXD
    //
    // If wins is on this machine the above SrcIsNameServer
    // check may not be sufficient since this machine is
    // the name server and that check checks the nameservers
    // used for name queries.  If WINS is on this machine it
    // could have sent from any local adapter's IP address
    //
    if (pWinsInfo)
    {
        return(SrcIsUs(SrcAddress));
    }
#endif
    return(FALSE);

}


//----------------------------------------------------------------------------
BOOLEAN
SrcIsUs(
    IN  ULONG                SrcAddress
    )
/*++

Routine Description:

    This function checks the src address against all adapters'Ip addresses
    address to see if it came from this node.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_UNSUCCESSFUL


--*/
{
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;
    tDEVICECONTEXT  *pDevContext;

    pHead = &NbtConfig.DeviceContexts;
    pEntry = pHead->Flink;

    while (pEntry != pHead)
    {
        pDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);

        if (pDevContext->IpAddress == SrcAddress)
        {
            return(TRUE);
        }
        pEntry = pEntry->Flink;
    }

    return(FALSE);

}
//----------------------------------------------------------------------------
VOID
SwitchToBackup(
    IN  tDEVICECONTEXT  *pDeviceContext
    )
/*++

Routine Description:

    This function switches the primary and backup name server addresses.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_UNSUCCESSFUL


--*/
{
    ULONG   SaveAddr;

    //
    // Bug: 30511: Dont switch servers if no backup.
    //
    if (pDeviceContext->lBackupServer == LOOP_BACK) {
        IF_DBG(NBT_DEBUG_REFRESH)
        KdPrint(("Nbt:Will not Switch to backup name server: devctx: %X, refreshtobackup=%X\n",
                pDeviceContext, pDeviceContext->RefreshToBackup));
        return;
    }

    SaveAddr = pDeviceContext->lNameServerAddress;
    pDeviceContext->lNameServerAddress = pDeviceContext->lBackupServer;
    pDeviceContext->lBackupServer = SaveAddr;

    IF_DBG(NBT_DEBUG_REFRESH)
    KdPrint(("Nbt:Switching to backup name server: devctx: %X, refreshtobackup=%X\n",
            pDeviceContext, pDeviceContext->RefreshToBackup));

    // keep track if we are on the backup or not.
    pDeviceContext->RefreshToBackup = ~pDeviceContext->RefreshToBackup;
    pDeviceContext->SwitchedToBackup = ~pDeviceContext->SwitchedToBackup;
}

//----------------------------------------------------------------------------
NTSTATUS
GetNbFlags(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNameSize,
    IN  LONG                lNumBytes,
    OUT USHORT              *pRegType
    )
/*++

Routine Description:

    This function finds the Nbflags field in certain pdu types and returns it.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_REMOTE_NOT_LISTENING

Called By: RegResponseFromNet

--*/
{
    LONG    DnsLabelLength, Offset;

    //
    // Bug#s 125648, 125649
    // The Data is packed in the form:
    // tNameHdr --> TransactId          ==> Offset 0, Length = 2 bytes
    //                  :
    //          --> NameRR.NetbiosName  ==> Offset=13, Length = lNameSize
    //          --> tGENERALRR          ==> Offset=13+lNameSize, Length >= 22bytes
    //
    // We need to verify that the NameHdr contains the minimum Buffer space required
    // to hold the entire PDU data
    // 
    if (lNumBytes < (FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize + NBT_MINIMUM_RR_LENGTH))
    {
        ASSERT (0);
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // if the question name is not a pointer to the first name then we
    // must find the end of that name and adjust it so when added to
    // to lNameSize we endup at NB_FLAGS
    //
    if ((pNameHdr->NameRR.NetBiosName[lNameSize+PTR_OFFSET] & PTR_SIGNATURE) != PTR_SIGNATURE)
    {
        // add one to include the null on the end of the string + the NB, IN TTL,
        // and length fields( another 10 bytes NO_PTR_OFFSET) + PTR_OFFSET(4).
        //
        Offset = FIELD_OFFSET(tNAMEHDR,NameRR.NetBiosName) + lNameSize + PTR_OFFSET;
        if (STATUS_SUCCESS != (strnlen ((PUCHAR) &pNameHdr->NameRR.NetBiosName [lNameSize+PTR_OFFSET],
                                        lNumBytes - (Offset+16),    // +16 bytes to end of GeneralRR
                                        &DnsLabelLength)))
        {
            ASSERT (0);
            return (STATUS_UNSUCCESSFUL);
        }
        // add one to include the null on the end of the string
        DnsLabelLength++;
    }
    else
    {
        DnsLabelLength = 2;
    }

    Offset = lNameSize+PTR_OFFSET+DnsLabelLength+NO_PTR_OFFSET;
    *pRegType = ntohs((USHORT) pNameHdr->NameRR.NetBiosName[Offset]);
    return (STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
FindOnPendingList(
    IN  PUCHAR                  pName,
    IN  tNAMEHDR UNALIGNED      *pNameHdr,
    IN  BOOLEAN                 DontCheckTransactionId,
    IN  ULONG                   BytesToCompare,
    OUT tNAMEADDR               **ppNameAddr

    )
/*++

Routine Description:

    This function is called to look for a name query request on the pending
    list.  It searches the list linearly to look for the name.

    The Joint Lock is held when calling this routine.


Arguments:


Return Value:


--*/
{
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;
    tNAMEADDR       *pNameAddr;
    tTIMERQENTRY    *pTimer;

    pHead = pEntry = &NbtConfig.PendingNameQueries;

    while ((pEntry = pEntry->Flink) != pHead)
    {
        pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);

        //
        // there could be multiple entries with the same name so check the
        // transaction id too
        //
        if (DontCheckTransactionId ||
            ((pTimer = pNameAddr->pTimer) &&
            (((tDGRAM_SEND_TRACKING *)pTimer->Context)->TransactionId == pNameHdr->TransactId))
                             &&
            (CTEMemEqu(pNameAddr->Name,pName,BytesToCompare)))
        {
            *ppNameAddr = pNameAddr;
            return(STATUS_SUCCESS);
        }
    }


    return(STATUS_UNSUCCESSFUL);
}



#if DBG
//----------------------------------------------------------------------------
VOID
PrintHexString(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  ULONG                lNumBytes
    )
/*++

Routine Description:

    This function is called to determine whether the name packet we heard on
    the net has the same address as the one in the remote hash table.
    If it has the same address or if it does not have any address, we return
    SUCCESS, else we return NOT_LISTENING.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_REMOTE_NOT_LISTENING

Called By: RegResponseFromNet

--*/
{
    ULONG   i,Count=0;
    PUCHAR  pHdr=(PUCHAR)pNameHdr;

    for (i=0;i<lNumBytes ;i++ )
    {
        KdPrint(("%2.2X ",*pHdr));
        pHdr++;
        if (Count >= 16)
        {
            Count = 0;
            KdPrint(("\n"));
        }
        else
            Count++;
    }
    KdPrint(("\n"));
}
#endif

#ifdef PROXY_NODE
//----------------------------------------------------------------------------
NTSTATUS
ChkIfValidRsp(
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNameSize,
    IN  tNAMEADDR          *pNameAddr
    )
/*++

Routine Description:

    This function is called to determine whether the name packet we heard on
    the net has the same address as the one in the remote hash table.
    If it has the same address or if it does not have any address, we return
    SUCCESS, else we return NOT_LISTENING.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS or STATUS_REMOTE_NOT_LISTENING

Called By: RegResponseFromNet

--*/
{
         ULONG IpAdd;

        IpAdd = ntohl(
        pNameHdr->NameRR.NetBiosName[lNameSize+IPADDRESS_OFFSET]
             );

        //
        // If the IP address in the packet received is same as the one
        // in the table we return success, else we are not interested
        // in the packet (we want to just drop the packet)
        //
      if (
             (IpAdd == pNameAddr->IpAddress)
         )
      {
            return(STATUS_SUCCESS);
      }
      else
      {
            return(STATUS_REMOTE_NOT_LISTENING);
      }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\hashtbl.c ===
//
//
//  hashtbl.c
//
//  This file contains the name code to implement the local and remote
//  hash tables used to store local and remote names to IP addresses
//  The hash table should not use more than 256 buckets since the hash
//  index is only calculated to one byte!

#include "precomp.h"


VOID DestroyHashTable(IN PHASHTABLE pHashTable);

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(INIT, CreateHashTable)
#pragma CTEMakePageable(PAGE, DestroyHashTables)
#pragma CTEMakePageable(PAGE, DestroyHashTable)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
CreateHashTable(
    tHASHTABLE          **pHashTable,
    LONG                lNumBuckets,
    enum eNbtLocation   LocalRemote
    )
/*++

Routine Description:

    This routine creates a hash table uTableSize long.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    ULONG       uSize;
    LONG        i;
    NTSTATUS    status;

    CTEPagedCode();

    uSize = (lNumBuckets-1)*sizeof(LIST_ENTRY) + sizeof(tHASHTABLE);

    *pHashTable = (tHASHTABLE *) NbtAllocMem (uSize, NBT_TAG2('01'));

    if (*pHashTable)
    {
        // initialize all of the buckets to have null chains off of them
        for (i=0;i < lNumBuckets ;i++ )
        {
            InitializeListHead(&(*pHashTable)->Bucket[i]);
        }

        (*pHashTable)->LocalRemote = LocalRemote;
        (*pHashTable)->lNumBuckets = lNumBuckets;
        status = STATUS_SUCCESS;
    }
    else
    {
        IF_DBG(NBT_DEBUG_HASHTBL)
            KdPrint(("Nbt.CreateHashTable: Unable to create hash table\n"));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}


#ifdef _PNP_POWER_
VOID
DestroyHashTable(
    IN PHASHTABLE pHashTable
    )
{
    LONG            i, j;
    tNAMEADDR       *pNameAddr;
    LIST_ENTRY      *pEntry;

    CTEPagedCode();

    if (pHashTable == NULL) {
        return;
    }

    /*
     * Go through all the buckets to see if there are any names left
     */
    for (i = 0; i < pHashTable->lNumBuckets; i++) {
        while (!IsListEmpty(&(pHashTable->Bucket[i]))) {
            pEntry = RemoveHeadList(&(pHashTable->Bucket[i]));
            pNameAddr = CONTAINING_RECORD(pEntry, tNAMEADDR, Linkage);

            IF_DBG(NBT_DEBUG_HASHTBL)
                KdPrint (("netbt!DestroyHashTable:  WARNING! Freeing Name: <%16.16s:%x>\n",
                    pNameAddr->Name, pNameAddr->Name[15]));

            /*
             * Notify deferencer not to do RemoveListEntry again becaseu we already do it above.
             */
            if (pNameAddr->Verify == REMOTE_NAME && (pNameAddr->NameTypeState & PRELOADED)) {
                ASSERT(pNameAddr->RefCount == 2);
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_PRELOADED, FALSE);
            }
            ASSERT(pNameAddr->RefCount == 1);
            pNameAddr->Linkage.Flink = pNameAddr->Linkage.Blink = NULL;
            NBT_DEREFERENCE_NAMEADDR(pNameAddr,((pNameAddr->Verify==LOCAL_NAME)?REF_NAME_LOCAL:REF_NAME_REMOTE),FALSE);
        }
    }
    CTEMemFree(pHashTable);
}

//----------------------------------------------------------------------------
VOID
DestroyHashTables(
    )
/*++

Routine Description:

    This routine destroys a hash table and frees the entries in NumBuckets
    It Must be called with the NbtConfig lock held!

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{

    CTEPagedCode();
    IF_DBG(NBT_DEBUG_HASHTBL)
        KdPrint (("netbt!DestroyHashTables: destroying remote hash table ..."));
    DestroyHashTable(NbtConfig.pRemoteHashTbl);
    NbtConfig.pRemoteHashTbl = NULL;

    IF_DBG(NBT_DEBUG_HASHTBL)
        KdPrint (("\nnetbt!DestroyHashTables: destroying local hash table ..."));
    DestroyHashTable(NbtConfig.pLocalHashTbl);
    NbtConfig.pLocalHashTbl = NULL;
    IF_DBG(NBT_DEBUG_HASHTBL)
        KdPrint (("\n"));
}
#endif  // _PNP_POWER_


//----------------------------------------------------------------------------
NTSTATUS
NbtUpdateRemoteName(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN tNAMEADDR        *pNameAddrNew,
    IN tNAMEADDR        *pNameAddrDiscard,
    IN USHORT           NameAddFlags
    )
{
    tIPADDRESS      IpAddress;
    tIPADDRESS      *pLmhSvcGroupList = NULL;
    tIPADDRESS      *pOrigIpAddrs = NULL;
    ULONG           AdapterIndex = 0;  // by default
    ULONG           i;

    ASSERT (pNameAddrNew);
    //
    // See if we need to grow the IP addrs cache for the cached name
    //
    if (pNameAddrNew->RemoteCacheLen < NbtConfig.RemoteCacheLen) {
        tADDRESS_ENTRY  *pRemoteCache;
        pRemoteCache = (tADDRESS_ENTRY *)NbtAllocMem(NbtConfig.RemoteCacheLen*sizeof(tADDRESS_ENTRY),NBT_TAG2('02'));
        if (pRemoteCache) {
            CTEZeroMemory(pRemoteCache, NbtConfig.RemoteCacheLen*sizeof(tADDRESS_ENTRY));

            /*
             * Copy data from and free the previous cache (if any)
             */
            if (pNameAddrNew->pRemoteIpAddrs) {
                CTEMemCopy (pRemoteCache, pNameAddrNew->pRemoteIpAddrs,
                        sizeof(tADDRESS_ENTRY) * pNameAddrNew->RemoteCacheLen);

                CTEFreeMem (pNameAddrNew->pRemoteIpAddrs)
            }

            pNameAddrNew->pRemoteIpAddrs = pRemoteCache;
            pNameAddrNew->RemoteCacheLen = NbtConfig.RemoteCacheLen;
        } else {
            KdPrint(("Nbt.NbtUpdateRemoteName:  FAILed to expand Cache entry!\n"));
        }
    }

    //
    // If the new entry being added replaces an entry which was
    // either pre-loaded or set by a client, and the new entry itself
    // does not have that flag set, then ignore this update.
    //
    ASSERT (NAME_RESOLVED_BY_DNS > NAME_RESOLVED_BY_LMH_P);     // For the check below to succeed!
    if (((pNameAddrNew->NameAddFlags & NAME_RESOLVED_BY_CLIENT) &&
         !(NameAddFlags & NAME_RESOLVED_BY_CLIENT)) ||
        ((pNameAddrNew->NameAddFlags & NAME_RESOLVED_BY_LMH_P) > 
         (NameAddFlags & (NAME_RESOLVED_BY_LMH_P | NAME_RESOLVED_BY_DNS))))
    {
        return (STATUS_UNSUCCESSFUL);
    }

    if (pNameAddrDiscard)
    {
        IpAddress = pNameAddrDiscard->IpAddress;
        pLmhSvcGroupList = pNameAddrDiscard->pLmhSvcGroupList;
        pNameAddrDiscard->pLmhSvcGroupList = NULL;
        pNameAddrNew->TimeOutCount  = NbtConfig.RemoteTimeoutCount; // Reset it since we are updating it!
        pOrigIpAddrs = pNameAddrDiscard->pIpAddrsList;
    }
    else
    {
        IpAddress = pNameAddrNew->IpAddress;
        pLmhSvcGroupList = pNameAddrNew->pLmhSvcGroupList;
        pNameAddrNew->pLmhSvcGroupList = NULL;
    }

    if ((NameAddFlags & (NAME_RESOLVED_BY_DNS | NAME_RESOLVED_BY_CLIENT | NAME_RESOLVED_BY_IP)) &&
        (pNameAddrNew->RemoteCacheLen))
    {
        ASSERT (!pLmhSvcGroupList);
        pNameAddrNew->pRemoteIpAddrs[0].IpAddress = IpAddress;

        if ((pNameAddrNew->NameAddFlags & NAME_RESOLVED_BY_LMH_P) &&
            (NameAddFlags & NAME_RESOLVED_BY_DNS))
        {
            //
            // If the name was resolved by DNS, then don't overwrite the
            // name entry if it was pre-loaded below
            //
            pNameAddrNew->NameAddFlags |= NameAddFlags;
            return (STATUS_SUCCESS);
        }
    }

    if ((pDeviceContext) &&
        (!IsDeviceNetbiosless(pDeviceContext)) &&
        (pDeviceContext->AdapterNumber < pNameAddrNew->RemoteCacheLen))
    {
        AdapterIndex = pDeviceContext->AdapterNumber;
        pNameAddrNew->AdapterMask |= pDeviceContext->AdapterMask;

        if (IpAddress)
        {
            pNameAddrNew->IpAddress = IpAddress;    // in case we are copying from pNameAddrDiscard
            pNameAddrNew->pRemoteIpAddrs[AdapterIndex].IpAddress = IpAddress;  // new addr
        }


        //
        // Now see if we need to update the Original IP addresses list!
        //
        if (pOrigIpAddrs)
        {
            // pOrigIpAddrs could only have been set earlier if it was obtained from pNameAddrDiscard!
            pNameAddrDiscard->pIpAddrsList = NULL;
        }
        else if (pOrigIpAddrs = pNameAddrNew->pIpAddrsList)
        {
            pNameAddrNew->pIpAddrsList = NULL;
        }

        if (pOrigIpAddrs)
        {
            if (pNameAddrNew->pRemoteIpAddrs[AdapterIndex].pOrigIpAddrs)
            {
                CTEFreeMem (pNameAddrNew->pRemoteIpAddrs[AdapterIndex].pOrigIpAddrs);
            }
            pNameAddrNew->pRemoteIpAddrs[AdapterIndex].pOrigIpAddrs = pOrigIpAddrs;
        }
    }

    if (pLmhSvcGroupList)
    {
        ASSERT(NameAddFlags == (NAME_RESOLVED_BY_LMH_P|NAME_ADD_INET_GROUP));
        if (pNameAddrNew->pLmhSvcGroupList) {
            CTEFreeMem (pNameAddrNew->pLmhSvcGroupList);
        }

        pNameAddrNew->pLmhSvcGroupList = pLmhSvcGroupList;
    }

    pNameAddrNew->NameAddFlags |= NameAddFlags;

    return (STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
LockAndAddToHashTable(
    IN  tHASHTABLE          *pHashTable,
    IN  PCHAR               pName,
    IN  PCHAR               pScope,
    IN  tIPADDRESS          IpAddress,
    IN  enum eNbtAddrType    NameType,
    IN  tNAMEADDR           *pNameAddr,
    OUT tNAMEADDR           **ppNameAddress,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT              NameAddFlags
    )
{
    NTSTATUS        status;
    CTELockHandle   OldIrq;

    CTESpinLock (&NbtConfig.JointLock, OldIrq);

    status = AddToHashTable(pHashTable,
                            pName,
                            pScope,
                            IpAddress,
                            NameType,
                            pNameAddr,
                            ppNameAddress,
                            pDeviceContext,
                            NameAddFlags);

    CTESpinFree (&NbtConfig.JointLock, OldIrq);
    return (status);
}


//----------------------------------------------------------------------------
NTSTATUS
AddToHashTable(
    IN  tHASHTABLE          *pHashTable,
    IN  PCHAR               pName,
    IN  PCHAR               pScope,
    IN  tIPADDRESS          IpAddress,
    IN  enum eNbtAddrType    NameType,
    IN  tNAMEADDR           *pNameAddr,
    OUT tNAMEADDR           **ppNameAddress,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  USHORT              NameAddFlags
    )
/*++

Routine Description:

    This routine adds a name to IPaddress to the hash table
    Called with the spin lock HELD.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tNAMEADDR           *pNameAddress;
    tNAMEADDR           *pScopeAddr;
    NTSTATUS            status;
    ULONG               iIndex;
    CTELockHandle       OldIrq;
    ULONG               i, OldRemoteCacheLen;
    tNAMEADDR           *pNameAddrFound;
    tADDRESS_ENTRY      *pRemoteCache = NULL;
    BOOLEAN             fNameIsAlreadyInCache;
    tIPADDRESS          OldIpAddress;

    if (pNameAddr)
    {
        ASSERT ((pNameAddr->Verify == LOCAL_NAME) || (pNameAddr->Verify == REMOTE_NAME));
    }

    fNameIsAlreadyInCache = (STATUS_SUCCESS == FindInHashTable(pHashTable,pName,pScope,&pNameAddrFound));

    if ((fNameIsAlreadyInCache) &&
        (pNameAddrFound->Verify == REMOTE_NAME) &&
        !(pNameAddrFound->NameTypeState & STATE_RELEASED))
    {
        OldIpAddress = pNameAddrFound->IpAddress;
        pNameAddrFound->IpAddress = IpAddress;

        if (!(NameAddFlags & NAME_ADD_IF_NOT_FOUND_ONLY) &&
            ((pNameAddr) ||
             !(pNameAddrFound->NameAddFlags & NAME_ADD_INET_GROUP)))
        {
            //
            // We have a valid existing name, so just update it!
            //
            status = NbtUpdateRemoteName(pDeviceContext, pNameAddrFound, pNameAddr, NameAddFlags);
            if (!NT_SUCCESS (status))
            {
                //
                // We Failed most problably because we were not allowed to
                // over-write or modify the current entry for some reason.
                // So, reset the old IpAddress
                //
                pNameAddrFound->IpAddress = OldIpAddress;
            }
        }

        if (pNameAddr)
        {
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
        }
        else
        {
            ASSERT (!(NameAddFlags & NAME_ADD_INET_GROUP));
        }

        if (ppNameAddress)
        {
            *ppNameAddress = pNameAddrFound;
        }

        // found it in the table so we're done - return pending to
        // differentiate from the name added case. Pending passes the
        // NT_SUCCESS() test as well as Success does.
        //
        return (STATUS_PENDING);
    }

    // first hash the name to an index
    // take the lower nibble of the first 2 characters.. mod table size
    iIndex = ((pName[0] & 0x0F) << 4) + (pName[1] & 0x0F);
    iIndex = iIndex % pHashTable->lNumBuckets;

    CTESpinLock(&NbtConfig,OldIrq);

    if (!pNameAddr)
    {
        //
        // Allocate memory for another hash table entry
        //
        pNameAddress = (tNAMEADDR *)NbtAllocMem(sizeof(tNAMEADDR),NBT_TAG('0'));
        if ((pNameAddress) &&
            (pHashTable->LocalRemote == NBT_REMOTE) &&
            (NbtConfig.RemoteCacheLen) &&
            (!(pRemoteCache = (tADDRESS_ENTRY *)
                                NbtAllocMem(NbtConfig.RemoteCacheLen*sizeof(tADDRESS_ENTRY),NBT_TAG2('03')))))
        {
            CTEMemFree (pNameAddress);
            pNameAddress = NULL;
        }

        if (!pNameAddress)
        {
            CTESpinFree(&NbtConfig,OldIrq);
            KdPrint (("AddToHashTable: ERROR - INSUFFICIENT_RESOURCES\n"));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        CTEZeroMemory(pNameAddress,sizeof(tNAMEADDR));
        pNameAddress->IpAddress     = IpAddress;
        pNameAddress->NameTypeState = (NameType == NBT_UNIQUE) ? NAMETYPE_UNIQUE : NAMETYPE_GROUP;
        pNameAddress->NameTypeState |= STATE_RESOLVED;
        CTEMemCopy (pNameAddress->Name, pName, (ULONG)NETBIOS_NAME_SIZE);   // fill in the name

        if ((pHashTable->LocalRemote == NBT_LOCAL)  ||
            (pHashTable->LocalRemote == NBT_REMOTE_ALLOC_MEM))
        {
            pNameAddress->Verify = LOCAL_NAME;
            NBT_REFERENCE_NAMEADDR (pNameAddress, REF_NAME_LOCAL);
        }
        else
        {
            ASSERT (!(NameAddFlags & NAME_ADD_INET_GROUP));
            pNameAddress->Verify = REMOTE_NAME;
            CTEZeroMemory(pRemoteCache, NbtConfig.RemoteCacheLen*sizeof(tADDRESS_ENTRY));
            pNameAddress->pRemoteIpAddrs = pRemoteCache;
            pNameAddress->RemoteCacheLen = NbtConfig.RemoteCacheLen;
            NBT_REFERENCE_NAMEADDR (pNameAddress, REF_NAME_REMOTE);

            NbtUpdateRemoteName(pDeviceContext, pNameAddress, NULL, NameAddFlags);
        }


    }
    else
    {
        //
        // See if we need to grow the IP addrs cache for remote names
        //
        ASSERT (!pNameAddr->pRemoteIpAddrs);
        if (pNameAddr->Verify == REMOTE_NAME)
        {
            NbtUpdateRemoteName(pDeviceContext, pNameAddr, NULL, NameAddFlags);
        }
        pNameAddress = pNameAddr;
    }

    pNameAddress->pTimer        = NULL;
    pNameAddress->TimeOutCount  = NbtConfig.RemoteTimeoutCount;

    // put on the head of the list in case the same name is in the table
    // twice (where the second one is waiting for its reference count to
    // go to zero, and will ultimately be removed, we want to find the new
    // name on any query of the table
    //
    InsertHeadList(&pHashTable->Bucket[iIndex],&pNameAddress->Linkage);
    if (pHashTable->LocalRemote == NBT_REMOTE) {
        NbtConfig.NumNameCached++;
    }


    // check for a scope too ( on non-local names only )
    if ((pHashTable->LocalRemote != NBT_LOCAL) && (*pScope))
    {
        // we must have a scope
        // see if the scope is already in the hash table and add if necessary
        //
        status = FindInHashTable(pHashTable, pScope, NULL, &pScopeAddr);
        if (!NT_SUCCESS(status))
        {
            PUCHAR  Scope;
            status = STATUS_SUCCESS;

            // *TODO* - this check will not adequately protect against
            // bad scopes passed in - i.e. we may run off into memory
            // and get an access violation...however converttoascii should
            // do the protection.  For local names the scope should be
            // ok since NBT read it from the registry and checked it first
            //
            iIndex = 0;
            Scope = pScope;
            while (*Scope && (iIndex <= 255))
            {
                iIndex++;
                Scope++;
            }

            // the whole length must be 255 or less, so the scope can only be
            // 255-16...
            if (iIndex > (255 - NETBIOS_NAME_SIZE))
            {
                RemoveEntryList(&pNameAddress->Linkage);
                if (pNameAddress->pRemoteIpAddrs)
                {
                    CTEMemFree ((PVOID)pNameAddress->pRemoteIpAddrs);
                }

                pNameAddress->Verify += 10;
                CTEMemFree(pNameAddress);

                CTESpinFree(&NbtConfig,OldIrq);
                return(STATUS_UNSUCCESSFUL);
            }

            iIndex++;   // to copy the null

            //
            // the scope is a variable length string, so allocate enough
            // memory for the tNameAddr structure based on this string length
            //
            pScopeAddr = (tNAMEADDR *)NbtAllocMem((USHORT)(sizeof(tNAMEADDR)
                                                        + iIndex
                                                        - NETBIOS_NAME_SIZE),NBT_TAG('1'));
            if ( !pScopeAddr )
            {
                RemoveEntryList(&pNameAddress->Linkage);
                if (pNameAddress->pRemoteIpAddrs)
                {
                    CTEMemFree ((PVOID)pNameAddress->pRemoteIpAddrs);
                }

                pNameAddress->Verify += 10;
                CTEMemFree (pNameAddress);

                CTESpinFree(&NbtConfig,OldIrq);
                return STATUS_INSUFFICIENT_RESOURCES ;
            }

            CTEZeroMemory(pScopeAddr, (sizeof(tNAMEADDR)+iIndex-NETBIOS_NAME_SIZE));

            // copy the scope to the name field including the Null at the end.
            // to the end of the name
            CTEMemCopy(pScopeAddr->Name,pScope,iIndex);

            // mark the entry as containing a scope name for cleanup later
            pScopeAddr->NameTypeState = NAMETYPE_SCOPE | STATE_RESOLVED;

            // keep the size of the name in the context value for easier name
            // comparisons in FindInHashTable

            pScopeAddr->Verify = REMOTE_NAME;
            NBT_REFERENCE_NAMEADDR (pScopeAddr, REF_NAME_REMOTE);
            NBT_REFERENCE_NAMEADDR (pScopeAddr, REF_NAME_SCOPE);
            pScopeAddr->ulScopeLength = iIndex;
            pNameAddress->pScope = pScopeAddr;

            // add the scope record to the hash table
            iIndex = ((pScopeAddr->Name[0] & 0x0F) << 4) + (pScopeAddr->Name[1] & 0x0F);
            iIndex = iIndex % pHashTable->lNumBuckets;
            InsertTailList(&pHashTable->Bucket[iIndex],&pScopeAddr->Linkage);
            if (pHashTable->LocalRemote == NBT_REMOTE) {
                NbtConfig.NumNameCached++;
            }

        }
        else
        {
            // the scope is already in the hash table so link the name to the
            // scope
            pNameAddress->pScope = pScopeAddr;
        }
    }
    else
    {
        pNameAddress->pScope = NULL; // no scope
    }

    // return the pointer to the hash table block
    if (ppNameAddress)
    {
        // return the pointer to the hash table block
        *ppNameAddress = pNameAddress;
    }
    CTESpinFree(&NbtConfig,OldIrq);
    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
tNAMEADDR *
LockAndFindName(
    enum eNbtLocation   Location,
    PCHAR               pName,
    PCHAR               pScope,
    ULONG               *pRetNameType
    )
{
    tNAMEADDR       *pNameAddr;
    CTELockHandle   OldIrq;

    CTESpinLock (&NbtConfig.JointLock, OldIrq);

    pNameAddr = FindName(Location,
                         pName,
                         pScope,
                         pRetNameType);

    CTESpinFree (&NbtConfig.JointLock, OldIrq);
    return (pNameAddr);
}


//----------------------------------------------------------------------------
tNAMEADDR *
FindName(
    enum eNbtLocation   Location,
    PCHAR               pName,
    PCHAR               pScope,
    ULONG               *pRetNameType
    )
/*++

Routine Description:

    This routine searches the name table to find a name.  The table searched
    depends on the Location passed in - whether it searches the local table
    or the network names table.  The routine checks the state of the name
    and only returns names in the resolved state.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tNAMEADDR       *pNameAddr;
    NTSTATUS        status;
    tHASHTABLE      *pHashTbl;

    if (Location == NBT_LOCAL)
    {
        pHashTbl =  pNbtGlobConfig->pLocalHashTbl;
    }
    else
    {
        pHashTbl =  pNbtGlobConfig->pRemoteHashTbl;
    }

    status = FindInHashTable (pHashTbl, pName, pScope, &pNameAddr);
    if (!NT_SUCCESS(status))
    {
        return(NULL);
    }

    *pRetNameType = pNameAddr->NameTypeState;

    //
    // Only return names that are in the resolved state
    //
    if (!(pNameAddr->NameTypeState & STATE_RESOLVED))
    {
        pNameAddr = NULL;
    }

    return(pNameAddr);
}


//----------------------------------------------------------------------------
NTSTATUS
FindInHashTable(
    tHASHTABLE          *pHashTable,
    PCHAR               pName,
    PCHAR               pScope,
    tNAMEADDR           **pNameAddress
    )
/*++

Routine Description:

    This routine checks if the name passed in matches a hash table entry.
    Called with the spin lock HELD.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    PLIST_ENTRY              pEntry;
    PLIST_ENTRY              pHead;
    tNAMEADDR                *pNameAddr;
    int                      iIndex;
    ULONG                    uNameSize;
    PCHAR                    pScopeTbl;
    ULONG                    uInScopeLength = 0;

    // first hash the name to an index...
    // take the lower nibble of the first 2 characters.. mod table size
    //
    iIndex = ((pName[0] & 0x0F) << 4) + (pName[1] & 0x0F);
    iIndex = iIndex % pHashTable->lNumBuckets;

    if (pScope)
    {
        uInScopeLength = strlen (pScope);
    }

    // check if the name is already in the table
    // check each entry in the hash list...until the end of the list
    pHead = &pHashTable->Bucket[iIndex];
    pEntry = pHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);

        if (pNameAddr->NameTypeState & NAMETYPE_SCOPE)
        {
            // scope names are treated differently since they are not
            // 16 bytes long...  the length is stored separately.
            uNameSize = pNameAddr->ulScopeLength;
        }
        else
        {
            uNameSize = NETBIOS_NAME_SIZE;
        }

        //
        // strncmp will terminate at the first non-matching byte
        // or when it has matched uNameSize bytes
        //
        // Bug # 225328 -- have to use CTEMemEqu to compare all
        // uNameSize bytes (otherwise bad name can cause termination
        // due to NULL character)
        //
        if (!(pNameAddr->NameTypeState & STATE_RELEASED) &&
            CTEMemEqu (pName, pNameAddr->Name, uNameSize))
        {
            // now check if the scopes match. Scopes are stored differently
            // on the local and remote tables.
            //
            if (!pScope)
            {
                // passing in a Null scope means try to find the name without
                // worrying about a scope matching too...
                *pNameAddress = pNameAddr;
                return(STATUS_SUCCESS);
            }

            //
            // Check if Local Hash table
            //
            if (pHashTable == NbtConfig.pLocalHashTbl)
            {
                // In the local hash table case the scope is the same for all
                // names on the node and it is stored in the NbtConfig structure
                pScopeTbl = NbtConfig.pScope;
                uNameSize = NbtConfig.ScopeLength;
            }
            //
            // This is a Remote Hash table lookup
            //
            else if (pNameAddr->pScope)
            {
                pScopeTbl = &pNameAddr->pScope->Name[0];
                uNameSize = pNameAddr->pScope->ulScopeLength;
            }
            //
            // Remote Hash table entry with NULL scope
            // so if passed in scope is also Null, we have a match
            //
            else if (!uInScopeLength)
            {
                *pNameAddress = pNameAddr;
                return(STATUS_SUCCESS);
            }
            else
            {
                //
                // Hash table scope length is 0 != uInScopeLength
                // ==> No match!
                //
                continue;
            }

            //
            // strncmp will terminate at the first non-matching byte
            // or when it has matched uNameSize bytes
            //
            if (0 == strncmp (pScope, pScopeTbl, uNameSize))
            {
                // the scopes match so return
                *pNameAddress = pNameAddr;
                return(STATUS_SUCCESS);
            }
        } // end of matching name found
    }

    return(STATUS_UNSUCCESSFUL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\name.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Name.c

Abstract:

    This file implements Tdi interface into the Top of NBT.  In the NT
    implementation, ntisol.c calls these routines after extracting the
    relevent information from the Irp passed in from the Io subsystem.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"   // procedure headings
#ifndef VXD

#ifdef RASAUTODIAL
#include <acd.h>
#include <acdapi.h>
#include <tcpinfo.h>
#include <tdiinfo.h>
#endif // RASAUTODIAL
#include "name.tmh"
#endif

//
// Allocate storage for the configuration information and setup a ptr to
// it.
//
tNBTCONFIG      NbtConfig;
tNBTCONFIG      *pNbtGlobConfig = &NbtConfig;
BOOLEAN         CachePrimed;

//
// This structure is used to store name query and registration statistics
//
tNAMESTATS_INFO NameStatsInfo;
#ifndef VXD
//
// this tracks the original File system process that Nbt was booted by, so
// that handles can be created and destroyed in that process
//
PEPROCESS   NbtFspProcess;
#endif
//
// this describes whether we are a Bnode, Mnode, MSnode or Pnode
//
USHORT      RegistryNodeType;
USHORT      NodeType;
//
// this is used to track the memory allocated for datagram sends
//
ULONG       NbtMemoryAllocated;

// this is used to track used trackers to help solve cases where they all
// are used.
//
//#if DBG

LIST_ENTRY  UsedTrackers;

//#endif

#ifdef VXD
ULONG   DefaultDisconnectTimeout;
#else
LARGE_INTEGER DefaultDisconnectTimeout;
#endif

// ************* REMOVE LATER *****************88
BOOLEAN StreamsStack;

#ifdef DBG
//
// Imported routines.
//
#endif

NTSTATUS
NbtpConnectCompletionRoutine(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    PVOID           pCompletionContext
    );

//
// Function prototypes for functions local to this file
//
VOID
CleanupFromRegisterFailed(
    IN  PUCHAR      pNameRslv,
    IN  tCLIENTELE  *pClientEle
        );

VOID
SendDgramContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );

VOID
CTECountedAllocMem(
    PVOID   *pBuffer,
    ULONG   Size
    );

VOID
CTECountedFreeMem(
    IN PVOID    pBuffer,
    IN ULONG    Size,
    IN BOOLEAN  fJointLockHeld
    );

VOID
SendNextDgramToGroup(
    IN tDGRAM_SEND_TRACKING *pTracker,
    IN  NTSTATUS            status
    );

VOID
SendDgramCompletion(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);

VOID
DgramSendCleanupTracker(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status,
    IN  BOOLEAN                 fJointLockHeld
    );

VOID
SessionSetupContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );

VOID
SessionStartupCompletion(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);


VOID
SendNodeStatusContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );


NTSTATUS
SendToResolvingName(
    IN  tNAMEADDR               *pNameAddr,
    IN  PCHAR                   pName,
    IN  CTELockHandle           OldIrq,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   QueryCompletion
        );

NTSTATUS
StartSessionTimer(
    tDGRAM_SEND_TRACKING    *pTracker,
    tCONNECTELE             *pConnEle
    );

VOID
QueryNameCompletion(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        );

#ifndef VXD
VOID
NTClearFindNameInfo(
    tDGRAM_SEND_TRACKING    *pTracker,
    PIRP                    *ppClientIrp,
    PIRP                    pIrp,
    PIO_STACK_LOCATION      pIrpSp
    );
#endif  // !VXD

NTSTATUS
FindNameOrQuery(
    IN  PUCHAR                  pName,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  PVOID                   QueryCompletion,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  ULONG                   NameFlags,
    OUT tIPADDRESS              *IpAddress,
    OUT tNAMEADDR               **pNameAddr,
    IN  ULONG                   NameReferenceContext,
    IN  BOOLEAN                 DgramSend
    );

#ifdef RASAUTODIAL
extern BOOLEAN fAcdLoadedG;
extern ACD_DRIVER AcdDriverG;

VOID
NbtRetryPreConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    );

VOID
NbtCancelPreConnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

VOID
NbtRetryPostConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    );

BOOLEAN
NbtAttemptAutoDial(
    IN  tCONNECTELE                 *pConnEle,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp,
    IN  ULONG                       ulFlags,
    IN  ACD_CONNECT_CALLBACK        pProc
    );

VOID
NbtNoteNewConnection(
    IN  tNAMEADDR   *pNameAddr,
    IN  ULONG       IPAddress
    );
#endif // RASAUTODIAL

NTSTATUS
NbtConnectCommon(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp
    );

NTSTATUS
GetListOfAllAddrs(
    IN tNAMEADDR   *pNameAddr,
    IN tNAMEADDR   *p1CNameAddr,
    IN tIPADDRESS  **ppIpBuffer,
    IN ULONG       *pNumAddrs
    );

BOOL
IsLocalAddress(
    tIPADDRESS  IpAddress
    );

BOOL
IsSmbBoundToOutgoingInterface(
    IN  tIPADDRESS      IpAddress
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, NbtOpenConnection)
#pragma CTEMakePageable(PAGE, NbtSendDatagram)
#pragma CTEMakePageable(PAGE, BuildSendDgramHdr)
#pragma CTEMakePageable(PAGE, DelayedNbtResyncRemoteCache)
#pragma CTEMakePageable(PAGE, NbtQueryFindName)
#pragma CTEMakePageable(PAGE, NbtCloseAddress)
#pragma CTEMakePageable(PAGE, NbtCloseConnection)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
PickBestAddress(
    IN  tNAMEADDR       *pNameAddr,
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT tIPADDRESS      *pIpAddress
    )
/*++
Routine Description:

    This Routine picks the best address on a name based on strictness of Source addressing specified
    -- MUST be called with the JointLock held!

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    tDEVICECONTEXT  *pThisDeviceContext;
    LIST_ENTRY      *pHead, *pEntry;
    BOOLEAN         fFreeGroupList = FALSE;
    tIPADDRESS      IpAddress = 0;
    tIPADDRESS      *pIpNbtGroupList = NULL;

    CHECK_PTR (pNameAddr);
    CHECK_PTR (pDeviceContext);

    if (pNameAddr->Verify == REMOTE_NAME)
    {
        //
        // Check if this is a pre-loaded name!
        //
        if (pNameAddr->NameAddFlags & NAME_RESOLVED_BY_LMH_P)
        {
            IpAddress = pNameAddr->IpAddress;
            pIpNbtGroupList = pNameAddr->pLmhSvcGroupList;
        }
        //
        // See if we can find the preferred address
        //
        else if (((IsDeviceNetbiosless(pDeviceContext)) &&
                (pNameAddr->pRemoteIpAddrs && pNameAddr->pRemoteIpAddrs[0].IpAddress)) ||
                 ((!IsDeviceNetbiosless(pDeviceContext)) &&
                  (pNameAddr->RemoteCacheLen > pDeviceContext->AdapterNumber) &&
                  (pNameAddr->AdapterMask & pDeviceContext->AdapterMask)))
        {
            IpAddress = pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].IpAddress;
            pIpNbtGroupList = pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].pOrigIpAddrs;
        }
        //
        // If strict source routing was not set, then pick the last updated address
        //
        if ((!NbtConfig.ConnectOnRequestedInterfaceOnly) &&
                 (!IpAddress) && (!pIpNbtGroupList))
        {
            if (STATUS_SUCCESS == GetListOfAllAddrs(pNameAddr, NULL, &pIpNbtGroupList, NULL))
            {
                fFreeGroupList = TRUE;
            }
            else
            {
                pIpNbtGroupList = NULL;     // for safety
            }
        }

        //
        // If this was a Group name, then IpAddress can be 0!
        //
        if ((!IpAddress) && (pIpNbtGroupList)) {
            //
            // Pick the first non-zero address from the group list
            //
            int i;

            for (i = 0; pIpNbtGroupList[i] != (tIPADDRESS) -1; i++) {
                if (pIpNbtGroupList[i]) {
                    IpAddress = pIpNbtGroupList[i];
                    break;
                }
            }
        }

        if (fFreeGroupList)
        {
            CTEMemFree(pIpNbtGroupList);
        }
    }
    else
    {
        ASSERT (pNameAddr->Verify == LOCAL_NAME);
        //
        // For local names, first check if the name is registered on this device
        //
        if ((!(IsDeviceNetbiosless(pDeviceContext)) && (pDeviceContext->IpAddress) &&
             (pNameAddr->AdapterMask & pDeviceContext->AdapterMask)) ||
            ((IsDeviceNetbiosless(pDeviceContext)) &&
             (pNameAddr->NameFlags & NAME_REGISTERED_ON_SMBDEV)))
        {
            IpAddress = pDeviceContext->IpAddress;
        }
        //
        // If the strict source routing option is not set, then return the first valid local address
        //
        else if (!NbtConfig.ConnectOnRequestedInterfaceOnly)
        {
            //
            // Find the first device with a valid IP address that this name is registered on
            //
            pHead = pEntry = &NbtConfig.DeviceContexts;
            while ((pEntry = pEntry->Flink) != pHead)
            {
                pThisDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
                if ((pThisDeviceContext->IpAddress) &&
                    (pThisDeviceContext->AdapterMask & pNameAddr->AdapterMask))
                {
                    IpAddress = pThisDeviceContext->IpAddress;
                    pNameAddr->IpAddress = pThisDeviceContext->IpAddress;
                    break;
                }
            }

            //
            // If we failed to find the name registered on any of the legacy
            // devices, then we should check if the name is registered on the
            // SMBDevice and if so, return its IP address.
            //
            if ((!IpAddress) &&
                (pNbtSmbDevice) &&
                (pNameAddr->NameFlags & NAME_REGISTERED_ON_SMBDEV))
            {
                IpAddress = pNbtSmbDevice->IpAddress;
            }
        }
    }

    if ((IpAddress) && (pIpAddress))
    {
        *pIpAddress = IpAddress;
        return (STATUS_SUCCESS);
    }

    return (STATUS_UNSUCCESSFUL);
}

//----------------------------------------------------------------------------
VOID
RemoveDuplicateAddresses(
    tIPADDRESS  *pIpAddrBuffer,
    ULONG       *pNumAddrs
    )
{
    ULONG       NumAddrs = *pNumAddrs;
    ULONG       i, j;

    for (i=0; i<NumAddrs; i++) {
        for (j=i+1; j<NumAddrs; j++) {
            if (pIpAddrBuffer[i] == pIpAddrBuffer[j]) {
                NumAddrs--;
                pIpAddrBuffer[j] = pIpAddrBuffer[NumAddrs];
                j--;
            }
        }
    }

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.RemoveDuplicateAddresses: NumAddresses = <%d> --> <%d>\n", *pNumAddrs, NumAddrs));

    *pNumAddrs = NumAddrs;
}

VOID
CountAndCopyAddrs(
    tIPADDRESS  *pIpAddrSrc,
    tIPADDRESS  *pIpAddrDest,
    ULONG       *pNumAddrs
    )
{
    ULONG       NumAddrs = *pNumAddrs;

    if (pIpAddrSrc)
    {
        while (*pIpAddrSrc != (ULONG)-1)
        {
            if (*pIpAddrSrc)
            {
                if (pIpAddrDest)
                {
                    pIpAddrDest[NumAddrs] = *pIpAddrSrc;
                }
                NumAddrs++;
            }

            pIpAddrSrc++;
        }
    }

    *pNumAddrs = NumAddrs;
}


//----------------------------------------------------------------------------
NTSTATUS
GetListOfAllAddrs(
    IN tNAMEADDR   *pNameAddr,
    IN tNAMEADDR   *p1CNameAddr,
    IN tIPADDRESS  **ppIpBuffer,
    IN ULONG       *pNumAddrs
    )
{
    ULONG       i;
    tIPADDRESS  *pIpBuffer;
    tIPADDRESS  *pIpAddr;
    ULONG       NumAddrs = 0;
    BOOLEAN     fAddBcastAddr = FALSE;

    *ppIpBuffer = NULL;
    if (pNumAddrs)
    {
        *pNumAddrs = 0;
    }

    //
    // First count all the addresses
    //
    if (pNameAddr->pLmhSvcGroupList) // if the name was Preloaded from LmHosts
    {
        ASSERT(pNameAddr->NameTypeState & NAMETYPE_INET_GROUP);
        CountAndCopyAddrs (pNameAddr->pLmhSvcGroupList, NULL, &NumAddrs);
    }
    else
    {
        if (pNameAddr->IpAddress)
        {
            NumAddrs++;
        }

        //
        // RemoteCacheLen will be 0 if we had failed to allocate the pRemoteIpAddrs structure earlier
        //
        for (i=0; i<pNameAddr->RemoteCacheLen; i++)
        {
            CountAndCopyAddrs (pNameAddr->pRemoteIpAddrs[i].pOrigIpAddrs, NULL, &NumAddrs);
            if (pNameAddr->pRemoteIpAddrs[i].IpAddress)
            {
                NumAddrs++;
            }
        }
    }

    if (p1CNameAddr)
    {
        //
        // This would a name that was added through LmHosts, so it will
        // not have been resolved-per-interface from Wins!
        //
        ASSERT((p1CNameAddr->NameTypeState & NAMETYPE_INET_GROUP) && (!p1CNameAddr->pRemoteIpAddrs));
        CountAndCopyAddrs (p1CNameAddr->pLmhSvcGroupList, NULL, &NumAddrs);
    }

    if (!NumAddrs)
    {
        return (STATUS_BAD_NETWORK_PATH);
    }

    NumAddrs++;  // For the terminating address
    if ((pNameAddr->NameTypeState & NAMETYPE_INET_GROUP) &&
        (!(pNameAddr->fPreload)))
    {
        // Add the bcast address
        fAddBcastAddr = TRUE;
        NumAddrs++; // For the bcast address
    }

    if (!(pIpBuffer = NbtAllocMem((NumAddrs*sizeof(tIPADDRESS)),NBT_TAG('N'))))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Now copy all the addresses starting with the broadcast address if necessary
    //
    NumAddrs = 0;
    if (fAddBcastAddr)
    {
        pIpBuffer[0] = 0;
        NumAddrs++;
    }

    if (pNameAddr->pLmhSvcGroupList) // if the name was Preloaded from LmHosts
    {
        CountAndCopyAddrs (pNameAddr->pLmhSvcGroupList, pIpBuffer, &NumAddrs);
    }
    else
    {
        if (pNameAddr->IpAddress)
        {
            pIpBuffer[NumAddrs] = pNameAddr->IpAddress;
            NumAddrs++;
        }
        for (i=0; i<pNameAddr->RemoteCacheLen; i++)
        {
            CountAndCopyAddrs (pNameAddr->pRemoteIpAddrs[i].pOrigIpAddrs, pIpBuffer, &NumAddrs);
            if (pNameAddr->pRemoteIpAddrs[i].IpAddress)
            {
                pIpBuffer[NumAddrs] = pNameAddr->pRemoteIpAddrs[i].IpAddress;
                NumAddrs++;
            }
        }
    }

    if (p1CNameAddr)
    {
        CountAndCopyAddrs (p1CNameAddr->pLmhSvcGroupList, pIpBuffer, &NumAddrs);
    }

    RemoveDuplicateAddresses(pIpBuffer, &NumAddrs);
    pIpBuffer[NumAddrs] = (tIPADDRESS)-1;

    *ppIpBuffer = pIpBuffer;
    if (pNumAddrs)
    {
        *pNumAddrs = NumAddrs;
    }
    return (STATUS_SUCCESS);
}



VOID
FilterIpAddrsForDevice(
    IN tIPADDRESS       *pIpAddr,
    IN tDEVICECONTEXT   *pDeviceContext,
    IN ULONG            *pNumAddrs
    )
{
    ULONG   i;
    ULONG   Interface, Metric;
    ULONG   NumAddrs = *pNumAddrs;

    ASSERT (NumAddrs > 0);
    if (NbtConfig.SendDgramOnRequestedInterfaceOnly)
    {
        for (i=1; i<NumAddrs; i++)
        {
            pDeviceContext->pFastQuery(ntohl(pIpAddr[i]), &Interface, &Metric);
            if (Interface != pDeviceContext->IPInterfaceContext)
            {
                pIpAddr[i] = pIpAddr[NumAddrs-1];
                NumAddrs--;
                i--;
            }
        }

        *pNumAddrs = NumAddrs;
        pIpAddr[NumAddrs] = (tIPADDRESS) -1;
    }
}


//----------------------------------------------------------------------------
NTSTATUS
NbtOpenAddress(
    IN  TDI_REQUEST         *pRequest,
    IN  TA_ADDRESS          *pTaAddress,
    IN  tIPADDRESS          IpAddress,
    IN  tDEVICECONTEXT      *pContext,
    IN  PVOID               pIrp)
/*++
Routine Description:

    This Routine handles opening an address for a Client.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS             status;
    tADDRESSELE          *pAddrElement;
    tCLIENTELE           *pClientEle;
    USHORT               uAddrType;
    CTELockHandle        OldIrq;
    CTELockHandle        OldIrq1;
    PUCHAR               pNameRslv;
    tNAMEADDR            *pNameAddr;
    COMPLETIONCLIENT     pClientCompletion;
    PVOID                Context;
    tTIMERQENTRY         *pTimer;
    BOOLEAN              MultiHomedReRegister = FALSE;
    BOOLEAN              DontIncrement= FALSE;
    ULONG                TdiAddressType;
    UCHAR                *BroadcastName = "\x2a\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0\x0";
    LIST_ENTRY           *pClientEntry;
    tCLIENTELE           *pClientEleTemp;
    BOOLEAN              fFirstClientOnDevice = TRUE;

    ASSERT(pTaAddress);
    if (!IpAddress)
    {
        //
        // when there is no ip address yet, use the Loop back address as
        // a default rather than null, since null tells NbtRegisterName
        // that the address is already in the name table and it only needs
        // to be reregistered.
        //
        IpAddress = LOOP_BACK;
    }

    TdiAddressType = pTaAddress->AddressType;
    switch (TdiAddressType)
    {
        case TDI_ADDRESS_TYPE_NETBIOS:
        {
            PTDI_ADDRESS_NETBIOS pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)pTaAddress->Address;

            uAddrType = pNetbiosAddress->NetbiosNameType;
            pNameRslv = pNetbiosAddress->NetbiosName;

            break;
        }

#ifndef VXD
        case TDI_ADDRESS_TYPE_NETBIOS_EX:
        {
            // The NETBIOS_EX address passed in will have two components,
            // an Endpoint name as well as the NETBIOS address.
            // In this implementation we ignore the second
            // component and register the Endpoint name as a netbios
            // address.

            PTDI_ADDRESS_NETBIOS_EX pNetbiosExAddress = (PTDI_ADDRESS_NETBIOS_EX)pTaAddress->Address;

            uAddrType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;
            pNameRslv = pNetbiosExAddress->EndpointName;

            break;
        }
#endif

        default:
            return STATUS_INVALID_ADDRESS_COMPONENT;
    }

    //
    // If the name is a Broadcast name, it can only be opened as a Group name
    //
    if ((CTEMemEqu (BroadcastName, pNameRslv, NETBIOS_NAME_SIZE)) &&
        (uAddrType != NBT_GROUP))
    {
        KdPrint (("Nbt.NbtOpenAddress: Warning: Opening broadcast name as Groupname!\n"));
        uAddrType = NBT_GROUP;
    }

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtOpenAddress: Name=<%-16.16s:%x>, pDevice=<%p>\n",
            pNameRslv, pNameRslv[15], pContext));

    //
    // be sure the broadcast name has 15 zeroes after it
    //
    if ((pNameRslv[0] == '*') && (TdiAddressType == TDI_ADDRESS_TYPE_NETBIOS))
    {
        CTEZeroMemory(&pNameRslv[1],NETBIOS_NAME_SIZE-1);
    }

    // this synchronizes access to the local name table when a new name
    // is registered.  Basically it will not let the second registrant through
    // until the first has put the name into the local table (i.e.
    // NbtRegisterName has returned )
    //
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

    // see if the name is registered on the local node.. we call the hash
    // table function directly rather than using findname, because find name
    // checks the state of the name too.  We want to know if the name is in
    // the table at all, and don't care if it is still resolving.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pNameAddr = NULL;
    status = FindInHashTable (pNbtGlobConfig->pLocalHashTbl, pNameRslv, NbtConfig.pScope, &pNameAddr);

    //
    // the name could be in the hash table, but the address element deleted
    //
    if (!NT_SUCCESS(status) || !pNameAddr->pAddressEle)
    {
        //
        // pNameAddr->pAddressEle is NULL <==> the Name is currently being released
        //
        if (pNameAddr)
        {
            //
            // Check if the name is about to be released on this adapter
            //
            if (pNameAddr->AdapterMask & pContext->AdapterMask)
            {
                pNameAddr->AdapterMask &= ~pContext->AdapterMask;
            }
            //
            // Check if the name is currently being released on this adapter
            //
            else if (pNameAddr->ReleaseMask & pContext->AdapterMask)
            {
                // Set the ReleaseMask bit to 0 so that the Timeout routine
                // does does not send this release out on the wire again
                //
                pNameAddr->ReleaseMask &= ~pContext->AdapterMask;
            }
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // open the name since it could not be found
        //
        // first of all allocate memory for the address block
        //
        status = STATUS_INSUFFICIENT_RESOURCES;
        if (pAddrElement = (tADDRESSELE *) NbtAllocMem(sizeof(tADDRESSELE),NBT_TAG('C')))
        {
            CTEZeroMemory(pAddrElement,sizeof(tADDRESSELE));
            InitializeListHead(&pAddrElement->Linkage);
            InitializeListHead(&pAddrElement->ClientHead);
            CTEInitLock(&pAddrElement->LockInfo.SpinLock);
#if DBG
            pAddrElement->LockInfo.LockNumber = ADDRESS_LOCK;
#endif
            pAddrElement->AddressType = TdiAddressType;
            if ((uAddrType == NBT_UNIQUE ) || (uAddrType == NBT_QUICK_UNIQUE))
            {
                pAddrElement->NameType = NBT_UNIQUE;
            }
            else
            {
                pAddrElement->NameType = NBT_GROUP;;
            }

            pAddrElement->Verify = NBT_VERIFY_ADDRESS;
            NBT_REFERENCE_ADDRESS (pAddrElement, REF_ADDR_NEW_CLIENT);

            // create client block and link to addresslist.  This allows multiple
            // clients to open the same address - for example a group name must
            // be able to handle multiple clients, each receiving datagrams to it.
            //
            if (pClientEle = NbtAllocateClientBlock(pAddrElement, pContext))
            {
                pClientEle->AddressType = TdiAddressType;
                pClientEle->pIrp = pIrp; // Track Irp -- complete it when the name registration completes
#ifndef VXD
                // set the share access ( NT only ) - security descriptor stuff
                if (pIrp)
                {
                    status = NTSetSharedAccess(pContext,pIrp,pAddrElement);
                }
                else
                {
                    status = STATUS_SUCCESS;
                }

                if (!NT_SUCCESS(status))
                {
                    // unable to set the share access correctly so release the
                    // address object and the client block connected to it
                    NbtFreeAddressObj(pAddrElement);
                    NbtFreeClientObj(pClientEle);

                    CTEExReleaseResource(&NbtConfig.Resource);
                    return(status);
                }

                // fill in the context values passed back to the client. These must
                // be done before the name is registered on the network because the
                // registration can succeed (or fail) before this routine finishes).
                // Since this routine can be called by NBT itself, pIrp may not be set,
                // so check for it.
                //
                if (pIrp)
                {
                    NTSetFileObjectContexts( pClientEle->pIrp,(PVOID)pClientEle, (PVOID)(NBT_ADDRESS_TYPE));
                }
#endif //!VXD

                // pass back the client block address as a handle for future reference
                // to the client
                pRequest->Handle.AddressHandle = (PVOID)pClientEle;

                // then add it to name service local name Q, passing the address of
                // the block as a context value ( so that subsequent finds return the
                // context value.
                // we need to know if the name is a group name or a unique name.
                // This registration may take some time so we return STATUS_PENDING
                // to the client
                //

                NBT_REFERENCE_ADDRESS (pAddrElement, REF_ADDR_REGISTER_NAME);
                status = NbtRegisterName (NBT_LOCAL,
                                          IpAddress,
                                          pNameRslv,
                                          NULL,
                                          pClientEle,            // context value
                                          (PVOID)NbtRegisterCompletion, // completion routine for
                                          uAddrType,                    // Name Srv to call
                                          pContext);
                //
                // ret status could be either status pending or status success since Quick
                // names return success - or status failure
                //
                if (!NT_SUCCESS(status))
                {
                    if (pIrp)
                    {
                        pClientEle->pIrp = NULL;
                        NTClearFileObjectContext(pIrp);
                    }

                    ASSERT(pAddrElement->RefCount == 2);
                    CTEExReleaseResource(&NbtConfig.Resource);

                    NBT_DEREFERENCE_CLIENT (pClientEle);
                    NBT_DEREFERENCE_ADDRESS (pAddrElement, REF_ADDR_REGISTER_NAME);
                    return (status);
                }

                NbtTrace(NBT_TRACE_NAMESRV, ("Client open address %!NBTNAME!<%02x> ClientEle=%p",
                                        pNameRslv, (unsigned)pNameRslv[15], pClientEle));

                // link the address element to the head of the address list
                // The Joint Lock protects this operation.
                ExInterlockedInsertTailList(&NbtConfig.AddressHead,
                                            &pAddrElement->Linkage,
                                            &NbtConfig.JointLock.LockInfo.SpinLock);

                NBT_DEREFERENCE_ADDRESS (pAddrElement, REF_ADDR_REGISTER_NAME);
            } // if pClientEle
            else
            {
                NbtFreeAddressObj(pAddrElement);
                pAddrElement = NULL;
            }

        } // if pAddrElement

    }
    else
    {
        pAddrElement = (tADDRESSELE *)pNameAddr->pAddressEle;

        //
        // increment here before releasing the spinlock so that a name
        // release done cannot free pAddrElement.
        //
        NBT_REFERENCE_ADDRESS (pAddrElement, REF_ADDR_NEW_CLIENT);

#ifndef VXD
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // check the shared access of the name - this check must be done
        // at Irl = 0, so no spin locks held
        //
        if (pIrp)
        {
            status = NTCheckSharedAccess (pContext, pIrp, (tADDRESSELE *)pNameAddr->pAddressEle);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        CTESpinLock(pAddrElement,OldIrq1);
#else
        //
        // For the Vxd, we don't allow multiple names in the local name table.
        // In NT, this is prevented on a per process basis by the Netbios
        // driver.  If the name is being deregistered (conflict) then allow
        // the client to reopen the name
        //
        if ( !(pNameAddr->NameTypeState & STATE_CONFLICT))
        {
            status = STATUS_UNSUCCESSFUL;
        }
#endif

        //
        // Write the correct Ip address to the table incase this
        // was a group name and has now changed to a unique
        // name, but don't overwrite with the loop back address because
        // that means that the adapter does not have an address yet.
        // For Group names the Ip address stays as 0, so we know to do a
        // broadcast.
        //
        if ((IpAddress != LOOP_BACK) &&
            (pNameAddr->NameTypeState & NAMETYPE_UNIQUE))
        {
            pNameAddr->IpAddress = IpAddress;
        }

        // multihomed hosts register the same unique name on several adapters.
        // NT DOES allow a client to share a unique name, so we must NOT
        // run this next code if the NT check has passed!!
        //
        if (!NT_SUCCESS(status))
        {
            //
            // if this is a unique name being registered on another adapter
            // then allow it to occur - the assumption is that the same
            // client is registering on more than one adapter all at once,
            // rather than two different clients.
            //
            if (NbtConfig.MultiHomed && (!(pNameAddr->AdapterMask & pContext->AdapterMask)))
            {
                status = STATUS_SUCCESS;
            }
            //
            // check if this is a client trying to add the permanent name,
            // since that name will fail the security check
            // We allow a single client to use the permanent name - since its
            // a unique name it will fail the Vxd check too.
            //
            else if (CTEMemEqu(&pNameAddr->Name[10], &pContext->MacAddress.Address[0], sizeof(tMAC_ADDRESS)))
            {
                // check if there is just one element on the client list.  If so
                // then the permanent name is not being used yet - i.e. it has
                // been opened once by the NBT code itself so the node will
                // answer Nodestatus requests to the name, but no client
                // has opened it yet
                //
                if (pAddrElement->ClientHead.Flink->Flink == &pAddrElement->ClientHead)
                {
                    status = STATUS_SUCCESS;
                }
            }
            else if ((pNameAddr->NameTypeState & STATE_CONFLICT))
            {
                // check if the name is in the process of being deregisterd -
                // STATE_CONFLICT - in this case allow it to carry on and take over
                // name.
                //
                status = STATUS_SUCCESS;
            }
        }

        if ((NT_SUCCESS(status)) &&
            (pNameAddr->NameTypeState & STATE_CONFLICT))
        {
            // this could either be a real conflict or a name being deleted on
            // the net, so stop any timer associated with the name release
            // and carry on
            //
            if (pTimer = pNameAddr->pTimer)
            {
                // this routine puts the timer block back on the timer Q, and
                // handles race conditions to cancel the timer when the timer
                // is expiring.
                pNameAddr->pTimer = NULL;
                status = StopTimer(pTimer,&pClientCompletion,&Context);

                // there is a client's irp waiting for the name release to finish
                // so complete that irp back to them
                if (pClientCompletion)
                {
                    //
                    // NOTE****
                    // We must clear the AdapterMask so that NameReleaseDone
                    // does not try to release the name on another net card
                    // for the multihomed case.
                    //
                    CHECK_PTR(pNameAddr);
                    CTESpinFree(pAddrElement,OldIrq1);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);

                    (*pClientCompletion)(Context,STATUS_SUCCESS);

                    CTESpinLock(&NbtConfig.JointLock,OldIrq);
                    CTESpinLock(pAddrElement,OldIrq1);
                }
                CHECK_PTR(pNameAddr);
            }
            //
            // this allows another client to use a name almost immediately
            // after the first one releases the name on the net.  However
            // if the first client has not released the name yet, and is
            // still on the clienthead list, then the name will not be
            // reregistered, and this current registration will fail because
            // the name state is conflict. That check is done below.
            //
            if (IsListEmpty(&pAddrElement->ClientHead))
            {
                pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                pNameAddr->NameTypeState |= STATE_RESOLVED;
                status = STATUS_SUCCESS;
                MultiHomedReRegister = TRUE;

                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtOpenAddress: Conflict State, re-registering name on net\n"));
            }
            else
            {
#if 0
                //
                // Don't log the event:
                //  The current name state is already in CONFLICTED state,
                //  we should have already logged an event when we change
                //  its state into CONFLICTED.
                //

                // set status that indicates someone else has the name on the
                // network.
                //
                if (!IS_MESSENGER_NAME(pNameRslv))
                {
                    //
                    // We need to Q this event to a Worker thread since it
                    // requires the name to be converted to Unicode
                    //
                    NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT);
                    status = NTQueueToWorkerThread(NULL, DelayedNbtLogDuplicateNameEvent,
                                                           (PVOID) pNameAddr,
                                                           IntToPtr(IpAddress),
                                                           IntToPtr(0x106),
                                                           pContext,
                                                           TRUE);
                    if (!NT_SUCCESS(status))
                    {
                        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_LOG_EVENT, TRUE);
                        NbtLogEvent (EVENT_NBT_DUPLICATE_NAME, IpAddress, 0x106);
                    }
                }
#endif
                status = STATUS_DUPLICATE_NAME;
            }
        }
        else if (NT_SUCCESS(status))
        {
            // name already exists - is open; allow only another client creating a
            // name of the same type
            //
            if ((uAddrType == NBT_UNIQUE) || ( uAddrType == NBT_QUICK_UNIQUE))
            {
                if (!(pNameAddr->NameTypeState & NAMETYPE_UNIQUE))
                {
                    status = STATUS_SHARING_VIOLATION;
                }
            }
            else if (!(pNameAddr->NameTypeState & NAMETYPE_GROUP))
            {
                status = STATUS_SHARING_VIOLATION;
            }
        }
        else
        {
            status = STATUS_SHARING_VIOLATION;
        }

        // if everything is OK, create client block and link to addresslist
        // pass back the client block address as a handle for future reference
        // to the client
        if ((NT_SUCCESS(status)) &&
            (!(pClientEle = NbtAllocateClientBlock (pAddrElement, pContext))))
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // check for a failure, if so , then return
        //
        if (!NT_SUCCESS(status))
        {
            CHECK_PTR(pRequest);
            pRequest->Handle.AddressHandle = NULL;

            CTESpinFree(pAddrElement,OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NBT_DEREFERENCE_ADDRESS (pAddrElement, REF_ADDR_NEW_CLIENT);
            CTEExReleaseResource(&NbtConfig.Resource);
            return(status);
        }

        // we need to track the Irp so that when the name registration
        // completes, we can complete the Irp.
        pClientEle->pIrp = pIrp;
        pClientEle->AddressType = TdiAddressType;

        pRequest->Handle.AddressHandle = (PVOID)pClientEle;

        // fill in the context values passed back to the client. These must
        // be done before the name is registered on the network because the
        // registration can succeed (or fail) before this routine finishes).
        // Since this routine can be called by NBT itself, there may not be an
        // irp to fill in, so check first.
        if (pIrp)
        {
#ifndef VXD
            NTSetFileObjectContexts( pClientEle->pIrp,(PVOID)pClientEle, (PVOID)(NBT_ADDRESS_TYPE));
#endif
        }

        //
        // See if this is not the first Client on this Device
        //
        pClientEntry = &pAddrElement->ClientHead;
        while ((pClientEntry = pClientEntry->Flink) != &pAddrElement->ClientHead)
        {
            pClientEleTemp = CONTAINING_RECORD (pClientEntry,tCLIENTELE,Linkage);
            if ((pClientEleTemp != pClientEle) &&
                (pClientEleTemp->pDeviceContext == pContext))
            {
                fFirstClientOnDevice = FALSE;
                break;
            }
        }

        if (fFirstClientOnDevice)
        {
            if (IsDeviceNetbiosless(pContext))
            {
                pNameAddr->NameFlags |= NAME_REGISTERED_ON_SMBDEV;
            }
            else
            {
                //
                // turn on the adapter's bit in the adapter Mask and set the
                // re-register flag (if the name is not resolving already) so
                // we register the name out the new adapter.
                //
                pNameAddr->AdapterMask |= pContext->AdapterMask;
                if (pNameAddr->NameTypeState & STATE_RESOLVED)
                {
                    MultiHomedReRegister = TRUE;
                }
            }
        }
        else
        {
            // the adapter bit is already on in the pAddressEle, so
            // this must be another client registering the same name,
            // therefore turn on the MultiClient boolean so that the DgramRcv
            // code will know to activate its multiple client rcv code.
            //
            pAddrElement->MultiClients = TRUE;
        }

        //
        // check the state of the entry in the table.  If the state is
        // resolved then complete the request now,otherwise we cannot complete
        // this request yet... i.e. we return Pending.
        //
        if (((pNameAddr->NameTypeState & STATE_RESOLVED) &&
            (!MultiHomedReRegister)))
        {
            // basically we are all done now, so just return status success
            // to the client
            //
            status = STATUS_SUCCESS;

            CHECK_PTR(pClientEle);
            pClientEle->pIrp = NULL;
            CTESpinFree(pAddrElement,OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            pClientEle->WaitingForRegistration = FALSE;
        }
        else
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtOpenAddress: Waiting for prev registration- state=%x, ReRegister=%x\n",
                    pNameAddr->NameTypeState, MultiHomedReRegister));

            // we need to track the Irp so that when the name registration
            // completes, we can complete the Irp.
            pClientEle->pIrp = pIrp;

            CTESpinFree(pAddrElement,OldIrq1);
            if (MultiHomedReRegister)
            {
                // this flag is used by RegisterCompletion ( when true )
                pClientEle->WaitingForRegistration = FALSE;
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtOpenAddress: Resolved State=%x, ReRegister=%x\n",
                        pNameAddr->NameTypeState, MultiHomedReRegister));

                // we need to re-register the name on the net because it is not
                // currently in the resolved state and there is no timer active
                // We do that by calling this routine with the IpAddress set to NULL
                // to signal that routine not to put the name in the hash table
                // since it is already there.
                //
                status = NbtRegisterName (NBT_LOCAL,
                                          0,        // set to zero to signify already in tbl
                                          pNameRslv,
                                          pNameAddr,
                                          pClientEle,
                                          (PVOID)NbtRegisterCompletion,
                                          uAddrType,
                                          pContext);

                if (!NT_SUCCESS(status))
                {
                    if (pIrp)
                    {
                        pClientEle->pIrp = NULL;
                        NTClearFileObjectContext(pIrp);
                    }

                    CTEExReleaseResource(&NbtConfig.Resource);
                    NBT_DEREFERENCE_CLIENT (pClientEle);
                    return (status);
                }
            }
            else
            {
                pClientEle->WaitingForRegistration = TRUE;
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                // for multihomed, a second registration on a second adapter
                // at the same time as the first adapter is registering is
                // delayed until the first completes, then its registration
                // proceeds - See RegistrationCompletion below.
                //
                status = STATUS_PENDING;
            }
        }
    }

    CTEExReleaseResource(&NbtConfig.Resource);

#ifdef _PNP_POWER_
    //
    // See if we need to set the Wakeup pattern on this Device
    //
    if ((NT_SUCCESS(status)) &&
        (*pNameRslv != '*') &&
        (pNameRslv[NETBIOS_NAME_SIZE-1] == SPECIAL_SERVER_SUFFIX))
    {
        pContext->NumServers++;
        CheckSetWakeupPattern (pContext, pNameRslv, TRUE);
    }
#endif

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtRegisterCompletion(
    IN  tCLIENTELE *pClientEleIn,
    IN  NTSTATUS    status
    )

/*++

Routine Description

    This routine handles completing a name registration request. The namesrv.c
    Name server calls this routine when it has registered a name.  The address
    of this routine is passed to the Local Name Server in the NbtRegisterName
    request.

    The idea is to complete the irps that are waiting on the name registration,
    one per client element.

    When a DHCP reregister occurs there is no client irp so the name is
    not actually deleted from the table when a bad status is passed to this
    routine.  Hence the need for the DhcpRegister flag to change the code
    path for that case.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{
    LIST_ENTRY      *pHead;
    LIST_ENTRY      *pEntry;
    CTELockHandle   OldIrq;
    CTELockHandle   OldIrq1;
    tADDRESSELE     *pAddress;
    tDEVICECONTEXT  *pDeviceContext;
    tNAMEADDR       *pNameAddr;
    tCLIENTELE      *pClientEle;
    LIST_ENTRY      TempList;
    ULONG           Count=0;

    InitializeListHead(&TempList);

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    pAddress = pClientEleIn->pAddress;
    pDeviceContext = pClientEleIn->pDeviceContext;

    CTESpinLock(pAddress,OldIrq);

    // Several Clients can open the same address at the same time, so when the
    // name registration completes, it should complete all of them!!


    // increment the reference count so that the hash table entry cannot
    // disappear while we are using it.
    //
    NBT_REFERENCE_ADDRESS (pAddress, REF_ADDR_REG_COMPLETION);
    pNameAddr = pAddress->pNameAddr;

    pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
    pNameAddr->pTimer = NULL;   // Bug #: 231693

    // if the registration failed or a previous registration failed for the
    // multihomed case, deny the client the name
    //
    if ((status == STATUS_SUCCESS) || (status == STATUS_TIMEOUT))
    {
        pNameAddr->NameTypeState |= STATE_RESOLVED;
    }
    else
    {
        pNameAddr->NameTypeState |= STATE_CONFLICT;
        pNameAddr->ConflictMask |= pDeviceContext->AdapterMask;
        status = STATUS_DUPLICATE_NAME;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // find all clients that are attached to the address and complete the
    // I/O requests, if they are on the same adapter that the name was
    // just registered against, if successful.  For failure cases complete
    // all irps with the failure code - i.e. failure to register a name on
    // one adapter fails all adapters.
    //
FailRegistration:
    pHead = &pAddress->ClientHead;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        // complete the I/O
        pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

        pEntry = pEntry->Flink;

        //
        // It is possible for the second registration  of a name to fail so
        // we do not want to attempt to return the irp on the first
        // registration, which has completed ok already.  Therefore
        // if the status is failure, then only complete those clients that
        // have the WaitingForReg... bit set
        //
        // if it is the client ele passed in, or one on the same device context
        // that is waiting for a name registration, or it is a failure...
        // AND the client IRP is still valid then return the Irp.
        //
        if ((pClientEle->pIrp) &&
            ((pClientEle == pClientEleIn) ||
             ((pClientEle->pDeviceContext == pDeviceContext) && (pClientEle->WaitingForRegistration)) ||
             ((status != STATUS_SUCCESS) && pClientEle->WaitingForRegistration)))
        {
            // for failed registrations, remove the client from the address list
            // since we are going to delete him below.
            if (!NT_SUCCESS(status))
            {
                // turn off the adapter bit so we know not to use this name with this
                // adapter - since it is a failure, turn off all adapter bits
                // since a single name registration failure means all registrations
                // fail.
                CHECK_PTR(pNameAddr);
                pNameAddr->AdapterMask = 0;

                // setting this to null prevents CloseAddress and CleanupAddress
                // from accessing pAddress and crashing.
                //
                CHECK_PTR(pClientEle);
                pClientEle->pAddress = NULL;

                // clear the ptr to the ClientEle that NbtRegisterName put into
                // the irp ( i.e. the context values are cleared )
                //
#ifndef VXD
                NTSetFileObjectContexts(pClientEle->pIrp,NULL,NULL);
#endif
                RemoveEntryList(&pClientEle->Linkage);
            }

            ASSERT(pClientEle->pIrp);

            pClientEle->WaitingForRegistration = FALSE;

#ifndef VXD
            // put all irps that have to be completed on a separate list
            // and then complete later after releaseing the spin lock.
            //
            InsertTailList(&TempList,&pClientEle->pIrp->Tail.Overlay.ListEntry);
#else
            //
            //  pAddress gets set in the name table for this NCB
            //
            Count++;
            CTESpinFree(pAddress,OldIrq1);
            CTEIoComplete( pClientEle->pIrp, status, (ULONG) pClientEle ) ;
            CTESpinLock(pAddress,OldIrq1);
#endif
            CHECK_PTR(pClientEle);
            pClientEle->pIrp = NULL ;

            // free the client object memory
            if (!NT_SUCCESS(status))
            {
                NbtFreeClientObj(pClientEle);
            }
        }
    }

    CTESpinFree(pAddress,OldIrq1);

#ifndef VXD
    //
    // for the NT case where MP - ness can disrupt the list at any
    // time, scan the whole list above without releasing the spin lock,
    // and then complete the irps collected here
    //
    while (!IsListEmpty(&TempList))
    {
        PIRP    pIrp;

        pEntry = RemoveHeadList(&TempList);
        pIrp = CONTAINING_RECORD(pEntry,IRP,Tail.Overlay.ListEntry);

        CTEIoComplete(pIrp,status,0);
        Count++;
    }
#endif


    // if the registration failed, do one more dereference of the address
    // to remove the refcount added by this client.  This may cause a name
    // release on the network if there are no other clients registering
    // the name.
    //
    if (!NT_SUCCESS(status))
    {
        //
        // dereference the address the same number of times that we have
        // returned failed registrations since each reg. referenced pAddress
        // once
        //
        while (Count--)
        {
            NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_NEW_CLIENT);
        }
    }
    else
    {
        USHORT  uAddrType;

        CTESpinLock(pAddress,OldIrq1);

        // go through the clients and see if any are waiting to register
        // a name.  This happens in the multihomed case, but should not
        // happen in the single adapter case.
        //
        pHead = &pAddress->ClientHead;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            // complete the I/O
            pClientEle = CONTAINING_RECORD(pEntry,tCLIENTELE,Linkage);

            pEntry = pEntry->Flink;

            if (pClientEle->WaitingForRegistration)
            {
                ULONG   SaveState;

                pClientEle->WaitingForRegistration = FALSE;

                if (pNameAddr->NameTypeState & NAMETYPE_UNIQUE)
                {
                    uAddrType = NBT_UNIQUE;
                }
                else
                    uAddrType = NBT_GROUP;

                //
                // preserve the "QUICK"ness
                //
                if (pNameAddr->NameTypeState & NAMETYPE_QUICK)
                {
                    uAddrType |= NBT_QUICK_UNIQUE;
                }

                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtRegisterCompletion: Registering next name state= %X,%15s<%X>\n",
                        pNameAddr->NameTypeState,pNameAddr->Name,pNameAddr->Name[15]));

                SaveState = pNameAddr->NameTypeState;

                CTESpinFree(pAddress,OldIrq1);

                // this may be a multihomed host, with another name registration
                // pending out another adapter, so start that registration.
                status = NbtRegisterName (NBT_LOCAL,
                                          0,        // set to zero to signify already in tbl
                                          pNameAddr->Name,
                                          pNameAddr,
                                          pClientEle,
                                          (PVOID)NbtRegisterCompletion,
                                          uAddrType,
                                          pClientEle->pDeviceContext);

                CTESpinLock(pAddress,OldIrq1);

                // since nbtregister will set the state to Resolving, when
                // it might be resolved already on one adapter.
                pNameAddr->NameTypeState = SaveState;
                if (!NT_SUCCESS(status))
                {
                    // if this fails for some reason, then fail any other name
                    // registrations pending. - the registername call should not
                    // fail unless we are out of resources.
                    pClientEle->WaitingForRegistration = TRUE;
                    goto FailRegistration;
                }
                // just register one name at a time, unless we get immediate success
                else if (status == STATUS_PENDING)
                {
                    break;
                }
                else    // SUCCESS
                {
                    CTESpinFree(pAddress,OldIrq1);
                    CTEIoComplete(pClientEle->pIrp,status,0);
                    pClientEle->pIrp = NULL;
                    CTESpinLock(pAddress,OldIrq1);
                }
            }
        }
        CTESpinFree(pAddress,OldIrq1);

    }

    if (!NT_SUCCESS(status))
    {
        //
        // Go through all the Clients still attached, and reset their
        // AdapterMasks since we could have removed them
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        CTESpinLock(pAddress,OldIrq1);

        pEntry = pHead = &pAddress->ClientHead;
        while ((pEntry = pEntry->Flink) != pHead)
        {
            pClientEle = CONTAINING_RECORD (pEntry,tCLIENTELE,Linkage);
            if (!IsDeviceNetbiosless(pClientEle->pDeviceContext))
            {
                pNameAddr->AdapterMask |= pClientEle->pDeviceContext->AdapterMask;
            }
        }

        CTESpinFree(pAddress,OldIrq1);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    // this decrements for the RefCount++ done in this routine.
    NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_REG_COMPLETION);

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtOpenConnection(
    IN  TDI_REQUEST         *pRequest,
    IN  CONNECTION_CONTEXT  ConnectionContext,
    IN  tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description

    This routine handles creating a connection object for the client.  It
    passes back a ptr to the connection so that OS specific portions of the
    data structure can be filled in.

Arguments:


Return Values:

    pConnectEle - ptr to the allocated connection data structure
    TDI_STATUS - status of the request

--*/
{
    NTSTATUS            status = STATUS_SUCCESS ;
    tCONNECTELE         *pConnEle;

    CTEPagedCode();

    // Acquire this resource to co-ordinate with DHCP changing the IP address
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

    if ((!pDeviceContext->pSessionFileObject) ||
        (!(pConnEle = (tCONNECTELE *)NbtAllocMem(sizeof(tCONNECTELE),NBT_TAG('D')))))
    {
        CTEExReleaseResource(&NbtConfig.Resource);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtOpenConnection: pConnEle = <%x>\n",pConnEle));

    // This ensures that all BOOLEAN values begin with a FALSE value among other things.
    CTEZeroMemory(pConnEle,sizeof(tCONNECTELE));
    CTEInitLock(&pConnEle->LockInfo.SpinLock);
#if DBG
    pConnEle->LockInfo.LockNumber = CONNECT_LOCK;
#endif
    // initialize lists to empty
    InitializeListHead(&pConnEle->RcvHead);

    pConnEle->Verify = NBT_VERIFY_CONNECTION;
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_CREATE); // so we don't delete the connection
    SET_STATE_UPPER (pConnEle, NBT_IDLE);
    pConnEle->pDeviceContext = pDeviceContext;
    pConnEle->ConnectContext = ConnectionContext;   // used in various event calls (eg. Receive, Disconnect)

    //
    // for each connection the client(s) open, open a connection to the transport
    // so that we can accept one to one from the transport.
#ifndef VXD
    //
    // Allocate an MDL to be used for partial Mdls
    // The length of the Mdl is set to 64K(MAXUSHORT) so that there are enough
    // pfns in the  Mdl to map a large buffer.
    //
    // use pConnEle as the Virtual address, since it doesn't matter
    // because it will be overwritten when the partial Mdl is created.
    //
    if (pConnEle->pNewMdl = IoAllocateMdl ((PVOID)pConnEle, MAXUSHORT, FALSE, FALSE, NULL))
#endif
    {
        //
        // allocate memory for the lower connection block.
        //
        status = NbtOpenAndAssocConnection(pDeviceContext, NULL, NULL, '2');
        if (NT_SUCCESS(status))
        {
            // link on to list of open connections for this device so that we
            // know how many open connections there are at any time (if we need to know)
            // This linkage is only in place until the client does an associate, then
            // the connection is unlinked from here and linked to the client ConnectHead.
            //
            ExInterlockedInsertHeadList(&pDeviceContext->UpConnectionInUse,
                                        &pConnEle->Linkage,
                                        &NbtConfig.JointLock.LockInfo.SpinLock);

            // return the pointer to the block to the client as the connection id
            pRequest->Handle.ConnectionContext = (PVOID)pConnEle;

            CTEExReleaseResource(&NbtConfig.Resource);
            NbtTrace(NBT_TRACE_OUTBOUND, ("New connection: pConnEle=%p pLowerConn=%p pDeviceContext=%p",
                            pConnEle, pConnEle->pLowerConnId, pConnEle->pDeviceContext));

            return(STATUS_SUCCESS);
        }
#ifndef VXD
        IoFreeMdl(pConnEle->pNewMdl);
#endif
    }
#ifndef VXD
    else
    {
        // ASSERTMSG("Nbt:Unable to allocate a MDL!!\n",0);
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
#endif  // !VXD

    FreeConnectionObj(pConnEle);
    CTEExReleaseResource(&NbtConfig.Resource);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtOpenAndAssocConnection(
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  tCONNECTELE         *pConnEle,
    OUT tLOWERCONNECTION    **ppLowerConn,
    IN  UCHAR               Identifier
    )

/*++
Routine Description:

    This Routine handles associating a Net Bios name with an open connection.
    In order to coordinate with ZwClose(hSession) in CloseAddressesWithTransport/ntutil.c,
    this routine should be called with NbtConfig.Resource exclusively locked.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status;
    NTSTATUS            Locstatus;
    BOOLEAN             Attached=FALSE;
    tLOWERCONNECTION    *pLowerConn;
    PDEVICE_OBJECT      pDeviceObject;
    HANDLE              hSession;
    ULONG               Id = 0;
    UCHAR               *Id1 = (UCHAR *) &Id;
    TCP_REQUEST_SET_INFORMATION_EX  *pTcpSetInfo;
    struct TCPSocketOption          *pSockOption;
    ULONG                           BufferLength;

    if (ppLowerConn)
    {
        *ppLowerConn = NULL;
    }

    Id1[1] = 'L';
    Id1[0] = Identifier;

    if (!(pLowerConn = (tLOWERCONNECTION *) NbtAllocMem(sizeof(tLOWERCONNECTION), NBT_TAG2(Id))))
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    CHECK_PTR(pLowerConn);
    CTEZeroMemory((PVOID)pLowerConn,sizeof(tLOWERCONNECTION));
    CTEAttachFsp(&Attached, REF_FSP_CONN);

    status = NbtTdiOpenConnection(pLowerConn,pDeviceContext);
    if (!NT_SUCCESS(status))
    {
        KdPrint(("Nbt.NbtOpenAndAssocConnection: NbtTdiOpenConnection returned ERROR=%x\n", status));
        CTEDetachFsp(Attached, REF_FSP_CONN);
        CTEMemFree(pLowerConn);

        return(status);
    }

    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE);
    NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_ASSOC_CONNECTION);

    if (pConnEle)
    {
        //
        // Open an address object (aka port)
        //

        //
        // until the correct state proc is set (i.e.Outbound), reject any data
        // (in other words, don't let this field stay NULL!)
        //
        SetStateProc (pLowerConn, RejectAnyData);

        status = NbtTdiOpenAddress (&pLowerConn->AddrFileHandle,
                                    &pDeviceObject,         // dummy argument, not used here
                                    &pLowerConn->pAddrFileObject,
                                    pDeviceContext,
                                    (USHORT) 0,             // any port
                                    pDeviceContext->IpAddress,
                                    TCP_FLAG);

        hSession = pLowerConn->AddrFileHandle;
    }
    else
    {
#ifndef VXD
        hSession = pDeviceContext->hSession;
#else
        hSession = (HANDLE) pDeviceContext->pSessionFileObject);    // Address handle stored in pFileObjects
#endif
    }

    /*
     * hSession could be NULL if the IP address is being released.
     */
    if (hSession == NULL) {
        status = STATUS_UNSUCCESSFUL;
    }
    if (NT_SUCCESS(status))
    {
        // associate with 139 or 445 session address
        status = NbtTdiAssociateConnection (pLowerConn->pFileObject, hSession);
        if (NT_SUCCESS(status))
        {
            ASSERT(pLowerConn->RefCount == 2);

            //
            // Disable nagling on this connection
            //
            if (!pDeviceContext->EnableNagling) {
                NbtSetTcpInfo (pLowerConn->FileHandle, TCP_SOCKET_NODELAY, INFO_TYPE_CONNECTION, (ULONG)TRUE);
            }

            if (pConnEle)
            {
                pLowerConn->pUpperConnection = pConnEle;
                ExInterlockedInsertTailList (&pDeviceContext->LowerConnection,   // put on active connections Q
                                             &pLowerConn->Linkage,
                                             &pDeviceContext->LockInfo.SpinLock);
            }
            else
            {
                InterlockedIncrement (&pDeviceContext->NumFreeLowerConnections);
                ExInterlockedInsertTailList (&pDeviceContext->LowerConnFreeHead,    // put on free list
                                             &pLowerConn->Linkage,
                                             &pDeviceContext->LockInfo.SpinLock);
            }
            InterlockedIncrement (&pDeviceContext->TotalLowerConnections);

            CTEDetachFsp(Attached, REF_FSP_CONN);
            if (ppLowerConn)
            {
                *ppLowerConn = pLowerConn;
            }

            NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_ASSOC_CONNECTION, FALSE);
            return status;
        }


        KdPrint(("Nbt.NbtOpenAndAssocConnection: NbtTdiAssociateConnection returned ERROR=%x\n", status));
    }
    else
    {
        KdPrint(("Nbt.NbtOpenAddress: NbtTdiOpenConnection returned ERROR=%x\n", status));
    }

    /*
     * NBT_DEREFERENCE_LOWERCONN will decrease the TotalLowerConnections
     * Without the following InterlockedIncrement, we could under-count
     * the actual # of Lower Connection.
     */
    InterlockedIncrement (&pDeviceContext->TotalLowerConnections);
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_ASSOC_CONNECTION, FALSE);
    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, FALSE);

    CTEDetachFsp(Attached, REF_FSP_CONN);

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtAssociateAddress(
    IN  TDI_REQUEST         *pRequest,
    IN  tCLIENTELE          *pClientHandle,
    IN  PVOID               pIrp
    )

/*++
Routine Description:

    This Routine handles associating a Net Bios name with an open connection.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    tCONNECTELE     *pConnEle;
    NTSTATUS        status;
    CTELockHandle   OldIrq;
    CTELockHandle   OldIrq1;
    CTELockHandle   OldIrq2;
    CTELockHandle   OldIrq3;

    pConnEle = pRequest->Handle.ConnectionContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq3);
    // Need code here to check if the address has been registered on the net
    // yet and if not, then this could must wait till then , then to the
    // associate  *TODO*

    CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status) // check connection for validity
    CTEVerifyHandle(pClientHandle,NBT_VERIFY_CLIENT,tCLIENTELE,&status) // check client for validity now!

    CTESpinLock(pClientHandle->pDeviceContext,OldIrq2);
    CTESpinLock(pClientHandle,OldIrq);
    CTESpinLock(pConnEle,OldIrq1);

    if ((pConnEle->state != NBT_IDLE) ||
        (!NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION)) ||  // NBT_VERIFY_CONNECTION_DOWN if cleaned up
        (!NBT_VERIFY_HANDLE (pClientHandle, NBT_VERIFY_CLIENT)))   // NBT_VERIFY_CLIENT_DOWN if cleaned up
    {
        // the connection is in use, so reject the associate attempt
        CTESpinFree(pConnEle,OldIrq1);
        CTESpinFree(pClientHandle,OldIrq);
        CTESpinFree(pClientHandle->pDeviceContext,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq3);
        return(STATUS_INVALID_HANDLE);
    }

    SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    // link the connection to the client so we can find the client, given
    // the connection.
    pConnEle->pClientEle = (PVOID)pClientHandle;
    NbtTrace(NBT_TRACE_OUTBOUND, ("Associate: pConnEle %p pDeviceContext %p Client %p",
                    pConnEle, pConnEle->pDeviceContext, pConnEle->pClientEle));

    // there can be multiple connections hooked to each client block - i.e.
    // multiple connections per address per client.  This allows the client
    // to find its connections.
    //
    // first unlink from the device context UpconnectionsInUse, which was linked
    // when the connection was created.
    RemoveEntryList(&pConnEle->Linkage);
    InsertTailList(&pClientHandle->ConnectHead,&pConnEle->Linkage);

    CTESpinFree(pConnEle,OldIrq1);
    CTESpinFree(pClientHandle,OldIrq);
    CTESpinFree(pClientHandle->pDeviceContext,OldIrq2);
    CTESpinFree(&NbtConfig.JointLock,OldIrq3);

    return(STATUS_SUCCESS);

}
//----------------------------------------------------------------------------
NTSTATUS
NbtDisassociateAddress(
    IN  TDI_REQUEST         *pRequest
    )

/*++
Routine Description:

    This Routine handles disassociating a Net Bios name with an open connection.
    The expectation is that the
    client will follow with a NtClose which will do the work in Cleanup and
    Close Connection.  Since not all clients call this it is duplicate work
    to put some code here to.  The Rdr always calls NtClose after calling
    this.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    tCONNECTELE     *pConnEle;
    tCLIENTELE      *pClientEle;
    NTSTATUS        status;
    CTELockHandle   OldIrq;
    CTELockHandle   OldIrq1;
    CTELockHandle   OldIrq2;
    tDEVICECONTEXT  *pDeviceContext;
    TDI_REQUEST         Request;
    ULONG           Flags;
    LIST_ENTRY      TempList;
    PLIST_ENTRY     pHead,pEntry;
    tLISTENREQUESTS *pListen;

    pConnEle = pRequest->Handle.ConnectionContext;
    // check the connection element for validity
    CHECK_PTR(pConnEle);
    if (!NBT_VERIFY_HANDLE2(pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        ASSERT(0);
        return (STATUS_INVALID_HANDLE);
    }

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDisassociateAddress: State = %X\n",pConnEle->state));

    Flags = TDI_DISCONNECT_RELEASE;

    switch (pConnEle->state)
    {
        case NBT_CONNECTING:
        case NBT_RECONNECTING:
        case NBT_SESSION_OUTBOUND:
        case NBT_SESSION_WAITACCEPT:
        case NBT_SESSION_INBOUND:
            // do abortive disconnects when the session is not up yet
            // to be sure the disconnect completes the client's irp.
            Flags = TDI_DISCONNECT_ABORT;
        case NBT_SESSION_UP:


            //
            // Call NbtDisconnect incase the connection has not disconnected yet
            //
            Request.Handle.ConnectionContext = (PVOID)pConnEle;
            status = NbtDisconnect(&Request, &DefaultDisconnectTimeout, Flags, NULL, NULL, NULL);

            //
            // NOTE: there is no BREAK here... the next case MUST be executed too.
            //
        case NBT_ASSOCIATED:
        case NBT_DISCONNECTING:
        case NBT_DISCONNECTED:

            CTESpinLock(&NbtConfig.JointLock,OldIrq2);

            CHECK_PTR(pConnEle);
            CTESpinLock(pConnEle,OldIrq);

            RemoveEntryList(&pConnEle->Linkage);
            InitializeListHead(&pConnEle->Linkage);
            SET_STATE_UPPER (pConnEle, NBT_IDLE);
            pConnEle->DiscFlag = 0;

            //
            // remove the connection from the client and put back on the
            // unassociated list
            //
            if (pClientEle = pConnEle->pClientEle)
            {
                pConnEle->pClientEle = NULL;

                CTESpinFree(pConnEle,OldIrq);
                CTESpinLock(pClientEle,OldIrq1);
                CTESpinLock(pConnEle,OldIrq);

                InitializeListHead (&TempList);
                pHead = &pClientEle->ListenHead;
                pEntry = pHead->Flink;
                while (pEntry != pHead)
                {
                    pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);
                    pEntry = pEntry->Flink;     // Don't reference freed memory

                    if (pListen->pConnectEle == pConnEle)
                    {
                        RemoveEntryList(&pListen->Linkage);
                        InsertTailList (&TempList, &pListen->Linkage);
                    }
                }

                pDeviceContext = pClientEle->pDeviceContext;

                CTESpinFree(pConnEle,OldIrq);
                CTESpinFree(pClientEle,OldIrq1);

                //
                // Ensure that the connection has not been cleaned up in this interval
                // Bug# 237836
                //
                if (pConnEle->Verify == NBT_VERIFY_CONNECTION)
                {
                    ExInterlockedInsertTailList(&pDeviceContext->UpConnectionInUse,
                                                &pConnEle->Linkage,
                                                &pDeviceContext->LockInfo.SpinLock);
                }

                CTESpinFree(&NbtConfig.JointLock,OldIrq2);

                while ((pEntry = TempList.Flink) != &TempList)
                {
                    pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);
                    RemoveEntryList(&pListen->Linkage);
                    CTEIoComplete (pListen->pIrp, STATUS_CANCELLED, 0);
                    CTEMemFree((PVOID)pListen);
                }
            }
            else
            {
                CTESpinFree(pConnEle,OldIrq);
                CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            }

            break;

        default:
            break;
    }

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtCloseAddress(
    IN  TDI_REQUEST         *pRequest,
    OUT TDI_REQUEST_STATUS  *pRequestStatus,
    IN  tDEVICECONTEXT      *pContext,
    IN  PVOID               pIrp)

/*++

Routine Description

    This routine closes an address object for the client.  Any connections
    associated with the address object are immediately aborted and any requests
    pending on the connection associated with the address object are
    immediately completed with an appropriate error code.  Any event handlers
    that are registered are immediately deregistered and will not be called
    after this request completes.

    Note the the client actually passes a handle to the client object which is
    chained off the address object.  It is the client object that is closed,
    which represents this clients attachment to the address object.  Other
    clients can continue to use the address object.

Arguments:
    pRequest->Handle.AddressHandle - ptr to the ClientEle object.
    pRequestStatus - return status for asynchronous completions.
    pContext - the NBT device that this address is valid upon
    pIrp - ptr to track for NT compatibility.

Return Values:

    TDI_STATUS - status of the request

--*/
{
    tCLIENTELE      *pClientEle;
    NTSTATUS        status;
#ifndef VXD
    UCHAR           IrpFlags;
    PIO_STACK_LOCATION           pIrpsp;
#endif

    CTEPagedCode();

    pClientEle = (tCLIENTELE *)pRequest->Handle.ConnectionContext;
    if (!pClientEle->pAddress)
    {
        // the address has already been deleted.
        return(STATUS_SUCCESS);
    }

    IF_DBG(NBT_DEBUG_DISCONNECT)
    KdPrint(("Nbt.NbtCloseAddress: Close Address Hit %16.16s<%X> %X\n",
            pClientEle->pAddress->pNameAddr->Name,
            pClientEle->pAddress->pNameAddr->Name[15],pClientEle));

    NbtTrace(NBT_TRACE_NAMESRV, ("close address ClientEle=%p %!NBTNAME!<%02x>", pClientEle,
                                    pClientEle->pAddress->pNameAddr->Name,
                                    (unsigned)pClientEle->pAddress->pNameAddr->Name[15]));

#ifdef VXD
    CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT,tCLIENTELE,&status);

    //
    // In NT-Land, closing connections is a two stage affair.  However in
    // the Vxd-Land, it is just a close, so call the other cleanup function
    // here to do most of the work. In the NT implementation it is called
    // from Ntisol.c, NTCleanupAddress.
    //
    pClientEle->pIrp = pIrp ;
    status = NbtCleanUpAddress(pClientEle,pClientEle->pDeviceContext);
#else
    // Note the special verifier  that is set during the cleanup phase.
    CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT_DOWN,tCLIENTELE,&status);

    //
    // clear the context value in the FileObject so that the client cannot
    // pass this to us again
    //
    (VOID)NTClearFileObjectContext(pIrp);
    pClientEle->pIrp = pIrp;

    pIrpsp = IoGetCurrentIrpStackLocation(((PIRP)pIrp));

    IrpFlags = pIrpsp->Control;
    IoMarkIrpPending(((PIRP)pIrp));

#endif

    NBT_DEREFERENCE_CLIENT(pClientEle);

    return(STATUS_PENDING);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtCleanUpAddress(
    IN  tCLIENTELE      *pClientEle,
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++
Routine Description:

    This Routine handles the first stage of releasing an address object.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status;
    tLOWERCONNECTION    *pLowerConn;
    tCONNECTELE         *pConnEle;
    tCONNECTELE         *pConnEleToDeref = NULL;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    CTELockHandle       OldIrq2;
    CTELockHandle       OldIrq3;
    PLIST_ENTRY         pHead,pEntry;
    PLIST_ENTRY         pEntryConn;
    tADDRESSELE         *pAddress;
    DWORD               i;
    LIST_ENTRY          TempList;

    // to prevent connections and datagram from the wire...remove from the
    // list of clients hooked to the address element
    //
    pAddress = pClientEle->pAddress;
    if (!pAddress)
    {
        // the address has already been deleted.
        return(STATUS_SUCCESS);
    }

    // lock the address to coordinate with receiving datagrams - to avoid
    // allowing the client to free datagram receive buffers in the middle
    // of DgramHndlrNotOs finding a buffer
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (!IsListEmpty(&pClientEle->RcvDgramHead))
    {
        PLIST_ENTRY     pHead;
        PLIST_ENTRY     pEntry;
        tRCVELE         *pRcvEle;
        PCTE_IRP        pRcvIrp;

        pHead = &pClientEle->RcvDgramHead;
        pEntry = pHead->Flink;

        // prevent any datagram from the wire seeing this list
        //
        InitializeListHead(&pClientEle->RcvDgramHead);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        while (pEntry != pHead)
        {
            pRcvEle   = CONTAINING_RECORD(pEntry,tRCVELE,Linkage);
            pRcvIrp   = pRcvEle->pIrp;

            CTEIoComplete(pRcvIrp,STATUS_NETWORK_NAME_DELETED,0);

            pEntry = pEntry->Flink;

            CTEMemFree(pRcvEle);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    // lock the client and the device context till we're done
    CTESpinLock(pClientEle,OldIrq2);

#ifndef VXD
    //
    // set to prevent reception of datagrams
    // (Vxd doesn't use this handler)
    //
    pClientEle->evRcvDgram = TdiDefaultRcvDatagramHandler;
#endif

    // so no one else can access the client element, set state to down. Therefore
    // the verify checks will fail anywhere the client is accessed in the code,
    // except in the NbtCloseAddress code which checks for this verifier value.
    //
    pClientEle->Verify = NBT_VERIFY_CLIENT_DOWN;

    //
    //  Disassociate all Connections from this address object, first starting
    //  with any active connections, then followup with any idle connections.
    //
    pDeviceContext = pClientEle->pDeviceContext;
    while ( !IsListEmpty( &pClientEle->ConnectActive ))
    {
        pEntry = RemoveHeadList( &pClientEle->ConnectActive ) ;
        InitializeListHead(pEntry);

        pConnEle = CONTAINING_RECORD( pEntry, tCONNECTELE, Linkage ) ;
        CTESpinLock(pConnEle,OldIrq3);
        NBT_REFERENCE_CONNECTION(pConnEle, REF_CONN_CLEANUP_ADDR); // Ensure conn stays around releasing lock below
        CTESpinFree(pConnEle,OldIrq3);

        CTESpinFree(pClientEle,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        //
        // if we had a connection in partial rcv state, make sure to remove it from
        // the list
        //
#ifdef VXD
        pLowerConn = pConnEle->pLowerConnId;

        if ( pLowerConn->StateRcv == PARTIAL_RCV &&
            (pLowerConn->fOnPartialRcvList == TRUE) )
        {
            RemoveEntryList( &pLowerConn->PartialRcvList ) ;
            pLowerConn->fOnPartialRcvList = FALSE;
            InitializeListHead(&pLowerConn->PartialRcvList);
        }
#endif

        //
        // Deref any connections referenced earlier if necessary
        //
        if (pConnEleToDeref)
        {
            NBT_DEREFERENCE_CONNECTION(pConnEleToDeref, REF_CONN_CLEANUP_ADDR);
        }
        pConnEleToDeref = pConnEle;

        status = NbtCleanUpConnection(pConnEle,pDeviceContext);

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        CTESpinLock(pClientEle,OldIrq2);
        CTESpinLock(pConnEle,OldIrq3);
        //
        // remove from this list again incase SessionSetupContinue has put it
        // back on the list - if no one has put it back on this list this
        // call is a no op since we initialized the list head above
        //
        RemoveEntryList(&pConnEle->Linkage);
        InitializeListHead (&pConnEle->Linkage);
        CHECK_PTR(pConnEle);
        SET_STATE_UPPER (pConnEle, NBT_IDLE);
        pConnEle->pClientEle = NULL;

        CTESpinFree(pConnEle,OldIrq3);
        CTESpinFree(pClientEle,OldIrq2);
        PUSH_LOCATION(0x80);

        //
        // put on the idle connection list, to wait for a close connection
        // to come down.
        // Bug # 405699
        // Do this only if the NTCleanupConnection did not run in the interim.
        //
        ASSERT(pConnEle->RefCount >= 1);
        if (!pConnEle->ConnectionCleanedUp)
        {
            ExInterlockedInsertTailList (&pDeviceContext->UpConnectionInUse,
                                         &pConnEle->Linkage,
                                         &pDeviceContext->LockInfo.SpinLock);
        }


        CTESpinLock(pClientEle,OldIrq2);
    }

    CTESpinFree(pClientEle,OldIrq2);
    CTESpinLock(pDeviceContext,OldIrq1);
    CTESpinLock(pClientEle,OldIrq2);
    // We are now holding the JointLock + DeviceLock + ClientLock

    //
    // each idle connection creates a lower connection to the transport for
    // inbound calls, therefore close a transport connection for each
    // connection in this list and then "dissassociate" the connection from
    // the address.
    //
    // make the list look empty so no connections will be serviced inbound
    // from the wire
    //
    while (!IsListEmpty(&pClientEle->ConnectHead))
    {
        pEntry = pClientEle->ConnectHead.Flink;
        RemoveEntryList (pEntry);
        pConnEle = CONTAINING_RECORD(pEntry,tCONNECTELE,Linkage);
        CHECK_PTR(pConnEle);
        ASSERT ((pConnEle->Verify==NBT_VERIFY_CONNECTION) || (pConnEle->Verify==NBT_VERIFY_CONNECTION_DOWN));

        CTESpinLock(pConnEle,OldIrq3);

        //
        // The Connection Element could be currently being cleaned up in NbtCleanUpConnection, so verify
        //
        if (pConnEle->Verify != NBT_VERIFY_CONNECTION)
        {
            InitializeListHead (&pConnEle->Linkage);
            CTESpinFree(pConnEle,OldIrq3);
            continue;
        }

        InsertTailList(&pDeviceContext->UpConnectionInUse,&pConnEle->Linkage);

        //
        // Cannot enable the following ASSERT. When NetBT deregister the address,
        // RDR will immediately close all its connections. However, the connections
        // could be residing in the system work item list, which can have a
        // refcount 4 (there could be more, but we haven't seen).
        //
        // ASSERT(pConnEle->RefCount == 1 || pConnEle->RefCount == 2);
        //

        SET_STATE_UPPER (pConnEle, NBT_IDLE);
        pConnEle->Verify = NBT_VERIFY_CONNECTION_DOWN;
        pConnEle->pClientEle = NULL;

        CTESpinFree(pConnEle,OldIrq3);

        //
        // Get a free connection to the transport and close it
        // for each free connection on this list.  It is possible that this
        // free list could be empty if an inbound connection was occurring
        // right at this moment.  In which case we would leave an extra connection
        // object to the transport lying around... not a problem.
        if (!IsListEmpty(&pDeviceContext->LowerConnFreeHead))
        {
            pEntryConn = RemoveHeadList(&pDeviceContext->LowerConnFreeHead);
            pLowerConn = CONTAINING_RECORD(pEntryConn,tLOWERCONNECTION,Linkage);
            InterlockedDecrement (&pDeviceContext->NumFreeLowerConnections);

            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.NbtCleanUpAddress: Closing Handle %p->%X\n",pLowerConn,pLowerConn->FileHandle));

            NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE);
        }
    }

    // check for any datagrams still outstanding. These could be waiting on
    // name queries to complete, so there could be timers associated with them
    //
    //  Complete any outstanding listens not on an active connection
    //
    //
    // make the list look empty so no connections will be serviced inbound
    // from the wire
    //
    //
    // Move all of the Listen requests onto a temporary list
    //
    InitializeListHead (&TempList);
    while (!IsListEmpty(&pClientEle->ListenHead))
    {
        pEntry = pClientEle->ListenHead.Flink;

        RemoveEntryList (pEntry);
        InsertTailList (&TempList, pEntry);
    }

    CTESpinFree(pClientEle, OldIrq2);
    CTESpinFree(pDeviceContext,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    while ((pEntry = TempList.Flink) != &TempList)
    {
        tLISTENREQUESTS  * pListen ;

        pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);
        RemoveEntryList(&pListen->Linkage);

        CTEIoComplete( pListen->pIrp, STATUS_NETWORK_NAME_DELETED, 0);
        CTEMemFree( pListen );
    }

    //
    // Deref any connections referenced earlier if necessary
    //
    if (pConnEleToDeref)
    {
        NBT_DEREFERENCE_CONNECTION(pConnEleToDeref, REF_CONN_CLEANUP_ADDR);
    }

#ifdef VXD
    //
    //  Complete any outstanding ReceiveAnys on this client element
    //
    DbgPrint("NbtCleanupAddress: Completing all RcvAny NCBs\r\n") ;
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLock(pClientEle,OldIrq2);

    pHead = &pClientEle->RcvAnyHead;
    pEntry = pHead->Flink;
    //
    // make the list look empty so no connections will be serviced inbound
    // from the wire
    //
    InitializeListHead(pHead);

    CTESpinFree(pClientEle, OldIrq2);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    while (pEntry != pHead )
    {
        PRCV_CONTEXT pRcvContext ;

        pRcvContext = CONTAINING_RECORD(pEntry,RCV_CONTEXT,ListEntry);
        pEntry = pEntry->Flink;

        CTEIoComplete( pRcvContext->pNCB, STATUS_NETWORK_NAME_DELETED, TRUE );

        FreeRcvContext( pRcvContext );
    }
#endif

    // *TODO the code above only removes names that are being resolved, and
    // leaves any datagram sends that are currently active with the
    // transport... these should be cancelled too by cancelling the irp..
    // Put this code in when the Irp cancelling code is done.

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtCloseConnection(
    IN  TDI_REQUEST         *pRequest,
    OUT TDI_REQUEST_STATUS  *pRequestStatus,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  PVOID               pIrp)

/*++

Routine Description

    This routine closes a connection object for the client.  Closing is
    different than disconnecting.  A disconnect breaks a connection with a
    peer whereas the close removes this connection endpoint from the local
    NBT only.  NtClose causes NTCleanup to be called first which does the
    session close.  This routine then does frees memory associated with the
    connection elements.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    tCONNECTELE         *pConnEle;
    NTSTATUS            status;

    CTEPagedCode();

    pConnEle = pRequest->Handle.ConnectionContext;
    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.NbtCloseConnection: Hit!! state = %X pConnEle %X\n",pConnEle->state,pConnEle));

#ifndef VXD
    CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION_DOWN,tCONNECTELE,&status);
    IoMarkIrpPending((PIRP)pIrp);     // Bug 261575: to make driver verifier happy
#else
    CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status);
    //
    // Call the Cleanup function, which NT calls from ntisol, NtCleanupConnection
    //
    status = NbtCleanUpConnection(pConnEle,pDeviceContext );
#endif

    // NOTE:
    // the NBtDereference routine will complete the irp and return pending
    //
    NbtTrace(NBT_TRACE_DISCONNECT, ("Close connection Irp=%p Upper=%p Lower=%p Client=%p Device=%p",
                            pIrp, pConnEle, pConnEle->pLowerConnId, pConnEle->pClientEle, pConnEle->pDeviceContext));

    pConnEle->pIrpClose = pIrp;
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CREATE);

    return (STATUS_PENDING);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtCleanUpConnection(
    IN  tCONNECTELE     *pConnEle,
    IN  tDEVICECONTEXT  *pDeviceContext
    )
/*++
Routine Description:

    This Routine handles running down a connection in preparation for a close
    that will come in next.  NtClose hits this entry first, and then it hits
    the NTCloseConnection next. If the connection was outbound, then the
    address object must be closed as well as the connection.  This routine
    mainly deals with the pLowerconn connection to the transport whereas
    NbtCloseConnection deals with closing pConnEle, the connection to the client.

    If DisassociateConnection is called by the client then it will do most of
    this cleanup.

Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status = STATUS_SUCCESS;
    NTSTATUS            Locstatus;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    CTELockHandle       OldIrq2;
    tLOWERCONNECTION    *pLowerConn;
    PLIST_ENTRY         pEntry;
    BOOLEAN             Originator = TRUE;
    ULONG               LowerState = NBT_IDLE;
    TDI_REQUEST         Request;
    tLISTENREQUESTS     *pListen;
    tCLIENTELE          *pClientEle;
    PLIST_ENTRY         pHead;
    LIST_ENTRY          TempList;
    BOOLEAN             QueueCleanupBool=FALSE;
    BOOLEAN             DoDisconnect=TRUE;
    BOOLEAN             FreeLower;

    NbtTrace(NBT_TRACE_DISCONNECT, ("Cleanup connection Upper=%p Lower=%p Client=%p Device=%p",
                            pConnEle, pConnEle->pLowerConnId, pConnEle->pClientEle, pConnEle->pDeviceContext));
    //
    // save the lower connection origination flag for later
    //
    pLowerConn = pConnEle->pLowerConnId;
    if (pLowerConn)
    {
        Originator = pLowerConn->bOriginator;
    }

    // the connection has not been associated so there is no further work to
    // do here.
    //
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    //
    // If the state is NBT_IDLE, the connection has already been disassociated,
    // and the next action will be a close, so change the verifier to allow
    // the close to complete
    //
    if (pConnEle->state != NBT_IDLE)
    {
        BOOLEAN     DoCleanup = FALSE;

        CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status);


        //
        // check if there is an outstanding name query going on and if so
        // then cancel the timer and call the completion routine.
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq2);
        CTESpinLock(pConnEle,OldIrq);

        if ((pConnEle->state == NBT_CONNECTING) ||
            (pConnEle->state == NBT_RECONNECTING))
        {
            status = CleanupConnectingState(pConnEle,pDeviceContext,&OldIrq,&OldIrq2);
            //
            // Pending means that the connection is currently being setup
            // by TCP, so do a disconnect, below.
            //
            if (status != STATUS_PENDING)
            {
                //
                // Since the connection is not setup with the transport yet
                // there is no need to call nbtdisconnect
                //
                DoDisconnect = FALSE;
           }
        }


        //
        // all other states of the connection are handled by NbtDisconnect
        // which will send a disconnect down the to transport and then
        // cleanup things.
        //

        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);

        CTEExReleaseResource(&NbtConfig.Resource);
        Request.Handle.ConnectionContext = (PVOID)pConnEle;

        if (DoDisconnect)
        {
            NbtTrace(NBT_TRACE_DISCONNECT, ("Abort connection ==> ConnEle %p", pConnEle));
            status = NbtDisconnect(
                                &Request,
                                &DefaultDisconnectTimeout,
                                TDI_DISCONNECT_ABORT,
                                NULL,
                                NULL,
                                NULL
                                );
            NbtTrace(NBT_TRACE_DISCONNECT, ("NbtDisconnect returns %!status!", status));
            ASSERT (STATUS_PENDING != status);
        }

        CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

        // we don't want to return Invalid connection if we disconnect an
        // already disconnected connection.
        if (status == STATUS_CONNECTION_INVALID)
        {
            status = STATUS_SUCCESS;
        }
    }

    CTESpinLock(pConnEle,OldIrq);

    //
    // if the verify value is already set to connection down then we have
    // been through here already and do not want to free a lower connection.
    // i.e. when the client calls close address then calls close connection.
    //
    if (pConnEle->Verify == NBT_VERIFY_CONNECTION)
    {
        FreeLower = TRUE;
    }
    else
    {
        FreeLower = FALSE;
    }

    pConnEle->Verify = NBT_VERIFY_CONNECTION_DOWN;

    //
    // Free any posted Rcv buffers that have not been filled
    //

    FreeRcvBuffers(pConnEle,&OldIrq);

    // check if any listens have been setup for this connection, and
    // remove them if so
    //
    pClientEle = pConnEle->pClientEle;
    CTESpinFree(pConnEle,OldIrq);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLock(pDeviceContext,OldIrq1);

    InitializeListHead (&TempList);
    if (pClientEle)
    {
        CTESpinLock(pClientEle,OldIrq2);

        pHead = &pClientEle->ListenHead;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);
            pEntry = pEntry->Flink;     // Don't reference freed memory

            if (pListen->pConnectEle == pConnEle)
            {
                RemoveEntryList(&pListen->Linkage);
                InsertTailList(&TempList, &pListen->Linkage);
            }
        }
        CTESpinFree(pClientEle,OldIrq2);
    }

    CTESpinLock(pConnEle,OldIrq2);

    //
    // Unlink the connection element from the client's list or the device context
    // if its not associated yet.
    //
    CHECK_PTR(pConnEle);
    if (pConnEle->state > NBT_IDLE)
    {
        // do the disassociate here
        //
        SET_STATE_UPPER (pConnEle, NBT_IDLE);
        pConnEle->pClientEle = NULL;
    }

    RemoveEntryList(&pConnEle->Linkage);
    InitializeListHead(&pConnEle->Linkage);

    CTESpinFree(pConnEle,OldIrq2);
    CTESpinFree(pDeviceContext,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    CTEExReleaseResource(&NbtConfig.Resource);

    while ((pEntry = TempList.Flink) != &TempList)
    {
        pListen = CONTAINING_RECORD(pEntry,tLISTENREQUESTS,Linkage);

        RemoveEntryList(&pListen->Linkage);
        CTEIoComplete (pListen->pIrp, STATUS_CANCELLED, 0);
        CTEMemFree (pListen);
    }

    // this could be status pending from NbtDisconnect...
    //
    return(status);
}
//----------------------------------------------------------------------------
extern
VOID
FreeRcvBuffers(
    tCONNECTELE     *pConnEle,
    CTELockHandle   *pOldIrq
    )
/*++
Routine Description:

    This Routine handles freeing any recv buffers posted by the client.
    The pConnEle lock could be held prior to calling this routine.

Arguments:

    pListHead
    pTracker

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                status = STATUS_SUCCESS;
    PLIST_ENTRY             pHead;

    pHead = &pConnEle->RcvHead;
    while (!IsListEmpty(pHead))
    {
        PLIST_ENTRY            pRcvEntry;
        PVOID                  pRcvElement ;

        KdPrint(("Nbt.FreeRcvBuffers: ***Freeing Posted Rcvs on Connection Cleanup!\n"));
        pRcvEntry = RemoveHeadList(pHead);
        CTESpinFree(pConnEle,*pOldIrq);

#ifndef VXD
        pRcvElement = CONTAINING_RECORD(pRcvEntry,IRP,Tail.Overlay.ListEntry);
        CTEIoComplete( (PIRP) pRcvElement, STATUS_CANCELLED,0);
#else
        pRcvElement = CONTAINING_RECORD(pRcvEntry, RCV_CONTEXT, ListEntry ) ;
        CTEIoComplete( ((PRCV_CONTEXT)pRcvEntry)->pNCB, STATUS_CANCELLED, 0);
#endif

        CTESpinLock(pConnEle,*pOldIrq);
    }

}



//----------------------------------------------------------------------------
NTSTATUS
FindPendingRequest(
    IN  tLMHSVC_REQUESTS        *pLmHRequests,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    OUT NBT_WORK_ITEM_CONTEXT   **pContextRet
    )
{
    PLIST_ENTRY             pEntry;
    NBT_WORK_ITEM_CONTEXT   *pWiContext = NULL;

    pWiContext = (NBT_WORK_ITEM_CONTEXT *) pLmHRequests->Context;
    if (pWiContext && (pWiContext->pTracker == pTracker))
    {
        pLmHRequests->Context = NULL;
        NTClearContextCancel (pWiContext);
        *pContextRet = pWiContext;

        return(STATUS_SUCCESS);
    }
    else
    {
        //
        // check the list for this tracker
        //
        pEntry = pLmHRequests->ToResolve.Flink;
        while (pEntry != &pLmHRequests->ToResolve)
        {
            pWiContext = CONTAINING_RECORD(pEntry,NBT_WORK_ITEM_CONTEXT,Linkage);
            pEntry = pEntry->Flink;

            if (pTracker == pWiContext->pTracker)
            {
                RemoveEntryList(pEntry);
                *pContextRet = pWiContext;
                return(STATUS_SUCCESS);
            }
        }
    }

    return (STATUS_UNSUCCESSFUL);
}


//----------------------------------------------------------------------------
NTSTATUS
CleanupConnectingState(
    IN  tCONNECTELE     *pConnEle,
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  CTELockHandle   *OldIrq,        // pConnEle lock
    IN  CTELockHandle   *OldIrq2        // joint lock
    )
/*++
Routine Description:

    This Routine handles running down a connection in the NBT_CONNECTING
    state since that connection could be doing a number of things such as:
        1)  Broadcast or WINS name Query
        2)  LmHosts name query
        3)  DNS name query
        4)  Tcp Connection setup

    The JointLock and the pConnEle lock are held when calling this routine.

Arguments:

    pConnEle        - ptr to the connection
    pDeviceContext  - the device context

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    tDGRAM_SEND_TRACKING    *pTrackerName = NULL;
    tDGRAM_SEND_TRACKING    *pTrackerConnect = NULL;
    tNAMEADDR               *pNameAddr = NULL;
    NBT_WORK_ITEM_CONTEXT   *pWiContext = NULL;
    tLOWERCONNECTION        *pLowerConn;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   Context;
    NTSTATUS                Locstatus;

    //
    // save the lower connection origination flag for later
    //
    pLowerConn = pConnEle->pLowerConnId;
    pTrackerConnect = (tDGRAM_SEND_TRACKING *) pConnEle->pIrpRcv;
    //CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&Locstatus);

    if (pConnEle->state == NBT_CONNECTING)
    {
        if ((pLowerConn) &&     // The LowerConnection could have gone away if it was deleted
            (pLowerConn->State == NBT_CONNECTING))
        {
            LOCATION(0x6E)
            //
            // We are setting up the TCP connection to the transport Now
            // so it is safe to call NbtDisconnect on this connection and
            // let that cleanup the mess - use this retcode to signify that.
            //
            return(STATUS_PENDING);

        }

        //
        // check if the name query is held up in doing a LmHost or DNS
        // Name Query
        //

        // check if there is an outstanding name query going on and if so
        // then cancel the timer and call the completion routine.
        //
        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.CleanupConnectingState: Cleanup in the Connecting State %X\n",pConnEle));

        pTrackerName = pTrackerConnect->pTrackerWorker;  // QueryNameOnNet tracker
        if (NBT_VERIFY_HANDLE (pTrackerName, NBT_VERIFY_TRACKER) && pTrackerConnect->pDestName)
        {
            status = FindInHashTable(NbtConfig.pRemoteHashTbl,
                                     pTrackerConnect->pDestName,
                                     NbtConfig.pScope,
                                     &pNameAddr);

            //
            // if there is a timer, then the connection setup is still
            // waiting on the name query.  If no timer, then we could be
            // waiting on an LmHosts or DNS name query or we
            // are waiting on the TCP connection setup - stopping the timer
            // should cleanup the tracker.
            //
            if (NT_SUCCESS(status))
            {
                tTIMERQENTRY    *pTimer;

                CHECK_PTR(pNameAddr);
                if (pNameAddr->NameTypeState & STATE_RESOLVED)
                {
                    //
                    // the name has resolved, but not started setting up the
                    // session yet, so return this status to tell the caller
                    // to cancel the tracker.
                    //
                    return(STATUS_UNSUCCESSFUL);
                }
                else if (pTimer = pNameAddr->pTimer)
                {
                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint(("Nbt.CleanupConnectingState: Cleanup During NameQuery: pConnEle=%X\n",
                                pConnEle));

                    pNameAddr->pTimer = NULL;
                    status = StopTimer(pTimer,&pClientCompletion,&Context);

#ifdef DEAD_CODE
                    //
                    // remove the name from the hash table, since it did not resolve
                    //
                    pNameAddr->NameTypeState &= ~STATE_RESOLVING;
                    pNameAddr->NameTypeState |= STATE_RELEASED;
                    pNameAddr->pTracker = NULL;
                    if (pClientCompletion)
                    {
                        NBT_DEREFERENCE_NAMEADDR (pNameAddr, TRUE);
                    }
#endif  // DEAD_CODE

                    pTrackerName = NULL;    // since StopTimer should have cleaned up the tracker, null it out
                }
                else
                {
                    //
                    // check if the name is waiting on an LmHost name Query
                    // or a DNS name query
                    //
                    status = FindPendingRequest (&LmHostQueries, pTrackerName, &pWiContext);
                    if (!NT_SUCCESS(status))
                    {
#ifndef VXD
                        status = FindPendingRequest (&DnsQueries, pTrackerName, &pWiContext);
                        if (!NT_SUCCESS(status))
                        {
                            status = FindPendingRequest (&CheckAddr, pTrackerName, &pWiContext);
                        }
#endif
                    }

                    if (NT_SUCCESS(status))
                    {
                        IF_DBG(NBT_DEBUG_NAMESRV)
                            KdPrint(("Nbt.CleanupConnectingState: Found pending NameQuery for pConnEle %X\n",
                                pConnEle));
                    }
                }
            }
            // ...else....
            // the completion routine has already run, so we are
            // in the state of starting a Tcp Connection, so
            // let nbtdisconnect handle it. (below).
            //
        }
    } // connnecting state
    else if (pConnEle->state == NBT_RECONNECTING)
    {
        LOCATION(0x77);
        //
        // this should signal NbtConnect not to do the reconnect
        //
        pTrackerConnect->pTrackerWorker->Flags = TRACKER_CANCELLED;
    }

    if (NT_SUCCESS(status))
    {
        // for items on the LmHost or Dns queues, get the completion routine
        // out of the Work Item context first
        //
        if (pWiContext)
        {
            LOCATION(0x78);
            pClientCompletion = pWiContext->ClientCompletion;
            Context = pWiContext->pClientContext;

            // for DNS and LmHosts, the tracker needs to be freed and the name
            // removed from the hash table
            //
            if (pTrackerName)
            {
                LOCATION(0x79);
                CTESpinFree(pConnEle,*OldIrq);
                CTESpinFree(&NbtConfig.JointLock,*OldIrq2);
                //
                // remove the name from the hash table, since it did not resolve
                //
                SetNameState (pTrackerName->pNameAddr, NULL, FALSE);
                NBT_DEREFERENCE_TRACKER(pTrackerName, FALSE);

                CTESpinLock(&NbtConfig.JointLock,*OldIrq2);
                CTESpinLock(pConnEle,*OldIrq);
            }

            CTEMemFree(pWiContext);
        }

        if (pClientCompletion)
        {
            LOCATION(0x7A);
            CTESpinFree(pConnEle,*OldIrq);
            CTESpinFree(&NbtConfig.JointLock,*OldIrq2);

            //
            // The completion routine is SessionSetupContinue
            // and it will cleanup the lower connection and
            // return the client's irp
            //
            status = STATUS_SUCCESS;
            CompleteClientReq(pClientCompletion, Context,STATUS_CANCELLED);

            CTESpinLock(&NbtConfig.JointLock,*OldIrq2);
            CTESpinLock(pConnEle,*OldIrq);
        }
        else
        {
            status = STATUS_UNSUCCESSFUL;
        }
    }

    return(status);
}

NTSTATUS
CheckConnect(
    IN tCONNECTELE  *pConnEle,
    IN tCLIENTELE   *pClientEle,
    IN tDEVICECONTEXT *pDeviceContext
    )
/*++
    This function should be called with the following locks held.
            NbtConfig.Resource
            NbtConfig.JointLock     SpinLock
            pClientEle              SpinLock
            pConnEle                SpinLock
 --*/
{
    /*
     * The state can be NBT_DISCONNECTING if this ConnectionElement
     * is being reused to setup a connection to a different Endpoint
     */
    if ((pConnEle->state != NBT_ASSOCIATED) &&
        (pConnEle->state != NBT_DISCONNECTING) &&
        (pConnEle->state != NBT_DISCONNECTED)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (pClientEle->Verify != NBT_VERIFY_CLIENT ) {
        return  (pClientEle->Verify == NBT_VERIFY_CLIENT_DOWN)? STATUS_CANCELLED: STATUS_INVALID_HANDLE;
    }

    /*
     * be sure the name is in the correct state for a connection
     */
    if ((!IsDeviceNetbiosless(pDeviceContext)) &&
        (pClientEle->pAddress->pNameAddr->NameTypeState & STATE_CONFLICT)) {
        return STATUS_DUPLICATE_NAME;
    }

    /*
     * this code handles the case when DHCP has not assigned an IP address yet
     */
    if (pDeviceContext->IpAddress == 0) {
        return STATUS_BAD_NETWORK_PATH;
    }
    return STATUS_SUCCESS;

/*
    //
    // this code handles the case when DHCP has not assigned an IP address yet
    //
    ASSERT (pDeviceContext->IpAddress == 0 || !pDeviceContext->pSessionFileObject);
    if (pDeviceContext->IpAddress == 0 || !pDeviceContext->pSessionFileObject) {
        return STATUS_BAD_NETWORK_PATH;
    }
    return STATUS_SUCCESS;
*/
}

NTSTATUS
NbtReConnect(
    IN tDGRAM_SEND_TRACKING    *pTracker,
    IN tIPADDRESS               DestIp
    )
{
    tCONNECTELE             *pConnEle;
    tCLIENTELE              *pClientEle;
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    CTELockHandle           OldIrq2;
    tIPADDRESS              IpAddress;
    tNAMEADDR               *pNameAddr;
    tLOWERCONNECTION        *pLowerConn;
    tDEVICECONTEXT          *pDeviceContext;

#ifdef _PNP_POWER_
    if (NbtConfig.Unloading) {
        KdPrint (("Nbt.NbtReConnect: --> ERROR New Connect request while Unloading!!!\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
#endif  // _PNP_POWER_

    NbtTrace(NBT_TRACE_OUTBOUND, ("Reconnect to %!ipaddr! for pTracker %p", DestIp, pTracker));

    /*
     * Only NETBIOS name can hit requery or retarget
     */
    ASSERT(pTracker->RemoteNameLength <= NETBIOS_NAME_SIZE);
    pConnEle = pTracker->pConnEle;

    //
    // Acquire this resource to co-ordinate with DHCP changing the IP
    // address
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    CTESpinLock(&NbtConfig.JointLock,OldIrq2);

    if ((!(NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION))) || (!(pClientEle = pConnEle->pClientEle))) {
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    CTESpinLock(pClientEle,OldIrq1);
    CTESpinLock(pConnEle,OldIrq);
    pDeviceContext = pClientEle->pDeviceContext;
    ASSERT(!IsDeviceNetbiosless(pDeviceContext));       // NetbiosLess device cannot hit reconnect or retarget case

    status = CheckConnect(pConnEle, pClientEle, pDeviceContext);
    if (status != STATUS_SUCCESS) {
        pConnEle->pIrp = NULL;
        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(pClientEle,OldIrq1);
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        NbtTrace(NBT_TRACE_OUTBOUND, ("CheckConnect returns %!status! for pTracker %p", status, pTracker));
        return status;
    }

    //
    // check if the Reconnect got cancelled
    //
    pTracker->pTrackerWorker = NULL;
    if (pTracker->Flags & TRACKER_CANCELLED) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("Connection Request is cancelled for pTracker %p", pTracker));

        //
        // if SessionSetupContinue has run, it has set the refcount to zero
        //
        if (pTracker->RefConn == 0) {
            FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        } else {
            pTracker->RefConn--;
        }
        pConnEle->pIrp = NULL;
        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(pClientEle,OldIrq1);
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        return STATUS_CANCELLED;
    }

    SET_STATE_UPPER (pConnEle, NBT_CONNECTING);

    // Increment the ref count so that a cleanup cannot remove
    // the pConnEle till the session is setup - one of these is removed when
    // the session is setup and the other is removed when it is disconnected.
    //
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
    ASSERT(pConnEle->RefCount >= 3);
    //
    // unlink the connection from the idle connection list and put on active list
    //
    RemoveEntryList(&pConnEle->Linkage);
    InsertTailList(&pClientEle->ConnectActive,&pConnEle->Linkage);

    // this field is used to hold a disconnect irp if it comes down during
    // NBT_CONNECTING or NBT_SESSION_OUTBOUND states
    //
    pConnEle->pIrpDisc = NULL;

    // if null then this is being called to reconnect and the tracker is already
    // setup.
    //
    // for the reconnect case we must skip most of the processing since
    // the tracker is all set up already.  All we need to do is
    // retry the connection.
    pTracker->RefConn++;
    pTracker->SendBuffer.pBuffer = pTracker->pRemoteName;

    // store the tracker in the Irp Rcv ptr so it can be used by the
    // session setup code in hndlrs.c in the event the destination is
    // between posting listens and this code should re-attempt the
    // session setup.  The code in hndlrs.c returns the tracker to its
    // free list and frees the session hdr memory too.
    //
    // We need to set this while holding the ConnEle lock because the client
    // can call NbtDisconnect while we are opening a Tcp handle and try to
    // set the Tracker's flag to TRACKER_CANCELLED
    //
    pConnEle->pIrpRcv = (PIRP)pTracker;

    CTESpinFree(pConnEle,OldIrq);
    CTESpinFree(pClientEle,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq2);

    // open a connection with the transport for this session
    status = NbtOpenAndAssocConnection (pDeviceContext, pConnEle, &pConnEle->pLowerConnId, '3'); 
    if (!NT_SUCCESS(status)) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("NbtOpenAndAssocConnection return %!status! for pTracker %p",
                                    status, pTracker));
        goto NbtConnect_Check;
    }

    // We need to track that this side originated the call so we discard this
    // connection at the end
    //
    pConnEle->pLowerConnId->bOriginator = TRUE;

    // set this state to associated so that the cancel irp routine
    // can differentiate the name query stage from the setupconnection
    // stage since pConnEle is in the Nbtconnecting state for both.
    //
    SET_STATE_LOWER (pConnEle->pLowerConnId, NBT_ASSOCIATED);

    // if this routine is called to do a reconnect, DO NOT close another
    // Lower Connection since one was closed the on the first
    // connect attempt.
    // the original "ToName" was stashed in this unused
    // ptr! - for the Reconnect case
    // the pNameAddr part of pTracker(pDestName) needs to pt. to
    // the name so that SessionSetupContinue can find the name
    pTracker->pDestName  = pTracker->pConnEle->RemoteName;
    pTracker->UnicodeDestName = NULL;       // We don't need unicode for NetBIOS name queries

    //
    // For a ReQuery request, DestIp is 0, otherwise for the ReTarget
    // case, DestIp is the new destination address
    //
    if (DestIp) {
        //
        // Retarget
        //
        status = FindNameOrQuery(pTracker->pConnEle->RemoteName,
                                pDeviceContext,
                                SessionSetupContinue,
                                pTracker,
                                (ULONG) (NAMETYPE_UNIQUE | NAMETYPE_GROUP | NAMETYPE_INET_GROUP),
                                &IpAddress,
                                &pNameAddr,
                                REF_NAME_CONNECT,
                                FALSE);
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NbtReConnect: name=<%16.16s:%x>, Status=%lx (%d of %s)\n",
                pConnEle->RemoteName, pConnEle->RemoteName[15], status, __LINE__, __FILE__));
    } else {
        //
        // This is the ReQuery attempt
        //
        BOOLEAN fNameReferenced = TRUE;

        status = ContinueQueryNameOnNet (pTracker,
                                         pTracker->pConnEle->RemoteName,
                                         pDeviceContext,
                                         SessionSetupContinue,
                                         &fNameReferenced);

        pNameAddr = pTracker->pNameAddr;
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
            KdPrint(("Nbt.NbtReConnect: name=<%16.16s:%x>, Status=%lx (%d of %s)\n",
                pConnEle->RemoteName, pConnEle->RemoteName[15], status, __LINE__, __FILE__));
    }

NbtConnect_Check:
    if ((status == STATUS_SUCCESS) && (!IpAddress)) {
        ASSERT (0);
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, FALSE);
        NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: returns %!status!", pTracker, status));
        status = STATUS_BAD_NETWORK_PATH;
    }

    if (status == STATUS_SUCCESS &&
        IsDeviceNetbiosless(pTracker->pDeviceContext) &&
        !IsSmbBoundToOutgoingInterface(IpAddress)) {

        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, FALSE);
        NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: Fail requests on unbound SmbDevice", pTracker));
        status = STATUS_BAD_NETWORK_PATH;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // be sure that a close or disconnect has not come down and
    // cancelled the tracker
    //
    if (status == STATUS_PENDING) {
        // i.e. pending was returned rather than success
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        CTEExReleaseResource(&NbtConfig.Resource);
        return(status);
    }

    if (status == STATUS_SUCCESS) {
        if (DestIp) {
            IpAddress = DestIp;
        }
        if ((pTracker->Flags & TRACKER_CANCELLED)) {
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, TRUE);
            status = STATUS_CANCELLED;
        } else {
            // set the session state to NBT_CONNECTING
            CHECK_PTR(pTracker->pConnEle);
            SET_STATE_UPPER (pTracker->pConnEle, NBT_CONNECTING);
            pTracker->pConnEle->BytesRcvd = 0;;
            pTracker->pConnEle->ReceiveIndicated = 0;

            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtReConnect: Setting Up Session(cached entry!!) to %16.16s <%X>, %p\n",
                    pNameAddr->Name,pNameAddr->Name[15], pConnEle));

            CHECK_PTR(pConnEle);
            // keep track of the other end's ip address
            // There may be a valid name address to use or it may have been
            // nulled out to signify "Do Another Name Query"

            pConnEle->pLowerConnId->SrcIpAddr = htonl(IpAddress);
            SET_STATE_LOWER (pConnEle->pLowerConnId, NBT_CONNECTING);

            pTracker->pTrackerWorker = NULL;

            //
            // We need to keep the pNameAddr data available for RAS
            //
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL);

            pTracker->RemoteIpAddress = IpAddress;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            status = TcpSessionStart(pTracker,
                                     IpAddress,
                                     (tDEVICECONTEXT *)pTracker->pDeviceContext,
                                     SessionStartupContinue,
                                     pTracker->DestPort);

            CTEExReleaseResource(&NbtConfig.Resource);

            //
            // if TcpSessionStart fails for some reason it will still
            // call the completion routine which will look after
            // cleaning up
            //

#ifdef RASAUTODIAL
            //
            // Notify the automatic connection driver
            // of the successful connection.
            //
            if (fAcdLoadedG && NT_SUCCESS(status))
            {
                CTELockHandle adirql;
                BOOLEAN fEnabled;

                CTEGetLock(&AcdDriverG.SpinLock, &adirql);
                fEnabled = AcdDriverG.fEnabled;
                CTEFreeLock(&AcdDriverG.SpinLock, adirql);
                if (fEnabled) {
                    NbtNoteNewConnection(pNameAddr, pDeviceContext->IpAddress);
                }
            }
#endif // RASAUTODIAL

            //
            // pNameAddr was referenced above for RAS, so deref it now!
            //
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL, FALSE);
            return(status);
        }
    }

    //
    // *** Error Handling Here ***
    //
    // ** We are still holding the JointLock **
    // unlink from the active connection list and put on idle list
    //
    CHECK_PTR(pConnEle);
    RelistConnection(pConnEle);
    CTESpinLock(pConnEle,OldIrq1);

    SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    pConnEle->pIrp = NULL;

    if (pLowerConn = pConnEle->pLowerConnId) {
        CHECK_PTR(pLowerConn);
        NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);

        // need to increment the ref count for DelayedCleanupAfterDisconnect to
        // work correctly since it assumes the connection got fully connected
        //
        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
        ASSERT(pLowerConn->RefCount == 2);
        ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));

        if (NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT)) {
            pDeviceContext = pLowerConn->pDeviceContext;
        } else {
            pDeviceContext = NULL;
        }

        NTQueueToWorkerThread(
                    &pLowerConn->WorkItemCleanUpAndWipeOut,
                    DelayedCleanupAfterDisconnect,
                    NULL,
                    pLowerConn,
                    NULL,
                    pDeviceContext,
                    TRUE);
    }

    CTESpinFree(pConnEle,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    CTEExReleaseResource(&NbtConfig.Resource);

    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);

    //
    // Undo the two references done above
    //
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

    return(status);
}

//----------------------------------------------------------------------------
extern
VOID
DelayedReConnect(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   DestAddr,
    IN  PVOID                   pUnused1,
    IN  tDEVICECONTEXT          *pUnused2
    )

/*++
Routine Description:

    This Routine handles seting up a DPC to send a session pdu so that the stack
    does not get wound up in multiple sends for the keep alive timeout case.

Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/
{
    NTSTATUS                status;
    tCONNECTELE             *pConnEle;
    CTELockHandle           OldIrq;
    PCTE_IRP                pIrp;

    CHECK_PTR(pTracker);
    // for retarget this is the destination address to connect to.

    pConnEle = pTracker->pConnEle;
    pTracker->pTimer = NULL;
    if (pTracker->Flags & TRACKER_CANCELLED)
    {
        CTELockHandle           OldIrq1;

        //
        // the connection setup got cancelled, return the connect irp
        //
        CTESpinLock(pConnEle,OldIrq1);
        if (pIrp = pConnEle->pIrp)
        {
            pConnEle->pIrp = NULL;
            CTESpinFree(pConnEle,OldIrq1);
            CTEIoComplete(pIrp,STATUS_CANCELLED,0);
        }
        else
        {
            CTESpinFree(pConnEle,OldIrq1);
        }

        //
        // if SessionSetupContinue has run, it has set the refcount to zero
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        if (pTracker->RefConn == 0)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        }
        else
        {
            pTracker->RefConn--;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }

        return;

    }

    PUSH_LOCATION(0x85);
    SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    status = NbtReConnect(pTracker, PtrToUlong(DestAddr));


    if (!NT_SUCCESS(status))
    {
        // Reset the Irp pending flag
        // No need to do this - pending has already be returned.
        //CTEResetIrpPending(pConnEle->pIrp);

        //
        // tell the client that the session setup failed
        //
        CTELockHandle           OldIrq1;

        CTESpinLock(pConnEle,OldIrq1);
        if (pIrp = pConnEle->pIrp)
        {
            pConnEle->pIrp = NULL;
            CTESpinFree(pConnEle,OldIrq1);

            CTEIoComplete( pIrp, STATUS_REMOTE_NOT_LISTENING, 0 ) ;
        } else {
            CTESpinFree(pConnEle,OldIrq1);
        }
    }
}

//----------------------------------------------------------------------------
NTSTATUS
NbtConnect(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp
    )

/*++
Routine Description:

    This Routine handles setting up a connection (netbios session) to
    destination. This routine is also called by the Reconnect code when
    doing a Retarget or trying to reach a destination that does not have
    a listen currently posted.  In this case the parameters mean different
    things.  pIrp could be a new Ipaddress to use (Retarget) and pCallinfo
    will be null.

Arguments:


Return Value:

    TDI_STATUS - status of the request

--*/

{
    tCONNECTELE             *pConnEle;
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    BOOLEAN                 fNoIpAddress;

    pConnEle = pRequest->Handle.ConnectionContext;

    NbtTrace(NBT_TRACE_OUTBOUND, ("TDI_CONNECT: pIrp %p pConnEle %p pClientEle %p",
                        pIrp, pConnEle, pConnEle->pClientEle));

    if (!pConnEle->pClientEle) {
        return (STATUS_INVALID_DEVICE_REQUEST);
    }

    ASSERT(pCallInfo);

    //
    // this code handles the When DHCP has not assigned an IP address yet
    //
    fNoIpAddress = (!pConnEle->pClientEle->pDeviceContext->pSessionFileObject) ||
         (pConnEle->pClientEle->pDeviceContext->IpAddress == 0);
#ifdef RASAUTODIAL
    if (fNoIpAddress && fAcdLoadedG) {
        CTELockHandle adirql;
        BOOLEAN fEnabled;

        //
        // There is no IP address assigned to the interface,
        // attempt to create an automatic connection.
        //
        CTEGetLock(&AcdDriverG.SpinLock, &adirql);
        fEnabled = AcdDriverG.fEnabled;
        CTEFreeLock(&AcdDriverG.SpinLock, adirql);
        if (fEnabled)
        {
            //
            // Set a special cancel routine on the irp
            // in case we get cancelled during the
            // automatic connection.
            //
            (VOID)NbtSetCancelRoutine( pIrp, NbtCancelPreConnect, pConnEle->pClientEle->pDeviceContext);
            if (NbtAttemptAutoDial(
                  pConnEle,
                  pTimeout,
                  pCallInfo,
                  pIrp,
                  0,
                  NbtRetryPreConnect))
            {
                return STATUS_PENDING;
            }
            //
            // We did not enqueue the irp on the
            // automatic connection driver, so
            // clear the cancel routine we set
            // above.
            //
            (VOID)NbtCancelCancelRoutine(pIrp);
        }
    }
#endif // RASAUTODIAL

    if (fNoIpAddress) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("returns STATUS_BAD_NETWORK_PATH"));
        return(STATUS_BAD_NETWORK_PATH);
    }

    // check the connection element for validity
    CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status)
    return NbtConnectCommon(pRequest, pTimeout, pCallInfo, pIrp);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtConnectCommon(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp
    )

/*++
Routine Description:

    This Routine handles setting up a connection (netbios session) to
    destination. This routine is also called by the DelayedReconnect code when
    doing a Retarget or trying to reach a destination that does not have
    a listen currently posted.  In this case the parameters mean different
    things.  pIrp could be a new Ipaddress to use (Retarget) and pCallinfo
    will be null.

Arguments:


Return Value:

    TDI_STATUS - status of the request

--*/

{
    TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;
    tCONNECTELE             *pConnEle;
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    CTELockHandle           OldIrq2;
    tIPADDRESS              IpAddress;
    PCHAR                   pToName;
    USHORT                  sLength;
    tSESSIONREQ             *pSessionReq = NULL;
    PUCHAR                  pCopyTo;
    tCLIENTELE              *pClientEle;
    ULONG                   NameLen;
    tDGRAM_SEND_TRACKING    *pTracker, *pQueryTracker;
    tNAMEADDR               *pNameAddr;
    tLOWERCONNECTION        *pLowerConn;
    tDEVICECONTEXT          *pDeviceContext;
    NBT_WORK_ITEM_CONTEXT   *pContext;
    tIPADDRESS              RemoteIpAddress;
    tLOWERCONNECTION        *pLowerDump;
    PLIST_ENTRY             pEntry;
    PCHAR                   pSessionName;
    tDEVICECONTEXT          *pDeviceContextOut = NULL;

#ifdef _PNP_POWER_
    if (NbtConfig.Unloading) {
        KdPrint (("Nbt.NbtConnectCommon: --> ERROR New Connect request while Unloading!!!\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
#endif  // _PNP_POWER_

#ifdef DBG
    {
        PIO_STACK_LOCATION pIrpSp;
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

        ASSERT(pIrpSp && pIrpSp->CompletionRoutine == NbtpConnectCompletionRoutine);
    }
#endif

    ASSERT (pCallInfo);

    /* If it is from local Irp, we always send an internal address format */
    if (pCallInfo->RemoteAddressLength < sizeof (TA_NETBT_INTERNAL_ADDRESS)) {
        ASSERT (0);
        return (STATUS_INVALID_ADDRESS);
    }

    ASSERT(((PTRANSPORT_ADDRESS)pCallInfo->RemoteAddress)->Address[0].AddressType == TDI_ADDRESS_TYPE_UNSPEC);
    CTEMemCopy(&TdiAddr,
            (PTDI_ADDRESS_NETBT_INTERNAL)((PTRANSPORT_ADDRESS)pCallInfo->RemoteAddress)->Address[0].Address,
            sizeof(TdiAddr));

    pToName = TdiAddr.OEMRemoteName.Buffer;
    NameLen = TdiAddr.OEMRemoteName.Length;

    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("Nbt.NbtConnectCommon: Remote Name: %*.*s, Length=%d\n", NameLen, NameLen, pToName, NameLen));

    pConnEle = pRequest->Handle.ConnectionContext;

    if (RemoteIpAddress = Nbt_inet_addr(pToName, SESSION_SETUP_FLAG)) {
        pDeviceContextOut = GetDeviceFromInterface (htonl(RemoteIpAddress), TRUE);
    }

    //
    // Acquire this resource to co-ordinate with DHCP changing the IP
    // address
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    CTESpinLock(&NbtConfig.JointLock,OldIrq2);

    NbtTrace(NBT_TRACE_OUTBOUND, ("\tpIrp %p: pConnEle %p: Connecting to %!NBTNAME!<%02x>",
                                    pIrp, pConnEle, pToName, (unsigned)pToName[15]));

    if ((!(NBT_VERIFY_HANDLE(pConnEle, NBT_VERIFY_CONNECTION))) || (!(pClientEle = pConnEle->pClientEle))) {
        KdPrint (("Nbt.NbtConnectCommon: --> ERROR Address not associated for pConnEle=<%p>\n", pConnEle));
        NbtTrace(NBT_TRACE_OUTBOUND, ("\tpIrp %p: ERROR Address not associated", pIrp));

        if (pDeviceContextOut) {
            NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, TRUE);
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        return(STATUS_INVALID_ADDRESS);
    }

    CTESpinLock(pClientEle,OldIrq1);
    CTESpinLock(pConnEle,OldIrq);
    pDeviceContext = pClientEle->pDeviceContext;

    status = CheckConnect(pConnEle, pClientEle, pDeviceContext);
    if (status != STATUS_SUCCESS) {
        NbtTrace(NBT_TRACE_OUTBOUND, ("\tpIrp %p: CheckConnect return %!status!", pIrp, status));

        pConnEle->pIrp = NULL;
        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(pClientEle,OldIrq1);
        if (pDeviceContextOut) {
            NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, TRUE);
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        return status;
    }

    if (RemoteIpAddress && NbtConfig.ConnectOnRequestedInterfaceOnly &&
            !IsDeviceNetbiosless(pDeviceContext) && pDeviceContext != pDeviceContextOut) {
        pConnEle->pIrp = NULL;
        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(pClientEle,OldIrq1);
        if (pDeviceContextOut) {
            NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, TRUE);
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        CTEExReleaseResource(&NbtConfig.Resource);
        NbtTrace(NBT_TRACE_OUTBOUND, ("\tpIrp %p: %!ipaddr! because Outgoing interface != RequestedInterface",
                    pIrp, RemoteIpAddress));
        return STATUS_BAD_NETWORK_PATH;
    }

    SET_STATE_UPPER (pConnEle, NBT_CONNECTING);

    // Increment the ref count so that a cleanup cannot remove
    // the pConnEle till the session is setup - one of these is removed when
    // the session is setup and the other is removed when it is disconnected.
    //
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
    ASSERT(pConnEle->RefCount >= 3);
    //
    // unlink the connection from the idle connection list and put on active list
    //
    RemoveEntryList(&pConnEle->Linkage);
    InsertTailList(&pClientEle->ConnectActive,&pConnEle->Linkage);

    // this field is used to hold a disconnect irp if it comes down during
    // NBT_CONNECTING or NBT_SESSION_OUTBOUND states
    //
    pConnEle->pIrpDisc = NULL;

    // we must store the client's irp in the connection element so that when
    // the session sets up, we can complete the Irp.
    ASSERT (pIrp);
    pConnEle->pIrp = (PVOID) pIrp;
    pConnEle->Orig = TRUE;
    pConnEle->SessionSetupCount = NBT_SESSION_SETUP_COUNT-1; // -1 for this attempt
    pConnEle->pClientEle->AddressType = TdiAddr.AddressType;
    pConnEle->AddressType = TdiAddr.AddressType;
    //
    //  Save the remote name while we still have it
    //
    CTEMemCopy (pConnEle->RemoteName, pToName, NETBIOS_NAME_SIZE);
    if (TdiAddr.OEMEndpointName.Buffer) {
        CTEMemCopy (pConnEle->pClientEle->EndpointName, TdiAddr.OEMEndpointName.Buffer, NETBIOS_NAME_SIZE);
        NbtTrace(NBT_TRACE_OUTBOUND, ("\tpIrp %p: Endpoint %!NBTNAME!<%02lx>",
                            pIrp,
                            TdiAddr.OEMEndpointName.Buffer,
                            TdiAddr.OEMEndpointName.Buffer[NETBIOS_NAME_SIZE-1]));
    }

    // get a buffer for tracking Session setup
    status = GetTracker(&pTracker, NBT_TRACKER_CONNECT);
    if (!NT_SUCCESS(status)) {
        SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitProc;
    }

    IF_DBG(NBT_DEBUG_NETBIOS_EX)
        KdPrint(("Nbt.NbtConnectCommon: Tracker %lx\n",pTracker));

    // the length of the Session Request Pkt is the 4 byte session hdr length + the
    // half ascii calling and called names + the scope length times 2, one for each name
    //
    sLength = (USHORT) (sizeof(tSESSIONREQ) + (NETBIOS_NAME_SIZE << 2) + (NbtConfig.ScopeLength <<1));

    pTracker->pNetbiosUnicodeEX = TdiAddr.pNetbiosUnicodeEX;
    pTracker->UnicodeRemoteName = NULL;
    if (TdiAddr.pNetbiosUnicodeEX) {
        pTracker->ucRemoteName = TdiAddr.pNetbiosUnicodeEX->RemoteName;
        ASSERT((pTracker->ucRemoteName.MaximumLength % sizeof(WCHAR)) == 0);
        ASSERT((pTracker->ucRemoteName.Length % sizeof(WCHAR)) == 0);

        if (TdiAddr.pNetbiosUnicodeEX->NameBufferType != NBT_WRITEONLY) {
            pTracker->UnicodeRemoteName = NbtAllocMem(pTracker->ucRemoteName.MaximumLength, NBT_TAG('F'));
            if (pTracker->UnicodeRemoteName) {
                pTracker->UnicodeRemoteNameLength = pTracker->ucRemoteName.Length;
                CTEMemCopy(pTracker->UnicodeRemoteName, pTracker->ucRemoteName.Buffer,
                        pTracker->ucRemoteName.Length+sizeof(WCHAR));
            }
        }
        // we ignore the failure because it isn't a critical feature. This failure only cause us not able to
        // take advantage of the UNICODE information and return the resolved DNS name to RDR.
    } else {
        pTracker->ucRemoteName.Buffer = NULL;
        pTracker->ucRemoteName.Length = 0;
        pTracker->ucRemoteName.MaximumLength = 0;
    }

    /*
     * Other netbt routines always assume that we have at least 16 bytes
     * for remote name.
     */
    if (NameLen < NETBIOS_NAME_SIZE) {
        pTracker->pRemoteName = NbtAllocMem(NETBIOS_NAME_SIZE, NBT_TAG('F'));
    } else {
        pTracker->pRemoteName = NbtAllocMem(NameLen, NBT_TAG('F'));
    }
    pSessionReq = (tSESSIONREQ *)NbtAllocMem(sLength,NBT_TAG('G'));

    if (pTracker->pRemoteName == NULL || pSessionReq == NULL) {
        if (pTracker->pRemoteName) {
            CTEMemFree(pTracker->pRemoteName);
            pTracker->pRemoteName = NULL;
        }
        if (pTracker->UnicodeRemoteName) {
            CTEMemFree(pTracker->UnicodeRemoteName);
            pTracker->UnicodeRemoteName = NULL;
        }
        if (pSessionReq) {
            CTEMemFree(pSessionReq);
            pSessionReq = NULL;
        }
        SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
        FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        status = STATUS_INSUFFICIENT_RESOURCES;
        NbtTrace(NBT_TRACE_OUTBOUND, ("\tpIrp %p: pTracker %p %!status!", pIrp, pTracker, status));
        goto ExitProc;
    }

    CTEMemCopy (pTracker->pRemoteName, pToName, NameLen);
    pTracker->RemoteNameLength      = NameLen;      // May be needed for Dns Name resolution
    pTracker->pDestName             = pTracker->pRemoteName;
    pTracker->UnicodeDestName       = pTracker->UnicodeRemoteName;   // bug #20697, #95241
    pTracker->SendBuffer.pBuffer    = pTracker->pRemoteName;
    pTracker->SendBuffer.Length     = 0;
    pTracker->SendBuffer.pDgramHdr  = pSessionReq;

    // this is a ptr to the name in the client's, Irp, so that address must
    // remain valid until this completes.  It should be valid, because we
    // do not complete the Irp until the transaction completes.  This ptr
    // is overwritten when the name resolves, so that it points the the
    // pNameAddr in the hash table.
    //
    pTracker->RefCount              = 1;
    pTracker->RefConn               = 1;
    pTracker->pClientIrp            = pIrp;
    pTracker->pTimeout              = pTimeout; // the timeout value is passed on through to the transport
    pTracker->Flags                 = SESSION_SETUP_FLAG;
    pTracker->pDeviceContext        = pDeviceContext;
    pTracker->pConnEle              = pConnEle;
#ifdef _NETBIOSLESS
    pTracker->DestPort              = pDeviceContext->SessionPort; // Port to Send to
#else
    pTracker->DestPort              = NBT_SESSION_TCP_PORT;
#endif

#ifndef VXD
    if (pConnEle->pClientEle->AddressType == TDI_ADDRESS_TYPE_NETBIOS_EX)
    {
       pSessionName = pConnEle->pClientEle->EndpointName;
    }
    else
#endif
    {
       pSessionName = pToName;
    }

    pSessionReq->Hdr.Type   = NBT_SESSION_REQUEST;
    pSessionReq->Hdr.Flags  = NBT_SESSION_FLAGS;
    pSessionReq->Hdr.Length = (USHORT)htons(sLength-(USHORT)sizeof(tSESSIONHDR));  // size of called and calling NB names.

    pTracker->SendBuffer.HdrLength = (ULONG)sLength;

    // put the Dest HalfAscii name into the Session Pdu
    pCopyTo = ConvertToHalfAscii ((PCHAR)&pSessionReq->CalledName.NameLength,
                                  pSessionName,
                                  NbtConfig.pScope,
                                  NbtConfig.ScopeLength);

    // put the Source HalfAscii name into the Session Pdu
    pCopyTo = ConvertToHalfAscii (pCopyTo,
                                  ((tADDRESSELE *)pClientEle->pAddress)->pNameAddr->Name,
                                  NbtConfig.pScope,
                                  NbtConfig.ScopeLength);

    // store the tracker in the Irp Rcv ptr so it can be used by the
    // session setup code in hndlrs.c in the event the destination is
    // between posting listens and this code should re-attempt the
    // session setup.  The code in hndlrs.c returns the tracker to its
    // free list and frees the session hdr memory too.
    //
    // We need to set this while holding the ConnEle lock because the client
    // can call NbtDisconnect while we are opening a Tcp handle and try to
    // set the Tracker's flag to TRACKER_CANCELLED
    //
    pConnEle->pIrpRcv = (PIRP)pTracker;

    CTESpinFree(pConnEle,OldIrq);
    CTESpinFree(pClientEle,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq2);

    // open a connection with the transport for this session
    status = NbtOpenAndAssocConnection (pDeviceContext, pConnEle, &pConnEle->pLowerConnId, '3'); 
    if (!NT_SUCCESS(status)) {
        goto NbtConnect_Check;
    }

    // We need to track that this side originated the call so we discard this
    // connection at the end
    //
    pConnEle->pLowerConnId->bOriginator = TRUE;

    // set this state to associated so that the cancel irp routine
    // can differentiate the name query stage from the setupconnection
    // stage since pConnEle is in the Nbtconnecting state for both.
    //
    SET_STATE_LOWER (pConnEle->pLowerConnId, NBT_ASSOCIATED);

    // if this routine is called to do a reconnect, DO NOT close another
    // Lower Connection since one was closed the on the first
    // connect attempt.
    //
    // remove a lower connection from the free list attached to the device
    // context since when this pConnEle was created, a lower connectin
    // was created then incase inbound calls were to be accepted on the
    // connection.  But since it is an outbound call, remove a lower
    // connection.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq2);  // Need this for DerefLowerConn
    CTESpinLock(pDeviceContext,OldIrq1);
    if (!pConnEle->LowerConnBlockRemoved &&
        !IsListEmpty(&pDeviceContext->LowerConnFreeHead))
    {
        pEntry = RemoveHeadList(&pDeviceContext->LowerConnFreeHead);
        pLowerDump = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);
        InterlockedDecrement (&pDeviceContext->NumFreeLowerConnections);

        pConnEle->LowerConnBlockRemoved = TRUE;

        //
        // close the lower connection with the transport
        //
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtConnectCommon: On Connect, close handle for pLower=<%p>\n", pLowerDump));
        NBT_DEREFERENCE_LOWERCONN (pLowerDump, REF_LOWC_CREATE, TRUE);
    }

    CTESpinFree(pDeviceContext,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq2);

    //
    // Check if the destination name is an IP address
    //
#ifndef VXD
    if (RemoteIpAddress)
    {
        //
        // Tell Outbound() not to schedule a re-connect attempt when a negative response is received.
        // Otherwise, we may end up with indefinitely loop
        //
        pTracker->ResolutionContextFlags = 0xFF;

        //
        // If the Address type is TDI_ADDRESS_TYPE_NETBIOS_EX, we have
        // been given a specific endpoint to use, so try to setup the
        // session using that Endpoint only
        //
        if (pConnEle->AddressType == TDI_ADDRESS_TYPE_NETBIOS_EX)
        {
            //
            // add this IP address to the remote hashtable
            //
            status = LockAndAddToHashTable(NbtConfig.pRemoteHashTbl,
                                           pToName,
                                           NbtConfig.pScope,
                                           RemoteIpAddress,
                                           NBT_UNIQUE,
                                           NULL,
                                           NULL,
                                           pDeviceContextOut,
                                           NAME_RESOLVED_BY_IP);
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
                KdPrint(("Nbt.NbtConnectCommon: AddRecordToHashTable <%-16.16s:%x>, Status %x\n",
                    pToName, pToName[15], status));

            if (NT_SUCCESS (status))    // SUCCESS if added first time, PENDING if name already existed!
            {
                SessionSetupContinue(pTracker, STATUS_SUCCESS);
                status = STATUS_PENDING;
            } else {
                NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p %!status!", pIrp, pTracker, status));
            }
        }
        //
        // Address type is TDI_ADDRESS_TYPE_NETBIOS
        // The endpoint name is the same as the IP address, so send a NodeStatus
        // request to the remote machine to get a proper Endpoint name
        //
        else
        {
            //
            // NbtSendNodeStatus will either return Pending or error -- it
            // should never return success!
            //
            pTracker->CompletionRoutine = SessionSetupContinue;
            status = NbtSendNodeStatus(pDeviceContext,
                                       pToName,
                                       NULL,
                                       pTracker,
                                       ExtractServerNameCompletion);
            if (!NT_SUCCESS(status)) {
                NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p %!status!", pIrp, pTracker, status));
            }
        }
    }
    else    // the name is not an IP address!
#endif
    {
        if (NameLen <= NETBIOS_NAME_SIZE) {
           status = FindNameOrQuery(pToName,
                                    pDeviceContext,
                                    SessionSetupContinue,
                                    pTracker,
                                    (ULONG) (NAMETYPE_UNIQUE | NAMETYPE_GROUP | NAMETYPE_INET_GROUP),
                                    &IpAddress,
                                    &pNameAddr,
                                    REF_NAME_CONNECT,
                                    FALSE);
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
                KdPrint(("Nbt.NbtConnectCommon: name=<%*.*s:%x>, Len=%d, Status=%lx (%d of %s)\n",
                    NameLen, NameLen, pConnEle->RemoteName,
                    pConnEle->RemoteName[15], NameLen, status, __LINE__, __FILE__));
            if (!NT_SUCCESS(status)) {
                NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p %!status!", pIrp, pTracker, status));
            } else if (NULL != pNameAddr && NULL != pNameAddr->FQDN.Buffer &&
                    pTracker->pNetbiosUnicodeEX &&
                    (pTracker->pNetbiosUnicodeEX->NameBufferType == NBT_READWRITE ||
                    pTracker->pNetbiosUnicodeEX->NameBufferType == NBT_WRITEONLY)) {

                USHORT  NameLength, MaxLength;

                NameLength = pNameAddr->FQDN.Length;
                MaxLength = pTracker->pNetbiosUnicodeEX->RemoteName.MaximumLength;
                if ((SHORT)NameLength > (SHORT)(MaxLength - sizeof(WCHAR))) {
                    NameLength = MaxLength - sizeof(WCHAR);
                }
                if ((SHORT)NameLength >= 0) {
                    CTEMemCopy(pTracker->pNetbiosUnicodeEX->RemoteName.Buffer,
                            pNameAddr->FQDN.Buffer, NameLength);
                    pTracker->pNetbiosUnicodeEX->RemoteName.Buffer[NameLength/sizeof(WCHAR)] = L'\0';
                    pTracker->pNetbiosUnicodeEX->RemoteName.Length = NameLength;
                    pTracker->pNetbiosUnicodeEX->NameBufferType    = NBT_WRITTEN;
                }
            }
        }

        //
        // if the name is longer than 16 bytes, it's not a netbios name.
        // skip wins, broadcast etc. and go straight to dns resolution
        // Also, we would go to DNS if the request came over the SmbDevice
        //
#ifdef _NETBIOSLESS
        if ((NameLen > NETBIOS_NAME_SIZE) ||
            ((IsDeviceNetbiosless(pDeviceContext)) && (!NT_SUCCESS(status))))
#else
        if (NameLen > NETBIOS_NAME_SIZE)
#endif
        {
            pTracker->AddressType = pConnEle->AddressType;
#ifndef VXD
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
                KdPrint(("Nbt.NbtConnectCommon: $$$$$ DNS for NETBIOS name=<%*.*s:%x>, Len=%d, Status=%lx (%d of %s)\n",
                    NameLen, NameLen, pConnEle->RemoteName,
                    pConnEle->RemoteName[15], NameLen, status, __LINE__, __FILE__));
#endif

            if (pContext = (NBT_WORK_ITEM_CONTEXT *)NbtAllocMem(sizeof(NBT_WORK_ITEM_CONTEXT),NBT_TAG('H'))) {
                pContext->pTracker = NULL;              // no query tracker
                pContext->pClientContext = pTracker;    // the client tracker
                pContext->ClientCompletion = SessionSetupContinue;
                pContext->pDeviceContext = pDeviceContext;

                //
                // Start the timer so that the request does not hang waiting for Dns!
                //
                StartLmHostTimer(pContext, FALSE);
                status = NbtProcessLmhSvcRequest (pContext, NBT_RESOLVE_WITH_DNS);
                if (!NT_SUCCESS (status)) {
                    NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p %!status!", pIrp, pTracker, status));
                    CTEMemFree(pContext);
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
                NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p %!status!", pIrp, pTracker, status));
            }
        }
    }

NbtConnect_Check:
    NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p %!status! %!ipaddr!", pIrp, pTracker, status, IpAddress));

    if ((status == STATUS_SUCCESS) && (!IpAddress)) {
        ASSERT(0);
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, FALSE);
        status = STATUS_BAD_NETWORK_PATH;
    }

    if (status == STATUS_SUCCESS &&
        IsDeviceNetbiosless(pTracker->pDeviceContext) &&
        !IsSmbBoundToOutgoingInterface(IpAddress)) {

        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, FALSE);

        NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p %!status!", pIrp, pTracker, status));

        status = STATUS_BAD_NETWORK_PATH;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pDeviceContextOut) {
        NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, TRUE);
        pDeviceContextOut = NULL;
    }

    //
    // be sure that a close or disconnect has not come down and
    // cancelled the tracker
    //
    if (status == STATUS_PENDING) {
        // i.e. pending was returned rather than success
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        CTEExReleaseResource(&NbtConfig.Resource);
        return(status);
    }

    if (status == STATUS_SUCCESS)
    {
        if ((pTracker->Flags & TRACKER_CANCELLED))
        {
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, TRUE);
            status = STATUS_CANCELLED;
        }
        else    // connect as long as we have an IP address (even to group names)
        {
            // set the session state to NBT_CONNECTING
            CHECK_PTR(pTracker->pConnEle);
            SET_STATE_UPPER (pTracker->pConnEle, NBT_CONNECTING);
            pTracker->pConnEle->BytesRcvd = 0;;
            pTracker->pConnEle->ReceiveIndicated = 0;

            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtConnectCommon: Setting Up Session(cached entry!!) to %16.16s <%X>, %p\n",
                    pNameAddr->Name,pNameAddr->Name[15], pConnEle));

            CHECK_PTR(pConnEle);
            // keep track of the other end's ip address
            // There may be a valid name address to use or it may have been
            // nulled out to signify "Do Another Name Query"

            pConnEle->pLowerConnId->SrcIpAddr = htonl(IpAddress);
            SET_STATE_LOWER (pConnEle->pLowerConnId, NBT_CONNECTING);

            pTracker->pTrackerWorker = NULL;

            //
            // We need to keep the pNameAddr data available for RAS
            //
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL);

            pTracker->RemoteIpAddress = IpAddress;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            status = TcpSessionStart(pTracker,
                                     IpAddress,
                                     (tDEVICECONTEXT *)pTracker->pDeviceContext,
                                     SessionStartupContinue,
                                     pTracker->DestPort);

            CTEExReleaseResource(&NbtConfig.Resource);

            //
            // if TcpSessionStart fails for some reason it will still
            // call the completion routine which will look after
            // cleaning up
            //

#ifdef RASAUTODIAL
            //
            // Notify the automatic connection driver
            // of the successful connection.
            //
            if (fAcdLoadedG && NT_SUCCESS(status))
            {
                CTELockHandle adirql;
                BOOLEAN fEnabled;

                CTEGetLock(&AcdDriverG.SpinLock, &adirql);
                fEnabled = AcdDriverG.fEnabled;
                CTEFreeLock(&AcdDriverG.SpinLock, adirql);
                if (fEnabled)
                {
                    NbtNoteNewConnection(pNameAddr, pDeviceContext->IpAddress);
                }
            }
#endif // RASAUTODIAL

            //
            // pNameAddr was referenced above for RAS, so deref it now!
            //
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL, FALSE);
            return(status);
        }
    }

    //
    // *** Error Handling Here ***
    //
    // ** We are still holding the JointLock **
    // unlink from the active connection list and put on idle list
    //
    CHECK_PTR(pConnEle);
    RelistConnection(pConnEle);
    CTESpinLock(pConnEle,OldIrq1);

    SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    pConnEle->pIrp = NULL;

    if (pLowerConn = pConnEle->pLowerConnId)
    {
        CHECK_PTR(pLowerConn);
        NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);

        // need to increment the ref count for DelayedCleanupAfterDisconnect to
        // work correctly since it assumes the connection got fully connected
        //
        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
        ASSERT(pLowerConn->RefCount == 2);
        ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));

        if (NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT))
        {
            pDeviceContext = pLowerConn->pDeviceContext;
        }
        else
        {
            pDeviceContext = NULL;
        }

        NTQueueToWorkerThread(
                    &pLowerConn->WorkItemCleanUpAndWipeOut,
                    DelayedCleanupAfterDisconnect,
                    NULL,
                    pLowerConn,
                    NULL,
                    pDeviceContext,
                    TRUE
                    );
    }

    CTESpinFree(pConnEle,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    CTEExReleaseResource(&NbtConfig.Resource);

    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);

    //
    // Undo the two references done above
    //
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

    NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p %!status!", pIrp, pTracker, status));

    return(status);


ExitProc:
    pConnEle->pIrp = NULL;

    //
    // Put the connection back on the idle connection list
    //
    RemoveEntryList(&pConnEle->Linkage);
    InsertTailList(&pClientEle->ConnectHead,&pConnEle->Linkage);

    CTESpinFree(pConnEle,OldIrq);
    CTESpinFree(pClientEle,OldIrq1);

    if (pDeviceContextOut) {
        NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, TRUE);
        pDeviceContextOut = NULL;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq2);
    CTEExReleaseResource(&NbtConfig.Resource);

    //
    // Undo the two references done above
    //
    NBT_DEREFERENCE_CONNECTION(pConnEle, REF_CONN_SESSION);
    NBT_DEREFERENCE_CONNECTION(pConnEle, REF_CONN_CONNECT);
    
    NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p %!status!", pIrp, pTracker, status));
    return(status);
}

//----------------------------------------------------------------------------
VOID
CleanUpPartialConnection(
    IN NTSTATUS             status,
    IN tCONNECTELE          *pConnEle,
    IN tDGRAM_SEND_TRACKING *pTracker,
    IN PIRP                 pClientIrp,
    IN CTELockHandle        irqlJointLock,
    IN CTELockHandle        irqlConnEle
    )
{
    CTELockHandle OldIrq;
    CTELockHandle OldIrq1;
    PIRP pIrpDisc;

    NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p pConnEle %p %!status!",
                        pClientIrp, pTracker, pConnEle, status));

    if (pConnEle->state != NBT_IDLE)
    {
        SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    }

    //
    // If the tracker is cancelled then NbtDisconnect has run and there is
    // a disconnect irp waiting to be returned.
    //
    pIrpDisc = NULL;

    if (pTracker->Flags & TRACKER_CANCELLED)
    {
        //
        // Complete the disconnect irp now too
        //
        pIrpDisc = pConnEle->pIrpDisc;
        status = STATUS_CANCELLED;
    }

    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);

    //
    // this will close the lower connection and dereference pConnEle once.
    //
    QueueCleanup (pConnEle, &irqlJointLock, &irqlConnEle);

    CTESpinFree(pConnEle,irqlConnEle);

    //
    // If the state is IDLE it means that NbtCleanupConnection has run and
    // the connection has been removed from the  list so don't add it to
    // the list again
    //
    if (pConnEle->state != NBT_IDLE)
    {
        RelistConnection(pConnEle);
    }
    CTESpinFree(&NbtConfig.JointLock,irqlJointLock);

    //
    // remove the last reference added in nbt connect.  The refcount will be 2
    // if nbtcleanupconnection has not run and 1, if it has.  So this call
    // could free pConnEle.
    //
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);

    NbtTrace(NBT_TRACE_OUTBOUND, ("pIrp %p: pTracker %p pConnEle %p %!status!",
                        pClientIrp, pTracker, pConnEle, status));

    if (status == STATUS_TIMEOUT)
    {
        status = STATUS_BAD_NETWORK_PATH;
    }

    CTEIoComplete(pClientIrp,status,0L);

    //
    // This is a disconnect irp that has been queued till the name query
    // completed
    //
    if (pIrpDisc)
    {
        NbtTrace(NBT_TRACE_OUTBOUND, ("TDI_DISCONNECT pIrp %p", pIrpDisc));

        CTEIoComplete(pIrpDisc,STATUS_SUCCESS,0L);
    }
}

//----------------------------------------------------------------------------
VOID
SessionSetupContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        )
/*++

Routine Description

    This routine handles setting up a session after a name has been resolved
    to an IP address.

    This routine is given as the completion routine to the "QueryNameOnNet" call
    in NbtConnect, above.  When a name query response comes in or the
    timer times out after N retries, this routine is called passing STATUS_TIMEOUT
    for a failure.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    tNAMEADDR               *pNameAddr = NULL;
    ULONG                   lNameType;
    PIRP                    pClientIrp;
    PIRP                    pIrpDisc;
    ULONG                   IpAddress;
    tCONNECTELE             *pConnEle;
    tLOWERCONNECTION        *pLowerConn;
    tDEVICECONTEXT          *pDeviceContext;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    pConnEle = pTracker->pConnEle;
    CHECK_PTR(pConnEle);

    NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: %!status!", pTracker, status));

    if (NT_SUCCESS(status)) {
        /*
         * Find the NameAddr and reference it
         */
        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        CTESpinLock(pConnEle,OldIrq);
        lNameType = NAMETYPE_UNIQUE;
        pNameAddr = FindNameRemoteThenLocal(pTracker, &IpAddress, &lNameType);
        if (pNameAddr) {
            // increment so the name cannot disappear and to be consistent
            // with FindNameOrQuery , which increments the refcount, so
            // we always need to deref it when the connection is setup.
            //
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT);
            // DEBUG
            ASSERT(pNameAddr->RefCount >= 2);
        } else {
            status = STATUS_BAD_NETWORK_PATH;
        }
        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }
    NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: %!ipaddr! %!status!", pTracker, IpAddress, status));

    /*
     * IsSmbBoundToOutgoingInterface won't work with JointLock held
     */
    if (NT_SUCCESS(status) &&
        IsDeviceNetbiosless(pTracker->pDeviceContext) &&
        !IsSmbBoundToOutgoingInterface(IpAddress)) {

        /* This status may be changed into STATUS_CANCELLED below */
        status = STATUS_BAD_NETWORK_PATH;
        NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: Client not bound to NetbiosSmb", pTracker));
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    CTESpinLock(pConnEle,OldIrq);

    if ((pTracker->Flags & TRACKER_CANCELLED) ||
        (!(pLowerConn = pConnEle->pLowerConnId)) ||     // The lower connection could have been cleaned up!
        (!NBT_VERIFY_HANDLE(pTracker->pDeviceContext, NBT_VERIFY_DEVCONTEXT)))
    {
        status = STATUS_CANCELLED;
    }

    // this is the QueryOnNet Tracker ptr being cleared rather than the
    // session setup tracker.
    //
    pTracker->pTrackerWorker = NULL;

    if (status == STATUS_SUCCESS)
    {
        // check the Remote table and then the Local table
        // a session can only be started with a unique named destination
        //
        if (lNameType & (NAMETYPE_UNIQUE | NAMETYPE_GROUP | NAMETYPE_INET_GROUP))
        {
            // set the session state, initialize a few things and setup a
            // TCP connection, calling SessionStartupContinue when the TCP
            // connection is up
            //
            CHECK_PTR(pConnEle);
            SET_STATE_LOWER (pLowerConn, NBT_CONNECTING);

            SET_STATE_UPPER (pConnEle, NBT_CONNECTING);
            pConnEle->BytesRcvd = 0;;
            pConnEle->ReceiveIndicated = 0;
            CHECK_PTR(pTracker);
            pTracker->pNameAddr = pNameAddr;

            if (NULL == pNameAddr->FQDN.Buffer && pTracker->pNetbiosUnicodeEX &&
                pTracker->pNetbiosUnicodeEX->NameBufferType == NBT_WRITTEN) {
                //
                // FQDN is available
                //  Save it into the pNameAddr
                //
                pNameAddr->FQDN.Buffer = NbtAllocMem(
                        pTracker->pNetbiosUnicodeEX->RemoteName.Length + sizeof(WCHAR),
                        NBT_TAG('F'));
                if (NULL != pNameAddr->FQDN.Buffer) {
                    pNameAddr->FQDN.Length = pTracker->pNetbiosUnicodeEX->RemoteName.Length;
                    pNameAddr->FQDN.MaximumLength = pNameAddr->FQDN.Length + sizeof(WCHAR);
                    CTEMemCopy(pNameAddr->FQDN.Buffer,
                        pTracker->pNetbiosUnicodeEX->RemoteName.Buffer,
                        pNameAddr->FQDN.Length
                        );
                    pNameAddr->FQDN.Buffer[pNameAddr->FQDN.Length/sizeof(WCHAR)] = L'\0';
                }
            }

            // keep track of the other end's ip address
            pConnEle->pLowerConnId->SrcIpAddr = htonl(IpAddress);

            IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.SessionSetupContinue: Setting Up Session(after Query) to %16.16s <%X>, %p\n",
                            pNameAddr->Name,pNameAddr->Name[15],
                            pTracker->pConnEle));

            ASSERT(pNameAddr->RefCount >= 2);
            //
            // increment pNameAddr once more since we may need to access
            // it below for RAS sessions
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL);

            pDeviceContext = pTracker->pDeviceContext;
            pTracker->RemoteIpAddress = IpAddress;

            CTESpinFree(pConnEle,OldIrq);
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            // start the session...
            status = TcpSessionStart (pTracker,
                                      IpAddress,
                                      (tDEVICECONTEXT *)pTracker->pDeviceContext,
                                      SessionStartupContinue,
                                      pTracker->DestPort);

            //
            // the only failure that could occur is if the pLowerConn
            // got separated from pConnEle, in which case some other
            // part of the code has disconnected and cleanedup, so
            // just return
            //

#ifdef RASAUTODIAL
            //
            // Notify the automatic connection driver
            // of the successful connection.
            //
            if (fAcdLoadedG && NT_SUCCESS(status))
            {
                CTELockHandle adirql;
                BOOLEAN fEnabled;

                CTEGetLock(&AcdDriverG.SpinLock, &adirql);
                fEnabled = AcdDriverG.fEnabled;
                CTEFreeLock(&AcdDriverG.SpinLock, adirql);
                if (fEnabled)
                {
                    NbtNoteNewConnection(pNameAddr, pDeviceContext->IpAddress);
                }
            }
#endif // RASAUTODIAL

            //
            // pNameAddr was referenced above for RAS, so deref it now!
            //
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_AUTODIAL, FALSE);
            return;
        }
        status = STATUS_BAD_NETWORK_PATH;
    }
    if (pNameAddr) {
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT, TRUE);
    }

    pClientIrp = pConnEle->pIrp;
    pConnEle->pIrp = NULL;

    if (STATUS_REMOTE_NOT_LISTENING != status)      // set in ExtractServerNameCompletion
    {
        status = STATUS_HOST_UNREACHABLE;
    }

    CleanUpPartialConnection(status, pConnEle, pTracker, pClientIrp, OldIrq1, OldIrq);
}

//----------------------------------------------------------------------------
VOID
QueueCleanup(
    IN  tCONNECTELE     *pConnEle,
    IN  CTELockHandle   *pOldIrqJointLock,
    IN  CTELockHandle   *pOldIrqConnEle
    )
/*++
Routine Description

    This routine handles Queuing a request to a worker thread to cleanup
    a connection(which basically closes the connection).

    This routine is called with the JointLock + ConnEle locks held
    and returns with them held

Arguments:

    pConnEle   - ptr to the upper connection

Return Values:

    VOID

--*/

{
    NTSTATUS            status;
    CTELockHandle       OldIrq;
    ULONG               State;
    BOOLEAN             DerefConnEle;
    tLOWERCONNECTION    *pLowerConn;
    tDEVICECONTEXT      *pDeviceContext = NULL;

    // to coordinate with RejectSession in hndlrs.c we are holding the spin lock
    // so we don't disconnect twice.
    //
    if ((pLowerConn = pConnEle->pLowerConnId) &&
        (pLowerConn->Verify == NBT_VERIFY_LOWERCONN) &&
        (pLowerConn->State > NBT_IDLE) &&
        (pLowerConn->State < NBT_DISCONNECTING))
    {

        CTESpinLock(pLowerConn,OldIrq);

        ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));
        if (pLowerConn->Verify != NBT_VERIFY_LOWERCONN)
        {
            //
            // The lower connection block has already been cleaned up
            // or is waiting to be cleaned up, so just return!
            //
// MALAM_FIX: Fix this so that we don't have to dereference the LowerConn to find this out.
// One scenario where this happens is if the device gets destroyed in DelayedNbtDeleteDevice
// and we end up dereferencing the lowerconn which causes it to get deleted!
//            ASSERT(0);
            CTESpinFree(pLowerConn,OldIrq);

            return;
        }

        IF_DBG(NBT_DEBUG_DISCONNECT)
            KdPrint(("Nbt.QueueCleanup: State=%X, Lower=%X Upper=%X\n",
                pLowerConn->State, pLowerConn,pLowerConn->pUpperConnection));

        CHECK_PTR(pLowerConn);
        State = pLowerConn->State;

        SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTING);

        if (pConnEle->state != NBT_IDLE)
        {
            SET_STATE_UPPER (pConnEle, NBT_DISCONNECTED);
        }

        NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);

        //
        // need to increment the ref count for DelayedCleanupAfterDisconnect to
        // work correctly since it assumes the connection got fully connected
        // Note: if this routine is called AFTER the connection is fully
        // connected such as in SessionStartupTimeout, then RefCount must
        // be decremented there to account for this increment.
        //
        if (State < NBT_SESSION_OUTBOUND)
        {
            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
        }

        ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));
        ASSERT (pLowerConn->RefCount > 1);

        CTESpinFree(pLowerConn,OldIrq);
        CTESpinFree(pConnEle,*pOldIrqConnEle);

        if (NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT))
        {
            pDeviceContext = pLowerConn->pDeviceContext;
        }

        status = NTQueueToWorkerThread(
                        &pLowerConn->WorkItemCleanUpAndWipeOut,
                        DelayedCleanupAfterDisconnect,
                        NULL,
                        pLowerConn,
                        NULL,
                        pDeviceContext,
                        TRUE
                        );

        CTESpinFree(&NbtConfig.JointLock,*pOldIrqJointLock);

        //
        // when the lower no longer points to the upper undo the reference
        // done in NbtConnect, or InBound.
        //
        NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

        CTESpinLock(&NbtConfig.JointLock,*pOldIrqJointLock);
        CTESpinLock(pConnEle,*pOldIrqConnEle);
    }
}

//----------------------------------------------------------------------------
extern
NTSTATUS
StartSessionTimer(
    tDGRAM_SEND_TRACKING    *pTracker,
    tCONNECTELE             *pConnEle
    )

/*++
Routine Description

    This routine handles setting up a timer to time the connection setup.
    JointLock Spin Lock is held before calling this routine.

Arguments:

    pConnEle - ptr to the connection structure

Return Values:

    VOID

--*/

{
    NTSTATUS        status;
    ULONG           Timeout = 0;
    CTELockHandle   OldIrq;

    CTESpinLock(pConnEle,OldIrq);

    if (pTracker->pTimeout)
    {
        CTEGetTimeout(pTracker->pTimeout,&Timeout);
    }

    // now start a timer to time the return of the session setup
    // message
    //
    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.StartSessionTimer: TimeOut = %X\n",Timeout));

    if (Timeout < NBT_SESSION_RETRY_TIMEOUT)
    {
        Timeout = NBT_SESSION_RETRY_TIMEOUT;
    }
    status = StartTimer(SessionStartupTimeout,
                        Timeout,
                        (PVOID)pTracker,       // context value
                        NULL,                  // context2 value
                        pTracker,
                        SessionStartupTimeoutCompletion,
                        pConnEle->pDeviceContext,
                        &pTracker->pTimer,
                        0,
                        TRUE);

    if (!NT_SUCCESS(status))
    {
        // we failed to get a timer, but the timer is only used
        // to handle the destination not responding to it is
        // not critical to get a timer... so carry on
        //
        CHECK_PTR(pTracker);
        pTracker->pTimer = NULL;
    }

    CTESpinFree(pConnEle,OldIrq);

    return(status);
}

//----------------------------------------------------------------------------
VOID
SessionStartupContinue(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo)
/*++
Routine Description

    This routine handles sending the session request PDU after the TCP
    connection has been setup to the destination IP address.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/

{
    tDGRAM_SEND_TRACKING        *pTracker;
    tCONNECTELE                 *pConnEle;
    ULONG                       lSentLength;
    TDI_REQUEST                 TdiRequest;
    PIRP                        pClientIrp;
    PIRP                        pIrpDisc = NULL;
    tLOWERCONNECTION            *pLowerConn;
    CTELockHandle               OldIrq;
    CTELockHandle               OldIrq1;
    BOOLEAN                     fNameReferenced = TRUE; // In FindNameOrQuery or SessionSetupContinue
    tNAMEADDR                   *pNameAddr;
    tDEVICECONTEXT              *pDeviceContext;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    pConnEle = (tCONNECTELE *)pTracker->pConnEle;
    pDeviceContext = pTracker->pDeviceContext;

    ASSERT (pTracker->Verify == NBT_VERIFY_TRACKER);
    CHECK_PTR (pConnEle);

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    CTESpinLock(pConnEle,OldIrq);

    NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: %!status!", pTracker, status));

    if (pTracker->Flags & TRACKER_CANCELLED)
    {
        status = STATUS_CANCELLED;
        pIrpDisc = pConnEle->pIrpDisc;  // Complete the Disconnect Irp that is pending too
    }

#ifdef MULTIPLE_WINS
    //
    // If we failed to establish a connection and we still have
    // not finished querying all the Name Servers, then continue
    // the Query process
    //
    if (NbtConfig.TryAllNameServers &&
#ifdef _NETBIOSLESS
        (!IsDeviceNetbiosless(pDeviceContext)) &&
#endif
        (pConnEle->pLowerConnId) &&
        (status != STATUS_CANCELLED) &&
        (!NT_SUCCESS(status)) &&
        (pTracker->ResolutionContextFlags != NAME_RESOLUTION_DONE))
    {
        SET_STATE_LOWER (pConnEle->pLowerConnId, NBT_ASSOCIATED);

        CTESpinFree(pConnEle,OldIrq);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

        //
        // See if we can get another IP address and re-try!
        //
        if (STATUS_PENDING == ContinueQueryNameOnNet (pTracker,
                                                      pTracker->pConnEle->RemoteName,
                                                      pDeviceContext,
                                                      SessionSetupContinue,
                                                      &fNameReferenced))
        {
            // i.e. pending was returned
            return;
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
        CTESpinLock(pConnEle,OldIrq);
        NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: %!status!", pTracker, status));
    }
#endif

    //
    // Set the pBuffer ptr = NULL so that we don't try to
    // set it as the Mdl->Next ptr in TdiSend!
    //
    if (pTracker->SendBuffer.pBuffer)
    {
        pTracker->SendBuffer.pBuffer = NULL;
    }

    pLowerConn = pConnEle->pLowerConnId;
    if ((NT_SUCCESS(status)) &&
        (!pLowerConn))
    {
        // in case the connection got disconnected during the setup phase,
        // check the lower conn value
        status = STATUS_UNSUCCESSFUL;
    }

    //
    // NbtDisconnect can cancel the tracker if a disconnect comes in during
    // the connecting phase.
    //
    if (NT_SUCCESS(status))
    {
#ifdef _NETBIOSLESS
        // *****************************************************************
        //
        // Skip session setup for message only mode
        //
        if (IsDeviceNetbiosless(pDeviceContext))
        {
            IF_DBG(NBT_DEBUG_NETBIOS_EX)
               KdPrint(("Nbt.SessionStartupContinue: skipping session setup\n"));

            // Here is where we fake out the data structures to move to the SESSION_UP state
            // We enter holding jointLock and pConnEle lock

            // zero out the number of bytes received so far, since this is a new connection
            pConnEle->BytesRcvd = 0;
            pConnEle->pIrpRcv = NULL;
            pClientIrp = pConnEle->pIrp;
            pConnEle->pIrp = NULL;
            SET_STATE_UPPER (pConnEle, NBT_SESSION_UP);

            CTESpinFree(pConnEle,OldIrq);

            if (fNameReferenced)
            {
                //
                // remove the reference done when FindNameOrQuery was called, or when
                // SessionSetupContinue ran
                //
                NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
            }

            //
            // Increment the reference count on a connection while it is connected
            // so that it cannot be deleted until it disconnects.
            //
            CTESpinLock(pLowerConn,OldIrq);

            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
            ASSERT(pLowerConn->RefCount == 2);
            SET_STATE_LOWER (pLowerConn, NBT_SESSION_UP);
            SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);

            CTESpinFree(pLowerConn,OldIrq);
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);

            // remove the reference added in nbt connect
            NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);

            // NOTE: the last reference done on pConnEle in NbtConnect is NOT undone
            // until the pLowerConn no longer points to pConnEle!!

            // the assumption is that if the connect irp was cancelled then the
            // client should be doing a disconnect or close shortly thereafter, so
            // there is no error handling code here.
            if (pClientIrp)
            {
                //
                // complete the client's connect request Irp
                //
#ifndef VXD
                CTEIoComplete (pClientIrp, STATUS_SUCCESS, 0 ) ;
#else
                CTEIoComplete (pClientIrp, STATUS_SUCCESS, (ULONG)pConnEle ) ;
#endif
            }

            return;
        }
        // *****************************************************************
#endif  // _NETBIOSLESS

        // set the session state to NBT_SESSION_OUTBOUND
        //
        SET_STATE_UPPER (pConnEle, NBT_SESSION_OUTBOUND);

        //
        // Increment the reference count on a connection while it is connected
        // so that it cannot be deleted until it disconnects.
        //
        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
        ASSERT(pLowerConn->RefCount == 2);

        SET_STATE_LOWER (pLowerConn, NBT_SESSION_OUTBOUND);
        SET_STATERCV_LOWER (pLowerConn, NORMAL, Outbound);

        // we need to pass the file handle of the connection to TCP.
        TdiRequest.Handle.AddressHandle = pLowerConn->pFileObject;

        // the completion routine is setup to free the pTracker memory block
        TdiRequest.RequestNotifyObject = SessionStartupCompletion;
        TdiRequest.RequestContext = (PVOID)pTracker;

        CTESpinFree(pConnEle,OldIrq);

        //
        // failure to get a timer causes the connection setup to fail
        //
        status = StartSessionTimer(pTracker,pConnEle);
        if (NT_SUCCESS(status))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            status = NbtSetCancelRoutine(pConnEle->pIrp, NbtCancelSession, pDeviceContext);
            if (!NT_SUCCESS(status))
            {
                //
                // We have closed down the connection by failing the call to
                // setup up the cancel routine - it ended up calling the
                // cancel routine.
                //
                //
                // remove the second reference added in nbtconnect
                //
                NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: %!status!", pTracker, status));

                if (pTracker->RefConn == 0) {
                    NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, FALSE);
                    FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
                } else {
                    pTracker->RefConn--;
                }

                NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
                return;
            }

            // the only data sent is the session request buffer which is in the pSendinfo
            // structure.
            status = TdiSend (&TdiRequest,
                              0,                  // send flags are not set
                              pTracker->SendBuffer.HdrLength,
                              &lSentLength,
                              &pTracker->SendBuffer,
                              0);

            //
            // the completion routine will get called with the errors and
            // handle them appropriately, so just return here
            //
            return;
        } else {
            NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: %!status!", pTracker, status));
        }
        CTESpinLock(pConnEle,OldIrq);
    }
    else
    {
        // if the remote station does not have a connection to receive the
        // session pdu on , then we will get back this status.  We may also
        // get this if the destination does not have NBT running at all. This
        // is a short timeout - 250 milliseconds, times 3.
        //
    }
    NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: %!status!", pTracker, status));

    //
    // this branch is taken if the TCP connection setup fails or the
    // tracker has been cancelled.
    //

    CHECK_PTR(pConnEle);

    pClientIrp = pConnEle->pIrp;
    pConnEle->pIrp = NULL;

    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.SessionStartupContinue: Failed, State=%X,TrackerFlags=%X pConnEle=%X\n",
            pConnEle->state, pTracker->Flags, pConnEle));

    //
    // remove the name from the hash table since  we did not connect
    // (only if the request was not cancelled)!
    //
    //
    // if it is in the remote table and still active...
    // and no one else is referencing the name, then delete it from
    // the hash table.
    //
    if (fNameReferenced)
    {
        if ((status != STATUS_CANCELLED) &&
            (pTracker->pNameAddr->Verify == REMOTE_NAME) &&
            (pTracker->pNameAddr->NameTypeState & STATE_RESOLVED) &&
            (pTracker->pNameAddr->RefCount == 2))
        {
            NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_REMOTE, TRUE);
        }
        //
        // remove the reference done when FindNameOrQuery was called, or when
        // SessionSetupContinue ran
        //
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
    }

    // Either the connection failed to get setup or the send on the
    // connection failed, either way, don't mess with disconnects, just
    // close the connection... If the Tracker was cancelled then it means
    // someother part of the code has done the disconnect already.
    //
    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);

    if (pConnEle->state != NBT_IDLE)
    {
        SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    }

    // Cache the fact that an attempt to set up a TDI connection failed. This will enable us to
    // weed out repeated attempts on the same remote address. The only case that is exempt is a
    // NETBIOS name which we let it pass through because it adopts a different name resolution
    // mechanism.

#ifndef VXD
    if (pConnEle->AddressType == TDI_ADDRESS_TYPE_NETBIOS_EX)
    {
        IF_DBG(NBT_DEBUG_NETBIOS_EX)
           KdPrint(("Nbt.SessionStartupContinue: Will avoid repeated attempts on a nonexistent address\n"));
        pConnEle->RemoteNameDoesNotExistInDNS = TRUE;
    }

    if (status == STATUS_IO_TIMEOUT)
    {
        status = STATUS_HOST_UNREACHABLE;
    }
    else if (status == STATUS_CONNECTION_REFUSED)
    {
        if (IsDeviceNetbiosless(pDeviceContext))
        {
            status = STATUS_REMOTE_NOT_LISTENING;
        }
        else
        {
            status = STATUS_BAD_NETWORK_PATH;
        }
    }
#else
    if (status == TDI_CONN_REFUSED || status == TDI_TIMED_OUT)
    {
        status = STATUS_BAD_NETWORK_PATH;
    }
#endif

    QueueCleanup (pConnEle, &OldIrq1, &OldIrq);

    CTESpinFree(pConnEle,OldIrq);


    //
    // put back on the idle connection list if nbtcleanupconnection has not
    // run and taken pconnele off the list (setting the state to Idle).
    //
    if (pConnEle->state != NBT_IDLE)
    {
        RelistConnection(pConnEle);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    //
    // remove the last reference added in nbt connect.  The refcount will be 2
    // if nbtcleanupconnection has not run and 1, if it has.  So this call
    // could free pConnEle.
    //
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);

    // the cancel irp routine in Ntisol.c sets the irp to NULL if it cancels
    // it.
    if (pClientIrp)
    {
        CTEIoComplete(pClientIrp,status,0L);
    }

    if (pIrpDisc)
    {
        CTEIoComplete(pIrpDisc,STATUS_SUCCESS,0L);
    }
}

//----------------------------------------------------------------------------
extern
VOID
SessionStartupCompletion(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo)
/*++
Routine Description

    This routine handles the completion of sending the session request pdu.
    It completes the Irp back to the client indicating the outcome of the
    transaction if there is an error otherwise it keeps the irp till the
    session setup response is heard.
    Tracker block is put back on its free Q and the
    session header is freed back to the non-paged pool.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/

{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;
    tCONNECTELE             *pConnEle;
    tLOWERCONNECTION        *pLowerConn;
    COMPLETIONCLIENT        CompletionRoutine = NULL;
    ULONG                   state;
    PCTE_IRP                pClientIrp;
    PCTE_IRP                pIrpDisc;
    tTIMERQENTRY            *pTimer;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    pConnEle = (tCONNECTELE *)pTracker->pConnEle;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pLowerConn = pConnEle->pLowerConnId;

    NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: %!status! pConnEle %p pLowerConn %p",
                            pTracker, status, pConnEle, pLowerConn));

    //
    // if OutBound or the SessionStartupTimeoutCompletion have run,
    // they have set the refcount to zero, so just cleanup!
    //
    if (pTracker->RefConn == 0)
    {
        //
        // remove the reference done when FindNameOrQuery was called, or when
        // SessionSetupContinue ran
        //
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
        FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
    else
    {
        pTracker->RefConn--;

        //
        // a failure status means that the transport could not send the
        // session startup pdu - if this happens, then disconnect the
        // connection and return the client's irp with the status code
        //
        if ((!NT_SUCCESS(status)))
        {
            // we must check the status first since it is possible that the
            // lower connection has disappeared already due to a disconnect/cleanup
            // in the VXD case anyway.  Only for a bad status can we be sure
            // that pConnEle is still valid.
            //
            CHECK_PTR(pTracker);
            if (pTimer = pTracker->pTimer)
            {
                pTracker->pTimer = NULL;
                StopTimer(pTimer,&CompletionRoutine,NULL);
            }

            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.SessionStartupCompletion: Failed, State=%X,TrackerFlags=%X CompletionRoutine=%X,pConnEle=%X\n",
                    pConnEle->state, pTracker->Flags, CompletionRoutine, pConnEle));

            //
            // Only if the timer has not expired yet do we kill off the connection
            // since if the timer has expired, it has already done this in
            // SessionStartupTimeout.
            //
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            if (CompletionRoutine)
            {
                (*CompletionRoutine) (pTracker, status);
            }
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }
    }

    //
    // remove the last reference added in nbt connect.  The refcount
    // will be 2 if nbtcleanupconnection has not run and 1, if it has.  So this call
    // could free pConnEle.
    //
    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION);
}


//----------------------------------------------------------------------------
VOID
SessionStartupTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles timing out a connection setup request.  The timer
    is started when the connection is started and the session setup
    message is about to be sent.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tDGRAM_SEND_TRACKING     *pTracker;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    // if pTimerQEntry is null then the timer is being cancelled, so do nothing
    if (!pTimerQEntry)
    {
        pTracker->pTimer = NULL;
        return;
    }

    NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: SessionStartupTimeout", pTracker));

    SessionStartupTimeoutCompletion (pTracker, STATUS_IO_TIMEOUT);
}


//----------------------------------------------------------------------------
VOID
SessionStartupTimeoutCompletion(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status
    )
{
    CTELockHandle            OldIrq;
    CTELockHandle            OldIrq1;
    CTELockHandle            OldIrq2;
    tCONNECTELE              *pConnEle;
    tLOWERCONNECTION         *pLowerConn;
    CTE_IRP                  *pIrp;
    enum eSTATE              State;

    NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: %!status!", pTracker, status));

    // kill the connection
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    pTracker->pTimer = NULL;

    if (!(pConnEle = pTracker->pConnEle) ||
        !(pLowerConn = pConnEle->pLowerConnId) ||
        !(pTracker == (tDGRAM_SEND_TRACKING *) pConnEle->pIrpRcv))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    NbtTrace(NBT_TRACE_OUTBOUND, ("pTracker %p: %!status! pConnEle %p pLowerConn %p",
                            pTracker, status, pConnEle, pLowerConn));

    CHECK_PTR(pConnEle);
    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.SessionStartupTimeout: pConnEle=<%x>-->State=<%x>\n", pConnEle, pConnEle->state));

    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.SessionStartupTimeout: pLowerConn=<%x>-->State=<%x>, TrackerFlags=<%x>\n",
            pLowerConn, pLowerConn->State, pTracker->Flags));

    CTESpinLock(pConnEle,OldIrq2);
    CTESpinLock(pLowerConn,OldIrq1);

    if ((pConnEle->state != NBT_SESSION_OUTBOUND) ||
        (!(pIrp = pConnEle->pIrp)))
    {
        CTESpinFree(pLowerConn,OldIrq1);
        CTESpinFree(pConnEle,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    pConnEle->pIrp = NULL;

    State = pConnEle->state;
    SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
    NBT_REFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION_TIMEOUT);
    pLowerConn->pUpperConnection = NULL;    // So that any response for this in Outbound does not succeed
    ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));

    CTESpinFree(pLowerConn,OldIrq1);

    QueueCleanup (pConnEle, &OldIrq, &OldIrq2);

    CTESpinFree(pConnEle,OldIrq2);

    //
    // Nbt_idle means that nbtcleanupConnection has run and the
    // connection is about to be deleted, so don't relist.
    //
    if (State != NBT_IDLE)
    {
        RelistConnection(pConnEle);
    }

    //
    // if SessionStartupCompletion has run, it has set the refcount to zero
    //
    if (pTracker->RefConn == 0)
    {
        if ((pTracker->pNameAddr->Verify == REMOTE_NAME) && // Remote names only!
            (pTracker->pNameAddr->NameTypeState & STATE_RESOLVED) &&
            (pTracker->pNameAddr->RefCount == 2))
        {
            //
            // If no one else is referencing the name, then delete it from
            // the hash table.
            //
            NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_REMOTE, TRUE);
        }

        //
        // remove the reference done when FindNameOrQuery was called, or when
        // SessionSetupContinue ran
        //
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
        FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
    }
    else
    {
        pTracker->RefConn--;
    }

    //
    // remove the reference done when FindNameOrQuery was called, or when
    // SessionSetupContinue ran
    //
    pConnEle->pIrpRcv = NULL;   // So that SessionStartupCompletion does not also try to cleanup!

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_SESSION_TIMEOUT);

    CTEIoComplete(pIrp, status, 0);
}

//----------------------------------------------------------------------------
extern
VOID
RelistConnection(
    IN  tCONNECTELE *pConnEle
        )
/*++

Routine Description

    This routine unlinks the ConnEle from the ConnectActive list and puts it
    back on the Connecthead.  It is used when a connection goes to
    NBT_ASSOCIATED state.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    tCLIENTELE          *pClientEle = pConnEle->pClientEle;

    //
    // If pClientEle is NULL, it means the client was most probably
    // cleaned up, and the connection should now be on the Device's
    // UpConnectionInUse list
    //
    ASSERT (NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN));
    if (pClientEle)
    {
        CTESpinLock(pClientEle,OldIrq);
        CTESpinLock(pConnEle,OldIrq1);
        ASSERT (NBT_VERIFY_HANDLE2 (pClientEle, NBT_VERIFY_CLIENT, NBT_VERIFY_CLIENT_DOWN));
        //
        // if the state is NBT_IDLE it means that NbtCleanupConnection has run
        // and removed the connection from its list in preparation for
        // freeing the memory, so don't put it back on the list
        //
        if (pConnEle->state != NBT_IDLE)
        {
            SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
            RemoveEntryList(&pConnEle->Linkage);
            InsertTailList(&pConnEle->pClientEle->ConnectHead,&pConnEle->Linkage);
        }
        CTESpinFree(pConnEle,OldIrq1);
        CTESpinFree(pClientEle,OldIrq);
    }
}


//----------------------------------------------------------------------------
NTSTATUS
NbtSend(
        IN  TDI_REQUEST     *pRequest,
        IN  USHORT          Flags,
        IN  ULONG           SendLength,
        OUT LONG            *pSentLength,
        IN  PVOID           *pBuffer,
        IN  tDEVICECONTEXT  *pContext,
        IN  PIRP            pIrp
        )
/*++

Routine Description

    ... does nothing now....

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    //
    // This routine is never hit since the NTISOL.C routine NTSEND actually
    // bypasses this code and passes the send directly to the transport
    //
    ASSERT(0);

    return(STATUS_SUCCESS);

}


//----------------------------------------------------------------------------
NTSTATUS
NbtListen(
    IN  TDI_REQUEST                 *pRequest,
    IN  ULONG                       Flags,
    IN  TDI_CONNECTION_INFORMATION  *pRequestConnectInfo,
    OUT TDI_CONNECTION_INFORMATION  *pReturnConnectInfo,
    IN  PVOID                       pIrp)

/*++
Routine Description:

    This Routine posts a listen on an open connection allowing a client to
    indicate that is prepared to accept inbound connections.  The ConnectInfo
    may contain an address to specify which remote clients may connect to
    the connection although we don't currently look at that info.

Arguments:


Return Value:

    ReturnConnectInfo - status of the request

--*/

{
    tCLIENTELE         *pClientEle;
    tCONNECTELE         *pConnEle;
    NTSTATUS            status;
    tLISTENREQUESTS     *pListenReq;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;

    pListenReq = NbtAllocMem(sizeof(tLISTENREQUESTS),NBT_TAG('I'));
    if (!pListenReq)
    {
        NbtTrace(NBT_TRACE_INBOUND, ("Out of memory"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // now find the connection object to link this listen record to
    pConnEle = ((tCONNECTELE *)pRequest->Handle.ConnectionContext);

    //
    // Find the client record associated with this connection
    //
    if ((!NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION)) ||  // NBT_VERIFY_CONNECTION_DOWN if cleaned up
        (!NBT_VERIFY_HANDLE ((pClientEle = pConnEle->pClientEle), NBT_VERIFY_CLIENT)))
    {
        CTEMemFree(pListenReq);
        NbtTrace(NBT_TRACE_INBOUND, ("Invalid Handle pConnEle<%p> pClientEle<%p>", pConnEle, pClientEle));
        return(STATUS_INVALID_HANDLE);
    }

    CTESpinLock(pClientEle,OldIrq);
    CTESpinLock(pConnEle,OldIrq1);

    //
    // Now reverify the Client and Connection handles, and ensure the Connection state is correct!
    //
    if ((!NBT_VERIFY_HANDLE (pConnEle, NBT_VERIFY_CONNECTION)) ||
        (!NBT_VERIFY_HANDLE (pClientEle, NBT_VERIFY_CLIENT)) ||
        (pConnEle->state != NBT_ASSOCIATED))
    {
        CTESpinFree(pConnEle,OldIrq1);
        CTESpinFree(pClientEle,OldIrq);
        CTEMemFree(pListenReq);
        NbtTrace(NBT_TRACE_INBOUND, ("Invalid state %x", pConnEle->state));
        return(STATUS_INVALID_HANDLE);
    }

    //
    // Fill in the Listen request
    //

    pListenReq->pIrp = pIrp;
    pListenReq->Flags = Flags;
    pListenReq->pConnectEle = pConnEle;
    pListenReq->pConnInfo = pRequestConnectInfo;
    pListenReq->pReturnConnInfo = pReturnConnectInfo;
    pListenReq->CompletionRoutine = pRequest->RequestNotifyObject;
    pListenReq->Context = pRequest->RequestContext;

    // queue the listen request on the client object
    InsertTailList(&pClientEle->ListenHead,&pListenReq->Linkage);

    status = NTCheckSetCancelRoutine(pIrp,(PVOID)NbtCancelListen,0);
    NbtTrace(NBT_TRACE_INBOUND, ("NTCheckSetCancelRoutine return %!status! for %!NBTNAME!<%02x>",
                status, pClientEle->pAddress->pNameAddr->Name,
                (unsigned)pClientEle->pAddress->pNameAddr->Name[15]));

    if (!NT_SUCCESS(status))
    {
        RemoveEntryList(&pListenReq->Linkage);
        status = STATUS_CANCELLED;
    }
    else
    {
        status = STATUS_PENDING;
    }

    CTESpinFree(pConnEle,OldIrq1);
    CTESpinFree(pClientEle,OldIrq);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtDisconnect(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  ULONG                       Flags,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PTDI_CONNECTION_INFORMATION pReturnInfo,
    IN  PIRP                        pIrp)

/*++
Routine Description:

    This Routine handles taking down a connection (netbios session).

Arguments:


Return Value:

    TDI_STATUS - status of the request

--*/

{
    tCONNECTELE             *pConnEle;
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq2;
    CTELockHandle           OldIrq3;
    tLOWERCONNECTION        *pLowerConn;
    ULONG                   LowerState = NBT_IDLE;
    ULONG                   StateRcv;
    BOOLEAN                 Originator = TRUE;
    PCTE_IRP                pClientIrp = NULL;
    BOOLEAN                 RelistIt = FALSE;
    BOOLEAN                 Wait;
    PCTE_IRP                pIrpDisc;

    pConnEle = pRequest->Handle.ConnectionContext;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDisconnect: state %X %X\n",pConnEle->state,pConnEle));

    // check the connection element for validity
    //CTEVerifyHandle(pConnEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status)

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if ((pConnEle->state <= NBT_ASSOCIATED) ||
        (pConnEle->state >= NBT_DISCONNECTING))
    {
        // the connection is not connected so reject the disconnect attempt
        // ( with an Invalid Connection return code ) - unless there is a
        // value stored in the flag
        // DiscFlag field which will be the status of a previous
        // disconnect indication from the transport.
        //
        if ((pConnEle->DiscFlag))
        {
            if (Flags == TDI_DISCONNECT_WAIT)
            {
                if (pConnEle->DiscFlag == TDI_DISCONNECT_ABORT)
                {
                    status = STATUS_CONNECTION_RESET;
                }
                else
                {
                    status = STATUS_GRACEFUL_DISCONNECT;
                }
            }
            else
            {
                status = STATUS_SUCCESS;
            }

            // clear the flag now.
            CHECK_PTR(pConnEle);
            pConnEle->DiscFlag = 0;
        }
        else
        {
            status = STATUS_CONNECTION_INVALID;
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return(status);
    }

    // to link and unlink upper and lower connections the Joint lock must
    // be held.  This allows coordination from the lower side and from
    // the upper side. - i.e. once the joint lock is held, the upper and lower
    // connections cannot become unlinked.
    //
    CTESpinLock(pConnEle,OldIrq2);

    // Do this check with the spin lock held to avoid a race condition
    // with a disconnect coming in from the transport at the same time.
    //

    pLowerConn = pConnEle->pLowerConnId;

    //
    // a disconnect wait is not really a disconnect, it is just there so that
    // when a disconnect occurs, the transport will complete it, and indicate
    // to the client there is a disconnect (instead of having a disconnect
    // indication handler) - therefore, for Disc Wait, do NOT change state.
    //
    CHECK_PTR(pConnEle);
    pIrpDisc = pConnEle->pIrpDisc;
    pConnEle->pIrpDisc  = NULL;
    if (Flags == TDI_DISCONNECT_WAIT)
    {

        //
        // save the Irp here and wait for a disconnect to return it
        // to the client.
        //
        if ((pConnEle->state == NBT_SESSION_UP) &&
            (!pConnEle->pIrpClose))
        {
            pConnEle->pIrpClose = pIrp;
            status = STATUS_PENDING;

            //
            // call this routine to check if the cancel flag has been
            // already set and therefore we must return the irp now
            //
            status = NbtSetCancelRoutine(pIrp, NbtCancelDisconnectWait,pLowerConn->pDeviceContext);
            //
            // change the ret status so if the irp has been cancelled,
            // driver.c will not also return it, since NbtSetCancelRoutine
            // will call the cancel routine and return the irp.
            //
            status = STATUS_PENDING;
        }
        else
        {
            status = STATUS_CONNECTION_INVALID;
        }


        CTESpinFree(pConnEle,OldIrq2);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return(status);
    }
    else
    {
        if (pLowerConn)
        {
            if (pConnEle->state > NBT_ASSOCIATED)
            {
                ULONG                   state = pConnEle->state;
                tDGRAM_SEND_TRACKING    *pTracker;

                pTracker = (tDGRAM_SEND_TRACKING *)pConnEle->pIrpRcv;

                switch (state)
                {
                    case NBT_RECONNECTING:
                    {
                        //
                        // the connection is waiting on the Exworker Q to run
                        // nbtreconnect. When that runs the connect irp is
                        // returned.
                        //
                        pTracker->Flags |= TRACKER_CANCELLED;

                        CTESpinFree(pConnEle,OldIrq2);
                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        CTESpinLock(pConnEle,OldIrq);
                        FreeRcvBuffers(pConnEle,&OldIrq);
                        CTESpinFree(pConnEle,OldIrq);

                        return(STATUS_SUCCESS);
                    }

                    case NBT_SESSION_OUTBOUND:
                    {
                        tTIMERQENTRY            *pTimerEntry;

                        LOCATION(0x66)
                        if (pTimerEntry = pTracker->pTimer)
                        {
                            COMPLETIONCLIENT  ClientRoutine;
                            PVOID             pContext;

                            //
                            // the Session Setup Message has been sent
                            // so stop the SessionSetup Timer.
                            //
                            LOCATION(0x67)
                            CHECK_PTR(pTracker);
                            pTracker->pTimer = NULL;
                            CTESpinFree(pConnEle,OldIrq2);

                            StopTimer(pTimerEntry,&ClientRoutine,&pContext);

                            CTESpinFree(&NbtConfig.JointLock,OldIrq);
                            if (ClientRoutine)
                            {
                                (* ClientRoutine) (pContext, STATUS_CANCELLED);
                            }
                            // else...
                            // the timer has completed and called QueueCleanup
                            // so all we need to do is return here.
                        }
                        else
                        {
                            ASSERTMSG("Nbt:In outbound state, but no timer.../n",0);
                            pTracker->Flags |= TRACKER_CANCELLED;
                            CTESpinFree(pConnEle,OldIrq2);
                            CTESpinFree(&NbtConfig.JointLock,OldIrq);
                        }

                        return(STATUS_SUCCESS);
                    }

                    case NBT_CONNECTING:
                    {
                        //
                        // This searchs for timers outstanding on name queries
                        // and name queries held up on Lmhosts or Dns Qs
                        //
                        LOCATION(0x69)
                        status = CleanupConnectingState(pConnEle,pLowerConn->pDeviceContext,&OldIrq2,&OldIrq);
                        if (status == STATUS_UNSUCCESSFUL)
                        {
                            LOCATION(0x6A)
                            //
                            // set this flag to tell sessionsetupcontinue  or
                            // SessionStartupContinue not to process
                            // anything, except to free the tracker
                            //
                            pTracker->Flags = TRACKER_CANCELLED;

                            //
                            // failed to cancel the name query so do not deref
                            // pConnEle yet.
                            //
                            //
                            // hold on to disconnect irp here - till name query is done
                            // then complete both the connect and disconnect irp
                            //
                            if (pIrpDisc)
                            {
                                status = STATUS_CONNECTION_INVALID;
                            }
                            else
                            {
                                pConnEle->pIrpDisc = pIrp;
                            }

                            status = STATUS_PENDING;
                            ASSERT (NULL != pIrp);
                        }
                        else if (status == STATUS_PENDING)
                        {
                            LOCATION(0x6B)
                            // the connection is being setup with the transport
                            // so disconnect below
                            //

                            pTracker->Flags = TRACKER_CANCELLED;
                            //
                            // DelayedCleanupAfterDisconnect expects this ref count
                            // to be 2, meaning that it got connected, so increment
                            // here
                            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CONNECTED);
                            break;
                        }

                        CTESpinFree(pConnEle,OldIrq2);
                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        return(status);
                    }
                }   // switch

                CTESpinLock(pLowerConn,OldIrq3);

                if (pConnEle->state != NBT_SESSION_UP)
                {   //
                    // do an abortive disconnect to be sure it completes now.
                    //
                    Flags = TDI_DISCONNECT_ABORT;
                }

                LOCATION(0x6C)
                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtDisconnect: LowerConn,state %X,Src %X %X\n",
                        pLowerConn->State,pLowerConn->SrcIpAddr,pLowerConn));

                ASSERT(pConnEle->RefCount > 1);

                Originator = pLowerConn->bOriginator;

                //
                // the upper connection is going to be put back on its free
                // list, and the lower one is going to get a Disconnect
                // request, so put the upper back in associated, and separate
                // the upper and lower connections
                //
                SET_STATE_UPPER (pConnEle, NBT_ASSOCIATED);
                CHECK_PTR(pConnEle);
                CHECK_PTR(pLowerConn);
                NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);

                LowerState = pLowerConn->State;
                StateRcv = pLowerConn->StateRcv;

//
// if we had a connection in partial rcv state, make sure to remove it from
// the list
//
#ifdef VXD
                if ((pLowerConn->StateRcv == PARTIAL_RCV) &&
                    (pLowerConn->fOnPartialRcvList == TRUE))
                {
                    RemoveEntryList (&pLowerConn->PartialRcvList);
                    pLowerConn->fOnPartialRcvList = FALSE;
                    InitializeListHead(&pLowerConn->PartialRcvList);
                }
#endif

                SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTING);
                pLowerConn->bDisconnectIrpPendingInTCP = TRUE;
                SetStateProc (pLowerConn, RejectAnyData);

                if (!pConnEle->pIrpDisc)
                {
                    pLowerConn->pIrp  = pIrp ;
                }

                CTESpinFree(pLowerConn,OldIrq3);

                PUSH_LOCATION(0x84);
                CTESpinFree(pConnEle,OldIrq2);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                // remove the reference added to pConnEle when pLowerConn pointed
                // to it, since that pointer link was just removed.
                // if the state is not disconnecting...
                //
                NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

                RelistIt = TRUE;
            }
            else
            {
                LOCATION(0x6D)
                PUSH_LOCATION(0x83);
                CHECK_PTR(pConnEle);
                CHECK_PTR(pLowerConn);
                NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);
                StateRcv = NORMAL;

                CTESpinFree(pConnEle,OldIrq2);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
            }

            //
            // check for any RcvIrp that may be still around
            //
            CTESpinLock(pLowerConn,OldIrq);
            if (StateRcv == FILL_IRP)
            {
                if (pConnEle->pIrpRcv)
                {
                    PCTE_IRP    pIrp;

                    IF_DBG(NBT_DEBUG_DISCONNECT)
                    KdPrint(("Nbt.NbtDisconnect: Cancelling RcvIrp on Disconnect!!!\n"));
                    pIrp = pConnEle->pIrpRcv;
                    CHECK_PTR(pConnEle);
                    pConnEle->pIrpRcv = NULL;

                    CTESpinFree(pLowerConn,OldIrq);
#ifndef VXD
                    IoCancelIrp(pIrp);
#else
                    CTEIoComplete(pIrp,STATUS_CANCELLED,0);
#endif

                    CHECK_PTR(pConnEle);
                    pConnEle->pIrpRcv = NULL;
                }
                else
                {
                    CTESpinFree(pLowerConn,OldIrq);
                }

                //
                // when the disconnect irp is returned we will close the connection
                // to avoid any peculiarities. This also lets the other side
                // know that we did not get all the data.
                //
                Flags = TDI_DISCONNECT_ABORT;
            }
            else
            {
                CTESpinFree(pLowerConn,OldIrq);
            }

            //
            // check if there is still data waiting in the transport for this end point
            // and if so do an abortive disconnect to let the other side know that something
            // went wrong
            //
            if (pConnEle->BytesInXport)
            {
                PUSH_LOCATION(0xA0);
                IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.NbtDisconnect: Doing ABORTIVE disconnect, dataInXport = %X\n",
                    pConnEle->BytesInXport));
                Flags = TDI_DISCONNECT_ABORT;
            }
        }
        else
        {
            CTESpinFree(pConnEle,OldIrq2);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

        }
    }

    ASSERT(pConnEle->RefCount > 0);

    CTESpinLock (pConnEle,OldIrq);
    FreeRcvBuffers (pConnEle,&OldIrq);
    CTESpinFree (pConnEle,OldIrq);

    if (RelistIt)
    {
        //
        // put the upper connection back on its free list
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        RelistConnection (pConnEle);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    //
    // disconnect (and delete) the lower connection
    //
    // when nbtdisconnect is called from cleanup connection it does not
    // have an irp and it wants a synchronous disconnect, so set wait
    // to true in this case
    //
    if (!pIrp)
    {
        Wait = TRUE;
    }
    else
    {
        Wait = FALSE;
    }

    status = DisconnectLower(pLowerConn,LowerState,Flags,pTimeout,Wait);
    ASSERT (!Wait || STATUS_PENDING != status);

    if ((pConnEle->pIrpDisc) &&
        (status != STATUS_INSUFFICIENT_RESOURCES))
    {
        // don't complete the disconnect irp yet if we are holding onto
        // it
        status = STATUS_PENDING;
    }

    return(status);

}
//----------------------------------------------------------------------------
NTSTATUS
DisconnectLower(
    IN  tLOWERCONNECTION     *pLowerConn,
    IN  ULONG                 state,
    IN  ULONG                 Flags,
    IN  PVOID                 Timeout,
    IN  BOOLEAN               Wait
    )

/*++
Routine Description:

    This Routine handles disconnecting the lower half of a connection.


Arguments:


Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS                status=STATUS_SUCCESS;
    tDGRAM_SEND_TRACKING    *pTracker;

    if (pLowerConn)
    {
        //
        // no need to disconnect a connection in the connecting state since it
        // hasn't connected yet...i.e. one where the destination refuses to
        // accept the tcp connection.... hmmmm maybe we do need to disconnect
        // a connection in the connecting state, since the transport is
        // actively trying to connect the connection, and we need to stop
        // that activity - so the Upper connection is connecting during
        // name resolution, but the lower one isn't connecting until the
        // tcp connection phase begins.
        //
        if ((state >= NBT_CONNECTING) && (state <= NBT_SESSION_UP))
        {
            //
            // got a cleanup for an active connection, so send a disconnect down
            // to the transport
            //
            IF_DBG(NBT_DEBUG_DISCONNECT)
                KdPrint(("Nbt.DisconnectLower: Waiting for disconnect...\n"));

            status = GetTracker(&pTracker, NBT_TRACKER_DISCONNECT_LOWER);
            if (NT_SUCCESS(status))
            {
                ULONG   TimeVal;

                // this should return status pending and the irp will be completed
                // in DelayedCleanupAfterDisconnect in hndlrs.c
                pTracker->pConnEle = (PVOID)pLowerConn;

#if DBG
                if (Timeout)
                {
                    TimeVal = ((PTIME)Timeout)->LowTime;
                }
                else
                {
                    TimeVal = 0;
                }
                IF_DBG(NBT_DEBUG_DISCONNECT)
                    KdPrint(("Nbt.DisconnectLower: Disconnect Timout = %X,Flags=%X\n",
                        TimeVal,Flags));
#endif

                // in the case where CleanupAddress calls cleanupConnection
                // which calls nbtdisconnect, we do not have an irp to wait
                // on so pass a flag down to TdiDisconnect to do a synchronous
                // disconnect.
                //
                status = TcpDisconnect (pTracker, Timeout, Flags, Wait);

#ifndef VXD
                if (Wait)
                {
                    // we need to call disconnect done now
                    // to free the tracker and cleanup the connection
                    //
                    DisconnectDone(pTracker,status,0);
                }
#else
                //
                // if the disconnect is abortive, transport doesn't call us
                // back so let's call DisconnectDone so that the lowerconn gets
                // cleaned up properly! (Wait parm is of no use in vxd)
                //
                if (Flags == TDI_DISCONNECT_ABORT)
                {
                    // we need to call disconnect done now
                    // to free the tracker and cleanup the connection
                    //
                    DisconnectDone(pTracker,STATUS_SUCCESS,0);
                }
#endif
            }
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    return status ;
}


//----------------------------------------------------------------------------
NTSTATUS
NbtAccept(
        TDI_REQUEST                     *pRequest,
        IN  TDI_CONNECTION_INFORMATION  *pAcceptInfo,
        OUT TDI_CONNECTION_INFORMATION  *pReturnAcceptInfo,
        IN  PIRP                        pIrp)

/*++

Routine Description

    This routine handles accepting an inbound connection by a client.
    The client calls this routine after it has been alerted
    by a Listen completing back to the client.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    tCONNECTELE  *pConnectEle;
    NTSTATUS     status;
    CTELockHandle OldIrq;

    // get the client object associated with this connection
    pConnectEle = (tCONNECTELE *)pRequest->Handle.ConnectionContext;

    CTEVerifyHandle(pConnectEle,NBT_VERIFY_CONNECTION,tCONNECTELE,&status);

    //
    // a Listen has completed
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pConnectEle);
    if (pConnectEle->state == NBT_SESSION_WAITACCEPT)
    {
        tLOWERCONNECTION    *pLowerConn;

        //
        // We need to send a session response PDU here, since a Listen has
        // has completed back to the client, and the session is not yet up
        //
        SET_STATE_UPPER (pConnectEle, NBT_SESSION_UP);

        pLowerConn = (tLOWERCONNECTION *)pConnectEle->pLowerConnId;
        SET_STATE_LOWER (pLowerConn, NBT_SESSION_UP);
        SET_STATERCV_LOWER(pLowerConn, NORMAL, Normal);

        CTESpinFreeAtDpc(pConnectEle);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        status = TcpSendSessionResponse(
                    pLowerConn,
                    NBT_POSITIVE_SESSION_RESPONSE,
                    0L);

        if (NT_SUCCESS(status))
        {
            status = STATUS_SUCCESS;
        }

    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
        CTESpinFreeAtDpc(pConnectEle);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
NbtReceiveDatagram(
        IN  TDI_REQUEST                 *pRequest,
        IN  PTDI_CONNECTION_INFORMATION pReceiveInfo,
        IN  PTDI_CONNECTION_INFORMATION pReturnedInfo,
        IN  LONG                        ReceiveLength,
        IN  LONG                        *pReceivedLength,
        IN  PVOID                       pBuffer,
        IN  tDEVICECONTEXT              *pDeviceContext,
        IN  PIRP                        pIrp
        )
/*++

Routine Description

    This routine handles sending client data to the Transport TDI
    interface.  It is mostly a pass through routine for the data
    except that this code must create a datagram header and pass that
    header back to the calling routine.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{

    NTSTATUS                status;
    tCLIENTELE              *pClientEle;
    CTELockHandle           OldIrq;
    tRCVELE                 *pRcvEle;
    tADDRESSELE             *pAddressEle;

    pClientEle = (tCLIENTELE *)pRequest->Handle.AddressHandle;
    CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT,tCLIENTELE,&status);
    pAddressEle = pClientEle->pAddress;
    *pReceivedLength = 0;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtReceiveDatagram: RcvDgram posted (pIrp) %X \n",pIrp));

    pRcvEle = (tRCVELE *)NbtAllocMem(sizeof(tRCVELE),NBT_TAG('J'));
    if (!pRcvEle)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pRcvEle->pIrp = pIrp;
    pRcvEle->ReceiveInfo = pReceiveInfo;
    pRcvEle->ReturnedInfo = pReturnedInfo;
    pRcvEle->RcvLength = ReceiveLength;
    pRcvEle->pRcvBuffer = pBuffer;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    //
    // tack the receive on to the client element for later use
    //
    InsertTailList(&pClientEle->RcvDgramHead,&pRcvEle->Linkage);

    status = NTCheckSetCancelRoutine(pIrp,(PVOID)NbtCancelRcvDgram,pDeviceContext);
    if (!NT_SUCCESS(status))
    {
        RemoveEntryList(&pRcvEle->Linkage);
    }
    else
    {
        status = STATUS_PENDING;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
FindNameOrQuery(
    IN  PUCHAR                  pName,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  PVOID                   QueryCompletion,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  ULONG                   NameFlags,
    OUT tIPADDRESS              *pIpAddress,
    OUT tNAMEADDR               **ppNameAddr,
    IN  ULONG                   NameReferenceContext,
    IN  BOOLEAN                 DgramSend
    )
/*++

Routine Description

    This routine handles finding a name in the local or remote table or doing
    a name query on the network.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{

    tNAMEADDR               *pNameAddr;
    CTELockHandle           OldIrq2;
    NTSTATUS                status=STATUS_UNSUCCESSFUL;
    BOOLEAN                 FoundInLocalTable = FALSE;
    tDEVICECONTEXT          *pThisDeviceContext;
    LIST_ENTRY              *pHead, *pEntry;
    ULONG                   Index;

    //
    // this saves the client threads security context so we can
    // open remote lmhost files later.- it is outside the Spin locks
    // so it can be pageable
    //
    CTESaveClientSecurity(pTracker);

    CTESpinLock(&NbtConfig.JointLock,OldIrq2);

    pTracker->pTrackerWorker = NULL;    // Initialize the NameQuery Tracker

#ifdef MULTIPLE_WINS
    if (ppNameAddr)
    {
        *ppNameAddr = NULL;
    }
#endif

    NbtTrace(NBT_TRACE_NAMESRV, ("pTracker %p: %!NBTNAME!<%02x>",
                        pTracker,
                        pTracker->pDestName,
                        pTracker->pDestName[NETBIOS_NAME_SIZE-1]));

    //
    // Fail all connect attempts to 1C names.
    //
    if ((pTracker->pDestName[NETBIOS_NAME_SIZE-1] == 0x1c) &&
        (pTracker->Flags & SESSION_SETUP_FLAG))
    {
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            DELETE_CLIENT_SECURITY(pTracker);

            KdPrint(("Nbt.FindNameOrQuery: Session setup -- p1CNameAddr was NULL\n"));
            NbtTrace(NBT_TRACE_NAMESRV, ("pTracker %p: STATUS_UNEXPECTED_NETWORK_ERROR", pTracker));
            return(STATUS_UNEXPECTED_NETWORK_ERROR);
    }

    // send to the NetBios Broadcast name, so use the subnet broadcast
    // address - also - a
    // Kludge to keep the browser happy - always broadcast sends to
    // 1d, however NodeStatus's are sent to the node owning the 1d name now.
    //
    if ((pName[0] == '*') || ((pName[NETBIOS_NAME_SIZE-1] == 0x1d) && (DgramSend)))
    {
        // this 'fake' pNameAddr has to be setup carefully so that the memory
        // is released when NbtDeferenceName is called from SendDgramCompletion
        // Note that this code does not apply to NbtConnect since these names
        // are group names, and NbtConnect will not allow a session to a group
        // name.
        status = STATUS_INSUFFICIENT_RESOURCES ;
        if (pNameAddr = NbtAllocMem(sizeof(tNAMEADDR),NBT_TAG('K')))
        {
            CTEZeroMemory(pNameAddr,sizeof(tNAMEADDR));
            CTEMemCopy( pNameAddr->Name, pName, NETBIOS_NAME_SIZE ) ;
            pNameAddr->IpAddress     = pDeviceContext->BroadcastAddress;
            pNameAddr->NameTypeState = NAMETYPE_GROUP | STATE_RESOLVED;

            // gets incremented below, and decremented when NBT_DEREFERENCE_NAMEADDR
            // is called
            CHECK_PTR(pNameAddr);
            pNameAddr->RefCount = 0;
            pNameAddr->Verify = LOCAL_NAME;
            pNameAddr->AdapterMask = pDeviceContext->AdapterMask;
            pNameAddr->ReleaseMask = (CTEULONGLONG) 0;

            // adjust the linked list ptr to fool the RemoveEntry routine
            // so it does not do anything wierd in NbtDeferenceName
            //
            pNameAddr->Linkage.Flink = pNameAddr->Linkage.Blink = &pNameAddr->Linkage;

            status = STATUS_SUCCESS;
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            DELETE_CLIENT_SECURITY(pTracker);
            NbtTrace(NBT_TRACE_NAMESRV, ("pTracker %p: STATUS_INSUFFICIENT_RESOURCES", pTracker));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }
    else
    {
        // The pdu is all made up and ready to go except that we don't know
        // the destination IP address yet, so check in the local then remote
        // table for the ip address.
        //
        pNameAddr = NULL;

        //
        // Dont check local cache for 1C names, to force a WINS query; so we find other
        // DCs even if we have a local DC running.
        //
        if ((pName[NETBIOS_NAME_SIZE-1] != 0x1c) )
        {
            status = FindInHashTable (NbtConfig.pLocalHashTbl, pName, NbtConfig.pScope, &pNameAddr);
        }
        else
        {
            status = STATUS_UNSUCCESSFUL;
        }

        // check the remote table now if not found, or if it was found in
        // conflict in the local table, or if it was found and its a group name
        // or if it was found to be resolving in the local table.  When the
        // remote query timesout, it will check the local again to see if
        // it is resolved yet.
        // Going to the remote table for group names
        // allows special Internet group names to be registered as
        // as group names in the local table and still prompt this code to go
        // to the name server to check for an internet group name. Bnodes do
        // not understand internet group names as being different from
        // regular group names, - they just broadcast to both. (Note: this
        // allows Bnodes to resolve group names in the local table and do
        // a broadcast to them without a costly broadcast name query for a
        // group name (where everyone responds)). Node Status uses this routine too
        // and it always wants to find the singular address of the destination,
        // since it doesn't make sense doing a node status to the broadcast
        // address.
        // DgramSend is a flag to differentiate Connect attempts from datagram
        // send attempts, so the last part of the If says that if it is a
        // group name and not a Bnode, and not a Dgram Send, then check the
        // remote table.
        //
        if ((!NT_SUCCESS(status)) ||
            (pNameAddr->NameTypeState & STATE_CONFLICT) ||
            (pNameAddr->NameTypeState & STATE_RESOLVING))
        {
            pNameAddr = NULL;
            status = FindInHashTable (NbtConfig.pRemoteHashTbl, pName, NbtConfig.pScope, &pNameAddr);

            if (NT_SUCCESS(status) &&
                NbtConfig.SmbDisableNetbiosNameCacheLookup &&
                IsDeviceNetbiosless(pDeviceContext) &&
                !(pNameAddr->NameTypeState & PRELOADED) &&
                NULL == pNameAddr->FQDN.Buffer) {
                status = STATUS_UNSUCCESSFUL;
            }

            //
            // See if we have an address resolved on this device
            //
            if (NT_SUCCESS(status))
            {
                ASSERT (!(pNameAddr->NameTypeState & STATE_RELEASED));
                status = PickBestAddress (pNameAddr, pDeviceContext, pIpAddress);
            }
        }
        else if (((IsDeviceNetbiosless (pDeviceContext)) &&
                  (pNameAddr->NameFlags & NAME_REGISTERED_ON_SMBDEV)) ||
                 ((!IsDeviceNetbiosless(pDeviceContext)) &&
                  ((pDeviceContext->IpAddress) &&
                   (pNameAddr->AdapterMask & pDeviceContext->AdapterMask))))
        {
            FoundInLocalTable = TRUE;
            *pIpAddress = pDeviceContext->IpAddress;
            pNameAddr->IpAddress = pDeviceContext->IpAddress;
        }
        else
        {
            //
            // This is a Local name, so find the first device this name is registered on
            //
            if (!IsDeviceNetbiosless (pDeviceContext)) {
                pHead = pEntry = &NbtConfig.DeviceContexts;
                while ((pEntry = pEntry->Flink) != pHead)
                {
                    pThisDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
                    if ((pThisDeviceContext->IpAddress) &&
                        (pThisDeviceContext->AdapterMask & pNameAddr->AdapterMask))
                    {
                        pNameAddr->IpAddress = pThisDeviceContext->IpAddress;
                        *pIpAddress = pThisDeviceContext->IpAddress;
                        FoundInLocalTable = TRUE;
                        break;
                    }
                }
            }
            /*
             * The name is in local name table. However, we cannot find a device which has an IP address.
             */
            if (!FoundInLocalTable) {
                CTESpinFree(&NbtConfig.JointLock,OldIrq2);
                DELETE_CLIENT_SECURITY(pTracker);

                NbtTrace(NBT_TRACE_NAMESRV, ("pTracker %p: STATUS_BAD_NETWORK_PATH", pTracker));
                return STATUS_BAD_NETWORK_PATH;
            }
        }

        //
        // If we found the name, but the name does not match
        // what we were looking for, return error!
        //
        if ((status == STATUS_SUCCESS) &&
            (!(pNameAddr->NameTypeState & NameFlags)))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            DELETE_CLIENT_SECURITY(pTracker);

            KdPrint(("Nbt.FindNameOrQuery: NameFlags=<%x> != pNameAddr->NameTypeState=<%x>\n",
                NameFlags, pNameAddr->NameTypeState));

            NbtTrace(NBT_TRACE_NAMESRV, ("pTracker %p: STATUS_UNEXPECTED_NETWORK_ERROR", pTracker));
            return(STATUS_UNEXPECTED_NETWORK_ERROR);
        }
    }

    // The proxy puts name in the released state, so we need to ignore those
    // and do another name query
    // If the name is not resolved on this adapter then do a name query.
    //
    // MAlam: 2/4/97
    // Added fix for Local Cluster Name Resolution:  If the name is in the Local
    // Names Cache, we do not need to check the adapter it's registered on.  This
    // is mainly to facilitate names registered on pseudo-devices which have to
    // be made visible locally.
    //
    if (!NT_SUCCESS(status))
    {
        // fill in some tracking values so we can complete the send later
        InitializeListHead(&pTracker->TrackerList);

#if _NETBIOSLESS
        // Query on the Net only if this request is not on a Netbiosless Device
        if (IsDeviceNetbiosless(pDeviceContext))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            status = STATUS_UNSUCCESSFUL;
        }
        else
#endif
        {
            // this will query the name on the network and call a routine to
            // finish sending the datagram when the query completes.
            status = QueryNameOnNet (pName,
                                     NbtConfig.pScope,
                                     NBT_UNIQUE,      //use this as the default
                                     pTracker,
                                     QueryCompletion,
                                     NodeType & NODE_MASK,
                                     NULL,
                                     pDeviceContext,
                                     &OldIrq2);

            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        }
    }
    else
    {
        // check the name state and if resolved, send to it
        if (pNameAddr->NameTypeState & STATE_RESOLVED)
        {
            //
            // found the name in the remote hash table, so send to it
            //
            // increment refcount so the name does not disappear out from under us
            NBT_REFERENCE_NAMEADDR (pNameAddr, NameReferenceContext);
            if (DgramSend)
            {
                pTracker->p1CNameAddr = NULL;
                //
                // check if it is a 1C name and if there is a name in
                // the domainname list
                //
                if (pTracker->pDestName[NETBIOS_NAME_SIZE-1] == 0x1c)
                {
                    //
                    // If the 1CNameAddr field is NULL here, we overwrite the pConnEle element (which is
                    // a union in the tracker). We check for NULL here and fail the request.
                    //
                    if (pTracker->p1CNameAddr = FindInDomainList(pTracker->pDestName,&DomainNames.DomainList))
                    {
                        NBT_REFERENCE_NAMEADDR (pTracker->p1CNameAddr, NameReferenceContext);
                    } 
                }
            }

            //
            // overwrite the pDestName field with the pNameAddr value
            // so that SendDgramContinue can send to Internet group names
            //
            pTracker->pNameAddr = pNameAddr;
            if (ppNameAddr)
            {
                *ppNameAddr = pNameAddr;
            }

            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        }
        else if (pNameAddr->NameTypeState & STATE_RESOLVING)
        {

            ASSERTMSG("A resolving name in the name table!",0);

            status = SendToResolvingName(pNameAddr,
                                         pName,
                                         OldIrq2,
                                         pTracker,
                                         QueryCompletion);

        }
        else
        {
            //
            // Name neither in the RESOLVED nor RESOLVING state
            //
            NBT_PROXY_DBG(("FindNameOrQuery: STATE of NAME %16.16s(%X) is %d\n",
                pName, pName[15], pNameAddr->NameTypeState & NAME_STATE_MASK));
            status = STATUS_UNEXPECTED_NETWORK_ERROR;
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        }
    }

    if (status != STATUS_PENDING)
    {
        DELETE_CLIENT_SECURITY(pTracker);
        NbtTrace(NBT_TRACE_NAMESRV, ("pTracker %p: %!status!", pTracker, status));
    }
    return(status);
}
//----------------------------------------------------------------------------
tNAMEADDR *
FindNameRemoteThenLocal(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    OUT tIPADDRESS              *pIpAddress,
    OUT PULONG                  plNameType
    )
/*++

Routine Description

    This routine Queries the remote hash table then the local one for a name.

Arguments:

Return Values:

    NTSTATUS    - completion status

--*/
{
    tNAMEADDR   *pNameAddr;
    tIPADDRESS  IpAddress = 0;
    tIPADDRESS  *pIpNbtGroupList = NULL;

    if (pNameAddr = FindName (NBT_REMOTE, pTracker->pDestName, NbtConfig.pScope, plNameType)) {
        pNameAddr->TimeOutCount = NbtConfig.RemoteTimeoutCount;
    } else {
        pNameAddr = FindName (NBT_LOCAL, pTracker->pDestName, NbtConfig.pScope, plNameType);
    }

    if ((pNameAddr) &&
        (!NT_SUCCESS (PickBestAddress (pNameAddr, pTracker->pDeviceContext, &IpAddress))))
    {
        pNameAddr = NULL;
    }

    
    if (pIpAddress)
    {
        *pIpAddress = IpAddress;
    }

    return(pNameAddr);
}

//----------------------------------------------------------------------------
NTSTATUS
SendToResolvingName(
    IN  tNAMEADDR               *pNameAddr,
    IN  PCHAR                   pName,
    IN  CTELockHandle           OldIrq,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   QueryCompletion
        )
/*++

Routine Description

    This routine handles the situation where a session send or a datagram send
    is made WHILE the name is still resolving.  The idea here is to hook this
    tracker on to the one already doing the name query and when the first completes
    this tracker will be completed too.

Arguments:

Return Values:

    NTSTATUS    - completion status

--*/
{
    tDGRAM_SEND_TRACKING    *pTrack;
    tTIMERQENTRY            *pTimer;


    KdPrint(("Nbt.SendToResolvingName: Two Name Queries for the same Resolving name %15.15s <%X>\n",
                pNameAddr->Name,pNameAddr->Name[NETBIOS_NAME_SIZE-1]));

#ifdef PROXY_NODE
    //
    // Check if the query outstanding was sent by the PROXY code.
    // If yes, we stop the timer and send the query ourselves.
    //
    if (pNameAddr->ProxyReqType != NAMEREQ_REGULAR)
    {
        NTSTATUS    status;
        //
        // Stop the proxy timer.  This will result in
        // cleanup of the tracker buffer
        //
        NBT_PROXY_DBG(("SendToResolvingName: STOPPING PROXY TIMER FOR NAME %16.16s(%X)\n", pName, pName[15]));

        // **** TODO ****** the name may be resolving with LMhosts or
        // DNS so we can't just stop the timer and carry on!!!.
        //
        CHECK_PTR(pNameAddr);
        if (pTimer = pNameAddr->pTimer)
        {
            pNameAddr->pTimer = NULL;
            status = StopTimer(pTimer,NULL,NULL);
        }

        pNameAddr->NameTypeState = STATE_RELEASED;

        //
        // this will query the name on the network and call a
        // routine to finish sending the datagram when the query
        // completes.
        //
        status = QueryNameOnNet (pName,
                                 NbtConfig.pScope,
                                 NBT_UNIQUE,      //use this as the default
                                 pTracker,
                                 QueryCompletion,
                                 NodeType & NODE_MASK,
                                 pNameAddr,
                                 pTracker->pDeviceContext,
                                 &OldIrq);

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return(status);

        //
        // NOTE: QueryNameOnNet frees the pNameAddr by calling NBT_DEREFERENCE_NAMEADDR
        // if that routine fails for some reason.
        //

    }
    else
#endif
    {
        ASSERT(pNameAddr->pTracker);

        // there is currently a name query outstanding so just hook
        // our tracker to the tracker already there.. use the
        // list entry TrackerList for this.
        //
        pTrack = pNameAddr->pTracker;

        //
        // save the completion routine for this tracker since it may
        // be different than the tracker currently doing the query
        //
        pTracker->CompletionRoutine = QueryCompletion;

        InsertTailList(&pTrack->TrackerList,&pTracker->TrackerList);

        CTESpinFree(&NbtConfig.JointLock,OldIrq);


        // we don't want to complete the Irp, so return pending status
        //
        return(STATUS_PENDING);
    }
}



//----------------------------------------------------------------------------
extern
USHORT
GetTransactId(
    )
/*++
Routine Description:

    This Routine increments the transaction id with the spin lock held.
    It uses NbtConfig.JointLock.

Arguments:

Return Value:


--*/

{
    USHORT                  TransactId;
    CTELockHandle           OldIrq;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    TransactId = NbtConfig.TransactionId++;
#ifndef VXD
    if (TransactId == 0xFFFF)
    {
        NbtConfig.TransactionId = WINS_MAXIMUM_TRANSACTION_ID +1;
    }
#else
    if (TransactId == (DIRECT_DNS_NAME_QUERY_BASE - 1))
    {
        NbtConfig.TransactionId = 0;
    }
#endif

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return (TransactId);
}

//----------------------------------------------------------------------------
extern
VOID
CTECountedAllocMem(
        PVOID   *pBuffer,
        ULONG   Size
        )
/*++
Routine Description:

    This Routine allocates memory and counts the amount allocated so that it
    will not allocate too much - generally this is used in datagram sends
    where the send datagram is buffered.

Arguments:

    Size - the number of bytes to allocate
    PVOID - a pointer to the memory or NULL if a failure

Return Value:


--*/

{
    CTELockHandle           OldIrq;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (NbtMemoryAllocated > NbtConfig.MaxDgramBuffering)
    {
        *pBuffer = NULL;
    }
    else
    {
        NbtMemoryAllocated += Size;
        *pBuffer = NbtAllocMem(Size,NBT_TAG('L'));
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}

//----------------------------------------------------------------------------
extern
VOID
CTECountedFreeMem(
    PVOID   pBuffer,
    ULONG   Size,
    BOOLEAN fJointLockHeld
    )
/*++
Routine Description:

    This Routine frees memory and decrements the global count of acquired
    memory.

Arguments:

    PVOID - a pointer to the memory to free
    Size - the number of bytes to free

Return Value:


--*/

{
    CTELockHandle           OldIrq;

    if (!fJointLockHeld)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    ASSERT(NbtMemoryAllocated >= Size);
    if (NbtMemoryAllocated >= Size)
    {
        NbtMemoryAllocated -= Size;
    }
    else
    {
        NbtMemoryAllocated = 0;
    }

    if (!fJointLockHeld)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    CTEMemFree(pBuffer);

}


//----------------------------------------------------------------------------
NTSTATUS
BuildSendDgramHdr(
        IN  ULONG                   SendLength,
        IN  tDEVICECONTEXT          *pDeviceContext,
        IN  PCHAR                   pSourceName,
        IN  PCHAR                   pDestName,
        IN  ULONG                   NameLength,
        IN  PVOID                   pBuffer,
        OUT tDGRAMHDR               **ppDgramHdr,
        OUT tDGRAM_SEND_TRACKING    **ppTracker
        )
/*++

Routine Description

    This routine builds a datagram header necessary for sending datagrams.
    It include the to and from Netbios names and ip addresses.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    NTSTATUS                status;
    PCHAR                   pCopyTo;
    tDGRAM_SEND_TRACKING    *pTracker;
    tDGRAMHDR               *pDgramHdr;
    ULONG                   HdrLength;
    ULONG                   HLength;
    ULONG                   TotalLength;
    PVOID                   pSendBuffer;
    PVOID                   pNameBuffer;
    ULONG                   BytesCopied;
    USHORT                  TransactId;

    CTEPagedCode();

    HdrLength = DGRAM_HDR_SIZE + (NbtConfig.ScopeLength <<1);
    HLength = ((HdrLength + 3) / 4 ) * 4; // 4 byte aligned the hdr size
    TotalLength = HLength + NameLength + SendLength;
    CTECountedAllocMem ((PVOID *)&pDgramHdr,TotalLength);
    if (!pDgramHdr)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    *ppDgramHdr = pDgramHdr;

    // fill in the Dgram header
    pDgramHdr->Flags    = FIRST_DGRAM | (NbtConfig.PduNodeType >> 11);
    TransactId  = GetTransactId();
    pDgramHdr->DgramId  = htons(TransactId);
#ifdef _NETBIOSLESS
    pDgramHdr->SrcPort  = htons(pDeviceContext->DatagramPort);
    if (IsDeviceNetbiosless(pDeviceContext))
    {
        // We don't know which adapter will be used, so use ANY
        pDgramHdr->SrcIpAddr = htonl(IP_ANY_ADDRESS);
    }
    else
    {
        pDgramHdr->SrcIpAddr = htonl(pDeviceContext->IpAddress);
    }
#else
    pDgramHdr->SrcPort  = htons(NBT_DATAGRAM_UDP_PORT);
    pDgramHdr->SrcIpAddr = htonl(pDeviceContext->IpAddress);
#endif
    //
    // the length is the standard datagram length (dgram_hdr_size + 2* scope)
    // minus size of the header that comes before the SourceName
    //
    pDgramHdr->DgramLength = htons( (USHORT)SendLength + (USHORT)DGRAM_HDR_SIZE
                               - (USHORT)(&((tDGRAMHDR *)0)->SrcName.NameLength)
                               + ( (USHORT)(NbtConfig.ScopeLength << 1) ));
    pDgramHdr->PckOffset   = 0; // not fragmented for now!

    pCopyTo = (PVOID)&pDgramHdr->SrcName.NameLength;
    pCopyTo = ConvertToHalfAscii(pCopyTo, pSourceName, NbtConfig.pScope, NbtConfig.ScopeLength);

    //
    // copy the destination name and scope to the pdu - we use this node's
    //
    ConvertToHalfAscii (pCopyTo, pDestName, NbtConfig.pScope, NbtConfig.ScopeLength);

    //
    // copy the name in to the buffer since we are completing the client's irp
    // and we will lose his buffer with the dest name in it.
    //
    pNameBuffer = (PVOID)((PUCHAR)pDgramHdr + HLength);
    CTEMemCopy (pNameBuffer, pDestName, NameLength);

    //
    // copy the client's send buffer to our buffer so the send dgram can
    // complete immediately.
    //
    pSendBuffer = (PVOID) ((PUCHAR)pDgramHdr + NameLength + HLength);
    if (SendLength)
    {
#ifdef VXD
        CTEMemCopy(pSendBuffer,pBuffer,SendLength);
#else
        status = TdiCopyMdlToBuffer(pBuffer,
                                    0,
                                    pSendBuffer,
                                    0,
                                    SendLength,
                                    &BytesCopied);

        if (!NT_SUCCESS(status) || (BytesCopied != SendLength))
        {
            CTECountedFreeMem ((PVOID)pDgramHdr, TotalLength, FALSE);
            return(STATUS_UNSUCCESSFUL);
        }
#endif
    }
    else
    {
        pSendBuffer = NULL;
    }

    //
    // get a buffer for tracking Dgram Sends
    //
    status = GetTracker(&pTracker, NBT_TRACKER_BUILD_SEND_DGRAM);
    if (NT_SUCCESS(status))
    {

        CHECK_PTR(pTracker);
        pTracker->SendBuffer.pBuffer   = pSendBuffer;
        pTracker->SendBuffer.Length    = SendLength;
        pTracker->SendBuffer.pDgramHdr = pDgramHdr;
        pTracker->SendBuffer.HdrLength = HdrLength;

        pTracker->pClientIrp           = NULL;
        pTracker->pDestName            = pNameBuffer;
        pTracker->UnicodeDestName      = NULL;
        pTracker->pNameAddr            = NULL;
        pTracker->RemoteNameLength     = NameLength;      // May be needed for Dns Name resolution
        pTracker->pClientEle           = NULL;
        pTracker->AllocatedLength      = TotalLength;

        *ppTracker = pTracker;

        status = STATUS_SUCCESS;
    }
    else
    {
        CTECountedFreeMem((PVOID)pDgramHdr,TotalLength, FALSE);

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}


//----------------------------------------------------------------------------
VOID
DgramSendCleanupTracker(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  NTSTATUS                status,
    IN  BOOLEAN                 fJointLockHeld
    )

/*++
Routine Description

    This routine cleans up after a data gram send.

Arguments:

    pTracker
    status
    Length

Return Values:

    VOID

--*/

{
    tNAMEADDR               *pNameAddr=NULL;

    //
    // Undo the nameAddr increment done before the send started - if we have
    // actually resolved the name - when the name does not resolve pNameAddr
    // is set to NULL before calling this routine.
    //
    if (pTracker->pNameAddr)
    {
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_SEND_DGRAM, fJointLockHeld);
    }

    if (pTracker->p1CNameAddr)
    {
        NBT_DEREFERENCE_NAMEADDR (pTracker->p1CNameAddr, REF_NAME_SEND_DGRAM, fJointLockHeld);
        pTracker->p1CNameAddr = NULL;
    }

    //
    // free the buffer used for sending the data and free
    // the tracker
    //
    CTECountedFreeMem((PVOID)pTracker->SendBuffer.pDgramHdr, pTracker->AllocatedLength, fJointLockHeld);

    if (pTracker->pGroupList)
    {
        CTEMemFree(pTracker->pGroupList);
        pTracker->pGroupList = NULL;
    }

    FreeTracker (pTracker,RELINK_TRACKER);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtSendDatagram(
        IN  TDI_REQUEST                 *pRequest,
        IN  PTDI_CONNECTION_INFORMATION pSendInfo,
        IN  LONG                        SendLength,
        IN  LONG                        *pSentLength,
        IN  PVOID                       pBuffer,
        IN  tDEVICECONTEXT              *pDeviceContext,
        IN  PIRP                        pIrp
        )
/*++

Routine Description

    This routine handles sending client data to the Transport TDI
    interface.  It is mostly a pass through routine for the data
    except that this code must create a datagram header and pass that
    header back to the calling routine.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{
    TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;
    tCLIENTELE              *pClientEle;
    tDGRAMHDR               *pDgramHdr;
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    PCHAR                   pName, pEndpointName;
    ULONG                   NameLen;
    ULONG                   NameType;
    ULONG                   SendCount;
    tIPADDRESS              RemoteIpAddress;
    tDEVICECONTEXT          *pDeviceContextOut = NULL;
    PIO_STACK_LOCATION      pIrpSp;
    PUCHAR                  pCopyTo;
    NBT_WORK_ITEM_CONTEXT   *pContext;

    CTEPagedCode();

    //
    // Check for valid address on this Device + valid ClientElement
    if ((pDeviceContext->IpAddress == 0) ||
        (pDeviceContext->pFileObjects == NULL))
    {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    pClientEle = (tCLIENTELE *)pRequest->Handle.AddressHandle;
    if ( pClientEle->Verify != NBT_VERIFY_CLIENT )
    {
        if ( pClientEle->Verify == NBT_VERIFY_CLIENT_DOWN )
        {
            status = STATUS_CANCELLED;
        }
        else
        {
            status = STATUS_INVALID_HANDLE;
        }
        return status;
    }

    //
    // Check for valid destination name and for whether it is an IP address
    //
    status = GetNetBiosNameFromTransportAddress (
            (PTRANSPORT_ADDRESS)pSendInfo->RemoteAddress, pSendInfo->RemoteAddressLength, &TdiAddr);
    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt.NbtSendDatagram: Unable to get dest name from address in dgramsend\n"));
        return(STATUS_INVALID_PARAMETER);
    }
    pName = TdiAddr.OEMRemoteName.Buffer;
    NameLen = TdiAddr.OEMRemoteName.Length;
    NameType = TdiAddr.NameType;
    if (TdiAddr.OEMEndpointName.Buffer) {
        CTEMemCopy (pClientEle->EndpointName, TdiAddr.OEMEndpointName.Buffer, NETBIOS_NAME_SIZE);
    }

    pClientEle->AddressType = TdiAddr.AddressType;
    if (RemoteIpAddress = Nbt_inet_addr(pName, DGRAM_SEND_FLAG))
    {
        pDeviceContextOut = GetDeviceFromInterface (htonl(RemoteIpAddress), TRUE);
        if ((NbtConfig.ConnectOnRequestedInterfaceOnly) &&
            (!IsDeviceNetbiosless(pDeviceContext)) &&
            (pDeviceContext != pDeviceContextOut))
        {
            status = STATUS_BAD_NETWORK_PATH;
            goto NbtSendDatagram_Exit;
        }
    }

#ifndef VXD
    if (pClientEle->AddressType == TDI_ADDRESS_TYPE_NETBIOS_EX)
    {
        pEndpointName = pClientEle->EndpointName;
    }
    else
#endif  // !VXD
    {
        pEndpointName = pName;
    }

    IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt.NbtSendDatagram: Dgram Send to = %16.16s<%X>\n",pName,pName[15]));

    status = BuildSendDgramHdr (SendLength,
                                pDeviceContext,
                                ((tADDRESSELE *)pClientEle->pAddress)->pNameAddr->Name, // Source name
                                pEndpointName,
                                NameLen,
                                pBuffer,
                                &pDgramHdr,
                                &pTracker);

    if (!NT_SUCCESS(status))
    {
        goto NbtSendDatagram_Exit;
    }

    //
    // save the devicecontext that the client is sending on.
    //
    pTracker->pDeviceContext = (PVOID)pDeviceContext;
    pTracker->Flags = DGRAM_SEND_FLAG;
    pTracker->pClientIrp = pIrp;
    pTracker->AddressType = pClientEle->AddressType;
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.Others.Argument4 = pTracker;
    status = NTCheckSetCancelRoutine(pIrp, NbtCancelDgramSend, pDeviceContext);
    if (STATUS_CANCELLED == status)
    {
        IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt.NbtSendDatagram: Request was cancelled!\n"));
        pTracker->pClientIrp = NULL;
        pIrpSp->Parameters.Others.Argument4 = NULL;
        DgramSendCleanupTracker(pTracker,status,FALSE);
        goto NbtSendDatagram_Exit;
    }

    if (RemoteIpAddress)
    {
        //
        // add this address to the remote hashtable
        //
        status = LockAndAddToHashTable (NbtConfig.pRemoteHashTbl,
                                        pName,
                                        NbtConfig.pScope,
                                        RemoteIpAddress,
                                        NBT_UNIQUE,
                                        NULL,
                                        NULL,
                                        pDeviceContextOut,
                                        NAME_RESOLVED_BY_IP);

        if (NT_SUCCESS (status))    // SUCCESS if added first time, PENDING if name already existed!
        {
            status = STATUS_SUCCESS;
        }
    }
    else
    {
        //
        // if the name is longer than 16 bytes, it's not a netbios name.
        // skip wins, broadcast etc. and go straight to dns resolution
        //
        status = STATUS_UNSUCCESSFUL;
        if (NameLen <= NETBIOS_NAME_SIZE)
        {
            status = FindNameOrQuery(pName,
                                     pDeviceContext,
                                     SendDgramContinue,
                                     pTracker,
                                     (ULONG) (NAMETYPE_UNIQUE | NAMETYPE_GROUP | NAMETYPE_INET_GROUP),
                                     &pTracker->RemoteIpAddress,
                                     &pTracker->pNameAddr,
                                     REF_NAME_SEND_DGRAM,
                                     TRUE);
        }

        if ((NameLen > NETBIOS_NAME_SIZE) ||
            ((IsDeviceNetbiosless(pDeviceContext)) && (!NT_SUCCESS(status))))
        {
            if (pContext = (NBT_WORK_ITEM_CONTEXT*)NbtAllocMem(sizeof(NBT_WORK_ITEM_CONTEXT),NBT_TAG('H')))
            {
                pContext->pTracker = NULL;              // no query tracker
                pContext->pClientContext = pTracker;    // the client tracker
                pContext->ClientCompletion = SendDgramContinue;
                pContext->pDeviceContext = pDeviceContext;

                //
                // Start the timer so that the request does not hang waiting for Dns!
                //
                StartLmHostTimer(pContext, FALSE);
                status = NbtProcessLmhSvcRequest (pContext, NBT_RESOLVE_WITH_DNS);
                if (!NT_SUCCESS (status))
                {
                    CTEMemFree(pContext);
                }
            }
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (status == STATUS_SUCCESS)   // If the name was an IP address or was present in the cache
    {
        SendDgramContinue (pTracker, STATUS_SUCCESS);
        status = STATUS_PENDING;    // SendDgramContinue will cleanup and complete the Irp
    }
    else if (status != STATUS_PENDING)
    {
        *pSentLength = 0;
        NTClearFindNameInfo (pTracker, &pIrp, pIrp, pIrpSp);
        if (!pIrp)
        {
            status = STATUS_PENDING; // irp is already completed: return pending so we don't complete again
        }

        pTracker->pNameAddr = NULL;
        DgramSendCleanupTracker(pTracker,status,FALSE);
    }

NbtSendDatagram_Exit:

    if (pDeviceContextOut)
    {
        NBT_DEREFERENCE_DEVICE (pDeviceContextOut, REF_DEV_OUT_FROM_IP, FALSE);
    }

    //
    // return the status to the client.
    //
    return(status);
}

//----------------------------------------------------------------------------
VOID
SendDgramContinue(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        )
/*++

Routine Description

    This routine handles sending client data to the Transport TDI
    interface after the destination name has resolved to an IP address.
    This routine is given as the completion routine to the "QueryNameOnNet" call
    in NbtSendDatagram, above.  When a name query response comes in or the
    timer times out after N retries.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    CTELockHandle           OldIrq;
    ULONG                   lNameType;
    tNAMEADDR               *pNameAddr = NULL;
    tNAMEADDR               *p1CNameAddr = NULL;
    tDGRAM_SEND_TRACKING    *pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    tDEVICECONTEXT          *pDeviceContext = pTracker->pDeviceContext;
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpSp;

    CHECK_PTR(pTracker);
    DELETE_CLIENT_SECURITY(pTracker);

    //
    // The Tracker can get cleaned up somewhere and reassigned if we fail below
    // causing the pClientIrp ptr to get lost.  We need to save the Irp here
    //
    IoAcquireCancelSpinLock(&OldIrq);
    if (pIrp = pTracker->pClientIrp)
    {
        pTracker->pClientIrp = NULL;
        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
        ASSERT (pIrpSp->Parameters.Others.Argument4 == pTracker);
        pIrpSp->Parameters.Others.Argument4 = NULL;

        IoSetCancelRoutine(pIrp, NULL);
    }
    IoReleaseCancelSpinLock(OldIrq);

    //
    // We have to reference the Device here for the calls to FindNameRemoteThenLocal,
    // and also for SendDgram
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if ((pIrp) &&
        (NBT_REFERENCE_DEVICE(pDeviceContext, REF_DEV_DGRAM, TRUE)))
    {
        //
        // attempt to find the destination name in the remote hash table.  If its
        // there, then send to it. For 1c names, this node may be the only node
        // with the 1c name registered, so check the local table, since we skipped
        // it if the name ended in 1c.
        //
        if ((status == STATUS_SUCCESS) ||
            (pTracker->pDestName[NETBIOS_NAME_SIZE-1] == 0x1c))
        {
            if (pTracker->pNameAddr)
            {
                pNameAddr = pTracker->pNameAddr;
            }
            else
            {
                //
                // Find and reference the Names if they were resolved
                //
                //
                // check if it is a 1C name and if there is a name in the domain list
                // If pNameAddr is not null, then the send to the domainlist will
                // send to the p1CNameAddr after sending to pNameAddr
                //
                if ((pTracker->pDestName[NETBIOS_NAME_SIZE-1] == 0x1c) &&
                    (p1CNameAddr = FindInDomainList(pTracker->pDestName,&DomainNames.DomainList)))
                {
                    NBT_REFERENCE_NAMEADDR (p1CNameAddr, REF_NAME_SEND_DGRAM);
                }

                if (pNameAddr = FindNameRemoteThenLocal(pTracker,&pTracker->RemoteIpAddress,&lNameType))
                {
                    NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_SEND_DGRAM);
                }
                else
                {
                    //
                    // if there is no pNameAddr then just make the domain list
                    // name the only pNameAddr to send to.
                    //
                    pNameAddr = p1CNameAddr;
                    p1CNameAddr = NULL;
                }

                pTracker->pNameAddr = pNameAddr;
                pTracker->p1CNameAddr = p1CNameAddr;
            }
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // check if the name resolved or we have a list of domain names
        // derived from the lmhosts file and it is a 1C name send.
        //
        if (pNameAddr)
        {
            // send the first datagram queued to this name
            status = SendDgram(pNameAddr,pTracker);
        }
        else
        {
            status = STATUS_BAD_NETWORK_PATH;
        }

        NBT_DEREFERENCE_DEVICE(pDeviceContext, REF_DEV_DGRAM, FALSE);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        status = STATUS_INVALID_DEVICE_STATE;
    }

    //
    // set this so that the cleanup routine does not try to dereference
    // the nameAddr

    if (status == STATUS_TIMEOUT)
    {
        status = STATUS_BAD_NETWORK_PATH;
    }

    if (pIrp)
    {
        if (NT_SUCCESS(status))
        {
            NTIoComplete (pIrp, STATUS_SUCCESS,((PTDI_REQUEST_KERNEL_SENDDG)&pIrpSp->Parameters)->SendLength);
        }
        else
        {
            // this is the ERROR handling if something goes wrong with the send
            CTEIoComplete(pIrp,status,0L);
        }
    }

    // a failure ret code means the send failed, so cleanup the tracker etc.
    if (!NT_SUCCESS(status))
    {
        DgramSendCleanupTracker(pTracker,status,FALSE);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
SendDgram(
    IN  tNAMEADDR               *pNameAddr,
    IN  tDGRAM_SEND_TRACKING    *pTracker
    )
/*++

Routine Description

    This routine handles sending client data to the Transport TDI
    interface after the destination name has resolved to an IP address. The
    routine specifically handles sending to internet group names where the destination
    is a list of ip addresses.

    The Device must be referenced before calling this routine!

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    ULONG                   IpAddress;
    NTSTATUS                status;
    PFILE_OBJECT            pFileObject;

    CHECK_PTR(pTracker);

    if (pNameAddr->NameTypeState & NAMETYPE_UNIQUE )
    {
        ((tDGRAMHDR *)pTracker->SendBuffer.pDgramHdr)->MsgType = DIRECT_UNIQUE;
    }
    else if (pNameAddr->Name[0] == '*')
    {
        ((tDGRAMHDR *)pTracker->SendBuffer.pDgramHdr)->MsgType = BROADCAST_DGRAM;
    }
    else
    {
        // must be group, -
        ((tDGRAMHDR *)pTracker->SendBuffer.pDgramHdr)->MsgType = DIRECT_GROUP;
    }

    //
    // if it is an internet group name, then send to the list of addresses
    //
    if (pNameAddr->NameTypeState & NAMETYPE_INET_GROUP)
    {
        status = DatagramDistribution(pTracker,pNameAddr);
        return(STATUS_PENDING);     // DatagramDistribution will cleanup if it failed!
    }

    if (pNameAddr->NameTypeState & NAMETYPE_GROUP)
    {
        IpAddress = 0;
    }
    else if (pNameAddr->Verify == REMOTE_NAME)
    {
        IpAddress = pTracker->RemoteIpAddress;
    }
    // LOCAL_NAME   Unique
    else if (IsDeviceNetbiosless(pTracker->pDeviceContext)) // use any non-zero value for local address
    {
        IpAddress = LOOP_BACK;
    }
    else
    {
        IpAddress = pTracker->pDeviceContext->IpAddress;
    }

    pTracker->p1CNameAddr = NULL;
    pTracker->IpListIndex = 0; // flag that there are no more addresses in the list

    /*
     * Strict source routing,
     *  1. The machine should be multi-homed.
     *  2. It is not turned off by the registry key.
     *  3. It is a regular device (not cluster device or SMB device).
     */
    if (!IsLocalAddress(IpAddress) && NbtConfig.MultiHomed && NbtConfig.SendDgramOnRequestedInterfaceOnly &&
            pTracker->pDeviceContext->IPInterfaceContext != (ULONG)(-1) &&
            (!IsDeviceNetbiosless(pTracker->pDeviceContext))) {
        ULONG   Interface, Metric;

        pTracker->pDeviceContext->pFastQuery(htonl(IpAddress), &Interface, &Metric); 
        if (Interface != pTracker->pDeviceContext->IPInterfaceContext) {
            SendDgramCompletion(pTracker, STATUS_SUCCESS, 0);
            return STATUS_PENDING;
        }
    }

    // send the Datagram...
    status = UdpSendDatagram( pTracker,
                              IpAddress,
                              SendDgramCompletion,
                              pTracker,               // context for completion
                              pTracker->pDeviceContext->DatagramPort,
                              NBT_DATAGRAM_SERVICE);

    // the irp will be completed via SendDgramCompletion
    // so don't complete it by the caller too
    return(STATUS_PENDING);
}


//----------------------------------------------------------------------------
extern
VOID
SendDgramCompletion(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo
    )
{
    CTELockHandle           OldIrq;
    tDGRAM_SEND_TRACKING    *pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pTracker->IpListIndex)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        SendNextDgramToGroup(pTracker, status);     // Further processing will be done here for Group sends
    }
    else
    {
        //
        // Datagram send to a unique name!
        //
        DgramSendCleanupTracker(pTracker,status,TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}


//----------------------------------------------------------------------------
VOID
DelayedSendDgramDist (
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused1,
    IN  tDEVICECONTEXT          *Unused2
    )

/*++

Routine Description:

    This function is called by the Executive Worker thread to send another
    datagram for the 1C name datagram distribution function.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    NTSTATUS                status;
    tDEVICECONTEXT          *pDeviceContext = pTracker->pDeviceContext;

    IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt.DelayedSendDgramDist: To name %15.15s<%X>:Ip %X, \n",
            pTracker->pNameAddr->Name,pTracker->pNameAddr->Name[15],pClientContext));

    // send the Datagram...
    if (NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DGRAM, FALSE))
    {
        status = UdpSendDatagram (pTracker,
                                  (tIPADDRESS) PtrToUlong(pClientContext),
                                  SendDgramCompletion,
                                  pTracker,
#ifdef _NETBIOSLESS
                                  pTracker->pDeviceContext->DatagramPort,
#else
                                  NBT_DATAGRAM_UDP_PORT,
#endif
                                  NBT_DATAGRAM_SERVICE);

        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DGRAM, FALSE);
    }
    else
    {
        SendNextDgramToGroup (pTracker, STATUS_BAD_NETWORK_PATH);
    }
}



//----------------------------------------------------------------------------
extern
VOID
SendNextDgramToGroup(
    IN tDGRAM_SEND_TRACKING *pTracker,
    IN  NTSTATUS            status
    )
/*++
Routine Description

    This routine is hit when the
    datagram has been sent by the transport and it completes the request back
    to us ( may not have actually sent on the wire though ).

    This routine also handles sending multiple datagrams for the InternetGroup name
    case.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/

{
    tIPADDRESS              IpAddress;
    CTELockHandle           OldIrq;

    // if this an Internet group send, then there may be more addresses in
    // the list to send to.  So check the IpListIndex.  For single
    // sends, this value is set to 0 and the code will jump to the bottom
    // where the client's irp will be completed.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    ASSERT (pTracker->RCount);  // RCount is still referenced from the last send
    // The SendCompletion can happen after the Device has been unbound,
    // so check for that also!

    if ((NT_SUCCESS(status)) &&
        (pTracker->IpListIndex < END_DGRAM_DISTRIBUTION))
    {
        IpAddress = pTracker->pGroupList[pTracker->IpListIndex++];

        if (IpAddress != (tIPADDRESS) -1) // The list ends in a -1 ipaddress, so stop when we see that
        {
            //
            // We already have an RCount reference, so no need to do another one here!
            if (NT_SUCCESS (NTQueueToWorkerThread(NULL,
                                        DelayedSendDgramDist,
                                        pTracker,
                                        ULongToPtr(IpAddress),
                                        NULL,
                                        pTracker->pDeviceContext,
                                        TRUE)))
            {
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                return;
            }
        }
    }

    pTracker->RCount--; // decrement the ref count done during the last send
    pTracker->IpListIndex = END_DGRAM_DISTRIBUTION;

    //
    // Either we failed, or we are done, so if the Timer is running, let it cleanup!
    //

    if (!(pTracker->pTimer) &&
        (pTracker->RCount == 0))
    {
        DgramSendCleanupTracker(pTracker,status,TRUE);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}


//----------------------------------------------------------------------------
extern
VOID
DgramDistTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles a short timeout on a datagram distribution.  It
    checks if the dgram send is hung up in the transport doing an ARP and
    then it does the next dgram send if the first is still hung up.

Arguments:


Return Value:

    none

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;
    tNAMEADDR               *pNameAddr;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    if (!pTimerQEntry)
    {
        pTracker->pTimer = NULL;
        if ((pTracker->IpListIndex == END_DGRAM_DISTRIBUTION) &&
            (pTracker->RCount == 0))
        {
            DgramSendCleanupTracker(pTracker,STATUS_SUCCESS,TRUE);
        }
        return;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // After the last dgram has completed the iplistindex will be set
    // to this and it is time to cleanup
    //
    if (pTracker->IpListIndex == END_DGRAM_DISTRIBUTION)
    {
        if (pTracker->RCount == 0)
        {
            IF_DBG(NBT_DEBUG_SEND)
                KdPrint(("Nbt.DgramDistTimeout: Cleanup After DgramDistribution %15.15s<%X> \n",
                            pTracker->pNameAddr->Name,pTracker->pNameAddr->Name[15]));

            pTracker->pTimer = NULL;
            DgramSendCleanupTracker(pTracker,STATUS_SUCCESS,TRUE);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return;
        }
        else
        {
            //
            // Wait for the dgram that has not completed yet - which may not
            // be the last dgram , since ARP could hold one up much long
            // than all the rest if the destination is dead. so start the timer
            // again....
            //
        }
    }
    else
    {
        if (pTracker->IpListIndex == pTracker->SavedListIndex)
        {
            //
            // The dgram send is hung up in the transport, so do the
            // next one now
            //
            IF_DBG(NBT_DEBUG_SEND)
                KdPrint(("Nbt.DgramDistTimeout: DgramDistribution hung up on ARP forcing next send\n"));

            pTracker->RCount++;     // Reference it here since SendDgramToGroup expects this to be ref'ed

            pTimerQEntry->Flags |= TIMER_RESTART;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            SendNextDgramToGroup(pTracker,STATUS_SUCCESS);
            return;
        }
        else
        {

            //
            // Save the current index so we can check it the next time the timer
            // expires
            //
            pTracker->SavedListIndex = pTracker->IpListIndex;
        }

    }

    pTimerQEntry->Flags |= TIMER_RESTART;
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}


//----------------------------------------------------------------------------
NTSTATUS
DatagramDistribution(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  tNAMEADDR               *pNameAddr
    )

/*++
Routine Description

    This routine sends a single datagram for a 1C name.  It then sends
    the next one when this one completes.  This is done so that if
    multiple sends go to the gateway, one does not cancel the next
    when an Arp is necessary to resolve the gateway.

Arguments:

    pTracker
    pNameAddr

Return Values:

    VOID

--*/

{
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    NTSTATUS                Locstatus;
    tIPADDRESS              *pIpList;
    ULONG                   Index;
    tIPADDRESS              IpAddress;
    tDEVICECONTEXT          *pDeviceContext;
    CTELockHandle           OldIrq;
    PIRP                    pIrp;
    PIO_STACK_LOCATION      pIrpSp;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    status = GetListOfAllAddrs (pTracker->pNameAddr, pTracker->p1CNameAddr, &pIpList, &Index);

    if (pTracker->p1CNameAddr)
    {
        NBT_DEREFERENCE_NAMEADDR (pTracker->p1CNameAddr, REF_NAME_SEND_DGRAM, TRUE);
        pTracker->p1CNameAddr = NULL;
    }

    NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_SEND_DGRAM, TRUE);
    pTracker->pNameAddr = NULL;
    pTracker->RCount = 1;   // Send RefCount == 0 when last send completes
    pDeviceContext = pTracker->pDeviceContext;

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    if (STATUS_SUCCESS == status)
    {
        FilterIpAddrsForDevice (pIpList, pTracker->pDeviceContext, &Index);

        pTracker->pGroupList = pIpList;

        //
        // When the proxy calls this routine the allocated length is set to
        // zero.  In that case we do not want to broadcast again since it
        // could setup an infinite loop with another proxy on the same
        // subnet.
        //
        if (pTracker->AllocatedLength == 0)
        {
            Index = 1;
        }
        else
        {
            Index = 0;
        }

        IpAddress = pIpList[Index];

        pTracker->SavedListIndex = (USHORT) (Index);    // For the next send in SendNextDgramToGroup
        pTracker->IpListIndex = pTracker->SavedListIndex + 1;    // For the next send in SendNextDgramToGroup

        if (IpAddress == (ULONG)-1)
        {
            status = STATUS_INVALID_ADDRESS;
        }
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if ((NT_SUCCESS(status)) &&
        (NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DGRAM, FALSE)))
    {
        IF_DBG(NBT_DEBUG_SEND)
            KdPrint(("Nbt.DgramDistribution: To name %15.15s<%X>: %X, pTracker=<%p>\n",
                    pNameAddr->Name,pNameAddr->Name[15],IpAddress, pTracker));

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        Locstatus = StartTimer(DgramDistTimeout,
                               DGRAM_SEND_TIMEOUT,
                               pTracker,
                               NULL,
                               pTracker,
                               NULL,
                               pDeviceContext,
                               &pTracker->pTimer,
                               1,
                               TRUE);

        if (!NT_SUCCESS(Locstatus))
        {
            CHECK_PTR(pTracker);
            pTracker->pTimer = NULL;
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // send the Datagram...
        status = UdpSendDatagram (pTracker,
                                  IpAddress,
                                  SendDgramCompletion,
                                  pTracker,
#ifdef _NETBIOSLESS
                                  pTracker->pDeviceContext->DatagramPort,
#else
                                  NBT_DATAGRAM_UDP_PORT,
#endif
                                  NBT_DATAGRAM_SERVICE);

        NBT_DEREFERENCE_DEVICE(pDeviceContext, REF_DEV_DGRAM, FALSE);
    }

    if (!NT_SUCCESS(status))
    {
        //
        // we failed to send probably because of a lack of free memory
        //
        IoAcquireCancelSpinLock(&OldIrq);
        //
        // Make sure is still there!
        //
        if (pIrp = pTracker->pClientIrp)
        {
            pTracker->pClientIrp = NULL;
            pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            ASSERT (pIrpSp->Parameters.Others.Argument4 == pTracker);
            pIrpSp->Parameters.Others.Argument4 = NULL;
            IoSetCancelRoutine(pIrp, NULL);
            IoReleaseCancelSpinLock(OldIrq);
            if (NT_SUCCESS(status))
            {
                CTEIoComplete(pIrp, STATUS_SUCCESS, 0xFFFFFFFF);
            }
            else
            {
                CTEIoComplete(pIrp, status, 0L);
            }
        }
        else
        {
            IoReleaseCancelSpinLock(OldIrq);
        }

        pTracker->RCount--;
        DgramSendCleanupTracker(pTracker,STATUS_SUCCESS,FALSE);
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtSetEventHandler(
    tCLIENTELE  *pClientEle,
    int         EventType,
    PVOID       pEventHandler,
    PVOID       pEventContext
    )
/*++

Routine Description

    This routine sets the event handler specified to the clients event procedure
    and saves the corresponding context value to return when that event is signaled.
Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    NTSTATUS            status;
    CTELockHandle       OldIrq;

    // first verify that the client element is valid
    CTEVerifyHandle(pClientEle,NBT_VERIFY_CLIENT,tCLIENTELE,&status)

    if (!pClientEle->pAddress)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    CTESpinLock(pClientEle,OldIrq);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtSetEventHandler: Handler <%x> set for Event <%x>, on name %16.16s<%X>\n",
                pEventHandler, EventType,
                ((tADDRESSELE *)pClientEle->pAddress)->pNameAddr->Name,
                ((tADDRESSELE *)pClientEle->pAddress)->pNameAddr->Name[15]));

    status = STATUS_SUCCESS;        // by default;

    if (pEventHandler)
    {
        switch (EventType)
        {
            case TDI_EVENT_CONNECT:
                pClientEle->evConnect = pEventHandler;
                pClientEle->ConEvContext = pEventContext;
                break;
            case TDI_EVENT_DISCONNECT:
                pClientEle->evDisconnect = pEventHandler;
                pClientEle->DiscEvContext = pEventContext;
                break;
            case TDI_EVENT_ERROR:
                pClientEle->evError = pEventHandler;
                pClientEle->ErrorEvContext = pEventContext;
                break;
            case TDI_EVENT_RECEIVE:
                pClientEle->evReceive = pEventHandler;
                pClientEle->RcvEvContext = pEventContext;
                break;
            case TDI_EVENT_RECEIVE_DATAGRAM:
                pClientEle->evRcvDgram = pEventHandler;
                pClientEle->RcvDgramEvContext = pEventContext;
                break;
            case TDI_EVENT_RECEIVE_EXPEDITED:
                pClientEle->evRcvExpedited = pEventHandler;
                pClientEle->RcvExpedEvContext = pEventContext;
                break;
            case TDI_EVENT_SEND_POSSIBLE:
                pClientEle->evSendPossible = pEventHandler;
                pClientEle->SendPossEvContext = pEventContext;
                break;

            case TDI_EVENT_CHAINED_RECEIVE:
            case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:
            case TDI_EVENT_CHAINED_RECEIVE_EXPEDITED:
            case TDI_EVENT_ERROR_EX:
                status = STATUS_UNSUCCESSFUL;
                break;

            default:
                ASSERTMSG("Invalid Event Type passed to SetEventHandler\n", (PVOID)0L);
                status = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {   //
        // the event handlers are set to point to the TDI default event handlers
        // and can only be changed to another one, but not to a null address,
        // so if null is passed in, set to default handler.
        //
        switch (EventType)
        {
            case TDI_EVENT_CONNECT:
#ifndef VXD
                pClientEle->evConnect = TdiDefaultConnectHandler;
#else
                pClientEle->evConnect = NULL;
#endif
                pClientEle->ConEvContext = NULL;
                break;
            case TDI_EVENT_DISCONNECT:
#ifndef VXD
                pClientEle->evDisconnect = TdiDefaultDisconnectHandler;
#else
                pClientEle->evDisconnect = NULL;
#endif
                pClientEle->DiscEvContext = NULL;
                break;
            case TDI_EVENT_ERROR:
#ifndef VXD
                pClientEle->evError = TdiDefaultErrorHandler;
#else
                pClientEle->evError = NULL;
#endif
                pClientEle->ErrorEvContext = NULL;
                break;
            case TDI_EVENT_RECEIVE:
#ifndef VXD
                pClientEle->evReceive = TdiDefaultReceiveHandler;
#else
                pClientEle->evReceive = NULL;
#endif
                pClientEle->RcvEvContext = NULL;
                break;
            case TDI_EVENT_RECEIVE_DATAGRAM:
#ifndef VXD
                pClientEle->evRcvDgram = TdiDefaultRcvDatagramHandler;
#else
                pClientEle->evRcvDgram = NULL;
#endif
                pClientEle->RcvDgramEvContext = NULL;
                break;
            case TDI_EVENT_RECEIVE_EXPEDITED:
#ifndef VXD
                pClientEle->evRcvExpedited = TdiDefaultRcvExpeditedHandler;
#else
                pClientEle->evRcvExpedited = NULL;
#endif
                pClientEle->RcvExpedEvContext = NULL;
                break;
            case TDI_EVENT_SEND_POSSIBLE:
#ifndef VXD
                pClientEle->evSendPossible = TdiDefaultSendPossibleHandler;
#else
                pClientEle->evSendPossible = NULL;
#endif
                pClientEle->SendPossEvContext = NULL;
                break;

            case TDI_EVENT_CHAINED_RECEIVE:
            case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:
            case TDI_EVENT_CHAINED_RECEIVE_EXPEDITED:
            case TDI_EVENT_ERROR_EX:
                status = STATUS_UNSUCCESSFUL;
                break;

            default:
                ASSERTMSG("Invalid Event Type passed to SetEventHandler\n", (PVOID)0L);
                status = STATUS_UNSUCCESSFUL;
        }
    }

    CTESpinFree(pClientEle,OldIrq);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtSendNodeStatus(
    IN  tDEVICECONTEXT  *pDeviceContext,
    IN  PCHAR           pName,
    IN  tIPADDRESS      *pIpAddrs,
    IN  PVOID           ClientContext,
    IN  PVOID           CompletionRoutine
    )
/*++

Routine Description

    This routine sends a node status message to another node.
    It's called for two reasons:
    1) in response to nbtstat -a (or -A).  In this case, CompletionRoutine that's
       passed in is CopyNodeStatusResponse, and ClientContext is the Irp to be completed
    2) in response to "net use \\foobar.microsoft.com" (or net use \\11.1.1.3)
       In this case, CompletionRoutine that's passed in is ExtractServerName,
       and ClientContext is the tracker that correspondes to session setup.

    The ip addr(s) s of the destination can be passed in (pIpAddrsList) when we
    want to send an adapter status to a particular host. (case 2 above and
    nbtstat -A pass in the ip address(es) since they don't know the name)

    Note for netbiosless.  In this case, the name server file object will be null, and the
    status request will be looped back in UdpSendDatagram.

Arguments:
Return Values:

    TDI_STATUS - status of the request

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    ULONG                   Length;
    PUCHAR                  pHdr;
    tNAMEADDR               *pNameAddr;
    PCHAR                   pName0;
    tIPADDRESS              IpAddress;
    tIPADDRESS UNALIGNED    *pAddress;
    tIPADDRESS              pIpAddress[2];
    tIPADDRESS              *pIpAddrsList = pIpAddrs;
    tDEVICECONTEXT          *pDeviceContextOut = NULL;
    DWORD                   i = 0;

    pName0 = pName;
    if ((pIpAddrsList) ||
        (IpAddress = Nbt_inet_addr (pName, REMOTE_ADAPTER_STAT_FLAG)))
    {
        if (!pIpAddrs)
        {
            pIpAddress[0] = IpAddress;
            pIpAddress[1] = 0;
            pIpAddrsList = pIpAddress;
        }

        if ((*pIpAddrsList == 0) ||
            (*pIpAddrsList == DEFAULT_BCAST_ADDR) ||
            (*pIpAddrsList == pDeviceContext->BroadcastAddress))
        {
            //
            // Can't do a remote adapter status to a 0 IP address or a BCast address
            return(STATUS_INVALID_ADDRESS);
        }

        // caller is expected to make sure list terminates in 0 and is
        // not bigger than MAX_IPADDRS_PER_HOST elements
        while(pIpAddrsList[i])
        {
            i++;
        }

        ASSERT(i<MAX_IPADDRS_PER_HOST);
        i++;                            // for the trailing 0

        IpAddress = pIpAddrsList[0];
        pDeviceContextOut = GetDeviceFromInterface (htonl(IpAddress), FALSE);
        if ((NbtConfig.ConnectOnRequestedInterfaceOnly) &&
            (!IsDeviceNetbiosless(pDeviceContext)) &&
            (pDeviceContext != pDeviceContextOut))
        {
            return (STATUS_BAD_NETWORK_PATH);
        }
        pName0 = NBT_BROADCAST_NAME;
    }

    IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt.NbtSendNodeStatus: <%16.16s:%x>, IP=<%x>, Completion=<%p>, Context=<%p>\n",
            pName0, pName0[15], IpAddress, CompletionRoutine, ClientContext));

    status = GetTracker(&pTracker, NBT_TRACKER_SEND_NODE_STATUS);
    if (!NT_SUCCESS(status))
    {
        return(status);
    }

    // fill in the tracker data block
    // note that the passed in transport address must stay valid till this
    // send completes
    pTracker->SendBuffer.pDgramHdr  = NULL;
    pTracker->SendBuffer.pBuffer    = NULL;
    pTracker->SendBuffer.Length     = 0;
    pTracker->Flags                 = REMOTE_ADAPTER_STAT_FLAG;
    pTracker->RefCount              = 2;     // 1 for the send completion + 1 for the node status completion
    pTracker->pDestName             = pName0;
    pTracker->UnicodeDestName       = NULL;
    pTracker->RemoteNameLength      = NETBIOS_NAME_SIZE; // May be needed for Dns Name resolution
    pTracker->pDeviceContext        = pDeviceContext;
    pTracker->pNameAddr             = NULL;
    pTracker->ClientCompletion      = CompletionRoutine;    // FindNameO.. may use CompletionRoutine!
    pTracker->ClientContext         = ClientContext;
    pTracker->p1CNameAddr           = NULL;

    // the node status is almost identical with the query pdu so use it
    // as a basis and adjust it .
    //
    pAddress = (ULONG UNALIGNED *)CreatePdu(pName0,
                                            NbtConfig.pScope,
                                            0L,
                                            0,
                                            eNAME_QUERY,
                                            (PVOID)&pHdr,
                                            &Length,
                                            pTracker);
    if (!pAddress)
    {
        FreeTracker(pTracker,RELINK_TRACKER);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    ((PUSHORT)pHdr)[1] &= ~(FL_RECURDESIRE|FL_BROADCAST);  // clear the recursion desired and broadcast bit
    pHdr[Length-3] = (UCHAR)QUEST_STATUS;   // set the NBSTAT field to 21 rather than 20

    pTracker->SendBuffer.pDgramHdr = (PVOID)pHdr;
    pTracker->SendBuffer.HdrLength  = Length;

    if (IpAddress)
    {
        // this 'fake' pNameAddr has to be setup carefully so that the memory
        // is released when NbtDeferenceName is called from SendDgramCompletion
        // Note that this code does not apply to NbtConnect since these names
        // are group names, and NbtConnect will not allow a session to a group
        // name.
        status = STATUS_INSUFFICIENT_RESOURCES;
        if (!(pNameAddr = NbtAllocMem(sizeof(tNAMEADDR),NBT_TAG('K'))))
        {
            FreeTracker(pTracker,RELINK_TRACKER);
            CTEMemFree(pHdr);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        CTEZeroMemory(pNameAddr,sizeof(tNAMEADDR));
        InitializeListHead (&pNameAddr->Linkage);
        CTEMemCopy (pNameAddr->Name, pName0, NETBIOS_NAME_SIZE ) ;
        pNameAddr->IpAddress        = IpAddress;
        pNameAddr->NameTypeState    = NAMETYPE_GROUP | STATE_RESOLVED;
        pNameAddr->Verify           = LOCAL_NAME;
        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_NODE_STATUS);
        if (pDeviceContextOut)
        {
            pNameAddr->AdapterMask = pDeviceContextOut->AdapterMask;
        }
        pNameAddr->TimeOutCount     = NbtConfig.RemoteTimeoutCount;

        if (!(pNameAddr->pIpAddrsList = NbtAllocMem(i*sizeof(ULONG),NBT_TAG('M'))))
        {
            FreeTracker(pTracker,RELINK_TRACKER);
            CTEMemFree(pHdr);
            CTEMemFree(pNameAddr);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        i = 0;
        do
        {
            pNameAddr->pIpAddrsList[i] = pIpAddrsList[i];
        } while(pIpAddrsList[i++]);

        status = STATUS_SUCCESS;
    }
    else
    {
        status = FindNameOrQuery(pName,
                                 pDeviceContext,
                                 SendNodeStatusContinue,
                                 pTracker,
                                 (ULONG) NAMETYPE_UNIQUE,
                                 &IpAddress,
                                 &pNameAddr,
                                 REF_NAME_NODE_STATUS,
                                 FALSE);
    }

    if (status == STATUS_SUCCESS)
    {
        pTracker->RemoteIpAddress   = IpAddress;

        pTracker->p1CNameAddr   = pNameAddr;    // Since we have already Ref'ed
        pNameAddr->IpAddress    = IpAddress;

        SendNodeStatusContinue (pTracker, STATUS_SUCCESS);
        status = STATUS_PENDING;    // SendNodeStatusContinue will cleanup
    }
    else if (!NT_SUCCESS(status))   // i.e not pending
    {
        FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);
    }

    return(status);
}


//----------------------------------------------------------------------------
VOID
SendNodeStatusContinue(
    IN  PVOID       pContext,
    IN  NTSTATUS    status
    )
/*++

Routine Description

    This routine handles sending a node status request to a node after the
    name has been resolved on the net.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq, OldIrq1;
    tNAMEADDR               *pNameAddr = NULL;
    ULONG                   lNameType;
    tTIMERQENTRY            *pTimerEntry;
    ULONG                   IpAddress;
    PCTE_IRP                pIrp;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   pClientContext;

    pTracker = (tDGRAM_SEND_TRACKING *) pContext;
    ASSERT (NBT_VERIFY_HANDLE (pTracker, NBT_VERIFY_TRACKER));
    ASSERT (pTracker->TrackerType == NBT_TRACKER_SEND_NODE_STATUS);

    DELETE_CLIENT_SECURITY(pTracker);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // attempt to find the destination name in the remote hash table.  If its
    // there, then send to it.
    //
    lNameType = NAMETYPE_UNIQUE;
    if ((status == STATUS_SUCCESS) &&
        ((pTracker->p1CNameAddr) ||
         (pNameAddr = FindNameRemoteThenLocal(pTracker, &IpAddress, &lNameType))))
    {
        //
        // found the name in the remote hash table, so send to it after
        // starting a timer to be sure we really do get a response
        //
        status = StartTimer(NodeStatusTimeout,
                            NbtConfig.uRetryTimeout,
                            pTracker,                       // Timer context value
                            NULL,                           // Timer context2 value
                            pTracker->ClientContext,        // ClientContext
                            pTracker->ClientCompletion,     // ClientCompletion
                            pTracker->pDeviceContext,
                            &pTimerEntry,
                            NbtConfig.uNumRetries,
                            TRUE);

        if (NT_SUCCESS(status))
        {
            if (pNameAddr)
            {
                // increment refcount so the name does not disappear
                // dereference when we get the response or timeout
                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_NODE_STATUS);
                pTracker->RemoteIpAddress = IpAddress;
            }
            else
            {
                //
                // This name was already Referenced either in NbtSendNodeStatus
                // or FindNameOrQuery
                //
                pNameAddr = pTracker->p1CNameAddr;
                pTracker->p1CNameAddr = NULL;
                IpAddress = pTracker->RemoteIpAddress;
            }

            pTracker->pNameAddr = pNameAddr;
            pTracker->pTimer = pTimerEntry;

            //
            // Save the transaction ID so that we can match it later on
            //
            pTracker->TransactionId = ((tNAMEHDR*)(pTracker->SendBuffer.pDgramHdr))->TransactId;

            // send the Datagram...
            // the tracker block is put on a global Q in the Config
            // data structure to keep track of it.
            //
            ExInterlockedInsertTailList(&NbtConfig.NodeStatusHead,
                                        &pTracker->Linkage,
                                        &NbtConfig.LockInfo.SpinLock);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            status = UdpSendDatagram (pTracker,
                                      IpAddress,
                                      NameDgramSendCompleted,
                                      pTracker,                 // context
#ifdef _NETBIOSLESS
                                      pTracker->pDeviceContext->NameServerPort,
#else
                                      NBT_NAMESERVICE_UDP_PORT,
#endif
                                      NBT_NAME_SERVICE);

            if (!(NT_SUCCESS(status)))
            {
                //
                // this undoes one of two ref's added in NbtSendNodeStatus
                //
                CTESpinLock(&NbtConfig.JointLock,OldIrq);

                CTEMemFree(pTracker->SendBuffer.pDgramHdr);
                pTracker->SendBuffer.pDgramHdr = NULL;
                NBT_DEREFERENCE_TRACKER(pTracker, TRUE);

                CTESpinFree(&NbtConfig.JointLock,OldIrq);
            }

            // if the send fails, the timer will resend it...so no need
            // to check the return code here.
            return;
        }
    }

    if (pTracker->p1CNameAddr)
    {
        NBT_DEREFERENCE_NAMEADDR (pTracker->p1CNameAddr, REF_NAME_NODE_STATUS, TRUE);
        pTracker->p1CNameAddr = NULL;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    // this is the ERROR handling if we failed to resolve the name
    // or the timer did not start
    pClientCompletion = pTracker->ClientCompletion;
    pClientContext = pTracker->ClientContext;

    if (pClientCompletion)
    {
        (*pClientCompletion) (pClientContext, STATUS_UNSUCCESSFUL);
    }

    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);
}


//----------------------------------------------------------------------------
VOID
NodeStatusTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles the NodeStatus timeouts on packets sent to nodes
    that do not respond in a timely manner to node status.  This routine will
    resend the request.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq, OldIrq1;
    COMPLETIONCLIENT        pClientCompletion;
    PVOID                   pClientContext;
    PCHAR                   pName0;
    PUCHAR                  pHdr;
    ULONG                   Length;
    ULONG UNALIGNED         *pAddress;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    ASSERT (NBT_VERIFY_HANDLE (pTracker, NBT_VERIFY_TRACKER));
    ASSERT (pTracker->TrackerType == NBT_TRACKER_SEND_NODE_STATUS);

    if (!pTimerQEntry)
    {
        //
        // Do not dereference here since  Node Status Done will do
        // the dereference
        //
        CTESpinLock(&NbtConfig,OldIrq1);
        RemoveEntryList(&pTracker->Linkage);
        InitializeListHead(&pTracker->Linkage);
        CTESpinFree(&NbtConfig,OldIrq1);

        pTracker->pTimer = NULL;
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_NODE_STATUS, TRUE);
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);

        return;
    }

    CHECK_PTR(pTimerQEntry);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pTracker->SendBuffer.pDgramHdr)
    {
        //
        // The timer has expired before the original Datagram
        // could be sent, so just restart the timer!
        //
        pTimerQEntry->Flags |= TIMER_RESTART;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        return;
    }

    if ((--pTimerQEntry->Retries) == 0)
    {
        pClientCompletion = pTimerQEntry->ClientCompletion;
        pClientContext = pTimerQEntry->ClientContext;
        pTimerQEntry->ClientCompletion = NULL;
        pTracker->pTimer = NULL;

        // if the client routine has not yet run, run it now.
        if (pClientCompletion)
        {
            // unlink the tracker from the node status Q if we successfully
            // called the completion routine. Note, remove from the
            // list before calling the completion routine to coordinate
            // with DecodeNodeStatusResponse in inbound.c
            //
            CTESpinLock(&NbtConfig,OldIrq1);
            RemoveEntryList(&pTracker->Linkage);
            InitializeListHead(&pTracker->Linkage);
            CTESpinFree(&NbtConfig,OldIrq1);

            NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_NODE_STATUS, TRUE);
            NBT_DEREFERENCE_TRACKER (pTracker, TRUE);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            (*pClientCompletion) (pClientContext, STATUS_TIMEOUT);

        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }

        return;
    }

    // send the Datagram...increment ref count
    NBT_REFERENCE_TRACKER (pTracker);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // the node status is almost identical with the query pdu so use it
    // as a basis and adjust it . We always rebuild the Node status
    // request since the datagram gets freed when the irp is returned
    // from the transport.
    //

    if (pTracker->p1CNameAddr)
    {
        pName0 = pTracker->p1CNameAddr->Name;
    }
    else
    {
        pName0 = pTracker->pNameAddr->Name;
    }

    pAddress = (ULONG UNALIGNED *)CreatePdu(pName0,
                                            NbtConfig.pScope,
                                            0L,
                                            0,
                                            eNAME_QUERY,
                                            (PVOID)&pHdr,
                                            &Length,
                                            pTracker);
    if (pAddress)
    {
        // clear the recursion desired bit
        //
        ((PUSHORT)pHdr)[1] &= ~FL_RECURDESIRE;

        // set the NBSTAT field to 21 rather than 20
        pHdr[Length-3] = (UCHAR)QUEST_STATUS;


        // fill in the tracker data block
        // the passed in transport address must stay valid till this send completes
        pTracker->SendBuffer.pDgramHdr = (PVOID)pHdr;
        status = UdpSendDatagram (pTracker,
                                  pTracker->pNameAddr->IpAddress,
                                  NameDgramSendCompleted,
                                  pTracker,
#ifdef _NETBIOSLESS
                                  pTracker->pDeviceContext->NameServerPort,
#else
                                  NBT_NAMESERVICE_UDP_PORT,
#endif
                                  NBT_NAME_SERVICE);

    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (!(NT_SUCCESS(status)))
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        if (pTracker->SendBuffer.pDgramHdr)
        {
            CTEMemFree(pTracker->SendBuffer.pDgramHdr);
            pTracker->SendBuffer.pDgramHdr = NULL;
        }
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    // always restart even if the above send fails, since it might succeed
    // later.
    pTimerQEntry->Flags |= TIMER_RESTART;
}


//----------------------------------------------------------------------------
#ifndef VXD
VOID
NTClearFindNameInfo(
    tDGRAM_SEND_TRACKING    *pTracker,
    PIRP                    *ppClientIrp,
    PIRP                    pIrp,
    PIO_STACK_LOCATION      pIrpSp
    )
/*++

Routine Description

    This routine clears the Find Name information from the Tracker
    within the Cancel SpinLock -- since NbtQueryFindNameInfo is a
    pageable function, we have to do this in non-pageable code

Arguments:


Return Values:

    none

--*/
{
    CTELockHandle           OldIrq1;

    IoAcquireCancelSpinLock(&OldIrq1);
    *ppClientIrp = pTracker->pClientIrp;
    if (*ppClientIrp == pIrp)
    {
        pTracker->pClientIrp = NULL;
    }
    pIrpSp->Parameters.Others.Argument4 = NULL;
    IoReleaseCancelSpinLock(OldIrq1);
}
#endif  // !VXD



NTSTATUS
NbtQueryFindName(
    IN  PTDI_CONNECTION_INFORMATION     pInfo,
    IN  tDEVICECONTEXT                  *pDeviceContext,
    IN  PIRP                            pIrp,
    IN  BOOLEAN                         IsIoctl
    )
/*++

Routine Description

    This routine handles a Client's query to find a netbios name.  It
    ultimately returns the IP address of the destination.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    PCHAR                   pName;
    ULONG                   lNameType;
    tNAMEADDR               *pNameAddr;
    PIRP                    pClientIrp = 0;
    ULONG                   NameLen;
    TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;

#ifndef VXD
    PIO_STACK_LOCATION      pIrpSp;
#endif

    CTEPagedCode();

    // this routine gets a ptr to the netbios name out of the wierd
    // TDI address syntax.
    if (!IsIoctl)
    {
        ASSERT(pInfo->RemoteAddressLength);
        status = GetNetBiosNameFromTransportAddress((PTRANSPORT_ADDRESS) pInfo->RemoteAddress,
                                                    pInfo->RemoteAddressLength, &TdiAddr);
        pName = TdiAddr.OEMRemoteName.Buffer;
        NameLen = TdiAddr.OEMRemoteName.Length;
        lNameType = TdiAddr.NameType;

        if ((!NT_SUCCESS(status)) ||
            (lNameType != TDI_ADDRESS_NETBIOS_TYPE_UNIQUE) ||
            (NameLen > NETBIOS_NAME_SIZE))
        {
            IF_DBG(NBT_DEBUG_SEND)
                KdPrint(("Nbt.NbtQueryFindName: Unable to get dest name from address in QueryFindName\n"));
            return(STATUS_INVALID_PARAMETER);
        }
    }
#ifndef VXD
    else
    {
        pName = ((tIPADDR_BUFFER *)pInfo)->Name;
        NameLen = NETBIOS_NAME_SIZE;
    }
#endif

    IF_DBG(NBT_DEBUG_SEND)
        KdPrint(("Nbt.NbtQueryFindName: For  = %16.16s<%X>\n",pName,pName[15]));

    //
    // this will query the name on the network and call a routine to
    // finish sending the datagram when the query completes.
    //
    status = GetTracker(&pTracker, NBT_TRACKER_QUERY_FIND_NAME);
    if (!NT_SUCCESS(status))
    {
        return(status);
    }

    pTracker->pClientIrp      = pIrp;
    pTracker->pDestName       = pName;
    pTracker->UnicodeDestName = NULL;
    pTracker->pDeviceContext  = pDeviceContext;
    pTracker->RemoteNameLength = NameLen;       // May be needed for Dns Name resolution

    //
    // Set the FIND_NAME_FLAG here to indicate to the DNS name resolution code that
    // this is not a session setup attempt so it can avoid the call to
    // ConvertToHalfAscii (where pSessionHdr is NULL).
    //
    if (IsIoctl)
    {
        // Do not do DNS query for this name since this is from GetHostByName!
        pTracker->Flags = REMOTE_ADAPTER_STAT_FLAG|FIND_NAME_FLAG|NO_DNS_RESOLUTION_FLAG;
    }
    else
    {
        pTracker->Flags = REMOTE_ADAPTER_STAT_FLAG|FIND_NAME_FLAG;
    }

#ifndef VXD
    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrpSp->Parameters.Others.Argument4 = (PVOID)pTracker;
    status = NTCheckSetCancelRoutine( pIrp, NbtCancelFindName,pDeviceContext );

    if (status == STATUS_CANCELLED )
    {
        FreeTracker(pTracker,RELINK_TRACKER);
        return(status);
    }
#endif

    status = FindNameOrQuery(pName,
                             pDeviceContext,
                             QueryNameCompletion,
                             pTracker,
                             (ULONG) (NAMETYPE_UNIQUE | NAMETYPE_GROUP | NAMETYPE_INET_GROUP),
                             &pTracker->RemoteIpAddress,
                             &pNameAddr,
                             REF_NAME_FIND_NAME,
                             FALSE);

    if ((status == STATUS_SUCCESS) || (!NT_SUCCESS(status)))
    {
#ifndef VXD
        NTClearFindNameInfo (pTracker, &pClientIrp, pIrp, pIrpSp);
#else
        pClientIrp = pTracker->pClientIrp;
#endif
        if (pClientIrp)
        {
            ASSERT( pClientIrp == pIrp );

            if (status == STATUS_SUCCESS)
            {
                status = CopyFindNameData(pNameAddr, pIrp, pTracker);
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_FIND_NAME, FALSE);
            }
        }

        //
        // irp is already completed: return pending so we don't complete again
        //
        else
        {
            if (status == STATUS_SUCCESS)
            {
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_FIND_NAME, FALSE);
            }
            status = STATUS_PENDING;
        }


        FreeTracker(pTracker, RELINK_TRACKER);
    }

    return(status);
}

//----------------------------------------------------------------------------
VOID
QueryNameCompletion(
        IN  PVOID       pContext,
        IN  NTSTATUS    status
        )
/*++

Routine Description

    This routine handles a name query completion that was requested by the
    client.  If successful the client is returned the ip address of the name
    passed in the original request.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq1;
    tNAMEADDR               *pNameAddr;
    ULONG                   lNameType;
    PIRP                    pClientIrp;
#ifndef VXD
    PIO_STACK_LOCATION      pIrpSp;

    //
    // We now use Cancel SpinLocks to check the validity of our Irps
    // This is to prevent a race condition in between the time that
    // the Cancel routine (NbtCancelFindName) releases the Cancel SpinLock
    // and acquires the joint lock and we complete the Irp over here
    //
    IoAcquireCancelSpinLock(&OldIrq1);
#endif

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    pClientIrp = pTracker->pClientIrp;
    pTracker->pClientIrp = NULL;

#ifndef VXD
    //
    // Make sure all parameters are valid for the Irp processing
    //
    if (! ((pClientIrp) &&
           (pIrpSp = IoGetCurrentIrpStackLocation(pClientIrp)) &&
           (pIrpSp->Parameters.Others.Argument4 == pTracker)     ) )
    {
        IoReleaseCancelSpinLock(OldIrq1);

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt:QueryNameCompletion: Irp=<%p> was cancelled\n", pClientIrp));

        FreeTracker( pTracker,RELINK_TRACKER );
        return;
    }

    pIrpSp->Parameters.Others.Argument4 = NULL;
    IoSetCancelRoutine(pClientIrp, NULL);
    IoReleaseCancelSpinLock(OldIrq1);
#endif

    //
    // attempt to find the destination name in the local/remote hash table.
    //
    if ((status == STATUS_SUCCESS) &&
        (NT_SUCCESS(status = CopyFindNameData (NULL, pClientIrp, pTracker))))
    {
        CTEIoComplete(pClientIrp,status,0xFFFFFFFF);
    }
    else
    {
        // this is the ERROR handling if something goes wrong with the send
        CTEIoComplete(pClientIrp,STATUS_IO_TIMEOUT,0L);
    }

    FreeTracker(pTracker,RELINK_TRACKER);
}


//----------------------------------------------------------------------------
NTSTATUS
CopyFindNameData(
    IN  tNAMEADDR              *pNameAddr,
    IN  PIRP                   pIrp,
    IN  tDGRAM_SEND_TRACKING   *pTracker
    )
/*++
Routine Description:

    This Routine copies data received from the net node status response to
    the client's irp.


Arguments:

    pIrp - a  ptr to an IRP

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS            status;
    PFIND_NAME_HEADER   pFindNameHdr;
    PFIND_NAME_BUFFER   pFindNameBuffer;
    tIPADDRESS          *pIpAddr = NULL;
    ULONG               BuffSize;
    ULONG               DataLength;
    ULONG               NumNames;
    ULONG               i;
    ULONG               lNameType;
    CTELockHandle       OldIrq;
    tIPADDRESS          SrcAddress, DestIpAddress;
    tIPADDRESS          *pIpAddrBuffer;
    tDEVICECONTEXT      *pDeviceContext = pTracker->pDeviceContext;

    SrcAddress = htonl(pDeviceContext->IpAddress);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (!pNameAddr)
    {
        if (pNameAddr = FindNameRemoteThenLocal (pTracker, &DestIpAddress, &lNameType))
        {
            pNameAddr->IpAddress = DestIpAddress;
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return (STATUS_IO_TIMEOUT);
        }
    }

    status = GetListOfAllAddrs(pNameAddr, NULL, &pIpAddr, &NumNames);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (STATUS_SUCCESS != status)
    {
        return (STATUS_IO_TIMEOUT);
    }

#ifdef VXD
    DataLength = ((NCB*)pIrp)->ncb_length ;
#else
    DataLength = MmGetMdlByteCount( pIrp->MdlAddress ) ;
#endif

    BuffSize = sizeof(FIND_NAME_HEADER) + NumNames*sizeof(FIND_NAME_BUFFER);

    //
    //  Make sure we don't overflow our buffer
    //
    if (BuffSize > DataLength)
    {
        if (DataLength <= sizeof(FIND_NAME_HEADER))
        {
            NumNames = 0 ;
        }
        else
        {
            NumNames = (DataLength - sizeof(FIND_NAME_HEADER)) / sizeof(FIND_NAME_BUFFER) ;
        }

        BuffSize = sizeof(FIND_NAME_HEADER) + NumNames*sizeof(FIND_NAME_BUFFER);
    }

    // sanity check that we are not allocating more than 64K for this stuff
    if (BuffSize > 0xFFFF)
    {
        return(STATUS_UNSUCCESSFUL);
    }
    else if ((NumNames == 0) ||
             (!(pFindNameHdr = NbtAllocMem ((USHORT)BuffSize, NBT_TAG('N')))))
    {
        if (pIpAddr)
        {
            CTEMemFree((PVOID)pIpAddr);
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Fill out the find name structure with zeros first
    CTEZeroMemory((PVOID)pFindNameHdr,BuffSize);
    pFindNameBuffer = (PFIND_NAME_BUFFER)((PUCHAR)pFindNameHdr + sizeof(FIND_NAME_HEADER));
    pFindNameHdr->node_count = (USHORT)NumNames;
    pFindNameHdr->unique_group = (pNameAddr->NameTypeState & NAMETYPE_UNIQUE) ? UNIQUE_NAME : GROUP_NAME;

    for (i=0;i < NumNames ;i++)
    {
        // Note: the source and destination address appear to be
        // reversed since they are supposed to be the source and
        // destination of the response to the findname query, hence
        // the destination of the response is this node and the
        // source is the other node.
        *(tIPADDRESS UNALIGNED *) &pFindNameBuffer->source_addr[2]      = htonl(pIpAddr[i]);
        *(tIPADDRESS UNALIGNED *) &pFindNameBuffer->destination_addr[2] = SrcAddress;
        pFindNameBuffer++;
    }

#ifdef VXD
    CTEMemCopy (((NCB*)pIrp)->ncb_buffer, pFindNameHdr, BuffSize);
    ASSERT( ((NCB*)pIrp)->ncb_length >= BuffSize ) ;
    ((NCB*)pIrp)->ncb_length = BuffSize ;
    status = STATUS_SUCCESS ;
#else
    //
    // copy the buffer to the client's MDL
    //
    status = TdiCopyBufferToMdl (pFindNameHdr, 0, BuffSize, pIrp->MdlAddress, 0, &DataLength);

    pIrp->IoStatus.Information = DataLength;
    pIrp->IoStatus.Status = status;
#endif

    if (pIpAddr)
    {
        CTEMemFree((PVOID)pIpAddr);
    }
    CTEMemFree((PVOID)pFindNameHdr);

    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtAddEntryToRemoteHashTable(
    IN tDEVICECONTEXT   *pDeviceContext,
    IN USHORT           NameAddFlag,
    IN PUCHAR           Name,
    IN ULONG            IpAddress,
    IN ULONG            Ttl,            // in seconds
    IN UCHAR            name_flags
    )
{
    NTSTATUS        status;
    tNAMEADDR       *pNameAddr;
    CTELockHandle   OldIrq;

    CTESpinLock (&NbtConfig.JointLock, OldIrq);

    //
    // We need only the name, IpAddress, name_flags, and Ttl fields
    //
    if (STATUS_SUCCESS == FindInHashTable (NbtConfig.pRemoteHashTbl,
                                           Name, NbtConfig.pScope, &pNameAddr))
    {
        status = STATUS_DUPLICATE_NAME;
    }
    else if (pNameAddr = NbtAllocMem(sizeof(tNAMEADDR),NBT_TAG('8')))
    {
        CTEZeroMemory (pNameAddr,sizeof(tNAMEADDR));
        InitializeListHead (&pNameAddr->Linkage);
        pNameAddr->Verify = REMOTE_NAME;
        if (NameAddFlag & NAME_RESOLVED_BY_CLIENT)
        {
            pNameAddr->AdapterMask = (CTEULONGLONG)-1;
        }
        else if (pDeviceContext)
        {
            pNameAddr->AdapterMask = pDeviceContext->AdapterMask;
        }

        //
        // Now copy the user-supplied data
        //
        CTEMemCopy (pNameAddr->Name,Name,NETBIOS_NAME_SIZE);
        pNameAddr->TimeOutCount = (USHORT) (Ttl / (REMOTE_HASH_TIMEOUT/1000)) + 1;
        pNameAddr->IpAddress = IpAddress;
        if (name_flags & GROUP_STATUS)
        {
            pNameAddr->NameTypeState = STATE_RESOLVED | NAMETYPE_GROUP;
        }
        else
        {
            pNameAddr->NameTypeState = STATE_RESOLVED | NAMETYPE_UNIQUE;
        }

        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE);
        status = AddToHashTable(NbtConfig.pRemoteHashTbl,
                                pNameAddr->Name,
                                NbtConfig.pScope,
                                IpAddress,
                                0,
                                pNameAddr,
                                NULL,
                                pDeviceContext,
                                NameAddFlag);

        //
        // If AddToHashTable fails, it will free the pNameAddr structure
        // within itself, so no need to cleanup here!
        //
        if (NT_SUCCESS (status))    // SUCCESS if added first time, PENDING if name already existed!
        {
            status = STATUS_SUCCESS;
        }
        if (status == STATUS_SUCCESS && NameAddFlag & NAME_RESOLVED_BY_CLIENT) {
            //
            // this prevents the name from being deleted by the Hash Timeout code
            //
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_PRELOADED);
            pNameAddr->Ttl = 0xFFFFFFFF;
            pNameAddr->NameTypeState |= PRELOADED | STATE_RESOLVED;
            pNameAddr->NameTypeState &= ~STATE_CONFLICT;
            pNameAddr->AdapterMask = (CTEULONGLONG)-1;
        }
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    CTESpinFree (&NbtConfig.JointLock, OldIrq);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtAddEntryToRemoteHashTable: Name=<%16.16s:%x>, status=<%x>\n",
            Name, Name[15], status));

    return status;
}


//----------------------------------------------------------------------------
NTSTATUS
NbtQueryAdapterStatus(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppAdapterStatus,
    IN OUT PLONG        pSize,
    enum eNbtLocation   Location
    )
/*++

Routine Description

    This routine creates a list of netbios names that are registered and
    returns a pointer to the list in pAdapterStatus.

    This routine can be called with a Null DeviceContext meaning, get the
    remote hash table names, rather than the local hash table names.


Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    NTSTATUS            status;
    CTELockHandle       OldIrq1;
    LONG                ActualCount, AllocatedCount;
    LONG                j;
    LONG                BuffSize;
    PADAPTER_STATUS     pAdapterStatus;
    PLIST_ENTRY         pEntry;
    PLIST_ENTRY         pHead;
    PNAME_BUFFER        pNameBuffer;
    tADDRESSELE         *pAddressEle;
    tNAMEADDR           *pNameAddr;
    tHASHTABLE          *pHashTable;
    ULONG               NameSize;
    USHORT              MaxAllowed;
    PUCHAR              pMacAddr;
    tIPADDRESS          IpAddress;
    tIPADDRESS          *pIpNbtGroupList;
    ULONG               Ttl;

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    AllocatedCount = 0;
    if (Location == NBT_LOCAL)      // ==> Local Hash table
    {
        pHashTable = NbtConfig.pLocalHashTbl;
        NameSize = sizeof(NAME_BUFFER);
    }
    else                            // ==> Remote Hash table
    {
        // get the list of addresses for this device - remote hash table
        pHashTable = NbtConfig.pRemoteHashTbl;
        NameSize = sizeof(tREMOTE_CACHE);
    }

    for (j=0;j < pHashTable->lNumBuckets ;j++ )
    {
        pHead = &pHashTable->Bucket[j];
        pEntry = pHead;
        while ((pEntry = pEntry->Flink) != pHead)
        {
            AllocatedCount++;
        }
    }

    // Allocate Memory for the adapter status
    BuffSize = sizeof(ADAPTER_STATUS) + AllocatedCount*NameSize;

#ifdef VXD
    //
    // The max BuffSize for Win9x is limited by a UShort,
    // so see if we are going to overflow that
    //
    if (BuffSize > MAXUSHORT)   // Make sure BuffSize fits in a USHORT
    {
        BuffSize = MAXUSHORT;   // Recalculate BuffSize and AllocatedCount
        AllocatedCount = (BuffSize - sizeof(ADAPTER_STATUS)) / NameSize;
    }
#endif  // VXD

#ifdef VXD
    pAdapterStatus = NbtAllocMem((USHORT)BuffSize,NBT_TAG('O'));
#else
    pAdapterStatus = NbtAllocMem(BuffSize,NBT_TAG('O'));
#endif

    if (!pAdapterStatus)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Fill out the adapter status structure with zeros first
    CTEZeroMemory((PVOID)pAdapterStatus,BuffSize);

    //
    // Fill in the  MAC address
    //
    pMacAddr = &pDeviceContext->MacAddress.Address[0];
    CTEMemCopy(&pAdapterStatus->adapter_address[0], pMacAddr, sizeof(tMAC_ADDRESS));

    pAdapterStatus->rev_major = 0x03;
    pAdapterStatus->adapter_type = 0xFE;    // pretend it is an ethernet adapter

    //
    // in the VXD land limit the number of Ncbs to 64
    //
#ifndef VXD
    MaxAllowed = 0xFFFF;
    pAdapterStatus->max_cfg_sess = (USHORT)MaxAllowed;
    pAdapterStatus->max_sess = (USHORT)MaxAllowed;
#else
    MaxAllowed = 64;
    pAdapterStatus->max_cfg_sess = pDeviceContext->cMaxSessions;
    pAdapterStatus->max_sess = pDeviceContext->cMaxSessions;
#endif

    pAdapterStatus->free_ncbs = (USHORT)MaxAllowed;
    pAdapterStatus->max_cfg_ncbs = (USHORT)MaxAllowed;
    pAdapterStatus->max_ncbs = (USHORT)MaxAllowed;

    pAdapterStatus->max_dgram_size    = MAX_NBT_DGRAM_SIZE;
    pAdapterStatus->max_sess_pkt_size = 0xffff;

    // get the address of the name buffer at the end of the adapter status
    // structure so we can copy the names into this area.
    pNameBuffer = (PNAME_BUFFER)((ULONG_PTR)pAdapterStatus + sizeof(ADAPTER_STATUS));

    ActualCount = 0;
    j = 0;
    if (Location == NBT_LOCAL)
    {
        pEntry = pHead = &NbtConfig.AddressHead;
    }
    else
    {
        pEntry = pHead = &pHashTable->Bucket[0];
    }

    while (AllocatedCount)
    {
        if (Location == NBT_LOCAL)
        {
            // ***** LOCAL HASH TABLE QUERY *****

            // get out of while if we reach the end of the list
            if ((pEntry = pEntry->Flink) == pHead)
            {
                break;
            }

            pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);
            pNameAddr = pAddressEle->pNameAddr;

            //
            // skip the broadcast name and any permanent names that are
            // registered as quick names(i.e. not registered on the net).
            //
            if ((pAddressEle->pNameAddr->Name[0] == '*') ||
                (pAddressEle->pNameAddr->NameTypeState & NAMETYPE_QUICK) ||
                (!(pAddressEle->pNameAddr->AdapterMask & pDeviceContext->AdapterMask)))  // This Device only
            {
                continue;
            }
        }
        else
        {
            // ***** REMOTE HASH TABLE QUERY *****

            //
            // See if we have reached the end of the HashTable
            //
            if (j == pHashTable->lNumBuckets)
            {
                break;
            }

            //
            // See if we have reached the last entry in the HashBucket
            //
            if ((pEntry = pEntry->Flink) == pHead)
            {
                pEntry = pHead = &pHashTable->Bucket[++j];
                continue;
            }

            // for the remote table, skip over scope records.
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);

            // don't return scope records or resolving records
            //
            if ((pNameAddr->NameTypeState & NAMETYPE_SCOPE) ||
                (!(pNameAddr->NameTypeState & STATE_RESOLVED)) ||
                (!(pNameAddr->AdapterMask & pDeviceContext->AdapterMask)))
            {
                continue;
            }
            //
            // the remote cache query has a different structure that includes
            // the ip address. Return the ip address to the caller.
            //
            IpAddress = 0;
            PickBestAddress (pNameAddr, pDeviceContext, &IpAddress);
            ((tREMOTE_CACHE *)pNameBuffer)->IpAddress = IpAddress;

            // preloaded entries do not timeout
            //
            if (pNameAddr->NameTypeState & PRELOADED)
            {
                Ttl = 0xFFFFFFFF;
            }
            else
            {
                Ttl = ((pNameAddr->TimeOutCount+1) * REMOTE_HASH_TIMEOUT)/1000;
            }

            ((tREMOTE_CACHE *)pNameBuffer)->Ttl = Ttl;
        }

        pNameBuffer->name_flags = (pNameAddr->NameTypeState & NAMETYPE_UNIQUE) ? UNIQUE_NAME : GROUP_NAME;
        switch (pNameAddr->NameTypeState & NAME_STATE_MASK)
        {
            default:
            case STATE_RESOLVED:
                pNameBuffer->name_flags |= REGISTERED;
                break;

            case STATE_CONFLICT:
                pNameBuffer->name_flags |= DUPLICATE;
                break;

            case STATE_RELEASED:
                pNameBuffer->name_flags |= DEREGISTERED;
                break;

            case STATE_RESOLVING:
                pNameBuffer->name_flags |= REGISTERING;
                break;
        }

        //
        // name number 0 corresponds to perm.name name, so start from 1
        //
        pNameBuffer->name_num = (UCHAR) (ActualCount+1);
        CTEMemCopy(pNameBuffer->name,pNameAddr->Name,NETBIOS_NAME_SIZE);

        if (Location == NBT_LOCAL)
        {
            pNameBuffer++;
        }
        else
        {
            ((tREMOTE_CACHE *)pNameBuffer)++;
        }

        AllocatedCount--;
        ActualCount++;
    }

    //
    // ReCalculate the new BuffSize based on the number of names
    // we actually copied
    //
    BuffSize = sizeof(ADAPTER_STATUS) + ActualCount*NameSize;

    //
    // Is our status buffer size greater then the user's buffer?
    // If the user buffer is expected to overflow, then
    // set the name_count to the maximum number of valid names
    // in the buffer
    //
    if (BuffSize > *pSize)
    {
        //
        //  Recalc how many names will fit
        //
        if (*pSize <= sizeof(ADAPTER_STATUS))
        {
            ActualCount = 0;
        }
        else
        {
            ActualCount = (*pSize - sizeof(ADAPTER_STATUS)) / NameSize;
        }
    }

    pAdapterStatus->name_count = (USHORT)ActualCount;

    //
    // return the ptr to this wonderful structure of goodies
    //
    *ppAdapterStatus = (PVOID)pAdapterStatus;
    *pSize = BuffSize;

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    return (STATUS_SUCCESS);

}
//----------------------------------------------------------------------------
NTSTATUS
NbtQueryConnectionList(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppConnList,
    IN OUT PLONG         pSize
    )
/*++

Routine Description

    This routine creates a list of netbios connections and returns them to the
    client.  It is used by the "NbtStat" console application.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    CTELockHandle       OldIrq1;
    CTELockHandle       OldIrq2;
    CTELockHandle       OldIrq3;
    LONG                Count;
    LONG                i;
    LONG                BuffSize;
    PLIST_ENTRY         pEntry;
    PLIST_ENTRY         pEntry1;
    PLIST_ENTRY         pEntry2;
    PLIST_ENTRY         pHead;
    PLIST_ENTRY         pHead1;
    PLIST_ENTRY         pHead2;
    ULONG               NameSize;
    tCONNECTIONS        *pCons;
    tCONNECTION_LIST    *pConnList;
    tADDRESSELE         *pAddressEle;
    tLOWERCONNECTION    *pLowerConn;
    tCONNECTELE         *pConnEle;
    tCLIENTELE          *pClient;
    NTSTATUS            status = STATUS_SUCCESS;    // default

    // locking the joint lock is enough to prevent new addresses from being
    // added to the list while we count the list.
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    // go through the list of addresses, then the list of clients on each
    // address and then the list of connection that are in use and those that
    // are currently Listening.
    //
    Count = 0;
    pHead = &NbtConfig.AddressHead;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);

        CTESpinLock(pAddressEle,OldIrq2);
        pHead1 = &pAddressEle->ClientHead;
        pEntry1 = pHead1->Flink;
        while (pEntry1 != pHead1)
        {
            pClient = CONTAINING_RECORD(pEntry1,tCLIENTELE,Linkage);
            pEntry1 = pEntry1->Flink;

            CTESpinLock(pClient,OldIrq3);
            pHead2 = &pClient->ConnectActive;
            pEntry2 = pHead2->Flink;
            while (pEntry2 != pHead2)
            {
                // count the connections in use
                pEntry2 = pEntry2->Flink;
                Count++;
            }
            pHead2 = &pClient->ListenHead;
            pEntry2 = pHead2->Flink;
            while (pEntry2 != pHead2)
            {
                // count the connections listening
                pEntry2 = pEntry2->Flink;
                Count++;
            }
            CTESpinFree(pClient,OldIrq3);
        }
        CTESpinFree(pAddressEle,OldIrq2);
        pEntry = pEntry->Flink;
    }
    NameSize = sizeof(tCONNECTIONS);

    // Allocate Memory for the adapter status
    BuffSize = sizeof(tCONNECTION_LIST) + Count*NameSize;

    pConnList = NbtAllocMem(BuffSize,NBT_TAG('P'));
    if (!pConnList)
    {
        CTESpinFree(&NbtConfig.JointLock, OldIrq1);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Initialize the adapter status structure
    //
    CTEZeroMemory ((PVOID)pConnList, BuffSize);
    pConnList->ConnectionCount = Count;
    *ppConnList = (PVOID)pConnList;

    if (Count == 0)
    {
        //
        // We are done!
        //
        *pSize = BuffSize;
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return status;
    }

    // get the address of the Connection List buffer at the end of the
    // structure so we can copy the Connection info into this area.
    pCons = pConnList->ConnList;

    pHead = &NbtConfig.AddressHead;
    pEntry = pHead->Flink;
    i = 0;
    while (pEntry != pHead)
    {
        pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);

        pEntry = pEntry->Flink;

        CTESpinLock(pAddressEle,OldIrq2);
        pHead1 = &pAddressEle->ClientHead;
        pEntry1 = pHead1->Flink;
        while (pEntry1 != pHead1)
        {
            pClient = CONTAINING_RECORD(pEntry1,tCLIENTELE,Linkage);
            pEntry1 = pEntry1->Flink;

            CTESpinLock(pClient,OldIrq3);
            pHead2 = &pClient->ConnectActive;
            pEntry2 = pHead2->Flink;
            while (pEntry2 != pHead2)
            {
                // count the connections in use
                pConnEle = CONTAINING_RECORD(pEntry2,tCONNECTELE,Linkage);

                if (pConnEle->pDeviceContext == pDeviceContext)
                {
                    CTEMemCopy(pCons->LocalName,
                              pConnEle->pClientEle->pAddress->pNameAddr->Name,
                              NETBIOS_NAME_SIZE);

                    pLowerConn = pConnEle->pLowerConnId;
                    if (pLowerConn)
                    {
                        pCons->SrcIpAddr = pLowerConn->SrcIpAddr;
                        pCons->Originator = (UCHAR)pLowerConn->bOriginator;
#ifndef VXD
                        pCons->BytesRcvd = *(PLARGE_INTEGER)&pLowerConn->BytesRcvd;
                        pCons->BytesSent = *(PLARGE_INTEGER)&pLowerConn->BytesSent;
#else
                        pCons->BytesRcvd = pLowerConn->BytesRcvd;
                        pCons->BytesSent = pLowerConn->BytesSent;
#endif
                        CTEMemCopy(pCons->RemoteName,pConnEle->RemoteName,NETBIOS_NAME_SIZE);
                    }

                    pCons->State = pConnEle->state;
                    i++;
                    pCons++;

                    if (i >= Count)
                    {
                        break;
                    }
                }

                pEntry2 = pEntry2->Flink;
            }
            if (i >= Count)
            {
                CTESpinFree(pClient,OldIrq3);
                break;
            }

            //
            // now for the Listens
            //
            pHead2 = &pClient->ListenHead;
            pEntry2 = pHead2->Flink;
            while (pEntry2 != pHead2)
            {
                tLISTENREQUESTS  *pListenReq;

                // count the connections listening on this Device
                pListenReq = CONTAINING_RECORD(pEntry2,tLISTENREQUESTS,Linkage);
                pConnEle = (tCONNECTELE *)pListenReq->pConnectEle;
                pEntry2 = pEntry2->Flink;

                if (pConnEle->pDeviceContext == pDeviceContext)
                {
                    CTEMemCopy(pCons->LocalName,
                              pConnEle->pClientEle->pAddress->pNameAddr->Name,
                              NETBIOS_NAME_SIZE);

                    pCons->State = LISTENING;

                    i++;
                    pCons++;

                    if (i >= Count)
                    {
                        break;
                    }
                }
            }
            CTESpinFree(pClient,OldIrq3);
            if (i >= Count)
            {
                break;
            }
        }

        CTESpinFree(pAddressEle,OldIrq2);
        if (i >= Count)
        {
            break;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    //
    // return the ptr to this wonderful structure of goodies
    //
    Count = i;
    BuffSize = sizeof(tCONNECTION_LIST) + Count*NameSize;

    //
    //  Is our status buffer size greater then the user's buffer?
    //  Set the Count value based on the number of connections
    //  actually being returned
    //
    if (BuffSize > *pSize)
    {
        //
        //  Recalc how many names will fit
        //  tCONNECTION_LIST already contains space for 1 tCONNECTION
        //  structure, but we will not include it in our calculations
        //  -- rather we will leave it as an overflow check
        //
        if (*pSize <= sizeof(tCONNECTION_LIST))
        {
            Count = 0 ;
        }
        else
        {
            Count = (*pSize - sizeof(tCONNECTION_LIST)) / NameSize ;
        }
    }

    pConnList->ConnectionCount = Count;
    *pSize = BuffSize;

    return status;
}
//----------------------------------------------------------------------------
VOID
DelayedNbtResyncRemoteCache(
    IN  PVOID                   Unused1,
    IN  PVOID                   Unused2,
    IN  PVOID                   Unused3,
    IN  tDEVICECONTEXT          *Unused4
    )
/*++

Routine Description

    This routine creates a list of netbios connections and returns them to the
    client.  It is used by the "NbtStat" console application.
    It cannot be called with any lock or NbtConfig.Resource held!

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    tTIMERQENTRY        TimerEntry = {0};
    LONG                i;
    LONG                lRetcode;
    PUCHAR              LmHostsPath;

    CTEPagedCode();
    //
    // calling this routine N+1 times should remove all names from the remote
    // hash table - N to count down the TimedOutCount to zero and then
    // one more to remove the name
    //
    RemoteHashTimeout(NbtConfig.pRemoteHashTbl,NULL,&TimerEntry);
    RemovePreloads();           // now remove any preloaded entries

    // now reload the preloads
#ifndef VXD
    //
    // The NbtConfig.pLmHosts path can change if the registry is
    // read during this interval
    // We cannot acquire the ResourceLock here since reading the
    // LmHosts file might result in File operations + network reads
    // that could cause a deadlock (Worker threads / ResourceLock)!
    // Best solution at this time is to copy the path onto a local
    // buffer under the Resource lock, and then try to read the file!
    // Bug # 247429
    //
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    if ((!NbtConfig.pLmHosts) ||
        (!(LmHostsPath = NbtAllocMem ((strlen(NbtConfig.pLmHosts)+1), NBT_TAG2('23')))))
    {
        CTEExReleaseResource(&NbtConfig.Resource);
        return;
    }

    CTEMemCopy (LmHostsPath, NbtConfig.pLmHosts, (strlen(NbtConfig.pLmHosts)+1));
    CTEExReleaseResource(&NbtConfig.Resource);

    lRetcode = PrimeCache(LmHostsPath, NULL, MAX_RECURSE_DEPTH, NULL);

    CTEMemFree(LmHostsPath);

    return;
#else
    lRetcode = PrimeCache(NbtConfig.pLmHosts, NULL, MAX_RECURSE_DEPTH, NULL);
    //
    // check if things didn't go well (InDos was set etc.)
    //
    if (lRetcode == -1)
    {
        return (STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
#endif  // !VXD
}
//----------------------------------------------------------------------------
NTSTATUS
NbtQueryBcastVsWins(
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT PVOID           *ppBuffer,
    IN OUT PLONG         pSize
    )
/*++

Routine Description

    This routine creates a list of netbios names that have been resolved
    via broadcast and returns them along with the count of names resolved
    via WINS and via broadcast.  It lets a user know which names are not
    in WINS and the relative frequency of "misses" with WINS that resort
    to broadcast.

Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    tNAMESTATS_INFO     *pStats;
    LONG                Count;
    tNAME               *pDest;
    tNAME               *pSrc;
    LONG                Index;

    //
    //  Is our status buffer size greater then the user's buffer?
    //
    if ( sizeof(tNAMESTATS_INFO) > *pSize )
    {
        return (STATUS_BUFFER_TOO_SMALL);
    }

    pStats = NbtAllocMem(sizeof(tNAMESTATS_INFO),NBT_TAG('Q'));
    if ( !pStats )
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    // Fill out the adapter status structure with zeros first
    CTEZeroMemory((PVOID)pStats,sizeof(tNAMESTATS_INFO));
    CTEMemCopy(pStats,&NameStatsInfo,FIELD_OFFSET(tNAMESTATS_INFO,NamesReslvdByBcast) );

    //
    // re-order the names so that names are returned in a list of newest to
    // oldest down the list.
    //
    Count = 0;
    Index = NameStatsInfo.Index;
    pDest = &pStats->NamesReslvdByBcast[SIZE_RESOLVD_BY_BCAST_CACHE-1];

    while (Count < SIZE_RESOLVD_BY_BCAST_CACHE)
    {
        pSrc = &NameStatsInfo.NamesReslvdByBcast[Index++];

        CTEMemCopy(pDest,pSrc,NETBIOS_NAME_SIZE);

        pDest--;
        if (Index >= SIZE_RESOLVD_BY_BCAST_CACHE)
        {
            Index = 0;
            pSrc = NameStatsInfo.NamesReslvdByBcast;
        }
        else
        {
            pSrc++;
        }

        Count++;
    }

    //
    // return the ptr to this wonderful structure of goodies
    //
    *ppBuffer = (PVOID)pStats;
    *pSize = sizeof(tNAMESTATS_INFO);

    return STATUS_SUCCESS;
}


ULONG
RemoveCachedAddresses(
    tDEVICECONTEXT  *pDeviceContext
    )
{
    LONG                    i;
    CTELockHandle           OldIrq;
    tNAMEADDR               *pNameAddr;
    tHASHTABLE              *pHashTable;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    ULONG   Count = 0;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // go through the Remote table removing addresses resolved on this interface
    //
    pHashTable = NbtConfig.pRemoteHashTbl;
    for (i=0; i < pHashTable->lNumBuckets; i++)
    {
        pHead = &pHashTable->Bucket[i];
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;
            //
            // do not delete scope entries, and do not delete names that
            // that are still resolving, and do not delete names that are
            // being used by someone (refcount > 1)
            //
            if (pNameAddr->RemoteCacheLen > pDeviceContext->AdapterNumber)
            {
                pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].IpAddress = 0;
                if (pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].pOrigIpAddrs)
                {
                    CTEMemFree(pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].pOrigIpAddrs);
                    pNameAddr->pRemoteIpAddrs[pDeviceContext->AdapterNumber].pOrigIpAddrs = NULL;
                }
                pNameAddr->AdapterMask &= ~pDeviceContext->AdapterMask;

#if DBG
/*
// MALAM_FIX -- Preloaded entries have 2 References!
                if ((!pNameAddr->AdapterMask) &&
                    (!(pNameAddr->NameTypeState & NAMETYPE_SCOPE)))
                {
                    RemoveEntryList (&pNameAddr->Linkage);
                    InsertTailList(&NbtConfig.StaleRemoteNames, &pNameAddr->Linkage);
                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                }
*/
#endif  // DBG
                Count++;
            }
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return (Count);
}

VOID
NbtAddressChangeResyncCacheTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
{
    if (!pTimerQEntry)
    {
        return;
    }

    NTQueueToWorkerThread(NULL, DelayedNbtResyncRemoteCache, NULL, NULL, NULL, NULL, FALSE);

    return;
}


#ifndef VXD
//----------------------------------------------------------------------------
VOID
NbtCheckSetNameAdapterInfo(
    tDEVICECONTEXT  *pDeviceContext,
    ULONG           IpAddress
    )
{
    LONG                i;
    CTELockHandle       OldIrq;
    tTIMERQENTRY        *pTimerEntry;
    tNAMEADDR           *pNameAddr;
    tHASHTABLE          *pHashTable;
    PLIST_ENTRY         pHead, pEntry;
    BOOLEAN             fStartRefresh = FALSE;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pWinsInfo)
    {
        if (IpAddress)
        {
            //
            // If there is no IP address, or the new IP address is the one Wins had preferred,
            // use it
            //
            if (((IpAddress == pWinsInfo->IpAddress) || (!pWinsInfo->pDeviceContext)) &&
                (NBT_VERIFY_HANDLE (pDeviceContext, NBT_VERIFY_DEVCONTEXT)))
            {
                pWinsInfo->pDeviceContext = pDeviceContext;
            }
        }
        else
        {
            if (pDeviceContext == pWinsInfo->pDeviceContext)
            {
                pWinsInfo->pDeviceContext = GetDeviceWithIPAddress(pWinsInfo->IpAddress);
            }
        }
    }

    //
    // For a Netbiosless device notification, we are done!
    //
    if (pDeviceContext->DeviceType == NBT_DEVICE_NETBIOSLESS)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    if (IpAddress == 0)
    {
        //
        // See if there were any names in conflict which we need to refresh!
        //
        pHashTable = NbtConfig.pLocalHashTbl;
        for (i=0; i < pHashTable->lNumBuckets; i++)
        {
            pHead = &pHashTable->Bucket[i];
            pEntry = pHead->Flink;
            while (pEntry != pHead)
            {
                pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
                pEntry = pEntry->Flink;

                if (pNameAddr->ConflictMask & pDeviceContext->AdapterMask)
                {
                    //
                    // Zero out the Conflicting adapter mask
                    // Restart Refreshing this name if there are no more
                    // adapters on which the name went into conflict
                    //
                    pNameAddr->ConflictMask &= (~pDeviceContext->AdapterMask);
                    if (!(pNameAddr->ConflictMask))
                    {
                        pNameAddr->RefreshMask = 0;
                        fStartRefresh = TRUE;
                    }
                }
            }
        }
    }
    else
    {
        if (NodeType & BNODE)
        {
            //
            // Stop the RefreshTimer if it is running!
            //
            if (pTimerEntry = NbtConfig.pRefreshTimer)
            {
                NbtConfig.pRefreshTimer = NULL;
                StopTimer (pTimerEntry, NULL, NULL);
            }
        }
        else
        {
            fStartRefresh = TRUE;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (fStartRefresh)
    {
        //
        // ReRegister all the local names on this device with the WINS server
        //
        ReRegisterLocalNames(pDeviceContext, FALSE);
    }

}
#endif  // !VXD

#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
//----------------------------------------------------------------------------
VOID
DelayedNbtProcessDhcpRequests(
    PVOID   Unused1,
    PVOID   Unused2,
    PVOID   Unused3,
    PVOID   pDevice)
/*++
Routine Description:

    Process each DHCP requests queued by NbtNewDhcpAddress

Arguments:

Return Value:
    NONE
--*/
{
    tDEVICECONTEXT          *pDeviceContext;
    CTELockHandle           OldIrq;
    enum eTDI_ACTION        action;

    pDeviceContext = (tDEVICECONTEXT*)pDevice;

    CTESpinLock(pDeviceContext, OldIrq);
    action = pDeviceContext->DelayedNotification;
    ASSERT(action == NBT_TDI_REGISTER || action == NBT_TDI_NOACTION);
    if (action != NBT_TDI_NOACTION) {
        pDeviceContext->DelayedNotification = NBT_TDI_BUSY;
    }
    CTESpinFree(pDeviceContext, OldIrq);

    if (action != NBT_TDI_NOACTION) {
        NbtNotifyTdiClients (pDeviceContext, action);
        CTESpinLock(pDeviceContext, OldIrq);
        pDeviceContext->DelayedNotification = NBT_TDI_NOACTION;
        CTESpinFree(pDeviceContext, OldIrq);
        KeSetEvent(&pDeviceContext->DelayedNotificationCompleteEvent, 0, FALSE);
    }

    //
    // Call this routine at PASSIVE_LEVEL
    //
    NbtDownBootCounter();
}

VOID
StartProcessNbtDhcpRequests(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
{
    /*
     * if pTimerQEntry == NULL, we are being called from StopTimer which is called by NbtDestroyDevice
     * DelayedNbtDeleteDevice will take care of notifying the clients and proper cleanup.
     */
    if (pTimerQEntry) {
        tDEVICECONTEXT          *pDeviceContext;

        pDeviceContext = (tDEVICECONTEXT*)(pTimerQEntry->pDeviceContext);
        if (!NT_SUCCESS(NTQueueToWorkerThread(NULL, DelayedNbtProcessDhcpRequests,
                    NULL, NULL, NULL, (tDEVICECONTEXT*)pTimerQEntry->pDeviceContext, FALSE))) {
            pDeviceContext->DelayedNotification = NBT_TDI_NOACTION;
            KeSetEvent(&pDeviceContext->DelayedNotificationCompleteEvent, 0, FALSE);

            NbtDownBootCounter();
        }

    } else {

        NbtDownBootCounter();

    }
}

//----------------------------------------------------------------------------
NTSTATUS
NbtQueueTdiNotification (
    tDEVICECONTEXT  *pDeviceContext,
    enum eTDI_ACTION action
    )
/*++
Routine Description:

    1. Queue the DHCP address notifications into NbtConfig.DhcpNewAddressQList.
    2. Start the worker thread if needed.

Arguments:

Return Value:
    NTSTATUS
--*/

{
    NTSTATUS        status;
    CTELockHandle   OldIrq1, OldIrq2;

    if (NbtConfig.DhcpProcessingDelay == 0) {
        NbtNotifyTdiClients (pDeviceContext, action);
        return STATUS_SUCCESS;
    }

    if (action == NBT_TDI_DEREGISTER) {
        /*
         * This should be done synchronously
         */
        CTESpinLock(&NbtConfig.JointLock, OldIrq1);
        CTESpinLock(pDeviceContext, OldIrq2);
        if (pDeviceContext->DelayedNotification != NBT_TDI_BUSY) {
            pDeviceContext->DelayedNotification = NBT_TDI_NOACTION;
            KeSetEvent(&pDeviceContext->DelayedNotificationCompleteEvent, 0, FALSE);
        } else {
            ASSERT(!KeReadStateEvent(&pDeviceContext->DelayedNotificationCompleteEvent));
        }
        CTESpinFree(pDeviceContext, OldIrq2);
        CTESpinFree(&NbtConfig.JointLock, OldIrq1);
        status = KeWaitForSingleObject(
                        &pDeviceContext->DelayedNotificationCompleteEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL
                        );
        ASSERT(status == STATUS_WAIT_0);
        NbtNotifyTdiClients (pDeviceContext, NBT_TDI_DEREGISTER);
        return STATUS_SUCCESS;
    }

    /*
     * Queue NBT_TDI_REGISTER
     */
    ASSERT(action == NBT_TDI_REGISTER);

    CTESpinLock(&NbtConfig.JointLock, OldIrq1);
    CTESpinLock(pDeviceContext, OldIrq2);
    if (pDeviceContext->DelayedNotification != NBT_TDI_NOACTION) {
        /*
         * Do nothing because another indication is going on
         */
        ASSERT(pDeviceContext->DelayedNotification == NBT_TDI_REGISTER ||
                pDeviceContext->DelayedNotification == NBT_TDI_BUSY);
        CTESpinFree(pDeviceContext, OldIrq2);
        CTESpinFree(&NbtConfig.JointLock, OldIrq1);
        return STATUS_SUCCESS;
    }

    status = StartTimer (StartProcessNbtDhcpRequests, NbtConfig.DhcpProcessingDelay,
                    NULL, NULL, NULL, NULL, pDeviceContext, NULL, 0, TRUE);
    if (NT_SUCCESS(status)) {
        KeResetEvent(&pDeviceContext->DelayedNotificationCompleteEvent);
        pDeviceContext->DelayedNotification = action;
        NbtUpBootCounter();
    }
    CTESpinFree(pDeviceContext, OldIrq2);
    CTESpinFree(&NbtConfig.JointLock, OldIrq1);

    if (!NT_SUCCESS(status)) {
        NbtNotifyTdiClients (pDeviceContext, action);
    }

    return STATUS_SUCCESS;
}
#endif       // REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG

//----------------------------------------------------------------------------
NTSTATUS
NbtNewDhcpAddress(
    tDEVICECONTEXT  *pDeviceContext,
    ULONG           IpAddress,
    ULONG           SubnetMask)

/*++

Routine Description:

    This routine processes a DHCP request to set a new ip address
    for this node.  Dhcp may pass in a zero for the ip address first
    meaning that it is about to change the IP address, so all connections
    should be shut down.
    It closes all connections with the transport and all addresses.  Then
    It reopens them at the new ip address.

Note for NETBIOSLESS:
    I have modeled a disabled adapter after an adapter with no address.  I considered
    not creating the device, but then, without the device, there is no handle
    for setup to contact the driver in order to enable it again.

Arguments:

Return Value:

    none

--*/

{
    NTSTATUS            status;
    BOOLEAN             Attached;
    ULONG               Count, i;

    CTEPagedCode();

    CHECK_PTR(pDeviceContext);
#ifdef _NETBIOSLESS
    if ( (!pDeviceContext->NetbiosEnabled) && (IpAddress != 0) )
    {
        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint(("NbtNewDhcpAddr: %wZ disabling address\n",&pDeviceContext->ExportName));
        IpAddress = 0;
        SubnetMask = 0;
    }
#endif

    // grab the resource that synchronizes opening addresses and connections.
    // to prevent the client from doing anything for a while
    //
    IF_DBG(NBT_DEBUG_PNP_POWER)
    {
        KdPrint(("Nbt.NbtNewDhcpAddress: %d.%d.%d.%d\n",
                                        (IpAddress)     & 0xFF,
                                        (IpAddress>>8)  & 0xFF,
                                        (IpAddress>>16) & 0xFF,
                                        (IpAddress>>24) & 0xFF));
    }

    if (IpAddress == 0)
    {
        if (pDeviceContext->IpAddress)
        {
            NbtTrace(NBT_TRACE_PNP, ("remove %!ipaddr! from device %p %Z",
                                    pDeviceContext->IpAddress, pDeviceContext, &pDeviceContext->BindName));
#ifdef VXD
            //
            // The permanent name is a function of the MAC address so remove
            // it since the Adapter is losing its Ip address
            //
            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
            NbtRemovePermanentName(pDeviceContext);
#else
            CloseAddressesWithTransport(pDeviceContext);
            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
#endif  // VXD

            //
            // Dhcp is has passed down a null IP address meaning that it has
            // lost the lease on the previous address, so close all connections
            // to the transport - pLowerConn.
            //
            DisableInboundConnections (pDeviceContext);

#ifndef VXD
            CTEExReleaseResource(&NbtConfig.Resource);
            NbtCheckSetNameAdapterInfo (pDeviceContext, IpAddress);

            if (pDeviceContext->DeviceType == NBT_DEVICE_REGULAR)
            {

                NbtUpBootCounter();

#ifdef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
                NbtNotifyTdiClients (pDeviceContext, NBT_TDI_DEREGISTER);
#else
                NbtQueueTdiNotification (pDeviceContext, NBT_TDI_DEREGISTER);
#endif       // REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG

                NbtDownBootCounter();

            }
#endif
            //
            // Resync the cache since we may need to reset the outgoing interface info
            //
            StartTimer (NbtAddressChangeResyncCacheTimeout, ADDRESS_CHANGE_RESYNC_CACHE_TIMEOUT,
                        NULL, NULL, NULL, NULL, NULL, NULL, 0, FALSE);
        }

        status = STATUS_SUCCESS;
    }
    else
    {
        ASSERT((signed)(pDeviceContext->TotalLowerConnections) >= 0);

        NbtTrace(NBT_TRACE_PNP, ("new %!ipaddr! for device %p %Z",
                                    IpAddress, pDeviceContext, &pDeviceContext->BindName));
        CloseAddressesWithTransport(pDeviceContext);
        CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
        DisableInboundConnections (pDeviceContext);

        // these are passed into here in the reverse byte order
        //
        IpAddress = htonl(IpAddress);
        SubnetMask = htonl(SubnetMask);
        //
        // must be a new IP address, so open up the connections.
        //
        // get the ip address and open the required address
        // objects with the underlying transport provider

        CTEAttachFsp(&Attached, REF_FSP_NEWADDR);
        Count = CountUpperConnections(pDeviceContext);
        Count += NbtConfig.MinFreeLowerConnections;

        for (i=0; i<2; i++)     // Retry once!
        {
            status = NbtCreateAddressObjects (IpAddress, SubnetMask, pDeviceContext);
            if (NT_SUCCESS(status))
            {
                // Allocate and set up connections with the transport provider.
                while ((NT_SUCCESS(status)) && (Count--))
                {
                    status = NbtOpenAndAssocConnection(pDeviceContext, NULL, NULL, '4');
                }

                if (!NT_SUCCESS(status))
                {
                    NbtLogEvent (EVENT_NBT_CREATE_CONNECTION, status, Count);
                    KdPrint(("Nbt.NbtNewDhcpAddress: NbtOpenAndAssocConnection Failed <%x>\n",status));
                }

                break;
            }

            //
            // Log an event only if it is a retry
            //
            if (i > 0)
            {
                NbtLogEvent (EVENT_NBT_CREATE_ADDRESS, status, i);
            }
            KdPrint(("Nbt.NbtNewDhcpAddress[i]: NbtCreateAddressObjects Failed, status=<%x>\n",i,status));
            KdPrint(("Nbt.NbtNewDhcpAddress: IpAddress: %x, SubnetMask: %x, pDeviceContext: %x\n",
                IpAddress, SubnetMask, pDeviceContext));
        }

        CTEDetachFsp(Attached, REF_FSP_NEWADDR);

        CTEExReleaseResource(&NbtConfig.Resource);

#ifdef VXD
        //
        // Add the "permanent" name to the local name table.  This is the IP
        // address of the node padded out to 16 bytes with zeros.
        //
        NbtAddPermanentName(pDeviceContext);
#else
        NbtCheckSetNameAdapterInfo (pDeviceContext, IpAddress);
        if (pDeviceContext->DeviceType == NBT_DEVICE_REGULAR)
        {
            //
            // Register this Device for our clients
            //
            NbtUpBootCounter();

#ifdef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
            NbtNotifyTdiClients (pDeviceContext, NBT_TDI_REGISTER);
#else
            NbtQueueTdiNotification (pDeviceContext, NBT_TDI_REGISTER);
#endif       // REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG

            NbtDownBootCounter();
        }

        //
        // Resync the cache since we may need to reset the outgoing interface info
        //
        StartTimer (NbtAddressChangeResyncCacheTimeout, ADDRESS_CHANGE_RESYNC_CACHE_TIMEOUT,
                    NULL, NULL, NULL, NULL, NULL, NULL, 0, FALSE);
#endif  // VXD
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtDeleteLowerConn(
    IN tLOWERCONNECTION   *pLowerConn
    )
/*++
Routine Description:

    This Routine attempts to delete a lower connection by closing it with the
    transport and dereferencing it.

Arguments:

Return Value:

     NONE

--*/

{
    NTSTATUS        status;
    CTELockHandle   OldIrq;
    tDEVICECONTEXT  *pDeviceContext;

    status = STATUS_SUCCESS;

    if ((pLowerConn->Verify != NBT_VERIFY_LOWERCONN) ||
        (pLowerConn->RefCount > 500))
    {
        ASSERT (0);
        return status;
    }

    // remove the lower connection from the active queue and then delete it
    //
    pDeviceContext = pLowerConn->pDeviceContext;
    CTESpinLock(pDeviceContext,OldIrq);

    //
    // The lower conn can get removed from the inactive list in OutOfRsrcKill (when we queue it on
    // the OutofRsrc.ConnectionHead). Check the flag that indicates this connection was dequed then.
    //
    if (!pLowerConn->OutOfRsrcFlag)
    {
        RemoveEntryList(&pLowerConn->Linkage);
        pLowerConn->Linkage.Flink = pLowerConn->Linkage.Blink = (PLIST_ENTRY)0x00009789;

        //
        // Setting this TRUE to prevent from running the OutOfRsrcKill again.
        //

        pLowerConn->bNoOutRsrcKill = TRUE;
    }

    CTESpinFree(pDeviceContext,OldIrq);

    NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, FALSE);

    return(status);

}

//----------------------------------------------------------------------------
VOID
DelayedWipeOutLowerconn(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused2,
    IN  tDEVICECONTEXT          *Unused3
    )
/*++
Routine Description:

    This routine does all the file close etc. that we couldn't do at dpc level
    and then frees the memory.

Arguments:

    pLowerConn - the lower connection to be wiped out

Return Value:

     NONE

--*/

{
    tLOWERCONNECTION    *pLowerConn = (tLOWERCONNECTION*) pClientContext;

    ASSERT(pLowerConn->Verify == NBT_VERIFY_LOWERCONN); // Verify LowerConn structure

    // dereference the fileobject ptr
    NTDereferenceObject((PVOID *)pLowerConn->pFileObject);

    // close the lower connection with the transport
    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.DelayedWipeOutLowerconn: Closing Handle %X -> %X\n",pLowerConn,pLowerConn->FileHandle));

    NbtTdiCloseConnection(pLowerConn);

    // Close the Address object too since outbound connections use unique
    // addresses for each connection, whereas inbound connections all use
    // the same address  ( and we don't want to close that address ever ).
    if (pLowerConn->pAddrFileObject)
    {
        // dereference the fileobject ptr
        NTDereferenceObject((PVOID *)pLowerConn->pAddrFileObject);
        NbtTdiCloseAddress(pLowerConn);
    }

#ifndef VXD
    // free the indicate buffer and the mdl that holds it
    //
    CTEMemFree(MmGetMdlVirtualAddress(pLowerConn->pIndicateMdl));
    IoFreeMdl(pLowerConn->pIndicateMdl);
#endif

    pLowerConn->Verify += 10;
    // now free the memory block tracking this connection
    CTEMemFree((PVOID)pLowerConn);
}

//----------------------------------------------------------------------------
VOID
NbtDereferenceClient(
    IN  tCLIENTELE    *pClientEle
    )
/*++

Routine Description

    This routine deletes a client element record (which points to a name
    in the local hash table.  If this is the last client element hooked to that
    name then the name is deleted too - causing a name release to be sent out.


Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    tADDRESSELE         *pAddress;
    PIRP                pIrp;
    NTSTATUS            status;
    tNAMEADDR           *pNameAddr;
    tTIMERQENTRY        *pTimer;
    tDGRAM_SEND_TRACKING *pTracker;
    COMPLETIONCLIENT    pClientCompletion = NULL;
    PVOID               Context;
    LIST_ENTRY          *pClientEntry;
    tDEVICECONTEXT      *pDeviceContext;
    tCLIENTELE          *pClientEleTemp;
    BOOLEAN             fLastClientOnDevice = TRUE;

    // lock the JointLock
    // so we can delete the client knowing that no one has a spin lock
    // pending on the client - basically use the Joint spin lock to
    // coordinate access to the AddressHead - NbtConnectionList also locks
    // the JointLock to scan the AddressHead list
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    ASSERT(pClientEle->RefCount);
    ASSERT ((pClientEle->Verify==NBT_VERIFY_CLIENT) || (pClientEle->Verify==NBT_VERIFY_CLIENT_DOWN)); 

    if (--pClientEle->RefCount)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        // return pending because we haven't been able to close the client
        // completely yet
        //
        return;
    }

    //
    // Unlink the Client in this routine after the reference count has
    // gone to zero since the DgramRcv code may need to find the client in
    // the Address client list when it is distributing a single received
    // dgram to several clients.
    //
    pIrp            = pClientEle->pIrp;
    pDeviceContext  = pClientEle->pDeviceContext;
    pAddress        = pClientEle->pAddress;
    pNameAddr       = pAddress->pNameAddr;

    CTESpinLock(pAddress,OldIrq1); // Need to acquire AddressEle lock -- Bug#: 231853
    RemoveEntryList(&pClientEle->Linkage);

    //
    // If there is no other client registered on this device, then
    // clear the adapter mask, and mark the release mask
    //
    pClientEntry = &pAddress->ClientHead;
    while ((pClientEntry = pClientEntry->Flink) != &pAddress->ClientHead)
    {
        pClientEleTemp = CONTAINING_RECORD (pClientEntry,tCLIENTELE,Linkage);
        if (pClientEleTemp->pDeviceContext == pDeviceContext)
        {
            fLastClientOnDevice = FALSE;
            break;
        }
    }
    CTESpinFree(pAddress,OldIrq1);

    if (pNameAddr)
    {
        //
        // If there is any timer running on this Client's device,
        // stop it now!
        //
        if ((pTimer = pNameAddr->pTimer) &&
            (pTracker = pTimer->Context) &&
            (pTracker->pDeviceContext == pDeviceContext))
        {
            pNameAddr->pTimer = NULL;
            StopTimer(pTimer,&pClientCompletion,&Context);
        }

        if (fLastClientOnDevice)
        {
            if (IsDeviceNetbiosless(pDeviceContext))
            {
                pNameAddr->NameFlags &= ~NAME_REGISTERED_ON_SMBDEV;
            }
            else
            {
                pNameAddr->AdapterMask &= ~pDeviceContext->AdapterMask;
                pNameAddr->ConflictMask &= ~pDeviceContext->AdapterMask;    // in case there was a conflict
                pNameAddr->ReleaseMask |= pDeviceContext->AdapterMask;
            }
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

#ifdef _PNP_POWER_
        //
        // Remove this name from the Adapter's Wakeup Pattern list (if set)
        //
        if ((pNameAddr->Name[0] != '*') &&
            (pNameAddr->Name[NETBIOS_NAME_SIZE-1] == SPECIAL_SERVER_SUFFIX))
        {
            pDeviceContext->NumServers--;
            CheckSetWakeupPattern (pDeviceContext, pNameAddr->Name, FALSE);
        }
#endif  // _PNP_POWER_
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    if (pClientCompletion)
    {
        (*pClientCompletion)(Context, STATUS_TIMEOUT);
    }
    //
    // The Connection Q Should be Empty otherwise we shouldn't get to this routine
    //
    ASSERT(IsListEmpty(&pClientEle->ConnectActive));
    ASSERT(IsListEmpty(&pClientEle->ConnectHead));
    ASSERT(IsListEmpty(&pClientEle->ListenHead));
    ASSERT(IsListEmpty(&pClientEle->SndDgrams));    // the Datagram Q should also be empty

    // check if there are more clients attached to the address, or can we
    // delete the address too.
    //
    NBT_DEREFERENCE_ADDRESS (pAddress, REF_ADDR_NEW_CLIENT);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDereferenceClient: Delete Client Object %X\n",pClientEle));
    //
    // if their is a client irp, complete now.  When the permanent name is
    // released there is no client irp.
    //
    // CHANGED:
    // Do not hold up the client's irp until the name has released on the
    // net.  It is simpler to just complete it now
    //
    if (pIrp)
    {
        // complete the client's close address irp
        CTEIoComplete(pIrp,STATUS_SUCCESS,0);
    }

    //
    // free the memory associated with the client element
    //
    pClientEle->Verify += 10;
    CTEMemFree((PVOID)pClientEle);

    return;
}

//----------------------------------------------------------------------------
NTSTATUS
NbtDereferenceAddress(
    IN  tADDRESSELE *pAddress,
    IN  ULONG       Context
    )
/*++

Routine Description

    This routine deletes an Address element record (which points to a name
    in the local hash table).  A name release is sent on the wire for this name.


Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    COMPLETIONCLIENT        pClientCompletion = NULL;
    PVOID                   pTimerContext;
    ULONG                   SaveState;
    tDEVICECONTEXT          *pDeviceContext;
    tTIMERQENTRY            *pTimer;

    // lock the hash table so another client cannot add a reference to this
    // name before we delete it.  We need the JointLock to keep the name
    // refresh mechanism from finding the name in the list just as
    // we are about to remove it (i.e. to synchronize with the name refresh
    // code).
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    CTESpinLock(pAddress,OldIrq);

    ASSERT(pAddress->RefCount);
    ASSERT (NBT_VERIFY_HANDLE (pAddress, NBT_VERIFY_ADDRESS));
    if (pAddress->pNameAddr)
    {
        ASSERT (NBT_VERIFY_HANDLE (pAddress->pNameAddr, LOCAL_NAME));
    }

    if (--pAddress->RefCount)
    {
        CTESpinFree(pAddress,OldIrq);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return(STATUS_SUCCESS);
    }

    //
    // remove the address object from the list of addresses tied to the
    // device context for the adapter
    //
    RemoveEntryList(&pAddress->Linkage);
    ASSERT(IsListEmpty(&pAddress->ClientHead));     // The ClientHead should be empty

    CTESpinFree(pAddress,OldIrq);

    if (pAddress->pNameAddr)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtDereferenceAddress: Freeing address object for <%-16.16s:%x>\n",
                pAddress->pNameAddr->Name,pAddress->pNameAddr->Name[NETBIOS_NAME_SIZE-1] ));

        pAddress->pNameAddr->pAddressEle = NULL;

        //
        // Release name on the network
        // change the name state in the hash table since it is being released
        //
        SaveState = pAddress->pNameAddr->NameTypeState;
        pAddress->pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
        pAddress->pNameAddr->NameTypeState |= STATE_CONFLICT;
        pAddress->pNameAddr->ReleaseMask |= pAddress->pNameAddr->AdapterMask;
        pAddress->pNameAddr->AdapterMask = 0;

        //
        // check for any timers outstanding against the hash table entry - there shouldn't
        // be any timers though
        //
        if (pTimer = pAddress->pNameAddr->pTimer)
        {
            pAddress->pNameAddr->pTimer = NULL;
            status = StopTimer(pTimer, &pClientCompletion, &pTimerContext);

            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtDereferenceAddress: StopTimer returned Context <%x>\n", pTimerContext));

            if (pClientCompletion)
            {
                ASSERT (pClientCompletion != NameReleaseDone);

                CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                (*pClientCompletion) (pTimerContext, STATUS_TIMEOUT);
                CTESpinLock(&NbtConfig.JointLock,OldIrq1);
            }
        }

        // only release the name on the net if it was not in conflict first
        // This prevents name releases going out for names that were not actually
        // claimed. Also, quick add names are not released on the net either.
        //
        if (!(SaveState & (STATE_CONFLICT | NAMETYPE_QUICK)) &&
            (pAddress->pNameAddr->Name[0] != '*') &&
            (pDeviceContext = GetAndRefNextDeviceFromNameAddr (pAddress->pNameAddr)))
        {
            //
            // The pNameAddr has to stay around until the NameRelease has completed
            //
            NBT_REFERENCE_NAMEADDR (pAddress->pNameAddr, REF_NAME_RELEASE);

            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            status = ReleaseNameOnNet (pAddress->pNameAddr,
                                       NbtConfig.pScope,
                                       NameReleaseDone,
                                       NodeType,
                                       pDeviceContext);

            CTESpinLock(&NbtConfig.JointLock,OldIrq1);

#ifndef VXD
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_GET_REF, TRUE);
#endif  // !VXD

            if (!NT_SUCCESS(status))
            {
                NBT_DEREFERENCE_NAMEADDR (pAddress->pNameAddr, REF_NAME_RELEASE, TRUE);
            }
        }

        NBT_DEREFERENCE_NAMEADDR (pAddress->pNameAddr, REF_NAME_LOCAL, TRUE);
    }

    //
    // Now, cleanup the Address info (we are still holding the JointLock)
    //

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    // free the memory associated with the address element
    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("NBt: Deleteing Address Obj after name release on net %X\n",pAddress));
    NbtFreeAddressObj(pAddress);

    //
    // the name has been deleted, so return success
    //
    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
NbtDereferenceName(
    IN  tNAMEADDR   *pNameAddr,
    IN  ULONG       RefContext,
    IN  BOOLEAN     fLocked
    )
/*++

Routine Description

    This routine dereferences and possibly deletes a name element record by first unlinking from the
    list it is in, and then freeing the memory if it is a local name.  Remote
    names remain in a circular list for reuse.
    The JOINTLOCK may have been taken before calling this routine.


Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/

{
    CTELockHandle   OldIrq;
    ULONG           i;

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    ASSERT (NBT_VERIFY_HANDLE2 (pNameAddr, LOCAL_NAME, REMOTE_NAME));
    ASSERT (pNameAddr->RefCount);
    ASSERT (pNameAddr->References[RefContext]--);

    if (--pNameAddr->RefCount)
    {
        if (!fLocked)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
        }

        return;
    }

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDereferenceName[%s]: Freeing Name=<%16.16s:%x> %x\n",
            (pNameAddr->Verify == REMOTE_NAME ? "Remote" : "Local"),
            pNameAddr->Name, pNameAddr->Name[15], pNameAddr));

    //
    // remove from the hash table, could be set to NULL by DestroyHashTable
    //
    if (pNameAddr->Linkage.Flink && pNameAddr->Linkage.Blink) {
        RemoveEntryList(&pNameAddr->Linkage);
    } else {
        // Both should be NULL
        ASSERT(pNameAddr->Linkage.Flink == pNameAddr->Linkage.Blink);
    }

    if (pNameAddr->Verify == LOCAL_NAME)
    {
        ASSERT(!pNameAddr->pTimer);
        ASSERT(NULL == pNameAddr->FQDN.Buffer);
        ASSERT(0 == pNameAddr->FQDN.Length);
    }
    //
    // if it is an internet group name it has a list of ip addresses and that
    // memory block must be deleted
    //
    else if (pNameAddr->Verify == REMOTE_NAME)
    {
        NbtConfig.NumNameCached--;

        //
        // TBD: keep an exact number of the entries in the hash table.
        //
        // It can be negative since the pNameAddr may not be in hash table
        // (It could be in the to-be-resolved list)
        // for now, it is ok since exact number isn't critical.
        //
        if (NbtConfig.NumNameCached < 0) {
            NbtConfig.NumNameCached = 0;
        }
        if (pNameAddr->NameAddFlags == (NAME_RESOLVED_BY_LMH_P | NAME_ADD_INET_GROUP))
        {
            if (pNameAddr->pLmhSvcGroupList)
            {
                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtDereferenceName: Freeing Pre-loaded Internet Group Name Memory = <%p>\n",
                        pNameAddr->pLmhSvcGroupList));
                CTEMemFree((PVOID)pNameAddr->pLmhSvcGroupList);
            }
        }
        if (pNameAddr->pRemoteIpAddrs)
        {
            for (i=0; i<pNameAddr->RemoteCacheLen; i++)
            {
                if (pNameAddr->pRemoteIpAddrs[i].pOrigIpAddrs)
                {
                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint(("Nbt.NbtDereferenceName: Freeing Internet Group Name Memory = <%p>\n",
                            pNameAddr->pRemoteIpAddrs[i].pOrigIpAddrs));
                    CTEMemFree((PVOID)pNameAddr->pRemoteIpAddrs[i].pOrigIpAddrs);
                }
            }
            CTEMemFree ((PVOID)pNameAddr->pRemoteIpAddrs);
        }
    }

    if (pNameAddr->pIpAddrsList)
    {
        CTEMemFree((PVOID)pNameAddr->pIpAddrsList);
    }
    if (NULL != pNameAddr->FQDN.Buffer) {
        CTEMemFree((PVOID)pNameAddr->FQDN.Buffer);
        pNameAddr->FQDN.Buffer = NULL;
        pNameAddr->FQDN.Length = 0;
        pNameAddr->FQDN.MaximumLength = 0;
    }

    //
    // free the memory now
    //
// #if   DBG
    pNameAddr->Verify += 10;
// #endif    // DBG
    CTEMemFree((PVOID)pNameAddr);

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}

//----------------------------------------------------------------------------
VOID
NbtDereferenceConnection(
    IN  tCONNECTELE     *pConnEle,
    IN  ULONG           RefContext
    )
/*++

Routine Description

    This routine dereferences and possibly deletes a connection element record.


Arguments:


Return Values:

    TDI_STATUS - status of the request

--*/
{
    PCTE_IRP            pIrp;
    CTELockHandle       OldIrq;
    CTELockHandle       OldIrq1;
    tDEVICECONTEXT      *pDeviceContext;
    tLOWERCONNECTION    *pLowerConn;
    PLIST_ENTRY         pEntry;

    CHECK_PTR(pConnEle);

    // grab the lock of the item that contains the one we are trying to
    // dereference and possibly delete.  This prevents anyone from incrementing
    // the count in between decrementing it and checking it for zero and deleting
    // it if it is zero.

    CTESpinLock(pConnEle,OldIrq);

    ASSERT (pConnEle->RefCount > 0) ;      // Check for too many derefs
    ASSERT ((pConnEle->Verify==NBT_VERIFY_CONNECTION) || (pConnEle->Verify==NBT_VERIFY_CONNECTION_DOWN));
    ASSERT (pConnEle->References[RefContext]--);

    if (--pConnEle->RefCount)
    {
        CTESpinFree(pConnEle,OldIrq);
        return;
    }

    ASSERT ((pConnEle->state <= NBT_CONNECTING) || (pConnEle->state > NBT_DISCONNECTING));
    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDereferenceConnection: Delete Connection Object %X\n",pConnEle));

#ifndef VXD
    IoFreeMdl(pConnEle->pNewMdl);
    //
    // Clear the context value in the Fileobject so that if this connection
    // is used again (erroneously) it will not pass the VerifyHandle test
    //
    if (pIrp = pConnEle->pIrpClose)     // the close irp should be held in here
    {
        NTClearFileObjectContext(pConnEle->pIrpClose);
    }
#endif

    pDeviceContext = pConnEle->pDeviceContext;

    CTESpinFree(pConnEle,OldIrq);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLock(pDeviceContext,OldIrq1);

    // For outbound connections the lower connection is deleted in hndlrs.c
    // For inbound connections, the lower connection is put back on the free
    // list in hndlrs.c and one from that list is deleted here.  Therefore
    // delete a lower connection in this list if the connection is inbound.
    //
    if ((pDeviceContext->NumFreeLowerConnections > NbtConfig.MinFreeLowerConnections) &&
        (pDeviceContext->NumFreeLowerConnections > (pDeviceContext->TotalLowerConnections/2)))
    {
        // get a lower connection from the free list and close it with the
        // transport.
        //
        pEntry = RemoveHeadList(&pConnEle->pDeviceContext->LowerConnFreeHead);
        pLowerConn = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);
        InterlockedDecrement (&pDeviceContext->NumFreeLowerConnections);

        // close the lower connection with the transport
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtDereferenceConnection: Closing LowerConn %X -> %X\n",
                pLowerConn,pLowerConn->FileHandle));
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE);
    }
    CTESpinFree(pDeviceContext,OldIrq1);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    FreeConnectionObj(pConnEle);    // free the memory block associated with the conn element

    //
    // The client may have sent down a close before NBT was done with the
    // pConnEle, so Pending was returned and the irp stored in the pCOnnEle
    // structure.  Now that the structure is fully dereferenced, we can complete the irp.
    //
    if (pIrp)
    {
        CTEIoComplete(pIrp,STATUS_SUCCESS,0);
    }

    return;
}

//----------------------------------------------------------------------------
VOID
NbtDereferenceLowerConnection(
    IN  tLOWERCONNECTION    *pLowerConn,
    IN  ULONG               RefContext,
    IN  BOOLEAN             fJointLockHeld
    )
/*++
Routine Description:

    This Routine decrements the reference count on a Lower Connection element and
    if the value is zero, deletes the connection.

Arguments:

Return Value:

     NONE

--*/

{
    CTELockHandle   OldIrq1;
    tCONNECTELE     *pConnEle;
    NTSTATUS        status;

    CTESpinLock(pLowerConn,OldIrq1);

    ASSERT (pLowerConn->Verify == NBT_VERIFY_LOWERCONN); // Verify LowerConn structure
    ASSERT (pLowerConn->References[RefContext]--);
    if(--pLowerConn->RefCount)
    {
        CTESpinFree(pLowerConn,OldIrq1);
        return;
    }
    InterlockedDecrement (&pLowerConn->pDeviceContext->TotalLowerConnections);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.NbtDereferenceLowerConnection: Delete Lower Connection Object %p\n",pLowerConn));

    //
    // it's possible that transport may indicate before we run the code
    // in DelayedWipeOutLowerconn.  If that happens, we don't want to run this
    // code again ( which will queue this to worker thread again!)
    // So, bump it up to some large value
    //
    pLowerConn->RefCount = 1000;

    if (NBT_VERIFY_HANDLE2((pConnEle = pLowerConn->pUpperConnection), NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
    {
        //
        // We still have a linked UpperConnection block, so unlink it,
        //
        SET_STATE_UPPER (pLowerConn->pUpperConnection, NBT_DISCONNECTED);
        NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);
    }

    CTESpinFree(pLowerConn,OldIrq1);

    //
    // let's come back and do this later since we may be at dpc now
    //
    NTQueueToWorkerThread(
            &pLowerConn->WorkItemCleanUpAndWipeOut,
            DelayedWipeOutLowerconn,
            NULL,
            pLowerConn,
            NULL,
            NULL,
            fJointLockHeld
            );
}


//----------------------------------------------------------------------------
VOID
NbtDereferenceTracker(
    IN tDGRAM_SEND_TRACKING     *pTracker,
    IN BOOLEAN                  fLocked
    )
/*++

Routine Description:

    This routine cleans up a Tracker block and puts it back on the free
    queue.  The JointLock Spin lock should be held before calling this
    routine to coordinate access to the tracker ref count.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    CTELockHandle   OldIrq;

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    if (--pTracker->RefCount == 0)
    {
        // the datagram header may have already been freed
        //
        FreeTracker(pTracker, RELINK_TRACKER);
    }

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}

BOOL
IsLocalAddress(
    tIPADDRESS  IpAddress
    )
{
    tDEVICECONTEXT  *pDeviceContext = NULL;
    ULONG           IPInterfaceContext = 0xffff, Metric = 0;
    ULONG           LoopbackIPInterfaceContext = 0xffff;
    CTELockHandle   OldIrq = 0;
    PIPFASTQUERY    pFastQuery;

    if (0 == IpAddress) {
        return TRUE;
    }
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (IsListEmpty(&NbtConfig.DeviceContexts)) {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return FALSE;
    }

    pDeviceContext = CONTAINING_RECORD(NbtConfig.DeviceContexts.Flink, tDEVICECONTEXT, Linkage);
    pFastQuery = pDeviceContext->pFastQuery;
    NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    /*
     * Hack!!!
     */
    if (NbtConfig.LoopbackIfContext == 0xffff) {
        (pFastQuery)(htonl(INADDR_LOOPBACK), &LoopbackIPInterfaceContext, &Metric);
        if (LoopbackIPInterfaceContext != 0xffff) {
            NbtConfig.LoopbackIfContext = LoopbackIPInterfaceContext;
        }
    }
    (pFastQuery)(htonl(IpAddress), &IPInterfaceContext, &Metric);

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, FALSE);

    if (NbtConfig.LoopbackIfContext == 0xffff || IPInterfaceContext == 0xffff) {
        return FALSE;
    }
    return (IPInterfaceContext == NbtConfig.LoopbackIfContext);
}

BOOL
IsSmbBoundToOutgoingInterface(
    IN  tIPADDRESS      IpAddress
    )
/*++

Routine Description:

    This routine returns TRUE if the destionation can be reached through
    an interface to which the SmbDevice is bound. Otherwise it returns FALSE


Arguments:

    IpAddress   The address of destination

Return Value:

    TRUE/FALSE

--*/
{
    tDEVICECONTEXT  *pDeviceContext;
    BOOL            bBind;

    if (IpAddress == INADDR_LOOPBACK) {
        return TRUE;
    }

    /*
     * First check if this is a local address
     * return TRUE if it is a local address
     */
    if (IsLocalAddress(IpAddress)) {
        return TRUE;
    }

    /*
     * This is not a local IP. Check with TCP
     */
    pDeviceContext = GetDeviceFromInterface (htonl(IpAddress), TRUE);
    bBind = (pDeviceContext && (pDeviceContext->AdapterMask & NbtConfig.ClientMask));

    if (pDeviceContext) {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, FALSE);
    }

    return bBind;
}

// ========================================================================
// End of file.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nbtutils.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Nbtutils.c

Abstract:

    This file continas  a number of utility and support routines for
    the NBT code.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"

//  For some reason inclusion of dnsapi.h seems to cause build error
//#include "dns.h"            // for DNS_MAX_NAME_LENGTH
//#include "windns.h"         // for DNS_MAX_NAME_LENGTH

#define  DNS_MAX_NAME_LENGTH    (255)


//#if DBG
LIST_ENTRY  UsedIrps;
//#endif

NTSTATUS
NewInternalAddressFromNetbios(
    IN  PTA_NETBIOS_ADDRESS         pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    );
NTSTATUS
NewInternalAddressFromNetbiosEX(
    IN  PTA_NETBIOS_EX_ADDRESS      pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    );
NTSTATUS
NewInternalAddressFromUnicodeAddress(
    IN  PTA_NETBIOS_UNICODE_EX_ADDRESS pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, ConvertDottedDecimalToUlong)
#pragma CTEMakePageable(PAGE, CloseLowerConnections)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------

BOOLEAN
IsEntryInList(
    PLIST_ENTRY     pEntryToFind,
    PLIST_ENTRY     pListToSearch
    )
{
    PLIST_ENTRY     pEntry, pHead;

    pHead = pListToSearch;
    pEntry = pHead->Flink;
    while (pEntry != pHead)
    {
        if (pEntry == pEntryToFind)
        {
            //
            // This Entry is still valid
            //
            return (TRUE);
        }

        //
        // Go to next Entry
        //
        pEntry = pEntry->Flink;
    }

    return (FALSE);
}


//----------------------------------------------------------------------------
void
NbtFreeAddressObj(
    tADDRESSELE    *pAddress
    )

/*++

Routine Description:

    This routine releases all memory associated with an Address object.

Arguments:


Return Value:

    none

--*/

{
    //
    // let's come back and do this later when it's not dpc time
    //
    NTQueueToWorkerThread(
                        &pAddress->WorkItemClose,
                        DelayedFreeAddrObj,
                        NULL,
                        pAddress,
                        NULL,
                        NULL,
                        FALSE
                        );
}

//----------------------------------------------------------------------------
VOID
DelayedFreeAddrObj(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   pUnused2,
    IN  tDEVICECONTEXT          *pUnused3
    )

/*++

Routine Description:

    This routine releases all memory associated with an Address object.

Arguments:


Return Value:

    none

--*/

{
    tADDRESSELE *pAddress = (tADDRESSELE *) pClientContext;
    ULONG       SavedVerify = pAddress->Verify;

#ifndef VXD
    if (pAddress->SecurityDescriptor)
    {
        SeDeassignSecurity(&pAddress->SecurityDescriptor);
    }
#endif

#if DBG
    CTEMemSet (pAddress, 0x12, sizeof(tADDRESSELE));
#endif  // DBG

    // free the address block itself
    // Modify the verify value so that another user of the same memory
    // block cannot accidently pass in a valid verifier

    pAddress->Verify = SavedVerify + 10;
    CTEMemFree ((PVOID) pAddress);
}

//----------------------------------------------------------------------------
void
NbtFreeClientObj(
    tCLIENTELE    *pClientEle
    )

/*++

Routine Description:

    This routine releases all memory associated with Client object.

Arguments:


Return Value:

    none

--*/

{
    ULONG   SavedVerify = pClientEle->Verify;

#if DBG
    CTEMemSet (pClientEle, 0x12, sizeof(tCLIENTELE));
#endif  // DBG

    // Modify the verify value so that another user of the same memory
    // block cannot accidently pass in a valid verifier
    pClientEle->Verify = SavedVerify + 10;
    CTEMemFree ((PVOID) pClientEle);
}

//----------------------------------------------------------------------------
void
FreeConnectionObj(
    tCONNECTELE       *pConnEle
    )

/*++

Routine Description:

    This routine releases all memory associated with a Connection object
    and then it frees the connection object itself.

Arguments:


Return Value:

    none

--*/

{
    ULONG   SavedVerify = pConnEle->Verify;

#if DBG
    CTEMemSet (pConnEle, 0x12, sizeof(tCONNECTELE));
#endif  // DBG
    // Modify the verify value so that another user of the same memory
    // block cannot accidently pass in a valid verifier
    pConnEle->Verify = SavedVerify + 10;
    CTEMemFree ((PVOID) pConnEle);
}


//----------------------------------------------------------------------------
tCLIENTELE *
NbtAllocateClientBlock(
    tADDRESSELE     *pAddrEle,
    tDEVICECONTEXT  *pDeviceContext
    )

/*++

Routine Description:

    This routine allocates a block of memory for a client openning an
    address.  It fills in default values for the block and links the
    block to the addresslist.  The AddressEle spin lock is held when this
    routine is called.

Arguments:


Return Value:

    none

--*/

{
    tCLIENTELE  *pClientElement;

    // allocate memory for the client block
    pClientElement = (tCLIENTELE *) NbtAllocMem (sizeof (tCLIENTELE), NBT_TAG2('05'));
    if (!pClientElement)
    {
        ASSERTMSG("Unable to allocate Memory for a client block\n",
                pClientElement);
        return(NULL);
    }
    CTEZeroMemory((PVOID)pClientElement,sizeof(tCLIENTELE));

    CTEInitLock(&pClientElement->LockInfo.SpinLock);
#if DBG
    pClientElement->LockInfo.LockNumber = CLIENT_LOCK;
#endif

    // Set Event handler function pointers to default routines provided by
    // TDI
#ifndef VXD
    pClientElement->evConnect      = TdiDefaultConnectHandler;
    pClientElement->evReceive      = TdiDefaultReceiveHandler;
    pClientElement->evDisconnect   = TdiDefaultDisconnectHandler;
    pClientElement->evError        = TdiDefaultErrorHandler;
    pClientElement->evRcvDgram     = TdiDefaultRcvDatagramHandler;
    pClientElement->evRcvExpedited = TdiDefaultRcvExpeditedHandler;
    pClientElement->evSendPossible = TdiDefaultSendPossibleHandler;
#else
    //
    // VXD provides no client support for event handlers but does
    // make use of some of the event handlers itself (for RcvAny processing
    // and disconnect cleanup).
    //
    pClientElement->evConnect      = NULL ;
    pClientElement->evReceive      = NULL ;
    pClientElement->RcvEvContext   = NULL ;
    pClientElement->evDisconnect   = NULL ;
    pClientElement->evError        = NULL ;
    pClientElement->evRcvDgram     = NULL ;
    pClientElement->evRcvExpedited = NULL ;
    pClientElement->evSendPossible = NULL ;
#endif

    pClientElement->RefCount = 1;

    // there are no rcvs or snds yet
    InitializeListHead(&pClientElement->RcvDgramHead);
    InitializeListHead(&pClientElement->ListenHead);
    InitializeListHead(&pClientElement->SndDgrams);
    InitializeListHead(&pClientElement->ConnectActive);
    InitializeListHead(&pClientElement->ConnectHead);
#ifdef VXD
    InitializeListHead(&pClientElement->RcvAnyHead);
    pClientElement->fDeregistered = FALSE ;
#endif
    pClientElement->pIrp = NULL;

    // copy a special value into the verify long so that we can verify
    // connection ptrs passed back from the application
    pClientElement->Verify = NBT_VERIFY_CLIENT;
    pClientElement->pAddress = (PVOID)pAddrEle;         // link the client block to the Address element.
    pClientElement->pDeviceContext = pDeviceContext;    // adapter this name is registered against.

    // put the new Client element block on the end of the linked list tied to
    // the address element
    InsertTailList(&pAddrEle->ClientHead,&pClientElement->Linkage);

    return(pClientElement);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtAddPermanentName(
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++

Routine Description:

    This routine adds the node permanent name to the local name table.  This
    is the node's MAC address padded out to 16 bytes with zeros.

Arguments:
    DeviceContext - Adapter to add permanent
    pIrp          - Irp (optional) to complete after name has been added


Return Value:

    status

--*/

{
    NTSTATUS             status;
    TDI_REQUEST          Request;
    TA_NETBIOS_ADDRESS   Address;
    UCHAR                pName[NETBIOS_NAME_SIZE];
    USHORT               uType;
    CTELockHandle        OldIrq, OldIrq1;
    tNAMEADDR            *pNameAddr;
    tCLIENTELE           *pClientEle;

    CTEZeroMemory(pName,NETBIOS_NAME_SIZE);
    CTEMemCopy(&pName[10],&pDeviceContext->MacAddress.Address[0],sizeof(tMAC_ADDRESS));

    //
    // be sure the name has not already been added
    //
    if (pDeviceContext->pPermClient)
    {
        if (CTEMemEqu(pDeviceContext->pPermClient->pAddress->pNameAddr->Name, pName, NETBIOS_NAME_SIZE))
        {
            return(STATUS_SUCCESS);
        }
        else
        {
            NbtRemovePermanentName(pDeviceContext);
        }
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    //
    // check if the name is already in the hash table
    //
    status = FindInHashTable (pNbtGlobConfig->pLocalHashTbl, pName, NbtConfig.pScope, &pNameAddr);
    if ((NT_SUCCESS(status)) && (pNameAddr->pAddressEle))
    {
        //  
        // Acquire Address Spinlock since we may be accessing the ClientHead list
        // Bug #: 230820
        //
        CTESpinLock(pNameAddr->pAddressEle,OldIrq1);

        //
        // create client block and link to addresslist
        // pass back the client block address as a handle for future reference
        // to the client
        //
        pClientEle = NbtAllocateClientBlock (pNameAddr->pAddressEle, pDeviceContext);

        if (!pClientEle)
        {
            CTESpinFree(pNameAddr->pAddressEle,OldIrq1);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NBT_REFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_NEW_CLIENT);
        CTESpinFree(pNameAddr->pAddressEle,OldIrq1);

        //
        // reset the ip address incase the the address got set to loop back
        // by a client releasing and re-openning the permanent name while there
        // was no ip address for this node.
        //
        pNameAddr->IpAddress = pDeviceContext->IpAddress;

        // turn on the adapter's bit in the adapter Mask and set the
        // re-register flag so we register the name out the new adapter.
        //
        pNameAddr->AdapterMask |= pDeviceContext->AdapterMask;
        pNameAddr->NameTypeState |= NAMETYPE_QUICK;

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt: Adding Permanent name %15.15s<%X> \n", pName,(UCHAR)pName[15]));
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        // make up the Request data structure from the IRP info
        Request.Handle.AddressHandle = NULL;

        //
        // Make it a Quick name so it does not get registered on the net
        //
        Address.TAAddressCount = 1;
        Address.Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
        Address.Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
        Address.Address[0].Address[0].NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;

        CTEMemCopy(Address.Address[0].Address[0].NetbiosName,pName,NETBIOS_NAME_SIZE);

        status = NbtOpenAddress(&Request,
                                (PTA_ADDRESS)&Address.Address[0],
                                pDeviceContext->IpAddress,
                                pDeviceContext,
                                NULL);

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        pClientEle = (tCLIENTELE *)Request.Handle.AddressHandle;

    }

    //
    // save the client element so we can remove the permanent name later
    // if required
    //
    if (NT_SUCCESS(status))
    {
        pDeviceContext->pPermClient = pClientEle;
#ifdef VXD
       //
       // 0th element is for perm. name: store it.
       //
       pDeviceContext->pNameTable[0] = pClientEle;
#endif
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    return(status);
}


//----------------------------------------------------------------------------
VOID
NbtRemovePermanentName(
    IN  tDEVICECONTEXT  *pDeviceContext
    )

/*++

Routine Description:

    This routine remomves the node permanent name to the local name table.

Arguments:
    DeviceContext - Adapter to add permanent
    pIrp          - Irp (optional) to complete after name has been added


Return Value:

    status

--*/

{
    NTSTATUS             status;
    tNAMEADDR            *pNameAddr;
    CTELockHandle        OldIrq;
    tCLIENTELE           *pClientEle;
    tADDRESSELE          *pAddressEle;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pDeviceContext->pPermClient)
    {

        //
        // We need to free the client and set the perm name ptr to null
        //
        pClientEle = pDeviceContext->pPermClient;
        pDeviceContext->pPermClient = NULL;

#ifdef VXD
        pDeviceContext->pNameTable[0] = NULL;
#endif

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NBT_DEREFERENCE_CLIENT(pClientEle);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
ConvertDottedDecimalToUlong(
    IN  PUCHAR               pInString,
    OUT PULONG               IpAddress
    )

/*++

Routine Description:

    This routine converts a unicode dotted decimal IP address into
    a 4 element array with each element being USHORT.

Arguments:


Return Value:

    NTSTATUS

--*/

{
    USHORT          i;
    ULONG           value;
    int             iSum =0;
    ULONG           k = 0;
    UCHAR           Chr;
    UCHAR           pArray[4];

    CTEPagedCode();
    pArray[0] = 0;

    // go through each character in the string, skipping "periods", converting
    // to integer by subtracting the value of '0'
    //
    while ((Chr = *pInString++) && (Chr != ' ') )
    {
        if (Chr == '.')
        {
            // be sure not to overflow a byte.
            if (iSum <= 0xFF)
                pArray[k] = (UCHAR) iSum;
            else
                return(STATUS_UNSUCCESSFUL);

            // check for too many periods in the address
            if (++k > 3)
                return STATUS_UNSUCCESSFUL;

            pArray[k] = 0;
            iSum = 0;
        }
        else
        {
            Chr = Chr - '0';

            // be sure character is a number 0..9
            if ((Chr < 0) || (Chr > 9))
                return(STATUS_UNSUCCESSFUL);

            iSum = iSum*10 + Chr;
        }
    }

    // save the last sum in the byte and be sure there are 4 pieces to the
    // address
    if ((iSum <= 0xFF) && (k == 3))
        pArray[k] = (UCHAR) iSum;
    else
        return(STATUS_UNSUCCESSFUL);

    // now convert to a ULONG, in network order...
    value = 0;

    // go through the array of bytes and concatenate into a ULONG
    for (i=0; i < 4; i++ )
    {
        value = (value << 8) + pArray[i];
    }
    *IpAddress = value;

    return(STATUS_SUCCESS);

}

//----------------------------------------------------------------------------
NTSTATUS
NbtInitQ(
    PLIST_ENTRY pListHead,
    LONG        iSizeBuffer,
    LONG        iNumBuffers
    )

/*++

Routine Description:

    This routine allocates memory blocks for doubly linked lists and links
    them to a list.

Arguments:
    ppListHead  - a ptr to a ptr to the list head to add buffer to
    iSizeBuffer - size of the buffer to add to the list head
    iNumBuffers - the number of buffers to add to the queue

Return Value:

    none

--*/

{
    int         i;
    PLIST_ENTRY pBuffer;

    //  NOTE THAT THIS ASSUMES THAT THE LINKAGE PTRS FOR EACH BLOCK ARE AT
    // THE START OF THE BLOCK    - so it will not work correctly if
    // the various types in types.h change to move "Linkage" to a position
    // other than at the start of each structure to be chained

    for (i=0;i<iNumBuffers ;i++ )
    {
        pBuffer =(PLIST_ENTRY) NbtAllocMem (iSizeBuffer, NBT_TAG2('06'));
        if (!pBuffer)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        else
        {
            InsertHeadList(pListHead,pBuffer);
        }
    }

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtGetBuffer(
    PLIST_ENTRY         pListHead,
    PLIST_ENTRY         *ppListEntry,
    enum eBUFFER_TYPES  eBuffType)

/*++

Routine Description:

    This routine tries to get a memory block and if it fails it allocates
    another set of buffers.

Arguments:
    ppListHead  - a ptr to a ptr to the list head to add buffer to
    iSizeBuffer - size of the buffer to add to the list head
    iNumBuffers - the number of buffers to add to the queue

Return Value:

    none

--*/

{
    NTSTATUS    status;

    if (IsListEmpty(pListHead))
    {
        // check if we are allowed to allocate more memory blocks
        if (NbtConfig.iCurrentNumBuff[eBuffType] >=
                                pNbtGlobConfig->iMaxNumBuff[eBuffType]  )
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        // no memory blocks, so allocate another one
        status = NbtInitQ(
                        pListHead,
                        pNbtGlobConfig->iBufferSize[eBuffType],
                        1);
        if (!NT_SUCCESS(status))
        {
            return(status);
        }

        NbtConfig.iCurrentNumBuff[eBuffType]++;

        *ppListEntry = RemoveHeadList(pListHead);
    }
    else
    {
        *ppListEntry = RemoveHeadList(pListHead);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
NetbiosAddressToInternalAddress(
    IN  PTA_NETBIOS_ADDRESS         pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTDI_ADDRESS_NETBT_INTERNAL pNetBT
    )
{
    //
    // name could be longer than 16 bytes (dns name), but make sure it's at
    // least 16 bytes (sizeof(TDI_ADDRESS_NETBIOS) == (16 + sizeof(USHORT)))
    //
    if (pTA->Address[0].AddressLength < sizeof(TDI_ADDRESS_NETBIOS)) {
        return(STATUS_INVALID_PARAMETER);
    }

    pNetBT->NameType = pTA->Address[0].Address[0].NetbiosNameType;
    pNetBT->AddressType = TDI_ADDRESS_TYPE_NETBIOS;

    pNetBT->OEMEndpointName.Buffer = NULL;
    pNetBT->OEMEndpointName.Length = pNetBT->OEMEndpointName.MaximumLength = 0;

    /* Here we bent OEM_STRING a little bit, we allow Length == MaximumLength */
    /* That is, Rtl routines cannot be used since they expect null-terminated Buffer */
    pNetBT->OEMRemoteName.MaximumLength = pNetBT->OEMRemoteName.Length =
            pTA->Address[0].AddressLength - (sizeof(TDI_ADDRESS_NETBIOS) - NETBIOS_NAME_SIZE);
    pNetBT->OEMRemoteName.Buffer = pTA->Address[0].Address[0].NetbiosName;
    pNetBT->pNetbiosUnicodeEX = NULL;
    return STATUS_SUCCESS;
}

NTSTATUS
NetbiosEXAddressToInternalAddress(
    IN  PTA_NETBIOS_EX_ADDRESS      pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTDI_ADDRESS_NETBT_INTERNAL pNetBT
    )
{
    //
    // Check for the minimum acceptable length for this type of address
    //
    if (MaxInputBufferLength < sizeof (TA_NETBIOS_EX_ADDRESS)) {
        ASSERT (0);
        return (STATUS_INVALID_ADDRESS);
    }

    pNetBT->OEMEndpointName.Buffer = pTA->Address[0].Address[0].EndpointName;
    pNetBT->OEMEndpointName.Length = pNetBT->OEMEndpointName.MaximumLength = NETBIOS_NAME_SIZE;

    pNetBT->NameType = pTA->Address[0].Address[0].NetbiosAddress.NetbiosNameType;
    pNetBT->AddressType = TDI_ADDRESS_TYPE_NETBIOS_EX;
    pNetBT->OEMRemoteName.MaximumLength = pNetBT->OEMRemoteName.Length =
                        pTA->Address[0].AddressLength -
                        FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,NetbiosAddress) -
                        FIELD_OFFSET(TDI_ADDRESS_NETBIOS,NetbiosName);
    pNetBT->OEMRemoteName.Buffer = pTA->Address[0].Address[0].NetbiosAddress.NetbiosName;
    pNetBT->pNetbiosUnicodeEX = NULL;
    return STATUS_SUCCESS;
}

NTSTATUS
NewInternalAddressFromNetbiosEX(
    IN  PTA_NETBIOS_EX_ADDRESS   pTA,
    IN  ULONG                    MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    )
{
    ULONG       required_size;
    PTA_NETBT_INTERNAL_ADDRESS  p;
    PTDI_ADDRESS_NETBT_INTERNAL pNetBT;
    TDI_ADDRESS_NETBT_INTERNAL  ta;
 
    ppNetBT[0] = NULL;
    if (!NT_SUCCESS(NetbiosEXAddressToInternalAddress(pTA, MaxInputBufferLength, &ta))) {
        return (STATUS_INVALID_ADDRESS);
    }

    required_size = NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)) +
                    NBT_DWORD_ALIGN(ta.OEMRemoteName.Length+1) +
                    NBT_DWORD_ALIGN(ta.OEMEndpointName.Length+1);
    p = (PTA_NETBT_INTERNAL_ADDRESS)NbtAllocMem (required_size, NBT_TAG2('TA'));
    if (p == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    CTEZeroMemory(p, required_size);

    // From now on, we cannot have failure.
    pNetBT = p->Address[0].Address;
    p->TAAddressCount = 1;
    p->Address[0].AddressLength = sizeof(TA_NETBT_INTERNAL_ADDRESS);
    p->Address[0].AddressType = TDI_ADDRESS_TYPE_UNSPEC;

    pNetBT->NameType = ta.NameType;
    pNetBT->AddressType = ta.AddressType;

    pNetBT->OEMRemoteName.MaximumLength = NBT_DWORD_ALIGN(ta.OEMRemoteName.Length+1);
    pNetBT->OEMRemoteName.Length        = ta.OEMRemoteName.Length;
    pNetBT->OEMRemoteName.Buffer        = (PVOID)((PUCHAR)p + NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)));
    ASSERT((ta.OEMRemoteName.Length % sizeof(ta.OEMRemoteName.Buffer[0])) == 0);
    CTEMemCopy(pNetBT->OEMRemoteName.Buffer, ta.OEMRemoteName.Buffer, ta.OEMRemoteName.Length);
    pNetBT->OEMRemoteName.Buffer[ta.OEMRemoteName.Length/sizeof(ta.OEMRemoteName.Buffer[0])] = 0;

    pNetBT->OEMEndpointName.MaximumLength = NBT_DWORD_ALIGN(ta.OEMEndpointName.Length+1);
    pNetBT->OEMEndpointName.Length        = ta.OEMEndpointName.Length;
    pNetBT->OEMEndpointName.Buffer        = (PVOID)((PUCHAR)pNetBT->OEMRemoteName.Buffer +
                                                    pNetBT->OEMRemoteName.MaximumLength);
    ASSERT((ta.OEMEndpointName.Length % sizeof(ta.OEMEndpointName.Buffer[0])) == 0);
    CTEMemCopy(pNetBT->OEMEndpointName.Buffer, ta.OEMEndpointName.Buffer, ta.OEMEndpointName.Length);
    pNetBT->OEMEndpointName.Buffer[ta.OEMEndpointName.Length/sizeof(ta.OEMEndpointName.Buffer[0])] = 0;

    pNetBT->pNetbiosUnicodeEX = NULL;

    ppNetBT[0] = p;
    return STATUS_SUCCESS;
}

NTSTATUS
NewInternalAddressFromNetbios(
    IN  PTA_NETBIOS_ADDRESS      pTA,
    IN  ULONG                    MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    )
{
    ULONG       required_size;
    PTA_NETBT_INTERNAL_ADDRESS  p;
    PTDI_ADDRESS_NETBT_INTERNAL pNetBT;
    TDI_ADDRESS_NETBT_INTERNAL  ta;
 
    ppNetBT[0] = NULL;
    if (!NT_SUCCESS(NetbiosAddressToInternalAddress(pTA, MaxInputBufferLength, &ta))) {
        return (STATUS_INVALID_ADDRESS);
    }

    required_size = NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)) +
                    NBT_DWORD_ALIGN(ta.OEMRemoteName.Length+1);
    p = (PTA_NETBT_INTERNAL_ADDRESS)NbtAllocMem (required_size, NBT_TAG2('TA'));
    if (p == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    CTEZeroMemory(p, required_size);

    // From now on, we cannot have failure.
    pNetBT = p->Address[0].Address;
    p->TAAddressCount = 1;
    p->Address[0].AddressLength = sizeof(TA_NETBT_INTERNAL_ADDRESS);
    p->Address[0].AddressType = TDI_ADDRESS_TYPE_UNSPEC;

    pNetBT->NameType = ta.NameType;
    pNetBT->AddressType = ta.AddressType;

    pNetBT->OEMRemoteName.MaximumLength = NBT_DWORD_ALIGN(ta.OEMRemoteName.Length+1);
    pNetBT->OEMRemoteName.Length        = ta.OEMRemoteName.Length;
    pNetBT->OEMRemoteName.Buffer        = (PVOID)((PUCHAR)p + NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)));
    ASSERT((ta.OEMRemoteName.Length % sizeof(ta.OEMRemoteName.Buffer[0])) == 0);
    CTEMemCopy(pNetBT->OEMRemoteName.Buffer, ta.OEMRemoteName.Buffer, ta.OEMRemoteName.Length);
    pNetBT->OEMRemoteName.Buffer[ta.OEMRemoteName.Length/sizeof(ta.OEMRemoteName.Buffer[0])] = 0;

    pNetBT->pNetbiosUnicodeEX = NULL;
    pNetBT->OEMEndpointName.MaximumLength = 0;
    pNetBT->OEMEndpointName.Length        = 0;
    pNetBT->OEMEndpointName.Buffer        = NULL;

    ppNetBT[0] = p;
    return STATUS_SUCCESS;
}

NTSTATUS
NewInternalAddressFromUnicodeAddress(
    IN  PTA_NETBIOS_UNICODE_EX_ADDRESS pTA,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    )
{
    OEM_STRING  OemEndpoint, OemRemote;
    UNICODE_STRING  temp;
    ULONG       required_size;
    PTA_NETBT_INTERNAL_ADDRESS  p;
    PTDI_ADDRESS_NETBT_INTERNAL pNetBT;
    int         remote_len;

    ppNetBT[0] = NULL;

    if (MaxInputBufferLength < sizeof (TDI_ADDRESS_NETBIOS_UNICODE_EX)) {
        ASSERT (0);
        return (STATUS_INVALID_ADDRESS);
    }
    switch(pTA->Address[0].Address[0].NameBufferType) {
    case NBT_READONLY:
    case NBT_WRITEONLY:
    case NBT_READWRITE:
    case NBT_WRITTEN:
        break;
    
    default:
        ASSERT(FALSE);
        return (STATUS_INVALID_ADDRESS);
    }

    /* unaligned */
    CTEMemCopy(&temp, &pTA->Address[0].Address[0].RemoteName, sizeof(temp));
    if (temp.MaximumLength > DNS_NAME_BUFFER_LENGTH * sizeof(WCHAR)) {
        return (STATUS_INVALID_ADDRESS);
    }
    if (temp.Length > DNS_MAX_NAME_LENGTH * sizeof(WCHAR)) {
        return (STATUS_INVALID_ADDRESS);
    }
    if (temp.Length + sizeof(WCHAR) > temp.MaximumLength) {
        return (STATUS_INVALID_ADDRESS);
    }
    if (!NT_SUCCESS(RtlUpcaseUnicodeStringToOemString(&OemRemote, &temp, TRUE))) {
        return (STATUS_INVALID_ADDRESS);
    }
    CTEMemCopy(&temp, &pTA->Address[0].Address[0].EndpointName, sizeof(temp));
    if (!NT_SUCCESS(RtlUpcaseUnicodeStringToOemString(&OemEndpoint, &temp, TRUE))) {
        RtlFreeOemString(&OemRemote);
        return (STATUS_INVALID_ADDRESS);
    }

    /*
     * Other NetBT may never expect that remote_len and endpoint_len can be less than NETBIOS_NAME_SIZE.
     * Some of them may try to access 15th byte of the name.
     * In NETBIOS_NAME_TYPE and NETBIOS_EX_NAME_TYPE, at least NETBIOS_NAME_SIZE bytes are required for each name.
     */
    remote_len = OemRemote.MaximumLength;
    if (remote_len <= NETBIOS_NAME_SIZE) {
        remote_len = NETBIOS_NAME_SIZE + 1;
    }

    /* Calculate the needed buffer size */
    required_size = NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)) +
            NBT_DWORD_ALIGN(remote_len) +          // For OEM remote
            NBT_DWORD_ALIGN((NETBIOS_NAME_SIZE+1)*sizeof(OemEndpoint.Buffer[0]));
    p = (PTA_NETBT_INTERNAL_ADDRESS)NbtAllocMem (required_size, NBT_TAG2('TA'));
    if (p == NULL) {
        RtlFreeOemString(&OemRemote);
        RtlFreeOemString(&OemEndpoint);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    CTEZeroMemory(p, required_size);

    // From now on, we cannot have failure.
    pNetBT = p->Address[0].Address;
    p->TAAddressCount = 1;
    p->Address[0].AddressLength = sizeof(TA_NETBT_INTERNAL_ADDRESS);
    p->Address[0].AddressType = TDI_ADDRESS_TYPE_UNSPEC;

    pNetBT->NameType = pTA->Address[0].Address[0].NetbiosNameType;
    pNetBT->AddressType = TDI_ADDRESS_TYPE_NETBIOS_EX;  // map to NETBIOS_EX

    // copy OEM EndpointName
    pNetBT->OEMEndpointName.Buffer =
            (PVOID)((PUCHAR)p + NBT_DWORD_ALIGN(sizeof(TA_NETBT_INTERNAL_ADDRESS)));
    pNetBT->OEMEndpointName.MaximumLength = NBT_DWORD_ALIGN((NETBIOS_NAME_SIZE+1));
    pNetBT->OEMEndpointName.Length = NETBIOS_NAME_SIZE;
    ASSERT((NETBIOS_NAME_SIZE % sizeof(OemRemote.Buffer[0])) == 0);
    if (OemEndpoint.Length < NETBIOS_NAME_SIZE) {
        memset(pNetBT->OEMEndpointName.Buffer + OemEndpoint.Length, ' ', NETBIOS_NAME_SIZE);
        CTEMemCopy(pNetBT->OEMEndpointName.Buffer, OemEndpoint.Buffer, OemEndpoint.Length);
    } else {
        CTEMemCopy(pNetBT->OEMEndpointName.Buffer, OemEndpoint.Buffer, NETBIOS_NAME_SIZE);
    }
    pNetBT->OEMEndpointName.Buffer[NETBIOS_NAME_SIZE] = 0;
    RtlFreeOemString(&OemEndpoint);

    // copy OEM RemoteName
    pNetBT->OEMRemoteName.Buffer =
        ((PUCHAR)pNetBT->OEMEndpointName.Buffer + pNetBT->OEMEndpointName.MaximumLength);
    pNetBT->OEMRemoteName.MaximumLength = NBT_DWORD_ALIGN(remote_len);
    if (OemRemote.Length < NETBIOS_NAME_SIZE) {
        pNetBT->OEMRemoteName.Length = NETBIOS_NAME_SIZE;
        memset (pNetBT->OEMRemoteName.Buffer, ' ', NETBIOS_NAME_SIZE);
        CTEMemCopy(pNetBT->OEMRemoteName.Buffer, OemRemote.Buffer, OemRemote.Length);
        pNetBT->OEMRemoteName.Buffer[remote_len-1] = 0;
    } else {
        pNetBT->OEMRemoteName.Length = OemRemote.Length;
        CTEMemCopy(pNetBT->OEMRemoteName.Buffer, OemRemote.Buffer, OemRemote.MaximumLength);
    }
    RtlFreeOemString(&OemRemote);

    pNetBT->pNetbiosUnicodeEX = pTA->Address[0].Address;

    ppNetBT[0] = p;
    return STATUS_SUCCESS;
}

VOID
DeleteInternalAddress(IN PTA_NETBT_INTERNAL_ADDRESS pNetBT)
{
#if 0
    PTA_NETBT_INTERNAL_ADDRESS  p;

    p = CONTAINING_RECORD(pNetBT,PTA_NETBT_INTERNAL_ADDRESS,Address[0].Address);
    ASSERT(p->AddressCount == 1);
    ASSERT(p->Address[0].AddressLength == sizeof(TDI_ADDRESS_NETBT_INTERNAL));
    ASSERT(p->Address[0].AddressType == TDI_ADDRESS_TYPE_UNSPEC);
#endif
    if (pNetBT == NULL) {
        return;
    }
    ASSERT(pNetBT->TAAddressCount == 1);
    ASSERT(pNetBT->Address[0].AddressLength == sizeof(TA_NETBT_INTERNAL_ADDRESS));
    ASSERT(pNetBT->Address[0].AddressType == TDI_ADDRESS_TYPE_UNSPEC);
    CTEMemFree(pNetBT);
}

//----------------------------------------------------------------------------
NTSTATUS
NewInternalAddressFromTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddress,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTA_NETBT_INTERNAL_ADDRESS  *ppNetBT
    )
/*++

Routine Description

    This routine handles deciphering the weird transport address syntax
    and convert all types of NetBIOS address into one internal format.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{
    ppNetBT[0] = NULL;
    //
    // Check for the minimum acceptable length
    //
    if ((!pTransportAddress) || (MaxInputBufferLength < sizeof (TA_NETBIOS_ADDRESS))) {
        ASSERT (0);
        return (STATUS_INVALID_ADDRESS);
    }

    switch (pTransportAddress->Address[0].AddressType)
    {
    case (TDI_ADDRESS_TYPE_NETBIOS):
        return NewInternalAddressFromNetbios(
                (PTA_NETBIOS_ADDRESS)pTransportAddress,
                MaxInputBufferLength, ppNetBT);

#ifndef VXD
    case (TDI_ADDRESS_TYPE_NETBIOS_EX):
        return NewInternalAddressFromNetbiosEX(
                (PTA_NETBIOS_EX_ADDRESS)pTransportAddress,
                MaxInputBufferLength, ppNetBT);
#endif  // !VXD

    case (TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX):
        return NewInternalAddressFromUnicodeAddress(
                (PTA_NETBIOS_UNICODE_EX_ADDRESS)pTransportAddress,
                MaxInputBufferLength, ppNetBT);

    default:
        return (STATUS_INVALID_ADDRESS);
    }

    if (ppNetBT[0]->Address[0].Address[0].OEMRemoteName.Length > DNS_MAX_NAME_LENGTH) {
        DeleteInternalAddress(ppNetBT[0]);
        ppNetBT[0] = NULL;
        return (STATUS_NAME_TOO_LONG);
    }

    return (STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
GetNetBiosNameFromTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *pTransportAddress,
    IN  ULONG                       MaxInputBufferLength,
    OUT PTDI_ADDRESS_NETBT_INTERNAL pNetBT
    )
/*++

Routine Description

    This routine handles deciphering the weird transport address syntax
    to retrieve the netbios name out of that address.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{
    //
    // Check for the minimum acceptable length
    //
    if ((!pTransportAddress) ||
        (MaxInputBufferLength < sizeof (TA_NETBIOS_ADDRESS)))
    {
        ASSERT (0);
        return (STATUS_INVALID_ADDRESS);
    }

    CTEZeroMemory(pNetBT, sizeof(pNetBT[0]));
    switch (pTransportAddress->Address[0].AddressType)
    {
    case (TDI_ADDRESS_TYPE_NETBIOS):
        return NetbiosAddressToInternalAddress(
                (PTA_NETBIOS_ADDRESS)pTransportAddress,
                MaxInputBufferLength, pNetBT);

#ifndef VXD
    case (TDI_ADDRESS_TYPE_NETBIOS_EX):
        return NetbiosEXAddressToInternalAddress(
                (PTA_NETBIOS_EX_ADDRESS)pTransportAddress,
                MaxInputBufferLength, pNetBT);
#endif  // !VXD

        default:
        {
            return (STATUS_INVALID_ADDRESS);
        }
    }

    if (pNetBT->OEMRemoteName.Length > DNS_MAX_NAME_LENGTH)
    {
        return (STATUS_NAME_TOO_LONG);
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
ConvertToAscii(
    IN  PCHAR            pNameHdr,
    IN  LONG             NumBytes,
    OUT PCHAR            pName,
    OUT PCHAR            *pScope,
    OUT PULONG           pNameSize
    )
/*++

Routine Description:

    This routine converts half ascii to normal ascii and then appends the scope
    onto the end of the name to make a full name again.

Arguments:
    NumBytes    - the total number of bytes in the message starting from the
                  tNETBIOS_NAME structure - may include more than just the name itself

Return Value:

    NTSTATUS - success or not
    This routine returns the length of the name in half ascii format including
    the null at the end, but NOT including the length byte at the beginning.
    Thus, for a non-scoped name it would return 33.

    It converts the name to ascii and puts 16 bytes into pName, then it returns
    pScope as the Ptr to the scope that is still in pNameHdr.


--*/
{
    LONG     i, ScopeLength, lValue;
    ULONG    UNALIGNED    *pHdr;

    // 1st byte is length of the half ascii name, ie 32 (0x20) ==> (Length == 1 byte)
    // It should be followed by the half-ascii name            ==> (Length == 32 bytes)
    // Finally, it has the Scope information                   ==> (Length >= 1 byte)
    //
    if ((NumBytes > 1+NETBIOS_NAME_SIZE*2) && (*pNameHdr == NETBIOS_NAME_SIZE*2))
    {
        pHdr = (ULONG UNALIGNED *)++pNameHdr;  // to increment past the length byte

        // the Half AScii portion of the netbios name is always 32 bytes long
        for (i=0; i < NETBIOS_NAME_SIZE*2 ;i +=4 )
        {
            lValue = *pHdr - 0x41414141;  // four A's
            pHdr++;
            lValue =    ((lValue & 0x0F000000) >> 16) +
                        ((lValue & 0x000F0000) >> 4) +
                        ((lValue & 0x00000F00) >> 8) +
                        ((lValue & 0x0000000F) << 4);
            *(PUSHORT)pName = (USHORT)lValue;
            ((PUSHORT)pName)++;

        }

        // verify that the name has the correct format...i.e. it is one or more
        // labels each starting with the length byte for the label and the whole
        // thing terminated with a 0 byte (for the root node name length of zero).
        // count the length of the scope.

        // pHdr should be pointing to the first byte after the half ascii name.
        // (If there is no scope present, then pHdr must be pointing to the NULL byte)
        //
        // Also, check for an overflow on the maximum length of 256 bytes
        if ((STATUS_SUCCESS != (strnlen ((PUCHAR)pHdr, NumBytes-(1+NETBIOS_NAME_SIZE*2), &ScopeLength))) ||
            (ScopeLength > ((MAX_SCOPE_LENGTH+1)-NETBIOS_NAME_SIZE)))
        {
            // the name is too long..probably badly formed
            return(STATUS_UNSUCCESSFUL);
        }

        // Store the address of the start of the scope in the netbios name
        // (if one is present).
        //
        *pScope = (PUCHAR)pHdr;
        *pNameSize = NETBIOS_NAME_SIZE*2 + ScopeLength + 1;  // include the null at the end.
        return(STATUS_SUCCESS);
    }
    else
    {
        return(STATUS_UNSUCCESSFUL);
    }
}


//----------------------------------------------------------------------------
PCHAR
ConvertToHalfAscii(
    OUT PCHAR            pDest,
    IN  PCHAR            pName,
    IN  PCHAR            pScope,
    IN  ULONG            uScopeSize
    )
/*++

Routine Description:

    This routine converts ascii to half ascii and appends the scope on the
    end

Arguments:


Return Value:

    the address of the next byte in the destination after the the name
    has been converted and copied

--*/
{
    LONG     i;

    // the first byte of the name is the length field = 2*16
    *pDest++ = ((UCHAR)NETBIOS_NAME_SIZE << 1);

    // step through name converting ascii to half ascii, for 32 times
    for (i=0; i < NETBIOS_NAME_SIZE ;i++ )
    {
        *pDest++ = ((UCHAR)*pName >> 4) + 'A';
        *pDest++ = (*pName++ & 0x0F) + 'A';
    }
    //
    // put the length of the scope into the next byte followed by the
    // scope itself.  For 1 length scopes (the normal case), writing
    // the zero(for the end of the scope is all that is needed).
    //
    if (uScopeSize > 1)
    {
        CTEMemCopy(pDest,pScope,uScopeSize);
        pDest = pDest + uScopeSize;
    }
    else
    {
        *pDest++ = 0;
    }

    // return the address of the next byte of the destination
    return(pDest);
}


//----------------------------------------------------------------------------
ULONG
Nbt_inet_addr(
    IN  PCHAR            pName,
    IN  ULONG            Flags
    )
/*++

Routine Description:

    This routine converts ascii ipaddr (11.101.4.25) into a ULONG.  This is
    based on the inet_addr code in winsock

Arguments:
    pName   - the string containing the ipaddress

Return Value:

    the ipaddress as a ULONG if it's a valid ipaddress.  Otherwise, 0.

--*/
{

    PCHAR    pStr;
    int      i;
    int      len, fieldLen;
    int      fieldsDone;
    ULONG    IpAddress;
    BYTE     ByteVal;
    PCHAR    pIpPtr;
    BOOLEAN  fDotFound;
    BOOLEAN  fieldOk;


    pStr = pName;
    len = 0;
    pIpPtr = (PCHAR)&IpAddress;
    pIpPtr += 3;                   // so that we store in network order
    fieldsDone=0;

    //
    // the 11.101.4.25 format can be atmost 15 chars, and pName is guaranteed
    // to be at least 16 chars long (how convenient!!).  Convert the string to
    // a ULONG.
    //
    while(len < NETBIOS_NAME_SIZE)
    {
        fieldLen=0;
        fieldOk = FALSE;
        ByteVal = 0;
        fDotFound = FALSE;

        //
        // This loop traverses each of the four fields (max len of each
        // field is 3, plus 1 for the '.'
        //
        while (fieldLen < 4)
        {
            if ((*pStr >='0') && (*pStr <='9'))
            {
                //
                // No Byte value should be greater than 255!
                // Bug#: 10487
                //
                if ((ByteVal > 25) ||
                    ((ByteVal == 25) && (*pStr > '5')))
                {
                    return (0);
                }
                ByteVal = (ByteVal*10) + (*pStr - '0');
                fieldOk = TRUE;
            }
            else if ((*pStr == '.') || (*pStr == ' ') || (*pStr == '\0'))
            {
                *pIpPtr = ByteVal;
                pIpPtr--;
                fieldsDone++;

                if (*pStr == '.')
                {
                    fDotFound = TRUE;
                }
                else    // (*pStr == ' ') || (*pStr == '\0')
                {
                    // if we got a space or 0, assume it's the 4th field
                    break;
                }
            }
            else        // unacceptable char: can't be ipaddr
            {
                return(0);
            }

            pStr++;
            len++;
            fieldLen++;

            // if we found the dot, we are done with this field: go to the next one
            if (fDotFound)
                break;
        }

        // this field wasn't ok (e.g. "11.101..4" or "11.101.4." etc.)
        if (!fieldOk)
        {
            return(0);
        }

        // if we are done with all 4 fields, we are done with the outer loop too
        if ( fieldsDone == 4)
            break;

        if (!fDotFound)
        {
            return(0);
        }
    }

    //
    // make sure the remaining NETBIOS_NAME_SIZE-1 chars are spaces or 0's
    // (i.e. don't allow 11.101.4.25xyz to succeed)
    //
    for (i=len; i<NETBIOS_NAME_SIZE-1; i++, pStr++)
    {
        if (*pStr != ' ' && *pStr != '\0')
        {
            return(0);
        }
    }

    if ((Flags & (SESSION_SETUP_FLAG|REMOTE_ADAPTER_STAT_FLAG)) &&
        (!(IS_UNIQUE_ADDR(IpAddress))))
    {
        KdPrint (("Nbt.Nbt_inet_addr: Address=<%15.15s> is not unique!\n", pName));
        IpAddress = 0;
    }
    return( IpAddress );
}


//----------------------------------------------------------------------------
tDGRAM_SEND_TRACKING *
NbtAllocInitTracker(
    IN  tDGRAM_SEND_TRACKING    *pTracker
    )
/*++

Routine Description:

    This routine allocates memory for several of the structures attached to
    the dgram tracking list, so that this memory does not need to be
    allocated and freed for each send.

Arguments:

    ppListHead  - a ptr to a ptr to the list head

Return Value:

    none

--*/

{
    PLIST_ENTRY             pEntry;
    PTRANSPORT_ADDRESS      pTransportAddr;
    ULONG                   TotalSize;

    TotalSize = sizeof(tDGRAM_SEND_TRACKING)
              + sizeof(TDI_CONNECTION_INFORMATION)
              + sizeof(TRANSPORT_ADDRESS) -1
              + NbtConfig.SizeTransportAddress;
    
    //
    // If not Tracker was provided, then we will have to allocate one!
    //
    if (!pTracker)
    {
        //
        // allocate all the tracker memory as one block and then divy it up later
        // into the various buffers
        //
        if (pTracker = (tDGRAM_SEND_TRACKING *) NbtAllocMem (TotalSize, NBT_TAG2('07')))
        {
            NbtConfig.iCurrentNumBuff[eNBT_DGRAM_TRACKER]++;
        }
    }

    if (pTracker)
    {
        CTEZeroMemory(pTracker,TotalSize);

        pTracker->Verify    = NBT_VERIFY_TRACKER;
        pTracker->RefCount  = 1;
        InitializeListHead (&pTracker->Linkage);
        InitializeListHead (&pTracker->TrackerList);    // Empty the list of trackers linked to this one

        pTracker->pSendInfo = (PTDI_CONNECTION_INFORMATION)((PUCHAR)pTracker + sizeof(tDGRAM_SEND_TRACKING));

        // fill in the connection information - especially the Remote address structure

        pTracker->pSendInfo->RemoteAddressLength = sizeof(TRANSPORT_ADDRESS) -1
                                                   + pNbtGlobConfig->SizeTransportAddress;

        // allocate the remote address structure
        pTransportAddr = (PTRANSPORT_ADDRESS) ((PUCHAR)pTracker->pSendInfo
                                              + sizeof(TDI_CONNECTION_INFORMATION));

        // fill in the remote address
        pTransportAddr->TAAddressCount = 1;
        pTransportAddr->Address[0].AddressLength = NbtConfig.SizeTransportAddress;
        pTransportAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->sin_port = NBT_NAMESERVICE_UDP_PORT;
        ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->in_addr  = 0L;

        // put a ptr to this address structure into the sendinfo structure
        pTracker->pSendInfo->RemoteAddress = (PVOID)pTransportAddr;
    }

    return(pTracker);
}

//----------------------------------------------------------------------------
#define MAX_FREE_TRACKERS   50

ULONG   NumFreeTrackers = 0;

// #if DBG
ULONG   TrackTrackers[NBT_TRACKER_NUM_TRACKER_TYPES];
ULONG   TrackerHighWaterMark[NBT_TRACKER_NUM_TRACKER_TYPES];
// #endif   // DBG


NTSTATUS
GetTracker(
    OUT tDGRAM_SEND_TRACKING    **ppTracker,
    IN  enum eTRACKER_TYPE      TrackerType)
/*++
Routine Description:

    This Routine gets a Tracker data structure to track sending a datagram
    or session packet.

Arguments:

Return Value:

    Status - STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES

--*/

{
    PLIST_ENTRY             pListEntry;
    CTELockHandle           OldIrq;
    tDGRAM_SEND_TRACKING    *pTracker = NULL;
    NTSTATUS                status = STATUS_INSUFFICIENT_RESOURCES;

    CTESpinLock(&NbtConfig,OldIrq);
    if (!IsListEmpty(&NbtConfig.DgramTrackerFreeQ))
    {
        pListEntry = RemoveHeadList(&NbtConfig.DgramTrackerFreeQ);
        pTracker = CONTAINING_RECORD(pListEntry,tDGRAM_SEND_TRACKING,Linkage);
        NumFreeTrackers--;
    }
    else if (NbtConfig.iCurrentNumBuff[eNBT_DGRAM_TRACKER] >= NbtConfig.iMaxNumBuff[eNBT_DGRAM_TRACKER])
    {
        CTESpinFree(&NbtConfig,OldIrq);
        KdPrint(("GetTracker: WARNING:  Tracker leak -- Failing request!\n")) ;
        *ppTracker = NULL;
        return (status);
    }

    if (pTracker = NbtAllocInitTracker (pTracker))
    {
// #if DBG
        pTracker->TrackerType = TrackerType;
        InsertTailList (&UsedTrackers, &pTracker->DebugLinkage);    // keep tracker on a used list for debug

        TrackTrackers[TrackerType]++;
        if (TrackTrackers[TrackerType] > TrackerHighWaterMark[TrackerType])
        {
            TrackerHighWaterMark[TrackerType] = TrackTrackers[TrackerType];
        }
// #endif
        status = STATUS_SUCCESS;
    }

    CTESpinFree(&NbtConfig,OldIrq);

    *ppTracker = pTracker;
    return (status);
}


//----------------------------------------------------------------------------
VOID
FreeTracker(
    IN tDGRAM_SEND_TRACKING     *pTracker,
    IN ULONG                    Actions
    )
/*++

Routine Description:

    This routine cleans up a Tracker block and puts it back on the free
    queue.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    CTELockHandle       OldIrq;
    PLIST_ENTRY         pListEntry;

    CTESpinLock(&NbtConfig,OldIrq);

    //
    CHECK_PTR(pTracker);
    if (!NBT_VERIFY_HANDLE(pTracker, NBT_VERIFY_TRACKER))   // Bad pointer -- don't mess with it!
    {
        CTESpinFree(&NbtConfig,OldIrq);
        DbgPrint("Nbt.FreeTracker:  ERROR!  Bad Tracker ptr @<%p>\n", pTracker);
        ASSERT(0);
        return;
    }

    if (Actions & REMOVE_LIST)
    {
        //
        // unlink the tracker block from the NodeStatus Q
        RemoveEntryList(&pTracker->Linkage);
    }

    if (Actions & FREE_HDR)
    {
        // return the datagram hdr to the free pool
        //
        if (pTracker->SendBuffer.pDgramHdr)
        {
            CTEMemFree((PVOID)pTracker->SendBuffer.pDgramHdr);
        }
        // Free the RemoteName storage
        //
        if (pTracker->pRemoteName)
        {
            CTEMemFree((PVOID)pTracker->pRemoteName);
            pTracker->pRemoteName = NULL;
        }
        if (pTracker->UnicodeRemoteName) {
            CTEMemFree((PVOID)pTracker->UnicodeRemoteName);
            pTracker->UnicodeRemoteName = NULL;
        }
    }

#ifdef MULTIPLE_WINS
    if (pTracker->pFailedIpAddresses)
    {
        CTEMemFree((PVOID)pTracker->pFailedIpAddresses);
        pTracker->pFailedIpAddresses = NULL;
    }
#endif

    if (pTracker->IpList)
    {
        ASSERT(pTracker->NumAddrs);
        CTEMemFree(pTracker->IpList);
    }

    ASSERT (IsListEmpty (&pTracker->TrackerList));
    InitializeListHead(&pTracker->TrackerList);
    InsertTailList (&NbtConfig.DgramTrackerFreeQ, &pTracker->Linkage);

    pTracker->Verify = NBT_VERIFY_TRACKER_DOWN;

// #IF DBG
    TrackTrackers[pTracker->TrackerType]--;
    RemoveEntryList(&pTracker->DebugLinkage);
// #endif // DBG

    if (NumFreeTrackers > MAX_FREE_TRACKERS)
    {
        //
        // We already have the required # of free trackers available
        // in our pool, so just free the oldest Tracker
        //
        pListEntry = RemoveHeadList(&NbtConfig.DgramTrackerFreeQ);
        pTracker = CONTAINING_RECORD(pListEntry,tDGRAM_SEND_TRACKING,Linkage);
        CTEMemFree (pTracker);
        NbtConfig.iCurrentNumBuff[eNBT_DGRAM_TRACKER]--;
    }
    else
    {
        NumFreeTrackers++;
    }

    CTESpinFree(&NbtConfig,OldIrq);
}



//----------------------------------------------------------------------------
NTSTATUS
NbtInitTrackerQ(
    LONG        iNumBuffers
    )

/*++

Routine Description:

    This routine allocates memory blocks for doubly linked lists and links
    them to a list.

Arguments:
    ppListHead  - a ptr to a ptr to the list head to add buffer to
    iNumBuffers - the number of buffers to add to the queue

Return Value:

    none

--*/

{
    int                     i;
    tDGRAM_SEND_TRACKING    *pTracker;

    for (i=0; i<iNumBuffers; i++)
    {
        pTracker = NbtAllocInitTracker (NULL);
        if (!pTracker)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        else
        {
            InsertTailList (&NbtConfig.DgramTrackerFreeQ, &pTracker->Linkage);
            NumFreeTrackers++;
        }
    }

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
#ifndef VXD
NTSTATUS
GetIrp(
    OUT PIRP *ppIrp)
/*++
Routine Description:

    This Routine gets an Irp from the free queue or it allocates another one
    the queue is empty.

Arguments:

Return Value:

    BOOLEAN - TRUE if IRQL is too high

--*/

{
    NTSTATUS        status = STATUS_INSUFFICIENT_RESOURCES;
    CTELockHandle   OldIrq;
    PIRP            pIrp = NULL;

    pIrp = IoAllocateIrp(NbtConfig.MaxIrpStackSize, FALSE);
    if (NULL == pIrp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    CTESpinLock(&NbtConfig,OldIrq);
    *ppIrp = pIrp;
    InsertTailList(&UsedIrps, &(pIrp->ThreadListEntry));
    CTESpinFree(&NbtConfig,OldIrq);

    status = STATUS_SUCCESS;

    return(status);
}

VOID
NbtFreeIrp (
    PIRP    pIrp
    )
{
    CTELockHandle       OldIrq;

    CTESpinLock(&NbtConfig,OldIrq);
    RemoveEntryList(&pIrp->ThreadListEntry);
    CTESpinFree(&NbtConfig,OldIrq);

    //
    // To make I/O manager and driver verifier happy, we need to empty the list
    // entry
    //

    InitializeListHead(&pIrp->ThreadListEntry);
    IoFreeIrp(pIrp);
}
#endif //!VXD

//----------------------------------------------------------------------------
ULONG
CountLocalNames(IN tNBTCONFIG  *pNbtConfig
    )
/*++
Routine Description:

    This Routine counts the number of names in the local name table.

Arguments:

Return Value:

    ULONG  - the number of names

--*/
{
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;
    ULONG           Count;
    tNAMEADDR       *pNameAddr;
    LONG            i;

    Count = 0;

    for (i=0;i < NbtConfig.pLocalHashTbl->lNumBuckets ;i++ )
    {
        pHead = &NbtConfig.pLocalHashTbl->Bucket[i];
        pEntry = pHead;
        while ((pEntry = pEntry->Flink) != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            //
            // don't want unresolved names, or the broadcast name
            //
            if (!(pNameAddr->NameTypeState & STATE_RESOLVING) &&
                (pNameAddr->Name[0] != '*'))
            {
                Count++;
            }
        }
    }

    return(Count);
}
//----------------------------------------------------------------------------
ULONG
CountUpperConnections(
    IN tDEVICECONTEXT  *pDeviceContext
    )
/*++
Routine Description:

    This Routine counts the number of upper connections that have been created
    in preparation for creating an equivalent number of lower connections.


Arguments:

Return Value:

    ULONG  - the number of names

--*/
{
    PLIST_ENTRY     pHead;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pClientHead;
    PLIST_ENTRY     pConnHead;
    PLIST_ENTRY     pClientEntry;
    PLIST_ENTRY     pConnEntry;
    ULONG           CountConnections = 0;
    tADDRESSELE     *pAddressEle;
    tCLIENTELE      *pClient;
    tCONNECTELE     *pConnEle;
    CTELockHandle   OldIrq1, OldIrq2, OldIrq3;

    //
    // Need to hold JointLock before accessing AddressHead!
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    // get the list of addresses for this device
    pHead = &NbtConfig.AddressHead;
    pEntry = pHead->Flink;

    while (pEntry != pHead)
    {
        pAddressEle = CONTAINING_RECORD(pEntry,tADDRESSELE,Linkage);

        //
        // Need to hold pAddressEle lock before accessing ClientHead!
        //
        CTESpinLock(pAddressEle,OldIrq2);

        pClientHead = &pAddressEle->ClientHead;
        pClientEntry = pClientHead->Flink;
        while (pClientEntry != pClientHead)
        {
            pClient = CONTAINING_RECORD(pClientEntry,tCLIENTELE,Linkage);

            //
            // Need to hold pClient lock before accessing ConnectHead!
            //
            CTESpinLock(pClient, OldIrq3);

            pConnHead = &pClient->ConnectHead;
            pConnEntry = pConnHead->Flink;
            while (pConnEntry != pConnHead)
            {
                pConnEle = CONTAINING_RECORD(pConnEntry,tCONNECTELE,Linkage);
                if (pConnEle->pDeviceContext == pDeviceContext)
                {
                    CountConnections++;
                }

                pConnEntry = pConnEntry->Flink;
            }
            CTESpinFree(pClient, OldIrq3);

            pClientEntry = pClientEntry->Flink;
        }
        CTESpinFree(pAddressEle, OldIrq2);

        pEntry = pEntry->Flink;
    }

    CTESpinFree(&NbtConfig.JointLock, OldIrq1);

    return(CountConnections);
}



//----------------------------------------------------------------------------
NTSTATUS
DisableInboundConnections(
    IN   tDEVICECONTEXT *pDeviceContext
    )
/*++

Routine Description:

    This routine checks the devicecontext for open connections and sets
    the  Lower Connection free list to empty.

Arguments:

Return Value:

    none

--*/

{
    CTELockHandle       OldIrqJoint;
    CTELockHandle       OldIrqDevice;
    CTELockHandle       OldIrqConn;
    CTELockHandle       OldIrqLower;
    tLOWERCONNECTION    *pLowerConn;
    NTSTATUS            status;
    PVOID               ConnectContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrqJoint);
    CTESpinLock(pDeviceContext,OldIrqDevice);

    //
    // First take care of the free connections
    //
    while (!IsListEmpty (&pDeviceContext->LowerConnFreeHead))
    {
        pLowerConn = CONTAINING_RECORD (pDeviceContext->LowerConnFreeHead.Flink,tLOWERCONNECTION,Linkage);
        RemoveEntryList (&pLowerConn->Linkage);
        InitializeListHead (&pLowerConn->Linkage);

        //
        // close the lower connection with the transport
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE);
        InterlockedDecrement (&pDeviceContext->NumFreeLowerConnections);
    }
    ASSERT (pDeviceContext->NumFreeLowerConnections == 0);

    //
    // Now go through the list of Inbound connections and cleanup!
    //
    while (!IsListEmpty (&pDeviceContext->WaitingForInbound))
    {
        pLowerConn = CONTAINING_RECORD(pDeviceContext->WaitingForInbound.Flink,tLOWERCONNECTION,Linkage);
        RemoveEntryList (&pLowerConn->Linkage);
        InitializeListHead (&pLowerConn->Linkage);

        SET_STATE_LOWER(pLowerConn, NBT_IDLE);  // so that Inbound doesn't start processing it!
        if (pLowerConn->SpecialAlloc)
        {
            InterlockedDecrement(&pLowerConn->pDeviceContext->NumSpecialLowerConn);
        }

        ASSERT (pLowerConn->RefCount == 2);
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, TRUE); // RefCount will go to 1
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE);// This should close all the Tcp handles
        InterlockedDecrement (&pDeviceContext->NumWaitingForInbound);
    }
    ASSERT (pDeviceContext->NumWaitingForInbound == 0);


    // ******************************************
    // NOTE: The code after this point can probably be deleted
    // because TCP should disconnect all open connections when it
    // is notified of the address change. Just use this code for test.
    //

    //
    // Now go through the list of active Lower connections to see which are
    // still up and issue disconnects on them.
    //
    while (!IsListEmpty (&pDeviceContext->LowerConnection))
    {
        pLowerConn = CONTAINING_RECORD (pDeviceContext->LowerConnection.Flink,tLOWERCONNECTION,Linkage);
        RemoveEntryList (&pLowerConn->Linkage);
        InitializeListHead (&pLowerConn->Linkage);

        NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_DISABLE_INBOUND);

        CTESpinFree(pDeviceContext,OldIrqDevice);
        CTESpinFree(&NbtConfig.JointLock,OldIrqJoint);

        CTESpinLock(pLowerConn,OldIrqLower);

        //
        // In the connecting state the TCP connection is being
        // setup.
        //
        if ((pLowerConn->State == NBT_SESSION_UP) ||
            (pLowerConn->State == NBT_CONNECTING))
        {
            tCLIENTELE  *pClientEle;
            tCONNECTELE *pConnEle;

            if (pLowerConn->State == NBT_CONNECTING)
            {
                // CleanupAfterDisconnect expects this ref count
                // to be 2, meaning that it got connected, so increment
                // here
                NBT_REFERENCE_LOWERCONN(pLowerConn, REF_LOWC_CONNECTED);
            }

            pClientEle = pLowerConn->pUpperConnection->pClientEle;
            pConnEle = pLowerConn->pUpperConnection;
            NBT_DISASSOCIATE_CONNECTION (pConnEle, pLowerConn);
            SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTING);
            SET_STATE_UPPER (pConnEle, NBT_DISCONNECTED);
            SetStateProc(pLowerConn,RejectAnyData);

            CTESpinFree(pLowerConn,OldIrqLower);

            ConnectContext = pConnEle->ConnectContext;
            NBT_DEREFERENCE_CONNECTION (pConnEle, REF_CONN_CONNECT);

            if (pClientEle->evDisconnect)
            {
                status = (*pClientEle->evDisconnect)(pClientEle->DiscEvContext,
                                            ConnectContext,
                                            0,
                                            NULL,
                                            0,
                                            NULL,
                                            TDI_DISCONNECT_ABORT);
            }

            // this should kill of the connection when the irp
            // completes by calling CleanupAfterDisconnect.
            //
#ifndef VXD
            status = DisconnectLower(pLowerConn,
                                     NBT_SESSION_UP,
                                     TDI_DISCONNECT_ABORT,
                                     &DefaultDisconnectTimeout,
                                     TRUE);
#else
            // Vxd can't wait for the disconnect
            status = DisconnectLower(pLowerConn,
                                     NBT_SESSION_UP,
                                     TDI_DISCONNECT_ABORT,
                                     &DefaultDisconnectTimeout,
                                     FALSE);

#endif
        }
        else if (pLowerConn->State == NBT_IDLE)
        {
            tCONNECTELE     *pConnEle;

            CTESpinFree(pLowerConn,OldIrqLower);
            CTESpinLock(&NbtConfig.JointLock,OldIrqJoint);

            if (pConnEle = pLowerConn->pUpperConnection)
            {
                CTESpinLock(pConnEle,OldIrqConn);
                //
                // this makes a best effort to find the connection and
                // and cancel it.  Anything not cancelled will eventually
                // fail with a bad ret code from the transport which is
                // ok too.
                //
                status = CleanupConnectingState(pConnEle,pDeviceContext, &OldIrqConn,&OldIrqLower);
                CTESpinFree(pConnEle,OldIrqConn);
            }
            CTESpinFree(&NbtConfig.JointLock,OldIrqJoint);
        }
        else
        {
            CTESpinFree(pLowerConn,OldIrqLower);
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrqJoint);
        CTESpinLock(pDeviceContext,OldIrqDevice);

        //
        // remove the reference added above when the list was
        // created.
        //
        NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_DISABLE_INBOUND, TRUE);
    }

    CTESpinFree(pDeviceContext,OldIrqDevice);
    CTESpinFree(&NbtConfig.JointLock,OldIrqJoint);

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
ReRegisterLocalNames(
    IN   tDEVICECONTEXT *pDeviceContext,
    IN  BOOLEAN         fSendNameRelease
    )

/*++

Routine Description:

    This routine re-registers names with WINS when DHCP changes the IP
    address.

Arguments:

    pDeviceContext - ptr to the devicecontext

Return Value:

    status

--*/

{
    NTSTATUS                status;
    tTIMERQENTRY            *pTimerEntry;
    CTELockHandle           OldIrq;
    LONG                    i;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pHead1;
    PLIST_ENTRY             pEntry1;
    PLIST_ENTRY             pHead2;
    PLIST_ENTRY             pEntry2;
    tDEVICECONTEXT          *pRelDeviceContext;
    tDEVICECONTEXT          *pSrcIpDeviceContext;
    tNAMEADDR               *pNameAddr;
    tDGRAM_SEND_TRACKING    *pTracker = NULL;
    CTEULONGLONG            ReRegisterMask;
    CTESystemTime           CurrentTime;

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint (("Nbt.ReRegisterLocalNames Called on Device=<%x>...\n",
            pDeviceContext));

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (fSendNameRelease)
    {
        CTEQuerySystemTime (CurrentTime);

        if (((CurrentTime.QuadPart-NbtConfig.LastForcedReleaseTime.QuadPart)
             <= (TWO_MINUTES*10000)) ||                               // Check in 100 nanosec units
            (!(NT_SUCCESS(GetTracker(&pTracker,NBT_TRACKER_RELEASE_REFRESH)))))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint (("Nbt.ReRegisterLocalNames: ERROR: Name Release -- last Release interval=<%d>Secs\n",
                (LONG) ((CurrentTime.QuadPart-NbtConfig.LastForcedReleaseTime.QuadPart)/(1000*10000))));
            return (STATUS_IO_TIMEOUT);
        }

        NbtConfig.LastForcedReleaseTime = CurrentTime;
    }

    if (pTimerEntry = NbtConfig.pRefreshTimer)
    {
        NbtConfig.pRefreshTimer = NULL;
        status = StopTimer(pTimerEntry,NULL,NULL);
    }

    //
    // restart timer and use
    // the initial refresh rate until we can contact the name server
    //
    NbtConfig.MinimumTtl = NbtConfig.InitialRefreshTimeout;
    NbtConfig.RefreshDivisor = REFRESH_DIVISOR;

    //
    // set this to 3 so that refreshBegin will refresh to the primary and
    // then switch to backup on the next refresh interval if it doesn't
    // get through.
    //
    NbtConfig.sTimeoutCount = 3;

    NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
    status = StartTimer(RefreshTimeout,
                        NbtConfig.InitialRefreshTimeout/NbtConfig.RefreshDivisor,
                        NULL,            // context value
                        NULL,            // context2 value
                        NULL,
                        NULL,
                        NULL,           // This is a Global Timer!
                        &pTimerEntry,
                        0,
                        TRUE);

    if ( !NT_SUCCESS( status ) )
    {
        if (pTracker)
        {
            FreeTracker(pTracker, RELINK_TRACKER);
        }
    
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return status ;
    }
    NbtConfig.pRefreshTimer = pTimerEntry;

    //
    // If a Device was specified to ReRegister on, then Zero out only the
    // bit for this Device in the RefreshMask for each name
    // otherwise, ReRegister on all Devices (Zero out all bits!)
    //
    if (pDeviceContext)
    {
        ReRegisterMask = ~pDeviceContext->AdapterMask;    // Only bit for this Device is 0
        pDeviceContext->DeviceRefreshState &= ~NBT_D_REFRESHING_NOW;
    }
    else
    {
        ReRegisterMask = 0;
    }

    for (i=0 ;i < NbtConfig.pLocalHashTbl->lNumBuckets ;i++ )
    {

        pHead = &NbtConfig.pLocalHashTbl->Bucket[i];
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            //
            // set so that nextrefresh finds the name and does a refresh
            //
            if (!(pNameAddr->NameTypeState & STATE_RESOLVED) ||
                (pNameAddr->Name[0] == '*') ||
                (pNameAddr->NameTypeState & NAMETYPE_QUICK))
            {
                pEntry = pEntry->Flink;
                continue;
            }

            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_RELEASE_REFRESH);

            if (fSendNameRelease)
            {
                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.ReRegisterLocalNames: Name=<%16.16s:%x>\n",
                        pNameAddr->Name,pNameAddr->Name[15]));

                pTracker->pNameAddr = pNameAddr;

                //
                // Release this name on all the devices (brute force method)!
                //
                pHead1 = &NbtConfig.DeviceContexts;
                pEntry1 = pHead1->Flink;
                while (pEntry1 != pHead1)
                {
                    pSrcIpDeviceContext = CONTAINING_RECORD(pEntry1,tDEVICECONTEXT,Linkage);
                    if ((pSrcIpDeviceContext->IpAddress == 0) ||
                        (!NBT_REFERENCE_DEVICE (pSrcIpDeviceContext, REF_DEV_REREG, TRUE)))
                    {
                        pEntry1 = pEntry1->Flink;
                        continue;
                    }

                    pHead2 = &NbtConfig.DeviceContexts;
                    pEntry2 = pHead2->Flink;
                    while (pEntry2 != pHead2)
                    {
                        //
                        // See if we need to release on this device
                        //
                        pRelDeviceContext = CONTAINING_RECORD(pEntry2,tDEVICECONTEXT,Linkage);
                        if ((pRelDeviceContext->IpAddress == 0) ||
                            (!NBT_REFERENCE_DEVICE (pRelDeviceContext, REF_DEV_REREG, TRUE)))
                        {
                            pEntry2 = pEntry2->Flink;
                            continue;
                        }

                        //
                        // Send the NameRelease to the Primary and Secondary Wins!
                        //
                        CTESpinFree(&NbtConfig.JointLock,OldIrq);

                        pTracker->pDeviceContext = pRelDeviceContext;
                        pTracker->SendBuffer.pDgramHdr = NULL; // catch erroneous frees
                        pTracker->RemoteIpAddress = pSrcIpDeviceContext->IpAddress;
                        pTracker->TransactionId = 0;

                        // Primary Wins ...
                        pTracker->Flags = NBT_NAME_SERVER | NBT_USE_UNIQUE_ADDR;
                        pTracker->RefCount = 2;
                        status = UdpSendNSBcast(pNameAddr,NbtConfig.pScope,pTracker,
                                    NULL, NULL, NULL, 0, 0, eNAME_RELEASE, TRUE);
                        // Secondary Wins ...
                        pTracker->Flags = NBT_NAME_SERVER_BACKUP | NBT_USE_UNIQUE_ADDR;
                        pTracker->RefCount = 2;
                        status = UdpSendNSBcast(pNameAddr,NbtConfig.pScope,pTracker,
                                    NULL, NULL, NULL, 0, 0, eNAME_RELEASE, TRUE);

                        CTESpinLock(&NbtConfig.JointLock,OldIrq);

                        pEntry2 = pRelDeviceContext->Linkage.Flink;
                        NBT_DEREFERENCE_DEVICE (pRelDeviceContext, REF_DEV_REREG, TRUE);
                    }

                    pEntry1 = pSrcIpDeviceContext->Linkage.Flink;
                    NBT_DEREFERENCE_DEVICE (pSrcIpDeviceContext, REF_DEV_REREG, TRUE);
                }
            }

            pNameAddr->RefreshMask &= ReRegisterMask;
            pNameAddr->Ttl = NbtConfig.InitialRefreshTimeout;

            pEntry = pNameAddr->Linkage.Flink;
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_RELEASE_REFRESH, TRUE);
        }
    }

    if (pTracker)
    {
        FreeTracker(pTracker, RELINK_TRACKER);
    }

    // start a refresh if there isn't one currently going on
    // Note that there is a time window here that if the refresh is
    // currently going on then, some names will not get refreshed with
    // the new IpAddress right away, but have to wait to the next
    // refresh interval.  It seems that this is a rather unlikely
    // scenario and given the low probability of DHCP changing the
    // address it makes even less sense to add the code to handle that
    // case.
    //

    if (NT_SUCCESS(NTQueueToWorkerThread(NULL, DelayedRefreshBegin, NULL, NULL, NULL, NULL, TRUE)))
    {
        NbtConfig.GlobalRefreshState |= NBT_G_REFRESHING_NOW;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
NbtStopRefreshTimer(
    )
{
    tTIMERQENTRY                *pTimerEntry;
    CTELockHandle               OldIrq;

    //
    // Stop the regular Refresh Timer
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pTimerEntry = NbtConfig.pRefreshTimer)
    {
        NbtConfig.pRefreshTimer = NULL;
        StopTimer (pTimerEntry, NULL, NULL);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}


//----------------------------------------------------------------------------
NTSTATUS
strnlen(
    PUCHAR  pSrcString,
    LONG    MaxBufferLength,
    LONG    *pStringLen
    )
{
    LONG    iIndex = 0;

    while ((iIndex < MaxBufferLength-1) && (*pSrcString))
    {
        iIndex++;
        pSrcString++;
    }

    if (*pSrcString)
    {
        *pStringLen = 0;
        return (STATUS_UNSUCCESSFUL);
    }

    *pStringLen = iIndex;
    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\namesrv.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Namesrv.c

Abstract:

    This file contains the name service functions called by other parts of
    the NBT code. (QueryNameOnNet, FindName, RegisterName).  It also contains
    the completion routines for the timeouts associated with these functions.

    The pScope values that are passed around from one routine to the next
    point to the scope string for the name.  If there is no scope then the
    pScope ptr points at a single character '\0' - signifying a string of
    zero length.  Therefore the check for scope is "if (*pScope != 0)"

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"
#include "namesrv.tmh"

//
// function prototypes for completion routines that are local to this file
//
NTSTATUS
AddToPendingList(
    IN  PCHAR                   pName,
    OUT tNAMEADDR               **ppNameAddr
    );

VOID
MSnodeCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
MSnodeRegCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
SetWinsDownFlag(
    tDEVICECONTEXT  *pDeviceContext
    );

VOID
ReleaseCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

VOID
NextRefresh(
    IN  PVOID     pNameAdd,
    IN  NTSTATUS  status
    );

VOID
GetNextName(
    IN      tNAMEADDR   *pNameAddrIn,
    OUT     tNAMEADDR   **ppNameAddr
    );

NTSTATUS
StartRefresh(
    IN  tNAMEADDR               *pNameAddr,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  CTELockHandle           *pJointLockOldIrq,
    IN  BOOLEAN                 ResetDevice
    );

VOID
NextKeepAlive(
    IN  tDGRAM_SEND_TRACKING     *pTracker,
    IN  NTSTATUS                 statuss,
    IN  ULONG                    Info
    );

VOID
GetNextKeepAlive(
    tDEVICECONTEXT          *pDeviceContext,
    tDEVICECONTEXT          **ppDeviceContextOut,
    tLOWERCONNECTION        *pLowerConnIn,
    tLOWERCONNECTION        **ppLowerConnOut,
    tDGRAM_SEND_TRACKING    *pTracker
    );

VOID
WinsDownTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

BOOL
AppropriateNodeType(
	IN PCHAR pName,
	IN ULONG NodeType
	);

BOOL
IsBrowserName(
	IN PCHAR pName
	);

#if DBG
unsigned char  Buff[256];
unsigned char  Loc;
#endif

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, DelayedSessionKeepAlive)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
NTSTATUS
AddToPendingList(
    IN  PCHAR                   pName,
    OUT tNAMEADDR               **ppNameAddr
    )
/*++
Routine Description:

    This routine Adds a name query request to the PendingNameQuery list.

Arguments:


Return Value:

    The function value is the status of the operation.


--*/
{
    tNAMEADDR   *pNameAddr;

    ASSERT(NbtConfig.lNumPendingNameQueries >= 0);

    if (NbtConfig.lNumPendingNameQueries > NbtConfig.lMaxNumPendingNameQueries) {

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pNameAddr = NbtAllocMem(sizeof(tNAMEADDR),NBT_TAG('R'));
    if (pNameAddr)
    {
        CTEZeroMemory(pNameAddr,sizeof(tNAMEADDR));

        CTEMemCopy(pNameAddr->Name,pName,NETBIOS_NAME_SIZE);
        pNameAddr->NameTypeState = STATE_RESOLVING | NBT_UNIQUE;
        pNameAddr->Verify = REMOTE_NAME;
        pNameAddr->TimeOutCount  = NbtConfig.RemoteTimeoutCount;
        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_ON_NET);

        InsertTailList(&NbtConfig.PendingNameQueries, &pNameAddr->Linkage);
        InterlockedIncrement(&NbtConfig.lNumPendingNameQueries);

        *ppNameAddr = pNameAddr;
        return(STATUS_SUCCESS);
    }
    else
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
QueryNameOnNet(
    IN  PCHAR                   pName,
    IN  PCHAR                   pScope,
    IN  USHORT                  uType,
    IN  tDGRAM_SEND_TRACKING    *pTrackerClientContext,
    IN  PVOID                   pClientCompletion,
    IN  ULONG                   LocalNodeType,
    IN  tNAMEADDR               *pNameAddrIn,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  CTELockHandle           *pJointLockOldIrq
    )
/*++

Routine Description:

    This routine attempts to resolve a name on the network either by a
    broadcast or by talking to the NS depending on the type of node. (M,P or B)

Arguments:


Return Value:

    The function value is the status of the operation.

Called By: ProxyQueryFromNet() in proxy.c,   NbtConnect() in name.c

--*/

{
    ULONG                Timeout;
    USHORT               Retries;
    NTSTATUS             status;
    PVOID                pCompletionRoutine;
    tDGRAM_SEND_TRACKING *pTrackerQueryNet;
    tNAMEADDR            *pNameAddr;
    LPVOID               pContext2 = NULL;
    CHAR				 cNameType = pName[NETBIOS_NAME_SIZE-1];
    BOOL				 SendFlag = TRUE;
    LONG                 IpAddr = 0;
    ULONG                Flags;

    status = GetTracker(&pTrackerQueryNet, NBT_TRACKER_QUERY_NET);
    if (!NT_SUCCESS(status))
    {
        return(status);
    }

    if (pTrackerClientContext)  // This will be NULL for Proxy requests
    {
        pTrackerClientContext->pTrackerWorker = pTrackerQueryNet;
    }

    //
    // put the name in the remote cache to keep track of it while it resolves...
    //
    pNameAddr = NULL;
    if (!pNameAddrIn)
    {
        status = AddToPendingList(pName,&pNameAddr);

        if (!NT_SUCCESS(status))
        {
            FreeTracker(pTrackerQueryNet,RELINK_TRACKER);
            return(status);
        }

        // fill in the record with the name and IpAddress
        pNameAddr->NameTypeState = (uType == NBT_UNIQUE) ? NAMETYPE_UNIQUE : NAMETYPE_GROUP;
    }
    else
    {
        status = STATUS_SUCCESS;
        pNameAddr = pNameAddrIn;
        pNameAddr->RefCount = 1;
    }

    CHECK_PTR(pNameAddr);
    pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
    pNameAddr->NameTypeState |= STATE_RESOLVING;
    pNameAddr->Ttl            = NbtConfig.RemoteHashTtl;
    //
    // put a pointer to the tracker here so that other clients attempting to
    // query the same name at the same time can tack their trackers onto
    // the end of this one. - i.e. This is the tracker for the
    // datagram send, or connect, not the name query.
    //
    pNameAddr->pTracker = pTrackerClientContext;
    pNameAddr->pTimer = NULL;

#ifdef PROXY_NODE
    //
    // If the node type is PROXY, it means that the request is being sent
    // as a result of hearing a name registration or a name query on the net.
    //
    // If the node type is not == PROXY (i.e. it is MSNODE | PROXY,
    // PNODE | PROXY, MSNODE, PNODE, etc, then the request is being sent as
    // a result of a client request
    //
    // Refer: RegOrQueryFromNet in Proxy.c
    //
    //  This field is used in QueryFromNet() to determine whether or not
    //  to revert to Broadcast
    //
#endif
    if(LocalNodeType & PROXY)
    {
        pNameAddr->ProxyReqType = (LocalNodeType & PROXY_REG)? NAMEREQ_PROXY_REGISTRATION: NAMEREQ_PROXY_QUERY;
        LocalNodeType &= (~PROXY_REG);    // Turn it off for safe
    }
    else
    {
        pNameAddr->ProxyReqType = NAMEREQ_REGULAR;
		LocalNodeType = AppropriateNodeType( pName, LocalNodeType );
	}

    // keep a ptr to the Ascii name so that we can remove the name from the
    // hash table later if the query fails.
    CHECK_PTR(pTrackerQueryNet);
    pTrackerQueryNet->pNameAddr = pNameAddr;
    pTrackerQueryNet->SendBuffer.pDgramHdr = NULL;     // set to NULL to catch any erroneous frees.
    pTrackerQueryNet->pDeviceContext = pDeviceContext;
    //
    // set the ref count high enough so that a pdu from the wire cannot
    // free the tracker while UdpSendNsBcast is running - i.e. between starting
    // the timer and actually sending the datagram.
    //
    pTrackerQueryNet->RefCount = 2;
#ifdef MULTIPLE_WINS
    // Set the info for the Extra Name Servers (in addition to Pri & Sec WINs)
    pTrackerQueryNet->NSOthersLeft = pDeviceContext->lNumOtherServers;
    pTrackerQueryNet->NSOthersIndex = pDeviceContext->lLastResponsive;
#endif

    //
    // Set a few values as a precursor to registering the name either by
    // broadcast or with the name server
    //
#ifdef PROXY_NODE
    IF_PROXY(LocalNodeType)
    {
        pCompletionRoutine      = ProxyTimerComplFn;
        pContext2               = pTrackerClientContext;
        pTrackerClientContext   = NULL;

        if  ((pDeviceContext->lNameServerAddress == LOOP_BACK) ||
                pDeviceContext->WinsIsDown) {
            Retries = pNbtGlobConfig->uNumBcasts;
            Timeout = (ULONG)pNbtGlobConfig->uBcastTimeout;
            pTrackerQueryNet->Flags = NBT_BROADCAST;
        } else {
            Retries = (USHORT)pNbtGlobConfig->uNumRetries;
            Timeout = (ULONG)pNbtGlobConfig->uRetryTimeout;
            pTrackerQueryNet->Flags = NBT_NAME_SERVER;
        }
    }
    else
#endif
    if (NbtConfig.UseDnsOnly)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint (("Nbt.QueryNameOnNet: Shorting out Query path to do DNS only for %16.16s<%X>\n",
                pName,pName[15]));

        //
        // Short out query over wire
        //
        Retries = 1;
        Timeout = 10;
        SendFlag = FALSE;
        pCompletionRoutine = MSnodeCompletion;

        //
        // For BNODE or MSNODE, the last stage is Broadcast
        //
        if (LocalNodeType & (BNODE | MSNODE))
        {
            pTrackerQueryNet->Flags = NBT_BROADCAST;
        }
        //
        // For PNODE or MNODE, the last stage is Secondary Wins server
        //
        else
        {
            pTrackerQueryNet->Flags = NBT_NAME_SERVER_BACKUP;
        }

        pTrackerClientContext->ResolutionContextFlags = 0xff;
    }
    else if ((pTrackerClientContext->pFailedIpAddresses) &&
             (pTrackerClientContext->ResolutionContextFlags))
    {
        //
        // We are reattempting the query after the previous attempt failed!
        //
        pTrackerQueryNet->Flags            = pTrackerClientContext->ResolutionContextFlags;
        pTrackerQueryNet->NSOthersIndex    = pTrackerClientContext->NSOthersIndex;
        pTrackerQueryNet->NSOthersLeft     = pTrackerClientContext->NSOthersLeft;

        //
        // Set the Retries to 1 by default so that we can immediately proceed
        // to the next stage in the querying process
        //
        Retries = 1;
        Timeout = 10;
        SendFlag = FALSE;
        pCompletionRoutine = MSnodeCompletion;
    }
    else
    {
        Retries = pNbtGlobConfig->uNumRetries;
        Timeout = (ULONG)pNbtGlobConfig->uRetryTimeout;
        pCompletionRoutine = MSnodeCompletion;
        pTrackerQueryNet->Flags = NBT_NAME_SERVER;

        // use broadcast if no name server address for MSNODE or Wins down,
        // or it is Bnode,Mnode.
        // for Pnode, just allow it to do the name query on the loop back
        // address
        //
        if ((LocalNodeType & (MNODE | BNODE)) ||
            ((LocalNodeType & MSNODE) &&
            ((pDeviceContext->lNameServerAddress == LOOP_BACK) ||
              pDeviceContext->WinsIsDown)))
        {
            Retries = pNbtGlobConfig->uNumBcasts;
            Timeout = (ULONG)pNbtGlobConfig->uBcastTimeout;
            pTrackerQueryNet->Flags = NBT_BROADCAST;
        }
        else if ((pDeviceContext->lNameServerAddress == LOOP_BACK) ||
                 (pDeviceContext->WinsIsDown))
        {
            //
            // short out timeout when no wins server configured -for PNODE
            //
            Retries = 1;
            Timeout = 10;
            pTrackerQueryNet->Flags = NBT_NAME_SERVER_BACKUP;
        }

        //
        // no sense doing a name query out an adapter with no Ip address
        //
        if (pTrackerClientContext)
        {
            Flags = pTrackerClientContext->Flags;
        }
        else
        {
            Flags = 0;
        }

        if ((pDeviceContext->IpAddress == 0) || (IpAddr = Nbt_inet_addr(pName, Flags)))
        {
            Retries = 1;
            Timeout = 10;
            pTrackerQueryNet->Flags = NBT_BROADCAST;
			SendFlag = FALSE;
            if (LocalNodeType & (PNODE | MNODE))
            {
                pTrackerQueryNet->Flags = NBT_NAME_SERVER_BACKUP;
            }
        }
    }

    CTESpinFree(&NbtConfig.JointLock,*pJointLockOldIrq);


    // do a name query... will always return status pending...
    // the pNameAddr structure cannot get deleted out from under us since
    // only a timeout on the send (3 retries) will remove the name.  Any
    // response from the net will tend to keep the name (change state to Resolved)
    //

    //
    // Bug: 22542 - prevent broadcast of remote adapter status on net view of limited subnet b'cast address.
    // In order to test for subnet broadcasts, we need to match against the subnet masks of all adapters. This
    // is expensive and not done.
    // Just check for the limited bcast.
    //
    if (IpAddr == 0xffffffff)
    {
        KdPrint(("Nbt.QueryNameOnNet: Query on Limited broadcast - failed\n"));
        status = STATUS_BAD_NETWORK_PATH;
    }
    else
    {
        status = UdpSendNSBcast(pNameAddr,
                                pScope,
                                pTrackerQueryNet,
                                pCompletionRoutine,
                                pTrackerClientContext,
                                pClientCompletion,
                                Retries,
                                Timeout,
                                eNAME_QUERY,
                                SendFlag);
        if (!NT_SUCCESS(status)) {
            NbtTrace(NBT_TRACE_NAMESRV, ("UdpSendNSBcast return %!status! for %!NBTNAME!<%02x>",
                status, pNameAddr->Name, (unsigned)pNameAddr->Name[15]));
        }
    }

    // a successful send means, Don't complete the Irp.  Status Pending is
    // returned to ntisol.c to tell that code not to complete the irp. The
    // irp will be completed when this send either times out or a response
    // is heard.  In the event of an error in the send, allow that return
    // code to propagate back and result in completing the irp - i.e. if
    // there isn't enough memory to allocate a buffer or some such thing
    //
    CTESpinLock(&NbtConfig.JointLock,*pJointLockOldIrq);
    NBT_DEREFERENCE_TRACKER (pTrackerQueryNet, TRUE);

    if (NT_SUCCESS(status))
    {
        LOCATION(0x49);

        // this return must be here to avoid freeing the tracker below.
        status = STATUS_PENDING;
    }
    else
    {
        LOCATION(0x50);

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.QueryNameOnNet: Query failed - bad retcode from UdpSendNsBcast = %X\n", status));

        //
        // UdpSendNsBcast should not fail AND start the timer, therefore there
        // is no need to worry about stopping the timer here.
        //
        CHECK_PTR(pNameAddr);
        pNameAddr->pTimer = NULL;
        if (pTrackerClientContext)
        {
            pTrackerClientContext->pTrackerWorker = NULL;
        }

        //
        // This will free the tracker
        //
        NBT_DEREFERENCE_TRACKER (pTrackerQueryNet, TRUE);
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        InterlockedDecrement(&NbtConfig.lNumPendingNameQueries);
    }

    return(status);
}


#ifdef MULTIPLE_WINS
//----------------------------------------------------------------------------
NTSTATUS
ContinueQueryNameOnNet(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PUCHAR                  pName,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  PVOID                   QueryCompletion,
    IN OUT BOOLEAN              *pfNameReferenced
    )
/*++

Routine Description

    This routine handles re-querying a name on the network.

Arguments:


Return Values:

    NTSTATUS - status of the request

--*/
{
    CTELockHandle           OldIrq2;
    ULONG                   lNameType;
    NTSTATUS                status;
    tNAMEADDR               *pNameAddr;
    tIPADDRESS              IpAddress;

    ASSERT (!IsDeviceNetbiosless(pDeviceContext));

    CTESpinLock(&NbtConfig.JointLock,OldIrq2);

    //
    // Name and Tracker should be currently Referenced!
    //
    ASSERT (NBT_VERIFY_HANDLE (pTracker, NBT_VERIFY_TRACKER));
    ASSERT (NBT_VERIFY_HANDLE2(pTracker->pNameAddr, LOCAL_NAME, REMOTE_NAME));

    //
    // If no one else is referencing the name, then delete it from
    // the hash table.
    //
    pTracker->pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
    pTracker->pNameAddr->NameTypeState |= STATE_RELEASED;
    if ((pTracker->pNameAddr->Verify == REMOTE_NAME) &&
        (pTracker->pNameAddr->NameTypeState & STATE_RESOLVED) &&
        (pTracker->pNameAddr->RefCount == 2))
    {
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_REMOTE, TRUE);
    }
    NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_CONNECT, TRUE);
    pTracker->pNameAddr = NULL;
    *pfNameReferenced = FALSE;

    //
    // no sense re-doing a name query if:
    //  the request has been cancelled, or
    //  adapter has no Ip address, or
    //  the name given is itself an IP address!
    //  the previous query had finished querying all the WINS servers
    //
    if ((pTracker->Flags & TRACKER_CANCELLED) ||
        (!pDeviceContext->IpAddress) ||
        (Nbt_inet_addr(pName, SESSION_SETUP_FLAG)) ||
        (pTracker->ResolutionContextFlags == 0xff))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
        return (STATUS_BAD_NETWORK_PATH);
    }

    //
    // Save the last Ip address we tried as bad!
    //
    if (!pTracker->pFailedIpAddresses)
    {
        if (!(pTracker->pFailedIpAddresses =
                    NbtAllocMem ((MAX_FAILED_IP_ADDRESSES) * sizeof(tIPADDRESS), NBT_TAG2('04'))))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq2);
            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        CTEZeroMemory(pTracker->pFailedIpAddresses,(MAX_FAILED_IP_ADDRESSES) * sizeof(tIPADDRESS));
    }
    pTracker->pFailedIpAddresses[pTracker->LastFailedIpIndex] = pTracker->RemoteIpAddress;
    pTracker->LastFailedIpIndex = (pTracker->LastFailedIpIndex+1) % MAX_FAILED_IP_ADDRESSES;

    // check the Remote table to see if the name has been resolved
    // by someone else
    //
    if ((pNameAddr = FindNameRemoteThenLocal(pTracker, &IpAddress, &lNameType)) &&
        (IpAddress) &&
        (pNameAddr->NameTypeState & STATE_RESOLVED) &&
        (IpAddress != pTracker->RemoteIpAddress))
    {
        //
        // We have another address to try!
        //
        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_CONNECT);
        *pfNameReferenced = TRUE;
        pNameAddr->TimeOutCount = NbtConfig.RemoteTimeoutCount;
        pTracker->pNameAddr = pNameAddr;

        // set the session state to NBT_CONNECTING
        CHECK_PTR(pTracker->pConnEle);
        SET_STATE_UPPER (pTracker->pConnEle, NBT_CONNECTING);
        pTracker->pConnEle->BytesRcvd = 0;;
        pTracker->pConnEle->ReceiveIndicated = 0;
        // keep track of the other end's ip address
        pTracker->pConnEle->pLowerConnId->SrcIpAddr = htonl(IpAddress);
        SET_STATE_LOWER (pTracker->pConnEle->pLowerConnId, NBT_CONNECTING);
        pTracker->pTrackerWorker = NULL;

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtConnectCommon: Setting Up Session(cached entry!!) to %16.16s <%X>\n",
                pNameAddr->Name,pNameAddr->Name[15]));

        CTESpinFree(&NbtConfig.JointLock,OldIrq2);

        //
        // Now, setup the Tcp connection
        //
        status = TcpSessionStart (pTracker,
                                  IpAddress,
                                  (tDEVICECONTEXT *)pTracker->pDeviceContext,
                                  SessionStartupContinue,
                                  pTracker->DestPort);
    }
    else
    {
        status = QueryNameOnNet (pName,
                                 NbtConfig.pScope,
                                 NBT_UNIQUE,
                                 pTracker,
                                 QueryCompletion,
                                 NodeType & NODE_MASK,
                                 NULL,
                                 pDeviceContext,
                                 &OldIrq2);

        CTESpinFree(&NbtConfig.JointLock,OldIrq2);
    }

    return (status);
}
#endif


//----------------------------------------------------------------------------
VOID
MSnodeCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine is called by the timer code when the timer expires. It must
    decide if another name query should be done, and if not, then it calls the
    client's completion routine (in completion2).
    This routine handles the broadcast portion of the name queries (i.e.
    those name queries that go out as broadcasts).

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS                 status;
    tDGRAM_SEND_TRACKING     *pTracker;
    CTELockHandle            OldIrq;
    COMPLETIONCLIENT         pClientCompletion;
    ULONG                    Flags;
    tDGRAM_SEND_TRACKING    *pClientTracker;
	ULONG					LocalNodeType;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
	LocalNodeType = AppropriateNodeType( pTracker->pNameAddr->Name, NodeType );

    //
    // check if the client completion routine is still set.  If not then the
    // timer has been cancelled and this routine should just clean up its
    // buffers associated with the tracker.
    //
    if (!pTimerQEntry)
    {
        // return the tracker block to its queue
        pTracker->pNameAddr->pTimer = NULL;
        InterlockedDecrement(&NbtConfig.lNumPendingNameQueries);
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
        return;
    }


    //
    // to prevent a client from stopping the timer and deleting the
    // pNameAddr, grab the lock and check if the timer has been stopped
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    ASSERT (NBT_VERIFY_HANDLE (pTracker->pNameAddr, REMOTE_NAME));

    //
    // StopTimer could have been called before we acquired the lock, so
    // check for this
    // Bug#: 229616
    //
    if (!pTimerQEntry->ClientCompletion)
    {
        pTracker->pNameAddr->pTimer = NULL;
        InterlockedDecrement(&NbtConfig.lNumPendingNameQueries);
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        return;
    }

    if (pTimerQEntry->Flags & TIMER_RETIMED)
    {
        pTimerQEntry->Flags &= ~TIMER_RETIMED;
        pTimerQEntry->Flags |= TIMER_RESTART;
        //
        // if we are not bound to this card than use a very short timeout
        //
        if (!pTracker->pDeviceContext->IpAddress)
        {
            pTimerQEntry->DeltaTime = 10;
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    pClientTracker = (tDGRAM_SEND_TRACKING *)pTimerQEntry->ClientContext;

    //
    // if the tracker has been cancelled, don't do any more queries
    //
    if (pClientTracker->Flags & TRACKER_CANCELLED)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.MSnodeCompletion: tracker flag cancelled\n"));

        //
        // In case the timer has been stopped, we coordinate
        // through the pClientCompletionRoutine Value with StopTimer.
        //
        pClientCompletion = pTimerQEntry->ClientCompletion;

        //
        // remove from the PendingNameQueries list
        //
        RemoveEntryList(&pTracker->pNameAddr->Linkage);
        InitializeListHead(&pTracker->pNameAddr->Linkage);

        // remove the link from the name table to this timer block
        CHECK_PTR(((tNAMEADDR *)pTimerQEntry->pCacheEntry));
        ((tNAMEADDR *)pTimerQEntry->pCacheEntry)->pTimer = NULL;
        //
        // to synch. with the StopTimer routine, Null the client completion
        // routine so it gets called just once.
        //
        CHECK_PTR(pTimerQEntry);
        pTimerQEntry->ClientCompletion = NULL;

        //
        // remove the name from the hash table, since it did not
        // resolve
        //
        CHECK_PTR(pTracker->pNameAddr);
        pTracker->pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
        pTracker->pNameAddr->NameTypeState |= STATE_RELEASED;
        pTracker->pNameAddr->pTimer = NULL;

        InterlockedDecrement(&NbtConfig.lNumPendingNameQueries);
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        pTracker->pNameAddr = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        // there can be a list of trackers Q'd up on this name
        // query, so we must complete all of them!
        //
        CompleteClientReq(pClientCompletion, pClientTracker, STATUS_CANCELLED);

        // return the tracker block to its queue
        LOCATION(0x51);
        NBT_DEREFERENCE_TRACKER(pTracker, FALSE);

        return;
    }

    // if number of retries is not zero then continue trying to contact the
    // Name Server.
    //
    if (!(--pTimerQEntry->Retries))
    {

        // set the retry count again
        //
        pTimerQEntry->Retries = NbtConfig.uNumRetries;
        Flags = pTracker->Flags;
        pTracker->Flags &= ~(NBT_NAME_SERVER_BACKUP
#ifdef MULTIPLE_WINS
                                | NBT_NAME_SERVER_OTHERS
#endif
                                | NBT_NAME_SERVER
                                | NBT_BROADCAST);

        if ((Flags & NBT_BROADCAST) && (LocalNodeType & MNODE) &&
            (pTracker->pDeviceContext->lNameServerAddress != LOOP_BACK) &&
            !pTracker->pDeviceContext->WinsIsDown)
        {
            LOCATION(0x44);
                // *** MNODE ONLY ***
            //
            // Can't Resolve through broadcast, so try the name server
            //
            pTracker->Flags |= NBT_NAME_SERVER;

            // set a different timeout for name resolution through WINS
            //
            pTimerQEntry->DeltaTime = NbtConfig.uRetryTimeout;

        }
        else if ((Flags & NBT_NAME_SERVER) && !(LocalNodeType & BNODE))
        {
            LOCATION(0x47);
                // *** NOT BNODE ***
            //
            // Can't reach the name server, so try the backup
            //
            pTracker->Flags |= NBT_NAME_SERVER_BACKUP;
            //
            // short out the timeout if no backup name server
            //
            if ((pTracker->pDeviceContext->lBackupServer == LOOP_BACK) ||
                pTracker->pDeviceContext->WinsIsDown)
            {
                pTimerQEntry->Retries = 1;
                pTimerQEntry->DeltaTime = 10;

            }

        }
#ifdef MULTIPLE_WINS
        else if ((Flags & NBT_NAME_SERVER_BACKUP) && !(LocalNodeType & BNODE))
        {
            //
            // Main backup and possibly some of the "others" have
            // failed, see if there are any (more) "others" left
            //
            USHORT  Index = pTracker->NSOthersIndex;
            USHORT  NumBackups = pTracker->pDeviceContext->lNumOtherServers;

            pTracker->Flags |= NBT_NAME_SERVER_OTHERS;

            if (Flags & NBT_NAME_SERVER_OTHERS)  // not 1st time here
            {                                   // so, move to next server
                pTracker->NSOthersLeft--;
                if (Index >= NumBackups-1)
                {
                    Index = 0;
                }
                else
                {
                    Index++;
                }
            }

            while ((pTracker->NSOthersLeft > 0) &&
                   (LOOP_BACK == pTracker->pDeviceContext->lOtherServers[Index]))
            {
                pTracker->NSOthersLeft--;
                if (Index >= NumBackups-1)
                {
                    Index = 0;
                }
                else
                {
                    Index++;
                }
            }
            pTracker->NSOthersIndex = Index;

            //
            // short out the timeout if we did not find any "other" name servers
            //
            if (0 == pTracker->NSOthersLeft)        // UdpSendNSBcast will do LOOP_BACK
            {
                pTimerQEntry->Retries = 1;
                pTimerQEntry->DeltaTime = 10;
            }
            else
            {
                pTracker->Flags |= NBT_NAME_SERVER_BACKUP;  // Try next "other" server on timeout
            }
        }
        else if ((Flags & NBT_NAME_SERVER_OTHERS)
#else
        else if ((Flags & NBT_NAME_SERVER_BACKUP)
#endif
             && (LocalNodeType & MSNODE))
        {
            LOCATION(0x46);
                // *** MSNODE ONLY ***
            //
            // Can't reach the name server(s), so try broadcast name queries
            //
            pTracker->Flags |= NBT_BROADCAST;

            // set a different timeout for broadcast name resolution
            //
            pTimerQEntry->DeltaTime = NbtConfig.uBcastTimeout;
            pTimerQEntry->Retries = NbtConfig.uNumBcasts;

            //
            // Set the WinsIsDown Flag and start a timer so we don't
            // try wins again for 15 seconds or so...only if we failed
            // to reach WINS, rather than WINS returning a neg response.
            //
            if (!(Flags & WINS_NEG_RESPONSE))
            {
                SetWinsDownFlag(pTracker->pDeviceContext);
            }
        }
        else
        {
            BOOLEAN    bFound = FALSE;
            LOCATION(0x45);

#ifdef MULTIPLE_WINS
            // Signal termination of WINs server queries
            pTracker->ResolutionContextFlags = NAME_RESOLUTION_DONE;
#endif
            //
            // see if the name is in the lmhosts file, if it ISN'T the
            // proxy making the name query request!!
            //
            status = STATUS_UNSUCCESSFUL;

            //
            // In case the timer has been stopped, we coordinate
            // through the pClientCompletionRoutine Value with StopTimer.
            //
            pClientCompletion = pTimerQEntry->ClientCompletion;
            //
            // the timeout has expired on the broadcast name resolution
            // so call the client
            //

            //
            // remove from the PendingNameQueries list
            //
            RemoveEntryList(&pTracker->pNameAddr->Linkage);
            InitializeListHead(&pTracker->pNameAddr->Linkage);

            // remove the link from the name table to this timer block
            CHECK_PTR(((tNAMEADDR *)pTimerQEntry->pCacheEntry));
            ((tNAMEADDR *)pTimerQEntry->pCacheEntry)->pTimer = NULL;
            //
            // to synch. with the StopTimer routine, Null the client completion
            // routine so it gets called just once.
            //
            CHECK_PTR(pTimerQEntry);
            pTimerQEntry->ClientCompletion = NULL;

            if (((NbtConfig.EnableLmHosts) ||
                 (NbtConfig.ResolveWithDns && !(pTracker->Flags & NO_DNS_RESOLUTION_FLAG))) &&
                (pTracker->pNameAddr->ProxyReqType == NAMEREQ_REGULAR))
            {
                // only do this if the client completion routine has not
                // been run yet.
                //
                if (pClientCompletion)
                {
                    status = LmHostQueueRequest(pTracker,
                                                pTimerQEntry->ClientContext,
                                                pClientCompletion,
                                                pTracker->pDeviceContext);
                }
            }

            CHECK_PTR(pTimerQEntry);
            CHECK_PTR(pTimerQEntry->pCacheEntry);
            if (NT_SUCCESS(status))
            {
                // if it is successfully queued to the Worker thread,
                // then Null the ClientCompletion routine in the timerQ
                // structure, letting
                // the worker thread handle the rest of the name query
                // resolution.  Also null the timer ptr in the
                // nameAddr entry in the name table.
                //
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
            }
            else
            {
                //
                // remove the name from the hash table, since it did not
                // resolve
                //
                CHECK_PTR(pTracker->pNameAddr);
                pTracker->pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
                pTracker->pNameAddr->NameTypeState |= STATE_RELEASED;
                pTracker->pNameAddr->pTimer = NULL;

                InterlockedDecrement(&NbtConfig.lNumPendingNameQueries);
                NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
                pTracker->pNameAddr = NULL;

                pClientTracker = (tDGRAM_SEND_TRACKING *)pTimerQEntry->ClientContext;
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                // there can be a list of trackers Q'd up on this name
                // query, so we must complete all of them!
                //
                CompleteClientReq(pClientCompletion, pClientTracker, STATUS_TIMEOUT);

                // return the tracker block to its queue
                LOCATION(0x51);
                NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
            }

            return;
        }
    }

    LOCATION(0x48);
    NBT_REFERENCE_TRACKER(pTracker);
    pTimerQEntry->Flags |= TIMER_RESTART;

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    status = UdpSendNSBcast(pTracker->pNameAddr,
                            NbtConfig.pScope,
                            pTracker,
                            NULL,NULL,NULL,
                            0,0,
                            eNAME_QUERY,
                            TRUE);

    NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
}

//----------------------------------------------------------------------------
VOID
SetWinsDownFlag(
    tDEVICECONTEXT  *pDeviceContext
    )
/*++

Routine Description:

    This routine sets the WinsIsDown flag if its not already set and
    its not a Bnode.  It starts a 15 second or so timer that un sets the
    flag when it expires.

    This routine must be called while holding the Joint Lock.

Arguments:

    None

Return Value:
    None

--*/
{
    NTSTATUS     status;
    tTIMERQENTRY *pTimer;

    if ((!pDeviceContext->WinsIsDown) && !(NodeType & BNODE))
    {
        status = StartTimer(WinsDownTimeout,
                            NbtConfig.WinsDownTimeout,
                            pDeviceContext,       // context value
                            NULL,
                            NULL,
                            NULL,
                            pDeviceContext,
                            &pTimer,
                            1,          // retries
                            TRUE);

        if (NT_SUCCESS(status))
        {
           pDeviceContext->WinsIsDown = TRUE;
        }
    }
}

//----------------------------------------------------------------------------
VOID
WinsDownTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine is called by the timer code when the timer expires.
    It just sets the WinsIsDown boolean to False so that we will try WINS
    again.  In this way we will avoid talking to WINS during this timeout.


Arguments:


Return Value:


--*/
{
    tDEVICECONTEXT  *pDeviceContext = (tDEVICECONTEXT *)pContext;
    CTELockHandle   OldIrq;

    if (!pTimerQEntry)
    {
        return;
    }

    //
    // Hold the Joint Lock while traversing the list of devices
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (IsEntryInList (&pDeviceContext->Linkage, &NbtConfig.DeviceContexts))
    {
        pDeviceContext->WinsIsDown = FALSE;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    IF_DBG(NBT_DEBUG_NAMESRV)
        KdPrint(("Nbt.WinsDownTimeout: WINS DOWN Timed Out - Up again\n"));
}


//----------------------------------------------------------------------------
VOID
CompleteClientReq(
    COMPLETIONCLIENT        pClientCompletion,
    tDGRAM_SEND_TRACKING    *pTracker,
    NTSTATUS                status
    )
/*++

Routine Description:

    This routine is called by completion routines to complete the client
    request.  It may involve completing several queued up requests.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    PLIST_ENTRY             pEntry;
    tDGRAM_SEND_TRACKING    *pTrack;
    tDEVICECONTEXT          *pDeviceContext = NULL;
    CTELockHandle           OldIrq;
    LIST_ENTRY              ListEntry;

    InitializeListHead (&ListEntry);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    //
    // set up a new list head for any queued name queries.
    // since we may need to do a new name query below.
    // The Proxy hits this routine with a Null Tracker, so check for that.
    //
    if (pTracker)
    {
        pDeviceContext = pTracker->pDeviceContext;
        if( !IsListEmpty(&pTracker->TrackerList))
        {
            ListEntry.Flink = pTracker->TrackerList.Flink;
            ListEntry.Flink->Blink = &ListEntry;
            ListEntry.Blink = pTracker->TrackerList.Blink;
            ListEntry.Blink->Flink = &ListEntry;

            InitializeListHead (&pTracker->TrackerList);
        }
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    (*pClientCompletion)(pTracker,status);

    while (!IsListEmpty(&ListEntry))
    {
        pEntry = RemoveHeadList(&ListEntry);
        pTrack = CONTAINING_RECORD(pEntry,tDGRAM_SEND_TRACKING,TrackerList);

        //
        // if the name query failed and there is another requested queued on
        // a different device context, re-attempt the name query
        //
        if ((pTrack->pDeviceContext != pDeviceContext) &&
            (status != STATUS_SUCCESS))
        {
            //
            // setup the correct back link since this guy is now the list
            // head. The Flink is ok unless the list is empty now.
            //
            pTrack->TrackerList.Blink = ListEntry.Blink;
            pTrack->TrackerList.Blink->Flink = &pTrack->TrackerList;

            if (pTrack->TrackerList.Flink == &ListEntry)
            {
                pTrack->TrackerList.Flink = &pTrack->TrackerList;
            }

            // do a name query on the next name in the list
            // and then wait for it to complete before processing any more
            // names on the list.
            CTESpinLock(&NbtConfig.JointLock,OldIrq);
            status = QueryNameOnNet (pTrack->pDestName,
                                     NbtConfig.pScope,
                                     NBT_UNIQUE,      //use this as the default
                                     (PVOID)pTrack,
                                     pTrack->CompletionRoutine,
                                     NodeType & NODE_MASK,
                                     NULL,
                                     pTrack->pDeviceContext,
                                     &OldIrq);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            break;
        }
        else
        {
            //
            // get the completion routine for this tracker since it may be
            // different than the tracker tied to the timer block. i.e.
            // pCompletionClient passed to this routine.
            //
            pClientCompletion = pTrack->CompletionRoutine;
            (*pClientCompletion)(pTrack,status);
        }
    }   // while
}

//----------------------------------------------------------------------------
NTSTATUS
NbtRegisterName(
    IN    enum eNbtLocation   Location,
    IN    ULONG               IpAddress,
    IN    PCHAR               pName,
    IN    tNAMEADDR           *pNameAddrIn,
    IN    tCLIENTELE          *pClientEle,
    IN    PVOID               pClientCompletion,
    IN    USHORT              uAddressType,
    IN    tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine registers a name from local or from the network depending
    on the value of Location. (i.e. local node uses this routine as well
    as the proxy code.. although it has only been tested with the local
    node registering names so far - and infact the remote code has been
    removed... since it is not used.  All that remains is to remove
    the Location parameter.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    ULONG       Timeout;
    USHORT      Retries;
    NTSTATUS    status;
    tNAMEADDR   *pNameAddr;
    USHORT      uAddrType;
    tDGRAM_SEND_TRACKING *pSentList= NULL;
    CTELockHandle OldIrq1;
    ULONG         PrevNameTypeState;
    ULONG		LocalNodeType;

    LocalNodeType = AppropriateNodeType( pName, NodeType );

    if ((uAddressType == (USHORT)NBT_UNIQUE ) ||
        (uAddressType == (USHORT)NBT_QUICK_UNIQUE))
    {
        uAddrType = NBT_UNIQUE;
    }
    else
    {
        uAddrType = NBT_GROUP;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    if (IpAddress)
    {
        status = AddToHashTable (pNbtGlobConfig->pLocalHashTbl,
                                 pName,
                                 NbtConfig.pScope,
                                 IpAddress,
                                 uAddrType,
                                 NULL,
                                 &pNameAddr,
                                 pDeviceContext,
                                 0);

        if (status != STATUS_SUCCESS)
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            return(STATUS_UNSUCCESSFUL);
        }

        pNameAddr->RefreshMask = 0;
    }
    else
    {
        // in this case the name is already in the table, we just need
        // to re-register it
        //
        status = FindInHashTable (pNbtGlobConfig->pLocalHashTbl, pName, NbtConfig.pScope, &pNameAddr);
        if (!NT_SUCCESS(status))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            return(status);
        }

        ASSERT (pNameAddr == pNameAddrIn);
    }

    CHECK_PTR(pNameAddr);
    if ((uAddressType != (USHORT)NBT_UNIQUE ) &&
        (uAddressType != (USHORT)NBT_QUICK_UNIQUE))
    {
        // this means group name so use Bcast Addr - UdpSendDgram changes this
        // value to the Broadcast address of the particular adapter
        // when is sees the 0.  So when we send to a group name that is
        // also registered on this node, it will go out as a broadcast
        // to the subnet as well as to this node.
        pNameAddr->IpAddress = 0;
    }

#ifdef _NETBIOSLESS
    if (IsDeviceNetbiosless(pDeviceContext))       // The Smb Device is not adapter specific
    {
        pNameAddr->NameFlags |= NAME_REGISTERED_ON_SMBDEV;
    }
    else
#endif
    {
        //
        // start with the refreshed bit not set
        //
        pNameAddr->RefreshMask &= ~pDeviceContext->AdapterMask;
        pNameAddr->AdapterMask |= pDeviceContext->AdapterMask; // turn on the adapter bit in the Mask
    }

    pClientEle->pAddress->pNameAddr = pNameAddr;    // save the local name ptr in the address element
    pNameAddr->pAddressEle = pClientEle->pAddress;  // store a back ptr to the address element
    pNameAddr->Ttl = NbtConfig.MinimumTtl; // set to 2 minutes until we hear differently from the Name Server

    PrevNameTypeState = pNameAddr->NameTypeState;
    pNameAddr->NameTypeState &= ~(NAME_TYPE_MASK | NAME_STATE_MASK);
    pNameAddr->NameTypeState |= (uAddrType == NBT_UNIQUE) ? NAMETYPE_UNIQUE : NAMETYPE_GROUP;
    if ((PrevNameTypeState & NAMETYPE_QUICK) ||
        (uAddressType >= (USHORT)NBT_QUICK_UNIQUE))
    {
       pNameAddr->NameTypeState |= NAMETYPE_QUICK;
    }

    //
    // for "quick" adds, do not register the name on the net!
    // however the name will get registered with the name server and
    // refreshed later....if this is an MS or M or P node.
    //
    if ((pNameAddr->NameTypeState & NAMETYPE_QUICK) ||
        (pName[0] == '*') ||                   // broadcast netbios name does not get claimed on network
        (IpAddress == LOOP_BACK) ||            // If no IP address, pretend the registration succeeded
        (pDeviceContext->IpAddress == 0) ||    // names will be registered when we get an address
        (IsDeviceNetbiosless (pDeviceContext)))
    {
        pNameAddr->NameTypeState |= STATE_RESOLVED;
        status = STATUS_SUCCESS;
    }
    else if (NT_SUCCESS(status = GetTracker(&pSentList, NBT_TRACKER_REGISTER_NAME)))
    {
        pNameAddr->NameTypeState |= STATE_RESOLVING;
        InitializeListHead(&pSentList->Linkage);    // there is no list of things sent yet

        // keep a ptr to the name so we can update the state of the name
        // later when the registration completes
        pSentList->pNameAddr = pNameAddr;
        pSentList->pDeviceContext = pDeviceContext;
        pSentList->RefCount = 2; // tracker can be deref'ed by a pdu from wire before UdpSendNsBcast is done
#ifdef MULTIPLE_WINS
        pSentList->NSOthersIndex = 0;       // Initialize for Name Server Queries
        pSentList->NSOthersLeft = 0;
#endif

        // the code must now register the name on the network, depending on the type of node
        Retries = pNbtGlobConfig->uNumBcasts + 1;
        Timeout = (ULONG)pNbtGlobConfig->uBcastTimeout;
        pSentList->Flags = NBT_BROADCAST;
        if (LocalNodeType & (PNODE | MSNODE))
        {
            // talk to the NS only to register the name
            // ( the +1 does not actually result in a name reg, it
            // is just compatible with the code for M node above since
            // it uses the same completion routine).
            //
            Retries = (USHORT)pNbtGlobConfig->uNumRetries + 1;
            Timeout = (ULONG)pNbtGlobConfig->uRetryTimeout;
            pSentList->Flags = NBT_NAME_SERVER;
            //
            // if there is no Primary WINS server short out the timeout
            // so it completes faster. For Hnode this means to go broadcast.
            //
            if ((pDeviceContext->lNameServerAddress == LOOP_BACK) ||
                pDeviceContext->WinsIsDown)
            {
                if (LocalNodeType & MSNODE)
                {
                    pSentList->Flags = NBT_BROADCAST;
                    Retries = (USHORT)pNbtGlobConfig->uNumBcasts + 1;
                    Timeout = (ULONG)pNbtGlobConfig->uBcastTimeout;

                    IncrementNameStats(NAME_REGISTRATION_SUCCESS, FALSE);   // not name server register
                }
                else // its a Pnode
                {
                    IF_DBG(NBT_DEBUG_NAMESRV)
                        KdPrint(("Nbt.NbtRegisterName: WINS DOWN - shorting out registration\n"));

                    Retries = 1;
                    Timeout = 10;
                    pSentList->Flags = NBT_NAME_SERVER_BACKUP;
                }
            }
        }

        // the name itself has a reference count too.
        // make the count 2, so that pNameAddr won't get released until
        // after NBT_DEREFERENCE_TRACKER is called below, since it writes to
        // pNameAddr. Note that we must increment here rather than set = 2
        // since it could be a multihomed machine doing the register at
        // the same time we are sending a datagram to that name.
        //
        NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_REGISTER);

        pDeviceContext->DeviceRefreshState |= NBT_D_REFRESHING_NOW;

        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

        // start the timer in this routine.
        status = UdpSendNSBcast(pNameAddr,
                                NbtConfig.pScope,
                                pSentList,
                                (PVOID) MSnodeRegCompletion,
                                pClientEle,
                                pClientCompletion,
                                Retries,
                                Timeout,
                                eNAME_REGISTRATION,
                                TRUE);

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);

        CHECK_PTR(pNameAddr);
        NBT_DEREFERENCE_TRACKER (pSentList, TRUE);  // possibly frees the tracker
        NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REGISTER, TRUE);

        if (NT_SUCCESS(status))
        {
            status = STATUS_PENDING;
        }
        else    // We failed to allocate resources, or the timer failed to start
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtRegisterName: UdpSendNsBcast returned ERROR = %x\n", status));
            NbtTrace(NBT_TRACE_NAMESRV, ("UdpSendNSBcast return %!status! for %!NBTNAME!<%02x>",
                status, pNameAddr->Name, (unsigned)pNameAddr->Name[15]));

            NBT_DEREFERENCE_TRACKER (pSentList, TRUE);
        }
    }

    if (!NT_SUCCESS(status))
    {
        if (!IsDeviceNetbiosless(pDeviceContext))       // The Smb Device is not adapter specific
        {
            pNameAddr->AdapterMask &= (~pDeviceContext->AdapterMask); // turn off the adapter bit in the Mask
        }
        pNameAddr->NameTypeState = PrevNameTypeState;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    return(status);
}

//----------------------------------------------------------------------------
VOID
MSnodeRegCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine is called by the timer code when the timer expires. It must
    decide if another name registration should be done, and if not, then it calls the
    client's completion routine (in completion2).
    It first attempts to register a name via Broadcast, then it attempts
    NameServer name registration.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    ULONG                   Flags;
    CTELockHandle           OldIrq;
    enum eNSTYPE            PduType;
	ULONG					LocalNodeType;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    PduType = eNAME_REGISTRATION;

	LocalNodeType = AppropriateNodeType( pTracker->pNameAddr->Name, NodeType );

    //
    // check if the client completion routine is still set.  If not then the
    // timer has been cancelled and this routine should just clean up its
    // buffers associated with the tracker.
    //
    if (!pTimerQEntry)
    {
        // return the tracker block to its queue
        LOCATION(0x55);
        pTracker->pNameAddr->pTimer = NULL;
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
        return;
    }

    //
    // to prevent a client from stopping the timer and deleting the
    // pNameAddr, grab the lock and check if the timer has been stopped
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (pTimerQEntry->Flags & TIMER_RETIMED)
    {
        pTimerQEntry->Flags &= ~TIMER_RETIMED;
        pTimerQEntry->Flags |= TIMER_RESTART;

        if ((!pTracker->pDeviceContext->IpAddress) ||
            (pTracker->Flags & NBT_NAME_SERVER) &&
            (pTracker->pDeviceContext->lNameServerAddress == LOOP_BACK))
        {
            // when the  address is loop back there is no wins server
            // so shorten the timeout.
            //
            pTimerQEntry->DeltaTime = 10;
        }
        else if ((pTracker->Flags & NBT_NAME_SERVER_BACKUP) &&
                 (pTracker->pDeviceContext->lBackupServer == LOOP_BACK))
        {
            // when the address is loop back there is no wins server
            // so shorten the timeout.
            //
            pTimerQEntry->DeltaTime = 10;
        }
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    if (!pTimerQEntry->ClientCompletion)
    {
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);    // Bug #: 230925
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    // if number of retries is not zero then continue trying to contact the Name Server
    //
    if (--pTimerQEntry->Retries)
    {
        // change the name reg pdu to a name overwrite request for the
        // final broadcast ( turn off Recursion Desired bit)
        //
        if (pTimerQEntry->Retries == 1)
        {
            if (pTracker->Flags & NBT_BROADCAST)
            {
                // do a broadcast name registration... on the last broadcast convert it to
                // a Name OverWrite Request by clearing the "Recursion Desired" bit
                // in the header
                //
                PduType = eNAME_REGISTRATION_OVERWRITE;
            }
            else if (LocalNodeType & (PNODE | MSNODE))
            {
                // we want the Pnode to timeout again, right away and fall
                // through to handle Timed out name registration - i.e. it
                // does not do the name overwrite demand like the B,M,&MS nodes
                //
                pTimerQEntry->Flags |= TIMER_RESTART;
                pTimerQEntry->DeltaTime = 5;
                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                return;
            }
        }
    }
    else
    {
        Flags = pTracker->Flags;
        pTracker->Flags &= ~(NBT_BROADCAST | NBT_NAME_SERVER);
        // set a different timeout for nameserver name registration
        //
        pTimerQEntry->DeltaTime = NbtConfig.uRetryTimeout;
        pTimerQEntry->Retries = NbtConfig.uNumRetries + 1;

        if ((Flags & NBT_BROADCAST) && (LocalNodeType & MNODE))
        {
            //
            // Registered through broadcast, so try the name server now.
            IncrementNameStats(NAME_REGISTRATION_SUCCESS, FALSE);  // not name server register
            pTracker->Flags |= NBT_NAME_SERVER;
            if ((pTracker->pDeviceContext->lNameServerAddress == LOOP_BACK) ||
                 pTracker->pDeviceContext->WinsIsDown)
            {
                pTimerQEntry->DeltaTime = 10;
                pTimerQEntry->Retries = 1;
            }
        }
        else if ((Flags & NBT_NAME_SERVER) && !(LocalNodeType & BNODE))
        {
            //
            // Can't reach the name server, so try the backup
            pTracker->Flags |= NBT_NAME_SERVER_BACKUP;
            //
            // short out the timer if no backup server
            //
            if ((pTracker->pDeviceContext->lBackupServer == LOOP_BACK) ||
                 pTracker->pDeviceContext->WinsIsDown)
            {
                pTimerQEntry->DeltaTime = 10;
                pTimerQEntry->Retries = 1;
            }
        }
        else if ((LocalNodeType & MSNODE) && !(Flags & NBT_BROADCAST))
        {
            if (Flags & NBT_NAME_SERVER_BACKUP)
            {
                // the msnode switches to broadcast if all else fails
                //
                pTracker->Flags |= NBT_BROADCAST;
                IncrementNameStats(NAME_REGISTRATION_SUCCESS, FALSE);   // not name server register

                //
                // change the timeout and retries since broadcast uses a shorter timeout
                //
                pTimerQEntry->DeltaTime = NbtConfig.uBcastTimeout;
                pTimerQEntry->Retries = (USHORT)pNbtGlobConfig->uNumBcasts + 1;
            }
        }
        else
        {
            if (LocalNodeType & BNODE)
            {
                IncrementNameStats(NAME_REGISTRATION_SUCCESS, FALSE);   // not name server register
            }
            //
            // the timeout has expired on the name registration
            // so call the client
            //

            // return the tracker block to its queue
            LOCATION(0x54);

            //
            // start a timer to stop using WINS for a short period of
            // time.  Do this only if we had sent the last registration
            // to a Wins server
            //
            if (!(Flags & NBT_BROADCAST) && pTracker->pDeviceContext->lNameServerAddress != LOOP_BACK)
            {
                SetWinsDownFlag(pTracker->pDeviceContext);
            }

            NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            status = STATUS_SUCCESS;
            InterlockedCallCompletion(pTimerQEntry,status);

            return;
        }
    }

    NBT_REFERENCE_TRACKER (pTracker);
    pTimerQEntry->Flags |= TIMER_RESTART;

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    status = UdpSendNSBcast(pTracker->pNameAddr,
                            NbtConfig.pScope,
                            pTracker,
                            NULL,NULL,NULL,
                            0,0,
                            PduType,
                            TRUE);

    NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
}


//----------------------------------------------------------------------------
VOID
RefreshRegCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles the name Refresh timeouts on packets sent to the Name
    Service. I.e it sends refreshes to the nameserver until a response is
    heard or the number of retries is exceeded.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    tNAMEADDR               *pNameAddr;
    CTELockHandle           OldIrq;
    COMPLETIONCLIENT        pCompletionClient;


    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    if (!pTimerQEntry)
    {
        pTracker->pNameAddr->pTimer = NULL;
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
        return;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // check if the timer has been stopped yet, since stopping the timer
    // nulls the client completion routine. If not null, increment the
    // tracker refcount, so that the last refresh completing cannot
    // free the tracker out from under us.
    //
    if (!(pCompletionClient = pTimerQEntry->ClientCompletion))
    {
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    // if still some count left and not refreshed yet
    // then do another refresh request
    //
    pNameAddr = pTracker->pNameAddr;

    if (--pTimerQEntry->Retries)
    {
        NBT_REFERENCE_TRACKER (pTracker);
        pTimerQEntry->Flags |= TIMER_RESTART;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        status = UdpSendNSBcast(pTracker->pNameAddr,
                                NbtConfig.pScope,
                                pTracker,
                                NULL,NULL,NULL,
                                0,0,
                                pTracker->AddressType,
                                TRUE);

        // always restart even if the above send fails, since it might succeed
        // later.
        NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        // this calls the completion routine synchronizing with the
        // timer expiry code.
        InterlockedCallCompletion(pTimerQEntry,STATUS_TIMEOUT);
    }
}

//----------------------------------------------------------------------------
NTSTATUS
ReleaseNameOnNet(
    tNAMEADDR           *pNameAddr,
    PCHAR               pScope,
    PVOID               pClientCompletion,
    ULONG               LocalNodeType,
    tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine deletes a name on the network either by a
    broadcast or by talking to the NS depending on the type of node. (M,P or B)

Arguments:


Return Value:

    The function value is the status of the operation.

Called By: ProxyQueryFromNet() in proxy.c,   NbtConnect() in name.c

--*/

{
    ULONG                Timeout;
    USHORT               Retries;
    NTSTATUS             status=STATUS_UNSUCCESSFUL;
    tDGRAM_SEND_TRACKING *pTracker;
    CTELockHandle        OldIrq;
    tTIMERQENTRY        *pTimer;

    status = GetTracker(&pTracker, NBT_TRACKER_RELEASE_NAME);
    if (!NT_SUCCESS(status))
    {
        return(status);
    }
    pTracker->pDeviceContext = pDeviceContext;
    pTracker->pNameAddr = pNameAddr;
    pTracker->SendBuffer.pDgramHdr = NULL;  // set to NULL to catch any erroneous frees.
    pTracker->RefCount = 3;                 // We use the same tracker for the CompletionContext + Request

    // Set a few values as a precursor to releasing the name either by
    // broadcast or with the name server
    //
    LocalNodeType = AppropriateNodeType( pNameAddr->Name, LocalNodeType );
    switch (LocalNodeType & NODE_MASK)
    {
        case MSNODE:
        case MNODE:
        case PNODE:

            pTracker->Flags = NBT_NAME_SERVER;
            Timeout = (ULONG)pNbtGlobConfig->uRetryTimeout;
            Retries = (USHORT)pNbtGlobConfig->uNumRetries;

            break;

        case BNODE:
        default:

            pTracker->Flags = NBT_BROADCAST;
            Timeout = (ULONG)pNbtGlobConfig->uBcastTimeout;
#ifndef VXD
            Retries = (USHORT)pNbtGlobConfig->uNumBcasts;
#else
            Retries = (USHORT)1;
#endif
    }

    //
    // Release name on the network
    //
    IF_DBG(NBT_DEBUG_NAMESRV)
    KdPrint(("Nbt.ReleaseNameOnNet: Doing Name Release on name %16.16s<%X>\n",
        pNameAddr->Name,pNameAddr->Name[15]));

    status = UdpSendNSBcast(pNameAddr,
                            pScope,
                            pTracker,
                            ReleaseCompletion,
                            pTracker,
                            pClientCompletion,
                            Retries,
                            Timeout,
                            eNAME_RELEASE,
                            TRUE);

    NBT_DEREFERENCE_TRACKER(pTracker, FALSE);

    if (!NT_SUCCESS(status))
    {
        NTSTATUS            Locstatus;
        COMPLETIONCLIENT    pCompletion;
        PVOID               pContext;

        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.ReleaseNameOnNet: UdpSendNSBcast failed - retcode = %X\n", status));

        // Stopping the timer will call ReleaseCompletion which will
        // free the tracker
        //
        pCompletion = NULL;
        CHECK_PTR(pNameAddr);
        if (pTimer = pNameAddr->pTimer)
        {
            pNameAddr->pTimer = NULL;
            Locstatus = StopTimer(pTimer,&pCompletion,&pContext);
        }
        else
        {
            // no timer setup, so just free the tracker
            //
            FreeTracker(pTracker, RELINK_TRACKER);
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(status);
}
//----------------------------------------------------------------------------
VOID
ReleaseCompletion(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine is called by the timer code when the timer expires. It must
    decide if another name query should be done, and if not, then it calls the
    client's completion routine (in completion2).
    This routine handles both the broadcast portion of the name queries and
    the WINS server directed sends.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
	ULONG					LocalNodeType;
    BOOLEAN                 fRetry;
    CTELockHandle           OldIrq;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    if (!pTimerQEntry)
    {
        pTracker->pNameAddr->pTimer = NULL;
        NBT_DEREFERENCE_TRACKER (pTracker, TRUE);
        return;
    }

    //
    // There could be a scenario here where this name is currently being
    // released, but we just got a new client with the same name -- in that
    // case NbtOpenAddress will set the ReleaseMask to 0, so we stop
    // releasing the name on that device if that happens!
    //
    if (!(pTracker->pNameAddr->ReleaseMask))
    {
        LocalNodeType = BNODE;
        pTimerQEntry->Retries = 1;
    }
    else if (IsBrowserName(pTracker->pNameAddr->Name))
	{
		LocalNodeType = BNODE;
	}
	else
	{
		LocalNodeType = NodeType;
	}

    fRetry = TRUE;
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (IsEntryInList (&pTracker->pDeviceContext->Linkage, &NbtConfig.DeviceContexts))
    {
        // if number of retries is not zero then continue trying
        // to contact the Name Server.
        //
        if (!(--pTimerQEntry->Retries))
        {
            if ((LocalNodeType & MNODE) &&
               (pTracker->Flags & NBT_NAME_SERVER))
            {
                //
                // try broadcast
                //
                pTracker->Flags &= ~NBT_NAME_SERVER;
                pTracker->Flags |= NBT_BROADCAST;

                // set a different timeout for broadcast name resolution
                //
                pTimerQEntry->DeltaTime = NbtConfig.uBcastTimeout;
                pTimerQEntry->Retries = NbtConfig.uNumBcasts;
            }
            else
            {
                fRetry = FALSE;
            }
        }
    }
    else
    {
        fRetry = FALSE;
    }

#ifdef VXD
    if (fRetry)
#else
    if ((fRetry) &&
        (NBT_REFERENCE_DEVICE (pTracker->pDeviceContext, REF_DEV_NAME_REL, TRUE)))
#endif  // VXD
    {
        NBT_REFERENCE_TRACKER (pTracker);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        status = UdpSendNSBcast(pTracker->pNameAddr,
                                NbtConfig.pScope,
                                pTracker,
                                NULL,NULL,NULL,
                                0,0,
                                eNAME_RELEASE,
                                TRUE);

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
#ifndef VXD
        NBT_DEREFERENCE_DEVICE (pTracker->pDeviceContext, REF_DEV_NAME_REL, TRUE);
#endif  !VXD
        NBT_DEREFERENCE_TRACKER (pTracker, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        pTimerQEntry->Flags |= TIMER_RESTART;
        return;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    //
    // the timeout has expired on the name release
    // or the Device on which we were releasing the name
    // could have gone away, so call the client
    //
    status = InterlockedCallCompletion(pTimerQEntry,STATUS_TIMEOUT);

    // return the tracker block to its queue if we successfully
    // called the completion  routine since someone else might
    // have done a Stop timer at this very moment and freed the
    // tracker already (i.e. the last else clause in this routine).
    //
    if (NT_SUCCESS(status))
    {
        NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
    }
}

//----------------------------------------------------------------------------
VOID
NameReleaseDone(
    PVOID               pContext,
    NTSTATUS            Status
    )
/*++

Routine Description:

    This routine is called when a name is released on the network.  Its
    main, role in life is to free the memory in Context, which is the pAddressEle
    structure.

Arguments:


Return Value:

    The function value is the status of the operation.

Called By Release Completion (above)
--*/

{
    CTELockHandle           OldIrq1;
    tDEVICECONTEXT          *pDeviceContext;
    tDGRAM_SEND_TRACKING    *pTracker = (tDGRAM_SEND_TRACKING *)  pContext;
    tNAMEADDR               *pNameAddr = pTracker->pNameAddr;

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);
    NBT_DEREFERENCE_TRACKER(pTracker, TRUE);

    pNameAddr->pTimer = NULL;   // Since we could be starting a new Timer below
    //
    // Before releasing this name, see if this name is registered on
    // any more devices
    // WARNING -- Do not touch the current pTracker->DeviceContext since the
    // the device may have gone away
    //
    while (pDeviceContext = GetAndRefNextDeviceFromNameAddr (pNameAddr))
    {
        //
        // Increment the RefCounts for the structures we need to keep around
        // They will be Dereferenced when the Name Release has completed
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

        Status = ReleaseNameOnNet(pNameAddr,
                       NbtConfig.pScope,
                       NameReleaseDone,
                       NodeType,
                       pDeviceContext);

        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
#ifndef VXD
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_GET_REF, TRUE);
#endif  // !VXD

        if (NT_SUCCESS(Status))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);
            return;
        }

        //
        // We failed to release the name on this Device, so try the
        // next Device!
        //
    }

    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_RELEASE, TRUE);
    CTESpinFree(&NbtConfig.JointLock,OldIrq1);
}


//----------------------------------------------------------------------------
NTSTATUS
StartRefresh(
    IN  tNAMEADDR               *pNameAddr,
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  CTELockHandle           *pJointLockOldIrq,
    IN  BOOLEAN                 ResetDevice
    )
/*++

Routine Description:

    This routine handles refreshing a name with the Name server.

    The idea is to set the timeout to T/8 and check for names with the Refresh
    bit cleared - re-registering those names.  At T=4 and T=0, clear all bits
    and refresh all names.  The Inbound code sets the refresh bit when it gets a
    refresh response from the NS.
    The JointLock is held while this routine is called, and the last Irql is
    passed in pJointLockOldIrq

Arguments:


Return Value:

    none

--*/
{
    NTSTATUS                status;
    tDEVICECONTEXT          *pDeviceContext = NULL;
    BOOLEAN                 NewTracker = FALSE;

    if (!pTracker)
    {
        LOCATION(0x9);

        status = GetTracker(&pTracker, NBT_TRACKER_REFRESH_NAME);
        if (!NT_SUCCESS(status))
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        // need to prevent the tracker from being freed by a pdu from
        // the wire before the UdpSendNsBcast is done
        //
        pTracker->RefCount = 1;

        NewTracker = TRUE;
    }

    // set the name to be refreshed in the tracker block
    pTracker->pNameAddr = pNameAddr;

    // this is set true when a new name gets refreshed
    //
    if ((ResetDevice) || (NewTracker))
    {
        PLIST_ENTRY  pEntry, pHead;
        CTEULONGLONG AdapterMask;

        LOCATION(0xb);

        //
        // Identify the Adapters which have not been refreshed
        // Then, get the lowest Adapter number and Refresh on it
        //
        pHead = &NbtConfig.DeviceContexts;
        AdapterMask = pNameAddr->AdapterMask & ~(pNameAddr->RefreshMask);
        AdapterMask = ~(AdapterMask - 1) & AdapterMask;

        ASSERT (AdapterMask);
        while (AdapterMask)
        {
            //
            // Travel to the actual device for this Adapter number
            //
            pEntry = pHead->Flink;
            while (pEntry != pHead)
            {
                pDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
                if (pDeviceContext->AdapterMask == AdapterMask)
                {
                    //
                    // Found a valid device on which this name is registered
                    //
                    break;
                }
                else
                {
                    pDeviceContext = NULL;
                }

                //
                // Go to next device
                //
                pEntry = pEntry->Flink;
            }

            if (pDeviceContext)
            {
                //
                // Found a Device to do a NameRefresh on
                //
                break;
            }

            //
            // This is an error case -- the device for this adapter number
            // does not exist.  Remove it from the Adapter and Refresh masks
            //
            pNameAddr->AdapterMask &= ~AdapterMask;
            pNameAddr->RefreshMask &= ~AdapterMask;

            AdapterMask = pNameAddr->AdapterMask & ~(pNameAddr->RefreshMask);
            AdapterMask = ~(AdapterMask - 1) & AdapterMask;
        }

        if (!pDeviceContext)
        {
            IF_DBG(NBT_DEBUG_REFRESH)
                KdPrint(("Nbt.StartRefresh: Failed to Refresh <%16.16s:%x>!! no valid adapter ****\n",
                    pNameAddr->Name, pNameAddr->Name[15]));
            NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
            return(STATUS_UNSUCCESSFUL);
        }

#ifndef VXD
        IF_DBG(NBT_DEBUG_REFRESH)
            KdPrint(("Nbt.StartRefresh: Refresh adapter: %lx:%lx, dev.nm: %lx for name: %lx\n",
                AdapterMask, pDeviceContext->BindName.Buffer, pNameAddr));
#endif  // !VXD

        pTracker->pDeviceContext = pDeviceContext;
        //
        // Clear the transaction Id so that CreatePdu will increment
        // it for this new name
        //
        CHECK_PTR(pTracker);
        pTracker->TransactionId = 0;
    }

    pTracker->pDeviceContext->DeviceRefreshState |= NBT_D_REFRESHING_NOW;
    pDeviceContext = pTracker->pDeviceContext;
    pTracker->AddressType = eNAME_REFRESH;
    // Check if we need to refresh to the primary or backup

    if ((pDeviceContext->IpAddress) &&
        (pTracker->pDeviceContext->lNameServerAddress == LOOP_BACK) &&
        (pNameAddr->NameTypeState & STATE_CONFLICT) &&
        (!pNameAddr->ConflictMask))
    {
        //
        // Broadcast the Refresh to ensure no conflict
        //
        pTracker->Flags = NBT_BROADCAST;
        pTracker->AddressType = eNAME_REGISTRATION;
    }
    else if (pTracker->pDeviceContext->RefreshToBackup)
    {
        pTracker->Flags = NBT_NAME_SERVER_BACKUP;
    }
    else
    {
        pTracker->Flags = NBT_NAME_SERVER;
    }

    // this accounts for the dereference done after the call to
    // send the datagram below.
    NBT_REFERENCE_TRACKER (pTracker);
    CTESpinFree(&NbtConfig.JointLock,*pJointLockOldIrq);

    status = UdpSendNSBcast(pNameAddr,
                            NbtConfig.pScope,
                            pTracker,
                            RefreshRegCompletion,
                            pTracker,
                            NextRefresh,
                            NbtConfig.uNumRetries,
                            NbtConfig.uRetryTimeout,
                            pTracker->AddressType,
                            TRUE);

    CTESpinLock(&NbtConfig.JointLock,*pJointLockOldIrq);
    NBT_DEREFERENCE_TRACKER(pTracker, TRUE);

    LOCATION(0x57);

    if (!NT_SUCCESS(status))
    {
        LOCATION(0xe);
        IF_DBG(NBT_DEBUG_REFRESH)
            KdPrint(("Nbt.StartRefresh: Failed to send Refresh!! status = %X****\n",status));
        //
        // This will free the tracker.  Name refresh will stop until
        // the next refresh timeout and at that point it will attempt
        // to refresh the names again.
        //
        NBT_DEREFERENCE_TRACKER(pTracker, TRUE);
    }

    return(status);
}

//----------------------------------------------------------------------------
VOID
GetNextName(
    IN      tNAMEADDR   *pNameAddrIn,
    OUT     tNAMEADDR   **ppNameAddr
    )
/*++

Routine Description:

    This routine finds the next name to refresh, including incrementing the
    reference count so that the name cannot be deleted during the refresh.
    The JointLock spin lock is held before calling this routine.

Arguments:


Return Value:

    none

--*/
{
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    LONG                    i, iIndex;
    tNAMEADDR               *pNameAddr;
    tHASHTABLE              *pHashTable;


    pHashTable = NbtConfig.pLocalHashTbl;

    for (i= NbtConfig.CurrentHashBucket;i < pHashTable->lNumBuckets ;i++ )
    {
        //
        // use the last name as the current position in the linked list
        // only if that name is still resolved, otherwise start at the
        // begining of the hash list, incase the name got deleted in the
        // mean time.
        //
        if (pNameAddrIn)
        {
            //
            // The Address for this name is Referenced, so it has to be a valid name!
            //
            ASSERT (NBT_VERIFY_HANDLE (pNameAddrIn, LOCAL_NAME));

            if ((pNameAddrIn->NameTypeState & STATE_CONFLICT) &&
                (!pNameAddrIn->ConflictMask) &&
                (!(pNameAddrIn->NameTypeState & REFRESH_FAILED)))
            {
                //
                // If we succeeded in Refreshing on all adapters,
                // remove the name from the Conflict state
                //
                pNameAddrIn->NameTypeState &= (~NAME_STATE_MASK);
                pNameAddrIn->NameTypeState |= STATE_RESOLVED;
            }

            // first hash the name to an index
            // take the lower nibble of the first 2 characters.. mod table size
            iIndex = ((pNameAddrIn->Name[0] & 0x0F) << 4) + (pNameAddrIn->Name[1] & 0x0F);
            iIndex = iIndex % pHashTable->lNumBuckets;

            if (iIndex != NbtConfig.CurrentHashBucket)
            {
                //
                // Someone else is refreshing right now!
                //
                *ppNameAddr = NULL;
                return;
            }

            pHead = &NbtConfig.pLocalHashTbl->Bucket[NbtConfig.CurrentHashBucket];
            pEntry = pNameAddrIn->Linkage.Flink;

            pNameAddrIn = NULL;
        }
        else
        {
            pHead = &pHashTable->Bucket[i];
            pEntry = pHead->Flink;
        }

        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;

            // don't refresh scope names or names in conflict or that are the
            // broadcast name "*    " or quick unique names - i.e. the permanent
            // name is nametype quick
            //
            if ((pNameAddr->Name[0] != '*') &&
                (!(pNameAddr->NameTypeState & NAMETYPE_QUICK)) &&
                (pNameAddr->pAddressEle) &&                     // Not currently being closed down!
                ((pNameAddr->NameTypeState & STATE_RESOLVED) ||
                 ((pNameAddr->NameTypeState & STATE_CONFLICT) && (!pNameAddr->ConflictMask))))
            {
                // check if the name has been refreshed yet
                //
                // Refresh this name only if any of the non-refreshed bits in
                // the RefreshMask match any of the bits for the adapters this
                // device is registered on!
                pNameAddr->NameTypeState &= (~REFRESH_FAILED);  // Will be set on Failure
                if (pNameAddr->AdapterMask & ~pNameAddr->RefreshMask)
                {
                    // increment the reference count so that this name cannot
                    // disappear while it is being refreshed and mess up the linked list
                    NBT_REFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_REFRESH);

                    NbtConfig.CurrentHashBucket = (USHORT)i;

                    *ppNameAddr = pNameAddr;
                    return;
                }
                else if (pNameAddr->NameTypeState & STATE_CONFLICT)
                {
                    pNameAddr->NameTypeState &= (~NAME_STATE_MASK);
                    pNameAddr->NameTypeState |= STATE_RESOLVED;
                }
            }
        }
    }

    *ppNameAddr = NULL;
}


//----------------------------------------------------------------------------
VOID
NextRefresh(
    IN  PVOID     pContext,
    IN  NTSTATUS  CompletionStatus
    )
/*++

Routine Description:

    This routine queues the work to an Executive worker thread to handle
    refreshing the next name.

Arguments:


Return Value:

    none

--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;

    pTracker = (tDGRAM_SEND_TRACKING *) pContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    pTracker->pNameAddr->pTimer = NULL;     // Set the timer to NULL!

    if (!(NBT_VERIFY_HANDLE (pTracker->pDeviceContext, NBT_VERIFY_DEVCONTEXT)))
    {
        //
        // Since the Device is going away, let's assume we succeeded
        //
        CompletionStatus = STATUS_SUCCESS;
        pTracker->pDeviceContext = NULL;
    }

    if (!NT_SUCCESS(NTQueueToWorkerThread(NULL, DelayedNextRefresh,
                                                  pTracker,
                                                  ULongToPtr(CompletionStatus), // Sundown: zero-extended.
                                                  NULL,
                                                  pTracker->pDeviceContext,
                                                  TRUE)))
    {
        IF_DBG(NBT_DEBUG_REFRESH)
            KdPrint (("Nbt.NextRefresh: Failed to Enqueu DelayedNextRefresh!!!\n"));

        NBT_DEREFERENCE_TRACKER (pTracker, TRUE);
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}

//----------------------------------------------------------------------------
VOID
DelayedNextRefresh(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   pUnused1,
    IN  tDEVICECONTEXT          *pDeviceContext
    )
/*++

Routine Description:

    This routine handles sending subsequent refreshes to the name server.
    This is the "Client Completion" routine of the Timer started above.

Arguments:


Return Value:

    none

--*/
{
    CTELockHandle           OldIrq;
    tNAMEADDR               *pNameAddr;
    tNAMEADDR               *pNameAddrNext;
    NTSTATUS                status;
    PLIST_ENTRY             pEntry, pHead;
    CTEULONGLONG            AdapterMask;
    BOOLEAN                 fAbleToReachWins = FALSE;
    BOOLEAN                 fResetDevice = FALSE;
    NTSTATUS                CompletionStatus;

    CompletionStatus = (NTSTATUS) (ULONG_PTR) pClientContext;
    pNameAddr = pTracker->pNameAddr;
    ASSERT(pNameAddr);

    //
    // grab the resource so that a name refresh response cannot start running this
    // code in a different thread before this thread has exited this routine,
    // otherwise the tracker can get dereferenced twice and blown away.
    //
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    LOCATION(0x1);
    // turn on the bit corresponding to this adapter, since the name refresh
    // completed ok
    //
    if (CompletionStatus == STATUS_SUCCESS)
    {
        if (pDeviceContext)
        {
            //
            // turn on the bit corresponding to this adapter, since the name refresh
            // completed ok
            //
            pNameAddr->RefreshMask |= pDeviceContext->AdapterMask;
        }
        fAbleToReachWins = TRUE;
    }
    else if (CompletionStatus == STATUS_TIMEOUT)
    {
        if (pNameAddr->NameTypeState & STATE_CONFLICT)
        {
            if ((!pDeviceContext->IpAddress) ||
                (pDeviceContext->lNameServerAddress == LOOP_BACK))
            {
                //
                // Let us assume we succeeded
                fAbleToReachWins = TRUE;
            }
            else
            {
                pNameAddr->NameTypeState |= REFRESH_FAILED;
            }
        }
    }
    else    // CompletionStatus != STATUS_TIMEOUT
    {
        LOCATION(0x3);
        // if the timer times out and we did not get to the name server, then
        // that is not an error.  However, any other bad status
        // must be a negative response to a name refresh so mark the name
        // in conflict
        //
        pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
        pNameAddr->NameTypeState |= STATE_CONFLICT;
        pNameAddr->ConflictMask |= pDeviceContext->AdapterMask;
        fAbleToReachWins = TRUE;
    }

    // for the multihomed case a failure to reach wins out one of the adapters
    // is not necessarily a failure to reach any WINS.  Since this flag
    // is just an optimization to prevent clients from continually trying to
    // register all of their names if WINS is unreachable, we can ignore the
    // optimization for the multihomed case.  The few nodes that are
    // multihomed will not create that much traffic compared to possibly
    // thousands that are singly homed clients.
    if (NbtConfig.MultiHomed)
    {
        fAbleToReachWins = TRUE;
    }

    LOCATION(0x8);
    //
    // still more adapters to check ...
    //
    // go to the next device context and refresh the name there
    // using the same tracker.
    // look for a device context with a valid IP address since there is
    // no sense in refreshing names out unconnected RAS links.
    //

    if (pDeviceContext)
    {
        //
        // check if any higher bits are set inthe AdapterMask
        //
        AdapterMask = pTracker->pDeviceContext->AdapterMask;
        AdapterMask = AdapterMask << 1;
        pDeviceContext = NULL;
    }
    else
    {
        //
        // The Device we were Refreshing on has gone away, but we don't
        // know which one it was, so ReRefresh!
        //
        AdapterMask = 1;
    }

    //
    // If we have finished refreshing on all devices for this name, get the next name
    //
    if ( (!(AdapterMask) ||
         (AdapterMask > (pNameAddr->AdapterMask & ~pNameAddr->RefreshMask))) )
    {
        // *** clean up the previously refreshed name ***

        // if we failed to reach WINS on the last refresh, stop refreshing
        // until the next time interval. This cuts down on network traffic.
        //
        if (fAbleToReachWins)
        {
            GetNextName(pNameAddr,&pNameAddrNext);
            AdapterMask = 1;
            fResetDevice = TRUE;
        }
        else
        {
            pNameAddrNext = NULL;
        }

        //
        // Dereference the previous address after calling GetNextName
        // since it cause the Name to get free'ed
        //
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NBT_DEREFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_REFRESH);
        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        pNameAddr = pNameAddrNext;
    }

    pHead = &NbtConfig.DeviceContexts;
    while (pNameAddr)
    {
        //
        // Get mask of Adapters left to Refresh on; after that, get the lowest adapter number
        //
        AdapterMask = ~(AdapterMask-1) & (pNameAddr->AdapterMask & ~(pNameAddr->RefreshMask));
        AdapterMask &= ~(AdapterMask - 1);

        //
        // Travel to the actual device for this Adapter number
        //
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pDeviceContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
            //
            // Check if this Device matches the AdapterMask and also has
            // a valid ip address and name server address
            //
            if (pDeviceContext->AdapterMask == AdapterMask)
            {
                if ((pDeviceContext->IpAddress != 0) &&
                    ((pDeviceContext->lNameServerAddress != LOOP_BACK)) ||
                     ((pNameAddr->NameTypeState & STATE_CONFLICT) && (!pNameAddr->ConflictMask)))
                {
                    //
                    // Found a valid device on which this name is registered
                    //
                    IF_DBG(NBT_DEBUG_REFRESH)
                        KdPrint(("Nbt.DelayedNextRefresh: Adapter <%lx:%lx>, Name <%15.15s:%X>\n",
                            AdapterMask,pNameAddr->Name,pNameAddr->Name[15]));

                    pTracker->pDeviceContext = pDeviceContext;

                    // remove the previous timer from the AddressEle since StartRefresh
                    // will start a new timer - safety measure and probably not required!
                    //
                    CHECK_PTR(pNameAddr);
                    pNameAddr->pTimer = NULL;

                    // this call sends out a name registration PDU on a different adapter
                    // to (potentially) a different name server.  The Name service PDU
                    // is the same as the last one though...no need to create a new one.
                    //
                    status = StartRefresh(pNameAddr, pTracker, &OldIrq, fResetDevice);
                    CTESpinFree(&NbtConfig.JointLock,OldIrq);
                    if (!NT_SUCCESS(status))
                    {
                        NBT_DEREFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_REFRESH);
                        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
                        KdPrint(("Nbt.DelayedNextRefresh: ERROR -- Refreshing <%-15.15s:%x>, status=<%X>\n",
                            pNameAddr->Name,pNameAddr->Name[15], status));
                    }

                    goto ExitRoutine;
                }

                //
                // This Device from AdapterMask did not have a valid IP or WINS address
                //
                break;
            }
            else
            {
                pDeviceContext = NULL;
            }

            //
            // Go to next device
            //
            pEntry = pEntry->Flink;
        }

        //
        // If we reached here with a non-NULL pDeviceContext, then it means that
        // the Device did not have a valid IP address or Name Server address
        // otherwise ...
        //
        if (!pDeviceContext)
        {
            //
            //
            // Error case:
            // It could be that an adapter was removed while we were looping
            //
            KdPrint (("Nbt.DelayedNextRefresh:  AdapterMask <%lx:%lx> no longer exists!\n", AdapterMask));
            pNameAddr->AdapterMask &= ~AdapterMask;
            pNameAddr->RefreshMask &= ~AdapterMask;
        }

        //
        // Go to the next adapter
        //
        AdapterMask = AdapterMask << 1;


        //
        // Check if this name has any more adapters on which it can be refreshed
        //
        if ( (!(AdapterMask) ||
             (AdapterMask > (pNameAddr->AdapterMask & ~pNameAddr->RefreshMask))) )
        {
            // *** clean up the previously refreshed name ***

            if (fAbleToReachWins)
            {
                //
                // No more adapters on which to Refresh for the previous name
                // Get the next name in the hash table
                //
                GetNextName(pNameAddr,&pNameAddrNext);
                AdapterMask = 1;
                fResetDevice = TRUE;
                pHead = &NbtConfig.DeviceContexts;
            }
            else
            {
                pNameAddrNext = NULL;
            }

            //
            // Dereference the previous address after calling GetNextName
            // since it cause the Name to get free'ed
            //
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NBT_DEREFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_REFRESH);
            CTESpinLock(&NbtConfig.JointLock,OldIrq);

            pNameAddr = pNameAddrNext;
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (!pNameAddr)
    {
        LOCATION(0x7);
        // we finally delete the tracker here after using it to refresh
        // all of the names.  It is not deleted in the RefreshCompletion
        // routine anymore!
        //
        NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
    }


ExitRoutine:

    CTEExReleaseResource(&NbtConfig.Resource);
}


//----------------------------------------------------------------------------
VOID
WakeupRefreshTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
{
    if (NbtConfig.pWakeupRefreshTimer)
    {
        NbtConfig.pWakeupRefreshTimer = NULL;
        ReRegisterLocalNames (NULL, FALSE);
    }
}

//----------------------------------------------------------------------------
VOID
RefreshTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles is the timeout handler for name refreshes to
    WINS.  It just queues the request to the Executive worker thread so that
    the work can be done at non-dispatch level. If there is currently a
    refresh going on, then the routine simply restarts the timer and
    exits.

Arguments:


Return Value:

    none

--*/
{
    CTELockHandle   OldIrq;

    if (!pTimerQEntry)
    {
        NbtConfig.pRefreshTimer = NULL;
        return;
    }

    CHECK_PTR(pTimerQEntry);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (NodeType & BNODE)
    {
        pTimerQEntry->Flags = 0;    // Do not restart the timer
        NbtConfig.pRefreshTimer = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return;
    }

    if (!(NbtConfig.GlobalRefreshState & NBT_G_REFRESHING_NOW))
    {
        // this is a global flag that prevents a second refresh
        // from starting when one is currently going on.
        //
        
        if (NT_SUCCESS(NTQueueToWorkerThread(NULL, DelayedRefreshBegin,
                                                     NULL, NULL, NULL, NULL, TRUE)))
        {
            NbtConfig.GlobalRefreshState |= NBT_G_REFRESHING_NOW;
        }
    } // doing refresh now

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    // set any new timeout value and restart the timer
    //
    pTimerQEntry->DeltaTime = NbtConfig.MinimumTtl/NbtConfig.RefreshDivisor;
    pTimerQEntry->Flags |= TIMER_RESTART;
}

//----------------------------------------------------------------------------
VOID
DelayedRefreshBegin(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pUnused2,
    IN  PVOID                   pUnused3,
    IN  tDEVICECONTEXT          *pUnused4
    )
/*++

Routine Description:

    This routine handles starting up sending name refreshes to the name server.

    The idea is to set the timeout to T/8 and check for names with the Refresh
    bit cleared - re-registering those names.  At T=4 and T=0, clear all bits
    and refresh all names.  The Inbound code sets the refresh bit when it gets a
    refresh response from the NS.

Arguments:


Return Value:

    none

--*/
{
    CTELockHandle           OldIrq;
    tNAMEADDR               *pNameAddr;
    NTSTATUS                status;
    tHASHTABLE              *pHashTable;
    LONG                    i;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    tDEVICECONTEXT          *pDeviceContext;
    CTEULONGLONG            Adapter;
    BOOLEAN                 fTimeToSwitch = FALSE;
    BOOLEAN                 fTimeToRefresh = FALSE;
    USHORT                  TimeoutsBeforeSwitching;
    ULONG                   TimeoutsBeforeNextRefresh;
    CTESystemTime           CurrentTime;
    ULONG                   TimeoutDelta;
    USHORT                  NumTimeoutIntervals;

    //
    // If the refresh timeout has been set to the maximum value then do
    // not send any refreshes to the name server
    //
    if (NbtConfig.MinimumTtl == NBT_MAXIMUM_TTL)
    {
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
        return;
    }

    LOCATION(0x12);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    CTEQuerySystemTime (CurrentTime);
    ExSystemTimeToLocalTime (&CurrentTime, &CurrentTime);
    TimeoutDelta = NbtConfig.MinimumTtl/NbtConfig.RefreshDivisor;
    NumTimeoutIntervals = (USHORT)
          (((CurrentTime.QuadPart - NbtConfig.LastRefreshTime.QuadPart) + ((LONGLONG)TimeoutDelta*10000/2))
                        / ((LONGLONG)TimeoutDelta*10000)); // in 100 nano second units
    NbtConfig.LastRefreshTime = CurrentTime;

    //
    // NumTimeoutIntervals > 1 if we were sleeping
    //
    if (NumTimeoutIntervals > 1)
    {
        //
        // If we crossed Ttl/2 or Ttl while sleeping, refresh all names
        //
        TimeoutsBeforeNextRefresh = (NbtConfig.RefreshDivisor/2)
                                    - (NbtConfig.sTimeoutCount % (NbtConfig.RefreshDivisor/2));
        NbtConfig.sTimeoutCount += NumTimeoutIntervals;      // Up the timeout count
        //
        // Refresh all of the names if
        // a) we crossed Ttl/2 during sleep, or
        // b) we are within Ttl/4 of the Ttl
        //
        if ((NumTimeoutIntervals > TimeoutsBeforeNextRefresh) ||
            ((NbtConfig.RefreshDivisor-NbtConfig.sTimeoutCount) < (NbtConfig.RefreshDivisor/4)))
        {
            fTimeToRefresh = TRUE;
        }
    }
    else
    {
        NbtConfig.sTimeoutCount++;      // Up the timeout count for this cycle!

        //
        // If it has been over an hour (DEFAULT_SWITCH_TTL) since we last switched,
        // then set fTimeToSwitch = TRUE
        //
        // If MinimumTtl is less than 2 hours, switch immediately. Otherwise, we
        // will never have chance to switch because we start from the very beginning
        // everytime we cross the MinimumTtl/2 (fTimeToRefresh will be TRUE and fTimeToSwitch
        // will be reset to FALSE)
        //
        if (NbtConfig.MinimumTtl > DEFAULT_SWITCH_TTL * 2) {
            TimeoutsBeforeSwitching =(USHORT)((DEFAULT_SWITCH_TTL*NbtConfig.RefreshDivisor)/NbtConfig.MinimumTtl);
        } else {
            TimeoutsBeforeSwitching = (USHORT)(NbtConfig.RefreshDivisor/2);
        }
        fTimeToSwitch = (NbtConfig.sTimeoutCount - NbtConfig.LastSwitchTimeoutCount)
                        >= TimeoutsBeforeSwitching;
        fTimeToRefresh = (NbtConfig.sTimeoutCount >= (NbtConfig.RefreshDivisor/2));

        if (fTimeToSwitch)
        {
            NbtConfig.LastSwitchTimeoutCount = NbtConfig.sTimeoutCount;
        }
    }

    NbtConfig.sTimeoutCount %= NbtConfig.RefreshDivisor;

    //
    // Reset the clock if we are Refreshing everything
    //
    if (fTimeToRefresh)
    {
        NbtConfig.sTimeoutCount = 0;
        if (NbtConfig.MinimumTtl > DEFAULT_SWITCH_TTL * 2) {
            fTimeToSwitch = FALSE;
        }
    }

    //
    // Set some special-case information
    //
    if (0 == NbtConfig.sTimeoutCount)
    {
        NbtConfig.LastSwitchTimeoutCount = 0;
    }

    IF_DBG(NBT_DEBUG_REFRESH)
        KdPrint(("Nbt.DelayedRefreshBegin: fTimeToRefresh=<%d>,fTimeToSwitch=<%d>, MinTtl=<%d>, RefDiv=<%d>\n"
                "TimeoutCount: %d, LastSwTimeoutCount: %d\n",
            fTimeToRefresh, fTimeToSwitch, NbtConfig.MinimumTtl, NbtConfig.RefreshDivisor,
                NbtConfig.sTimeoutCount, NbtConfig.LastSwitchTimeoutCount));

    //
    // go through the local table clearing the REFRESHED bit and sending
    // name refreshes to the name server
    //
    pHashTable = NbtConfig.pLocalHashTbl;
    if (fTimeToRefresh || fTimeToSwitch)
    {
        CTEULONGLONG   ToRefreshMask = 0;
        PLIST_ENTRY pHead1,pEntry1;

        for (i=0 ;i < pHashTable->lNumBuckets ;i++ )
        {
            pHead = &pHashTable->Bucket[i];
            pEntry = pHead->Flink;

            //
            // Go through each name in each bucket of the hashtable
            //
            while (pEntry != pHead)
            {
                pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
                CHECK_PTR(pNameAddr);

                // don't refresh scope names or names in conflict or that are the
                // broadcast name "*    ", or Quick added names.(since these are
                // not registered on the network)
                //
                if (!(pNameAddr->NameTypeState & STATE_RESOLVED) ||
                    (pNameAddr->Name[0] == '*') ||
                    (IsBrowserName(pNameAddr->Name)) ||
                    (pNameAddr->NameTypeState & NAMETYPE_QUICK))
                {
                    pEntry = pEntry->Flink;
                    continue;
                }


                if (fTimeToRefresh)
                {
                    //
                    // Clear the refreshed bits so all names get refreshed if we are
                    // at interval 0 or interval NbtConfig.RefreshDivisor/2
                    //
                    pNameAddr->RefreshMask = 0;
                }

                //
                // Set the ToRefreshMask to include any Devices not Refreshed previously
                //
                ToRefreshMask |= (pNameAddr->AdapterMask & ~pNameAddr->RefreshMask);

                pEntry = pEntry->Flink;         // next hash table entry
            }
        }       // for ( .. pHashTable .. )

        //
        // Go through each adapter checking if a name needs to be Refreshed on this adapter.
        //
        pHead1 = &NbtConfig.DeviceContexts;
        pEntry1 = pHead1->Flink;
        while (pEntry1 != pHead1)
        {
            pDeviceContext = CONTAINING_RECORD(pEntry1,tDEVICECONTEXT,Linkage);
            pEntry1 = pEntry1->Flink;

            //
            // If we are currently switched to the backup, then try
            // to switch back to the primary
            //
            if (pDeviceContext->SwitchedToBackup)
            {
                SwitchToBackup(pDeviceContext);
                pDeviceContext->RefreshToBackup = FALSE;
            }
            else if (!fTimeToSwitch)     // If this is a fresh Refresh cycle, restart from the primary
            {
                pDeviceContext->RefreshToBackup = FALSE;
            }
            else if ((pDeviceContext->AdapterMask & ToRefreshMask) && // do we need to switch on this device
                     (pDeviceContext->lBackupServer != LOOP_BACK))
            {
                pDeviceContext->RefreshToBackup = ~pDeviceContext->RefreshToBackup;
            }
        }
    }

    // always start at the first name in the hash table.  As each name gets
    // refreshed NextRefresh will be hit to get the next name etc..
    //
    NbtConfig.CurrentHashBucket = 0;
    GetNextName(NULL,&pNameAddr);   // get the next(first) name in the hash table

    status = STATUS_UNSUCCESSFUL;
    if (pNameAddr)
    {
        LOCATION(0x13);
        status = StartRefresh(pNameAddr, NULL, &OldIrq, TRUE);

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        //
        // If this routine fails then the address element increment done in
        // GetNextName has to be undone here
        //
        if (!NT_SUCCESS(status))
        {
            NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
            NBT_DEREFERENCE_ADDRESS (pNameAddr->pAddressEle, REF_ADDR_REFRESH);
        }
    }
    else
    {
        NbtConfig.GlobalRefreshState &= ~NBT_G_REFRESHING_NOW;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}


//----------------------------------------------------------------------------
VOID
RemoteHashTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles deleting names in the Remote Hash table that are
    old.  The basic alorithm scans the table looking at the Timed_out bit.
    If it is set then the name is deleted, otherwise the bit is set.  This
    means the names can live as long as 2*Timeout or as little as Timeout.
    So set the Timeout to 6 Minutes and names live 9 minutes +- 3 minutes.

Arguments:


Return Value:

    none

--*/
{
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    tNAMEADDR               *pNameAddr;
    tHASHTABLE              *pHashTable;
    LONG                    i;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pDeviceHead;
    PLIST_ENTRY             pDeviceEntry;
    tDEVICECONTEXT          *pDeviceContext;
    tLOWERCONNECTION        *pLowerConn;
    ULONG                   TimeoutCount;

    if (!pTimerQEntry)
    {
        //
        // The Timer is being cancelled
        //
        NbtConfig.pRemoteHashTimer = NULL;
        return;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // Update the Remote cache timestamp
    //
    NbtConfig.CacheTimeStamp++;

    //
    // go through the remote table deleting names that have timeout bits
    // set and setting the bits for names that have the bit clear
    //
    pHashTable = NbtConfig.pRemoteHashTbl;
    for (i=0;i < pHashTable->lNumBuckets ;i++ )
    {
        pHead = &pHashTable->Bucket[i];
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;
            //
            // do not delete scope entries, and do not delete names that
            // that are still resolving, and do not delete names that are
            // being used by someone (refcount > 1)
            //
            if ((pNameAddr->NameTypeState & (STATE_RESOLVED | STATE_RELEASED)) &&
                (pNameAddr->RefCount <= 1))
            {
                if ((pNameAddr->TimeOutCount == 0) ||
                    ((pContext == NbtConfig.pRemoteHashTbl) &&
                     !(pNameAddr->NameTypeState & NAMETYPE_SCOPE)))
                {
                    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
                }
                else if (!(pNameAddr->NameTypeState & NAMETYPE_SCOPE))
                {
                    pNameAddr->TimeOutCount--;
                }
            }
        }
    }

    // *** Inbound Connections Cleanup *** //

    //
    // Go through each Device and cleanup any lingering connections waiting in the Inbound state
    // Start with the SmbDevice
    //
    pDeviceHead = pDeviceEntry = &NbtConfig.DeviceContexts;
    if (pNbtSmbDevice)
    {
        pDeviceContext = pNbtSmbDevice;
    }
    else if ((pDeviceEntry = pDeviceEntry->Flink) != pDeviceHead)
    {
        pDeviceContext = CONTAINING_RECORD(pDeviceEntry,tDEVICECONTEXT,Linkage);
    }
    else
    {
        pDeviceContext = NULL;
    }

    while (pDeviceContext)
    {
        CTESpinLock(pDeviceContext,OldIrq1);

        //
        // Set the timeout based on the Resource usage!
        //
        if (pDeviceContext->NumWaitingForInbound > NbtConfig.MaxBackLog)
        {
            TimeoutCount = MIN_INBOUND_STATE_TIMEOUT / REMOTE_HASH_TIMEOUT;    // Minimum Timeout value
        }
        else if (pDeviceContext->NumWaitingForInbound > NbtConfig.MaxBackLog/2)
        {
            TimeoutCount = MED_INBOUND_STATE_TIMEOUT / REMOTE_HASH_TIMEOUT;    // Medium Timeout value
        }
        else
        {
            TimeoutCount = MAX_INBOUND_STATE_TIMEOUT / REMOTE_HASH_TIMEOUT;    // Maximum Timeout Value
        }

        //
        // Now go through the list of Inbound connections and see if
        // we need to cleanup any that have lingering around for too long!
        //
        pHead = &pDeviceContext->WaitingForInbound;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pLowerConn = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);
            pEntry = pEntry->Flink;

            pLowerConn->TimeUnitsInLastState++;

            if (pLowerConn->TimeUnitsInLastState > TimeoutCount)
            {
                RemoveEntryList (&pLowerConn->Linkage);
                InitializeListHead (&pLowerConn->Linkage);
                SET_STATE_LOWER(pLowerConn, NBT_IDLE);  // so that Inbound doesn't start processing it!
                if (pLowerConn->SpecialAlloc)
                {
                    InterlockedDecrement(&pLowerConn->pDeviceContext->NumSpecialLowerConn);
                }
                else
                {
                    NTQueueToWorkerThread(
                                    NULL,
                                    DelayedAllocLowerConn,
                                    NULL,
                                    NULL,
                                    NULL,
                                    pLowerConn->pDeviceContext,
                                    TRUE
                                    );
                }

                ASSERT (pLowerConn->RefCount == 2);
                NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_WAITING_INBOUND, TRUE); // RefCount: 2 -> 1
                NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_CREATE, TRUE); // Close all the Tcp handles
                InterlockedDecrement (&pDeviceContext->NumWaitingForInbound);
            }
        }       // pDeviceContext->WaitingForInbound List

        CTESpinFree(pDeviceContext,OldIrq1);

        if ((pDeviceEntry = pDeviceEntry->Flink) != pDeviceHead)
        {
            pDeviceContext = CONTAINING_RECORD(pDeviceEntry,tDEVICECONTEXT,Linkage);
        }
        else
        {
            pDeviceContext = NULL;
        }
    }           // NbtConfig.DeviceContexts List

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    // restart the timer
    //
    pTimerQEntry->Flags |= TIMER_RESTART;

    return;
}
//----------------------------------------------------------------------------
VOID
NextKeepAlive(
    IN  tDGRAM_SEND_TRACKING     *pTracker,
    IN  NTSTATUS                 status,
    IN  ULONG                    Info
    )
/*++

Routine Description:

    This routine handles sending subsequent KeepAlives for sessions.
    This is the "Client Completion" routine of the TdiSend that sends the
    keep alive on the session.

Arguments:


Return Value:

    none

--*/
{
    tLOWERCONNECTION        *pLowerConnLast;
    tLOWERCONNECTION        *pLowerConn;
    tDEVICECONTEXT          *pDeviceContext;

    PUSH_LOCATION(0x92);
    pDeviceContext = pTracker->pDeviceContext;
    pLowerConnLast = (tLOWERCONNECTION *)pTracker->pClientEle;

    // get the next session to send a keep alive on, if there is one, otherwise
    // free the session header block.
    //
    GetNextKeepAlive (pDeviceContext, &pDeviceContext, pLowerConnLast, &pLowerConn, pTracker);

    NBT_DEREFERENCE_LOWERCONN (pLowerConnLast, REF_LOWC_KEEP_ALIVE, FALSE);
    status = STATUS_UNSUCCESSFUL;

    if (pLowerConn)
    {
        pTracker->pDeviceContext = pDeviceContext;
        pTracker->pClientEle = (tCLIENTELE *)pLowerConn;

        ASSERT((pTracker->SendBuffer.HdrLength + pTracker->SendBuffer.Length) == 4);
        PUSH_LOCATION(0x91);
#ifndef VXD
        // this may wind up the stack if the completion occurs synchronously,
        // because the completion routine is this routine, so call a routine
        // that sets up a dpc to to the send, which will not run until this
        // procedure returns and we get out of raised irql.
        //
        status = NTSendSession (pTracker, pLowerConn, NextKeepAlive);
#else
        (void) TcpSendSession (pTracker, pLowerConn, NextKeepAlive);
        status = STATUS_SUCCESS;
#endif
    }

    if (!NT_SUCCESS(status))
    {
        if (pLowerConn)
        {
            NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_KEEP_ALIVE, FALSE);
        }

        FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);
    }
}


//----------------------------------------------------------------------------
VOID
GetNextKeepAlive(
    tDEVICECONTEXT          *pDeviceContext,
    tDEVICECONTEXT          **ppDeviceContextOut,
    tLOWERCONNECTION        *pLowerConnIn,
    tLOWERCONNECTION        **ppLowerConnOut,
    tDGRAM_SEND_TRACKING    *pTracker
    )
/*++

Routine Description:

    This routine handles sending session keep Alives to the other end of a
    connection about once a minute or so.

Arguments:


Return Value:

    none

--*/
{
    CTELockHandle           OldIrq;
    CTELockHandle           OldIrq1;
    CTELockHandle           OldIrq2;
    tLOWERCONNECTION        *pLowerConn;
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pHeadDevice;
    PLIST_ENTRY             pEntryDevice;
    NTSTATUS                status;
    tDEVICECONTEXT          *pEntryDeviceContext;

    *ppLowerConnOut = NULL;

    //
    // loop through all the adapter cards looking at all connections
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    //
    // Verify that the Device passed in is a valid device,
    // otherwise either pick the next Device, or fail
    //
    status = STATUS_UNSUCCESSFUL;
    pEntryDevice = pHeadDevice = &NbtConfig.DeviceContexts;
    while ((pEntryDevice = pEntryDevice->Flink) != pHeadDevice)
    {
        pEntryDeviceContext = CONTAINING_RECORD(pEntryDevice,tDEVICECONTEXT,Linkage);
        if ((pEntryDeviceContext == pDeviceContext) ||
            (pEntryDeviceContext->AdapterNumber > pTracker->RCount))
        {
            if (pEntryDeviceContext != pDeviceContext)
            {
                pLowerConnIn = NULL;
            }
            pDeviceContext = pEntryDeviceContext;
            status = STATUS_SUCCESS;
            break;
        }
    }

    if (!NT_SUCCESS(status))
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return;
    }

    pEntryDevice = &pDeviceContext->Linkage;
    while (pEntryDevice != pHeadDevice)
    {
        pDeviceContext = CONTAINING_RECORD(pEntryDevice,tDEVICECONTEXT,Linkage);
        pEntryDevice = pEntryDevice->Flink;

        // grab the device context spin lock so that the lower connection
        // element does not get removed from the Q while we are checking the
        // connection state
        //
        CTESpinLock(pDeviceContext,OldIrq);
        pHead = &pDeviceContext->LowerConnection;
        //
        // get the next lower connection after this one one the list, but
        // be sure this connection is still on the active list by checking
        // the state.
        //
        // If this connection has been cleaned up in OutOfRsrcKill, then dont trust the linkages.
        //
        if (pLowerConnIn &&
            (!pLowerConnIn->OutOfRsrcFlag || !pLowerConnIn->bNoOutRsrcKill) &&
            ((pLowerConnIn->State == NBT_SESSION_UP) ||
             (pLowerConnIn->State == NBT_SESSION_INBOUND)))
        {
            pEntry = pLowerConnIn->Linkage.Flink;
            pLowerConnIn = NULL;
        }
        else
        {
            pEntry = pHead->Flink;
        }

        while (pEntry != pHead)
        {
            pLowerConn = CONTAINING_RECORD(pEntry,tLOWERCONNECTION,Linkage);

            //
            // Inbound connections can hang around forever in that state if
            // the session setup message never gets sent, so send keep
            // alives on those too.
            //
            if ((pLowerConn->State == NBT_SESSION_UP) ||
                (pLowerConn->State == NBT_SESSION_INBOUND))
            {

                // grab the spin lock, recheck the state and
                // increment the reference count so that this connection cannot
                // disappear while the keep alive is being sent and mess up
                // the linked list.
                CTESpinLock(pLowerConn,OldIrq2);
                if ((pLowerConn->State != NBT_SESSION_UP ) &&
                    (pLowerConn->State != NBT_SESSION_INBOUND))
                {
                    // this connection is probably back on the free connection
                    // list, so we will never satisfy the pEntry = pHead and
                    // loop forever, so just get out and send keepalives on the
                    // next timeout
                    //
                    pEntry = pEntry->Flink;
                    PUSH_LOCATION(0x91);
                    CTESpinFree(pLowerConn,OldIrq2);
                    break;

                }
                else if (pLowerConn->RefCount >= 3 )
                {
                    //
                    // already a keep alive on this connection, or we
                    // are currently in the receive handler and do not
                    // need to send a keep alive.
                    //
                    pEntry = pEntry->Flink;
                    PUSH_LOCATION(0x93);
                    CTESpinFree(pLowerConn,OldIrq2);
                    continue;
                }

                //
                // found a connection to send a keep alive on
                //
                NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_KEEP_ALIVE);
                //
                // return the current position in the list of connections
                //
                pTracker->RCount = pDeviceContext->AdapterNumber;
                *ppLowerConnOut = pLowerConn;
                *ppDeviceContextOut = pDeviceContext;

                CTESpinFree(pLowerConn,OldIrq2);
                CTESpinFree(pDeviceContext,OldIrq);
                CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                return;
            }

            pEntry = pEntry->Flink;
        }

        CTESpinFree(pDeviceContext,OldIrq);
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    return;

}

//----------------------------------------------------------------------------
VOID
SessionKeepAliveTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine handles starting the non dispatch level routine to send
    keep alives.

Arguments:


Return Value:

    none

--*/
{
    if (!pTimerQEntry)
    {
        NbtConfig.pSessionKeepAliveTimer = NULL;
        return;
    }

    CHECK_PTR(pTimerQEntry);
    if (!NT_SUCCESS(NTQueueToWorkerThread(NULL, DelayedSessionKeepAlive,
                                                 NULL, NULL, NULL, NULL, FALSE)))
    {
        IF_DBG(NBT_DEBUG_REFRESH)
            KdPrint (("Nbt.SessionKeepAliveTimeout: Failed to Queue DelayedSessionKeepAlive!!!\n"));
    }

    // restart the timer
    //
    pTimerQEntry->Flags |= TIMER_RESTART;

    return;
}

//----------------------------------------------------------------------------
VOID
DelayedSessionKeepAlive(
    IN  tDGRAM_SEND_TRACKING    *Unused1,
    IN  PVOID                   Unused2,
    IN  PVOID                   Unused3,
    IN  tDEVICECONTEXT          *pUnused4
    )
/*++

Routine Description:

    This routine handles sending session keep Alives to the other end of a
    connection about once a minute or so.

Arguments:


Return Value:

    none

--*/
{
    NTSTATUS                status;
    tLOWERCONNECTION        *pLowerConn;
    tDEVICECONTEXT          *pDeviceContext;
    tSESSIONHDR             *pSessionHdr;
    tDGRAM_SEND_TRACKING    *pTracker;


    CTEPagedCode();

    if (!(pSessionHdr = (tSESSIONHDR *)NbtAllocMem(sizeof(tSESSIONERROR),NBT_TAG('S'))))
    {
        return;
    }

    // get a tracker structure, which has a SendInfo structure in it
    if (!NT_SUCCESS(status = GetTracker(&pTracker, NBT_TRACKER_KEEP_ALIVE)))
    {
        CTEMemFree((PVOID)pSessionHdr);
        return;
    }

    //
    // go through the list of connections attached to each adapter and
    // send a session keep alive pdu on each
    //
    pDeviceContext = CONTAINING_RECORD(NbtConfig.DeviceContexts.Flink,
                                        tDEVICECONTEXT,Linkage);

    // get the next session to send a keep alive on, if there is one, otherwise
    // free the session header block.
    //
    pTracker->RCount = 0;       // This field keeps track of the last device
    GetNextKeepAlive(pDeviceContext, &pDeviceContext, NULL, &pLowerConn, pTracker);
    if (pLowerConn)
    {
        // if we have found a connection, send the first keep alive.  Subsequent
        // keep alives will be sent by the completion routine, NextKeepAlive()
        //
        CHECK_PTR(pTracker);
        pTracker->SendBuffer.pDgramHdr = (PVOID)pSessionHdr;
        pTracker->SendBuffer.HdrLength = sizeof(tSESSIONHDR);
        pTracker->SendBuffer.Length  = 0;
        pTracker->SendBuffer.pBuffer = NULL;

        pSessionHdr->Flags = NBT_SESSION_FLAGS; // always zero

        pTracker->pDeviceContext = pDeviceContext;
        pTracker->pClientEle = (tCLIENTELE *)pLowerConn;
        CHECK_PTR(pSessionHdr);
        pSessionHdr->Type = NBT_SESSION_KEEP_ALIVE;     // 85
        pSessionHdr->Length = 0;        // no data following the length byte

        status = TcpSendSession(pTracker, pLowerConn, NextKeepAlive);
    }
    else
    {
        CTEMemFree((PVOID)pSessionHdr);
        FreeTracker (pTracker, RELINK_TRACKER);
    }
}


//----------------------------------------------------------------------------
VOID
IncrementNameStats(
    IN ULONG           StatType,
    IN BOOLEAN         IsNameServer
    )
/*++

Routine Description:

    This routine increments statistics on names that resolve either through
    the WINS or through broadcast.

Arguments:


Return Value:

    none

--*/
{

    //
    // Increment the stattype if the name server is true, that way we can
    // differentiate queries and registrations to the name server or not.
    //
    if (IsNameServer)
    {
        StatType += 2;
    }

    NameStatsInfo.Stats[StatType]++;

}
//----------------------------------------------------------------------------
VOID
SaveBcastNameResolved(
    IN PUCHAR          pName
    )
/*++

Routine Description:

    This routine saves the name in LIFO list, so we can see the last
    N names that resolved via broadcast.

Arguments:


Return Value:

    none

--*/
{
    ULONG                   Index;

    Index = NameStatsInfo.Index;

    CTEMemCopy(&NameStatsInfo.NamesReslvdByBcast[Index],
               pName,
               NETBIOS_NAME_SIZE);

    NameStatsInfo.Index++;
    if (NameStatsInfo.Index >= SIZE_RESOLVD_BY_BCAST_CACHE)
    {
        NameStatsInfo.Index = 0;
    }

}

//
// These are names that should never be sent to WINS.
//
BOOL
IsBrowserName(
	IN PCHAR pName
)
{
	CHAR cNameType = pName[NETBIOS_NAME_SIZE - 1];

	return (
		(cNameType == 0x1E)
		|| (cNameType == 0x1D)
		|| (cNameType == 0x01)
		);
}

//
// Returns the node type that should be used with a request,
// based on NetBIOS name type.  This is intended to help the
// node to behave like a BNODE for browser names only.
//
AppropriateNodeType(
	IN PCHAR pName,
	IN ULONG NodeType
)
{
	ULONG LocalNodeType = NodeType;

	if (LocalNodeType & BNODE)
	{
		if ( IsBrowserName ( pName ) )
		{
			LocalNodeType &= BNODE;
		}
	}
	return LocalNodeType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\init.c ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    Init.c

    OS Independent initialization routines



    FILE HISTORY:
        Johnl   26-Mar-1993     Created
*/


#include "nbtnt.h"
#include "precomp.h"
#include "hosts.h"

VOID
ReadScope(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    );

VOID
ReadLmHostFile(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    );

extern  tTIMERQ TimerQ;

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(INIT, InitNotOs)
#pragma CTEMakePageable(PAGE, InitTimersNotOs)
#pragma CTEMakePageable(PAGE, StopInitTimers)
#pragma CTEMakePageable(PAGE, ReadParameters)
#pragma CTEMakePageable(PAGE, ReadParameters2)
#pragma CTEMakePageable(PAGE, ReadScope)
#pragma CTEMakePageable(PAGE, ReadLmHostFile)
#endif
//*******************  Pageable Routine Declarations ****************

#ifdef VXD
#pragma BEGIN_INIT
#endif

//----------------------------------------------------------------------------
NTSTATUS
InitNotOs(
    void
    )

/*++

Routine Description:

    This is the initialization routine for the Non-OS Specific side of the
    NBT device driver.

    pNbtGlobConfig must be initialized before this is called!

Arguments:

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               i;


    CTEPagedCode();

    //
    // for multihomed hosts, this tracks the number of adapters as each one
    // is created.
    //
    NbtMemoryAllocated = 0;

    NbtConfig.AdapterCount = 0;
    NbtConfig.MultiHomed = FALSE;
    NbtConfig.SingleResponse = FALSE;
    NbtConfig.ServerMask = 0;
    NbtConfig.ClientMask = 0;
    NbtConfig.iCurrentNumBuff[eNBT_DGRAM_TRACKER] = 0;
    pNbtGlobConfig->iBufferSize[eNBT_DGRAM_TRACKER] = sizeof(tDGRAM_SEND_TRACKING);
    CTEZeroMemory (&NameStatsInfo,sizeof(tNAMESTATS_INFO));     // Initialize the name statistics
    CTEZeroMemory (&LmHostQueries,sizeof(tLMHSVC_REQUESTS));    // Synchronize reads from the LmHosts file
    InitializeListHead (&LmHostQueries.ToResolve);


    //
    // Initialize the linked lists associated with the global configuration
    // data structures
    //
    InitializeListHead (&NbtConfig.DeviceContexts);
    InitializeListHead (&NbtConfig.DevicesAwaitingDeletion);
    InitializeListHead (&NbtConfig.AddressHead);
    InitializeListHead (&NbtConfig.PendingNameQueries);
    NbtConfig.lNumPendingNameQueries = 0;
    InitializeListHead (&NbtConfig.WorkerQList);
    InitializeListHead (&NbtConfig.NodeStatusHead);
    InitializeListHead (&NbtConfig.DgramTrackerFreeQ);
    InitializeListHead (&UsedTrackers);
    InitializeListHead (&UsedIrps);
    InitializeListHead (&DomainNames.DomainList);

    // initialize the spin lock
    CTEInitLock (&NbtConfig.LockInfo.SpinLock);
    CTEInitLock (&NbtConfig.JointLock.LockInfo.SpinLock);
    CTEInitLock (&NbtConfig.WorkerQLock.LockInfo.SpinLock);

#ifndef VXD
    pWinsInfo = NULL;
    NbtConfig.NumWorkItemQueued = 0;
    NbtConfig.bSystemWorkThreadQueued = FALSE;
    NbtConfig.lNumTimersRunning = 0;
    NbtConfig.CacheTimeStamp = 0;
    NbtConfig.InterfaceIndex = 0;
    NbtConfig.GlobalRefreshState = 0;
    NbtConfig.pWakeupRefreshTimer = NULL;
    NbtConfig.TransactionId = WINS_MAXIMUM_TRANSACTION_ID + 1;
    NbtConfig.RemoteCacheLen = REMOTE_CACHE_INCREMENT;
    NbtConfig.iBufferSize[eNBT_FREE_SESSION_MDLS] = sizeof(tSESSIONHDR);

    //
    // Set the Unitialized flag in the TimerQ, so that it can be initialized
    // when needed
    //
    TimerQ.TimersInitialized = FALSE;

    // Initialize the LastForcedReleaseTime!
    CTEQuerySystemTime (NbtConfig.LastForcedReleaseTime);
    CTEQuerySystemTime (NbtConfig.LastOutOfRsrcLogTime);
    CTEQuerySystemTime (NbtConfig.LastRefreshTime);
    ExSystemTimeToLocalTime (&NbtConfig.LastRefreshTime, &NbtConfig.LastRefreshTime);

    //
    // this resource is used to synchronize access to the Dns structure
    //
    CTEZeroMemory (&DnsQueries,sizeof(tLMHSVC_REQUESTS));
    InitializeListHead (&DnsQueries.ToResolve);
    //
    // this resource is used to synchronize access to the CheckAddr structure
    //
    CTEZeroMemory(&CheckAddr,sizeof(tLMHSVC_REQUESTS));
    InitializeListHead (&CheckAddr.ToResolve);

    //
    // Setup the default disconnect timeout - 10 seconds - convert
    // to negative 100 Ns.
    //
    DefaultDisconnectTimeout.QuadPart = Int32x32To64(DEFAULT_DISC_TIMEOUT, MILLISEC_TO_100NS);
    DefaultDisconnectTimeout.QuadPart = -(DefaultDisconnectTimeout.QuadPart);

    InitializeListHead (&FreeWinsList);
    // set up a list for connections when we run out of resources and need to
    // disconnect these connections. An Irp is also needed for this list, and
    // it is allocated in Driver.C after we have created the connections to the
    // transport and therefore know our Irp Stack Size.
    //
    InitializeListHead (&NbtConfig.OutOfRsrc.ConnectionHead);

    KeInitializeEvent (&NbtConfig.TimerQLastEvent, NotificationEvent, TRUE);
    KeInitializeEvent (&NbtConfig.WakeupTimerStartedEvent, NotificationEvent, TRUE);

    // use this resources to synchronize access to the security info between
    // assigning security and checking it - when adding names to the
    // name local name table through NbtregisterName.  This also insures
    // that the name is in the local hash table (from a previous Registration)
    // before the next registration is allowed to proceed and check for
    // the name in the table.
    //
    ExInitializeResourceLite(&NbtConfig.Resource);
#else
    DefaultDisconnectTimeout = DEFAULT_DISC_TIMEOUT * 1000; // convert to milliseconds

    InitializeListHead(&NbtConfig.SendTimeoutHead) ;
    InitializeListHead(&NbtConfig.SessionBufferFreeList) ;
    InitializeListHead(&NbtConfig.SendContextFreeList) ;
    InitializeListHead(&NbtConfig.RcvContextFreeList) ;

    //
    //  For session headers, since they are only four bytes and we can't
    //  change the size of the structure, we'll covertly add enough for
    //  a full LIST_ENTRY and treat it like a standalone LIST_ENTRY structure
    //  when adding and removing from the list.
    //
    NbtConfig.iBufferSize[eNBT_SESSION_HDR]  = sizeof(tSESSIONHDR) + sizeof(LIST_ENTRY) - sizeof(tSESSIONHDR);
    NbtConfig.iBufferSize[eNBT_SEND_CONTEXT] = sizeof(TDI_SEND_CONTEXT);
    NbtConfig.iBufferSize[eNBT_RCV_CONTEXT]  = sizeof(RCV_CONTEXT);
    NbtConfig.iCurrentNumBuff[eNBT_SESSION_HDR]    = NBT_INITIAL_NUM;
    NbtConfig.iCurrentNumBuff[eNBT_SEND_CONTEXT]   = NBT_INITIAL_NUM;
    NbtConfig.iCurrentNumBuff[eNBT_RCV_CONTEXT]    = NBT_INITIAL_NUM;

    InitializeListHead (&NbtConfig.DNSDirectNameQueries);
#endif

#if DBG
    NbtConfig.LockInfo.LockNumber = NBTCONFIG_LOCK;
    NbtConfig.JointLock.LockInfo.LockNumber = JOINT_LOCK;
    NbtConfig.WorkerQLock.LockInfo.LockNumber = WORKERQ_LOCK;
    for (i=0; i<MAXIMUM_PROCESSORS; i++)
    {
        NbtConfig.CurrentLockNumber[i] = 0;
    }
    InitializeListHead(&NbtConfig.StaleRemoteNames);
#endif

    //
    // create trackers List
    //
// #if DBG
    for (i=0; i<NBT_TRACKER_NUM_TRACKER_TYPES; i++)
    {
        TrackTrackers[i] = 0;
        TrackerHighWaterMark[i] = 0;
    }
// #endif   // DBG

    //
    // Now allocate any initial memory/Resources
    //
#ifdef VXD
    status = NbtInitQ (&NbtConfig.SessionBufferFreeList,
                       NbtConfig.iBufferSize[eNBT_SESSION_HDR],
                       NBT_INITIAL_NUM);
    if (!NT_SUCCESS (status))
    {
        return status ;
    }

    status = NbtInitQ( &NbtConfig.SendContextFreeList,
                       sizeof( TDI_SEND_CONTEXT ),
                       NBT_INITIAL_NUM);
    if (!NT_SUCCESS (status))
    {
        return status ;
    }

    status = NbtInitQ( &NbtConfig.RcvContextFreeList,
                       sizeof (RCV_CONTEXT),
                       NBT_INITIAL_NUM);
    if (!NT_SUCCESS (status))
    {
        return status ;
    }
#endif

    // create the hash tables for storing names in.
    status = CreateHashTable(&NbtConfig.pLocalHashTbl, NbtConfig.uNumBucketsLocal, NBT_LOCAL);
    if (!NT_SUCCESS (status))
    {
        ASSERTMSG("NBT:Unable to create hash tables for Netbios Names\n", (status == STATUS_SUCCESS));
        return status ;
    }

    // we always have a remote hash table, but if we are a Proxy, it is
    // a larger table. In the Non-proxy case the remote table just caches
    // names resolved with the NS.  In the Proxy case it also holds names
    // resolved for all other clients on the local broadcast area.
    // The node size registry parameter controls the number of remote buckets.
    status = CreateHashTable (&NbtConfig.pRemoteHashTbl, NbtConfig.uNumBucketsRemote, NBT_REMOTE);
    NbtConfig.NumNameCached = 0;
    if (!NT_SUCCESS (status))
    {
        return status;
    }

    status = NbtInitTrackerQ (NBT_INITIAL_NUM);
    if (!NT_SUCCESS (status))
    {
        return status;
    }

    // create the timer control blocks, setting the number of concurrent timers
    // allowed at one time
    status = InitTimerQ ();

    return status;
}

//----------------------------------------------------------------------------
NTSTATUS
InitTimersNotOs(
    void
    )

/*++

Routine Description:

    This is the initialization routine for the Non-OS Specific side of the
    NBT device driver that starts the timers needed.

Arguments:

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS            status = STATUS_SUCCESS;

    CTEPagedCode();

    //
    // If the timers have already been initialized, return success
    //
    if (TimerQ.TimersInitialized)
    {
        return STATUS_SUCCESS;
    }

    NbtConfig.pRefreshTimer = NULL;
    NbtConfig.pRemoteHashTimer = NULL;
    NbtConfig.pSessionKeepAliveTimer = NULL;
    NbtConfig.RefreshDivisor = REFRESH_DIVISOR;

    if (!NT_SUCCESS(status))
    {
        return status ;
    }

    // start a Timer to refresh names with the name service
    //
    if (!(NodeType & BNODE))
    {

        // the initial refresh rate until we can contact the name server
        NbtConfig.MinimumTtl = NbtConfig.InitialRefreshTimeout;
        NbtConfig.sTimeoutCount = 3;

        status = StartTimer(RefreshTimeout,
                            NbtConfig.InitialRefreshTimeout/REFRESH_DIVISOR,
                            NULL,            // context value
                            NULL,            // context2 value
                            NULL,
                            NULL,
                            NULL,           // This timer is a global timer
                            &NbtConfig.pRefreshTimer,
                            0,
                            FALSE);

        if ( !NT_SUCCESS(status))
        {
            return status;
        }
    }

    //
    // Set the TimersInitialized flag
    //
    TimerQ.TimersInitialized = TRUE;

    // calculate the count necessary to timeout out names in RemoteHashTimeout
    // milliseconds
    //
    NbtConfig.RemoteTimeoutCount = (USHORT)((NbtConfig.RemoteHashTtl/REMOTE_HASH_TIMEOUT));
    if (NbtConfig.RemoteTimeoutCount == 0)
    {
        NbtConfig.RemoteTimeoutCount = 1;
    }
    NbtConfig.InboundDgramNameCacheTimeOutCount =
                    (USHORT)((NbtConfig.InboundDgramNameCacheTtl/REMOTE_HASH_TIMEOUT));
    if (0 == NbtConfig.InboundDgramNameCacheTimeOutCount) {
        NbtConfig.InboundDgramNameCacheTimeOutCount = 1;
    }

    // start a Timer to timeout remote cached names from the Remote hash table.
    // The timer is a one minute timer, and the hash entries count down to zero
    // then time out.
    //
    status = StartTimer(RemoteHashTimeout,  // timer expiry routine
                        REMOTE_HASH_TIMEOUT,
                        NULL,            // context value
                        NULL,            // context2 value
                        NULL,
                        NULL,
                        NULL,           // This timer is a global timer
                        &NbtConfig.pRemoteHashTimer,
                        0,
                        FALSE);

    if ( !NT_SUCCESS( status ) )
    {
        StopInitTimers();
        return status ;
    }

    // start a Timer for Session Keep Alives which sends a session keep alive
    // on a connection if the timer value is not set to -1
    //
    if (NbtConfig.KeepAliveTimeout != -1)
    {
        status = StartTimer(SessionKeepAliveTimeout,  // timer expiry routine
                            NbtConfig.KeepAliveTimeout,
                            NULL,            // context value
                            NULL,            // context2 value
                            NULL,
                            NULL,
                            NULL,           // This timer is a global timer
                            &NbtConfig.pSessionKeepAliveTimer,
                            0,
                            FALSE);

        if ( !NT_SUCCESS( status ) )
        {
            StopInitTimers();
            return status ;
        }
    }

    return(STATUS_SUCCESS);
}
//----------------------------------------------------------------------------
NTSTATUS
StopInitTimers(
    VOID
    )

/*++

Routine Description:

    This is stops the timers started in InitTimerNotOS

Arguments:

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    CTEPagedCode();

    //
    // If the timers have already been stopped, return success
    //
    if (!TimerQ.TimersInitialized)
    {
        return STATUS_SUCCESS;
    }

    //
    // Set the TimersInitialized flag to FALSE
    //
    TimerQ.TimersInitialized = FALSE;

    if (NbtConfig.pRefreshTimer)
    {
        StopTimer(NbtConfig.pRefreshTimer,NULL,NULL);
    }
    if (NbtConfig.pSessionKeepAliveTimer)
    {
        StopTimer(NbtConfig.pSessionKeepAliveTimer,NULL,NULL);
    }
    if (NbtConfig.pRemoteHashTimer)
    {
        StopTimer(NbtConfig.pRemoteHashTimer,NULL,NULL);
    }

    return(STATUS_SUCCESS);
}

WORD
NbtGetProductType(void)
{
    RTL_OSVERSIONINFOEXW    OsVer = { 0 };
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    OsVer.dwOSVersionInfoSize = sizeof(OsVer);
    status = RtlGetVersion((PRTL_OSVERSIONINFOW)&OsVer);
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    return OsVer.wProductType;
}

BOOL
IsDomainController(void)
/*++

Routine Description:

    Return TRUE if this machine is a DC.

Arguments:

Return Value:

--*/
{
    return (NbtGetProductType() == VER_NT_DOMAIN_CONTROLLER);
}

//----------------------------------------------------------------------------
VOID
ReadParameters(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    )

/*++

Routine Description:

    This routine is called to read various parameters from the parameters
    section of the NBT section of the registry.

Arguments:

    pConfig     - A pointer to the configuration data structure.
    ParmHandle  - a handle to the parameters Key under Nbt

Return Value:

    Status

--*/

{
    ULONG           NodeSize;
    ULONG           Refresh;
    BOOL            UseNewSmb;

    CTEPagedCode();

    ReadParameters2(pConfig, ParmHandle);

    pConfig->NameServerPort =  (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                                     WS_NS_PORT_NUM,
                                                     NBT_NAMESERVER_UDP_PORT,
                                                     0);

    pConfig->MaxPreloadEntries = CTEReadSingleIntParameter(ParmHandle,
                                       WS_MAX_PRELOADS,
                                       DEF_PRELOAD,
                                       DEF_PRELOAD ) ;

    if (pConfig->MaxPreloadEntries > MAX_PRELOAD)
    {
      pConfig->MaxPreloadEntries = MAX_PRELOAD;
    }

#ifdef VXD
    pConfig->DnsServerPort =  (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                                     WS_DNS_PORT_NUM,
                                                     NBT_DNSSERVER_UDP_PORT,
                                                     0);

    pConfig->lRegistryMaxNames = (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                       VXD_NAMETABLE_SIZE_NAME,
                                       VXD_DEF_NAMETABLE_SIZE,
                                       VXD_MIN_NAMETABLE_SIZE ) ;

    pConfig->lRegistryMaxSessions = (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                       VXD_SESSIONTABLE_SIZE_NAME,
                                       VXD_DEF_SESSIONTABLE_SIZE,
                                       VXD_MIN_SESSIONTABLE_SIZE ) ;

    pConfig->DoDNSDevolutions =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_DO_DNS_DEVOLUTIONS,
                                               0,   // disabled by default
                                               0);
#endif

    pConfig->RemoteHashTtl =  CTEReadSingleIntParameter(ParmHandle,
                                                     WS_CACHE_TIMEOUT,
                                                     DEFAULT_CACHE_TIMEOUT,
                                                     MIN_CACHE_TIMEOUT);
    pConfig->InitialRefreshTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                                     WS_INITIAL_REFRESH,
                                                     NBT_INITIAL_REFRESH_TTL,
                                                     NBT_INITIAL_REFRESH_TTL);

    pConfig->MinimumRefreshSleepTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                                     WS_MINIMUM_REFRESH_SLEEP_TIME,
                                                     DEFAULT_MINIMUM_REFRESH_SLEEP_TIME,
                                                     0);

    if (IsDomainController()) {
        pConfig->InboundDgramNameCacheTtl =  CTEReadSingleIntParameter(ParmHandle,
                                                         WS_INBOUND_DGRAM_NAME_CACHE_TIMEOUT,
                                                         DEFAULT_DC_INBOUND_DGRAM_NAME_CACHE_TIMEOUT,
                                                         MIN_INBOUND_DGRAM_NAME_CACHE_TIMEOUT);
    } else {
        pConfig->InboundDgramNameCacheTtl =  CTEReadSingleIntParameter(ParmHandle,
                                                         WS_INBOUND_DGRAM_NAME_CACHE_TIMEOUT,
                                                         DEFAULT_INBOUND_DGRAM_NAME_CACHE_TIMEOUT,
                                                         MIN_INBOUND_DGRAM_NAME_CACHE_TIMEOUT);
    }


    {
        CTESystemTime   TimeValue;

        CTEQuerySystemTime(TimeValue);
        pConfig->RandomNumberSeed = RandomizeFromTime( TimeValue, 0x20000) ;
    }

    pConfig->MaxNumNameCached = CTEReadSingleIntParameter(ParmHandle,
                                                    WS_MAX_NUM_NAME_CACHE,
                                                    pConfig->InboundDgramNameCacheTtl / 3,
                                                    pConfig->InboundDgramNameCacheTtl / 20);

    // retry timeouts and number of retries for both Broadcast name resolution
    // and Name Service resolution
    //
    pConfig->uNumBcasts =  (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                                     WS_NUM_BCASTS,
                                                     DEFAULT_NUMBER_BROADCASTS,
                                                     1);

    pConfig->uBcastTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                                     WS_BCAST_TIMEOUT,
                                                     DEFAULT_BCAST_TIMEOUT,
                                                     MIN_BCAST_TIMEOUT);

    pConfig->uNumRetries =  (USHORT)CTEReadSingleIntParameter(ParmHandle,
                                                     WS_NAMESRV_RETRIES,
                                                     DEFAULT_NUMBER_RETRIES,
                                                     1);

    pConfig->uRetryTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                                     WS_NAMESRV_TIMEOUT,
                                                     DEFAULT_RETRY_TIMEOUT,
                                                     MIN_RETRY_TIMEOUT);

    pConfig->KeepAliveTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                               WS_KEEP_ALIVE,
                                               DEFAULT_KEEP_ALIVE,
                                               MIN_KEEP_ALIVE);

    pConfig->SelectAdapter =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_RANDOM_ADAPTER,
                                               0,
                                               0);
    pConfig->SingleResponse =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_SINGLE_RESPONSE,
                                               0,
                                               0);
    pConfig->NoNameReleaseOnDemand =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_NO_NAME_RELEASE,
                                               0,
                                               0);  // disabled by default
    if (pConfig->CachePerAdapterEnabled = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               WS_CACHE_PER_ADAPTER_ENABLED,
                                               1,   // Enabled by default
                                               0))
    {
        pConfig->ConnectOnRequestedInterfaceOnly = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                                   WS_CONNECT_ON_REQUESTED_IF_ONLY,
                                                   0,   // Disabled by default
                                                   0);
    }
    else
    {
        pConfig->ConnectOnRequestedInterfaceOnly = FALSE;
    }
    pConfig->SendDgramOnRequestedInterfaceOnly = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               WS_SEND_DGRAM_ON_REQUESTED_IF_ONLY,
                                               1,   // Enabled by default
                                               0);
    UseNewSmb       = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               L"UseNewSmb",
                                               0,   // Disabled by default
                                               0);
    if (!UseNewSmb) {
        pConfig->SMBDeviceEnabled = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               WS_SMB_DEVICE_ENABLED,
                                               1,   // Enabled by default
                                               0);
    } else {
        pConfig->SMBDeviceEnabled = FALSE;
    }

    pConfig->MultipleCacheFlags       = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               WS_MULTIPLE_CACHE_FLAGS,
                                               0,   // Not enabled by default
                                               0);
    pConfig->UseDnsOnly =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_USE_DNS_ONLY,
                                               0,
                                               0);  // disabled by default
    if (pConfig->UseDnsOnly)
    {
        pConfig->ResolveWithDns = TRUE;
        pConfig->TryAllNameServers = FALSE;
    }
    else
    {
        pConfig->ResolveWithDns =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_ENABLE_DNS,
                                               1,   // Enabled by default
                                               0);
#ifdef MULTIPLE_WINS
        pConfig->TryAllNameServers =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_TRY_ALL_NAME_SERVERS,
                                               0,   // disabled by default
                                               0);
#endif
    }
    pConfig->SmbDisableNetbiosNameCacheLookup =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_SMB_DISABLE_NETBIOS_NAME_CACHE_LOOKUP,
                                               1,   // Enabled by default
                                               0);
    pConfig->TryAllAddr =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_TRY_ALL_ADDRS,
                                               1,
                                               1);  // enabled by default
    pConfig->LmHostsTimeout =  CTEReadSingleIntParameter(ParmHandle,
                                               WS_LMHOSTS_TIMEOUT,
                                               DEFAULT_LMHOST_TIMEOUT,
                                               MIN_LMHOST_TIMEOUT);
    pConfig->MaxDgramBuffering =  CTEReadSingleIntParameter(ParmHandle,
                                               WS_MAX_DGRAM_BUFFER,
                                               DEFAULT_DGRAM_BUFFERING,
                                               DEFAULT_DGRAM_BUFFERING);

    pConfig->EnableProxyRegCheck =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_ENABLE_PROXY_REG_CHECK,
                                               0,
                                               0);

    pConfig->WinsDownTimeout =  (ULONG)CTEReadSingleIntParameter(ParmHandle,
                                               WS_WINS_DOWN_TIMEOUT,
                                               DEFAULT_WINS_DOWN_TIMEOUT,
                                               MIN_WINS_DOWN_TIMEOUT);

    pConfig->MaxBackLog =  (ULONG)CTEReadSingleIntParameter(ParmHandle,
                                               WS_MAX_CONNECTION_BACKLOG,
                                               DEFAULT_CONN_BACKLOG,
                                               MIN_CONN_BACKLOG);

    pConfig->SpecialConnIncrement =  (ULONG)CTEReadSingleIntParameter(ParmHandle,
                                                           WS_CONNECTION_BACKLOG_INCREMENT,
                                                           DEFAULT_CONN_BACKLOG_INCREMENT,
                                                           MIN_CONN_BACKLOG_INCREMENT);

    pConfig->MinFreeLowerConnections =  (ULONG)CTEReadSingleIntParameter(ParmHandle,
                                                           WS_MIN_FREE_INCOMING_CONNECTIONS,
                                                           DEFAULT_NBT_NUM_INITIAL_CONNECTIONS,
                                                           MIN_NBT_NUM_INITIAL_CONNECTIONS);

    pConfig->BreakOnAssert          = (BOOLEAN) CTEReadSingleIntParameter(ParmHandle,
                                               WS_BREAK_ON_ASSERT,
                                               1,   // Enabled by default
                                               0);
#ifndef REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG
    pConfig->DhcpProcessingDelay = (ULONG) CTEReadSingleIntParameter(ParmHandle,
                                                WS_DHCP_PROCESSING_DELAY,
                                                DEFAULT_DHCP_PROCESSING_DELAY,
                                                MIN_DHCP_PROCESSING_DELAY);
#endif       // REMOVE_IF_TCPIP_FIX___GATEWAY_AFTER_NOTIFY_BUG

    //
    // Cap the upper limit
    //
    if (pConfig->MaxBackLog > MAX_CONNECTION_BACKLOG) {
        pConfig->MaxBackLog = MAX_CONNECTION_BACKLOG;
    }

    if (pConfig->SpecialConnIncrement > MAX_CONNECTION_BACKLOG_INCREMENT) {
        pConfig->SpecialConnIncrement = MAX_CONNECTION_BACKLOG_INCREMENT;
    }


    //
    // Since UB chose the wrong opcode (9) we have to allow configuration
    // of that opcode incase our nodes refresh to their NBNS
    //
    Refresh =  (ULONG)CTEReadSingleIntParameter(ParmHandle,
                                               WS_REFRESH_OPCODE,
                                               REFRESH_OPCODE,
                                               REFRESH_OPCODE);
    if (Refresh == UB_REFRESH_OPCODE)
    {
        pConfig->OpRefresh = OP_REFRESH_UB;
    }
    else
    {
        pConfig->OpRefresh = OP_REFRESH;
    }

#ifndef VXD
    pConfig->EnableLmHosts =  (BOOLEAN)CTEReadSingleIntParameter(ParmHandle,
                                               WS_ENABLE_LMHOSTS,
                                               0,
                                               0);
#endif

#ifdef PROXY_NODE

    {
       ULONG Proxy;
       Proxy =  CTEReadSingleIntParameter(ParmHandle,
                                               WS_IS_IT_A_PROXY,
                                               IS_NOT_PROXY,    //default value
                                               IS_NOT_PROXY);

      //
      // If the returned value is greater than IS_NOT_PROXY, it is a proxy
      // (also check that they have not entered an ascii string instead of a
      // dword in the registry
      //
      if ((Proxy > IS_NOT_PROXY) && (Proxy < ('0'+IS_NOT_PROXY)))
      {
           NodeType |= PROXY;
           RegistryNodeType |= PROXY;
           NbtConfig.ProxyType = Proxy;
      }
    }
#endif
    NodeSize =  CTEReadSingleIntParameter(ParmHandle,
                                               WS_NODE_SIZE,
                                               NodeType & PROXY ? LARGE : DEFAULT_NODE_SIZE,
                                               NodeType & PROXY ? LARGE : SMALL);

    switch(NbtGetProductType()) {
    case VER_NT_WORKSTATION:
        NbtConfig.lMaxNumPendingNameQueries = 32;
        break;

    default:
        NbtConfig.lMaxNumPendingNameQueries = 256;
        break;
    }

    if (NodeType & PROXY) {
        NbtConfig.lMaxNumPendingNameQueries *= 2;
    }
    NbtConfig.lMaxNumPendingNameQueries = CTEReadSingleIntParameter(
                                        ParmHandle,
                                        WS_PENDING_NAME_QUERIES_COUNT,
                                        NbtConfig.lMaxNumPendingNameQueries,
                                        MIN_NBT_NUM_PENDING_NAME_QUERIES
                                        );

    //
    // "2" reflects the 2 timers: RefreshTimeout and RemoteHashTimeout
    //
    NbtConfig.lMaxNumTimersRunning = NbtConfig.lMaxNumPendingNameQueries + 2;

    switch (NodeSize)
    {
        default:
        case SMALL:

            pConfig->uNumLocalNames = NUMBER_LOCAL_NAMES;
            pConfig->uNumRemoteNames = NUMBER_REMOTE_NAMES;
            pConfig->uNumBucketsLocal = NUMBER_BUCKETS_LOCAL_HASH_TABLE;
            pConfig->uNumBucketsRemote = NUMBER_BUCKETS_REMOTE_HASH_TABLE;

            pConfig->iMaxNumBuff[eNBT_DGRAM_TRACKER]   = NBT_NUM_DGRAM_TRACKERS;
#ifndef VXD
            pConfig->iMaxNumBuff[eNBT_FREE_SESSION_MDLS] = NBT_NUM_SESSION_MDLS;
#else
            pConfig->iMaxNumBuff[eNBT_SESSION_HDR]     = NBT_NUM_SESSION_HDR ;
            pConfig->iMaxNumBuff[eNBT_SEND_CONTEXT]    = NBT_NUM_SEND_CONTEXT ;
            pConfig->iMaxNumBuff[eNBT_RCV_CONTEXT]     = NBT_NUM_RCV_CONTEXT ;
#endif
            break;

        case MEDIUM:

            pConfig->uNumLocalNames = MEDIUM_NUMBER_LOCAL_NAMES;
            pConfig->uNumRemoteNames = MEDIUM_NUMBER_REMOTE_NAMES;
            pConfig->uNumBucketsLocal = MEDIUM_NUMBER_BUCKETS_LOCAL_HASH_TABLE;
            pConfig->uNumBucketsRemote = MEDIUM_NUMBER_BUCKETS_REMOTE_HASH_TABLE;

            pConfig->iMaxNumBuff[eNBT_DGRAM_TRACKER]   = MEDIUM_NBT_NUM_DGRAM_TRACKERS;
#ifndef VXD
            pConfig->iMaxNumBuff[eNBT_FREE_SESSION_MDLS] = MEDIUM_NBT_NUM_SESSION_MDLS;
#else
            pConfig->iMaxNumBuff[eNBT_SESSION_HDR]     = MEDIUM_NBT_NUM_SESSION_HDR ;
            pConfig->iMaxNumBuff[eNBT_SEND_CONTEXT]    = MEDIUM_NBT_NUM_SEND_CONTEXT ;
            pConfig->iMaxNumBuff[eNBT_RCV_CONTEXT]     = MEDIUM_NBT_NUM_RCV_CONTEXT ;
#endif
            break;

        case LARGE:

            pConfig->uNumLocalNames = LARGE_NUMBER_LOCAL_NAMES;
            pConfig->uNumRemoteNames = LARGE_NUMBER_REMOTE_NAMES;
            pConfig->uNumBucketsLocal = LARGE_NUMBER_BUCKETS_LOCAL_HASH_TABLE;
            pConfig->uNumBucketsRemote = LARGE_NUMBER_BUCKETS_REMOTE_HASH_TABLE;

            pConfig->iMaxNumBuff[eNBT_DGRAM_TRACKER]   = LARGE_NBT_NUM_DGRAM_TRACKERS;
#ifndef VXD
            pConfig->iMaxNumBuff[eNBT_FREE_SESSION_MDLS] = LARGE_NBT_NUM_SESSION_MDLS;
#else
            pConfig->iMaxNumBuff[eNBT_SESSION_HDR]     = LARGE_NBT_NUM_SESSION_HDR ;
            pConfig->iMaxNumBuff[eNBT_SEND_CONTEXT]    = LARGE_NBT_NUM_SEND_CONTEXT ;
            pConfig->iMaxNumBuff[eNBT_RCV_CONTEXT]     = LARGE_NBT_NUM_RCV_CONTEXT ;
#endif
            break;
    }

    ReadLmHostFile(pConfig,ParmHandle);
}

#ifdef VXD
#pragma END_INIT
#endif

//----------------------------------------------------------------------------
VOID
ReadParameters2(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    )

/*++

Routine Description:

    This routine is called to read DHCPable parameters from the parameters
    section of the NBT section of the registry.

    This routine is primarily for the Vxd.

Arguments:

    pConfig     - A pointer to the configuration data structure.
    ParmHandle  - a handle to the parameters Key under Nbt

Return Value:

    Status

--*/

{
    ULONG           Node;
    ULONG           ReadOne;
    ULONG           ReadTwo;

    CTEPagedCode();

    Node = CTEReadSingleIntParameter(ParmHandle,     // handle of key to look under
                                     WS_NODE_TYPE,   // wide string name
                                     0,              // default value
                                     0);

    switch (Node)
    {
        case 2:
            NodeType = PNODE;
            break;

        case 4:
            NodeType = MNODE;
            break;

        case 8:
            NodeType = MSNODE;
            break;

        case 1:
            NodeType = BNODE;
            break;

        default:
            NodeType = BNODE | DEFAULT_NODE_TYPE;
            break;
    }
    RegistryNodeType = NodeType;

    // do a trick  here - read the registry twice for the same value, passing
    // in two different defaults, in order to determine if the registry
    // value has been defined or not - since it may be defined, but equal
    // to one default.
    ReadOne =  CTEReadSingleHexParameter(ParmHandle,
                                         WS_ALLONES_BCAST,
                                         DEFAULT_BCAST_ADDR,
                                         0);
    ReadTwo =  CTEReadSingleHexParameter(ParmHandle,
                                         WS_ALLONES_BCAST,
                                         0,
                                         0);
    if (ReadOne != ReadTwo)
    {
        NbtConfig.UseRegistryBcastAddr = FALSE;
    }
    else
    {
        NbtConfig.UseRegistryBcastAddr = TRUE;
        NbtConfig.RegistryBcastAddr = ReadTwo;
    }

    ReadScope(pConfig,ParmHandle);
}

//----------------------------------------------------------------------------
VOID
ReadScope(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    )

/*++

Routine Description:

    This routine is called to read the scope from registry and convert it to
    a format where the intervening dots are length bytes.

Arguments:

    pConfig     - A pointer to the configuration data structure.
    ParmHandle  - a handle to the parameters Key under Nbt

Return Value:

    Status

--*/

{
    NTSTATUS        status;
    PUCHAR          pScope, pOldScope, pNewScope;
    PUCHAR          pBuff;
    PUCHAR          pBuffer;
    PUCHAR          pPeriod;
    ULONG           Len;
    UCHAR           Chr;


    CTEPagedCode();
    //
    // this routine returns the scope in a dotted format.
    // "Scope.MoreScope.More"  The dots are
    // converted to byte lengths by the code below.  This routine allocates
    // the memory for the pScope string.
    //
    status = CTEReadIniString(ParmHandle,NBT_SCOPEID,&pBuffer);

    if (NT_SUCCESS(status))
    {
        //
        // the user can type in an * to indicate that they really want
        // a null scope and that should override the DHCP scope. So check
        // here for an * and if so, set the scope back to null.
        //

        if ((strlen(pBuffer) == 0) || (pBuffer[0] == '*'))
        {
            CTEMemFree(pBuffer);
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(status))
    {
        // length of scope is num chars plus the 0 on the end, plus
        // the length byte on the start(+2 total) - so allocate another buffer
        // that is one longer than the previous one so it can include
        // these extra two bytes.
        //
        Len = strlen(pBuffer);
        //
        // the scope cannot be longer than 255 characters as per RFC1002
        //
        if (Len <= MAX_SCOPE_LENGTH)
        {
            pScope = NbtAllocMem (Len+2, NBT_TAG2('02'));
            if (pScope)
            {
                CTEMemCopy((pScope+1),pBuffer,Len);

                //
                // Put a null on the end of the scope
                //
                pScope[Len+1] = 0;

                Len = 1;

                // now go through the string converting periods to length
                // bytes - we know the first byte is a length byte so skip it.
                //
                pBuff = pScope;
                pBuff++;
                Len++;
                pPeriod = pScope;
                while (Chr = *pBuff)
                {
                    Len++;
                    if (Chr == '.')
                    {
                        *pPeriod = (UCHAR) (pBuff-pPeriod-1);

                        //
                        // Each label can be at most 63 bytes long
                        //
                        if (*pPeriod > MAX_LABEL_LENGTH)
                        {
                            status = STATUS_UNSUCCESSFUL;
                            NbtLogEvent (EVENT_SCOPE_LABEL_TOO_LONG, STATUS_SUCCESS, 0x104);
                            break;
                        }

                        // check for two periods back to back and use no scope if this
                        // happens
                        if (*pPeriod == 0)
                        {
                            status = STATUS_UNSUCCESSFUL;
                            break;
                        }

                        pPeriod = pBuff++;
                    }
                    else
                        pBuff++;
                }
                if (NT_SUCCESS(status))
                {
                    // the last ptr is always the end of the name.

                    *pPeriod = (UCHAR)(pBuff - pPeriod -1);

                    pOldScope = pConfig->pScope;
                    pConfig->pScope = pScope;
                    pConfig->ScopeLength = (USHORT)Len;
                    if (pOldScope)
                    {
                        CTEMemFree(pOldScope);
                    }
                    CTEMemFree(pBuffer);
                    return;
                }
                CTEMemFree(pScope);
            }
            CTEMemFree(pBuffer);
        }
        else
        {
            status = STATUS_UNSUCCESSFUL;
            NbtLogEvent (EVENT_SCOPE_LABEL_TOO_LONG, STATUS_SUCCESS, 0x105);
        }
    }

    //
    // the scope is one byte => '\0' - the length of the root name (zero)
    //
    // If the old scope and new scope are the same, then don't change the
    // scope tag!
    //
    pOldScope = pConfig->pScope;
    if (!(pOldScope) ||
        (*pOldScope != '\0'))
    {
        if (pNewScope = NbtAllocMem ((1), NBT_TAG2('03')))
        {
            *pNewScope = '\0';

            pConfig->ScopeLength = 1;
            pConfig->pScope = pNewScope;
            if (pOldScope)
            {
                CTEMemFree(pOldScope);
            }
        }
    }
}

#ifdef VXD
#pragma BEGIN_INIT
#endif

//----------------------------------------------------------------------------
VOID
ReadLmHostFile(
    IN  tNBTCONFIG  *pConfig,
    IN  HANDLE      ParmHandle
    )

/*++

Routine Description:

    This routine is called to read the lmhost file path from the registry.

Arguments:

    pConfig     - A pointer to the configuration data structure.
    ParmHandle  - a handle to the parameters Key under Nbt

Return Value:

    Status

--*/

{
    NTSTATUS        status;
    PUCHAR          pBuffer, pOldLmHosts;
    PUCHAR          pchr;

    CTEPagedCode();

    NbtConfig.PathLength = 0;
    pOldLmHosts = pConfig->pLmHosts;
    NbtConfig.pLmHosts = NULL;

    //
    // read in the LmHosts File location
    //
#ifdef VXD
    status = CTEReadIniString(ParmHandle,WS_LMHOSTS_FILE,&pBuffer);
#else
    status = NTGetLmHostPath(&pBuffer);
#endif

    //
    // Find the last backslash so we can calculate the file path length
    //
    // Also, the lm host file must include a path of at least "c:\" i.e.
    // the registry contains c:\lmhost, otherwise NBT won't be
    // able to find the file since it doesn't know what directory
    // to look in.
    //
    if (NT_SUCCESS(status))
    {
        if (pchr = strrchr(pBuffer,'\\'))
        {
            NbtConfig.pLmHosts = pBuffer;
            NbtConfig.PathLength = (ULONG) (pchr-pBuffer+1); // include backslash in length

            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.ReadLmHostFile:  LmHostsFile path is %s\n",NbtConfig.pLmHosts));
        }
        else
        {
            CTEMemFree(pBuffer);
        }
    }

    //
    // If we get a new Dhcp address this routine will get called again
    // after startup so we need to free any current lmhosts file path
    //
    if (pOldLmHosts)
    {
        CTEMemFree(pOldLmHosts);
    }
}
#ifdef VXD
#pragma END_INIT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\parse.c ===
/*++

Copyright (c) 1991-1993 Microsoft Corporation

Module Name:

    parse.c

Abstract:

    This source contains the functions that parse the lmhosts file.

Author:

    Jim Stewart           May 2, 1993

Revision History:


--*/

#include "precomp.h"
#include "hosts.h"
#include <ctype.h>
#include <string.h>

#include "parse.tmh"

#ifdef VXD
extern BOOL fInInit;
extern BOOLEAN CachePrimed;
#endif

//
//  Returns 0 if equal, 1 if not equal.  Used to avoid using c-runtime
//
#define strncmp( pch1, pch2, length ) \
    (!CTEMemEqu( pch1, pch2, length ) )


//
// Private Definitions
//
// As an lmhosts file is parsed, a #INCLUDE directive is interpreted
// according to the INCLUDE_STATE at that instance.  This state is
// determined by the #BEGIN_ALTERNATE and #END_ALTERNATE directives.
//
//
typedef enum _INCLUDE_STATE
{

    MustInclude = 0,                                    // shouldn't fail
    TryToInclude,                                       // in alternate block
    SkipInclude                                         // satisfied alternate
                                                        //  block
} INCLUDE_STATE;


//
// LmpGetTokens() parses a line and returns the tokens in the following
// order:
//
typedef enum _TOKEN_ORDER_
{

    IpAddress = 0,                                      // first token
    NbName,                                             // 2nd token
    GroupName,                                          // 3rd or 4th token
    NotUsed,                                            // #PRE, if any
    NotUsed2,                                           // #NOFNR, if any
    MaxTokens                                           // this must be last

} TOKEN_ORDER;


//
// As each line in an lmhosts file is parsed, it is classified into one of
// the categories enumerated below.
//
// However, Preload is a special member of the enum.
//
//
typedef enum _TYPE_OF_LINE
{

    Comment           = 0x0000,                         // comment line
    Ordinary          = 0x0001,                         // ip_addr NetBIOS name
    Domain            = 0x0002,                         // ... #DOM:name
    Include           = 0x0003,                         // #INCLUDE file
    BeginAlternate    = 0x0004,                         // #BEGIN_ALTERNATE
    EndAlternate      = 0x0005,                         // #END_ALTERNATE
    ErrorLine         = 0x0006,                         // Error in line

    NoFNR             = 0x4000,                         // ... #NOFNR
    Preload           = 0x8000                          // ... #PRE

} TYPE_OF_LINE;


//
// In an lmhosts file, the following are recognized as keywords:
//
//     #BEGIN_ALTERNATE        #END_ALTERNATE          #PRE
//     #DOM:                   #INCLUDE
//
// Information about each keyword is kept in a KEYWORD structure.
//
//
typedef struct _KEYWORD
{                               // reserved keyword

    char           *k_string;                           //  NULL terminated
    size_t          k_strlen;                           //  length of token
    TYPE_OF_LINE    k_type;                             //  type of line
    int             k_noperands;                        //  max operands on line

} KEYWORD, *PKEYWORD;


typedef struct _LINE_CHARACTERISTICS_
{

    int              l_category:4;                      // enum _TYPE_OF_LINE
    int              l_preload:1;                       // marked with #PRE ?
    unsigned int     l_nofnr:1;                         // marked with #NOFNR

} LINE_CHARACTERISTICS, *PLINE_CHARACTERISTICS;



//
// Do not allow DNS name queries for the following Name Types:
//
//  Name                Number(h)  Type     Usage
//  --------------------------------------------------------------------------
//  <computername>         01       Unique  Messenger Service
//  <\\--__MSBROWSE__>     01       Group   Master Browser
//  <domain>               1B       Unique  Domain Master Browser
//  <domain>               1C       Group   Domain Controllers
//  <INet~Services>        1C       Group   IIS
//  <domain>               1D       Unique  Master Browser
//  <domain>               1E       Group   Browser Service Elections

#define IsValidDnsNameTag(_c)       \
    ((_c != 0x01) &&                \
     ((_c < 0x1B) || (_c > 0x1E)))



//
// Local Variables
//
//
// In an lmhosts file, the token '#' in any column usually denotes that
// the rest of the line is to be ignored.  However, a '#' may also be the
// first character of a keyword.
//
// Keywords are divided into two groups:
//
//  1. decorations that must either be the 3rd or 4th token of a line,
//  2. directives that must begin in column 0,
//
//
KEYWORD Decoration[] =
{

    DOMAIN_TOKEN,   sizeof(DOMAIN_TOKEN) - 1,   Domain,         5,
    PRELOAD_TOKEN,  sizeof(PRELOAD_TOKEN) - 1,  Preload,        5,
    NOFNR_TOKEN,    sizeof(NOFNR_TOKEN) -1,     NoFNR,          5,

    NULL,           0                                   // must be last
};


KEYWORD Directive[] =
{

    INCLUDE_TOKEN,  sizeof(INCLUDE_TOKEN) - 1,  Include,        2,
    BEG_ALT_TOKEN,  sizeof(BEG_ALT_TOKEN) - 1,  BeginAlternate, 1,
    END_ALT_TOKEN,  sizeof(END_ALT_TOKEN) - 1,  EndAlternate,   1,

    NULL,           0                                   // must be last
};

//
// Local Variables
//
//
// Each preloaded lmhosts entry corresponds to NSUFFIXES NetBIOS names,
// each with a 16th byte from Suffix[].
//
// For example, an lmhosts entry specifying "popcorn" causes the
// following NetBIOS names to be added to nbt.sys' name cache:
//
//      "POPCORN         "
//      "POPCORN        0x0"
//      "POPCORN        0x3"
//
//
#define NSUFFIXES       3
UCHAR Suffix[] = {                                  // LAN Manager Component
    0x20,                                           //   server
    0x0,                                            //   redirector
    0x03                                            //   messenger
};

#ifndef VXD
//
// this structure tracks names queries that are passed up to user mode
// to resolve via DnsQueries
//
tLMHSVC_REQUESTS    DnsQueries;
tLMHSVC_REQUESTS    CheckAddr;
#endif
tLMHSVC_REQUESTS    LmHostQueries;   // Track names queries passed for LMhost processing
tDOMAIN_LIST    DomainNames;


//
// Local (Private) Functions
//
LINE_CHARACTERISTICS
LmpGetTokens (
    IN OUT      PUCHAR line,
    OUT PUCHAR  *token,
    IN OUT int  *pnumtokens
    );

PKEYWORD
LmpIsKeyWord (
    IN PUCHAR string,
    IN PKEYWORD table
    );

BOOLEAN
LmpBreakRecursion(
    IN PUCHAR path,
    IN PUCHAR target,
    IN ULONG  TargetLength
    );

LONG
HandleSpecial(
    IN char **pch);

ULONG
AddToDomainList (
    IN PUCHAR           pName,
    IN tIPADDRESS       IpAddress,
    IN PLIST_ENTRY      pDomainHead,
    IN BOOLEAN          fPreload
    );

NTSTATUS
ChangeStateOfName (
    IN      tIPADDRESS              IpAddress,
    IN      NBT_WORK_ITEM_CONTEXT   *pContext,
    IN OUT  NBT_WORK_ITEM_CONTEXT   **ppContext,
    IN      USHORT                  NameAddFlags
    );

VOID
LmHostTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    );

NBT_WORK_ITEM_CONTEXT *
GetNameToFind(
    OUT PUCHAR      pName
    );

VOID
GetContext (
    IN OUT  NBT_WORK_ITEM_CONTEXT   **ppContext
    );

VOID
MakeNewListCurrent (
    PLIST_ENTRY     pTmpDomainList
    );

VOID
RemoveNameAndCompleteReq (
    IN NBT_WORK_ITEM_CONTEXT    *pContext,
    IN NTSTATUS                 status
    );

PCHAR
Nbtstrcat( PUCHAR pch, PUCHAR pCat, LONG Len );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, LmGetIpAddr)
#pragma CTEMakePageable(PAGE, HandleSpecial)
#pragma CTEMakePageable(PAGE, LmpGetTokens)
#pragma CTEMakePageable(PAGE, LmpIsKeyWord)
#pragma CTEMakePageable(PAGE, LmpBreakRecursion)
#pragma CTEMakePageable(PAGE, AddToDomainList)
#pragma CTEMakePageable(PAGE, LmExpandName)
#pragma CTEMakePageable(PAGE, LmInclude)
#pragma CTEMakePageable(PAGE, LmGetFullPath)
#pragma CTEMakePageable(PAGE, PrimeCache)
#pragma CTEMakePageable(PAGE, DelayedScanLmHostFile)
#pragma CTEMakePageable(PAGE, NbtCompleteLmhSvcRequest)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------

unsigned long
LmGetIpAddr (
    IN PUCHAR   path,
    IN PUCHAR   target,
    IN CHAR     RecurseDepth,
    OUT BOOLEAN *bFindName
    )

/*++

Routine Description:

    This function searches the file for an lmhosts entry that can be
    mapped to the second level encoding.  It then returns the ip address
    specified in that entry.

    This function is called recursively, via LmInclude() !!

Arguments:

    path        -  a fully specified path to a lmhosts file
    target      -  the unencoded 16 byte NetBIOS name to look for
    RecurseDepth-  the depth to which we can resurse -- 0 => no more recursion

Return Value:

    The ip address (network byte order), or 0 if no appropriate entry was
    found.

    Note that in most contexts (but not here), ip address 0 signifies
    "this host."

--*/


{
    PUCHAR                     buffer;
    PLM_FILE                   pfile;
    NTSTATUS                   status;
    int                        count, nwords;
    INCLUDE_STATE              incstate;
    PUCHAR                     token[MaxTokens];
    LINE_CHARACTERISTICS       current;
    unsigned                   long inaddr, retval;
    UCHAR                      temp[NETBIOS_NAME_SIZE+1];

    CTEPagedCode();
    //
    // Check for infinitely recursive name lookup in a #INCLUDE.
    //
    if (LmpBreakRecursion(path, target, NETBIOS_NAME_SIZE-1) == TRUE)
    {
        return (0);
    }

#ifdef VXD
    //
    // if we came here via nbtstat -R and InDos is set, report error: user
    // can try nbtstat -R again.  (since nbtstat can only be run from DOS box,
    // can InDos be ever set???  Might as well play safe)
    //
    if ( !fInInit && GetInDosFlag() )
    {
       return(0);
    }
#endif

    pfile = LmOpenFile(path);

    if (!pfile)
    {
        return((unsigned long) 0);
    }

    *bFindName = FALSE;
    inaddr   = 0;
    incstate = MustInclude;

    while (buffer = LmFgets(pfile, &count))
    {

        nwords   = MaxTokens;
        current = LmpGetTokens(buffer, token, &nwords);

        switch ((ULONG)current.l_category)
        {
        case ErrorLine:
            continue;

        case Domain:
        case Ordinary:
            if (current.l_preload ||
              ((nwords - 1) < NbName))
            {
                continue;
            }
            break;

        case Include:
            if (!RecurseDepth || (incstate == SkipInclude) || (nwords < 2))
            {
                continue;
            }

            retval = LmInclude(token[1], LmGetIpAddr, target, (CHAR) (RecurseDepth-1), bFindName);

            if (retval != 0) {
                if (incstate == TryToInclude)
                {
                    incstate = SkipInclude;
                }
            } else {
                if (incstate == MustInclude)
                {
                    IF_DBG(NBT_DEBUG_LMHOST)
                        KdPrint(("Nbt.LmGetIpAddr: Can't #INCLUDE \"%s\"", token[1]));
                }
                continue;
            }
            inaddr = retval;
            goto found;

        case BeginAlternate:
            ASSERT(nwords == 1);
            incstate = TryToInclude;
            continue;

        case EndAlternate:
            ASSERT(nwords == 1);
            incstate = MustInclude;
            continue;

        default:
            continue;
        }

        if (strlen(token[NbName]) == (NETBIOS_NAME_SIZE))
        {
            if (strncmp(token[NbName], target, (NETBIOS_NAME_SIZE)) != 0)
            {
                continue;
            }
        } else
        {
            //
            // attempt to match, in a case insensitive manner, the first 15
            // bytes of the lmhosts entry with the target name.
            //
            LmExpandName(temp, token[NbName], 0);

            if (strncmp(temp, target, NETBIOS_NAME_SIZE - 1) != 0)
            {
                continue;
            }
        }

        if (current.l_nofnr)
        {
            *bFindName = TRUE;
        }
        status = ConvertDottedDecimalToUlong(token[IpAddress],&inaddr);
        if (!NT_SUCCESS(status))
        {
            inaddr = 0;
        }
        break;
    }

found:
    status = LmCloseFile(pfile);

    ASSERT(status == STATUS_SUCCESS);

    if (!NT_SUCCESS(status))
    {
        *bFindName = FALSE;
    }

    IF_DBG(NBT_DEBUG_LMHOST)
        KdPrint(("Nbt.LmGetIpAddr: (\"%15.15s<%X>\") = %X\n",target,target[15],inaddr));


    return(inaddr);
} // LmGetIpAddr


//----------------------------------------------------------------------------
LONG
HandleSpecial(
    IN CHAR **pch)

/*++

Routine Description:

    This function converts ASCII hex into a ULONG.

Arguments:


Return Value:

    The ip address (network byte order), or 0 if no appropriate entry was
    found.

    Note that in most contexts (but not here), ip address 0 signifies
    "this host."

--*/


{
    int                         sval;
    int                         rval;
    char                       *sp = *pch;
    int                         i;

    CTEPagedCode();

    sp++;
    switch (*sp)
    {
    case '\\':
        // the second character is also a \ so  return a \ and set pch to
        // point to the next character (\)
        //
        *pch = sp;
        return((int)'\\');

    default:

        // convert some number of characters to hex and increment pch
        // the expected format is "\0x03"
        //
//        sscanf(sp, "%2x%n", &sval, &rval);

        sval = 0;
        rval = 0;
        sp++;

        // check for the 0x part of the hex number
        if (*sp != 'x')
        {
            *pch = sp;
            return(-1);
        }
        sp++;
        for (i=0;(( i<2 ) && *sp) ;i++ )
        {
            if (*sp != ' ')
            {
                // convert from ASCII to hex, allowing capitals too
                //
                if (*sp >= 'a')
                {
                    sval = *sp - 'a' + 10 + sval*16;
                }
                else
                if (*sp >= 'A')
                {
                    sval = *sp - 'A' + 10 + sval*16;
                }
                else
                {
                    sval = *sp - '0' + sval*16;
                }
                sp++;
                rval++;
            }
            else
                break;
        }

        if (rval < 1)
        {
            *pch = sp;
            return(-1);
        }

        *pch += (rval+2);    // remember to account for the characters 0 and x

        return(sval);

    }
}

#define LMHASSERT(s)  if (!(s)) \
{ retval.l_category = ErrorLine; return(retval); }

//----------------------------------------------------------------------------

LINE_CHARACTERISTICS
LmpGetTokens (
    IN OUT PUCHAR line,
    OUT PUCHAR *token,
    IN OUT int *pnumtokens
    )

/*++

Routine Description:

    This function parses a line for tokens.  A maximum of *pnumtokens
    are collected.

Arguments:

    line        -  pointer to the NULL terminated line to parse
    token       -  an array of pointers to tokens collected
    *pnumtokens -  on input, number of elements in the array, token[];
                   on output, number of tokens collected in token[]

Return Value:

    The characteristics of this lmhosts line.

Notes:

    1. Each token must be separated by white space.  Hence, the keyword
       "#PRE" in the following line won't be recognized:

            11.1.12.132     lothair#PRE

    2. Any ordinary line can be decorated with a "#PRE", a "#DOM:name" or
       both.  Hence, the following lines must all be recognized:

            111.21.112.3        kernel          #DOM:ntwins #PRE
            111.21.112.4        orville         #PRE        #DOM:ntdev
            111.21.112.7        cliffv4         #DOM:ntlan
            111.21.112.132      lothair         #PRE

--*/


{
    enum _PARSE
    {                                      // current fsm state

        StartofLine,
        WhiteSpace,
        AmidstToken

    } state;

    PUCHAR                     pch;                                        // current fsm input
    PUCHAR                     och;
    PKEYWORD                   keyword;
    int                        index, maxtokens, quoted, rchar;
    LINE_CHARACTERISTICS       retval;

    CTEPagedCode();
    CTEZeroMemory(token, *pnumtokens * sizeof(PUCHAR));

    state             = StartofLine;
    retval.l_category = Ordinary;
    retval.l_preload  = 0;
    retval.l_nofnr    = 0;
    maxtokens         = *pnumtokens;
    index             = 0;
    quoted            = 0;

    for (pch = line; *pch; pch++)
    {
        switch (*pch)
        {

        //
        // does the '#' signify the start of a reserved keyword, or the
        // start of a comment ?
        //
        //
        case '#':
            if (quoted)
            {
                *och++ = *pch;
                continue;
            }
            keyword = LmpIsKeyWord(
                            pch,
                            (state == StartofLine) ? Directive : Decoration);

            if (keyword)
            {
                state     = AmidstToken;
                maxtokens = keyword->k_noperands;

                switch (keyword->k_type)
                {
                case NoFNR:
                    retval.l_nofnr = 1;
                    continue;

                case Preload:
                    retval.l_preload = 1;
                    continue;

                default:
                    LMHASSERT(maxtokens <= *pnumtokens);
                    LMHASSERT(index     <  maxtokens);

                    token[index++]    = pch;
                    retval.l_category = keyword->k_type;
                    continue;
                }

                LMHASSERT(0);
            }

            if (state == StartofLine)
            {
                retval.l_category = Comment;
            }
            /* fall through */

        case '\r':
        case '\n':
            *pch = (UCHAR) NULL;
            if (quoted)
            {
                *och = (UCHAR) NULL;
            }
            goto done;

        case ' ':
        case '\t':
            if (quoted)
            {
                *och++ = *pch;
                continue;
            }
            if (state == AmidstToken)
            {
                state = WhiteSpace;
                *pch  = (UCHAR) NULL;

                if (index == maxtokens)
                {
                    goto done;
                }
            }
            continue;

        case '"':
            if ((state == AmidstToken) && quoted)
            {
                state = WhiteSpace;
                quoted = 0;
                *pch  = (UCHAR) NULL;
                *och  = (UCHAR) NULL;

                if (index == maxtokens)
                {
                    goto done;
                }
                continue;
            }

            state  = AmidstToken;
            quoted = 1;
            LMHASSERT(maxtokens <= *pnumtokens);
            LMHASSERT(index     <  maxtokens);
            token[index++] = pch + 1;
            och = pch + 1;
            continue;

        case '\\':
            if (quoted)
            {
                rchar = HandleSpecial(&pch);
                if (rchar == -1)
                {
                    retval.l_category = ErrorLine;
                    return(retval);
                }
                *och++ = (UCHAR)rchar;
                //
                // put null on end of string
                //

                continue;
            }

        default:
            if (quoted)
            {
                *och++ = *pch;
                       continue;
            }
            if (state == AmidstToken)
            {
                continue;
            }

            state  = AmidstToken;

            LMHASSERT(maxtokens <= *pnumtokens);
            LMHASSERT(index     <  maxtokens);
            token[index++] = pch;
            continue;
        }
    }

done:
    //
    // if there is no name on the line, then return an error
    //
    if (index <= NbName && index != maxtokens)
    {
        retval.l_category = ErrorLine;
    }
    ASSERT(!*pch);
    ASSERT(maxtokens <= *pnumtokens);
    ASSERT(index     <= *pnumtokens);

    *pnumtokens = index;
    return(retval);
} // LmpGetTokens



//----------------------------------------------------------------------------

PKEYWORD
LmpIsKeyWord (
    IN PUCHAR string,
    IN PKEYWORD table
    )

/*++

Routine Description:

    This function determines whether the string is a reserved keyword.

Arguments:

    string  -  the string to search
    table   -  an array of keywords to look for

Return Value:

    A pointer to the relevant keyword object, or NULL if unsuccessful

--*/


{
    size_t                     limit;
    PKEYWORD                   special;

    CTEPagedCode();
    limit = strlen(string);

    for (special = table; special->k_string; special++)
    {

        if (limit < special->k_strlen)
        {
            continue;
        }

        if ((limit >= special->k_strlen) &&
            !strncmp(string, special->k_string, special->k_strlen))
            {

                return(special);
        }
    }

    return((PKEYWORD) NULL);
} // LmpIsKeyWord



//----------------------------------------------------------------------------

BOOLEAN
LmpBreakRecursion(
    IN PUCHAR path,
    IN PUCHAR target,
    IN ULONG  TargetLength
    )
/*++

Routine Description:

    This function checks that the file name we are about to open
    does not use the target name of this search, which would
    cause an infinite lookup loop.

Arguments:

    path        -  a fully specified path to a lmhosts file
    target      -  the unencoded 16 byte NetBIOS name to look for

Return Value:

    TRUE if the UNC server name in the file path is the same as the
    target of this search. FALSE otherwise.

Notes:

    This function does not detect redirected drives.

--*/


{
    PCHAR     keystring = "\\DosDevices\\UNC\\";
    PCHAR     servername[NETBIOS_NAME_SIZE+1];  // for null on end
    PCHAR     marker1;
    PCHAR     marker2;
    PCHAR     marker3;
    BOOLEAN   retval = FALSE;
    tNAMEADDR *pNameAddr;
    ULONG     uType;

    CTEPagedCode();
    //
    // Check for and extract the UNC server name
    //
    if ((path) && (strlen(path) > strlen(keystring)))
    {
        // check that the name is a unc name
        if (strncmp(path, keystring, strlen(keystring)) == 0)
        {
            marker1 = path + strlen(keystring); // the end of the \DosDevices\Unc\ string
            marker3 = &path[strlen(path)-1];    // the end of the whole path
            marker2 = strchr(marker1,'\\');     // the end of the server name

            if ((marker2) &&                    // marker2 can be NULL if '\\' does not exist in the string
                (marker2 != marker3))
            {
                *marker2 = '\0';

                //
                // attempt to match, in a case insensitive manner, the
                // first 15 bytes of the lmhosts entry with the target
                // name.
                //
                LmExpandName((PUCHAR)servername, marker1, 0);

                if(strncmp((PUCHAR)servername, target, TargetLength) == 0)
                {
                    //
                    // break the recursion
                    //
                    retval = TRUE;
                    IF_DBG(NBT_DEBUG_LMHOST)
                    KdPrint(("Nbt.LmpBreakRecursion: Not including Lmhosts file <%s> because of recursive name\n",
                                servername));
                }
                else
                {
                    //
                    // check if the name has been preloaded in the cache, and
                    // if not, fail the request so we can't get into a loop
                    // trying to include the remote file while trying to
                    // resolve the remote name
                    //
                    pNameAddr = LockAndFindName(NBT_REMOTE,
                                         (PCHAR)servername,
                                         NbtConfig.pScope,
                                         &uType);

                    if (!pNameAddr || !(pNameAddr->NameTypeState & PRELOADED) )
                    {
                        //
                        // break the recursion
                        //
                        retval = TRUE;
                        IF_DBG(NBT_DEBUG_LMHOST)
                        KdPrint(("Nbt.LmpBreakRecursion: Not including Lmhosts #include because name not Preloaded %s\n",
                                    servername));
                    }
                }
                *marker2 = '\\';
            }
        }
    }

    return(retval);
}


//----------------------------------------------------------------------------

char *
LmExpandName (
    OUT PUCHAR dest,
    IN PUCHAR source,
    IN UCHAR last
    )

/*++

Routine Description:

    This function expands an lmhosts entry into a full 16 byte NetBIOS
    name.  It is padded with blanks up to 15 bytes; the 16th byte is the
    input parameter, last.

    This function does not encode 1st level names to 2nd level names nor
    vice-versa.

    Both dest and source are NULL terminated strings.

Arguments:

    dest        -  sizeof(dest) must be NBT_NONCODED_NMSZ
    source      -  the lmhosts entry
    last        -  the 16th byte of the NetBIOS name

Return Value:

    dest.

--*/


{
    char             byte;
    char            *retval = dest;
    char            *src    = source ;
#ifndef VXD
    WCHAR            unicodebuf[NETBIOS_NAME_SIZE+1];
    UNICODE_STRING   unicode;
    STRING           tmp;
#endif
    NTSTATUS         status;
    PUCHAR           limit;

    CTEPagedCode();
    //
    // first, copy the source OEM string to the destination, pad it, and
    // add the last character.
    //
    limit = dest + NETBIOS_NAME_SIZE - 1;

    while ( (*source != '\0') && (dest < limit) )
    {
        *dest++ = *source++;
    }

    while(dest < limit)
    {
        *dest++ = ' ';
    }

    ASSERT(dest == (retval + NETBIOS_NAME_SIZE - 1));

    *dest       = '\0';
    *(dest + 1) = '\0';
    dest = retval;

#ifndef VXD
    //
    // Now, convert to unicode then to ANSI to force the OEM -> ANSI munge.
    // Then convert back to Unicode and uppercase the name. Finally convert
    // back to OEM.
    //
    unicode.Length = 0;
    unicode.MaximumLength = 2*(NETBIOS_NAME_SIZE+1);
    unicode.Buffer = unicodebuf;

    RtlInitString(&tmp, dest);

    status = RtlOemStringToUnicodeString(&unicode, &tmp, FALSE);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint (("Nbt.LmExpandName: Oem -> Unicode failed,  status %X\n", status));
        goto oldupcase;
    }

    status = RtlUnicodeStringToAnsiString(&tmp, &unicode, FALSE);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint (("Nbt.LmExpandName: Unicode -> Ansi failed,  status %X\n", status));
        goto oldupcase;
    }

    status = RtlAnsiStringToUnicodeString(&unicode, &tmp, FALSE);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint (("Nbt.LmExpandName: Ansi -> Unicode failed,  status %X\n", status));
        goto oldupcase;
    }

    status = RtlUpcaseUnicodeStringToOemString(&tmp, &unicode, FALSE);

    if (!NT_SUCCESS(status))
    {
        IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint (("Nbt.LmExpandName: Unicode upcase -> Oem failed,  status %X\n", status));
        goto oldupcase;
    }

    // write  the last byte to "0x20" or "0x03" or whatever
    // since we do not want it to go through the munge above.
    //
    dest[NETBIOS_NAME_SIZE-1] = last;
    return(retval);

#endif

oldupcase:

    for ( source = src ; dest < (retval + NETBIOS_NAME_SIZE - 1); dest++)
    {
        byte = *(source++);

        if (!byte)
        {
            break;
        }

        //  Don't use the c-runtime (nt c defn. included first)
        //  What about extended characters etc.?  Since extended characters do
        //  not normally part of netbios names, we will fix if requested
        *dest = (byte >= 'a' && byte <= 'z') ? byte-'a' + 'A' : byte ;
//        *dest = islower(byte) ? toupper(byte) : byte;
    }

    for (; dest < retval + NETBIOS_NAME_SIZE - 1; dest++)
    {
        *dest = ' ';
    }

    ASSERT(dest == (retval + NETBIOS_NAME_SIZE - 1));

    *dest       = last;
    *(dest + 1) = (char) NULL;

    return(retval);
} // LmExpandName

//----------------------------------------------------------------------------

unsigned long
LmInclude(
    IN PUCHAR            file,
    IN LM_PARSE_FUNCTION function,
    IN PUCHAR            argument  OPTIONAL,
    IN CHAR              RecurseDepth,
    OUT BOOLEAN          *NoFindName OPTIONAL
    )

/*++

Routine Description:

    LmInclude() is called to process a #INCLUDE directive in the lmhosts
    file.

Arguments:

    file        -  the file to include
    function    -  function to parse the included file
    argument    -  optional second argument to the parse function
    RecurseDepth-  the depth to which we can resurse -- 0 => no more recursion
    NoFindName  -  Are find names allowed for this address

Return Value:

    The return value from the parse function.  This should be -1 if the
    file could not be processed, or else some positive number.

--*/


{
    int         retval;
    PUCHAR      end;
    NTSTATUS    status;
    PUCHAR      path;

    CTEPagedCode();
    //
    // unlike C, treat both variations of the #INCLUDE directive identically:
    //
    //      #INCLUDE file
    //      #INCLUDE "file"
    //
    // If a leading '"' exists, skip over it.
    //
    if (*file == '"')
    {

        file++;

        end = strchr(file, '"');

        if (end)
        {
            *end = (UCHAR) NULL;
        }
    }

    //
    // check that the file to be included has been preloaded in the cache
    // since we do not want to have the name query come right back to here
    // to force another inclusion of the same remote file
    //

#ifdef VXD
    return (*function)(file, argument, RecurseDepth, NoFindName ) ;
#else
    status = LmGetFullPath(file, &path);

    if (status != STATUS_SUCCESS)
    {
        return(status);
    }
//    IF_DBG(NBT_DEBUG_LMHOST)
    KdPrint(("Nbt.LmInclude: #INCLUDE \"%s\"\n", path));

    retval = (*function) (path, argument, RecurseDepth, NoFindName);

    CTEMemFree(path);

    return(retval);
#endif
} // LmInclude



#ifndef VXD                     // Not used by VXD
//----------------------------------------------------------------------------
NTSTATUS
LmGetFullPath (
    IN  PUCHAR target,
    OUT PUCHAR *ppath
    )

/*++

Routine Description:

    This function returns the full path of the lmhosts file.  This is done
    by forming a  string from the concatenation of the C strings
    DatabasePath and the string, file.

Arguments:

    target    -  the name of the file.  This can either be a full path name
                 or a mere file name.
    path    -  a pointer to a UCHAR

Return Value:

    STATUS_SUCCESS if successful.

Notes:

    RtlMoveMemory() handles overlapped copies; RtlCopyMemory() doesn't.

--*/

{
    ULONG    FileNameType;
    ULONG    Len;
    PUCHAR   path;

    CTEPagedCode();
    //
    // use a count to figure out what sort of string to build up
    //
    //  0  - local full path file name
    //  1  - local file name only, no path
    //  2  - remote file name
    //  3  - \SystemRoot\ starting file name, or \DosDevices\UNC\...
    //

    // if the target begins with a '\', or contains a DOS drive letter,
    // then assume that it specifies a full path.  Otherwise, prepend the
    // directory used to specify the lmhost file itself.
    //
    //
    if (target[1] == ':')
    {
        FileNameType = 0;
    }
    else
    if (strncmp(&target[1],"SystemRoot",10) == 0)
    {
        FileNameType = 3;
    }
    else
    if (strncmp(&target[0],"\\DosDevices\\",12) == 0)
    {
        FileNameType = 3;
    }
    else
    if (strncmp(target,"\\DosDevices\\UNC\\",sizeof("\\DosDevices\\UNC\\")-1) == 0)
    {
        FileNameType = 3;
    }
    else
    {
        FileNameType = 1;
    }

    //
    // does the directory specify a remote file ?
    //
    // If so, it must be prefixed with "\\DosDevices\\UNC", and the double
    // slashes of the UNC name eliminated.
    //
    //
    if  ((target[1] == '\\') && (target[0] == '\\'))
    {
        FileNameType = 2;
    }

    path = NULL;
    switch (FileNameType)
    {
        case 0:
            //
            // Full file name, put \DosDevices on front of name
            //
            Len = sizeof("\\DosDevices\\") + strlen(target);
            path = NbtAllocMem (Len, NBT_TAG2('11'));
            if (path)
            {
                ULONG   Length=sizeof("\\DosDevices\\"); // Took out -1

                strncpy(path,"\\DosDevices\\",Length);
                Nbtstrcat(path,target,Len);
            }
            break;


        case 1:
            //
            // only the file name is present, with no path, so use the path
            // specified for the lmhost file in the registry NbtConfig.PathLength
            // includes the last backslash of the path.
            //
            //Len = sizeof("\\DosDevices\\") + NbtConfig.PathLength + strlen(target);

            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);    // # 247429

            Len =  NbtConfig.PathLength + strlen(target) +1;
            path = NbtAllocMem (Len, NBT_TAG2('12'));
            if (path)
            {
                //ULONG   Length=sizeof("\\DosDevices") -1; // -1 not to count null

                //strncpy(path,"\\DosDevices",Length);

                strncpy(path,NbtConfig.pLmHosts,NbtConfig.PathLength);
                path[NbtConfig.PathLength] = '\0';

                Nbtstrcat(path,target,Len);
            }

            CTEExReleaseResource(&NbtConfig.Resource);

            break;

        case 2:
            //
            // Full file name, put \DosDevices\UNC on front of name and delete
            // one of the two back slashes used for the remote name
            //
            Len = strlen(target);
            path = NbtAllocMem (Len+sizeof("\\DosDevices\\UNC"), NBT_TAG2('13'));

            if (path)
            {
                ULONG   Length = sizeof("\\DosDevices\\UNC");

                strncpy(path,"\\DosDevices\\UNC",Length);

                // to delete the first \ from the two \\ on the front of the
                // remote file name add one to target.
                //
                Nbtstrcat(path,target+1,Len+sizeof("\\DosDevices\\UNC"));
            }
            break;

        case 3:
            // the target is the full path
            Len = strlen(target) + 1;
            path = NbtAllocMem (Len, NBT_TAG2('14'));
            if (path)
            {
                strncpy(path,target,Len);
            }
            break;


    }

    if (path)
    {
        *ppath = path;
        return(STATUS_SUCCESS);
    }
    else
        return(STATUS_UNSUCCESSFUL);
} // LmGetFullPath


//----------------------------------------------------------------------------
VOID
DelayedScanLmHostFile (
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pUnused2,
    IN  PVOID                   pUnused3,
    IN  tDEVICECONTEXT          *pDeviceContext
    )

/*++

Routine Description:

    This function is called by the Executive Worker thread to scan the
    LmHost file looking for a name. The name to query is on a list in
    the DNSQueries structure.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    NTSTATUS                status;
    LONG                    IpAddress;
    ULONG                   IpAddrsList[2];
    BOOLEAN                 bFound;
    NBT_WORK_ITEM_CONTEXT   *pContext;
    BOOLEAN                 DoingDnsResolve = FALSE;
    UCHAR                   pName[NETBIOS_NAME_SIZE];
    PUCHAR                  LmHostsPath;
    ULONG                   LoopCount;
    tDGRAM_SEND_TRACKING   *pTracker;
    tDGRAM_SEND_TRACKING   *pTracker0;

    CTEPagedCode();

    LoopCount = 0;
    while (TRUE)
    {
        // get the next name on the linked list of LmHost name queries that
        // are pending
        //
        pContext = NULL;
        DoingDnsResolve = FALSE;

        if (!(pContext = GetNameToFind(pName)))
        {
            return;
        }

        LoopCount ++;

        IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint(("Nbt.DelayedScanLmHostFile: Lmhosts pName = %15.15s<%X>,LoopCount=%X\n",
                pName,pName[15],LoopCount));

        status = STATUS_TIMEOUT;

        //
        // check if the name is in the lmhosts file or pass to Dns if
        // DNS is enabled
        //
        IpAddress = 0;
        if (NbtConfig.EnableLmHosts)
        {
#ifdef VXD
            //
            // if for some reason PrimeCache failed at startup time
            // then this is when we retry.
            //
            if (!CachePrimed)
            {
                if (PrimeCache (NbtConfig.pLmHosts, NULL, MAX_RECURSE_DEPTH, NULL) != -1)
                {
                    CachePrimed = TRUE ;
                }
            }
#endif

            //
            // The NbtConfig.pLmHosts path can change if the registry is
            // read during this interval
            // We cannot acquire the ResourceLock here since reading the
            // LmHosts file might result in File operations + network reads
            // that could cause a deadlock (Worker threads / ResourceLock)!
            // Best solution at this time is to copy the path onto a local
            // buffer under the Resource lock, and then try to read the file!
            //
            CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
            if ((NbtConfig.pLmHosts) &&
                (LmHostsPath = NbtAllocMem ((strlen(NbtConfig.pLmHosts)+1), NBT_TAG2('20'))))
            {
                CTEMemCopy (LmHostsPath, NbtConfig.pLmHosts, (strlen(NbtConfig.pLmHosts)+1));
                CTEExReleaseResource(&NbtConfig.Resource);

                IpAddress = LmGetIpAddr(LmHostsPath, pName, 1, &bFound);

                CTEMemFree(LmHostsPath);
            }
            else
            {
                CTEExReleaseResource(&NbtConfig.Resource);
                IpAddress = 0;
            }
#ifdef VXD
            //
            // hmmm.. didn't find it in lmhosts: try hosts (if Dns is enabled)
            //
            if ((IpAddress == (ULONG)0) && (NbtConfig.ResolveWithDns))
            {
                IpAddress = LmGetIpAddr(NbtConfig.pHosts, pName, 1, &bFound);
            }
#endif
        }


        if (IpAddress == (ULONG)0)
        {
            // check if the name query has been cancelled
            //
            LOCATION(0x61);
            GetContext (&pContext);
            //
            // for some reason we didn't find our context: maybe cancelled.
            // Go back to the big while loop...
            //
            if (!pContext)
            {
                continue;
            }

            //
            // see if the name is in the 11.101.4.26 format: if so, we got the
            // ipaddr!  Use that ipaddr to get the server name
            //
            pTracker = ((NBT_WORK_ITEM_CONTEXT *)pContext)->pTracker;
            pTracker0 = (tDGRAM_SEND_TRACKING *)((NBT_WORK_ITEM_CONTEXT *)pContext)->pClientContext;

            if (pTracker0->Flags & (REMOTE_ADAPTER_STAT_FLAG|SESSION_SETUP_FLAG|DGRAM_SEND_FLAG))
            {
                IpAddress = Nbt_inet_addr(pTracker->pNameAddr->Name, pTracker0->Flags);
            }

            //
            // yes, the name is the ipaddr: NbtCompleteLmhSvcRequest() starts
            // the process of finding out server name for this ipaddr
            //
            if (IpAddress)
            {
                IpAddrsList[0] = IpAddress;
                IpAddrsList[1] = 0;

		        //
		        // if this is in response to an adapter stat command (e.g.nbtstat -a) then
		        // don't try to find the server name (using remote adapter status!)
		        //
		        if (pTracker0->Flags & REMOTE_ADAPTER_STAT_FLAG)
		        {
		            //
		            // change the state to resolved if the name query is still pending
		            //
                    status = ChangeStateOfName(IpAddress, pContext, &pContext, NAME_RESOLVED_BY_IP);
		        }
		        else
		        {
		            NbtCompleteLmhSvcRequest(pContext, IpAddrsList, NBT_RESOLVE_WITH_DNS, 0, NULL, TRUE);
		            //
		            // done with this name query: go back to the big while loop
		            //
		            continue;
		        }
            }

            //
            //
            // inet_addr failed.  If DNS resolution is enabled, try DNS
            else if ((NbtConfig.ResolveWithDns) &&
                     (!(pTracker0->Flags & NO_DNS_RESOLUTION_FLAG)))
            {
                status = NbtProcessLmhSvcRequest (pContext, NBT_RESOLVE_WITH_DNS);

                if (NT_SUCCESS(status))
                {
                    DoingDnsResolve = TRUE;
                }
            }
        }
        else   // if (IpAddress != (ULONG)0)
        {
            //
            // change the state to resolved if the name query is still pending
            //
            status = ChangeStateOfName(IpAddress, NULL, &pContext, NAME_RESOLVED_BY_LMH);
        }

        //
        // if DNS gets involved, then we wait for that to complete before calling
        // completion routine.
        //
        if (!DoingDnsResolve)
        {
            LOCATION(0x60);
            RemoveNameAndCompleteReq((NBT_WORK_ITEM_CONTEXT *)pContext, status);
        }

    }// of while(TRUE)
}

//----------------------------------------------------------------------------
ULONG
AddToDomainList (
    IN PUCHAR           pName,
    IN tIPADDRESS       IpAddress,
    IN PLIST_ENTRY      pDomainHead,
    IN BOOLEAN          fPreload
    )

/*++

Routine Description:

    This function adds a name and ip address to the list of domains that
    are stored in a list.


Arguments:

Return Value:


--*/


{
    PLIST_ENTRY                pHead;
    PLIST_ENTRY                pEntry;
    tNAMEADDR                  *pNameAddr=NULL;
    tIPADDRESS                 *pIpAddr;

    CTEPagedCode();

    pHead = pEntry = pDomainHead;
    if (!IsListEmpty(pDomainHead))
    {
        pNameAddr = FindInDomainList(pName,pDomainHead);
        if (pNameAddr)
        {
            //
            // the name matches, so add to the end of the ip address list
            //
            if (pNameAddr->CurrentLength < pNameAddr->MaxDomainAddrLength)
            {
                pIpAddr = pNameAddr->pLmhSvcGroupList;

                while (*pIpAddr != (ULONG)-1) {
                    pIpAddr++;
                }

                *pIpAddr++ = IpAddress;
                *pIpAddr = (ULONG)-1;
                pNameAddr->CurrentLength += sizeof(ULONG);
            }
            else
            {
                //
                // need to allocate more memory for for ip addresses
                //
                if (pIpAddr = NbtAllocMem (pNameAddr->MaxDomainAddrLength+INITIAL_DOM_SIZE, NBT_TAG2('08')))
                {
                    CTEMemCopy(pIpAddr, pNameAddr->pLmhSvcGroupList, pNameAddr->MaxDomainAddrLength);

                    //
                    // Free the old chunk of memory and tack the new one on
                    // to the pNameaddr
                    //
                    CTEMemFree(pNameAddr->pLmhSvcGroupList);
                    pNameAddr->pLmhSvcGroupList = pIpAddr;

                    pIpAddr = (PULONG)((PUCHAR)pIpAddr + pNameAddr->MaxDomainAddrLength);

                    //
                    // our last entry was -1: overwrite that one
                    //
                    pIpAddr--;

                    *pIpAddr++ = IpAddress;
                    *pIpAddr = (ULONG)-1;

                    //
                    // update the number of addresses in the list so far
                    //
                    pNameAddr->MaxDomainAddrLength += INITIAL_DOM_SIZE;
                    pNameAddr->CurrentLength += sizeof(ULONG);
                    pNameAddr->Verify = REMOTE_NAME;
                }
            }
        }
    }

    //
    // check if we found the name or we need to add a new name
    //
    if (!pNameAddr)
    {
        //
        // create a new name for the domain list
        //
        if (pNameAddr = NbtAllocMem (sizeof(tNAMEADDR), NBT_TAG2('09')))
        {
            CTEZeroMemory(pNameAddr,sizeof(tNAMEADDR));
            pIpAddr = NbtAllocMem (INITIAL_DOM_SIZE, NBT_TAG2('10'));
            if (pIpAddr)
            {
                CTEMemCopy(pNameAddr->Name,pName,NETBIOS_NAME_SIZE);
                pNameAddr->pLmhSvcGroupList = pIpAddr;
                *pIpAddr++ = IpAddress;
                *pIpAddr = (ULONG)-1;

                pNameAddr->NameTypeState = NAMETYPE_INET_GROUP;
                pNameAddr->MaxDomainAddrLength = INITIAL_DOM_SIZE;
                pNameAddr->CurrentLength = 2*sizeof(ULONG);
                pNameAddr->Verify = REMOTE_NAME;
                NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE);

                InsertHeadList(pDomainHead,&pNameAddr->Linkage);
            }
            else
            {
                CTEMemFree(pNameAddr);
                pNameAddr = NULL;
            }
        }
    }

    if (pNameAddr && fPreload)
    {
        pNameAddr->fPreload = TRUE;
    }

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
tNAMEADDR *
FindInDomainList (
    IN PUCHAR           pName,
    IN PLIST_ENTRY      pDomainHead
    )

/*++

Routine Description:

    This function finds a name in the domain list passed in.

Arguments:

    name to find
    head of list to look on

Return Value:

    ptr to pNameaddr

--*/
{
    PLIST_ENTRY                pHead;
    PLIST_ENTRY                pEntry;
    tNAMEADDR                  *pNameAddr;

    pHead = pEntry = pDomainHead;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
        if (strncmp(pNameAddr->Name,pName,NETBIOS_NAME_SIZE) == 0)
        {
            return(pNameAddr);
        }
    }

    return(NULL);
}

//----------------------------------------------------------------------------
VOID
MakeNewListCurrent (
    PLIST_ENTRY     pTmpDomainList
    )

/*++

Routine Description:

    This function frees the old entries on the DomainList and hooks up the
    new entries

Arguments:

    pTmpDomainList  - list entry to the head of a new domain list

Return Value:


--*/


{
    CTELockHandle   OldIrq;
    tNAMEADDR       *pNameAddr;
    PLIST_ENTRY     pEntry;
    PLIST_ENTRY     pHead;
    NTSTATUS        status;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (!IsListEmpty(pTmpDomainList))
    {
        //
        // free the old list elements
        //
        pHead = &DomainNames.DomainList;
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;

            RemoveEntryList(&pNameAddr->Linkage);
            //
            // initialize linkage so that if the nameaddr is being
            // referenced now, when it does get freed in a subsequent
            // call to NBT_DEREFERENCE_NAMEADDR it will not
            // remove it from any lists
            //
            InitializeListHead(&pNameAddr->Linkage);

            //
            // Since the name could be in use now we must dereference rather
            // than just free it outright
            //
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
        }

        //
        // See if any of the new names has to be preloaded!
        //
        pEntry = pTmpDomainList->Flink;
        while (pEntry != pTmpDomainList)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;

            if (pNameAddr->fPreload)
            {
                RemoveEntryList(&pNameAddr->Linkage);
                InitializeListHead(&pNameAddr->Linkage);

                status = AddToHashTable (NbtConfig.pRemoteHashTbl,
                                         pNameAddr->Name,
                                         NbtConfig.pScope,
                                         0,
                                         0,
                                         pNameAddr,
                                         &pNameAddr,
                                         NULL,
                                         NAME_RESOLVED_BY_LMH_P | NAME_ADD_INET_GROUP);

                if ((status == STATUS_SUCCESS) ||
                    ((status == STATUS_PENDING) &&
                     (!(pNameAddr->NameTypeState & PRELOADED))))
                {
                    //
                    // this prevents the name from being deleted by the Hash Timeout code
                    //
                    NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_PRELOADED);
                    pNameAddr->Ttl = 0xFFFFFFFF;
                    pNameAddr->NameTypeState |= PRELOADED | STATE_RESOLVED;
                    pNameAddr->NameTypeState &= ~STATE_CONFLICT;
                    pNameAddr->AdapterMask = (CTEULONGLONG)-1;
                }
            }
        }

        DomainNames.DomainList.Flink = pTmpDomainList->Flink;
        DomainNames.DomainList.Blink = pTmpDomainList->Blink;
        pTmpDomainList->Flink->Blink = &DomainNames.DomainList;
        pTmpDomainList->Blink->Flink = &DomainNames.DomainList;
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

}



//----------------------------------------------------------------------------
NTSTATUS
NtProcessLmHSvcIrp(
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  PVOID                   *pBuffer,
    IN  LONG                    Size,
    IN  PCTE_IRP                pIrp,
    IN  enum eNbtLmhRequestType RequestType
    )
/*++

Routine Description:

    This function is used by LmHsvc Dll to collect requests for
    Pinging IP addresses or querying through DNS.
    The request is sent to LmhSvc in the buffer associated with
    this request.

Arguments:

Return Value:
    STATUS_PENDING if the buffer is to be held on to, the normal case.

Notes:


--*/

{
    NTSTATUS                        status;
    NTSTATUS                        Locstatus;
    CTELockHandle                   OldIrq;
    tIPADDR_BUFFER_DNS              *pIpAddrBuf;
    PVOID                           pClientCompletion;
    PVOID                           pClientContext;
    tDGRAM_SEND_TRACKING            *pTracker;
    ULONG                           IpAddrsList[MAX_IPADDRS_PER_HOST+1];
    NBT_WORK_ITEM_CONTEXT           *pContext;
    BOOLEAN                         CompletingAnotherQuery = FALSE;
    tLMHSVC_REQUESTS                *pLmhRequest;
    tDEVICECONTEXT                  *pDeviceContextRequest;

    pIpAddrBuf = (tIPADDR_BUFFER_DNS *)pBuffer;

    switch (RequestType)
    {
        case NBT_PING_IP_ADDRS:
        {
            pLmhRequest = &CheckAddr;
            break;
        }

        case NBT_RESOLVE_WITH_DNS:
        {
            pLmhRequest = &DnsQueries;
            break;
        }

        default:
        {
            ASSERTMSG ("Nbt.NtProcessLmHSvcIrp: ERROR - Invalid Request from LmhSvc Dll\n", 0);
            return STATUS_UNSUCCESSFUL;
        }
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    //
    // If we already have an Irp posted, return this Irp -- Bug # 311924
    //
    if ((pLmhRequest->QueryIrp) &&
        (!pLmhRequest->ResolvingNow))
    {
        CTESpinFree (&NbtConfig.JointLock,OldIrq);
        KdPrint (("Nbt.NtProcessLmHSvcIrp: ERROR -- duplicate request Irp!\n"));
        NTIoComplete (pIrp, STATUS_OBJECT_PATH_INVALID, 0);
        NbtTrace(NBT_TRACE_NAMESRV, ("duplicate Lmhosts request"));
        return STATUS_OBJECT_PATH_INVALID;
    }

    IoMarkIrpPending(pIrp);
    pLmhRequest->QueryIrp = pIrp;
    status = STATUS_PENDING;
    if (pLmhRequest->ResolvingNow)
    {
        //
        // if the client got tired of waiting for DNS, the NbtCancelWaitForLmhSvcIrp
        // in ntisol.c will have cleared the pContext value when cancelling the
        // irp, so check for that here.
        //
        if (pLmhRequest->Context)
        {
            pContext = (NBT_WORK_ITEM_CONTEXT *) pLmhRequest->Context;
            pLmhRequest->Context = NULL;
            pDeviceContextRequest = pContext->pDeviceContext;

            if (NBT_REFERENCE_DEVICE (pDeviceContextRequest, REF_DEV_LMH, TRUE))
            {
                NbtCancelCancelRoutine (((tDGRAM_SEND_TRACKING *) (pContext->pClientContext))->pClientIrp);
                CTESpinFree(&NbtConfig.JointLock,OldIrq);

                ASSERT(sizeof(pIpAddrBuf->pwName) == DNS_NAME_BUFFER_LENGTH * sizeof(pIpAddrBuf->pwName[0]));
                pIpAddrBuf->pwName[DNS_NAME_BUFFER_LENGTH-1] = 0;
                NbtCompleteLmhSvcRequest (pContext,
                                          pIpAddrBuf->IpAddrsList,
                                          RequestType,
                                          pIpAddrBuf->NameLen,
                                          pIpAddrBuf->pwName,
                                          (BOOLEAN)pIpAddrBuf->Resolved);

                CTESpinLock(&NbtConfig.JointLock,OldIrq);
                NBT_DEREFERENCE_DEVICE (pDeviceContextRequest, REF_DEV_LMH, TRUE);
            }
            else
            {
                ASSERT (0);
            }
        }
        else
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NtProcessLmHSvcIrp[%s]: No Context!! *******\r\n",
                    (RequestType == NBT_RESOLVE_WITH_DNS ? "NBT_RESOLVE_WITH_DNS" : "NBT_PING_IP_ADDRS")));
        }

        pLmhRequest->ResolvingNow = FALSE;
        //
        // are there any more name query requests to process?
        //
        while (!IsListEmpty(&pLmhRequest->ToResolve))
        {
            PLIST_ENTRY     pEntry;

            pEntry = RemoveHeadList(&pLmhRequest->ToResolve);
            pContext = CONTAINING_RECORD(pEntry,NBT_WORK_ITEM_CONTEXT,Linkage);

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            Locstatus = NbtProcessLmhSvcRequest (pContext, RequestType);
            if (NT_SUCCESS(Locstatus))
            {
                CTESpinLock(&NbtConfig.JointLock,OldIrq);
                CompletingAnotherQuery = TRUE;
                break;
            }

            //
            // if it failed then complete the irp now
            //
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NtProcessLmHSvcIrp[%s]: NbtProcessLmhSvcRequest failed with %x\r\n",
                    (RequestType==NBT_RESOLVE_WITH_DNS ? "NBT_RESOLVE_WITH_DNS":"NBT_PING_IP_ADDRS"),
                    Locstatus));
            pClientCompletion = pContext->ClientCompletion;
            pClientContext = pContext->pClientContext;
            pTracker = pContext->pTracker;

            //
            // Clear the Cancel Routine now
            //
            (VOID)NbtCancelCancelRoutine(((tDGRAM_SEND_TRACKING *)pClientContext)->pClientIrp);

            if (pTracker)
            {
                if (pTracker->pNameAddr)
                {
                    SetNameState (pTracker->pNameAddr, NULL, FALSE);
                    pTracker->pNameAddr = NULL;
                }

                //
                // pTracker is NULL for Ping requests, hence this dereference is
                // done only for Dns requests
                //
                NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
            }

            CompleteClientReq(pClientCompletion, pClientContext, STATUS_BAD_NETWORK_PATH);
            CTEMemFree(pContext);

            CTESpinLock(&NbtConfig.JointLock,OldIrq);
        }
    }

    //
    // We are holding onto the Irp, so set the cancel routine.
    // (Since we may have released the lock earlier, we also need
    //  to ensure that no other Query has completed the Irp!)
    //
    if ((!CompletingAnotherQuery) &&
        (!pLmhRequest->ResolvingNow) &&
        (pLmhRequest->QueryIrp == pIrp))
    {
        status = NTCheckSetCancelRoutine(pIrp, NbtCancelLmhSvcIrp, pDeviceContext);
        if (!NT_SUCCESS(status))
        {
            // the irp got cancelled so complete it now
            //
            pLmhRequest->QueryIrp = NULL;
            pLmhRequest->pIpAddrBuf = NULL;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NTIoComplete(pIrp,status,0);
        }
        else
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            status = STATUS_PENDING;
        }
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtProcessLmhSvcRequest(
    IN  NBT_WORK_ITEM_CONTEXT   *pContext,
    IN  enum eNbtLmhRequestType RequestType
    )
/*++

Routine Description:

    This function is called to pass a NBT request to ping IP addrs
    or query DNS to the LmhSvc Dll

Arguments:

Return Value:

    STATUS_PENDING if the buffer is to be held on to , the normal case.

Notes:


--*/

{
    NTSTATUS                status = STATUS_SUCCESS;
    tIPADDR_BUFFER_DNS      *pIpAddrBuf;
    PCTE_IRP                pIrp;
    tDGRAM_SEND_TRACKING    *pTracker;
    tDGRAM_SEND_TRACKING    *pClientTracker;
    CTELockHandle           OldIrq;
    PCHAR                   pDestName;
    ULONG                   NameLen, NumAddrs;
    tLMHSVC_REQUESTS        *pLmhRequest;

    switch (RequestType)
    {
        case NBT_PING_IP_ADDRS:
        {
            pLmhRequest = &CheckAddr;
            break;
        }

        case NBT_RESOLVE_WITH_DNS:
        {
            pLmhRequest = &DnsQueries;
            break;
        }

        default:
        {
            ASSERTMSG ("Nbt.NbtProcessLmHSvcRequest: ERROR - Invalid Request type\n", 0);
            return STATUS_UNSUCCESSFUL;
        }
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pContext->TimedOut = FALSE;
    if ((!NBT_VERIFY_HANDLE (pContext->pDeviceContext, NBT_VERIFY_DEVCONTEXT)) ||
        (!pLmhRequest->QueryIrp))
    {
        //
        // Either the device is going away, or
        // the irp either never made it down here, or it was cancelled,
        // so pretend the name query timed out.
        //
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtProcessLmhSvcRequest[%s]: QueryIrp is NULL, returning\r\n",
                (RequestType == NBT_RESOLVE_WITH_DNS ? "NBT_RESOLVE_WITH_DNS" : "NBT_PING_IP_ADDRS")));
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        if (pLmhRequest->QueryIrp) {
            NbtTrace(NBT_TRACE_NAMESRV, ("return STATUS_BAD_NETWORK_PATH because the device is going away"));
        } else {
            NbtTrace(NBT_TRACE_NAMESRV, ("LmHost services didn't start"));
        }
        return(STATUS_BAD_NETWORK_PATH);
    }
    else if (!pLmhRequest->ResolvingNow)
    {
        pIrp = pLmhRequest->QueryIrp;
        if ((!pLmhRequest->pIpAddrBuf) &&
            (!(pLmhRequest->pIpAddrBuf = (tIPADDR_BUFFER_DNS *)
                                         MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority))))
        {
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NbtTrace(NBT_TRACE_NAMESRV, ("returns STATUS_UNSUCCESSFUL"));
            return(STATUS_UNSUCCESSFUL);
        }

        pIpAddrBuf = pLmhRequest->pIpAddrBuf;
        pLmhRequest->ResolvingNow = TRUE;
        pLmhRequest->Context = pContext;

        pTracker = pContext->pTracker;           // this is the name query tracker (for Dns queries only)
        pClientTracker = (tDGRAM_SEND_TRACKING *)pContext->pClientContext; // session setup tracker

        switch (RequestType)
        {
            case NBT_PING_IP_ADDRS:
            {
                ASSERT(pTracker == NULL);

                //
                // copy the IP addrs for lmhsvc to ping (upto MAX_IPADDRS_PER_HOST) ...
                //
                NumAddrs = pClientTracker->NumAddrs > MAX_IPADDRS_PER_HOST ?
                                MAX_IPADDRS_PER_HOST : pClientTracker->NumAddrs;
                CTEMemCopy(pIpAddrBuf->IpAddrsList, pClientTracker->IpList, NumAddrs * sizeof(ULONG));
                pIpAddrBuf->IpAddrsList[NumAddrs] = 0;
                break;
            }
            case NBT_RESOLVE_WITH_DNS:
            {
                WCHAR   *UnicodeDestName;

                UnicodeDestName =  pClientTracker? pClientTracker->UnicodeDestName: NULL;

                //
                // whenever dest. name is 16 bytes long (or smaller), we have no
                // way of knowing if its a netbios name or a dns name, so we presume
                // it's netbios name, go to wins, broadcast etc. and then come to dns
                // In this case, the name query tracker will be setup, so be non-null
                //
                if (pTracker)
                {
                    pDestName = pTracker->pNameAddr->Name;
                    NameLen = NETBIOS_NAME_SIZE;
                }
                //
                // if the dest name is longer than 16 bytes, it's got to be dns name so
                // we bypass wins etc. and come straight to dns.  In this case, we didn't
                // set up a name query tracker so it will be null.  Use the session setup
                // tracker (i.e. pClientTracker) to get the dest name
                //
                else
                {
                    ASSERT(pClientTracker);

                    pDestName = pClientTracker->pDestName;
                    NameLen = pClientTracker->RemoteNameLength;
                }

                if ((NameLen == NETBIOS_NAME_SIZE) &&
                    (!(IsValidDnsNameTag (pDestName[NETBIOS_NAME_SIZE-1]))))
                {
                    NbtTrace(NBT_TRACE_NAMESRV, ("returns STATUS_BAD_NETWORK_PATH %02x",
                                            (unsigned)pDestName[NETBIOS_NAME_SIZE-1]));
                    status = STATUS_BAD_NETWORK_PATH;
                }
                else
                {
                    //
                    // Ignore the 16th byte only if it is a non-DNS name character (we should be
                    // safe below 0x20). This will allow queries to DNS names which are exactly 16
                    // characters long.
                    //
                    if (NameLen == NETBIOS_NAME_SIZE)
                    {
                        if ((pDestName[NETBIOS_NAME_SIZE-1] <= 0x20 ) ||
                            (pDestName[NETBIOS_NAME_SIZE-1] >= 0x7f ))
                        {
                            NameLen = NETBIOS_NAME_SIZE-1;          // ignore 16th byte
                        }
                    }
                    else if (NameLen > DNS_MAX_NAME_LENGTH)
                    {
                        NameLen = DNS_MAX_NAME_LENGTH;
                    }

                    //
                    // copy the name to the Irps return buffer for lmhsvc to resolve with
                    // a gethostbyname call
                    //

                    if (UnicodeDestName) {
                        int len;

                        len = pClientTracker->UnicodeRemoteNameLength;
                        if (len > sizeof(pIpAddrBuf->pwName - sizeof(WCHAR))) {
                            len = sizeof(pIpAddrBuf->pwName) - sizeof(WCHAR);
                        }
                        ASSERT((len % sizeof(WCHAR)) == 0);
                        CTEMemCopy(pIpAddrBuf->pwName, UnicodeDestName, len);
                        pIpAddrBuf->pwName[len/sizeof(WCHAR)] = 0;
                        pIpAddrBuf->NameLen = len;
                        pIpAddrBuf->bUnicode = TRUE;
                    } else {
                        //
                        // I would like to maintain only UNICODE interface between NetBT and LmhSVC.
                        // But I cannot do RtlAnsiStringToUnicodeString here due to IRQ level here.
                        //
                        pIpAddrBuf->bUnicode = FALSE;
                        CTEMemCopy(pIpAddrBuf->pName, pDestName, NameLen);
                        pIpAddrBuf->pName[NameLen] = 0;
                        pIpAddrBuf->NameLen = NameLen;
                    }
                }

                break;
            }

            default:
            {
                //
                // This code path should never be hit!
                //
                ASSERT(0);
            }
        }   // switch

        //
        // Since datagrams are buffered there is no client irp to get cancelled
        // since the client's irp is returned immediately -so this check
        // is only for connections being setup or QueryFindname or
        // nodestatus, where we allow the irp to
        // be cancelled.
        //
        if ((NT_SUCCESS(status)) &&
            (pClientTracker->pClientIrp))
        {
            //
            // allow the client to cancel the name query Irp - no need to check
            // if the client irp was already cancelled or not since the DNS query
            // will complete and find no client request and stop.
            //
            status = NTCheckSetCancelRoutine(pClientTracker->pClientIrp, NbtCancelWaitForLmhSvcIrp,NULL);
        }

        //
        // pass the irp up to lmhsvc.dll to do a gethostbyname call to
        // sockets
        // The Irp will return to NtDnsNameResolve, above
        //
        if (NT_SUCCESS(status))
        {
            pLmhRequest->pIpAddrBuf = NULL;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            NTIoComplete(pLmhRequest->QueryIrp,STATUS_SUCCESS,0);
            return (STATUS_PENDING);
        }

        //
        // We failed to set the cancel routine, so undo setting up the
        // the pLmhRequest structure.
        //
        NbtTrace(NBT_TRACE_NAMESRV, ("returns %!status!", status));
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtProcessLmhSvcRequest[%s]: CheckSet (submitting) failed with %x\r\n",
            (RequestType == NBT_RESOLVE_WITH_DNS ? "NBT_RESOLVE_WITH_DNS" : "NBT_PING_IP_ADDRS"),status));
        pLmhRequest->ResolvingNow = FALSE;
        pLmhRequest->Context = NULL;
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
    else
    {
        pClientTracker = (tDGRAM_SEND_TRACKING *)pContext->pClientContext;
        //
        // Since datagrams are buffered there is no client irp to get cancelled
        // since the client's irp is returned immediately -so this check
        // is only for connections being setup, where we allow the irp to
        // be cancelled.
        //
        //
        // allow the client to cancel the name query Irp
        //
        if (pClientTracker->pClientIrp)         // check if this is the session setup tracker
        {
            status = NTCheckSetCancelRoutine(pClientTracker->pClientIrp, NbtCancelWaitForLmhSvcIrp,NULL);
        }

        if (NT_SUCCESS(status))
        {
            // the irp is busy resolving another name, so wait for it to return
            // down here again, mean while, Queue the name query
            //
            InsertTailList(&pLmhRequest->ToResolve, &pContext->Linkage);
        }
        else
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtProcessLmhSvcRequest[%s]: CheckSet (queuing) failed with %x\r\n",
                (RequestType == NBT_RESOLVE_WITH_DNS ? "NBT_RESOLVE_WITH_DNS" : "NBT_PING_IP_ADDRS"),status));
            NbtTrace(NBT_TRACE_NAMESRV, ("returns %!status!", status));
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    if (NT_SUCCESS(status))
    {
        status = STATUS_PENDING;
    }

    return(status);
}


//----------------------------------------------------------------------------
extern
VOID
SetNameState(
    IN  tNAMEADDR   *pNameAddr,
    IN  PULONG      pIpList,
    IN  BOOLEAN     IpAddrResolved
    )

/*++

Routine Description:

    This function dereferences the pNameAddr and sets the state to Released
    just incase the dereference does not delete the entry right away, due to
    another outstanding reference against the name.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    CTELockHandle   OldIrq;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (IpAddrResolved)
    {
        pNameAddr->IpAddress = pIpList[0];
    }
    else
    {
        pNameAddr->NameTypeState &= ~NAME_STATE_MASK;
        pNameAddr->NameTypeState |= STATE_RELEASED;
        pNameAddr->pTracker = NULL;
    }

    ASSERT (pNameAddr->RefCount == 1);
    InterlockedDecrement(&NbtConfig.lNumPendingNameQueries);
    NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}


//----------------------------------------------------------------------------
VOID
NbtCompleteLmhSvcRequest(
    IN  NBT_WORK_ITEM_CONTEXT   *Context,
    IN  ULONG                   *IpList,
    IN  enum eNbtLmhRequestType RequestType,
    IN  ULONG                   lNameLength,
    IN  PWSTR                   pwsName,        // The rosolved name return by LmhSvc
    IN  BOOLEAN                 IpAddrResolved
    )
/*++

Routine Description:

    If the destination name is of the form 11.101.4.25 or is a dns name (i.e. of
    the form ftp.microsoft.com) then we come to this function.  In addition to
    doing some house keeping, if the name did resolve then we also send out
    a nodestatus request to find out the server name for that ipaddr

Arguments:

    Context        - (NBT_WORK_ITEM_CONTEXT)
    IpList         - Array of ipaddrs if resolved (i.e. IpAddrResolved is TRUE)
    IpAddrResolved - TRUE if ipaddr could be resolved, FALSE otherwise

Return Value:

    Nothing

Notes:


--*/

{

    NTSTATUS                status;
    PVOID                   pClientCompletion;
    tDGRAM_SEND_TRACKING    *pTracker;
    tDGRAM_SEND_TRACKING    *pClientTracker;
    ULONG                   TdiAddressType = TDI_ADDRESS_TYPE_NETBIOS;
    ULONG                   IpAddrsList[MAX_IPADDRS_PER_HOST+1];
    tDEVICECONTEXT          *pDeviceContext;
    int                     i;
    tCONNECTELE             *pConnEle;

    CTEPagedCode();

    IF_DBG(NBT_DEBUG_NAMESRV)
       KdPrint(("Nbt.NbtCompleteLmhSvcRequest: Entered ...\n"));

    pTracker = Context->pTracker;
    pClientCompletion = Context->ClientCompletion;
    pClientTracker = (tDGRAM_SEND_TRACKING *) Context->pClientContext;
    pDeviceContext = pClientTracker->pDeviceContext;

    // whether or not name resolved, we don't need this nameaddr anymore
    // (if name resolved, then we do a node status to that addr and create
    // a new nameaddr for the server name in ExtractServerName)
    // pTracker is null if we went straight to dns (without wins etc)
    if (pTracker)
    {
        //
        // Set some info in case some client is still resolving the name
        //
        SetNameState (pTracker->pNameAddr, IpList, IpAddrResolved);
        pTracker->pNameAddr = NULL;
    }

    (VOID)NbtCancelCancelRoutine (pClientTracker->pClientIrp);
    pClientTracker->pTrackerWorker = NULL;  // The original NameQuery Tracker will be dereferenced below

    status = STATUS_BAD_NETWORK_PATH;

    if (RequestType == NBT_RESOLVE_WITH_DNS)
    {
        TdiAddressType = ((pTracker == NULL) ? pClientTracker->AddressType: TDI_ADDRESS_TYPE_NETBIOS);
    }

    //
    // If we failed to resolve it, set the state approriately!
    //
    if (!IpAddrResolved)
    {
        if ((TdiAddressType == TDI_ADDRESS_TYPE_NETBIOS_EX) &&
            (pConnEle = pClientTracker->pConnEle))   // NULL if request was to send Datagram!
        {
            pConnEle->RemoteNameDoesNotExistInDNS = TRUE;
        }
    }
    else if (NBT_VERIFY_HANDLE(pDeviceContext, NBT_VERIFY_DEVCONTEXT)) // check if this Device is still up!
    {
        // the name was resolved successfully!
        switch (RequestType)
        {
            case NBT_RESOLVE_WITH_DNS:
            {
                // bug #20697, #95241
                if (pwsName && pClientTracker->pNetbiosUnicodeEX &&
                            (pClientTracker->pNetbiosUnicodeEX->NameBufferType == NBT_READWRITE ||
                            pClientTracker->pNetbiosUnicodeEX->NameBufferType == NBT_WRITEONLY)) {
                    UNICODE_STRING  temp;

                    temp = pClientTracker->pNetbiosUnicodeEX->RemoteName;

                    //
                    // Has the buffer changed?
                    //
                    if (memcmp(&temp, &pClientTracker->ucRemoteName, sizeof(UNICODE_STRING)) == 0) {
                        ASSERT(lNameLength <= (DNS_NAME_BUFFER_LENGTH-1) * sizeof(pwsName[0]));
                        ASSERT((lNameLength%sizeof(WCHAR)) == 0);

                        //
                        // Make sure we don't overrun the buffer
                        //
                        if (lNameLength > temp.MaximumLength - sizeof(WCHAR)) {
                            // Don't return STATUS_BUFFER_OVERFLOW since it is just a warning instead of error
                            status = STATUS_BUFFER_TOO_SMALL;
                            break;
                        }
                        CTEMemCopy(temp.Buffer, pwsName, lNameLength);
                        temp.Buffer[lNameLength/sizeof(WCHAR)] = 0;
                        temp.Length = (USHORT)lNameLength;
                        pClientTracker->pNetbiosUnicodeEX->NameBufferType = NBT_WRITTEN;
                        pClientTracker->pNetbiosUnicodeEX->RemoteName = temp;

                        IF_DBG(NBT_DEBUG_NETBIOS_EX)
                            KdPrint(("netbt!NbtCompleteLmhSvcRequest: Update Unicode Name at %d of %s\n"
                                    "\t\tDNS return (%ws)\n",
                                __LINE__, __FILE__, pwsName));
                    }
                }

                if ((TdiAddressType == TDI_ADDRESS_TYPE_NETBIOS) &&
                    (!IsDeviceNetbiosless(pDeviceContext)))         // Can't do a NodeStatus on the SMB port
                {
                    for (i=0; i<MAX_IPADDRS_PER_HOST; i++)
                    {
                        IpAddrsList[i] = IpList[i];
                        if (IpAddrsList[i] == 0)
                        {
                            break;
                        }
                    }
                    IpAddrsList[MAX_IPADDRS_PER_HOST] = 0;

                    pClientTracker->Flags |= NBT_DNS_SERVER;    // Set this so that the completion will know
                    pClientTracker->CompletionRoutine = pClientCompletion;
                    status = NbtSendNodeStatus(pDeviceContext,
                                               NULL,
                                               IpAddrsList,
                                               pClientTracker,
                                               ExtractServerNameCompletion);

                    //
                    // If we succeeded in sending a Node status, exit now,
                    // without calling the completion routine
                    //
                    if (NT_SUCCESS(status))
                    {
                        // pTracker is null if we went straight to dns (without wins etc) or
                        // if this was a Ping request
                        if (pTracker)
                        {
                            NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
                        }

                        CTEMemFree(Context);
                        return;
                    }

                    break;
                }

                //
                // The Address is of type TDI_ADDRESS_TYPE_NETBIOS_EX,
                // so now handle this scenario in the same way as for
                // for a Ping request!
                //
                // NO break!
            }

            case NBT_PING_IP_ADDRS:
            {
                //
                // add this server name to the remote hashtable
                // Call into IP to determine the outgoing interface for this address
                //
                pDeviceContext = GetDeviceFromInterface (htonl(IpList[0]), TRUE);
                status = LockAndAddToHashTable(NbtConfig.pRemoteHashTbl,
                                               pClientTracker->pDestName,
                                               NbtConfig.pScope,
                                               IpList[0],
                                               NBT_UNIQUE,
                                               NULL,
                                               NULL,
                                               pDeviceContext,
                                               (USHORT) ((RequestType == NBT_RESOLVE_WITH_DNS) ?
                                                    NAME_RESOLVED_BY_DNS : 
                                                    NAME_RESOLVED_BY_WINS | NAME_RESOLVED_BY_BCAST));


                if (pDeviceContext)
                {
                    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, FALSE);
                }

                //
                // STATUS_PENDING will be returned if the name already existed
                // in the hashtable
                //
                if (status == STATUS_PENDING)
                {
                    status = STATUS_SUCCESS;
                }

                IF_DBG(NBT_DEBUG_NAMESRV)
                    KdPrint(("Nbt.NbtCompleteLmhSvcRequest: AddRecordToHashTable Status %lx\n",status));

                break;
            }

            default:
            {
                ASSERT(0);
            }
        }   // switch
    }

    // pTracker is null if we went straight to dns (without wins etc) or
    // if this was a Ping request
    if (pTracker)
    {
        NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
    }

    NbtTrace(NBT_TRACE_NAMESRV, ("complete client request with %!status!", status));
    CompleteClientReq(pClientCompletion, pClientTracker, status);

    CTEMemFree(Context);
}
#endif  // !VXD


//----------------------------------------------------------------------------
NTSTATUS
PreloadEntry(
    IN PUCHAR       name,
    IN tIPADDRESS   inaddr
    )
/*++

Routine Description:

    This function adds an lmhosts entry to nbt's name cache.  For each
    lmhosts entry, NSUFFIXES unique cache entries are created.

    Even when some cache entries can't be created, this function doesn't
    attempt to remove any that were successfully added to the cache.

Arguments:

    name        -  the unencoded NetBIOS name specified in lmhosts
    inaddr      -  the ip address, in host byte order

Return Value:

    The number of new name cache entries created.

--*/

{
    NTSTATUS        status;
    tNAMEADDR       *pNameAddr;
    LONG            nentries;
    LONG            Len;
    CHAR            temp[NETBIOS_NAME_SIZE+1];
    CTELockHandle   OldIrq;
    LONG            NumberToAdd;
    tDEVICECONTEXT  *pDeviceContext;

    // if all 16 bytes are present then only add that name exactly as it
    // is.
    //
    Len = strlen(name);
    //
    // if this string is exactly 16 characters long, do  not expand
    // into 0x00, 0x03,0x20 names.  Just add the single name as it is.
    //
    if (Len == NETBIOS_NAME_SIZE)
    {
        NumberToAdd = 1;
    }
    else
    {
        NumberToAdd = NSUFFIXES;
    }
    for (nentries = 0; nentries < NumberToAdd; nentries++)
    {
        // for names less than 16 bytes, expand out to 16 and put a 16th byte
        // on according to the suffix array
        //
        if (Len != NETBIOS_NAME_SIZE)
        {
            LmExpandName(temp, name, Suffix[nentries]);
        }
        else
        {
            CTEMemCopy(temp,name,NETBIOS_NAME_SIZE);
        }

        pDeviceContext = GetDeviceFromInterface (htonl(inaddr), TRUE);

        CTESpinLock(&NbtConfig.JointLock,OldIrq);

        status = AddToHashTable (NbtConfig.pRemoteHashTbl,
                                 temp,
                                 NbtConfig.pScope,
                                 inaddr,
                                 NBT_UNIQUE,
                                 NULL,
                                 &pNameAddr,
                                 pDeviceContext,
                                 NAME_RESOLVED_BY_LMH_P);

        // if the name is already in the hash table, the status code is
        // status pending. This could happen if the preloads are purged
        // when one is still being referenced by another part of the code,
        // and was therefore not deleted.  We do not want to add the name
        // twice, so we just change the ip address to agree with the preload
        // value
        //
        if ((status == STATUS_SUCCESS) ||
            ((status == STATUS_PENDING) &&
             (!(pNameAddr->NameTypeState & PRELOADED))))
        {
            //
            // this prevents the name from being deleted by the Hash Timeout code
            //
            pNameAddr->NameTypeState |= PRELOADED | STATE_RESOLVED;
            pNameAddr->NameTypeState &= ~STATE_CONFLICT;
            pNameAddr->Ttl = 0xFFFFFFFF;
            pNameAddr->Verify = REMOTE_NAME;
            NBT_REFERENCE_NAMEADDR (pNameAddr, REF_NAME_PRELOADED);

            if (pDeviceContext)
            {
                pNameAddr->AdapterMask |= pDeviceContext->AdapterMask;
            }
        }
        else if (status == STATUS_PENDING)
        {
            pNameAddr->IpAddress = inaddr;
        }

        if (pDeviceContext)
        {
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, TRUE);
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(STATUS_SUCCESS);

} // PreloadEntry
//----------------------------------------------------------------------------
extern
VOID
RemovePreloads (
    )

/*++

Routine Description:

    This function removes preloaded entries from the remote hash table.
    If it finds any of the preloaded entries are active with a ref count
    above the base level of 2, then it returns true.

Arguments:

    none
Return Value:

    none

--*/

{
    tNAMEADDR       *pNameAddr;
    PLIST_ENTRY     pHead,pEntry;
    CTELockHandle   OldIrq;
    tHASHTABLE      *pHashTable;
    BOOLEAN         FoundActivePreload=FALSE;
    LONG            i;

    //
    // go through the remote table deleting names that have the PRELOAD
    // bit set.
    //
    pHashTable = NbtConfig.pRemoteHashTbl;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    for (i=0;i < pHashTable->lNumBuckets ;i++ )
    {
        pHead = &pHashTable->Bucket[i];
        pEntry = pHead->Flink;
        while (pEntry != pHead)
        {
            pNameAddr = CONTAINING_RECORD(pEntry,tNAMEADDR,Linkage);
            pEntry = pEntry->Flink;
            //
            // Delete preloaded entries that are not in use by some other
            // part of the code now.  Note that preloaded entries start with
            // a ref count of 2 so that the normal remote hashtimeout code
            // will not delete them
            //
            if ((pNameAddr->NameTypeState & PRELOADED) &&
                (pNameAddr->RefCount == 2))
            {
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_PRELOADED, TRUE);
                NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_REMOTE, TRUE);
            }
        }
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    return;
}

//----------------------------------------------------------------------------
LONG
PrimeCache(
    IN  PUCHAR  path,
    IN  PUCHAR   ignored,
    IN  CHAR    RecurseDepth,
    OUT BOOLEAN *ignored2
    )

/*++

Routine Description:

    This function is called to prime the cache with entries in the lmhosts
    file that are marked as preload entries.


Arguments:

    path        -  a fully specified path to a lmhosts file
    ignored     -  unused
    RecurseDepth-  the depth to which we can resurse -- 0 => no more recursion

Return Value:

    Number of new cache entries that were added, or -1 if there was an
    i/o error.

--*/

{
    int             nentries;
    PUCHAR          buffer;
    PLM_FILE        pfile;
    NTSTATUS        status;
    int             count, nwords;
    unsigned long   temp;
    INCLUDE_STATE   incstate;
    PUCHAR          token[MaxTokens];
    ULONG           inaddr;
    LINE_CHARACTERISTICS current;
    UCHAR           Name[NETBIOS_NAME_SIZE+1];
    ULONG           IpAddr;
    LIST_ENTRY      TmpDomainList;
    int             domtoklen;

    CTEPagedCode();

    if (!NbtConfig.EnableLmHosts)
    {
        return(STATUS_SUCCESS);
    }

    InitializeListHead(&TmpDomainList);
    //
    // Check for infinitely recursive name lookup in a #INCLUDE.
    //
    if (LmpBreakRecursion(path, "", 1) == TRUE)
    {
        return (-1);
    }

    pfile = LmOpenFile(path);

    if (!pfile)
    {
        return(-1);
    }

    nentries  = 0;
    incstate  = MustInclude;
    domtoklen = strlen(DOMAIN_TOKEN);

    while (buffer = LmFgets(pfile, &count))
    {
#ifndef VXD
        if ((NbtConfig.MaxPreloadEntries - nentries) < 3)
        {
            break;
        }
#else
        if ( nentries >= (NbtConfig.MaxPreloadEntries - 3) )
        {
            break;
        }
#endif

        nwords   = MaxTokens;
        current =  LmpGetTokens(buffer, token, &nwords);

        // if there is and error or no name on the line, then continue
        // to the next line.
        //
        if (current.l_category == ErrorLine)
        {
            IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint(("Nbt.PrimeCache: Error line in Lmhost file\n"));
            continue;
        }
        if (current.l_category != BeginAlternate && current.l_category != EndAlternate) {
            if (token[NbName] == NULL) {
                IF_DBG(NBT_DEBUG_LMHOST)
                KdPrint(("Nbt.PrimeCache: Error line in Lmhost file\n"));
                continue;
            }
        }

        if (current.l_preload)
        {
            status = ConvertDottedDecimalToUlong(token[IpAddress],&inaddr);

            if (NT_SUCCESS(status))
            {
                status = PreloadEntry (token[NbName], inaddr);
                if (NT_SUCCESS(status))
                {
                    nentries++;
                }
            }
        }
        switch ((ULONG)current.l_category)
        {
        case Domain:
            if ((nwords - 1) < GroupName)
            {
                continue;
            }

            //
            // and add '1C' on the end
            //
            LmExpandName(Name, token[GroupName]+ domtoklen, SPECIAL_GROUP_SUFFIX);

            status = ConvertDottedDecimalToUlong(token[IpAddress],&IpAddr);
            if (NT_SUCCESS(status))
            {
                AddToDomainList (Name, IpAddr, &TmpDomainList, (BOOLEAN)current.l_preload);
            }

            continue;

        case Include:

            if (!RecurseDepth || ((incstate == SkipInclude) || (nwords < 2)))
            {
                continue;
            }

#ifdef VXD
            //
            // the buffer which we read into is reused for the next file: we
            // need the contents when we get back: back it up!
            // if we can't allocate memory, just skip this include
            //
            if ( !BackupCurrentData(pfile) )
            {
                continue;
            }
#endif

            temp = LmInclude(token[1], PrimeCache, NULL, (CHAR) (RecurseDepth-1), NULL);

#ifdef VXD
            //
            // going back to previous file: restore the backed up data
            //
            RestoreOldData(pfile);
#endif

            if (temp != -1)
            {

                if (incstate == TryToInclude)
                {
                    incstate = SkipInclude;
                }
                nentries += temp;
                continue;
            }

            continue;

        case BeginAlternate:
            ASSERT(nwords == 1);
            incstate = TryToInclude;
            continue;

        case EndAlternate:
            ASSERT(nwords == 1);
            incstate = MustInclude;
            continue;

        default:
            continue;
        }

    }

    status = LmCloseFile(pfile);
    ASSERT(status == STATUS_SUCCESS);

    //
    // make this the new domain list
    //
    MakeNewListCurrent(&TmpDomainList);

    ASSERT(nentries >= 0);
    return(nentries);


} // LmPrimeCache

//----------------------------------------------------------------------------
extern
VOID
GetContext(
    IN OUT  NBT_WORK_ITEM_CONTEXT   **ppContext
    )

/*++

Routine Description:

    This function is called to get the context value to check if a name
    query has been cancelled or not.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    CTELockHandle           OldIrq;
    NBT_WORK_ITEM_CONTEXT   *pContext;

    //
    // remove the Context value and return it.
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (pContext = LmHostQueries.Context)
    {
        if ((*ppContext) &&
            (*ppContext != pContext))
        {
            pContext = NULL;
        }
#ifndef VXD
        else if (NbtCancelCancelRoutine(((tDGRAM_SEND_TRACKING *)(pContext->pClientContext))->pClientIrp)
                == STATUS_CANCELLED)
        {
            pContext = NULL;
        }
        else
#endif // VXD
        {
            LmHostQueries.Context = NULL;
        }
    }
    *ppContext = pContext;

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}


//----------------------------------------------------------------------------
extern
NTSTATUS
ChangeStateOfName (
    IN      tIPADDRESS              IpAddress,
    IN      NBT_WORK_ITEM_CONTEXT   *pContext,
    IN OUT  NBT_WORK_ITEM_CONTEXT   **ppContext,
    IN  USHORT                      NameAddFlags
    )

/*++

Routine Description:

    This function changes the state of a name and nulls the Context
    value in lmhostqueries.

Arguments:

    pContext    -   The Context value if it has been removed from the
                    LmHostQueries.Context ptr.
    ppContext   -   The Context we are processing

Return Value:

    none

--*/


{
    NTSTATUS                status;
    CTELockHandle           OldIrq;
    tDEVICECONTEXT          *pDeviceContext;

    pDeviceContext = GetDeviceFromInterface(htonl(IpAddress), TRUE);
    if (pContext == NULL)
    {
        //
        // See if the name query is still active
        //
        pContext = *ppContext;
        GetContext (&pContext);
    }

    if (pContext)
    {
        // convert broadcast addresses to zero since NBT interprets zero
        // to be broadcast
        //
        if (IpAddress == (ULONG)-1)
        {
            IpAddress = 0;
        }

        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        status = AddToHashTable (NbtConfig.pRemoteHashTbl,
                                 pContext->pTracker->pNameAddr->Name,
                                 NbtConfig.pScope,
                                 IpAddress,
                                 NBT_UNIQUE,
                                 NULL,
                                 NULL,
                                 pDeviceContext,
                                 NameAddFlags);
        //
        // this will free the pNameAddr, so do not access this after this point
        //
        InterlockedDecrement(&NbtConfig.lNumPendingNameQueries);
        NBT_DEREFERENCE_NAMEADDR (pContext->pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        pContext->pTracker->pNameAddr = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        *ppContext = pContext;
    }
    else
    {
        *ppContext = NULL;
    }

    if (pDeviceContext)
    {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_OUT_FROM_IP, FALSE);
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
RemoveLmHRequests(
    IN  tLMHSVC_REQUESTS    *pLmHRequest,
    IN  PLIST_ENTRY         pTmpHead,
    IN  tTIMERQENTRY        *pTimerQEntry,
    IN  tDEVICECONTEXT      *pDeviceContext
    )
/*++

Routine Description:

    This routine is called to find timed out entries in the queue of
    lmhost or dns name queries.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    PLIST_ENTRY             pEntry;
    NBT_WORK_ITEM_CONTEXT   *pWiContext;
    BOOLEAN                 fRestartTimer = FALSE;

    //
    // check the currently processing LMHOSTS entry
    //
    if (pLmHRequest->Context)
    {
        pWiContext = (NBT_WORK_ITEM_CONTEXT *) pLmHRequest->Context;
        if ((pWiContext->TimedOut) || (pWiContext->pDeviceContext == pDeviceContext))
        {
            pLmHRequest->Context = NULL;
            InsertTailList(pTmpHead, &pWiContext->Linkage);
#ifndef VXD
            // Not for win95, MohsinA, 05-Dec-96.
            NbtCancelCancelRoutine(((tDGRAM_SEND_TRACKING *) (pWiContext->pClientContext))->pClientIrp);
#endif
        }
        else
        {
            //
            // restart the timer
            //
            fRestartTimer = TRUE;
            pWiContext->TimedOut = TRUE;
        }
    }

    //
    // Check the list of queued entries
    //
    if (!IsListEmpty(&pLmHRequest->ToResolve))
    {
        //
        // restart the timer
        //
        fRestartTimer = TRUE;

        pEntry = pLmHRequest->ToResolve.Flink;
        while (pEntry != &pLmHRequest->ToResolve)
        {
            pWiContext = CONTAINING_RECORD(pEntry,NBT_WORK_ITEM_CONTEXT,Linkage);
            pEntry = pEntry->Flink;

            if ((pWiContext->TimedOut) || (pWiContext->pDeviceContext == pDeviceContext))
            {
                //
                // save on a temporary list and complete below
                //
                RemoveEntryList(&pWiContext->Linkage);
                InsertTailList(pTmpHead, &pWiContext->Linkage);
            }
            else
            {
                pWiContext->TimedOut = TRUE;
            }
        }
    }

    if ((fRestartTimer) && (pTimerQEntry))
    {
        pTimerQEntry->Flags |= TIMER_RESTART;
    }
}


//----------------------------------------------------------------------------
VOID
TimeoutLmHRequests(
    IN  tTIMERQENTRY        *pTimerQEntry,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  BOOLEAN             fLocked,
    IN  CTELockHandle       *pJointLockOldIrq
    )
{
    PLIST_ENTRY             pHead;
    PLIST_ENTRY             pEntry;
    NBT_WORK_ITEM_CONTEXT   *pWiContext;
    LIST_ENTRY              TmpHead;

    InitializeListHead(&TmpHead);

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,*pJointLockOldIrq);
    }

    //
    // check the currently processing LMHOSTS entry
    //
    RemoveLmHRequests (&LmHostQueries, &TmpHead, pTimerQEntry, pDeviceContext);
    RemoveLmHRequests (&CheckAddr, &TmpHead, pTimerQEntry, pDeviceContext);
#ifndef VXD
    RemoveLmHRequests (&DnsQueries, &TmpHead, pTimerQEntry, pDeviceContext);
#endif

    CTESpinFree(&NbtConfig.JointLock,*pJointLockOldIrq);

    if (!IsListEmpty(&TmpHead))
    {
        pHead = &TmpHead;
        pEntry = pHead->Flink;

        while (pEntry != pHead)
        {
            pWiContext = CONTAINING_RECORD(pEntry,NBT_WORK_ITEM_CONTEXT,Linkage);
            pEntry = pEntry->Flink;
            RemoveEntryList(&pWiContext->Linkage);

            IF_DBG(NBT_DEBUG_LMHOST)
                KdPrint(("Nbt.TimeoutLmHRequests: Context=<%p>, pDeviceContext=<%p>\n",
                    pWiContext, pDeviceContext));

            RemoveNameAndCompleteReq(pWiContext,STATUS_TIMEOUT);
        }
    }

    if (fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,*pJointLockOldIrq);
    }
}


//----------------------------------------------------------------------------
VOID
LmHostTimeout(
    PVOID               pContext,
    PVOID               pContext2,
    tTIMERQENTRY        *pTimerQEntry
    )
/*++

Routine Description:

    This routine is called by the timer code when the timer expires. It
    marks all items in Lmhosts/Dns q as timed out and completes any that have
    already timed out with status timeout.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    CTELockHandle           OldIrq;

    //
    // If the timer is NULL, it means that the Timer is currently
    // being stopped (usually at Unload time), so don't do anything!
    //
    if (!pTimerQEntry)
    {
        LmHostQueries.pTimer = NULL;
        return;
    }

    TimeoutLmHRequests (pTimerQEntry, NULL, FALSE, &OldIrq);

    // null the timer if we are not going to restart it.
    //
    if (!(pTimerQEntry->Flags & TIMER_RESTART))
    {
        LmHostQueries.pTimer = NULL;
    }
}


//----------------------------------------------------------------------------
extern
VOID
StartLmHostTimer(
    IN NBT_WORK_ITEM_CONTEXT   *pContext,
    IN BOOLEAN                 fLockedOnEntry
    )

/*++
Routine Description

    This routine handles setting up a timer to time the Lmhost entry.
    The Joint Spin Lock may be held when this routine is called

Arguments:


Return Values:

    VOID

--*/

{
    NTSTATUS        status;
    tTIMERQENTRY    *pTimerEntry;
    CTELockHandle   OldIrq;

    if (!fLockedOnEntry)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    pContext->TimedOut = FALSE;

    //
    // start the timer if it is not running
    //
    if (!LmHostQueries.pTimer)
    {
        status = StartTimer(LmHostTimeout,
                            NbtConfig.LmHostsTimeout,
                            NULL,                // context value
                            NULL,                // context2 value
                            NULL,
                            NULL,
                            NULL,
                            &pTimerEntry,
                            0,
                            TRUE);

        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.StartLmHostTimer: Start Timer to time Lmhost Qing for pContext= %x,\n", pContext));

        if (NT_SUCCESS(status))
        {
            LmHostQueries.pTimer = pTimerEntry;
        }
        else
        {
            // we failed to get a timer, but that is not
            // then end of the world.  The lmhost query will just
            // not timeout in 30 seconds.  It may take longer if
            // it tries to include a remove file on a dead machine.
            //
            LmHostQueries.pTimer = NULL;
        }
    }

    if (!fLockedOnEntry)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}


//----------------------------------------------------------------------------
NTSTATUS
LmHostQueueRequest(
    IN  tDGRAM_SEND_TRACKING    *pTracker,
    IN  PVOID                   pClientContext,
    IN  PVOID                   ClientCompletion,
    IN  PVOID                   pDeviceContext
    )
/*++

Routine Description:

    This routine exists so that LmHost requests will not take up more than
    one executive worker thread.  If a thread is busy performing an Lmhost
    request, new requests are queued otherwise we could run out of worker
    threads and lock up the system.

    The Joint Spin Lock is held when this routine is called

Arguments:
    pTracker        - the tracker block for context
    DelayedWorkerRoutine - the routine for the Workerthread to call
    pDeviceContext  - dev context that initiated this

Return Value:


--*/

{
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    NBT_WORK_ITEM_CONTEXT   *pContext;
    tDGRAM_SEND_TRACKING    *pTrackClient;
    PCTE_IRP                pIrp;
    BOOLEAN                 OnList;

    if (pContext = (NBT_WORK_ITEM_CONTEXT *)NbtAllocMem(sizeof(NBT_WORK_ITEM_CONTEXT),NBT_TAG('V')))
    {
        pContext->pTracker = pTracker;
        pContext->pClientContext = pClientContext;
        pContext->ClientCompletion = ClientCompletion;
        pContext->pDeviceContext = pDeviceContext;
        pContext->TimedOut = FALSE;

        if (LmHostQueries.ResolvingNow)
        {
            // Lmhosts is busy resolving another name, so wait for it to return
            // mean while, Queue the name query
            //
            InsertTailList(&LmHostQueries.ToResolve,&pContext->Linkage);
            OnList = TRUE;
        }
        else
        {
            LmHostQueries.Context = pContext;
            LmHostQueries.ResolvingNow = TRUE;
            OnList = FALSE;

            if (!NT_SUCCESS (NTQueueToWorkerThread(NULL, DelayedScanLmHostFile,
                                                           pTracker,
                                                           pClientContext,
                                                           ClientCompletion,
                                                           pDeviceContext,
                                                           TRUE)))
            {
                LmHostQueries.Context = NULL;
                LmHostQueries.ResolvingNow = FALSE;
                CTEMemFree(pContext);
                return (STATUS_UNSUCCESSFUL);
            }
        }

        //
        // To prevent this name query from languishing on the Lmhost Q when
        // a #include on a dead machine is trying to be openned, start the
        // connection setup timer
        //
        StartLmHostTimer(pContext, TRUE);

        //
        // this is the session setup tracker
        //
#ifndef VXD
        pTrackClient = (tDGRAM_SEND_TRACKING *)pClientContext;
        if (pIrp = pTrackClient->pClientIrp)
        {
            //
            // allow the client to cancel the name query Irp
            //
            // but do not call NTSetCancel... since it takes need to run
            // at non DPC level, and it calls the completion routine
            // which takes the JointLock that we already have.
            //
            status = NTCheckSetCancelRoutine(pTrackClient->pClientIrp, NbtCancelWaitForLmhSvcIrp,NULL);
            if (status == STATUS_CANCELLED)
            {
                //
                // since the name query is cancelled do not let lmhost processing
                // handle it.
                //
                if (OnList)
                {
                    RemoveEntryList(&pContext->Linkage);
                }
                else
                {
                    //
                    // do not set resolving now to False since the work item
                    // has been queued to the worker thread
                    //
                    LmHostQueries.Context = NULL;
                    LmHostQueries.ResolvingNow = FALSE;
                }

                CTEMemFree(pContext);
            }
            return(status);
        }
#endif
        status = STATUS_SUCCESS;
    }

    return(status);
}

//----------------------------------------------------------------------------
extern
NBT_WORK_ITEM_CONTEXT *
GetNameToFind(
    OUT PUCHAR      pName
    )

/*++

Routine Description:

    This function is called to get the name to query from the LmHostQueries
    list.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;
    NBT_WORK_ITEM_CONTEXT   *Context;
    PLIST_ENTRY             pEntry;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    // if the context value has been cleared then that name query has been
    // cancelled, so check for another one.
    //
    if (!(Context = LmHostQueries.Context))
    {
        //
        // the current name query got canceled so see if there are any more
        // to service
        //
        if (!IsListEmpty(&LmHostQueries.ToResolve))
        {
            pEntry = RemoveHeadList(&LmHostQueries.ToResolve);
            Context = CONTAINING_RECORD(pEntry,NBT_WORK_ITEM_CONTEXT,Linkage);
            LmHostQueries.Context = Context;
        }
        else
        {
            //
            // no more names to resolve, so clear the flag
            //
            LmHostQueries.ResolvingNow = FALSE;
            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            return(NULL);
        }
    }
    pTracker = ((NBT_WORK_ITEM_CONTEXT *)Context)->pTracker;


    CTEMemCopy(pName,pTracker->pNameAddr->Name,NETBIOS_NAME_SIZE);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(Context);
}
//----------------------------------------------------------------------------
extern
VOID
RemoveNameAndCompleteReq (
    IN NBT_WORK_ITEM_CONTEXT    *pContext,
    IN NTSTATUS                 status
    )

/*++

Routine Description:

    This function removes the name, cleans up the tracker
    and then completes the clients request.

Arguments:

    Context    -

Return Value:

    none

--*/


{
    tDGRAM_SEND_TRACKING    *pTracker;
    PVOID                   pClientContext;
    PVOID                   pClientCompletion;
    CTELockHandle           OldIrq;

    // if pContext is null the name query was cancelled during the
    // time it took to go read the lmhosts file, so don't do this
    // stuff
    //
    if (pContext)
    {
        pTracker = pContext->pTracker;
        pClientCompletion = pContext->ClientCompletion;
        pClientContext = pContext->pClientContext;

        CTEMemFree(pContext);

#ifndef VXD
        //
        // clear out the cancel routine if there is an irp involved
        //
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        NbtCancelCancelRoutine( ((tDGRAM_SEND_TRACKING *)(pClientContext))->pClientIrp );
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
#endif

        // remove the name from the hash table, since it did not resolve
        if (pTracker)
        {
            if ((status != STATUS_SUCCESS) &&
                (pTracker->pNameAddr))
            {
                SetNameState (pTracker->pNameAddr, NULL, FALSE);
                pTracker->pNameAddr = NULL;
            }

            // free the tracker and call the completion routine.
            //
            NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
        }

        if (pClientCompletion)
        {
            CompleteClientReq(pClientCompletion, pClientContext, status);
        }
    }
}

//----------------------------------------------------------------------------
//
//  Alternative to the c-runtime
//
#ifndef VXD
PCHAR
Nbtstrcat( PUCHAR pch, PUCHAR pCat, LONG Len )
{
    STRING StringIn;
    STRING StringOut;

    RtlInitAnsiString(&StringIn, pCat);
    RtlInitAnsiString(&StringOut, pch);
    StringOut.MaximumLength = (USHORT)Len;
    //
    // increment to include the null on the end of the string since
    // we want that on the end of the final product
    //
    StringIn.Length++;
    RtlAppendStringToString(&StringOut,&StringIn);

    return(pch);
}
#else
#define Nbtstrcat( a,b,c ) strcat( a,b )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\proxy.c ===
//
//
//  proxy.c
//
//  This file contains the Proxy related functions that implement the Bnode
//  proxy functionality.  This allows a Bnode to make use of a Name Service
//  transparently since the proxy code picks up the Bnode Query broadcasts directly
//  and either answers them directly or queries the NS and then answers them
//  later.
//  code

#include "precomp.h"
#include <ipinfo.h>
#include "proxy.tmh"

VOID
ProxyClientCompletion(
  IN PVOID            pContext,
  IN NTSTATUS         status
 );


#ifdef PROXY_NODE
//----------------------------------------------------------------------------
NTSTATUS
RegOrQueryFromNet(
    IN  BOOL                fReg,
    IN  tDEVICECONTEXT      *pDeviceContext,
    IN  tNAMEHDR UNALIGNED  *pNameHdr,
    IN  LONG                lNameSize,
    IN  PCHAR               pNameInPkt,
    IN  PUCHAR              pScope
    )
/*++

Routine Description:

    This function handles a name registration/name overwrite  or a name
    query that comes over the subnet.  It checks the remote name table.  If
    the name is there, the function simply returns.  If the name is not
    there, the function calls QueryNameOnNet to add the name to the remote table
    (in the resolving state) and to query the NS.

    Note: If the name is there in the table, it may or may not have the same
          address as the registration that we got or it may be of a different
          type.  Not doing anything for this case is ok as explained below.


Arguments:


Return Value:

    NTSTATUS - success or not - failure means no response to the net

Called By:
        QueryFromNet() in inbound.c, NameSrvHndlrNotOs() in hndlrs.c
--*/
{
    tGENERALRR          *pResrcRecord;
    ULONG               IpAddress;
    BOOLEAN             bGroupName;
    CTELockHandle       OldIrq;
    PLIST_ENTRY         pHead;
    PLIST_ENTRY         pEntry;


    //
    // if we have heard a registration on the net, get the IP address
    // and the type of registration (unique/group) from the packet.
    //
    // if we have heard a query, use default values for the above two
    // fields
    //
    if (fReg)
    {
      // get the Ip address out of the Registration request
      pResrcRecord = (tGENERALRR *) &pNameHdr->NameRR.NetBiosName[lNameSize];
      IpAddress  = ntohl(pResrcRecord->IpAddress);
      bGroupName = pResrcRecord->Flags & FL_GROUP;
    }
    else
    {
      IpAddress  = 0;
      bGroupName = NBT_UNIQUE;  //default value
    }
    //
    // The name is not there in the remote name table.
    // Add it in the RESOLVING state and send a name query
    // to the NS.
    //


    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (NbtConfig.ProxyType == PROXY_WINS) {
        NbtTrace(NBT_TRACE_PROXY, ("Send WINS Proxy query %!NBTNAME!<%02x> on %!ipaddr!",
                                    pNameInPkt, (unsigned)pNameInPkt[15], pDeviceContext->IpAddress));
        QueryNameOnNet (pNameInPkt,
                    pScope,
                    bGroupName,
                    NULL,   //client context
                    ProxyClientCompletion,
                    PROXY| (fReg?PROXY_REG: 0),
                    NULL,     //we want to add the name(pNameAddr = NULL)
                    pDeviceContext,
                    &OldIrq);
    } else {
        pHead = &NbtConfig.DeviceContexts;
        pEntry = pHead->Flink;
        while (pEntry != pHead) {
            tDEVICECONTEXT      *dev;

            dev = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
            pEntry = pEntry->Flink;

            /*
             * Make sure we are not getting the device from the DeviceAwaitingDeletion.
             * It could happen since QueryNameOnNet could temporarily release the JointLock.
             */
            if (dev->Verify != NBT_VERIFY_DEVCONTEXT) {
                break;
            }

            if (dev->IpAddress == 0 || dev->IpAddress == LOOP_BACK ||
                (!fReg && (dev->RasProxyFlags & PROXY_RAS_NONAMEQUERYFORWARDING))) {
                continue;
            }
            if (dev == pDeviceContext) {
                /* We don't want to broadcast back to the same interface through which we receive */
                continue;
            }

            /*
             * Reference the device so that it won't disappear inside QueryNameOnNet
             * Note: QueryNameOnNet may temporarily release the JointLock
             */
            NBT_REFERENCE_DEVICE(dev, REF_DEV_DGRAM, TRUE);
            NbtTrace(NBT_TRACE_PROXY, ("Send RAS Proxy query %!NBTNAME!<%02x> on %!ipaddr!",
                                    pNameInPkt, (unsigned)pNameInPkt[15], dev->IpAddress));
            QueryNameOnNet (pNameInPkt,
                        pScope,
                        bGroupName,
                        NULL,   //client context
                        ProxyClientCompletion,
                        PROXY| (fReg?PROXY_REG: 0),
                        NULL,     //we want to add the name(pNameAddr = NULL)
                        dev,
                        &OldIrq);

            /*
             * Since the QueryNameOnNet could release the lock temporarily, it is possible
             * that the device is deleted (removing from the NbtConfig.DeviceContexts
             * list) after QueryNameOnNet returns.
             * Worse than that, the pEntry may also be removed. The IP address of pEntry
             * will be 0.0.0.0 and pEntry->Flink == pEntry. We could end up with a indefinite
             * looping above.
             */
            pEntry = dev->Linkage.Flink;
            if (dev->IpAddress == 0 || dev->Verify != NBT_VERIFY_DEVCONTEXT || pEntry->Flink == pEntry) {
                /*
                 * In this case, we cannot go ahead because dev->Linkage.Flink may not
                 * be valid. pEntry may not be valid also. Simply stop here.
                 */
                NBT_DEREFERENCE_DEVICE(dev, REF_DEV_DGRAM, TRUE);
                break;
            }
            NBT_DEREFERENCE_DEVICE(dev, REF_DEV_DGRAM, TRUE);
        }
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
VOID
ProxyTimerComplFn (
  IN PVOID            pContext,
  IN PVOID            pContext2,
  IN tTIMERQENTRY    *pTimerQEntry
 )

/*++

Routine Description:

       This function either deletes the name from the remote name table
        if fReg is FALSE (i.e. the timer has expired on a name query
        sent by the Proxy on behalf of a node doing a name query) or changes
        the state to RESOLVED if fReg is  TRUE (i.e. the timer has expired
        on a name query sent on  behalf of a node doing name registration)

Arguments:
       pfReg  - indicates whether the timer expiry is for a name
                query

Return Value:

    NTSTATUS - success or not - failure means no response to the net

--*/
{

    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle           OldIrq;
    tNAMEADDR               *pNameAddr;
    tNAMEADDR               *pNameAddrNew;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    if (!pTimerQEntry)
    {
        // return the tracker block to its queue
        pTracker->pNameAddr->pTimer = NULL;
        InterlockedDecrement(&NbtConfig.lNumPendingNameQueries);
        NBT_DEREFERENCE_NAMEADDR (pTracker->pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
        NBT_DEREFERENCE_TRACKER (pTracker, TRUE);
        return;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if ((--pTimerQEntry->Retries) == 0)     // The Retires have expired
    {
        if (!(pTracker->Flags & NBT_NAME_SERVER))
        {
            //
            // If pContext2 is not 0, it means that this timer function was
            // called by the proxy for a query which it sent on hearing a
            // registration on the net.  If pContext2 is  0, it means
            // that the timer function was called by the proxy  for a query
            // which it sent on hearing a query on the net.
            //
            pTimerQEntry->ClientCompletion = NULL;

            //
            // Mark the entry as released.  Do not dereference the name
            // The entry will remain in the remote hash table.  When the proxy
            // code sees a query or registration for a released entry in the
            // cache it does not query the name server. This cuts down on
            // name server traffic.  The released entries are removed from
            // the cache at cache timer expiry (kept small).

            //************************************

            // Changed:  Dereference the name because the name query timed
            // out meaning that we did not contact WINS, therefore we
            // do not know if the name is valid or not!
            //

            pNameAddr = pTracker->pNameAddr;
            CHECK_PTR(pNameAddr);
            pNameAddr->pTimer = NULL;           // remove the link from the name table to this timer block

//            NBT_PROXY_DBG(("ProxyTimerComplFn: State of name %16.16s(%X) changed to (%s)\n", pTracker->pNameAddr->Name, pTracker->pNameAddr->Name[15], "RELEASED"));


            // Remove from the pending Queries list - and put into the hash
            // table for 1 minute so we do not beat up on WINS if it is down
            // or slow right now.
            //
            RemoveEntryList (&pNameAddr->Linkage);
            InitializeListHead (&pNameAddr->Linkage);

            status = AddToHashTable (NbtConfig.pRemoteHashTbl,
                                     pNameAddr->Name,
                                     NbtConfig.pScope,
                                     pNameAddr->IpAddress,
                                     NBT_UNIQUE,
                                     NULL,
                                     &pNameAddrNew,
                                     pTracker->pDeviceContext,
                                     NAME_RESOLVED_BY_WINS | NAME_RESOLVED_BY_BCAST);
            if (NT_SUCCESS(status))
            {
                pNameAddrNew->NameTypeState &= ~NAME_STATE_MASK;
                pNameAddrNew->NameTypeState |= STATE_RELEASED;

                pNameAddrNew->TimeOutCount = 60000 / REMOTE_HASH_TIMEOUT;
            }

            InterlockedDecrement(&NbtConfig.lNumPendingNameQueries);
            NBT_DEREFERENCE_NAMEADDR (pNameAddr, REF_NAME_QUERY_ON_NET, TRUE);
            NBT_DEREFERENCE_TRACKER (pTracker, TRUE);   // return the tracker block to its queue

            CTESpinFree(&NbtConfig.JointLock,OldIrq);

            return;
        }

        //
        // Can't reach the name server, so try the backup
        //
        pTracker->Flags &= ~NBT_NAME_SERVER;
        pTracker->Flags |= NBT_NAME_SERVER_BACKUP;

        // set the retry count again
        pTimerQEntry->Retries = NbtConfig.uNumRetries;
    }

    NBT_REFERENCE_TRACKER (pTracker);
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    status = UdpSendNSBcast(pTracker->pNameAddr,
                            NbtConfig.pScope,
                            pTracker,
                            NULL,NULL,NULL,
                            0,0,
                            eNAME_QUERY,
                            TRUE);

    NBT_DEREFERENCE_TRACKER(pTracker, FALSE);
    pTimerQEntry->Flags |= TIMER_RESTART;

    return;
}

//----------------------------------------------------------------------------
VOID
ProxyClientCompletion(
  IN PVOID            pContext,
  IN NTSTATUS         status
 )

/*++

Routine Description:

       This function does nothing since the proxy does not need to do anything
       when a name query succeeds.  The code in inbound.c does all that
       is necessary - namely put the name in the name table.

Arguments:

Return Value:


--*/
{

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\autodial.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    autodial.c

Abstract:

    This file provides routines for interacting
    with the automatic connection driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)  9-6-95

Revision History:

--*/
#include "precomp.h"   // procedure headings

#ifdef RASAUTODIAL

#ifndef VXD
#include <acd.h>
#include <acdapi.h>
#endif

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(INIT, NbtAcdBind)
#pragma CTEMakePageable(PAGE, NbtAcdUnbind)
#endif
//*******************  Pageable Routine Declarations ****************


//
// Automatic connection global variables.
//
BOOLEAN fAcdLoadedG;
ACD_DRIVER AcdDriverG;
ULONG ulDriverIdG = 'Nbt ';

//
// Imported routines.
//
VOID
CleanUpPartialConnection(
    IN NTSTATUS             status,
    IN tCONNECTELE          *pConnEle,
    IN tDGRAM_SEND_TRACKING *pTracker,
    IN PIRP                 pClientIrp,
    IN CTELockHandle        irqlJointLock,
    IN CTELockHandle        irqlConnEle
    );

NTSTATUS
NbtConnectCommon(
    IN  TDI_REQUEST                 *pRequest,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp
    );

NTSTATUS
NbtpConnectCompletionRoutine(
    PDEVICE_OBJECT  pDeviceObject,
    PIRP            pIrp,
    PVOID           pCompletionContext
    );


VOID
NbtRetryPreConnect(
    IN BOOLEAN fSuccess,
    IN PVOID *pArgs
    )

/*++

Routine Description:

    This routine is called indirectly by the automatic
    connection driver to continue the connection process
    after an automatic connection has been made.

Arguments:

    fSuccess - TRUE if the connection attempt was successful.

    pArgs - a pointer to the argument vector

Return Value:

    None.

--*/

{
    NTSTATUS                    status;
    tCONNECTELE                 *pConnEle = pArgs[0];
    PVOID                       pTimeout = pArgs[1];
    PTDI_CONNECTION_INFORMATION pCallInfo = pArgs[2];
    PIRP                        pIrp = pArgs[3];
    TDI_REQUEST                 request;
    KIRQL                       irql;
    CTELockHandle               OldIrq;
    tDEVICECONTEXT              *pDeviceContext = pConnEle->pDeviceContext;

    IF_DBG(NBT_DEBUG_NAME)
        KdPrint(("Nbt.NbtRetryPreConnect: fSuccess=%d, pIrp=0x%x, pIrp->Cancel=%d, pConnEle=0x%x\n",
            fSuccess, pIrp, pIrp->Cancel, pConnEle));

    request.Handle.ConnectionContext = pConnEle;
    status = NbtCancelCancelRoutine (pIrp);
    if (status != STATUS_CANCELLED)
    {
        //
        // We're done with the connection progress,
        // so clear the fAutoConnecting flag.  We
        // set the fAutoConnected flag to prevent us
        // from re-attempting another automatic
        // connection on this connection.
        //
        CTESpinLock(pConnEle,OldIrq);
        pConnEle->fAutoConnecting = FALSE;
        pConnEle->fAutoConnected = TRUE;
        CTESpinFree(pConnEle,OldIrq);

        status = fSuccess ? NbtConnectCommon (&request, pTimeout, pCallInfo, pIrp) :
                            STATUS_BAD_NETWORK_PATH;
        //
        // We are responsible for completing
        // the irp.
        //
        if (status != STATUS_PENDING)
        {
            //
            // Clear out the Irp pointer in the Connection object so that we dont try to
            // complete it again when we clean up the connection. Do this under the connection
            // lock.
            //
            CTESpinLock(pConnEle,OldIrq);
            pConnEle->pIrp = NULL;
            CTESpinFree(pConnEle,OldIrq);

            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        }

        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_AUTODIAL, FALSE);
    }
} // NbtRetryPreConnect



BOOLEAN
NbtCancelAutoDialRequest(
    IN PVOID pArg,
    IN ULONG ulFlags,
    IN ACD_CONNECT_CALLBACK pProc,
    IN USHORT nArgs,
    IN PVOID *pArgs
    )
{
    if (nArgs != 5)
        return FALSE;

    return (pArgs[4] == pArg);
} // NbtCancelAutoDialRequest



BOOLEAN
NbtCancelPreConnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  pIrpSp;
    tCONNECTELE         *pConnEle;
    KIRQL               irql;
    ACD_ADDR            *pAddr;
    BOOLEAN             fCancelled;
    CTELockHandle       OldIrq;

    UNREFERENCED_PARAMETER(pDeviceObject);

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pConnEle = (tCONNECTELE *) pIrpSp->FileObject->FsContext;
    if ((!pConnEle) ||
        (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) ||
        (!(pAddr = (ACD_ADDR *) NbtAllocMem(sizeof(ACD_ADDR),NBT_TAG('A')))))
    {
        IoReleaseCancelSpinLock(pIrp->CancelIrql);
        ASSERTMSG ("Nbt.NbtCancelPreConnect: ERROR - Invalid Connection Handle\n", 0);
        return FALSE;
    }

    IF_DBG(NBT_DEBUG_NAME)
        KdPrint(("NbtCancelPreConnect: pIrp=0x%x, pConnEle=0x%x\n", pIrp, pConnEle));
    //
    // Get the address of the connection.
    //
    pAddr->fType = ACD_ADDR_NB;
    RtlCopyMemory(&pAddr->cNetbios, pConnEle->RemoteName, 16);
    //
    // Cancel the autodial request.
    //
    fCancelled = (*AcdDriverG.lpfnCancelConnection) (ulDriverIdG, pAddr, NbtCancelAutoDialRequest, pIrp);
    if (fCancelled)
    {
        IoSetCancelRoutine(pIrp, NULL);
    }
    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    CTEMemFree(pAddr);

    //
    // If the request could not be found
    // in the driver, then it has already
    // been completed, so we simply return.
    //
    if (!fCancelled)
    {
        return FALSE;
    }

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    NBT_DEREFERENCE_DEVICE (pConnEle->pDeviceContext, REF_DEV_AUTODIAL, FALSE);

    //
    // Clear out the Irp pointer in the Connection object so that we dont try to
    // complete it again when we clean up the connection. Do this under the connection
    // lock.
    //
    // This should not be needed since before we call NbtConnectCommon, the Cancel routine
    // is NULLed out, so it cannot happen that the pIrp ptr in the connection is set to the
    // Irp, and this cancel routine is called.
    //

    CTESpinLock(pConnEle,OldIrq);
    pConnEle->pIrp = NULL;
    CTESpinFree(pConnEle,OldIrq);

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    KeLowerIrql(irql);

    return TRUE;
} // NbtCancelPreConnect


BOOLEAN
NbtCancelPostConnect(
    IN PIRP pIrp
    )
{
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    tCONNECTELE         *pConnEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;
    ACD_ADDR            *pAddr;
    BOOLEAN             fCancelled;

    if ((!pConnEle) ||
        (!NBT_VERIFY_HANDLE2 (pConnEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN)) ||
        (!(pAddr = (ACD_ADDR *) NbtAllocMem(sizeof(ACD_ADDR),NBT_TAG('A')))))
    {
        ASSERTMSG ("Nbt.NbtCancelPostConnect: ERROR - Invalid Connection Handle\n", 0);
        return FALSE;
    }

    IF_DBG(NBT_DEBUG_NAME)
        KdPrint(("Nbt.NbtCancelPostConnect: pIrp=0x%x, pConnEle=0x%x\n", pIrp, pConnEle));
    //
    // Get the address of the connection.
    //
    pAddr->fType = ACD_ADDR_NB;
    RtlCopyMemory(&pAddr->cNetbios, pConnEle->RemoteName, 15);

    //
    // Cancel the autodial request.
    //
    fCancelled = (*AcdDriverG.lpfnCancelConnection) (ulDriverIdG, pAddr, NbtCancelAutoDialRequest, pIrp);
    if (fCancelled)
    {
        NBT_DEREFERENCE_DEVICE (pConnEle->pDeviceContext, REF_DEV_AUTODIAL, FALSE);
    }

    CTEMemFree(pAddr);
    return (fCancelled);
} // NbtCancelPostConnect



BOOLEAN
NbtAttemptAutoDial(
    IN  tCONNECTELE                 *pConnEle,
    IN  PVOID                       pTimeout,
    IN  PTDI_CONNECTION_INFORMATION pCallInfo,
    IN  PIRP                        pIrp,
    IN  ULONG                       ulFlags,
    IN  ACD_CONNECT_CALLBACK        pProc
    )

/*++

Routine Description:

    Call the automatic connection driver to attempt an
    automatic connection.  The first five parameters are
    used in the call to NbtConnect after the connection
    completes successfully.

Arguments:

    ...

    ulFlags - automatic connection flags

    pProc - callback procedure when the automatic connection completes

Return Value:

    TRUE if the automatic connection was started successfully,
    FALSE otherwise.

--*/

{
    NTSTATUS    status;
    BOOLEAN     fSuccess;
    ACD_ADDR    *pAddr = NULL;
    KIRQL       irql;
    PVOID       pArgs[4];
    PCHAR       pName;
    ULONG       ulcbName;
    LONG        lNameType;
    TDI_ADDRESS_NETBT_INTERNAL  TdiAddr;
    PIO_STACK_LOCATION pIrpSp;

    ASSERT(pCallInfo);

    //
    // If this connection has already been through the
    // automatic connection process, don't do it again.
    //
    if ((pConnEle->fAutoConnected)) {
        return FALSE;
    }

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    if (pIrpSp->CompletionRoutine != NbtpConnectCompletionRoutine) {
        status = GetNetBiosNameFromTransportAddress((PTRANSPORT_ADDRESS) pCallInfo->RemoteAddress,
                                                          pCallInfo->RemoteAddressLength, &TdiAddr);
    } else {
        ASSERT(((PTRANSPORT_ADDRESS)pCallInfo->RemoteAddress)->Address[0].AddressType == TDI_ADDRESS_TYPE_UNSPEC);
        CTEMemCopy(&TdiAddr,
                (PTDI_ADDRESS_NETBT_INTERNAL)((PTRANSPORT_ADDRESS)pCallInfo->RemoteAddress)->Address[0].Address,
                sizeof(TdiAddr));
        status = STATUS_SUCCESS;
    }
    if (status != STATUS_SUCCESS || (!NBT_REFERENCE_DEVICE (pConnEle->pDeviceContext, REF_DEV_AUTODIAL, FALSE)) ||
        (!(pAddr = (ACD_ADDR *) NbtAllocMem(sizeof(ACD_ADDR),NBT_TAG('A'))))) {
        if (pAddr) {
            CTEMemFree(pAddr);
        }

        return FALSE;
    }

    pName = TdiAddr.OEMRemoteName.Buffer;
    ulcbName = TdiAddr.OEMRemoteName.Length;
    lNameType = TdiAddr.NameType;

    //
    // Save the address for pre-connect attempts,
    // because if we have to cancel this irp,
    // it is not saved anywhere else.
    //
    CTESpinLock(pConnEle, irql);
    pConnEle->fAutoConnecting = TRUE;
    CTEMemCopy(pConnEle->RemoteName, pName, NETBIOS_NAME_SIZE);
    CTESpinFree(pConnEle, irql);
    pAddr->fType = ACD_ADDR_NB;
    RtlCopyMemory(&pAddr->cNetbios, pName, NETBIOS_NAME_SIZE);

    IF_DBG(NBT_DEBUG_NAME)
        KdPrint(("Nbt.NbtAttemptAutodial: szAddr=%-15.15s\n", pName));
    //
    // Enqueue this request on the network
    // connection pending queue.
    //
    pArgs[0] = pConnEle;
    pArgs[1] = pTimeout;
    pArgs[2] = pCallInfo;
    pArgs[3] = pIrp;
    fSuccess = (*AcdDriverG.lpfnStartConnection) (ulDriverIdG, pAddr, ulFlags, pProc, 4, pArgs);

    //
    // If fSuccess is TRUE, then it means that the NetBT proc has
    // already been called to setup the connection, and hence the
    // data in pConnEle may not be valid now
    //
    // In the case it is FALSE, then pProc has not been called, and
    // we should set the fAutoConnecting flag to FALSE also
    //
    if (!fSuccess)
    {
        NBT_DEREFERENCE_DEVICE (pConnEle->pDeviceContext, REF_DEV_AUTODIAL, FALSE);
        CTESpinLock(pConnEle, irql);
        pConnEle->fAutoConnecting = FALSE;
        CTESpinFree(pConnEle, irql);
    }

    CTEMemFree(pAddr);
    return fSuccess;
} // NbtAttemptAutoDial



VOID
NbtNoteNewConnection(
    IN tNAMEADDR    *pNameAddr,
    IN  ULONG       IpAddress
    )

/*++

Routine Description:

    Inform the automatic connection driver of a
    successful new connection.

Arguments:

    pNameAddr - a pointer to the remote name
    IpAddress - Source IP address of the connection

Return Value:
    None.

--*/

{
    ACD_ADDR        *pAddr = NULL;
    ACD_ADAPTER     *pAdapter = NULL;

    //
    // Notify the AcdDriver only if we have a valid Source address
    //
    // We can end up blowing the stack if we pre-allocate ACD_ADDR
    // and ACD_ADAPTER on the stack -- so allocate them dynamically!
    //
    if ((IpAddress) &&
        (pAddr = (ACD_ADDR *) NbtAllocMem(sizeof(ACD_ADDR),NBT_TAG('A'))) &&
        (pAdapter = (ACD_ADAPTER *) NbtAllocMem(sizeof(ACD_ADAPTER),NBT_TAG('A'))))
    {
        pAddr->fType = ACD_ADDR_NB;
        RtlCopyMemory(&pAddr->cNetbios, pNameAddr->Name, 15);

        pAdapter->fType = ACD_ADAPTER_IP;
        pAdapter->ulIpaddr = htonl(IpAddress);  // Get the source IP address of the connection.

        (*AcdDriverG.lpfnNewConnection) (pAddr, pAdapter);
    }

    if (pAddr)
    {
        CTEMemFree(pAddr);
    }

    if (pAdapter)
    {
        CTEMemFree(pAdapter);
    }
} // NbtNoteNewConnection



VOID
NbtAcdBind()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP pIrp;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    PACD_DRIVER pDriver = &AcdDriverG;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer(
               &nameString,
               SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
               &pAcdFileObject,
               &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
        return;
    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);
    //
    // Initialize our part of the ACD_DRIVER
    // structure.
    //
    KeInitializeSpinLock(&AcdDriverG.SpinLock);
    AcdDriverG.ulDriverId = ulDriverIdG;
    AcdDriverG.fEnabled = FALSE;
    //
    // Build a request to get the automatic
    // connection driver entry points.
    //
    pIrp = IoBuildDeviceIoControlRequest (IOCTL_INTERNAL_ACD_BIND,
                                          pAcdDeviceObject,
                                          (PVOID)&pDriver,
                                          sizeof (pDriver),
                                          NULL,
                                          0,
                                          TRUE,
                                          NULL,
                                          &ioStatusBlock);
    if (pIrp == NULL)
    {
        ObDereferenceObject(pAcdDeviceObject);
        return;
    }
    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);
    fAcdLoadedG = (status == STATUS_SUCCESS);
    //
    // Close the device.
    //
    ObDereferenceObject(pAcdDeviceObject);
} // NbtAcdBind



VOID
NbtAcdUnbind()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP pIrp;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    PACD_DRIVER pDriver = &AcdDriverG;

    //
    // Don't bother to unbind if we
    // didn't successfully bind in the
    // first place.
    //
    if (!fAcdLoadedG)
    {
        return;
    }

    fAcdLoadedG = FALSE;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer (&nameString,
                                       SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
                                       &pAcdFileObject,
                                       &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
    {
        return;
    }

    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);
    //
    // Build a request to unbind from
    // the automatic connection driver.
    //
    pIrp = IoBuildDeviceIoControlRequest (IOCTL_INTERNAL_ACD_UNBIND,
                                          pAcdDeviceObject,
                                          (PVOID)&pDriver,
                                          sizeof (pDriver),
                                          NULL,
                                          0,
                                          TRUE,
                                          NULL,
                                          &ioStatusBlock);
    if (pIrp == NULL)
    {
        ObDereferenceObject(pAcdDeviceObject);
        return;
    }

    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);
    //
    // Close the device.
    //
    ObDereferenceObject(pAcdDeviceObject);
} // NbtAcdUnbind

#endif // RASAUTODIAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\udpsend.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Udpsend.c

Abstract:


    This file handles building udp(and Tcp) requests, formated to the Tdi specification
    to pass to Tdiout.  Tdiout formats the request in an Os specific manner and
    passes it on to the transport.

    This file handles name service type functions such as query name or
    register name, datagram sends.  It also handles building Tcp packets.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/


#include "precomp.h"   // procedure headings
#include <ipinfo.h>

#include "udpsend.tmh"

VOID
SessionRespDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo);
VOID
NDgramSendCompleted(
    PVOID               pContext,
    NTSTATUS            status,
    ULONG               lInfo
    );

//----------------------------------------------------------------------------
NTSTATUS
UdpSendNSBcast(
    IN tNAMEADDR             *pNameAddr,
    IN PCHAR                 pScope,
    IN tDGRAM_SEND_TRACKING  *pTrackerRequest,
    IN PVOID                 pTimeoutRoutine,
    IN PVOID                 pClientContext,
    IN PVOID                 pClientCompletion,
    IN ULONG                 Retries,
    IN ULONG                 Timeout,
    IN enum eNSTYPE          eNsType,
	IN BOOL					 SendFlag
    )
/*++

Routine Description:

    This routine sends a name registration or a name query
    as a broadcast on the subnet or directed to the name server.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    tNAMEHDR                    *pNameHdr;
    ULONG                       uLength;
    CTELockHandle               OldIrq;
    ULONG   UNALIGNED           *pHdrIpAddress;
    ULONG                       IpAddress;
    USHORT                      Port;
    USHORT                      NameType;
    tDGRAM_SEND_TRACKING        *pTrackerDgram;
    tTIMERQENTRY                *pTimerQEntry;
    PFILE_OBJECT                pFileObject;
    tDEVICECONTEXT              *pDeviceContext = pTrackerRequest->pDeviceContext;
    COMPLETIONCLIENT            pOldCompletion;
    PVOID                       pOldContext;


    if (pNameAddr->NameTypeState & (NAMETYPE_GROUP | NAMETYPE_INET_GROUP))
    {
        NameType = NBT_GROUP;
    }
    else
    {
        NameType = NBT_UNIQUE;
    }

    // build the correct type of pdu depending on the request type

    status = GetTracker (&pTrackerDgram, NBT_TRACKER_SEND_NSBCAST);
    if (!NT_SUCCESS(status))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pHdrIpAddress = (ULONG UNALIGNED *)CreatePdu(pNameAddr->Name,
                                                 pScope,
                                                 0L,     // we don't know the IP address yet
                                                 NameType,
                                                 eNsType,
                                                 (PVOID)&pNameHdr,
                                                 &uLength,
                                                 pTrackerRequest);

    if (!pHdrIpAddress)
    {
        IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt:Failed to Create Pdu to send to WINS PduType= %X\n", eNsType));

        FreeTracker (pTrackerDgram, RELINK_TRACKER);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // change the dgram header for name refreshes
    //
    if (eNsType == eNAME_REFRESH)
    {
        pNameHdr->OpCodeFlags = NbtConfig.OpRefresh;
    }
    else
    if (   (eNsType == eNAME_QUERY)
#ifdef VXD
        || (eNsType == eDNS_NAME_QUERY)
#endif
       )
    {
        pHdrIpAddress = NULL;
    }

    CTESpinLock(&NbtConfig.JointLock,OldIrq);


    // fill in the Datagram hdr info in the tracker structure.
    // There is never a client buffer to send.
    //
    // Set the fields here instead of after the timer is started
    // since they may be accessed by the Timer completion function
    //
    pTrackerRequest->pNameAddr          = pNameAddr;
    pTrackerRequest->TransactionId      = pNameHdr->TransactId; // save for response checks.
    pTrackerDgram->SendBuffer.pDgramHdr = NULL;                 // to catch erroneous free's

    pTrackerDgram->SendBuffer.pDgramHdr = pNameHdr;
    pTrackerDgram->SendBuffer.HdrLength = uLength;
    pTrackerDgram->SendBuffer.pBuffer   = NULL;
    pTrackerDgram->SendBuffer.Length    = 0;
    pTrackerDgram->pNameAddr            = pNameAddr;
    pTrackerDgram->pDeviceContext       = pDeviceContext;

    // start the timer now...We didn't start it before because it could
    // have expired during the dgram setup, perhaps before the Tracker was
    // fully setup.
    //
    if (Timeout)
    {
        //
        // Before we over-write the current pTimer field in pNameAddr below,
        // we need to check if there is any timer running, and if so, we will
        // have to stop it right now
        //
        while (pTimerQEntry = pNameAddr->pTimer)
        {
            pNameAddr->pTimer = NULL;
            status = StopTimer(pTimerQEntry, &pOldCompletion, &pOldContext);
            if (pOldCompletion)
            {
                CTESpinFree(&NbtConfig.JointLock, OldIrq);
                (*pOldCompletion) (pOldContext, STATUS_TIMEOUT);
                CTESpinLock(&NbtConfig.JointLock, OldIrq);
            }
        }

        status = StartTimer(pTimeoutRoutine,
                            Timeout,
                            (PVOID)pTrackerRequest,       // context value
                            NULL,
                            pClientContext,
                            pClientCompletion,
                            pDeviceContext,
                            &pTimerQEntry,
                            (USHORT)Retries,
                            TRUE);

        if (!NT_SUCCESS(status))
        {
            // we need to differentiate the timer failing versus lack
            // of resources
            CTESpinFree(&NbtConfig.JointLock,OldIrq);
            CTEMemFree(pNameHdr);

            FreeTracker(pTrackerDgram,RELINK_TRACKER);

            return(STATUS_INVALID_PARAMETER_6);
        }
        //
        // Cross link the nameaddr and the timer so we can stop the timer
        // when the name query response occurs
        //
        pTimerQEntry->pCacheEntry = pNameAddr;
        pNameAddr->pTimer = pTimerQEntry;
    }

    //
    // Check the Flag value in the tracker and see if we should do a broadcast
    // or a directed send to the name server
    //
    if (pTrackerRequest->Flags & NBT_BROADCAST)
    {
        //
        // set the broadcast bit in the header to be ON since this may be
        // an M or MS node that is changing to broadcast from directed sends.
        //
        ((PUCHAR)pTrackerDgram->SendBuffer.pDgramHdr)[3] |= FL_BROADCAST_BYTE;

        Port = NBT_NAMESERVICE_UDP_PORT;

        IpAddress = pDeviceContext->BroadcastAddress;
    }
    else
    {
        //
        // turn off the broadcast bit in the header since this may be
        // an M or MS node that is changing to directed sends from broadcasts.
        //
        ((PUCHAR)pTrackerDgram->SendBuffer.pDgramHdr)[3] &= ~FL_BROADCAST_BYTE;

        // check for a zero first byte in the name passed to the name server
        ASSERT(((PUCHAR)pTrackerDgram->SendBuffer.pDgramHdr)[12]);

        //
        // for Multihomed hosts, UNIQUE name registrations use a special new
        // code (0x0F) to tell the name server this is a multihomed name that
        // will have several ip addresses
        //
        if (NbtConfig.MultiHomed && ((eNsType == eNAME_REGISTRATION) && (NameType == NBT_UNIQUE)))
        {
            //
            // if it is a multihomed host, then use a new special registration opcode (0xF)
            //
            ((PUCHAR)pTrackerDgram->SendBuffer.pDgramHdr)[2] |= OP_REGISTER_MULTI;
        }

        Port = NbtConfig.NameServerPort;

           // name srvr, backup name srvr, dns srvr, backup dnr srvr:which one?

        if (pTrackerRequest->Flags & NBT_NAME_SERVER)
        {
            IpAddress = pDeviceContext->lNameServerAddress;
        }
#ifdef MULTIPLE_WINS
        //
        // IMPORTANT: Check for NAME_SERVER_OTHERS flag has to be before check
        // for NAME_SERVER_BACKUP flag, since both flags will be set when we
        // we are querying "other" servers
        //
        else if (pTrackerRequest->Flags & NBT_NAME_SERVER_OTHERS)  // Try "other" servers
        {
            if (0 == pTrackerRequest->NSOthersLeft)        // Do LOOP_BACK
            {
                IpAddress = LOOP_BACK;
            }
            else
            {
                IpAddress = pTrackerRequest->pDeviceContext->lOtherServers[pTrackerRequest->NSOthersIndex];
            }
        }
#endif
        else
#ifndef VXD
        {
            IpAddress = pDeviceContext->lBackupServer;
        }
#else
        if (pTrackerRequest->Flags & NBT_NAME_SERVER_BACKUP)
        {
            IpAddress = pDeviceContext->lBackupServer;
        }
        else
        if (pTrackerRequest->Flags & NBT_DNS_SERVER)
        {
            IpAddress = pDeviceContext->lDnsServerAddress;
            Port = NbtConfig.DnsServerPort;
        }
        else  // ----- if (pTrackerRequest->Flags & NBT_DNS_SERVER_BACKUP) ----
        {
            IpAddress = pDeviceContext->lDnsBackupServer;
            Port = NbtConfig.DnsServerPort;
        }
#endif


        //
        // is it is a send to WINS on this machine
        //
        if (pNameHdr->AnCount == (UCHAR)WINS_SIGNATURE)
        {
            //
            // on RAS links, we don't want to register with the local wins
            // but with the wins that RAS told us about.
            // (of course, if RAS didn't give us a wins address, at least
            // register with the local guy!)
            //
            if ((pDeviceContext->IpInterfaceFlags & IP_INTFC_FLAG_P2P) &&  // Check for PointToPoint
                (pDeviceContext->lNameServerAddress != LOOP_BACK))
            {
                // Don't do anything;
            }
            else
            {
                IpAddress = pDeviceContext->IpAddress;
            }
        }
    }

    ASSERT(pTrackerRequest->Flags);

    // each adapter has a different source Ip address for registrations
    // pHdrIpAddress will be NULL for NameQueries
    if (pHdrIpAddress)
    {
        // If the Source IP address is to be different from the device we are
        // sending the Datagram on, fill it in!
        if (pTrackerRequest->Flags & NBT_USE_UNIQUE_ADDR)
        {
            *pHdrIpAddress = htonl(pTrackerRequest->RemoteIpAddress);
        }
        else
        {
            *pHdrIpAddress = htonl(pDeviceContext->IpAddress);
        }
    }

    //
    // in the event that DHCP has just removed the IP address, use a null
    // FileObject to signal UdpSendDatagram not to do the send
    // Also, if the device has been destroyed, dont send anything.
    //
    CTESpinFree(&NbtConfig.JointLock,OldIrq);
    status = UdpSendDatagram(pTrackerDgram,
                             IpAddress,
                             NDgramSendCompleted,
                             pTrackerDgram,
                             Port,
                             (SendFlag ? NBT_NAME_SERVICE : 0));

    if (!NT_SUCCESS(status))
    {
        //
        // Since pTrackerDgram is associated only with the Datagram send,
        // it should be free'ed here only!
        //
        FreeTracker (pTrackerDgram, FREE_HDR | RELINK_TRACKER);
    }

    return(status);
}
//----------------------------------------------------------------------------
PVOID
CreatePdu(
    IN  PCHAR                   pName,
    IN  PCHAR                   pScope,
    IN  ULONG                   IpAddress,
    IN  USHORT                  NameType,
    IN  enum eNSTYPE            eNsType,
    OUT PVOID                   *pHdrs,
    OUT PULONG                  pLength,
    IN  tDGRAM_SEND_TRACKING    *pTrackerRequest
    )
/*++

Routine Description:

    This routine builds a registration pdu

Arguments:


Return Value:

    PULONG  - a ptr to the ip address in the pdu so it can be filled in later

--*/
{
    tNAMEHDR        *pNameHdr;
    ULONG           uLength;
    ULONG           uScopeSize;
    tGENERALRR      *pGeneral;
    CTELockHandle   OldIrq;


#ifdef VXD
    if ( (eNsType == eDNS_NAME_QUERY) || (eNsType == eDIRECT_DNS_NAME_QUERY) )
    {
        uScopeSize = domnamelen(pTrackerRequest->pchDomainName) + 1;   // +1 for len byte
        if (uScopeSize > 1)
        {
            uScopeSize++;        // for the null byte
        }
    }
    else
#endif
    uScopeSize = strlen(pScope) +1; // +1 for null too


    // size is size of the namehdr structure -1 for the NetbiosName[1]
    // + the 32 bytes for the half ascii name +
    // scope + size of the General RR structure
    uLength = sizeof(tNAMEHDR) - 1
                            + (NETBIOS_NAME_SIZE << 1)
                            + uScopeSize;

    if (eNsType == eNAME_QUERY)
    {
        uLength = uLength + sizeof(ULONG);
    }
#ifdef VXD
    // there is no half-ascii conversion in DNS.  we added 32 bytes above, but
    // we need only 16.  so, subtract 16.
    else if (eNsType == eDNS_NAME_QUERY)
    {
        uLength = uLength - NETBIOS_NAME_SIZE + sizeof(ULONG);
    }
	// This is a "raw" DNS name query.  Substitute raw string length of pName
	// for NETBIOS_NAME_SIZE.
    else if (eNsType == eDIRECT_DNS_NAME_QUERY)
    {
        uLength = uLength - (NETBIOS_NAME_SIZE << 1) + sizeof(ULONG) + strlen(pName) + 1;
    }
#endif
	else
	{
	    uLength += sizeof(tGENERALRR);
	}

    // Note that this memory must be deallocated when the send completes in
    // tdiout.DgramSendCompletion
    pNameHdr = NbtAllocMem((USHORT)uLength ,NBT_TAG('X'));

    if (!pNameHdr)
    {
        return(NULL);
    }

    CTEZeroMemory((PVOID)pNameHdr,uLength);

    //
    // for resends of the same name query or name registration, do not increment
    // the transaction id
    //
    if (pTrackerRequest->TransactionId)
    {
        pNameHdr->TransactId = pTrackerRequest->TransactionId;
    }
    else
    {
        pNameHdr->TransactId = htons(GetTransactId());
    }

    pNameHdr->QdCount = 1;
    pNameHdr->AnCount = 0;
    pNameHdr->NsCount = 0;


#ifdef VXD
    if ((eNsType != eDNS_NAME_QUERY)&&(eNsType != eDIRECT_DNS_NAME_QUERY))
    {
#endif
        // Convert the name to half ascii and copy!! ... adding the scope too
        pGeneral = (tGENERALRR *)ConvertToHalfAscii(
                        (PCHAR)&pNameHdr->NameRR.NameLength,
                        pName,
                        pScope,
                        uScopeSize);

        pGeneral->Question.QuestionTypeClass = htonl(QUEST_NBINTERNET);
#ifdef VXD
    }
#endif

    *pHdrs = (PVOID)pNameHdr;
    *pLength = uLength;

    switch (eNsType)

    {

#ifdef VXD
    case eDNS_NAME_QUERY:
    case eDIRECT_DNS_NAME_QUERY:

        // copy the netbios name ... adding the scope too
        pGeneral = (tGENERALRR *)DnsStoreName(
                        (PCHAR)&pNameHdr->NameRR.NameLength,
                        pName,
                        pTrackerRequest->pchDomainName,
                        eNsType);

        pGeneral->Question.QuestionTypeClass = htonl(QUEST_DNSINTERNET);

        pNameHdr->OpCodeFlags = (FL_RECURDESIRE);

        pNameHdr->ArCount = 0;

        // we just need to return something non-null to succeed.
        return((PULONG)pNameHdr);
#endif

    case eNAME_QUERY:

        if (NodeType & BNODE)
        {
            pNameHdr->OpCodeFlags = (FL_BROADCAST | FL_RECURDESIRE);
        }
        else
            pNameHdr->OpCodeFlags = (FL_RECURDESIRE);

        pNameHdr->ArCount = 0;

        // we just need to return something non-null to succeed.
        return((PULONG)pNameHdr);
        break;

    case eNAME_REGISTRATION_OVERWRITE:
    case eNAME_REFRESH:
    case eNAME_REGISTRATION:
        //
        // The broadcast bit is set in UdpSendNSBcast so we don't
        // need to set it here. - just set the op code, since the broadcast
        // bit is a function of whether we are talking to the nameserver or doing
        // a broadcast.  This code handles the multi-homed case with a new
        // opcode for registration, and that opcode is set in the routine that
        //
        // The final name registration in Broadcast is called an Overwrite request
        // and it does not have the FL_RECURSION Desired bit set.
        //
        if (eNsType == eNAME_REGISTRATION_OVERWRITE)
        {
            pNameHdr->OpCodeFlags = (OP_REGISTRATION);
        }
        else
        {
            pNameHdr->OpCodeFlags = (FL_RECURDESIRE | OP_REGISTRATION);
        }

        pGeneral->Ttl = htonl(DEFAULT_TTL);

        // *** NOTE: There is no BREAK here by DESIGN!!

    case eNAME_RELEASE:

        // this code sets the Broadcast bit based on the node type rather than the
        // type of send....UdpSendNSBcast, resets the code according to the type of
        // name, so this code may not need to set the Broadcast bit
        //
        if (eNsType == eNAME_RELEASE)
        {
            pNameHdr->OpCodeFlags = OP_RELEASE;
            //
            // TTL for release is zero
            //
            pGeneral->Ttl = 0;
        }

        pNameHdr->ArCount = 1;  // 1 additional resource record included
        //
        // If WINS is on the same machine adjust the PDU to be able to tell
        // WINS that this pdu came from the local machine
        //
#ifndef VXD
        if (pWinsInfo && (pTrackerRequest->Flags & NBT_NAME_SERVER))
        {
            pNameHdr->AnCount = (UCHAR)WINS_SIGNATURE;
        }
#endif

        pGeneral->RrName.uSizeLabel = PTR_TO_NAME;  // set top two bits to signify ptr

        // the offset ptr to the name added above
        pGeneral->RrName.pLabel[0] = sizeof(tNAMEHDR) - sizeof(tNETBIOS_NAME);
        pGeneral->RrTypeClass = htonl(QUEST_NBINTERNET);


        pGeneral->Length = htons(6);
        pGeneral->Flags = htons((USHORT)((NameType << 15) | NbtConfig.PduNodeType));
        pGeneral->IpAddress = htonl(IpAddress);

        break;
    }

    // return the ptr to the IP address so this can be filled in later if necessary
    return((PVOID)&pGeneral->IpAddress);
}


//----------------------------------------------------------------------------
VOID
NameDgramSendCompleted(
    PVOID               pContext,
    NTSTATUS            status,
    ULONG               lInfo
    )
/*++

Routine Description:

    This routine frees the name service datagram that was allocated for
    this name query or name registration in UdpSendNsBcast.

Arguments:

    pContext = ptr to datagram header

Return Value:


--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle OldIrq;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTEMemFree(pTracker->SendBuffer.pDgramHdr);
    pTracker->SendBuffer.pDgramHdr = NULL;
    NBT_DEREFERENCE_TRACKER(pTracker, TRUE);

    CTESpinFree(&NbtConfig.JointLock,OldIrq);
}
//----------------------------------------------------------------------------
VOID
NDgramSendCompleted(
    PVOID               pContext,
    NTSTATUS            status,
    ULONG               lInfo
    )
/*++

Routine Description:

    This routine frees the name service datagram that was allocated for
    this name query or name registration in UdpSendNsBcast.

Arguments:

    pContext = ptr to datagram header

Return Value:


--*/
{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle OldIrq;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    FreeTracker(pTracker, FREE_HDR | RELINK_TRACKER);
}

//----------------------------------------------------------------------------
NTSTATUS
UdpSendResponse(
    IN  ULONG                   lNameSize,
    IN  tNAMEHDR   UNALIGNED    *pNameHdrIn,
    IN  tNAMEADDR               *pNameAddr,
    IN  PTDI_ADDRESS_IP         pDestIpAddress,
    IN  tDEVICECONTEXT          *pDeviceContext,
    IN  ULONG                   Rcode,
    IN  enum eNSTYPE            NsType,
    IN  CTELockHandle           OldIrq
    )
/*++

Routine Description:

    This routine builds a Name Release/Registration/Query response pdu and
    sends it with the specified Rcode.

Arguments:

    lSize       - number of bytes in the name including scope in half ascii

Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    tNAMEHDR                    *pNameHdr;
    ULONG                       uLength;
    tDGRAM_SEND_TRACKING        *pTracker;
    tQUERYRESP UNALIGNED        *pQuery;
    ULONG                       ToCopy;
    LONG                        i;
    BOOLEAN                     RespondWithOneAddr = TRUE;
    ULONG                       MultiHomedSize = 0;
    ULONG                       in_addr;
    USHORT                      in_port;
    ULONG                       IpAddress = 0;
    USHORT                      NameType = 0;   // Assume we are Unique by default!
    BOOLEAN                     DoNonProxyCode = TRUE;

    in_addr = ntohl(pDestIpAddress->in_addr);
    in_port = ntohs(pDestIpAddress->sin_port);

    // a  multihomed node can have the SingleResponse registry value set so
    // that it never returns a list of ip addresses. This allows multihoming
    // in disjoint WINS server domains. - for name Query responses only
    //

    if ((NbtConfig.MultiHomed) && (!pNameAddr || pNameAddr->Verify != REMOTE_NAME) &&
        (!NbtConfig.SingleResponse) &&
        (NsType == eNAME_QUERY_RESPONSE))
    {
//        if (SrcIsNameServer(in_addr,in_port))
        {
            RespondWithOneAddr = FALSE;
            MultiHomedSize = (NbtConfig.AdapterCount-1)*sizeof(tADDSTRUCT);
        }
    }

    // size is size of the namehdr structure -1 for NetBiosName[1]
    // + the 32 bytes for the half ascii name + the Query response record
    // + any scope size (including the null on the end of the name)
    // ( part of the lNameSize) + the number of extra adapters * the size
    // of the address structure (multihomed case).
    uLength = sizeof(tNAMEHDR)
                            + sizeof(tQUERYRESP)
                            + lNameSize
                            - 1
                            + MultiHomedSize;

    // Note that this memory must be deallocated when the send completes in
    // tdiout.DgramSendCompletion
    pNameHdr = NbtAllocMem((USHORT)uLength ,NBT_TAG('Y'));
    if (!pNameHdr)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CTEZeroMemory((PVOID)pNameHdr,uLength);

    pNameHdr->QdCount = 0;
    pNameHdr->AnCount = 1;

    //
    // fill in the rest of the PDU explicitly
    //
    pQuery = (tQUERYRESP *)&pNameHdr->NameRR.NetBiosName[lNameSize];

    pQuery->RrTypeClass = htonl(QUEST_NBINTERNET);
    pQuery->Ttl = 0;
    pQuery->Length = htons(sizeof(tADDSTRUCT));
    pQuery->Flags = htons((USHORT)(NbtConfig.PduNodeType));

    // set the name type to 1 if it is a group so we can shift the 1 to the 16th
    // bit position
    // pNameAddr may not be set if we are sending a -ve NameQuery response, in which case, the field
    // is never looked at, or if we are sending a release response, which holds sends only  
    // for a unique name, in which case we have already initialized the value to 0
    //
    if (pNameAddr != NULL)
    {
        NameType = (pNameAddr->NameTypeState & (NAMETYPE_GROUP | NAMETYPE_INET_GROUP)) ? 1 : 0;
    }
    pQuery->Flags = htons((USHORT)((NameType << 15) | NbtConfig.PduNodeType));

    // convert Rcode to network order
    Rcode = htons(Rcode);

    switch (NsType)
    {

    case eNAME_RELEASE:
    case eNAME_REGISTRATION_RESPONSE:

        // copy the source name and the 12 bytes preceeding it to complete the
        // response pdu
        //
        ToCopy = sizeof(tNAMEHDR) + lNameSize -1;
        CTEMemCopy((PVOID)pNameHdr,
                   (PVOID)pNameHdrIn,
                   ToCopy);

        if (NsType == eNAME_RELEASE)
        {
            // setup the fields in the response.
            pNameHdr->OpCodeFlags = (USHORT)(OP_RESPONSE | OP_RELEASE
                                    | FL_AUTHORITY
                                    | Rcode);

        }
        else
        {
            // setup the fields in the response.
            pNameHdr->OpCodeFlags = (USHORT)(OP_RESPONSE | OP_REGISTRATION |
                                    FL_RECURDESIRE | FL_RECURAVAIL | FL_AUTHORITY
                                    | Rcode);

        }

        // these two lines must be here because the memcopy above sets
        // them to wrong values.
        pNameHdr->QdCount = 0;
        pNameHdr->AnCount = 1;
        pNameHdr->ArCount = 0;
        pNameHdr->NsCount = 0;

        // this code will run in the proxy case where another node does a
        // registration of a unique name that conflicts with an internet
        // group name in the remote table.  There are never any internet group
        // names in the local table - at least if there are, they are flagged
        // as simple groups.
        //
        if (pNameAddr)
        {
            if (pNameAddr->NameTypeState & NAMETYPE_INET_GROUP)
            {
                if (pNameAddr->pLmhSvcGroupList)
                {
                    IpAddress = pNameAddr->pLmhSvcGroupList[0];
                }
                else
                {
                    IpAddress = 0;
                }
            }
            else
            {
                // an ipaddress of 0 and a group name means it is a local name
                // table entry, where the 0 ipaddress should be switched to the
                // ipaddress of this adapter.
                //
                if ((pNameAddr->IpAddress == 0) &&
                   (pNameAddr->NameTypeState & NAMETYPE_GROUP))
                {
                    IpAddress = pDeviceContext->IpAddress;
                }
                else
                {
                    IpAddress = pNameAddr->IpAddress;
                }
            }
        }
        else
        {
            IpAddress = 0;
        }
        break;

    case eNAME_QUERY_RESPONSE:

        pNameHdr->OpCodeFlags = ( OP_RESPONSE | FL_AUTHORITY | FL_RECURDESIRE );

        pNameHdr->TransactId = pNameHdrIn->TransactId;

        // add 1 for the name length byte on the front of the name - scope is already
        // included in lNameSize
        //
        CTEMemCopy(&pNameHdr->NameRR.NameLength, (PVOID)&pNameHdrIn->NameRR.NameLength, lNameSize+1);

        if (pNameAddr == NULL)
        {
            // this is a negative query response record since there is no
            // local name to be found
            //
            pNameHdr->OpCodeFlags |= htons(NAME_ERROR);
            pQuery->Length = 0;
            IpAddress = 0;
        }
        else
        {
            tDEVICECONTEXT  *pDevContext;
            PLIST_ENTRY     pHead;
            PLIST_ENTRY     pEntry;

            // do not send name query responses for names not registered on
            // this net card, unless it is the name server for that net
            // card requesting the name query, since for Multihomed nodes
            // when it registers a name, WINS will do a query, which may
            // come in on the other net card that the name is not active on
            // yet - so we want to respond to this sort of query. Do not do
            // this check for a proxy since it is responding for a name
            // in the remote name table and it is not bound to an adapter.
            //
            if (!(NodeType & PROXY) &&
                !(pNameAddr->AdapterMask & pDeviceContext->AdapterMask) &&
                (!((in_port == NbtConfig.NameServerPort) &&
                (pDeviceContext->lNameServerAddress == in_addr) ||
                (pDeviceContext->lBackupServer == in_addr))))
            {
                //
                // Only return an address to the requestor if the
                // name is registered on that adapter
                //
                CTEMemFree(pNameHdr);

                CTESpinFree(&NbtConfig.JointLock,OldIrq);
                return(STATUS_UNSUCCESSFUL);
            }

            pQuery->Ttl = htonl(DEFAULT_TTL);
            //
            // In case of PROXY, we send one IP address as response to an
            // internet group query. Note: there should not be any INET_GROUP
            // names in the local hash table, hence a non-proxy should not execute
            // this code
            //
#ifdef PROXY_NODE
            //
            // When the proxy responds, the source node will see that it is a
            // group name and convert it to a broadcast, so the Ip address doesn't
            // really matter since the sender will not use it.  Note that the
            // source node send may not actually reach any members of the
            // internet group since they may all be off the local subnet.
            //
            IF_PROXY(NodeType)
            {
                DoNonProxyCode = FALSE;

                if (pNameAddr->NameTypeState & (NAMETYPE_INET_GROUP))
                {
                    IpAddress = 0;
                    PickBestAddress (pNameAddr, pDeviceContext, &IpAddress);
                }
                else if (pNameAddr->Verify == LOCAL_NAME)
                {
                    //
                    // if this name is local and if this is a multihomed machine
                    // we should treat it like a regular multihomed machine, even
                    // though this is a Proxy node
                    //
                    DoNonProxyCode = TRUE;
                }
                else
                {
                    IpAddress = pNameAddr->IpAddress;
                }

                if (IpAddress == 0)
                {
                    // don't return 0, return the broadcast address
                    //
                    IpAddress = pDeviceContext->BroadcastAddress;
                }

            }

            if (DoNonProxyCode)
#endif
            {
                // the node could be multihomed, but we are saying, only
                // respond with one address when this flag is set.
                if (RespondWithOneAddr)
                {
                    // for multihomed hosts, SelectAdapter can be set to TRUE
                    //
                    if (NbtConfig.SelectAdapter)
                    {
                        CTESystemTime   TimeValue;
                        LONG            Index;
                        ULONG           Count=0;

                        // we are only going to return one address, but we
                        // can randomly select it from the available adapters
                        // Try to find a valid ip address 5 times.
                        //
                        IpAddress = 0;
                        while ((IpAddress == 0) && (Count < 5))
                        {
                            Count++;
                            CTEQuerySystemTime(TimeValue);
                            Index = RandomizeFromTime( TimeValue, NbtConfig.AdapterCount ) ;

                            pHead = &NbtConfig.DeviceContexts;
                            pEntry = pHead->Flink;

                            for (i = 0;i< Index;i++)
                                pEntry = pEntry->Flink;

                            pDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);
                            IpAddress = pDevContext->IpAddress;
                        }

                        //
                        // if this adapter still has a null IpAddress then respond
                        // with the adapter the request came in on, since the
                        // other adapters could be idle RAS or waiting for a DHCP
                        // address just now...
                        //
                        if (IpAddress == 0)
                        {
                            IpAddress = pDeviceContext->IpAddress;
                        }
                    }
                    else
                    {
                        IpAddress = pDeviceContext->IpAddress;
                    }
                }
                else
                {
                    tADDSTRUCT      *pAddStruct;
                    USHORT          Flags;
                    ULONG           Count = 0;

                    // multihomed case - go through all the adapters making
                    // up a structure of all adapters that the name is
                    // registered against.  Enough memory was allocated up
                    // front to have the name registered against all adapeters
                    // on this node.
                    //
                    Flags = pQuery->Flags;

                    // set to zero so we don't try to set pQuery->IpAddress
                    // below
                    IpAddress = 0;

                    pAddStruct = (tADDSTRUCT *)&pQuery->Flags;
                    pHead = &NbtConfig.DeviceContexts;
                    pEntry = pHead->Flink;
                    while (pEntry != pHead)
                    {
                        pDevContext = CONTAINING_RECORD(pEntry,tDEVICECONTEXT,Linkage);

                        //
                        // only pass back addresses registered on this adapter
                        // that are not null(i.e. not RAS adapters after a disconnect)
                        //
                        if ((pDevContext->AdapterMask & pNameAddr->AdapterMask) &&
                            (pDevContext->IpAddress))
                        {
                            pAddStruct->NbFlags = Flags;
                            pAddStruct->IpAddr = htonl(pDevContext->IpAddress);
                            Count++;
                            pAddStruct++;
                        }
                        pEntry = pEntry->Flink;

                    }
                    // re-adjust the length of the pdu if the name is not registered
                    // against all adapters...
                    //
                    if (Count != NbtConfig.AdapterCount)
                    {
                        uLength -= (NbtConfig.AdapterCount - Count)*sizeof(tADDSTRUCT);
                    }
                    pQuery->Length = (USHORT)htons(Count*sizeof(tADDSTRUCT));
                }
            }
        }
    }

    if (IpAddress)
    {
        pQuery->IpAddress = htonl(IpAddress);
    }

    // get a tracker structure, which has a SendInfo structure in it
    status = GetTracker(&pTracker, NBT_TRACKER_SEND_RESPONSE_DGRAM);
    if (!NT_SUCCESS(status))
    {
        CTEMemFree((PVOID)pNameHdr);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // fill in the connection information
    pTracker->SendBuffer.HdrLength  = uLength;
    pTracker->SendBuffer.pDgramHdr = (PVOID)pNameHdr;
    pTracker->SendBuffer.Length  = 0;
    pTracker->SendBuffer.pBuffer = NULL;
    pTracker->pDeviceContext = pDeviceContext;

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    status = UdpSendDatagram (pTracker,
                              in_addr,
                              QueryRespDone,
                              pTracker,
                              in_port,
                              NBT_NAME_SERVICE);

    return(status);
}

//----------------------------------------------------------------------------
VOID
QueryRespDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo)
/*++
Routine Description

    This routine handles cleaning up various data blocks used in conjunction
    with the sending the Query response.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/

{
    tDGRAM_SEND_TRACKING    *pTracker;
    CTELockHandle OldIrq;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    FreeTracker(pTracker,RELINK_TRACKER | FREE_HDR);
}

//----------------------------------------------------------------------------
NTSTATUS
UdpSendDatagram(
    IN  tDGRAM_SEND_TRACKING       *pDgramTracker,
    IN  ULONG                      IpAddress,
    IN  PVOID                      pCompletionRoutine,
    IN  PVOID                      CompletionContext,
    IN  USHORT                     Port,
    IN  ULONG                      Service
    )
/*++

Routine Description:

    This routine sends a datagram across the TDI to be sent by Udp.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    TDI_REQUEST                 TdiRequest;
    ULONG                       uSentSize;
    TDI_CONNECTION_INFORMATION  *pSendInfo;
    PTRANSPORT_ADDRESS          pTransportAddr;
    ULONG                       Length;
    PFILE_OBJECT                TransportFileObject = NULL;
    CTELockHandle               OldIrq;
    tDEVICECONTEXT              *pDeviceContext = NULL;
    tFILE_OBJECTS               *pFileObjectsContext;

    status = STATUS_SUCCESS;

    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    if (NBT_REFERENCE_DEVICE (pDgramTracker->pDeviceContext, REF_DEV_UDP_SEND, TRUE))
    {
        pDeviceContext = pDgramTracker->pDeviceContext; // Assigned => referenced!

        if ((pDgramTracker->pDeviceContext->IpAddress) &&
            (pFileObjectsContext = pDgramTracker->pDeviceContext->pFileObjects))
        {
            switch (Service)
            {
                case (NBT_NAME_SERVICE):
                    TransportFileObject = pDgramTracker->pDeviceContext->pFileObjects->pNameServerFileObject;
                    break;

                case (NBT_DATAGRAM_SERVICE):
                    TransportFileObject = pDgramTracker->pDeviceContext->pFileObjects->pDgramFileObject;
                    break;

                default:
                    ;
            }

            //
            // an address of 0 means do a broadcast.  When '1C' internet group
            // names are built either from the Lmhost file or from the network
            // the broadcast address is inserted in the list as 0.
            //
            if (IpAddress == 0)
            {
                IpAddress = pDgramTracker->pDeviceContext->BroadcastAddress;
            }

            // when there is no WINS server set in the registry we set the WINS
            // ip address to LOOP_BACK, so if it is set to that here, do not send
            // the datagram.  If There is no Ip Address then the Transport Handle
            // will be null and we do not do the send in that case either.
            //
            if (IpAddress == LOOP_BACK)
            {
                TransportFileObject = NULL ;
            }
        }

        //
        // Dereference the Device if the request is going to fail, or
        // there is no completion routine!
        //
        if ((!TransportFileObject) || (!pCompletionRoutine))
        {
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_UDP_SEND, TRUE);
        }
    }

    if (!TransportFileObject)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);

        if (pCompletionRoutine)
        {
            (*(NBT_COMPLETION) pCompletionRoutine) (CompletionContext, STATUS_UNSUCCESSFUL, 0);
        }
        return(status);
    }

    pFileObjectsContext->RefCount++;        // Dereferenced after the Send has completed
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    // the completion routine is setup to free the pDgramTracker memory block
    TdiRequest.Handle.AddressHandle = (PVOID)TransportFileObject;
    TdiRequest.RequestNotifyObject = pCompletionRoutine;
    TdiRequest.RequestContext = (PVOID)CompletionContext;

    // the send length is the client dgram length + the size of the dgram header
    Length = pDgramTracker->SendBuffer.HdrLength + pDgramTracker->SendBuffer.Length;

    // fill in the connection information
    pSendInfo = pDgramTracker->pSendInfo;
    pSendInfo->RemoteAddressLength = sizeof(TRANSPORT_ADDRESS) -1 + pNbtGlobConfig->SizeTransportAddress;

    // fill in the remote address
    pTransportAddr = (PTRANSPORT_ADDRESS)pSendInfo->RemoteAddress;
    pTransportAddr->TAAddressCount = 1;
    pTransportAddr->Address[0].AddressLength = pNbtGlobConfig->SizeTransportAddress;
    pTransportAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->sin_port = htons(Port);
    ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->in_addr  = htonl(IpAddress);

    status = TdiSendDatagram (&TdiRequest, pSendInfo, Length, &uSentSize, pDgramTracker);

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    if (--pFileObjectsContext->RefCount == 0)
    {
        NTQueueToWorkerThread(
                        &pFileObjectsContext->WorkItemCleanUp,
                        DelayedNbtCloseFileHandles,
                        NULL,
                        pFileObjectsContext,
                        NULL,
                        NULL,
                        TRUE
                        );
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
TcpSessionStart(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  ULONG                      IpAddress,
    IN  tDEVICECONTEXT             *pDeviceContext,
    IN  PVOID                      pCompletionRoutine,
    IN  ULONG                      Port
    )
/*++

Routine Description:

    This routine sets up a tcp connection by passing a connect through TDI to
    TCP.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    TDI_REQUEST                 TdiRequest;
    TDI_CONNECTION_INFORMATION  *pSendInfo;
    PTRANSPORT_ADDRESS          pTransportAddr;
    tCONNECTELE                 *pConnEle;
    CTELockHandle               OldIrq;
    tLOWERCONNECTION            *pLowerConn;

    pSendInfo = pTracker->pSendInfo;

    // we need to pass the file handle of the connection to TCP.
    pConnEle = (tCONNECTELE *)pTracker->pConnEle;

    CTESpinLock(pConnEle,OldIrq);
    pLowerConn = pConnEle->pLowerConnId;
    if (pLowerConn)
    {
        TdiRequest.Handle.AddressHandle = (PVOID)((tLOWERCONNECTION *)pConnEle->pLowerConnId)->pFileObject;

        // the completion routine is setup to free the pTracker memory block
        TdiRequest.RequestNotifyObject = pCompletionRoutine;
        TdiRequest.RequestContext = (PVOID)pTracker;

        // fill in the connection information
        pSendInfo->RemoteAddressLength = sizeof(TRANSPORT_ADDRESS) -1 + pNbtGlobConfig->SizeTransportAddress;

        pTransportAddr = (PTRANSPORT_ADDRESS)pSendInfo->RemoteAddress;

        // fill in the remote address
        pTransportAddr->TAAddressCount = 1;
        pTransportAddr->Address[0].AddressLength = pNbtGlobConfig->SizeTransportAddress;
        pTransportAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->sin_port = htons((USHORT)Port);
        ((PTDI_ADDRESS_IP)pTransportAddr->Address[0].Address)->in_addr  = htonl(IpAddress);

        CTESpinFree(pConnEle,OldIrq);

        // pass through the TDI I/F on the bottom of NBT, to the transport
        // pass in the original irp from the client so that the client can
        // cancel it ok...rather than use one of NBT's irps
        //
        status = TdiConnect (&TdiRequest, (ULONG_PTR)pTracker->pTimeout, pSendInfo, pConnEle->pIrp);
    }
    else
    {
        CTESpinFree(pConnEle,OldIrq);
        //
        // Complete the request through the completion routine so it
        // cleans up correctly
        //
        (*(NBT_COMPLETION)pCompletionRoutine)( (PVOID)pTracker, STATUS_CANCELLED, 0L );
        status = STATUS_CANCELLED;
    }

    NbtTrace(NBT_TRACE_OUTBOUND, ("\tpTracker %p: %!status!", pTracker, status));
    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
TcpSendSessionResponse(
    IN  tLOWERCONNECTION           *pLowerConn,
    IN  ULONG                      lStatusCode,
    IN  ULONG                      lSessionStatus
    )
/*++

Routine Description:

    This routine sends a session PDU corresponding to the lStatusCode. This
    could be a KeepAlive, PositiveSessionResponse, NegativeSessionResponse or
    a Retarget (not implemented yet).  For the Keep Alive case the completion
    routine passed in is used rather than SessionRespDone, as is the case
    for all other messages.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    tDGRAM_SEND_TRACKING        *pTracker;
    tSESSIONERROR               *pSessionHdr;

    pSessionHdr = (tSESSIONERROR *)NbtAllocMem(sizeof(tSESSIONERROR),NBT_TAG('Z'));
    if (!pSessionHdr)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // get a tracker structure, which has a SendInfo structure in it
    status = GetTracker(&pTracker, NBT_TRACKER_SEND_RESPONSE_SESSION);
    if (NT_SUCCESS(status))
    {
        pTracker->SendBuffer.pDgramHdr = (PVOID)pSessionHdr;
        pTracker->SendBuffer.pBuffer = NULL;
        pTracker->SendBuffer.Length = 0;

        pSessionHdr->Flags = NBT_SESSION_FLAGS;
        pSessionHdr->Type = (UCHAR)lStatusCode;

        switch (lStatusCode)
        {
            case NBT_NEGATIVE_SESSION_RESPONSE:
                pTracker->SendBuffer.HdrLength = sizeof(tSESSIONERROR);
                // this length is one byte longer for the error code - different type used here
                pSessionHdr->Length = htons(1);    // one error code byte
                pSessionHdr->ErrorCode = (UCHAR)lSessionStatus;
                break;

            case NBT_POSITIVE_SESSION_RESPONSE:
                pTracker->SendBuffer.HdrLength = sizeof(tSESSIONHDR);
                pSessionHdr->Length = 0;        // no data following the length byte
                break;

        }
        NbtTrace(NBT_TRACE_INBOUND, ("pTracker %p: Session Response %d", pTracker, lStatusCode));

        status = TcpSendSession(pTracker,
                                pLowerConn,
                                SessionRespDone);
    }
    else
    {
        CTEMemFree((PVOID)pSessionHdr);
    }

    return(status);

}


//----------------------------------------------------------------------------
NTSTATUS
TcpSendSession(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  tLOWERCONNECTION           *pLowerConn,
    IN  PVOID                      pCompletionRoutine
    )
/*++

Routine Description:

    This routine sends a message on a tcp connection.

Arguments:


Return Value:

    NTSTATUS - success or not

--*/
{
    NTSTATUS                    status;
    TDI_REQUEST                 TdiRequest;
    ULONG                       lSentLength;

    // we need to pass the file handle of the connection to TCP.
    TdiRequest.Handle.AddressHandle = (PVOID)pLowerConn->pFileObject;

    // the completion routine is setup to free the pTracker memory block
    TdiRequest.RequestContext = (PVOID)pTracker;

    // this completion routine just puts the tracker back on its list and
    // frees the memory associated with the UserData buffer.
    TdiRequest.RequestNotifyObject = pCompletionRoutine;

    // pass through the TDI I/F on the bottom of NBT, to the transport
    status = TdiSend(
                &TdiRequest,
                0,                           // no send flags
                (ULONG)pTracker->SendBuffer.HdrLength +
                (ULONG)pTracker->SendBuffer.Length ,
                &lSentLength,
                &pTracker->SendBuffer,
                0);     // no send flags set

    NbtTrace(NBT_TRACE_OUTBOUND, ("\tpTracker %p: %!status!", pTracker, status));

    return(status);
}

//----------------------------------------------------------------------------
VOID
SessionRespDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo)
/*++
Routine Description

    This routine handles cleaning up various data blocks used in conjunction
    sending a session response at session startup time.  If the session
    response was negative, then kill the connection.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block
    NTSTATUS    - completion status

Return Values:

    VOID

--*/

{
    tDGRAM_SEND_TRACKING    *pTracker;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;

    FreeTracker(pTracker,FREE_HDR | RELINK_TRACKER);

}


//----------------------------------------------------------------------------
NTSTATUS
SendTcpDisconnect(
    IN  tLOWERCONNECTION  *pLowerConnId
    )
/*++
Routine Description

    This routine disconnects a TCP connection in a graceful manner which
    insures that any data still in the pipe gets to the other side. Mostly
    it calls TcpDisconnect which does the work. This routine just gets a
    tracker for the send.

Arguments:

    pLowerConnID    - ptr to the lower connection that has the file object in it

Return Values:
    NTSTATUS    - completion status

    VOID

--*/

{
    NTSTATUS                status;
    tDGRAM_SEND_TRACKING    *pTracker;

    status = GetTracker(&pTracker, NBT_TRACKER_SEND_DISCONNECT);
    if (NT_SUCCESS(status))
    {
        pTracker->pConnEle = (PVOID)pLowerConnId;

        status = TcpDisconnect(pTracker,NULL,TDI_DISCONNECT_RELEASE,FALSE);
    }
    return(status);

}

//----------------------------------------------------------------------------
NTSTATUS
TcpDisconnect(
    IN  tDGRAM_SEND_TRACKING       *pTracker,
    IN  PVOID                      Timeout,
    IN  ULONG                      Flags,
    IN  BOOLEAN                    Wait
    )
/*++
Routine Description

    This routine disconnects a TCP connection in a graceful manner which
    insures that any data still in the pipe gets to the other side.

Arguments:

    pTracker    - ptr to the DGRAM_TRACKER block

Return Values:
    NTSTATUS    - completion status

    VOID

--*/

{
    TDI_REQUEST             TdiRequest;
    NTSTATUS                status;

    // we need to pass the file handle of the connection to TCP.
    TdiRequest.Handle.AddressHandle =
       (PVOID)((tLOWERCONNECTION *)pTracker->pConnEle)->pFileObject;

    // the completion routine is setup to free the pTracker memory block
    TdiRequest.RequestContext = (PVOID)pTracker;

    // this completion routine just puts the tracker back on its list and
    // frees the memory associated with the UserData buffer.
    TdiRequest.RequestNotifyObject = DisconnectDone;
    pTracker->Flags = (USHORT)Flags;

    status = TdiDisconnect(&TdiRequest,
                  Timeout,
                  Flags,
                  pTracker->pSendInfo,
                  ((tLOWERCONNECTION *)pTracker->pConnEle)->pIrp,
                  Wait);

    NbtTrace(NBT_TRACE_DISCONNECT, ("pTracker %p: %!status!", pTracker, status));

    return(status);
}

//----------------------------------------------------------------------------
VOID
DisconnectDone(
    IN  PVOID       pContext,
    IN  NTSTATUS    status,
    IN  ULONG       lInfo)
/*++
Routine Description

    This routine handles cleaning up after a disconnect is sent to the transport.

Arguments:

    pContext    - ptr to the DGRAM_TRACKER block

Return Values:

    VOID

--*/

{
    tDGRAM_SEND_TRACKING    *pTracker;
    tLOWERCONNECTION        *pLowerConn;
    CTELockHandle           OldIrq;
    PCTE_IRP                pIrp;
    BOOLEAN                 CleanupLower = FALSE;
    NTSTATUS                DiscWaitStatus;
    tCONNECTELE             *pConnEle;
    PCTE_IRP                pIrpClose;
    tDEVICECONTEXT          *pDeviceContext = NULL;

    pTracker = (tDGRAM_SEND_TRACKING *)pContext;
    pLowerConn = (tLOWERCONNECTION *)pTracker->pConnEle;

    NbtTrace(NBT_TRACE_DISCONNECT, ("pTracker %p: pLowerConn %p pConnEle %p %!status!",
                        pTracker, pLowerConn, pLowerConn->pUpperConnection, status));

    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    CTESpinLockAtDpc(pLowerConn);

    ASSERT (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN));

    IF_DBG(NBT_DEBUG_DISCONNECT)
        KdPrint(("Nbt.DisconnectDone: Disconnect Irp has been returned...pLowerConn %X,state %X\n",
            pLowerConn,pLowerConn->State));
    //
    // if the state is disconnected, then a disconnect indication
    // has come from the transport.. . if still disconnecting,
    // then we have not had a disconnect indication yet, so
    // wait for the indication to go through DisconnectHndlrNotOs which
    // will do the cleanup.
    //

    //  Streams TCP always indicates before completing the disconnect request,
    //  so we always cleanup here for the Streams stack.
    //
    //
    //  If the disconnect was abortive, then there will not be a disconnect
    //  indication, so do the cleanup now.
    //
    if ((!StreamsStack) &&
        (NT_SUCCESS (status)) &&
        (pTracker->Flags == TDI_DISCONNECT_RELEASE) &&
        (pLowerConn->State == NBT_DISCONNECTING))
    {
        SET_STATE_LOWER (pLowerConn, NBT_DISCONNECTED);
    }
    else if (pLowerConn->State != NBT_IDLE)
    {
        //
        // change the state to idle so that the Disconnect handler will
        // not attempt to do anything with it if for some reason the transport
        // indicates a disconnect after this point.
        //
        ASSERT((pLowerConn->State == NBT_DISCONNECTED) || (pLowerConn->State == NBT_DISCONNECTING));
        SET_STATE_LOWER (pLowerConn, NBT_IDLE);

        CleanupLower = TRUE;
    }

    //
    // there may be a disconnect wait irp, so return that first if there
    // is one waiting around.
    //
    pConnEle = pLowerConn->pUpperConnection;
    if (pConnEle && pConnEle->pIrpClose)
    {
        pIrpClose = pConnEle->pIrpClose;
        CHECK_PTR(pConnEle);
        pConnEle->pIrpClose = NULL ;
        if (pConnEle->DiscFlag == TDI_DISCONNECT_ABORT)
        {
            DiscWaitStatus = STATUS_CONNECTION_RESET;
        }
        else
        {
            DiscWaitStatus = STATUS_GRACEFUL_DISCONNECT;
        }
    }
    else
    {
        pIrpClose = NULL;
    }

    //
    // This is the disconnect requesting Irp
    //
    pLowerConn->bDisconnectIrpPendingInTCP = FALSE;
    if (pLowerConn->pIrp)
    {
        pIrp = pLowerConn->pIrp;
        pLowerConn->pIrp = NULL ;
    }
    else
    {
        pIrp = NULL;
    }

    CTESpinFreeAtDpc(pLowerConn);

    if (CleanupLower)
    {
        ASSERT(pLowerConn->RefCount > 1);

        if (NBT_VERIFY_HANDLE (pLowerConn->pDeviceContext, NBT_VERIFY_DEVCONTEXT))
        {
            pDeviceContext = pLowerConn->pDeviceContext;
        }

        // this either puts the lower connection back on its free
        // queue if inbound, or closes the connection with the transport
        // if out bound. (it can't be done at dispatch level).
        //
        status = NTQueueToWorkerThread(
                            &pLowerConn->WorkItemCleanUpAndWipeOut,
                            DelayedCleanupAfterDisconnect,
                            NULL,
                            pLowerConn,
                            NULL,
                            pDeviceContext,
                            TRUE
                            );
    }

    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    FreeTracker(pTracker,RELINK_TRACKER);

    if (pIrpClose)
    {
        CTEIoComplete( pIrpClose, DiscWaitStatus, 0 ) ;
    }

    if (pIrp)
    {
        CTEIoComplete( pIrp, status, 0 ) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\timer.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Timer.c

Abstract:


    This file contains the code to implement timer functions.


Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/

#include "precomp.h"
#include "timer.h"
#include "ntddndis.h"

// the timer Q
tTIMERQ TimerQ;


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, InitTimerQ)
#pragma CTEMakePageable(PAGE, DestroyTimerQ)
#pragma CTEMakePageable(PAGE, DelayedNbtStopWakeupTimer)
#endif
// #pragma CTEMakePageable(PAGE, WakeupTimerExpiry)
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------
NTSTATUS
InterlockedCallCompletion(
    IN  tTIMERQENTRY    *pTimer,
    IN  NTSTATUS        status
    )
/*++

Routine Description:

    This routine calls the completion routine if it hasn't been called
    yet, by first getting the JointLock spin lock and then getting the
    Completion routine ptr. If the ptr is null then the completion routine
    has already been called. Holding the Spin lock interlocks this
    with the timer expiry routine to prevent more than one call to the
    completion routine.

Arguments:

Return Value:

    there is no return value


--*/
{
    CTELockHandle       OldIrq;
    COMPLETIONCLIENT    pClientCompletion;

    // to synch. with the the Timer completion routines, Null the client completion
    // routine so it gets called just once, either from here or from the
    // timer completion routine setup when the timer was started.(in namesrv.c)
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    pClientCompletion = pTimer->ClientCompletion;
    pTimer->ClientCompletion = NULL;
    if (pClientCompletion)
    {
        // remove the link from the name table to this timer block
        CHECK_PTR(((tNAMEADDR *)pTimer->pCacheEntry));
        ((tNAMEADDR *)pTimer->pCacheEntry)->pTimer = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        (*pClientCompletion) (pTimer->ClientContext, status);
        return(STATUS_SUCCESS);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(STATUS_UNSUCCESSFUL);
}

//----------------------------------------------------------------------------
NTSTATUS
InitTimerQ(
    VOID
    )
/*++

Routine Description:

    This routine sets up the timer Q.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tTIMERQENTRY    *pTimerEntry;

    CTEPagedCode();

    InitializeListHead(&TimerQ.ActiveHead);
    ExInitializeNPagedLookasideList(
                    &TimerQ.LookasideList,
                    NULL,
                    NULL,
                    0,
                    sizeof(tTIMERQENTRY),
                    NBT_TAG2('16'),
                    0
                    );
    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
DestroyTimerQ(
    )
/*++

Routine Description:

    This routine clears up the TimerQEntry structures allocated

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tTIMERQENTRY    *pTimer;
    PLIST_ENTRY     pEntry;

    CTEPagedCode();
    ExDeleteNPagedLookasideList(&TimerQ.LookasideList);

    return(STATUS_SUCCESS);
}

//----------------------------------------------------------------------------
NTSTATUS
GetTimerEntry(
    OUT tTIMERQENTRY    **ppTimerEntry
    )
/*++

Routine Description:

    This routine gets a free block&TimerQ.
    NOTE: this function is called with the JointLock held.

Arguments:

Return Value:

    The function value is the status of the operation.


--*/
{
    PLIST_ENTRY     pEntry;
    tTIMERQENTRY    *pTimerEntry;

    pTimerEntry = (tTIMERQENTRY *)ExAllocateFromNPagedLookasideList(&TimerQ.LookasideList);
    if (NULL == pTimerEntry) {
        KdPrint(("Unable to allocate memory!! - for the timer Q\n"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    *ppTimerEntry = pTimerEntry;
    pTimerEntry->Verify = NBT_VERIFY_TIMER_ACTIVE;
    NbtConfig.lNumTimersRunning++;

    return(STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
VOID
ReturnTimerToFreeQ(
    tTIMERQENTRY    *pTimerEntry,
    BOOLEAN         fLocked
    )
{
    CTELockHandle   OldIrq;

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    // return the timer block
    ASSERT (pTimerEntry->Verify == NBT_VERIFY_TIMER_ACTIVE);
    pTimerEntry->Verify = NBT_VERIFY_TIMER_DOWN;

    ExFreeToNPagedLookasideList(&TimerQ.LookasideList, pTimerEntry);
    if (!--NbtConfig.lNumTimersRunning)
    {
        KeSetEvent(&NbtConfig.TimerQLastEvent, 0, FALSE);
    }

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }
}


//----------------------------------------------------------------------------
NTSTATUS
CleanupCTETimer(
    IN  tTIMERQENTRY     *pTimerEntry
    )
/*++

Routine Description:

    This routine cleans up the timer. Called with the JointLock held.

Arguments:


Return Value:

    returns the reference count after the decrement

--*/
{
    COMPLETIONROUTINE   TimeoutRoutine;
    PVOID               Context;
    PVOID               Context2;

    pTimerEntry->RefCount = 0;

    // the expiry routine is not currently running so we can call the
    // completion routine and remove the timer from the active timer Q

    TimeoutRoutine = (COMPLETIONROUTINE)pTimerEntry->TimeoutRoutine;
    pTimerEntry->TimeoutRoutine = NULL;
    Context = pTimerEntry->Context;
    Context2 = pTimerEntry->Context2;

    if (pTimerEntry->pDeviceContext)
    {
        NBT_DEREFERENCE_DEVICE ((tDEVICECONTEXT *) pTimerEntry->pDeviceContext, REF_DEV_TIMER, TRUE);
        pTimerEntry->pDeviceContext = NULL;
    }

    // release any tracker block hooked to the timer entry.. This could
    // be modified to not call the completion routine if there was
    // no context value... ie. for those timers that do not have anything
    // to cleanup ...however, for now we require all completion routines
    // to have a if (pTimerQEntry) if around the code so when it gets hit
    // from this call it does not access any part of pTimerQEntry.
    //
    if (TimeoutRoutine)
    {
        // call the completion routine so it can clean up its own buffers
        // the routine that called this one will call the client's completion
        // routine.  A NULL timerEntry value indicates to the routine that
        // cleanup should be done.

        (VOID)(*TimeoutRoutine) (Context, Context2, NULL);
    }

    // move to the free list
    RemoveEntryList(&pTimerEntry->Linkage);
    ReturnTimerToFreeQ (pTimerEntry, TRUE);

    return(STATUS_SUCCESS);
}



//----------------------------------------------------------------------------
NTSTATUS
StartTimer(
    IN  PVOID           TimeoutRoutine,
    IN  ULONG           DeltaTime,
    IN  PVOID           Context,
    IN  PVOID           Context2,
    IN  PVOID           ContextClient,
    IN  PVOID           CompletionClient,
    IN  tDEVICECONTEXT  *pDeviceContext,
    OUT tTIMERQENTRY    **ppTimerEntry,
    IN  USHORT          Retries,
    BOOLEAN             fLocked)
/*++

Routine Description:

    This routine starts a timer.
    It has to be called with the JointLock held!

Arguments:

    The value passed in is in milliseconds - must be converted to 100ns
    so multiply to 10,000

Return Value:
    The function value is the status of the operation.


--*/
{
    tTIMERQENTRY    *pTimerEntry;
    NTSTATUS        status;
    CTELockHandle   OldIrq;

    //
    // Do not allow any timers to be started if we are currently
    // Unloading!
    //
    if (NbtConfig.Unloading)
    {
        return STATUS_UNSUCCESSFUL;
    }

    if (!fLocked)
    {
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
    }

    if ((!pDeviceContext) ||
        (NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_TIMER, TRUE)))
    {
        // get a free timer block
        status = GetTimerEntry (&pTimerEntry);
        if (NT_SUCCESS(status))
        {
            pTimerEntry->DeltaTime = DeltaTime;
            pTimerEntry->RefCount = 1;
            //
            // this is the context value and routine called when the timer expires,
            // called by TimerExpiry below.
            //
            pTimerEntry->Context = Context;
            pTimerEntry->Context2 = Context2;
            pTimerEntry->TimeoutRoutine = TimeoutRoutine;
            pTimerEntry->Flags = 0; // no flags

            // now fill in the client's completion routines that ultimately get called
            // after one or more timeouts...
            pTimerEntry->ClientContext = (PVOID)ContextClient;
            pTimerEntry->ClientCompletion = (COMPLETIONCLIENT)CompletionClient;
            pTimerEntry->Retries = Retries;

            pTimerEntry->pDeviceContext = (PVOID) pDeviceContext;

            CTEInitTimer(&pTimerEntry->VxdTimer);
            CTEStartTimer(&pTimerEntry->VxdTimer,
                           pTimerEntry->DeltaTime,
                           (CTEEventRtn)TimerExpiry,
                           (PVOID)pTimerEntry);

            // check if there is a ptr to return
            if (ppTimerEntry)
            {
                *ppTimerEntry = pTimerEntry;
            }

            // put on list
            InsertHeadList(&TimerQ.ActiveHead, &pTimerEntry->Linkage);
        }
        else if (pDeviceContext)
        {
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_TIMER, TRUE);
        }
    }
    else
    {
        status = STATUS_INVALID_DEVICE_STATE;
    }

    if (!fLocked)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    return(status);
}

//----------------------------------------------------------------------------
NTSTATUS
StopTimer(
    IN  tTIMERQENTRY     *pTimerEntry,
    OUT COMPLETIONCLIENT *ppClientCompletion,
    OUT PVOID            *ppContext)
/*++

Routine Description:

    This routine stops a timer.  Must be called with the Joint lock held.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS            status;
    COMPLETIONROUTINE   TimeoutRoutine;

    // null the client completion routine and Context so that it can't be called again
    // accidently
    if (ppClientCompletion)
    {
        *ppClientCompletion = NULL;
    }
    if (ppContext)
    {
        *ppContext = NULL;
    }

    // it is possible that the timer expiry routine has just run and the timer
    // has not been restarted, so check the refcount, it will be zero if the
    // timer was not restarted and 2 if the timer expiry is currently running.
    if (pTimerEntry->RefCount == 1)
    {
        // this allows the caller to call the client's completion routine with
        // the context value.
        if (ppClientCompletion)
        {
            *ppClientCompletion = pTimerEntry->ClientCompletion;
        }
        if (ppContext)
        {
            *ppContext = pTimerEntry->ClientContext;
        }

        pTimerEntry->ClientCompletion = NULL;

        if (!(pTimerEntry->Flags & TIMER_NOT_STARTED))
        {
            if (!CTEStopTimer((CTETimer *)&pTimerEntry->VxdTimer ))
            {
                //
                // It means the TimerExpiry routine is waiting to run,
                // so let it return this timer block to the free Q
                // Bug # 229535
                //
                // Before returning from here, we should do the cleanup since
                // the CompletionRoutine (if any) can result in some data
                // that is required for cleanup to be cleaned up (Bug # 398730)
                //
                if (TimeoutRoutine = (COMPLETIONROUTINE)pTimerEntry->TimeoutRoutine)
                {
                    // call the completion routine so it can clean up its own buffers
                    // the routine that called this one will call the client's completion
                    // routine.  A NULL timerEntry value indicates to the routine that
                    // cleanup should be done.
            
                    pTimerEntry->TimeoutRoutine = NULL;
                    (VOID)(*TimeoutRoutine) (pTimerEntry->Context, pTimerEntry->Context2, NULL);
                }
                pTimerEntry->RefCount = 2;
                return (STATUS_SUCCESS);
            }
        }

        status = STATUS_SUCCESS;
        status = CleanupCTETimer(pTimerEntry);
    }
    else if (pTimerEntry->RefCount == 2)
    {
        // the timer expiry completion routines must set this routine to
        // null with the spin lock held to synchronize with this stop timer
        // routine.  Likewise that routine checks this value too, to synchronize
        // with this routine.
        //
        if (pTimerEntry->ClientCompletion)
        {
            // this allows the caller to call the client's completion routine with
            // the context value.
            if (ppClientCompletion)
            {
                *ppClientCompletion = pTimerEntry->ClientCompletion;
            }
            if (ppContext)
            {
                *ppContext = pTimerEntry->ClientContext;
            }
            // so that the timer completion routine cannot also call the client
            // completion routine.
            pTimerEntry->ClientCompletion = NULL;

        }

        // signal the TimerExpiry routine that the timer has been cancelled
        //
        pTimerEntry->RefCount++;
        status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        status = STATUS_UNSUCCESSFUL;
    }

    return(status);
}


//----------------------------------------------------------------------------
VOID
TimerExpiry(
#ifndef VXD
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArg1,
    IN  PVOID   SystemArg2
#else
    IN  CTEEvent * pCTEEvent,
    IN  PVOID   DeferredContext
#endif
    )
/*++

Routine Description:

    This routine is the timer expiry completion routine.  It is called by the
    kernel when the timer expires.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    tTIMERQENTRY    *pTimerEntry;
    CTELockHandle   OldIrq1;

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    // get the timer Q list entry from the context passed in
    pTimerEntry = (tTIMERQENTRY *)DeferredContext;

    if (pTimerEntry->RefCount == 0)
    {
        // the timer has been cancelled already!
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return;
    }
    else if (pTimerEntry->RefCount >= 2)    // Bug #: 229535
    {
        // the timer has been cancelled already!
        // Bug # 324655
        // If the Timer has been cancelled, we still need to do cleanup,
        // so do not NULL the TimeoutRoutine!
        //
//        pTimerEntry->TimeoutRoutine = NULL;
        ASSERT ((pTimerEntry->RefCount == 2) || (pTimerEntry->TimeoutRoutine == NULL));
        CleanupCTETimer (pTimerEntry);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return;
    }

    // increment the reference count because we are handling a timer completion
    // now
    pTimerEntry->RefCount++;

    CTESpinFree(&NbtConfig.JointLock,OldIrq1);

    // call the completion routine passing the context value
    pTimerEntry->Flags &= ~TIMER_RESTART;   // incase the clients wants to restart the timer
    (*(COMPLETIONROUTINE)pTimerEntry->TimeoutRoutine)(
                pTimerEntry->Context,
                pTimerEntry->Context2,
                pTimerEntry);

    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

    pTimerEntry->RefCount--;
    if (pTimerEntry->Flags & TIMER_RESTART)
    {
        if (pTimerEntry->RefCount == 2)
        {
            // the timer was stopped during the expiry processing, so call the
            // deference routine
            //
            CleanupCTETimer(pTimerEntry);
            CTESpinFree(&NbtConfig.JointLock,OldIrq1);

            return;
        }
        else
        {
            CTEStartTimer (&pTimerEntry->VxdTimer,
                           pTimerEntry->DeltaTime,
                           (CTEEventRtn)TimerExpiry,
                           (PVOID)pTimerEntry);
        }

        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
        return;
    }
    else
    {
        // move to the free list after setting the reference count to zero
        // since this timer block is no longer active.
        //
        pTimerEntry->TimeoutRoutine = NULL;
        CleanupCTETimer (pTimerEntry);
        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
    }
}

//----------------------------------------------------------------------------
VOID
ExpireTimer(
    IN  tTIMERQENTRY    *pTimerEntry,
    IN  CTELockHandle   *OldIrq1
    )
/*++

Routine Description:

    This routine causes the timer to be stopped (if it hasn't already)
    and if successful, calls the Completion routine.

Arguments:


Return Value:

    The function value is the status of the operation.

--*/
{
    //
    // Reset the Number of retries
    //
    pTimerEntry->Retries = 1;

    //
    // RefCount == 0    =>  Timer was stopped, but not restarted
    // RefCount == 1    =>  Timer is still running                  *
    // RefCount == 2    =>  TimerExpiry is currently running
    //
    if ((pTimerEntry->RefCount == 1) &&
        (!(pTimerEntry->Flags & TIMER_NOT_STARTED)) &&
        (CTEStopTimer( (CTETimer *)&pTimerEntry->VxdTimer)))
    {
        // increment the reference count because we are handling a timer completion
        // now
        pTimerEntry->RefCount++;

        CTESpinFree(&NbtConfig.JointLock, *OldIrq1);

        // call the completion routine passing the context value
        pTimerEntry->Flags &= ~TIMER_RESTART;   // incase the clients wants to restart the timer
        (*(COMPLETIONROUTINE)pTimerEntry->TimeoutRoutine) (pTimerEntry->Context,
                                                           pTimerEntry->Context2,
                                                           pTimerEntry);

        CTESpinLock(&NbtConfig.JointLock, *OldIrq1);

        pTimerEntry->RefCount--;
        if (pTimerEntry->Flags & TIMER_RESTART)
        {
            if (pTimerEntry->RefCount == 2)
            {
                // the timer was stopped during the expiry processing, so call the
                // deference routine
                //
                CleanupCTETimer(pTimerEntry);
            }
            else
            {
                CTEStartTimer(&pTimerEntry->VxdTimer,
                               pTimerEntry->DeltaTime,
                               (CTEEventRtn)TimerExpiry,
                               (PVOID)pTimerEntry);
            }
        }
        else
        {
            // move to the free list after setting the reference count to zero
            // since this tierm block is no longer active.
            //
            pTimerEntry->TimeoutRoutine = NULL;
            CleanupCTETimer (pTimerEntry);
        }
    }

    CTESpinFree(&NbtConfig.JointLock, *OldIrq1);
}



//----------------------------------------------------------------------------
//
// Wakeup Timer routines
//
//----------------------------------------------------------------------------


VOID
WakeupTimerExpiry(
    PVOID           DeferredContext,
    ULONG           LowTime,
    LONG            HighTime
    )
{
    BOOLEAN         fAttached = FALSE;
    CTELockHandle   OldIrq;
    tTIMERQENTRY    *pTimerEntry = (tTIMERQENTRY *)DeferredContext;

    //
    // Call the TimerExpiry function while holding the NbtConfig.Resource
    //
    CTEExAcquireResourceExclusive (&NbtConfig.Resource,TRUE);
    if (pTimerEntry->RefCount > 1)
    {
        //
        // The timer is waiting to be cleaned up on a Worker thread,
        // so let it cleanup!
        //
        CTEExReleaseResource (&NbtConfig.Resource);
        return;
    }

    //
    // The Timeout routine has to ensure that it cleans up
    // properly since this pTimerEntry + handle will not be valid
    // at the end of this routine!
    //
    (*(COMPLETIONROUTINE) pTimerEntry->TimeoutRoutine) (pTimerEntry->Context,
                                                        pTimerEntry->Context2,
                                                        pTimerEntry);

    //
    // Close the timer handle
    //
    CTEAttachFsp(&fAttached, REF_FSP_WAKEUP_TIMER_EXPIRY);
    //
    // The Expiry routine should always be called in the context
    // of the system process
    //
    ASSERT (fAttached == FALSE);
    ZwClose (pTimerEntry->WakeupTimerHandle);
    CTEDetachFsp(fAttached, REF_FSP_WAKEUP_TIMER_EXPIRY);
    CTEExReleaseResource (&NbtConfig.Resource);

    ReturnTimerToFreeQ (pTimerEntry, FALSE);
}


//----------------------------------------------------------------------------
VOID
DelayedNbtStopWakeupTimer(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   pClientContext,
    IN  PVOID                   Unused2,
    IN  tDEVICECONTEXT          *Unused3
    )
/*++
Routine Description:

    This Routine stops a timer.
    This function has to be called after ensuring that the TimerExpiry has not
    yet cleaned up (while holding the NbtConfig.Resource)
    The NbtConfig.Resource has to be held while this routine is called

Arguments:

    Timer       - Timer structure

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/
{
    NTSTATUS        Status;
    BOOLEAN         CurrentState = FALSE;
    BOOLEAN         fAttached = FALSE;
    tTIMERQENTRY    *pTimerEntry = (tTIMERQENTRY *) pClientContext;

    CTEPagedCode();

    ASSERT (pTimerEntry->fIsWakeupTimer);

    CTEAttachFsp(&fAttached, REF_FSP_STOP_WAKEUP_TIMER);
    Status = ZwCancelTimer (pTimerEntry->WakeupTimerHandle, &CurrentState);
    ZwClose (pTimerEntry->WakeupTimerHandle);
    CTEDetachFsp(fAttached, REF_FSP_STOP_WAKEUP_TIMER);

    ReturnTimerToFreeQ (pTimerEntry, FALSE);

    return;
}


//----------------------------------------------------------------------------
VOID
DelayedNbtStartWakeupTimer(
    IN  tDGRAM_SEND_TRACKING    *pUnused1,
    IN  PVOID                   Unused2,
    IN  PVOID                   Unused3,
    IN  tDEVICECONTEXT          *Unused4
    )
/*++

Routine Description:

    This routine starts a Wakeup timer.
    NbtConfig.Resource may be held on entry into this routine!

Arguments:

    The value passed in is in milliseconds - must be converted to 100ns
    so multiply to 10,000
Return Value:

    The function value is the status of the operation.


--*/
{
    NTSTATUS            Status = STATUS_UNSUCCESSFUL;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    BOOLEAN             fAttached = FALSE;
    LARGE_INTEGER       Time;
    tTIMERQENTRY        *pTimerEntry;
    CTELockHandle       OldIrq;
    ULONG               TimerInterval = 0;
    ULONG               MilliSecsLeftInTtl = 0;
    LIST_ENTRY          *pEntry;
    LIST_ENTRY          *pHead;
    tDEVICECONTEXT      *pDeviceContext;
    BOOLEAN             fValidDevice = FALSE;

    CTEAttachFsp(&fAttached, REF_FSP_START_WAKEUP_TIMER);
    CTEExAcquireResourceExclusive(&NbtConfig.Resource,TRUE);
    CTESpinLock(&NbtConfig.JointLock,OldIrq);

    ASSERT (!NbtConfig.pWakeupRefreshTimer);

    //  
    // Verify that at least 1 WOL-enabled device has an Ip + Wins address!
    //
    pHead = pEntry = &NbtConfig.DeviceContexts;
    while ((pEntry = pEntry->Flink) != pHead)
    {
        pDeviceContext = CONTAINING_RECORD (pEntry,tDEVICECONTEXT,Linkage);
        if ((pDeviceContext->WOLProperties & NDIS_DEVICE_WAKE_UP_ENABLE) &&
            (pDeviceContext->IpAddress) &&
            (pDeviceContext->lNameServerAddress != LOOP_BACK))
        {
            fValidDevice = TRUE;
            break;
        }
    }

    if ((NbtConfig.Unloading) ||                                    // Problem!!!
        (!fValidDevice) ||                                          // No valid device ?
        !(NbtConfig.GlobalRefreshState & NBT_G_REFRESH_SLEEPING))   // check if request was cancelled!
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        KdPrint (("Nbt.NbtStartWakeupTimer: FAIL: Either: Unloading=<%x>, fValidDevice=<%x>, RefreshState=<%x>\n",
            NbtConfig.Unloading, fValidDevice, NbtConfig.GlobalRefreshState));
    }
    else if (!NT_SUCCESS (Status = GetTimerEntry (&pTimerEntry)))    // get a free timer block
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        KdPrint (("Nbt.NbtStartWakeupTimer: ERROR: GetTimerEntry returned <%x>\n", Status));
    }
    else
    {
        pTimerEntry->RefCount = 1;
        pTimerEntry->TimeoutRoutine = WakeupRefreshTimeout;
        pTimerEntry->Context = NULL;
        pTimerEntry->Context2 = NULL;

        CTESpinFree(&NbtConfig.JointLock,OldIrq);

#ifdef HDL_FIX
        InitializeObjectAttributes (&ObjectAttributes, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);
#else
        InitializeObjectAttributes (&ObjectAttributes, NULL, 0, NULL, NULL);
#endif  // HDL_FIX
        Status = ZwCreateTimer (&pTimerEntry->WakeupTimerHandle,
                                TIMER_ALL_ACCESS,
                                &ObjectAttributes,
                                NotificationTimer);

        if (NT_SUCCESS (Status))
        {
            //
            // Set the machine to Wakeup at 1/2 the time between now and Ttl
            // This should not be less than the configured MinimumRefreshSleepTimeout
            // (default = 6 hrs)
            //
            MilliSecsLeftInTtl = NbtConfig.MinimumTtl
                                 - (ULONG) (((ULONGLONG) NbtConfig.sTimeoutCount * NbtConfig.MinimumTtl)
                                            / NbtConfig.RefreshDivisor);

            if ((MilliSecsLeftInTtl/2) < NbtConfig.MinimumRefreshSleepTimeout)
            {
                TimerInterval = NbtConfig.MinimumRefreshSleepTimeout;
            }
            else
            {
                TimerInterval = MilliSecsLeftInTtl/2;
            }
            pTimerEntry->DeltaTime = TimerInterval;

            IF_DBG(NBT_DEBUG_PNP_POWER)
                KdPrint(("Nbt.DelayedNbtStartWakeupTimer: TimerInterval=<%d:%d> (h:m), Currently: <%d/%d>\n",
                    TimerInterval/(3600000), ((TimerInterval/60000)%60),
                    NbtConfig.sTimeoutCount, NbtConfig.RefreshDivisor));

            //
            // convert to 100 ns units by multiplying by 10,000
            //
            Time.QuadPart = UInt32x32To64(pTimerEntry->DeltaTime,(LONG)MILLISEC_TO_100NS);
            Time.QuadPart = -(Time.QuadPart);   // to make a delta time, negate the time
            pTimerEntry->fIsWakeupTimer = TRUE;
            ASSERT(Time.QuadPart < 0);
    
            Status = ZwSetTimer(pTimerEntry->WakeupTimerHandle,
                                &Time,
                                (PTIMER_APC_ROUTINE) WakeupTimerExpiry,
                                pTimerEntry,
                                TRUE,
                                0,
                                NULL);
    
            if (!NT_SUCCESS (Status))
            {
                KdPrint (("Nbt.NbtStartWakeupTimer: ERROR: ZwSetTimer returned <%x>, TimerHandle=<%x>\n",
                    Status, pTimerEntry->WakeupTimerHandle));
                ZwClose (pTimerEntry->WakeupTimerHandle);
            }
        }
        else
        {
            KdPrint (("Nbt.NbtStartWakeupTimer: ERROR: ZwCreateTimer returned <%x>\n", Status));
        }

        if (NT_SUCCESS (Status))
        {
            NbtConfig.pWakeupRefreshTimer = pTimerEntry;
        }
        else
        {
            ReturnTimerToFreeQ (pTimerEntry, FALSE);
        }
    }

    CTEExReleaseResource(&NbtConfig.Resource);
    CTEDetachFsp(fAttached, REF_FSP_START_WAKEUP_TIMER);

    KeSetEvent (&NbtConfig.WakeupTimerStartedEvent, 0, FALSE);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\ctestuff.c ===
//
//
//  CTESTUFF.C
//
//  This file contains Common Transport Environment code to handle
//  OS dependent functions such as allocating memory etc.
//
//
#include "precomp.h"

// to convert a millisecond to a 100ns time
//
#define MILLISEC_TO_100NS   10000


//----------------------------------------------------------------------------
PVOID
CTEStartTimer(
    IN  CTETimer        *pTimerIn,
    IN  ULONG           DeltaTime,
    IN  CTEEventRtn     TimerExpiry,
    IN  PVOID           Context OPTIONAL
        )
/*++
Routine Description:

    This Routine starts a timer.

Arguments:

    Timer       - Timer structure
    TimerExpiry - completion routine

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

{
    LARGE_INTEGER   Time;

    //
    // initialize the DPC to have the correct completion routine and context
    //
    KeInitializeDpc(&pTimerIn->t_dpc,
                    (PVOID)TimerExpiry,     // completion routine
                    Context);               // context value

    //
    // convert to 100 ns units by multiplying by 10,000
    //
    Time.QuadPart = UInt32x32To64(DeltaTime,(LONG)MILLISEC_TO_100NS);

    //
    // to make a delta time, negate the time
    //
    Time.QuadPart = -(Time.QuadPart);

    ASSERT(Time.QuadPart < 0);

    (VOID)KeSetTimer(&pTimerIn->t_timer,Time,&pTimerIn->t_dpc);

    return(NULL);
}
//----------------------------------------------------------------------------
VOID
CTEInitTimer(
    IN  CTETimer        *pTimerIn
        )
/*++
Routine Description:

    This Routine initializes a timer.

Arguments:

    Timer       - Timer structure
    TimerExpiry - completion routine

Return Value:

    PVOID - a pointer to the memory or NULL if a failure

--*/

{
    KeInitializeTimer(&pTimerIn->t_timer);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\fileio.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fileio.c

Abstract:

    This source implements a stdio-like facility.

Author:

    Jim Stewart     June 1993

Revision History:

--*/

#include "precomp.h"
#include "hosts.h"
#include <string.h>


//
// Private Definitions
//



//
// Local Variables
//



//
// Local (Private) Functions
//
PUCHAR
LmpMapFile (
    IN HANDLE handle,
    IN OUT int *pnbytes
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(PAGE, LmCloseFile)
#pragma CTEMakePageable(PAGE, LmFgets)
#pragma CTEMakePageable(PAGE, LmpMapFile)
#pragma CTEMakePageable(PAGE, LmOpenFile)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------

NTSTATUS
LmCloseFile (
    IN PLM_FILE pfile
    )

/*++

Routine Description:

    This function closes a file opened via LmOpenFile(), and frees its
    LM_FILE object.

Arguments:

    pfile  -  pointer to the LM_FILE object

Return Value:

    An NTSTATUS value.

--*/


{
    NTSTATUS status;

    CTEPagedCode();
    CTEMemFree(pfile->f_buffer);

    status = ZwClose(pfile->f_handle);

    ASSERT(status == STATUS_SUCCESS);

    CTEMemFree(pfile);

    return(status);

} // LmCloseFile



//----------------------------------------------------------------------------

PUCHAR
LmFgets (
    IN PLM_FILE pfile,
    OUT int *nbytes
    )

/*++

Routine Description:

    This function is vaguely similar to fgets(3).

    Starting at the current seek position, it reads through a newline
    character, or the end of the file. If a newline is encountered, it
    is replaced with a NULL character.

Arguments:

    pfile   -  file to read from
    nbytes  -  the number of characters read, excluding the NULL character

Return Value:

    A pointer to the beginning of the line, or NULL if we are at or past
    the end of the file.

--*/


{
    PUCHAR endOfLine;
    PUCHAR startOfLine;
    size_t maxBytes;

    CTEPagedCode();
    startOfLine = pfile->f_current;

    if (startOfLine >= pfile->f_limit)
    {

        return((PUCHAR) NULL);
    }

    maxBytes  = (size_t)(pfile->f_limit - pfile->f_current);
    endOfLine = (PUCHAR) memchr(startOfLine, (UCHAR) '\n', maxBytes);

    if (!endOfLine)
    {
        IF_DBG(NBT_DEBUG_LMHOST)
        KdPrint(("NBT: lmhosts file doesn't end in '\\n'"));
        endOfLine = pfile->f_limit;
    }

    *endOfLine = (UCHAR) NULL;

    pfile->f_current = endOfLine + 1;
    (pfile->f_lineno)++;
    ASSERT(pfile->f_current <= pfile->f_limit+1);

    *nbytes = (int)(endOfLine - startOfLine);

    return(startOfLine);

} // LmFgets



//----------------------------------------------------------------------------

PUCHAR
LmpMapFile (
    IN HANDLE handle,
    IN OUT int *pnbytes
    )

/*++

Routine Description:

    This function reads an entire file into memory.

Arguments:

    handle  -  file handle
    pnbytes -  size of the whole file


Return Value:

    the buffer allocated, or NULL if unsuccessful.

--*/


{
    PUCHAR                     buffer;
    NTSTATUS                   status;
    IO_STATUS_BLOCK            iostatus;
    FILE_STANDARD_INFORMATION  stdInfo;
    LARGE_INTEGER offset ={0, 0};
    LARGE_INTEGER length ={0x7fffffff, 0x7fffffff};

    CTEPagedCode();


    status = ZwQueryInformationFile(
                handle,                         // FileHandle
                &iostatus,                      // IoStatusBlock
                (PVOID) &stdInfo,               // FileInformation
                sizeof(stdInfo),                // Length
                FileStandardInformation);       // FileInformationClass

    if (status != STATUS_SUCCESS)
    {
        IF_DBG(NBT_DEBUG_LMHOST)
        KdPrint(("NBT: ZwQueryInformationFile(std) = %X\n", status));
        return(NULL);
    }

    length = stdInfo.EndOfFile;                 // structure copy

    if (length.HighPart)
    {
        return(NULL);
    }

    buffer = NbtAllocMem (length.LowPart+2, NBT_TAG2('18'));

    if (buffer != NULL)
    {

        status = ZwReadFile(
                    handle,                         // FileHandle
                    NULL,                           // Event
                    NULL,                           // ApcRoutine
                    NULL,                           // ApcContext
                    &iostatus,                      // IoStatusBlock
                    buffer,                         // Buffer
                    length.LowPart,                 // Length
                    &offset,                        // ByteOffset
                    NULL);                          // Key

        if (status != STATUS_SUCCESS)
        {
            IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint(("NBT: ZwReadFile(std) = %X\n", status));
        }

        ASSERT(status != STATUS_PENDING);

        if (iostatus.Status != STATUS_SUCCESS || status != STATUS_SUCCESS)
        {
            CTEMemFree(buffer);
            return(NULL);
        }

        *pnbytes = length.LowPart;
    }
    return(buffer);

} // LmpMapFile



//----------------------------------------------------------------------------

PLM_FILE
LmOpenFile (
    IN PUCHAR path
    )

/*++

Routine Description:

    This function opens a file for use by LmFgets().

Arguments:

    path    -  a fully specified, complete path to the file.

Return Value:

    A pointer to an LM_FILE object, or NULL if unsuccessful.

--*/


{
    NTSTATUS                   status;
    HANDLE                     handle;
    PLM_FILE                   pfile;
    IO_STATUS_BLOCK            iostatus;
    OBJECT_ATTRIBUTES          attributes;
    UNICODE_STRING             ucPath;
    PUCHAR                     start;
    int                        nbytes;
    OEM_STRING                 String;
    PUCHAR                     LongerPath;


    CTEPagedCode();
    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    status = LmGetFullPath(path,&LongerPath);

    if (NT_SUCCESS(status))
    {
        RtlInitString(&String,LongerPath);

        status = RtlAnsiStringToUnicodeString(&ucPath,&String,TRUE);

        if (NT_SUCCESS(status))
        {

#ifdef HDL_FIX
            InitializeObjectAttributes (&attributes,                                // POBJECT_ATTRIBUTES
                                        &ucPath,                                    // ObjectName
                                        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // Attributes
                                        (HANDLE) NULL,                              // RootDirectory
                                        (PSECURITY_DESCRIPTOR) NULL);               // SecurityDescriptor
#else
            InitializeObjectAttributes (&attributes,                                // POBJECT_ATTRIBUTES
                                        &ucPath,                                    // ObjectName
                                        OBJ_CASE_INSENSITIVE,                       // Attributes
                                        (HANDLE) NULL,                              // RootDirectory
                                        (PSECURITY_DESCRIPTOR) NULL);               // SecurityDescriptor
#endif  // HDL_FIX

            status = ZwCreateFile (&handle,                            // FileHandle
                                   SYNCHRONIZE | FILE_READ_DATA,       // DesiredAccess
                                   &attributes,                        // ObjectAttributes
                                   &iostatus,                          // IoStatusBlock
                                   0,                                  // AllocationSize
                                   FILE_ATTRIBUTE_NORMAL,              // FileAttributes
                                   FILE_SHARE_READ | FILE_SHARE_WRITE, // ShareAccess
                                   FILE_OPEN,                          // CreateDisposition
                                   FILE_SYNCHRONOUS_IO_NONALERT,       // OpenOptions
                                   NULL,                               // EaBuffer
                                   0);                                 // EaLength

            if (NT_SUCCESS(status))
            {
                start = LmpMapFile(handle, &nbytes);

                if (start)
                {
                    pfile = (PLM_FILE) NbtAllocMem (sizeof(LM_FILE), NBT_TAG2('19'));
                    if (pfile)
                    {
                        KeInitializeSpinLock(&(pfile->f_lock));

                        pfile->f_refcount            = 1;
                        pfile->f_handle              = handle;
                        pfile->f_lineno              = 0;
                        pfile->f_fileOffset.HighPart = 0;
                        pfile->f_fileOffset.LowPart  = 0;

                        pfile->f_current = start;
                        pfile->f_buffer  = start;
                        pfile->f_limit   = pfile->f_buffer + nbytes;

                        RtlFreeUnicodeString(&ucPath);
                        CTEMemFree(LongerPath);

                        return(pfile);
                    }

                    CTEMemFree(start);
                }

                ZwClose(handle);
            }

            RtlFreeUnicodeString(&ucPath);

            IF_DBG(NBT_DEBUG_LMHOST)
            KdPrint(("Nbt.LmOpenFile: ZwOpenFile(std) = %X\n", status));

        }

        CTEMemFree(LongerPath);
    }

    return((PLM_FILE) NULL);

} // LmOpenFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\netbt\sys\nt\driver.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    Driver.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the
    NBT Transport and other routines that are specific to the NT implementation
    of a driver.

Author:

    Jim Stewart (Jimst)    10-2-92

Revision History:

--*/


#include "precomp.h"
#include <nbtioctl.h>

#include "driver.tmh"

#if DBG
// allocate storage for the global debug flag NbtDebug
//ULONG   NbtDebug = NBT_DEBUG_KDPRINTS| NBT_DEBUG_NETBIOS_EX;
ULONG   NbtDebug = 0;
#endif // DBG

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
NbtDispatchCleanup(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    );

NTSTATUS
NbtDispatchClose(
    IN PDEVICE_OBJECT   device,
    IN PIRP             pIrp
    );

NTSTATUS
NbtDispatchCreate(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    );

NTSTATUS
NbtDispatchDevCtrl(
    IN PDEVICE_OBJECT   device,
    IN PIRP             pIrp
    );

NTSTATUS
NbtDispatchInternalCtrl(
    IN PDEVICE_OBJECT   device,
    IN PIRP             pIrp
    );

#ifdef _PNP_POWER_
VOID
NbtUnload(
    IN PDRIVER_OBJECT   device
    );
#endif  // _PNP_POWER_

NTSTATUS
NbtDispatchPnP(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    );

PFILE_FULL_EA_INFORMATION
FindInEA(
    IN PFILE_FULL_EA_INFORMATION    start,
    IN PCHAR                        wanted
    );

VOID
ReturnIrp(
    IN PIRP     pIrp,
    IN int      status
    );

VOID
MakePending(
    IN PIRP     pIrp
    );

NTSTATUS
NbtCreateAdminSecurityDescriptor(
    IN PDEVICE_OBJECT dev
    );

#ifdef _PNP_POWER_DBG_
//
//Debug Stuff for DbgBreakPoint -- REMOVE
//
NTSTATUS
NbtOpenRegistry(
    IN HANDLE       NbConfigHandle,
    IN PWSTR        String,
    OUT PHANDLE     pHandle
    );
#endif  // _PNP_POWER_DBG_

#ifdef _PNP_POWER_
HANDLE      TdiClientHandle     = NULL;
HANDLE      TdiProviderHandle   = NULL;
extern      tTIMERQ TimerQ;
#endif  // _PNP_POWER_

#ifdef _NETBIOSLESS
tDEVICECONTEXT       *pNbtSmbDevice = NULL;
BOOL                gbDestroyingSmbDevice = FALSE;
DWORD               gdwPendingEnableDisableSmbDevice = FALSE;
#endif  // _NETBIOSLESS

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma CTEMakePageable(INIT, DriverEntry)
#pragma CTEMakePageable(PAGE, NbtDispatchCleanup)
#pragma CTEMakePageable(PAGE, NbtDispatchClose)
#pragma CTEMakePageable(PAGE, NbtDispatchCreate)
#pragma CTEMakePageable(PAGE, NbtDispatchDevCtrl)
#pragma CTEMakePageable(PAGE, FindInEA)
#pragma CTEMakePageable(PAGE, NbtUnload)
#endif
//*******************  Pageable Routine Declarations ****************

//----------------------------------------------------------------------------
VOID
CleanupDriverEntry(
    ULONG   CleanupStage
    )
{
    PSINGLE_LIST_ENTRY      pSingleListEntry;
    PMDL                    pMdl;
    PVOID                   pBuffer;
    LIST_ENTRY              *pListEntry;
    tDGRAM_SEND_TRACKING    *pTracker;

    switch (CleanupStage)
    {
        case (6):
            NbtDestroyDevice (pWinsDeviceContext, FALSE);

#ifdef RASAUTODIAL
            //
            // Unbind fron the RAS driver if we were bound
            //
            NbtAcdUnbind ();
#endif  // RASAUTODIAL

            // Fall through

        case (5):
            if (pNbtSmbDevice)
            {
                NbtDestroyDevice (pNbtSmbDevice, FALSE);
                pNbtSmbDevice = NULL;
            }

            if (NbtConfig.OutOfRsrc.pDpc)
            {
                CTEMemFree (NbtConfig.OutOfRsrc.pDpc);
            }
            if (NbtConfig.OutOfRsrc.pIrp)
            {
                IoFreeIrp (NbtConfig.OutOfRsrc.pIrp);
            }

            // Fall through

        case (4):
            while (NbtConfig.SessionMdlFreeSingleList.Next)
            {
                pSingleListEntry = PopEntryList(&NbtConfig.SessionMdlFreeSingleList);
                pMdl = CONTAINING_RECORD(pSingleListEntry,MDL,Next);
                pBuffer = MmGetMdlVirtualAddress (pMdl);
                CTEMemFree (pBuffer);
                IoFreeMdl (pMdl);
            }

            // Fall through

        case (3):
            //
            // InitNotOs has been called
            //

            DestroyTimerQ();

            while (!IsListEmpty(&NbtConfig.DgramTrackerFreeQ))
            {
                pListEntry = RemoveHeadList(&NbtConfig.DgramTrackerFreeQ);
                pTracker = CONTAINING_RECORD(pListEntry,tDGRAM_SEND_TRACKING,Linkage);
                CTEMemFree (pTracker);
            }

            DestroyHashTables ();
            ExDeleteResourceLite (&NbtConfig.Resource);  // Delete the resource

            // Fall through

        case (2):
            //
            // Read registry has been called!
            //
            if (NbtConfig.pLmHosts) {
                CTEMemFree (NbtConfig.pLmHosts);
            }

            if (NbtConfig.pScope) {
                CTEMemFree (NbtConfig.pScope);
            }

            if (NbtConfig.pTcpBindName)
            {
                CTEMemFree (NbtConfig.pTcpBindName);
            }

            // Fall through

        case (1):
            CTEMemFree (NbtConfig.pRegistry.Buffer);

        default:
            break;
    }
}

//----------------------------------------------------------------------------
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the NBT device driver.
    This routine creates the device object for the NBT
    device and calls a routine to perform other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS            status;
    tDEVICES            *pBindDevices=NULL;
    tDEVICES            *pExportDevices=NULL;
    tADDRARRAY          *pAddrArray=NULL;
    PMDL                pMdl;
    PSINGLE_LIST_ENTRY  pSingleListEntry;

    UNICODE_STRING      ucWinsDeviceBindName;
    UNICODE_STRING      ucWinsDeviceExportName;
    UNICODE_STRING      ucSmbDeviceBindName;
    UNICODE_STRING      ucSmbDeviceExportName;
    UNICODE_STRING      ucNetBTClientName;
    UNICODE_STRING      ucNetBTProviderName;

    TDI_CLIENT_INTERFACE_INFO   TdiClientInterface;

#ifdef _PNP_POWER_DBG_
    //
    //Debug Stuff for DbgBreakPoint
    //
    OBJECT_ATTRIBUTES   TmpObjectAttributes;
    HANDLE              NbtConfigHandle;
    ULONG               Disposition;
    PWSTR               ParametersString = L"Parameters";
    HANDLE              ParametersHandle;
#endif  // _PNP_POWER_DBG_

    CTEPagedCode();

#ifdef _NBT_WMI_SOFTWARE_TRACING_
	WPP_INIT_TRACING(DriverObject, RegistryPath);
#endif

#ifdef _PNP_POWER_DBG_
    InitializeObjectAttributes (&TmpObjectAttributes,
                                RegistryPath,               // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
                                NULL,                       // root
                                NULL);                      // security descriptor

    status = ZwCreateKey (&NbtConfigHandle,
                          KEY_READ,
                          &TmpObjectAttributes,
                          0,                 // title index
                          NULL,              // class
                          0,                 // create options
                          &Disposition);     // disposition

    if (!NT_SUCCESS(status))
    {
        NbtLogEvent (EVENT_NBT_CREATE_DRIVER, status, 0x109);
        return STATUS_UNSUCCESSFUL;
    }

    status = NbtOpenRegistry (NbtConfigHandle, ParametersString, &ParametersHandle);
    if (!NT_SUCCESS(status))
    {
        ZwClose(NbtConfigHandle);
        return (status);
    }

    if (CTEReadSingleIntParameter(ParametersHandle, ANSI_IF_VXD("Break"), 0, 0))  // disabled by default
    {
        KdPrint (("Nbt.DriverEntry: Registry-set Break!\n"));
        DbgBreakPoint();
    }

    ZwClose(ParametersHandle);
    ZwClose(NbtConfigHandle);
#endif  // _PNP_POWER_DBG_

    TdiInitialize();

    //
    // get the file system process for NBT since we need to know this for
    // allocating and freeing handles
    //
    NbtFspProcess =(PEPROCESS)PsGetCurrentProcess();

    //
    // Initialize the Configuration data structure
    //
    CTEZeroMemory(&NbtConfig,sizeof(tNBTCONFIG));

    NbtConfig.LoopbackIfContext = 0xffff;

    // save the driver object for event logging purposes
    //
    NbtConfig.DriverObject = DriverObject;

    // save the registry path for later use when DHCP asks us
    // to re-read the registry.
    //
    NbtConfig.pRegistry.MaximumLength = (USHORT) RegistryPath->MaximumLength;
    if (NbtConfig.pRegistry.Buffer = NbtAllocMem (RegistryPath->MaximumLength, NBT_TAG2('17')))
    {
        RtlCopyUnicodeString(&NbtConfig.pRegistry,RegistryPath);
    }
    else
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]                  = (PDRIVER_DISPATCH)NbtDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = (PDRIVER_DISPATCH)NbtDispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = (PDRIVER_DISPATCH)NbtDispatchInternalCtrl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 = (PDRIVER_DISPATCH)NbtDispatchCleanup;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = (PDRIVER_DISPATCH)NbtDispatchClose;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = (PDRIVER_DISPATCH)NbtDispatchPnP;
    DriverObject->DriverUnload                                  = NbtUnload;

    //
    // read in registry configuration data
    //
    status = NbtReadRegistry (&pBindDevices, &pExportDevices, &pAddrArray);
    if (!NT_SUCCESS(status))
    {
        //
        // There must have been some major problems with the registry, so
        // we will not load!
        //
        DbgPrint ("Nbt.DriverEntry[1]: Not loading because of failure to read registry = <%x>\n", status);

        CleanupDriverEntry (1);
        return(status);
    }

    //
    // Cleanup Allocated memory
    //
    NbtReadRegistryCleanup (&pBindDevices, &pExportDevices, &pAddrArray);

    //
    // Initialize NBT global data.
    //
    status = InitNotOs();
    if (!NT_SUCCESS(status))
    {
        NbtLogEvent (EVENT_NBT_NON_OS_INIT, status, 0x110);

        DbgPrint ("Nbt.DriverEntry[3]: Not loading because of failure to Initialize = <%x>\n",status);
        CleanupDriverEntry (3);     // We may have done some partial initialization!
        return (status);
    }

    // create some MDLs, for session sends to speed up the sends.
    status = NbtInitMdlQ (&NbtConfig.SessionMdlFreeSingleList, eNBT_FREE_SESSION_MDLS);
    if (!NT_SUCCESS(status))
    {
        DbgPrint ("Nbt.DriverEntry[4]: Not loading because of failure to init Session MDL Q = <%x>\n",status);
        CleanupDriverEntry (4);
        return (status);
    }

    //---------------------------------------------------------------------------------------
    //
    // Create the SmbDevice object for Rdr/Srv
    //
    if ((NbtConfig.SMBDeviceEnabled) &&
        (!(pNbtSmbDevice = NbtCreateSmbDevice())))
    {
        KdPrint (("Nbt.DriverEntry: Failed to create SmbDevice!\n"));
        //
        // Allow the initialization to succeed even if this fails!
        //
    }

    //---------------------------------------------------------------------------------------

    //
    // Create the NBT device object for WINS to use
    //
    RtlInitUnicodeString (&ucWinsDeviceBindName, WC_WINS_DEVICE_BIND_NAME);
    ucWinsDeviceBindName.MaximumLength = sizeof (WC_WINS_DEVICE_BIND_NAME);
    RtlInitUnicodeString (&ucWinsDeviceExportName, WC_WINS_DEVICE_EXPORT_NAME);
    ucWinsDeviceExportName.MaximumLength = sizeof (WC_WINS_DEVICE_EXPORT_NAME);

    //
    // Try to export a DeviceObject for Wins, but do not add it to the list
    // of devices which we notify TDI about
    // Do not care about status because we want to continue even if we fail
    //
    status = NbtAllocAndInitDevice (&ucWinsDeviceBindName,
                                    &ucWinsDeviceExportName,
                                    &pWinsDeviceContext,
                                    NBT_DEVICE_WINS);

    if (!NT_SUCCESS(status))
    {
        DbgPrint ("Nbt.DriverEntry[5]: Not loading because of failure to create pWinsDevContext = <%x>\n",
            status);
        CleanupDriverEntry (5);
        return (status);
    }
    status = NbtCreateAdminSecurityDescriptor(&pWinsDeviceContext->DeviceObject);
    ASSERT(NT_SUCCESS(status));

    pWinsDeviceContext->IpAddress = 0;
    pWinsDeviceContext->DeviceRegistrationHandle = NULL;
    pWinsDeviceContext->NetAddressRegistrationHandle = NULL;
    pWinsDeviceContext->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;

    //---------------------------------------------------------------------------------------

#ifdef RASAUTODIAL
    //
    // Get the automatic connection driver
    // entry points.
    //
    NbtAcdBind();
#endif

    //---------------------------------------------------------------------------------------

    //
    // Register ourselves as a Provider with Tdi
    //
    RtlInitUnicodeString(&ucNetBTProviderName, WC_NETBT_PROVIDER_NAME);
    ucNetBTProviderName.MaximumLength = sizeof (WC_NETBT_PROVIDER_NAME);
    status = TdiRegisterProvider (&ucNetBTProviderName, &TdiProviderHandle);
    if (NT_SUCCESS (status))
    {
        //
        // Register our Handlers with TDI
        //
        RtlInitUnicodeString(&ucNetBTClientName, WC_NETBT_CLIENT_NAME);
        ucNetBTClientName.MaximumLength = sizeof (WC_NETBT_CLIENT_NAME);
        RtlZeroMemory(&TdiClientInterface, sizeof(TdiClientInterface));

        TdiClientInterface.MajorTdiVersion      = MAJOR_TDI_VERSION;
        TdiClientInterface.MinorTdiVersion      = MINOR_TDI_VERSION;
        TdiClientInterface.ClientName           = &ucNetBTClientName;
        TdiClientInterface.AddAddressHandlerV2  = TdiAddressArrival;
        TdiClientInterface.DelAddressHandlerV2  = TdiAddressDeletion;
        TdiClientInterface.BindingHandler       = TdiBindHandler;
        TdiClientInterface.PnPPowerHandler      = TdiPnPPowerHandler;

        status = TdiRegisterPnPHandlers (&TdiClientInterface, sizeof(TdiClientInterface), &TdiClientHandle);
        if (!NT_SUCCESS (status))
        {
            TdiDeregisterProvider (TdiProviderHandle);
            TdiProviderHandle = NULL;
        }
    }
    else
    {
        TdiProviderHandle = NULL;
    }

    if (!NT_SUCCESS (status))
    {
        DbgPrint ("Nbt.DriverEntry[6]: Not loading because of error = <%x>\n", status);
        CleanupDriverEntry (6);
    }

    //
    // Return to the caller.
    //
    return (status);
}

//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchCleanup(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the NBT driver's dispatch function for IRP_MJ_CLEANUP
    requests.

    This function is called when the last reference to the handle is closed.
    Hence, an NtClose() results in an IRP_MJ_CLEANUP first, and then an
    IRP_MJ_CLOSE.  This function runs down all activity on the object, and
    when the close comes in the object is actually deleted.

Arguments:

    device    - ptr to device object for target device
    pIrp       - ptr to I/O request packet

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS            status;
    PIO_STACK_LOCATION  pIrpSp;
    tDEVICECONTEXT   *pDeviceContext;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ASSERT(pIrpSp->MajorFunction == IRP_MJ_CLEANUP);

    pDeviceContext = (tDEVICECONTEXT *)Device;
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchCleanup: Short-Ckt request --Device=<%x>, Context=<%x>, Context2=<%x>\n",
                pDeviceContext, pIrpSp->FileObject->FsContext, pIrpSp->FileObject->FsContext2));

        status = STATUS_SUCCESS;

        pIrp->IoStatus.Status = status;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (status);
    }

    // look at the context value that NBT put into the FSContext2 value to
    // decide what to do
    switch ((USHORT)pIrpSp->FileObject->FsContext2)
    {
        case NBT_ADDRESS_TYPE:
            // the client is closing the address file, so we must cleanup
            // and memory blocks associated with it.
            status = NTCleanUpAddress(pDeviceContext,pIrp);
            ASSERT (STATUS_PENDING!=status);
            break;

        case NBT_CONNECTION_TYPE:
            // the client is closing a connection, so we must clean up any
            // memory blocks associated with it.
            status = NTCleanUpConnection(pDeviceContext,pIrp);
            ASSERT (STATUS_PENDING!=status);
            break;

        case NBT_WINS_TYPE:
            //
            // This is synchronous with the Wins NtClose operation
            //
            status = NTCleanUpWinsAddr (pDeviceContext, pIrp);
            ASSERT (STATUS_PENDING!=status);
            break;

        case NBT_CONTROL_TYPE:
            // there is nothing to do here....
            status = STATUS_SUCCESS;
            break;

        default:
            /*
             * complete the i/o successfully.
             */
            status = STATUS_SUCCESS;
            break;
    }

    //
    // Complete the Irp
    //
    if (status == STATUS_PENDING) {
        ASSERT (0);
        status = STATUS_SUCCESS;
    }
    ReturnIrp(pIrp, status);

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
    return(status);
} // DispatchCleanup


//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchClose(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the NBT driver's dispatch function for IRP_MJ_CLOSE
    requests.  This is called after Cleanup (above) is called.

Arguments:

    device  - ptr to device object for target device
    pIrp     - ptr to I/O request packet

Return Value:

    an NT status code.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION pIrpSp;
    tDEVICECONTEXT   *pDeviceContext;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ASSERT(pIrpSp->MajorFunction == IRP_MJ_CLOSE);

    pDeviceContext = (tDEVICECONTEXT *)Device;
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchClose: Short-Ckt request -- Device=<%x>, Context=<%x>, Context2=<%x>\n",
                pDeviceContext, pIrpSp->FileObject->FsContext, pIrpSp->FileObject->FsContext2));

        status = STATUS_SUCCESS;

        pIrp->IoStatus.Status = status;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (status);
    }

    //
    // close operations are synchronous.
    //
    pIrp->IoStatus.Status      = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;

    switch (PtrToUlong(pIrpSp->FileObject->FsContext2))
        {
        case NBT_ADDRESS_TYPE:
            status = NTCloseAddress(pDeviceContext,pIrp);
            break;

        case NBT_CONNECTION_TYPE:
            status = NTCloseConnection(pDeviceContext,pIrp);
            break;

        case NBT_WINS_TYPE:
            //
            // We don't need to set the DeviceContext here since we had
            // already saved it in pWinsInfo
            // This is an Asynchronous operation wrt the Wins server, hence
            // we should do only minimal work in this routine -- the
            // major cleanup should be in the DispatchCleanup routine
            //
            status = NTCloseWinsAddr(pDeviceContext,pIrp);
            break;

        case NBT_CONTROL_TYPE:
            // the client is closing the Control Object...
            // there is nothing to do here....
            status = STATUS_SUCCESS;
            break;

        default:
            KdPrint(("Nbt:Close Received for unknown object type = %X\n",
                                         pIrpSp->FileObject->FsContext2));
            status = STATUS_SUCCESS;
            break;
        }

    // NTCloseAddress can return Pending until the ref count actually gets
    // to zero.
    //
    if (status != STATUS_PENDING)
    {
        ReturnIrp(pIrp, status);
    }

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
    return(status);
} // DispatchClose


//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchCreate(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the NBT driver's dispatch function for IRP_MJ_CREATE
    requests.  It is called as a consequence of one of the following:

        a. TdiOpenConnection("\Device\Nbt_Elnkii0"),
        b. TdiOpenAddress("\Device\Nbt_Elnkii0"),

Arguments:

    Device - ptr to device object being opened
    pIrp    - ptr to I/O request packet
    pIrp->Status => return status
    pIrp->MajorFunction => IRP_MD_CREATE
    pIrp->MinorFunction => not used
    pIpr->FileObject    => ptr to file obj created by I/O system. NBT fills in FsContext
    pIrp->AssociatedIrp.SystemBuffer => ptr to EA buffer with address of obj to open(Netbios Name)
    pIrp->Parameters.Create.EaLength => length of buffer specifying the Xport Addr.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING

--*/

{
    NTSTATUS                    status;
    PIO_STACK_LOCATION          pIrpSp;
    PFILE_FULL_EA_INFORMATION   ea, eabuf;
    tDEVICECONTEXT              *pDeviceContext;
    UCHAR                       IrpFlags;
    tIPADDRESS UNALIGNED        *pIpAddressU;
    tIPADDRESS                  IpAddress;

    CTEPagedCode();

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ASSERT(pIrpSp->MajorFunction == IRP_MJ_CREATE);

    //
    // If this device was destroyed, then reject all opens on it.
    // Ideally we would like the IO sub-system to guarantee that no
    // requests come down on IoDeleted devices, but.....
    //
    pDeviceContext = (tDEVICECONTEXT *)Device;
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchCreate: Short-Ckt request -- Device=<%x>, CtrlCode=<%x>\n",
                pDeviceContext, pIrpSp->Parameters.DeviceIoControl.IoControlCode));
        pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (STATUS_INVALID_DEVICE_STATE);
    }

    IrpFlags = pIrpSp->Control;

    //
    // set the pending flag here so that it is sure to be set BEFORE the
    // completion routine gets hit.
    //
    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pIrp);

    /*
     * was this a TdiOpenConnection() or TdiOpenAddress()?
     * Get the Extended Attribute pointer and look at the text
     * value passed in for a match with "TransportAddress" or
     * "ConnectionContext" (in FindEa)
     */
    ea = (PFILE_FULL_EA_INFORMATION) pIrp->AssociatedIrp.SystemBuffer;

    IF_DBG(NBT_DEBUG_DRIVER)
        KdPrint(("Nbt.NbtDispatchCreate: Major:Minor=<%x:%x>, PFILE_FULL_EA_INFORMATION = <%x>\n",
            pIrpSp->MajorFunction, pIrpSp->MinorFunction, ea));

    if (!ea)
    {
        // a null ea means open the control object
        status = NTOpenControl(pDeviceContext,pIrp);
    }
    else if (eabuf = FindInEA(ea, TdiConnectionContext))
    {
        // not allowed to pass in both a Connect Request and a Transport Address
        ASSERT(!FindInEA(ea, TdiTransportAddress));
        status = NTOpenConnection(pDeviceContext, pIrp, eabuf);
    }
    else if (eabuf = FindInEA(ea, TdiTransportAddress))
    {
        status = NTOpenAddr(pDeviceContext, pIrp, eabuf);
    }
    else if ((eabuf = FindInEA(ea, WINS_INTERFACE_NAME)) &&
            ((ea->EaValueLength) >= sizeof(tIPADDRESS)))
    {
        pIpAddressU = (tIPADDRESS UNALIGNED *) &ea->EaName[ea->EaNameLength+1];
        if (IpAddress = *pIpAddressU)
        {
            status = NTOpenWinsAddr(pDeviceContext, pIrp, IpAddress);
        }
        else
        {
            status = STATUS_INVALID_ADDRESS;
        }
    }
    else
    {
        status = STATUS_INVALID_EA_NAME;
    }

    // complete the irp if the status is anything EXCEPT status_pending
    // since the name query completion routine NTCompletIO completes pending
    // open addresses

    if (status != STATUS_PENDING)
    {

#if DBG
        if (!NT_SUCCESS(status))
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtDispatchCreate: Returning Error status = %X\n",status));
        }
#endif
        // reset the pending returned bit, since we are NOT returning pending
        pIrpSp->Control = IrpFlags;
        ReturnIrp(pIrp,status);

    }

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
    return(status);
}


//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchDevCtrl(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the NBT driver's dispatch function for all
    IRP_MJ_DEVICE_CONTROL requests.

Arguments:

    device - ptr to device object for target device
    pIrp    - ptr to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PIO_STACK_LOCATION  pIrpSp;
    tDEVICECONTEXT      *pDeviceContext;
    ULONG               IoControlCode;
    PULONG_PTR          pEntryPoint;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ASSERT(pIrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);

    //
    // If this device was destroyed, then reject all requests on it.
    // Ideally we would like the IO sub-system to guarantee that no
    // requests come down on IoDeleted devices, but.....
    //
    pDeviceContext = (tDEVICECONTEXT *)Device;
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchDevCtrl: Short-Ckt request -- Device=<%x>, CtrlCode=<%x>\n",
                pDeviceContext, pIrpSp->Parameters.DeviceIoControl.IoControlCode));
        pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (STATUS_INVALID_DEVICE_STATE);
    }

    /*
     * Initialize the I/O status block.
     */
    pIrp->IoStatus.Status      = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;
    IoControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode; // Save the IoControl code

    IF_DBG(NBT_DEBUG_DRIVER)
    KdPrint(("Nbt.NbtDispatchDevCtrl: IoControlCode = <%x>\n",
        pIrpSp->Parameters.DeviceIoControl.IoControlCode));

    /*
     * if possible, convert the (external) device control into internal
     * format, then treat it as if it had arrived that way.
     */
    if (STATUS_SUCCESS == TdiMapUserRequest(Device, pIrp, pIrpSp))
    {
        status = NbtDispatchInternalCtrl (Device, pIrp);
    }
#if FAST_DISP
    // Check if upper layer is querying for fast send path
    else if (pIrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER)
    {
        if (pEntryPoint = pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer)
        {
            if (pIrp->RequestorMode != KernelMode) // Bug# 120649:  Make sure data + the Address type are good
            {
                try
                {
                    ProbeForWrite (pEntryPoint, sizeof(PVOID *), sizeof(BYTE));
                    *pEntryPoint = (ULONG_PTR) NTSend;
                    status = STATUS_SUCCESS;
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    // status = STATUS_UNSUCCESSFUL by default
                }
            }
            else
            {
                *pEntryPoint = (ULONG_PTR) NTSend;
                status = STATUS_SUCCESS;
            }
        }

        IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchDevCtrl: direct send handler query %x\n", pEntryPoint));

        ReturnIrp(pIrp, status);
    }
#endif
    else
    {
        status = DispatchIoctls (pDeviceContext, pIrp, pIrpSp);
    }

    //
    // Dereference this DeviceContext, unless it was to destroy the Device!
    //
    if (IoControlCode != IOCTL_NETBT_DELETE_INTERFACE)
    {
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
    }

    return (status);
} // NbtDispatchDevCtrl


//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchInternalCtrl(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )

/*++

Routine Description:

    This is the driver's dispatch function for all
    IRP_MJ_INTERNAL_DEVICE_CONTROL requests.

Arguments:

    device - ptr to device object for target device
    pIrp    - ptr to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    tDEVICECONTEXT      *pDeviceContext;
    PIO_STACK_LOCATION  pIrpSp;
    NTSTATUS            status;
    UCHAR               IrpFlags;

    pDeviceContext = (tDEVICECONTEXT *)Device;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    ASSERT(pIrpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);

    //
    // this check is first to optimize the Send path
    //
    if (pIrpSp->MinorFunction ==TDI_SEND)
    {
        //
        // this routine decides if it should complete the pIrp or not
        // It never returns status pending, so we can turn off the
        // pending bit
        //
        status = NTSend (pDeviceContext,pIrp);
        NbtTrace(NBT_TRACE_SEND, ("TDI_SEND pIrp %p: %!status!", pIrp, status));
        return status;
    }

    //
    // If this device was destroyed, then reject all operations on it.
    // Ideally we would like the IO sub-system to guarantee that no
    // requests come down on IoDeleted devices, but.....
    //
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        // IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchInternalCtrl: Short-Ckt request -- Device=<%x>, CtrlCode=<%x>\n",
                pDeviceContext, pIrpSp->Parameters.DeviceIoControl.IoControlCode));
        pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (STATUS_INVALID_DEVICE_STATE);
    }

    IrpFlags = pIrpSp->Control;

    IF_DBG(NBT_DEBUG_DRIVER)
        KdPrint(("Nbt.NbtDispatchInternalCtrl: MajorFunction:MinorFunction = <%x:%x>\n",
            pIrpSp->MajorFunction, pIrpSp->MinorFunction));

    switch (pIrpSp->MinorFunction)
    {
        case TDI_ACCEPT:
            MakePending(pIrp);
            status = NTAccept(pDeviceContext,pIrp);
            NbtTrace(NBT_TRACE_IOCTL, ("TDI_ACCEPT pIrp %p: %!status!", pIrp, status));
            break;

        case TDI_ASSOCIATE_ADDRESS:
            MakePending(pIrp);
            status = NTAssocAddress(pDeviceContext,pIrp);
            NbtTrace(NBT_TRACE_IOCTL, ("TDI_ASSOCIATE_ADDRESS pIrp %p: %!status!", pIrp, status));
            break;

        case TDI_DISASSOCIATE_ADDRESS:
            MakePending(pIrp);
            status = NTDisAssociateAddress(pDeviceContext,pIrp);
            NbtTrace(NBT_TRACE_IOCTL, ("TDI_DISASSOCIATE_ADDRESS pIrp %p: %!status!", pIrp, status));
            break;

        case TDI_CONNECT:
            MakePending(pIrp);
            status = NTConnect(pDeviceContext,pIrp);
            NbtTrace(NBT_TRACE_IOCTL, ("TDI_CONNECT pIrp %p: %!status!", pIrp, status));
            break;

        case TDI_DISCONNECT:
            MakePending(pIrp);
            status = NTDisconnect(pDeviceContext,pIrp);
            NbtTrace(NBT_TRACE_IOCTL, ("TDI_DISCONNECT pIrp %p: %!status!", pIrp, status));
            break;

        case TDI_LISTEN:
            status = NTListen(pDeviceContext,pIrp);
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            NbtTrace(NBT_TRACE_IOCTL, ("TDI_LISTEN pIrp %p: %!status!", pIrp, status));
            return(status);
            break;

        case TDI_QUERY_INFORMATION:
            status = NTQueryInformation(pDeviceContext,pIrp);
#if DBG
            if (!NT_SUCCESS(status))
            {
                IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtDispatchInternalCtrl: Bad status from NTQueryInformation = %x\n",status));
            }
#endif
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            NbtTrace(NBT_TRACE_IOCTL, ("TDI_QUERY_INFORMATION pIrp %p: %!status!", pIrp, status));
            return(status);
            break;

        case TDI_RECEIVE:
            status = NTReceive(pDeviceContext,pIrp);
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            NbtTrace(NBT_TRACE_RECV, ("TDI_RECEIVE pIrp %p: %!status!", pIrp, status));
            return(status);
            break;

        case TDI_RECEIVE_DATAGRAM:
            status = NTReceiveDatagram(pDeviceContext,pIrp);
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            NbtTrace(NBT_TRACE_RECVDGRAM, ("TDI_RECEIVE_DATAGRAM pIrp %p: %!status!", pIrp, status));
            return(status);
            break;


    case TDI_SEND_DATAGRAM:

            status = NTSendDatagram(pDeviceContext,pIrp);
#if DBG
            if (!NT_SUCCESS(status))
            {
                IF_DBG(NBT_DEBUG_NAMESRV)
                KdPrint(("Nbt.NbtDispatchInternalCtrl: Bad status from NTSendDatagram = %x\n",status));
            }
#endif
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            NbtTrace(NBT_TRACE_SENDDGRAM, ("TDI_SEND_DATAGRAM pIrp %p: %!status!", pIrp, status));
            return(status);
            break;

        case TDI_SET_EVENT_HANDLER:
            MakePending(pIrp);
            status = NTSetEventHandler(pDeviceContext,pIrp);
            NbtTrace(NBT_TRACE_IOCTL, ("TDI_SET_EVENT_HANDLER pIrp %p: %!status!", pIrp, status));
            break;

        case TDI_SET_INFORMATION:
            MakePending(pIrp);
            status = NTSetInformation(pDeviceContext,pIrp);
            NbtTrace(NBT_TRACE_IOCTL, ("TDI_ACCEPT pIrp %p: %!status!", pIrp, status));
            break;

    #if DBG
        //
        // 0x7f is a request by the redirector to put a "magic bullet" out on
        // the wire, to trigger the Network General Sniffer.
        //
        case 0x7f:
            NbtTrace(NBT_TRACE_IOCTL, ("pIrp %p: not supported", pIrp));

            KdPrint(("NBT.DispatchInternalCtrl: - 07f minor function code\n"));
            ReturnIrp(pIrp, STATUS_NOT_SUPPORTED);
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            return(STATUS_NOT_SUPPORTED);

    #endif /* DBG */

        default:
            NbtTrace(NBT_TRACE_IOCTL, ("pIrp %p: not supported", pIrp));

            KdPrint(("Nbt.DispatchInternalCtrl: Invalid minor function %X\n",
                            pIrpSp->MinorFunction));
            ReturnIrp(pIrp, STATUS_INVALID_DEVICE_REQUEST);
            NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
            return(STATUS_INVALID_DEVICE_REQUEST);
    }

    // if the returned status is pending, then we do not complete the IRP
    // here since it will be completed elsewhere in the code...
    //
    if (status != STATUS_PENDING)
    {
#if DBG
        // *TODO* for debug...
        if (!NT_SUCCESS(status))
        {
            IF_DBG(NBT_DEBUG_NAMESRV)
            KdPrint(("Nbt.NbtDispatchInternalCtrl: Returning Error status = %X,MinorFunc = %X\n",
                status,pIrpSp->MinorFunction));
//            ASSERTMSG("An error Status reported from NBT",0L);
        }
#endif
        pIrpSp->Control = IrpFlags;
        ReturnIrp(pIrp,status);
    }

    NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
    return(status);
} // NbtDispatchInternalCtrl


//----------------------------------------------------------------------------

ULONG
CompleteTimerAndWorkerRequests(
    )
{
    CTELockHandle               OldIrq;
    tDEVICECONTEXT              *pDeviceContext;
    LIST_ENTRY                  *pTimerQEntry;
    tTIMERQENTRY                *pTimer;
    LIST_ENTRY                  *pWorkerQEntry;
    NBT_WORK_ITEM_CONTEXT       *pContext;
    PNBT_WORKER_THREAD_ROUTINE  pCompletionRoutine;
    ULONG                       NumTimerRequests = 0;
    ULONG                       NumDelayedRequests = 0;
    NTSTATUS   status;

    //
    // First remove any active Device Contexts if they are still present
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    while (!IsListEmpty(&NbtConfig.DeviceContexts))
    {
        pDeviceContext = CONTAINING_RECORD(NbtConfig.DeviceContexts.Flink, tDEVICECONTEXT, Linkage);
        NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        NbtDestroyDevice (pDeviceContext, FALSE);   // Don't wait since the Worker threads will not fire
        CTESpinLock(&NbtConfig.JointLock,OldIrq);
        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_FIND_REF, TRUE);
    }
    CTESpinFree(&NbtConfig.JointLock,OldIrq);

    if (pNbtSmbDevice)
    {
        NbtDestroyDevice (pNbtSmbDevice, FALSE);   // Don't wait since the Worker threads will not fire
        pNbtSmbDevice = NULL;
    }

    NbtDestroyDevice (pWinsDeviceContext, FALSE);   // Don't wait since the Worker threads will not fire

    StopInitTimers();
    KeClearEvent (&NbtConfig.TimerQLastEvent);

    //
    // if any other timers are active, stop them
    //
    CTESpinLock(&NbtConfig.JointLock,OldIrq);
    while (!IsListEmpty(&TimerQ.ActiveHead))
    {
        pTimerQEntry = RemoveHeadList(&TimerQ.ActiveHead);
        pTimer = CONTAINING_RECORD(pTimerQEntry,tTIMERQENTRY,Linkage);
        InitializeListHead (&pTimer->Linkage);      // in case the Linkage is touched again

        IF_DBG(NBT_DEBUG_PNP_POWER)
            KdPrint (("CompleteTimerAndWorkerRequests[%d]: Completing request <%x>\n",
                NumTimerRequests, pTimer));

        StopTimer (pTimer, NULL, NULL);

        NumTimerRequests++;
    }

    //
    // See if there are any Timers currently executing, and if so, wait for
    // them to complete
    //
    if (NbtConfig.lNumTimersRunning)
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
        status = KeWaitForSingleObject(&NbtConfig.TimerQLastEvent,  // Object to wait on.
                                       Executive,            // Reason for waiting
                                       KernelMode,           // Processor mode
                                       FALSE,                // Alertable
                                       NULL);                // Timeout
        ASSERT(status == STATUS_SUCCESS);
    }
    else
    {
        CTESpinFree(&NbtConfig.JointLock,OldIrq);
    }

    //
    // See if there are any worker threads currently executing, and if so, wait for
    // them to complete
    //
    while (NbtConfig.bSystemWorkThreadQueued) {
        LARGE_INTEGER   Timout;

        Timout.QuadPart = Int32x32To64(MILLISEC_TO_100NS, 1000);
        Timout.QuadPart = -(Timout.QuadPart);

        KeDelayExecutionThread(KernelMode, FALSE, &Timout);
    }

    //
    // Flush all the workitem
    //
    NTExecuteWorker(NULL);

    //
    // Now destroy the Devices queued on the Free'ed list since there are no more Worker threads or
    // Timers pending!
    //
    while (!IsListEmpty(&NbtConfig.DevicesAwaitingDeletion))
    {
        pDeviceContext = CONTAINING_RECORD(NbtConfig.DevicesAwaitingDeletion.Flink, tDEVICECONTEXT, Linkage);
        ASSERT (pDeviceContext->RefCount == 0);

        KdPrint(("Nbt.CompleteTimerAndWorkerRequests: *** Destroying Device *** \n\t%wZ\n",
            &pDeviceContext->ExportName));

        RemoveEntryList (&pDeviceContext->Linkage); // Remove the Device from the to-be-free'ed list

        if (pDeviceContext->ExportName.Buffer) {
            CTEMemFree (pDeviceContext->ExportName.Buffer);
            pDeviceContext->ExportName.Buffer = NULL;
        }
        IoDeleteDevice((PDEVICE_OBJECT)pDeviceContext);
    }

    ASSERT (IsListEmpty(&NbtConfig.AddressHead));
    KdPrint(("Nbt.CompleteTimerAndWorkerRequests:  Completed <%d> Timer and <%d> Delayed requests\n",
        NumTimerRequests, NumDelayedRequests));

    return (NumTimerRequests + NumDelayedRequests);
}



//----------------------------------------------------------------------------
VOID
NbtUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the NBT driver's dispatch function for Unload requests

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None

--*/

{
    NTSTATUS                status;

    CTEPagedCode();

    KdPrint(("Nbt.NbtUnload: Unloading ...\n"));

    //
    // After setting the following flag, no new requests should be queued on to
    // the WorkerQ.
    //
    NbtConfig.Unloading = TRUE;

    //
    // Unbind fron the RAS driver if we were bound
    //
    NbtAcdUnbind ();

    status = TdiDeregisterPnPHandlers(TdiClientHandle);
    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint (("NbtUnload: TdiDeregisterPnPHandlers returned <%x>\n", status));

    status = TdiDeregisterProvider (TdiProviderHandle);
    IF_DBG(NBT_DEBUG_PNP_POWER)
        KdPrint (("NbtUnload: TdiDeregisterProvider returned <%x>\n", status));

    //
    // Dequeue each of the requests in the Timer and NbtConfigWorker Queues and complete them
    //
    CompleteTimerAndWorkerRequests();

    //
    // Now cleanup the rest of the static allocations
    //
    CleanupDriverEntry (5);

    ASSERT (IsListEmpty (&NbtConfig.PendingNameQueries) && NbtConfig.lNumPendingNameQueries == 0);

    if (NbtConfig.pServerBindings) {
        CTEFreeMem (NbtConfig.pServerBindings);
        NbtConfig.pServerBindings = NULL;
    }

    if (NbtConfig.pClientBindings) {
        CTEFreeMem (NbtConfig.pClientBindings);
        NbtConfig.pClientBindings = NULL;
    }

#ifdef _NBT_WMI_SOFTWARE_TRACING_
    WPP_CLEANUP(DriverObject);
#endif
}


//----------------------------------------------------------------------------
NTSTATUS
NbtDispatchPnP(
    IN PDEVICE_OBJECT   Device,
    IN PIRP             pIrp
    )
{
    tDEVICECONTEXT      *pDeviceContext;
    PIO_STACK_LOCATION  pIrpSp, pIrpSpNext;
    NTSTATUS            status = STATUS_INVALID_DEVICE_REQUEST;
    tCONNECTELE         *pConnectEle;
    tLOWERCONNECTION    *pLowerConn;
    KIRQL               OldIrq1, OldIrq2;
    PDEVICE_OBJECT      pTcpDeviceObject;
    PFILE_OBJECT        pTcpFileObject;
    tFILE_OBJECTS       *pFileObjectsContext;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    //
    // If this device was destroyed, then reject all operations on it.
    // Ideally we would like the IO sub-system to guarantee that no
    // requests come down on IoDeleted devices, but.....
    //
    pDeviceContext = (tDEVICECONTEXT *)Device;
    if (!NBT_REFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE))
    {
        IF_DBG(NBT_DEBUG_DRIVER)
            KdPrint(("Nbt.NbtDispatchPnP: Short-Ckt request -- Device=<%x>\n", pDeviceContext));
        pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        return (STATUS_INVALID_DEVICE_STATE);
    }

    switch (pIrpSp->MinorFunction)
    {
        case IRP_MN_QUERY_DEVICE_RELATIONS:
        {
            if (pIrpSp->Parameters.QueryDeviceRelations.Type==TargetDeviceRelation)
            {
                if (PtrToUlong(pIrpSp->FileObject->FsContext2) == NBT_CONNECTION_TYPE)
                {
                    // pass to transport to get the PDO
                    //
                    pConnectEle = (tCONNECTELE *)pIrpSp->FileObject->FsContext;
                    if (NBT_VERIFY_HANDLE2 (pConnectEle, NBT_VERIFY_CONNECTION, NBT_VERIFY_CONNECTION_DOWN))
                    {
                        CTESpinLock(pConnectEle, OldIrq1);

                        pLowerConn = (tLOWERCONNECTION *)pConnectEle->pLowerConnId;
                        if (NBT_VERIFY_HANDLE (pLowerConn, NBT_VERIFY_LOWERCONN))
                        {
                            CTESpinLock(pLowerConn, OldIrq2);
                            NBT_REFERENCE_LOWERCONN (pLowerConn, REF_LOWC_QUERY_DEVICE_REL);
                            CTESpinFree(pLowerConn, OldIrq2);
                            CTESpinFree(pConnectEle, OldIrq1);

                            if ((pTcpFileObject = pLowerConn->pFileObject) &&
                                (pTcpDeviceObject = IoGetRelatedDeviceObject (pLowerConn->pFileObject)))
                            {
                                //
                                // Simply pass the Irp on by to the Transport, and let it
                                // fill in the info
                                //
                                pIrpSpNext = IoGetNextIrpStackLocation (pIrp);
                                *pIrpSpNext = *pIrpSp;

                                IoSetCompletionRoutine (pIrp, NULL, NULL, FALSE, FALSE, FALSE);
                                pIrpSpNext->FileObject = pTcpFileObject;
                                pIrpSpNext->DeviceObject = pTcpDeviceObject;

                                status = IoCallDriver(pTcpDeviceObject, pIrp);

                                NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, FALSE);
                                return status;
                            }
                            else
                            {
                                status =  STATUS_INVALID_HANDLE;
                            }
                            NBT_DEREFERENCE_LOWERCONN (pLowerConn, REF_LOWC_QUERY_DEVICE_REL, FALSE);
                        }
                        else
                        {
                            status = STATUS_CONNECTION_INVALID;
                            CTESpinFree(pConnectEle, OldIrq1);
                        }
                    }
                    else
                    {
                        status =  STATUS_INVALID_HANDLE;
                    }
                }
                else if ( PtrToUlong(pIrpSp->FileObject->FsContext2) == NBT_ADDRESS_TYPE)
                {
                    CTESpinLock(&NbtConfig.JointLock,OldIrq1);

                    if ((pDeviceContext->IpAddress) &&
                        (pFileObjectsContext = pDeviceContext->pFileObjects) &&
                        (pTcpFileObject = pFileObjectsContext->pDgramFileObject) &&
                        (pTcpDeviceObject = pFileObjectsContext->pDgramDeviceObject))
                    {
                        pFileObjectsContext->RefCount++;        // Dereferenced after the Query has completed

                        //
                        // pass the Irp to transport to get the PDO
                        //
                        pIrpSpNext = IoGetNextIrpStackLocation (pIrp);
                        *pIrpSpNext = *pIrpSp;

                        IoSetCompletionRoutine (pIrp, NULL, NULL, FALSE, FALSE, FALSE);
                        pIrpSpNext->FileObject = pTcpFileObject;
                        pIrpSpNext->DeviceObject = pTcpDeviceObject;

                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                        status = IoCallDriver(pTcpDeviceObject, pIrp);

                        CTESpinLock(&NbtConfig.JointLock,OldIrq1);
                        if (--pFileObjectsContext->RefCount == 0)
                        {
                            NTQueueToWorkerThread(
                                        &pFileObjectsContext->WorkItemCleanUp,
                                        DelayedNbtCloseFileHandles,
                                        NULL,
                                        pFileObjectsContext,
                                        NULL,
                                        NULL,
                                        TRUE
                                        );
                        }

                        NBT_DEREFERENCE_DEVICE (pDeviceContext, REF_DEV_DISPATCH, TRUE);
                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);

                        return status;
                    }
                    else
                    {
                        CTESpinFree(&NbtConfig.JointLock,OldIrq1);
                        status =  STATUS_INVALID_DEVICE_REQUEST;
                    }
                }
                else
                {
                    ASSERT (0);
                }