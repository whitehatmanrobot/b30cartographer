ec.Mode;
            IPSecToDo[i].BundleSize = SP->NestCount;
            *Action = LOOKUP_CONT;
            break;
        } // end of for (SA = SP->OutboundSA; ...)

        // Check if the match was found.
        if (*Action == LOOKUP_DROP) {
            // No match so free IPSecToDo memory.
            FreeIPSecToDo(IPSecToDo, i);
            break;
        }
    } // end of for (i = 1; ...)

    return IPSecToDo;
}


//* OutboundSPLookup - Do the IPSec processing associated with an outbound SP.
//
//  This function is called from the transport layer to find an appropriate
//  SA or SABundle associated with the traffic.  The Outbound SPD is sorted
//  so the first SP found is for this traffic.
//
IPSecProc *
OutboundSPLookup(
    IPv6Addr *SourceAddr,       // Source Address.
    IPv6Addr *DestAddr,         // Destination Address.
    ushort TransportProtocol,   // Transport Protocol.
    ushort SourcePort,          // Source Port.
    ushort DestPort,            // Destination Port.
    Interface *IF,              // Interface Pointer.
    uint *Action)               // Action to do.
{
    SecurityPolicy *SP;
    KIRQL OldIrql;
    IPSecProc *IPSecToDo;

    IPSecToDo = NULL;
    *Action = LOOKUP_DROP;

    //
    // Get IPSec lock then get interface lock.
    // REVIEW: Do we still need to grab the IF lock here?
    //
    KeAcquireSpinLock(&IPSecLock, &OldIrql);
    KeAcquireSpinLockAtDpcLevel(&IF->Lock);

    for (SP = SecurityPolicyList; SP != NULL; SP = SP->Next) {
        // Check Interface.
        if ((SP->IFIndex != 0) && (SP->IFIndex != IF->Index))
            continue;

        // Check Direction of SP.
        if (!(SP->DirectionFlag == OUTBOUND ||
            SP->DirectionFlag == BIDIRECTIONAL)) {
            continue;
        }

        // Check Remote Address.
        if (!SPCheckAddr(DestAddr, SP->RemoteAddrField,
                         &SP->RemoteAddr, &SP->RemoteAddrData)) {
            continue;
        }

        // Check Local Address.
        if (!SPCheckAddr(SourceAddr, SP->LocalAddrField,
                         &SP->LocalAddr, &SP->LocalAddrData)) {
            continue;
        }

        // Check Transport Protocol.
        if (SP->TransportProto == NONE) {
            // None so protocol passed.

        } else {
            if (SP->TransportProto != TransportProtocol) {
                continue;
            } else {
                // Check Remote Port.
                if (!SPCheckPort(DestPort, SP->RemotePortField,
                                 SP->RemotePort, SP->RemotePortData)) {
                    continue;
                }

                // Check Local Port.
                if (!SPCheckPort(SourcePort, SP->LocalPortField,
                                 SP->LocalPort, SP->LocalPortData)) {
                    continue;
                }
            }
        }

        //
        // Check IPSec Action.
        //
        if (SP->SecPolicyFlag == IPSEC_APPLY) {
            // Search for an SA entry that matches.
            IPSecToDo = OutboundSALookup(SourceAddr, DestAddr,
                                         TransportProtocol, DestPort,
                                         SourcePort, SP, Action);
            if (IPSecToDo == NULL) {
                // No SA was found for the outgoing traffic.
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                           "OutboundSPLookup: No SA found for SP entry %d\n",
                           SP->Index));
                *Action = LOOKUP_DROP;
            }
        } else {
            if (SP->SecPolicyFlag == IPSEC_DISCARD) {
                // Packet is dropped.
                IPSecToDo = NULL;
                *Action = LOOKUP_DROP;
            } else {
                //
                // This is Bypass or "App determines" mode.
                // REVIEW: What is the app determine mode?
                //
                IPSecToDo = NULL;
                *Action = LOOKUP_BYPASS;
            }
        }
        break;
    }

    // Release locks.
    KeReleaseSpinLockFromDpcLevel(&IF->Lock);
    KeReleaseSpinLock(&IPSecLock, OldIrql);

    return IPSecToDo;
}

//* PerformDeferredAHProcessing - Helper for AuthenticationHeaderReceive
//
//  This routine handles processing the AH authentication algorithm over
//  a given extension header once we know which header logically follows it.
//  
void
PerformDeferredAHProcessing(
    SecurityAlgorithm *Alg,  // Authentication algorithm to use.
    void *Context,           // Context to use with algorithm.
    uchar *Key,              // Key to use with algorithm.
    uint AmountSkipped,      // Size of headers not included in AH validation.
    void *Data,              // Start of header we're currently processing.
    uchar ThisHeader,        // Which header we're currently processing.
    uchar NextHeader)        // Header logically following this one.
    
{
    uint Dummy;
    ushort PayloadLength;

    switch(ThisHeader) {

    case IP_PROTOCOL_V6: {
        IPv6Header UNALIGNED *IP = (IPv6Header UNALIGNED *)Data;

        //
        // REVIEW: Cache IPv6 header so we can give it to Operate as a single
        // REVIEW: chunk and avoid all these individual calls?  More efficient?
        //

        // In VersClassFlow, only the IP version is immutable.
        Dummy = IP_VERSION;

        //
        // For non-jumbograms, the payload length needs to be altered to
        // reflect the lack of those headers which aren't included in the
        // authentication check.
        //
        PayloadLength = net_short(IP->PayloadLength);
        if (PayloadLength != 0) {
            PayloadLength = PayloadLength - AmountSkipped;
        }
        PayloadLength = net_short(PayloadLength);

#ifdef IPSEC_DEBUG
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "\nAH Receive Data:\n"));
        dump_encoded_mesg((uchar *)&Dummy, 4);
        dump_encoded_mesg((uchar *)&PayloadLength, 2);
        dump_encoded_mesg((uchar *)&NextHeader, 1);
#endif
        (*Alg->Operate)(Context, Key, (uchar *)&Dummy, 4);
        (*Alg->Operate)(Context, Key, (uchar *)&PayloadLength, 2);
        (*Alg->Operate)(Context, Key, (uchar *)&NextHeader, 1);
        Dummy = 0;  // Hop Limit is mutable.
#ifdef IPSEC_DEBUG
        dump_encoded_mesg((uchar *)&Dummy, 1);
        dump_encoded_mesg((uchar *)&IP->Source, 2 * sizeof(IPv6Addr));
#endif
        (*Alg->Operate)(Context, Key, (uchar *)&Dummy, 1);
        (*Alg->Operate)(Context, Key, (uchar *)&IP->Source,
                        2 * sizeof(IPv6Addr));
        break;
    }

    case IP_PROTOCOL_HOP_BY_HOP:
    case IP_PROTOCOL_DEST_OPTS: {
        IPv6OptionsHeader UNALIGNED *Ext;
        uint HdrLen, Amount;
        uchar *Start, *Current;

        //
        // The options headers have the NextHeader field as the first byte.
        //
        C_ASSERT(FIELD_OFFSET(IPv6OptionsHeader, NextHeader) == 0);

        //
        // First feed the NextHeader field into the algorithm.
        // We use the one that logically follows, not the one in the header.
        //
#ifdef IPSEC_DEBUG
        dump_encoded_mesg(&NextHeader, 1);
#endif
        (*Alg->Operate)(Context, Key, &NextHeader, 1);

        //
        // Now feed the rest of this header into the algorithm.
        // This includes the remainder of the base header and any
        // non-mutable options.  For mutable options, we feed the
        // algorithm with the equivalent number of zeroes.
        //
        Ext = (IPv6OptionsHeader UNALIGNED *)Data;
        HdrLen = (Ext->HeaderExtLength + 1) * EXT_LEN_UNIT;
        Start = (uchar *)Data + 1;
        Current = (uchar *)Data + sizeof(IPv6OptionsHeader);
        HdrLen -= sizeof(IPv6OptionsHeader);
        while (HdrLen) {

            if (*Current == OPT6_PAD_1) {
                //
                // This is the special one byte pad option.  Immutable.
                //
                Current++;
                HdrLen--;
                continue;
            }

            if ((*Current == OPT6_JUMBO_PAYLOAD) && (AmountSkipped != 0 )) {
                //
                // Special case for jumbo payload option where we have to
                // update the payload length to reflect skipped headers.
                //

                //
                // First feed in everything up to the option data.
                //
                Amount = (uint)(Current - Start) + sizeof(OptionHeader);
#ifdef IPSEC_DEBUG
                dump_encoded_mesg(Start, Amount);
#endif
                (*Alg->Operate)(Context, Key, Start, Amount);

                //
                // Adjust the payload length before feeding it in.
                //
                Current += sizeof(OptionHeader);
                Dummy = net_long(net_long(*(ulong *)Current) - AmountSkipped);
#ifdef IPSEC_DEBUG
                dump_encoded_mesg((uchar *)&Dummy, 4);
#endif
                (*Alg->Operate)(Context, Key, (uchar *)&Dummy, 4);

                HdrLen -= sizeof(OptionHeader) + sizeof(ulong);
                Current += sizeof(ulong);
                Start = Current;
                continue;
            }

            if (OPT6_ISMUTABLE(*Current)) {
                //
                // This option's data is mutable.  Everything preceeding
                // the option data is not.
                //
                Amount = (uint)(Current - Start) + 2;  // Immutable amount.
#ifdef IPSEC_DEBUG
                dump_encoded_mesg(Start, Amount);
#endif
                (*Alg->Operate)(Context, Key, Start, Amount);

                Current++;  // Now on option data length byte.
                Amount = *Current;  // Mutable amount.
#ifdef IPSEC_DEBUG
                dump_encoded_mesg(Zero, Amount);
#endif
                (*Alg->Operate)(Context, Key, Zero, Amount);

                HdrLen -= Amount + 2;
                Current += Amount + 1;
                Start = Current;

            } else {

                //
                // This option's data is not mutable.
                // Just skip over it.
                //
                Current++;  // Now on option data length byte.
                Amount = *Current;
                HdrLen -= Amount + 2;
                Current += Amount + 1;
            }
        }
        if (Start != Current) {
            //
            // Option block ends with an immutable region.
            //
            Amount = (uint)(Current - Start);
#ifdef IPSEC_DEBUG
            dump_encoded_mesg(Start, Amount);
#endif
            (*Alg->Operate)(Context, Key, Start, Amount);
        }
        break;
    }

    case IP_PROTOCOL_ROUTING: {
        IPv6RoutingHeader UNALIGNED *Route;
        uint HdrLen;

        //
        // The routing header has the NextHeader field as the first byte.
        //
        C_ASSERT(FIELD_OFFSET(IPv6RoutingHeader, NextHeader) == 0);

        //
        // First feed the NextHeader field into the algorithm.
        // We use the one that logically follows, not the one in the header.
        //
#ifdef IPSEC_DEBUG
        dump_encoded_mesg(&NextHeader, 1);
#endif
        (*Alg->Operate)(Context, Key, &NextHeader, 1);

        //
        // Now feed the rest of this header into the algorithm.
        // It's all immutable.
        //
        Route = (IPv6RoutingHeader UNALIGNED *)Data;
        HdrLen = ((Route->HeaderExtLength + 1) * EXT_LEN_UNIT) - 1;
        ((uchar *)Data)++;
#ifdef IPSEC_DEBUG
        dump_encoded_mesg(Data, HdrLen);
#endif
        (*Alg->Operate)(Context, Key, Data, HdrLen);
        
        break;
    }

    default:
        //
        // Unrecognized header.
        // The only way this can happen is if somebody later adds code
        // to AuthenticationHeaderReceive to call this function for a
        // new header and neglects to add corresponding support here.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "PerformDeferredAHProcessing: "
                   "Unsupported header = %d\n",
                   ThisHeader));
        ABORT();
    }
}


//* AuthenticationHeaderReceive - Handle an IPv6 AH header.
//
//  This is the routine called to process an Authentication Header,
//  next header value of 51.
//
uchar
AuthenticationHeaderReceive(
    IPv6Packet *Packet)      // Packet handed to us by IPv6Receive.
{
    AHHeader UNALIGNED *AH;
    SecurityAssociation *SA;
    SecurityAlgorithm *Alg;
    uint ResultSize, AHHeaderLen;
    void *Context;
    uchar *Result, *AuthData;
    SALinkage *SAPerformed;
    uint SavePosition;
    void *SaveData;
    uint SaveContigSize;
    uint SaveTotalSize;
    void *SaveAuxList = NULL;
    uchar NextHeader, DeferredHeader;
    void *DeferredData;
    uint Done;

    //
    // Verify that we have enough contiguous data to overlay an Authentication
    // Header structure on the incoming packet.  Then do so and skip over it.
    //
    if (! PacketPullup(Packet, sizeof(AHHeader), 1, 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof(AHHeader))
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "AuthenticationHeaderReceive: Incoming packet too small"
                       " to contain authentication header\n"));
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    AH = (AHHeader UNALIGNED *)Packet->Data;
    // Remember offset to this header's NextHeader field.
    Packet->NextHeaderPosition = Packet->Position +
        FIELD_OFFSET(AHHeader, NextHeader);
    AdjustPacketParams(Packet, sizeof(AHHeader));

    //
    // Lookup Security Association in the Security Association Database.
    //
    SA = InboundSAFind(net_long(AH->SPI),
                       AlignAddr(&Packet->IP->Dest),
                       IP_PROTOCOL_AH);
    if (SA == NULL) {
        // No SA exists for this packet.
        // Drop packet.  NOTE: This is an auditable event.
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "AuthenticationHeaderReceive: "
                   "No matching SA in database\n"));
        return IP_PROTOCOL_NONE;
    }

    //
    // Verify the Sequence Number if required to do so by the SA.
    // Since we only support manual keying currently, we treat all SAs
    // as not requiring this check.
    // TBD: Will need to change this when we add support for dynamic
    // TBD: keying (IKE).
    //


    //
    // Perform Integrity check.
    //
    // First ensure that the amount of Authentication Data claimed to exist
    // in this packet by the AH header's PayloadLen field is large enough to
    // contain the amount that is required by the algorithm specified in the
    // SA.  Note that the former may contain padding to make it a multiple
    // of 32 bits.  Then check the packet size to ensure that it is big
    // enough to hold what the header claims is present.
    //
    AHHeaderLen = (AH->PayloadLen + 2) * 4;
    if (AHHeaderLen < sizeof (AHHeader)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "AuthenticationHeaderReceive: Bogus AH header length\n"));
        goto ErrorReturn;
    }
    AHHeaderLen -= sizeof(AHHeader);  // May include padding.
    Alg = &AlgorithmTable[SA->AlgorithmId];
    ResultSize = Alg->ResultSize;  // Does not include padding.
    if (ResultSize  > AHHeaderLen) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "AuthenticationHeaderReceive: Incoming packet's AHHeader"
                   " length inconsistent with algorithm's AuthData size\n"));
        goto ErrorReturn;
    }
    if (! PacketPullup(Packet, AHHeaderLen, 1, 0)) {
        // Pullup failed.
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "AuthenticationHeaderReceive: Incoming packet too small"
                   " to contain authentication data\n"));
        goto ErrorReturn;
    }
    AuthData = (uchar *)Packet->Data;
    AdjustPacketParams(Packet, AHHeaderLen);

    //
    // AH authenticates everything (expect mutable fields) starting from
    // the previous IPv6 header.  Stash away our current position (so we can
    // restore it later) and backup to the previous IPv6 header.
    //
    SavePosition = Packet->Position;
    SaveData = Packet->Data;
    SaveContigSize = Packet->ContigSize;
    SaveTotalSize = Packet->TotalSize;
    SaveAuxList = Packet->AuxList;
    PositionPacketAt(Packet, Packet->IPPosition);
    Packet->AuxList = NULL;

    //
    // Initialize this particular algorithm.
    //
    Context = alloca(Alg->ContextSize);
    (*Alg->Initialize)(Context, SA->Key);

    //
    // Run algorithm over packet data.  We start with the IP header that
    // encapsulates this AH header.  We proceed through the end of the
    // packet, skipping over certain headers which are not part of the
    // logical packet being secured.  We also treat any mutable fields
    // as zero for the purpose of the algorithm calculation.
    //
    // Note: We only search for mutable fields in Destination Options
    // headers that appear before this AH header.  While the spec doesn't
    // explicitly spell this out anywhere, this is the behavior that makes
    // the most sense and we've verified this interpretation in the working
    // group.  However, because of this, our interpretation fails a TAHI test.
    // TAHI will hopefully fix their test, if they haven't already.
    //

    //
    // Start by pulling up the IP header and seeing which header physically
    // follows it.
    //
    if (! PacketPullup(Packet, sizeof(IPv6Header),
                       __builtin_alignof(IPv6Addr), 0)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "AuthenticationHeaderReceive: Out of memory!?!\n"));
        goto ErrorReturn;
    }
    NextHeader = Packet->IP->NextHeader;

    //
    // Defer processing of this header until after we've determined
    // whether or not we'll be skipping the following header.  This allows us
    // to use the correct NextHeader field value when running the algorithm.
    //
    DeferredHeader = IP_PROTOCOL_V6;
    DeferredData = Packet->Data;
    AdjustPacketParams(Packet, sizeof(IPv6Header));

    //
    // Continue over the various extension headers until we reach the
    // AH header for which we're running this authentication algoritm.
    // We've already parsed this far, so we know these headers are legit.
    //
    for (Done = FALSE; !Done;) {
        switch (NextHeader) {

        case IP_PROTOCOL_HOP_BY_HOP:
        case IP_PROTOCOL_DEST_OPTS: {
            IPv6OptionsHeader *Ext;
            uint HdrLen;

            //
            // These headers are not skipped, so process the header
            // logically preceeding this one.  Its NextHeader field
            // will contain the Protocol value for this header.
            //
            PerformDeferredAHProcessing(Alg, Context, SA->Key,
                                        Packet->SkippedHeaderLength,
                                        DeferredData, DeferredHeader,
                                        NextHeader);

            //
            // Remember this header for deferred processing.
            //
            DeferredHeader = NextHeader;

            //
            // Get the extension header and all the options pulled up
            // into one nice contiguous chunk.
            //
            if (! PacketPullup(Packet, sizeof(ExtensionHeader),
                               __builtin_alignof(ExtensionHeader), 0)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "AuthenticationHeaderReceive: "
                           "Out of mem!?!\n"));
                goto ErrorReturn;
            }
            Ext = (IPv6OptionsHeader *)Packet->Data;
            NextHeader = Ext->NextHeader;
            HdrLen = (Ext->HeaderExtLength + 1) * EXT_LEN_UNIT;
            if (! PacketPullup(Packet, HdrLen, 1, 0)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "AuthenticationHeaderReceive: "
                           "Out of mem!?!\n"));
                goto ErrorReturn;
            }

            //
            // Remember where this header starts for deferred processing.
            //
            DeferredData = Packet->Data;

            AdjustPacketParams(Packet, HdrLen);
            break;
        }

        case IP_PROTOCOL_ROUTING: {
            IPv6RoutingHeader *Route;
            uint HdrLen;

            //
            // This header is not skipped, so process the header
            // logically preceeding this one.  Its NextHeader field
            // will contain the Protocol value for this header.
            //
            PerformDeferredAHProcessing(Alg, Context, SA->Key,
                                        Packet->SkippedHeaderLength,
                                        DeferredData, DeferredHeader,
                                        IP_PROTOCOL_ROUTING);

            //
            // Remember this header for deferred processing.
            //
            DeferredHeader = IP_PROTOCOL_ROUTING;

            //
            // Get the extension header and all the options pulled up
            // into one nice contiguous chunk.
            //
            if (! PacketPullup(Packet, sizeof(IPv6RoutingHeader),
                               __builtin_alignof(IPv6RoutingHeader), 0)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "AuthenticationHeaderReceive: "
                           "Out of mem!?!\n"));
                goto ErrorReturn;
            }
            Route = (IPv6RoutingHeader *)Packet->Data;
            NextHeader = Route->NextHeader;
            HdrLen = (Route->HeaderExtLength + 1) * EXT_LEN_UNIT;
            if (! PacketPullup(Packet, HdrLen, 1, 0)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "AuthenticationHeaderReceive: "
                           "Out of mem!?!\n"));
                goto ErrorReturn;
            }

            //
            // Remember where this header starts for deferred processing.
            //
            DeferredData = Packet->Data;

            AdjustPacketParams(Packet, HdrLen);
            break;
        }

        case IP_PROTOCOL_AH: {
            //
            // We don't know yet whether we'll be including this AH header
            // in the algorithm calculation we're currently running.
            // See below.
            //
            AHHeader UNALIGNED *ThisAH;
            uint ThisHdrLen;
            uint Padding;

            //
            // Pullup the AH header.
            //
            if (! PacketPullup(Packet, sizeof(AHHeader), 1, 0)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "AuthenticationHeaderReceive: "
                           "Out of mem!?!\n"));
                goto ErrorReturn;
            }
            ThisAH = (AHHeader UNALIGNED *)Packet->Data;
            AdjustPacketParams(Packet, sizeof(AHHeader));
            ThisHdrLen = ((ThisAH->PayloadLen + 2) * 4) - sizeof(AHHeader);
            if (! PacketPullup(Packet, ThisHdrLen, 1, 0)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "AuthenticationHeaderReceive: "
                           "Out of mem!?!\n"));
                goto ErrorReturn;
            }
            AdjustPacketParams(Packet, ThisHdrLen);

            //
            // If this is another AH header encapsulating the one we are
            // currently processing, then don't include it in the integrity
            // check as per AH spec section 3.3.
            //
            if (Packet->Position != SavePosition) {
                NextHeader = ThisAH->NextHeader;
                break;
            }

            //
            // Otherwise this is the AH header that we're currently processing,
            // and we include it in its own integrity check.  But first we
            // need to process the header logically preceeding this one (which
            // we previously defered).  Its NextHeader field will contain the
            // Protocol value for this header.
            //
            PerformDeferredAHProcessing(Alg, Context, SA->Key,
                                        Packet->SkippedHeaderLength,
                                        DeferredData, DeferredHeader,
                                        IP_PROTOCOL_AH);

            //
            // Now process this AH header.  We do not need to defer processing
            // of this header, since everything following it is included in
            // the check.  The Authentication Data is mutable, the rest of the
            // AH header is not.
            //
            ASSERT(Packet->TotalSize == SaveTotalSize);
#ifdef IPSEC_DEBUG
            dump_encoded_mesg((uchar *)AH, sizeof(AHHeader));
#endif
            (*Alg->Operate)(Context, SA->Key, (uchar *)AH, sizeof(AHHeader));

#ifdef IPSEC_DEBUG
            dump_encoded_mesg(Zero, ResultSize);
#endif
            (*Alg->Operate)(Context, SA->Key, Zero, ResultSize);

            //
            // The Authentication Data may be padded.  This padding is
            // included as non-mutable in the integrity calculation.
            // REVIEW: We should double-check our interpretation of the RFC
            // about this with the IPSec working group.
            //
            Padding = AHHeaderLen - ResultSize;
            if (Padding != 0) {
#ifdef IPSEC_DEBUG
                dump_encoded_mesg((uchar *)(Packet->Data) - Padding, Padding);
#endif
                (*Alg->Operate)(Context, SA->Key,
                                (uchar *)(Packet->Data) - Padding, Padding);
            }

            Done = TRUE;
            break;
        }

        case IP_PROTOCOL_ESP: {
            //
            // We don't include other IPSec headers in the integrity check
            // as per AH spec section 3.3.  So just skip over this.  Tricky
            // part is that the NextHeader was in the ESP trailer which we've
            // already thrown away at this point.
            //
            ESPHeader UNALIGNED *ThisESP;
            ulong ThisSPI;
            SALinkage *ThisSAL;

            //
            // Get the SPI out of the ESP header so we can identify its
            // SALinkage entry on the SAPerformed chain.  Skip over the
            // ESP header while we're at it.
            //
            if (! PacketPullup(Packet, sizeof(ESPHeader), 1, 0)) {
                // Pullup failed.
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                           "AuthenticationHeaderReceive: Out of mem!?!\n"));
                goto ErrorReturn;
            }
            ThisESP = (ESPHeader UNALIGNED *)Packet->Data;
            AdjustPacketParams(Packet, sizeof(ESPHeader));
            ThisSPI = net_long(ThisESP->SPI);

            //
            // Find the SALinkage entry on the SAPerformed chain with the
            // matching SPI.  It must be present.
            // REVIEW: This code assumes we made SPIs system-wide unique.
            //
            for (ThisSAL = Packet->SAPerformed;
                 ThisSAL->This->SPI != ThisSPI; ThisSAL = ThisSAL->Next)
                ASSERT(ThisSAL->Next != NULL);

            //
            // Pull NextHeader value out of the SALinkage (where we stashed
            // it back in EncapsulatingSecurityPayloadReceive).
            //
            NextHeader = (uchar)ThisSAL->NextHeader;

            break;
        }

        case IP_PROTOCOL_FRAGMENT: {
            //
            // We normally won't encounter a fragment header here,
            // since reassembly will occur before authentication.
            // However, our implementation optimizes the reassembly of
            // single-fragment packets by leaving the fragment header in
            // place.  When performing the authentication calculation,
            // we treat such fragment headers as if they didn't exist.
            //
            FragmentHeader UNALIGNED *Frag;

            if (! PacketPullup(Packet, sizeof(FragmentHeader), 1, 0)) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_NTOS_ERROR,
                           "AuthenticationHeaderReceive: Out of mem!?\n"));
                goto ErrorReturn;
            }
            Frag = (FragmentHeader UNALIGNED *)Packet->Data;
            NextHeader = Frag->NextHeader;

            AdjustPacketParams(Packet, sizeof(FragmentHeader));

            break;
        }

        default:
            // Unrecognized header.
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "AuthenticationHeaderReceive: "
                       "Unsupported header = %d\n",
                       NextHeader));
            goto ErrorReturn;
        }
    }

    //
    // Everything inside this AH header is treated as immutable.
    //
    // REVIEW: For performance reasons, the ContigSize check could be moved
    // REVIEW: before the loop for the additional code space cost of
    // REVIEW: duplicating the PacketPullup call.
    //
    while (Packet->TotalSize != 0) {

        if (Packet->ContigSize == 0) {
            //
            // Ran out of contiguous data.
            // Get next buffer in packet.
            //
            PacketPullupSubr(Packet, 0, 1, 0);  // Moves to next buffer.
        }
#ifdef IPSEC_DEBUG
        dump_encoded_mesg(Packet->Data, Packet->ContigSize);
#endif
        (*Alg->Operate)(Context, SA->Key, Packet->Data, Packet->ContigSize);
        AdjustPacketParams(Packet, Packet->ContigSize);
    }

    //
    // Get final result from the algorithm.
    //
    Result = alloca(ResultSize);
    (*Alg->Finalize)(Context, SA->Key, Result);
#ifdef IPSEC_DEBUG
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "Recv Key (%d bytes)): ", SA->RawKeyLength));
        DumpKey(SA->RawKey, SA->RawKeyLength);
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "Recv AuthData:\n"));
        dump_encoded_mesg(Result, ResultSize);

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "Sent AuthData:\n"));
        dump_encoded_mesg(AuthData, ResultSize);
#endif

    //
    // Compare result to authentication data in packet.  They should match.
    //
    if (RtlCompareMemory(Result, AuthData, ResultSize) != ResultSize) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "AuthenticationHeaderReceive: Failed integrity check\n"));
        goto ErrorReturn;
    }

    //
    // Restore our packet position (to just after AH Header).
    //
    PacketPullupCleanup(Packet);
    Packet->Position = SavePosition;
    Packet->Data = SaveData;
    Packet->ContigSize = SaveContigSize;
    Packet->TotalSize = SaveTotalSize;
    Packet->AuxList = SaveAuxList;
    SaveAuxList = NULL;

    //
    // Nested AH headers don't include this one in their calculations.
    //
    Packet->SkippedHeaderLength += sizeof(AHHeader) + AHHeaderLen;

    //
    // Add this SA to the list of those that this packet has passed.
    //
    SAPerformed = ExAllocatePool(NonPagedPool, sizeof *SAPerformed);
    if (SAPerformed == NULL) {
      ErrorReturn:
        ReleaseSA(SA);
        if (SaveAuxList != NULL) {
            PacketPullupCleanup(Packet);
            Packet->AuxList = SaveAuxList;
        }
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    SAPerformed->This = SA;
    SAPerformed->Next = Packet->SAPerformed;  // This SA is now first on list.
    SAPerformed->Mode = TRANSPORT;  // Assume trans until we see an IPv6Header.
    Packet->SAPerformed = SAPerformed;

    return AH->NextHeader;
}


//* EncapsulatingSecurityPayloadReceive - Handle an IPv6 ESP header.
//
//  This is the routine called to process an Encapsulating Security Payload,
//  next header value of 50.
//
uchar
EncapsulatingSecurityPayloadReceive(
    IPv6Packet *Packet)      // Packet handed to us by IPv6Receive.
{
    ESPHeader UNALIGNED *ESP;
    ESPTrailer TrailerBuffer;
    ESPTrailer UNALIGNED *ESPT;
    SecurityAssociation *SA;
    PNDIS_BUFFER NdisBuffer;
    SALinkage *SAPerformed;

    //
    // Verify that we have enough contiguous data to overlay an Encapsulating
    // Security Payload Header structure on the incoming packet.  Since the
    // authentication check covers the ESP header, we don't skip over it yet.
    //
    if (! PacketPullup(Packet, sizeof(ESPHeader), 1, 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof(ESPHeader))
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "EncapsulatingSecurityPayloadReceive: "
                       "Incoming packet too small to contain ESP header\n"));
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    ESP = (ESPHeader UNALIGNED *)Packet->Data;

    //
    // Lookup Security Association in the Security Association Database.
    //
    SA = InboundSAFind(net_long(ESP->SPI),
                       AlignAddr(&Packet->IP->Dest),
                       IP_PROTOCOL_ESP);
    if (SA == NULL){
        // No SA exists for this packet.
        // Drop packet.  NOTE: This is an auditable event.
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "EncapsulatingSecurityPayloadReceive: "
                   "No SA found for the packet\n"));
        return IP_PROTOCOL_NONE;
    }

    //
    // Verify the Sequence Number if required to do so by the SA.
    // Since we only support manual keying currently, we treat all SAs
    // as not requiring this check.
    // TBD: Will need to change this when we add support for dynamic
    // TBD: keying (IKE).
    //

    //
    // Perform integrity check if authentication has been selected.
    // TBD: When (if?) we add encryption support, we'll want to check the
    // TBD: SA to see if authentication is desired.  Hardwired for now.
    //
    {
        SecurityAlgorithm *Alg;
        uint AuthDataSize;
        uint PayloadLength;
        void *Context;
        IPv6Packet Clone;
        uint DoNow = 0;
        uchar *AuthData;
        uchar *Result;

        //
        // First ensure that the incoming packet is large enough to hold the
        // Authentication Data required by the algorithm specified in the SA.
        // Then calculate the amount of data covered by authentication.
        //
        Alg = &AlgorithmTable[SA->AlgorithmId];
        AuthDataSize = Alg->ResultSize;
        if (Packet->TotalSize < sizeof(ESPHeader) + sizeof(ESPTrailer) +
            AuthDataSize) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "EncapsulatingSecurityPaylofadReceive: "
                       "Packet too short to hold Authentication Data\n"));
            goto ErrorReturn;
        }
        PayloadLength = Packet->TotalSize - AuthDataSize;

        //
        // Clone the packet positioning information so we can step through
        // the packet without losing our current place.  Start clone with
        // a fresh pullup history, however.
        //
        Clone = *Packet;
        Clone.AuxList = NULL;

#ifdef IPSEC_DEBUG
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "\nESP Receive Data:\n"));
#endif
        //
        // Initialize this particular algorithm.
        //
        Context = alloca(Alg->ContextSize);
        (*Alg->Initialize)(Context, SA->Key);

        //
        // Run algorithm over packet data.
        // ESP authenticates everything beginning with the ESP Header and
        // ending just prior to the Authentication Data.
        //
        while (PayloadLength != 0) {
            DoNow = MIN(PayloadLength, Clone.ContigSize);

#ifdef IPSEC_DEBUG
            dump_encoded_mesg(Clone.Data, DoNow);
#endif
            (*Alg->Operate)(Context, SA->Key, Clone.Data, DoNow);
            if (DoNow < PayloadLength) {
                //
                // Not done yet, must have run out of contiguous data.
                // Get next buffer in packet.
                //
                AdjustPacketParams(&Clone, DoNow);
                PacketPullupSubr(&Clone, 0, 1, 0);  // Moves to next buffer.
            }
            PayloadLength -= DoNow;
        }

        AdjustPacketParams(&Clone, DoNow);

        //
        // Get final result from the algorithm.
        //
        Result = alloca(AuthDataSize);
        (*Alg->Finalize)(Context, SA->Key, Result);

#ifdef IPSEC_DEBUG
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "Calculated AuthData:\n"));
        dump_encoded_mesg(Result, AuthDataSize);
#endif

        //
        // The Authentication Data immediately follows the region of
        // authentication coverage.  So our clone should be positioned
        // at the beginning of it.  Ensure that it's contiguous.
        //
        if (! PacketPullup(&Clone, AuthDataSize, 1, 0)) {
            // Pullup failed.  Should never happen due to earlier check.
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "EncapsulatingSecurityPayloadReceive: "
                       "Incoming packet too small for Auth Data\n"));
            goto ErrorReturn;
        }

        // Point to Authentication data.
        AuthData = Clone.Data;

#ifdef IPSEC_DEBUG
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "Received AuthData:\n"));
        dump_encoded_mesg(AuthData, AuthDataSize);
#endif
        //
        // Compare our result to the Authentication Data.  They should match.
        //
        if (RtlCompareMemory(Result, AuthData, AuthDataSize) != AuthDataSize) {
            //
            // Integrity check failed.  NOTE: This is an auditable event.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "EncapsulatingSecurityPayloadReceive: "
                       "Failed integrity check\n"));
            PacketPullupCleanup(&Clone);
            goto ErrorReturn;
        }

        //
        // Done with the clone, clean up after it.
        //
        PacketPullupCleanup(&Clone);

        //
        // Truncate our packet to no longer include the Authentication Data.
        //
        Packet->TotalSize -= AuthDataSize;
        if (Packet->ContigSize > Packet->TotalSize)
            Packet->ContigSize = Packet->TotalSize;
    }

    //
    // We can consume the ESP Header now since it isn't
    // covered by confidentiality.
    //
    AdjustPacketParams(Packet, sizeof(ESPHeader));

    //
    // Decrypt Packet if confidentiality has been selected.
    // TBD: When (if?) we add encryption support, we'll want to check the
    // TBD: SA to see if encryption is desired.  Hardwired for now.
    //
#if 0
    if (0) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "EncapsulatingSecurityPayloadReceive: "
                   "SA requested confidentiality -- unsupported feature\n"));
        goto ErrorReturn;
    }
#endif

    //
    // Remove trailer and padding (if any).  Note that padding may appear
    // even in the no-encryption case in order to align the Authentication
    // Data on a four byte boundary.
    //
    if (Packet->NdisPacket == NULL) {
        //
        // This packet must be just a single contiguous region.
        // Finding the trailer is a simple matter of arithmetic.
        //
        ESPT = (ESPTrailer UNALIGNED *)
            ((uchar *)Packet->Data + Packet->TotalSize - sizeof(ESPTrailer));
    } else {
        //
        // Need to find the trailer in the Ndis buffer chain.
        //
        NdisQueryPacket(Packet->NdisPacket, NULL, NULL, &NdisBuffer, NULL);
        ESPT = (ESPTrailer UNALIGNED *)
            GetDataFromNdis(NdisBuffer,
                            Packet->Position + Packet->TotalSize -
                                                        sizeof(ESPTrailer),
                            sizeof(ESPTrailer),
                            (uchar *)&TrailerBuffer);
    }
    Packet->TotalSize -= sizeof(ESPTrailer);
    if (ESPT->PadLength > Packet->TotalSize) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "EncapsulatingSecurityPayloadReceive: "
                   "PadLength impossibly large (%u of %u bytes)\n",
                   ESPT->PadLength, Packet->TotalSize));
        goto ErrorReturn;
    }
    // Remember offset to this header's NextHeader field.
    Packet->NextHeaderPosition = Packet->Position + Packet->TotalSize +
        FIELD_OFFSET(ESPTrailer, NextHeader);
    // Remove padding.
    Packet->TotalSize -= ESPT->PadLength;
    if (Packet->ContigSize > Packet->TotalSize)
        Packet->ContigSize = Packet->TotalSize;

    //
    // Encapsulated AH headers don't include this ESP header when
    // authenticating the packet.
    //
    Packet->SkippedHeaderLength += sizeof(ESPHeader) + sizeof(ESPTrailer) +
        ESPT->PadLength;

    //
    // Add this SA to the list of those that this packet has passed.
    //
    SAPerformed = ExAllocatePool(NonPagedPool, sizeof *SAPerformed);
    if (SAPerformed == NULL) {
      ErrorReturn:
        ReleaseSA(SA);
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    SAPerformed->This = SA;
    SAPerformed->Next = Packet->SAPerformed;  // This SA is now first on list.
    SAPerformed->Mode = TRANSPORT;  // Assume trans until we see an IPv6Header.
    SAPerformed->NextHeader = ESPT->NextHeader;
    Packet->SAPerformed = SAPerformed;

    return ESPT->NextHeader;
}


//* InsertSecurityPolicy
//
//  Add a security policy to the global list (a.k.a. "SecurityPolicyList").
//  The global list is doubly-linked, ordered by the index value with the
//  higher numbers (more specific policies) first.
//
//  Called with security lock held.
//
int
InsertSecurityPolicy(
    SecurityPolicy *NewSP)  // Policy to insert.
{
    SecurityPolicy *CurrentSP, *PrevSP;

    //
    // Run through the SP list looking for place to insert.
    //
    CurrentSP = PrevSP = SecurityPolicyList;
    while (CurrentSP != NULL) {
        if (CurrentSP->Index <= NewSP->Index) {
            break;
        }

        // Move down the list.
        PrevSP = CurrentSP;
        CurrentSP = CurrentSP->Next;
    }

    //
    // See where we ended up.
    //
    if (CurrentSP == NULL) {
        //
        // Ran off the end of the list.
        // New entry will become the last element.
        //
        NewSP->Next = NULL;
    } else {
        //
        // Check for duplicate entries.
        //
        if (CurrentSP->Index == NewSP->Index) {
            // A policy with this index value already exists.
            return FALSE;
        }
        //
        // Put new one before 'current'.
        //
        NewSP->Next = CurrentSP;
        NewSP->Prev = CurrentSP->Prev;
        CurrentSP->Prev = NewSP;
    }

    if (CurrentSP == SecurityPolicyList) {
        //
        // Still at the front of the list.
        // New entry becomes new list head.
        //
        NewSP->Prev = NULL;
        SecurityPolicyList = NewSP;
    } else {
        //
        // Add new entry after 'previous'.
        //
        NewSP->Prev = PrevSP;
        PrevSP->Next = NewSP;
    }

    InvalidateSecurityState();

    return TRUE;
}


//* InsertSecurityAssociation - Insert SA entry on SecurityAssociationList.
//
//  Add a security association to the global list.
//  The global list is doubly-linked, ordered by the index value with the
//  higher numbers first.
//  REVIEW: the order is arbitrary - just to look nicer when print out.
//
int
InsertSecurityAssociation(
    SecurityAssociation *NewSA)  // Association to insert.
{
    SecurityAssociation *CurrentSA, *PrevSA;

    //
    // Run through the SA list looking for place to insert.
    //
    CurrentSA = PrevSA = SecurityAssociationList;
    while (CurrentSA != NULL) {
        if (CurrentSA->Index <= NewSA->Index) {
            break;
        }

        // Move down the list.
        PrevSA = CurrentSA;
        CurrentSA = CurrentSA->Next;
    }

    //
    // See where we ended up.
    //
    if (CurrentSA == NULL) {
        //
        // Ran off the end of the list.
        // New entry will become the last element.
        //
        NewSA->Next = NULL;
    } else {
        //
        // Check for duplicate entries.
        //
        if (CurrentSA->Index == NewSA->Index) {
            // An association with this index value already exists.
            return FALSE;
        }
        //
        // Put new one before 'current'.
        //
        NewSA->Next = CurrentSA;
        NewSA->Prev = CurrentSA->Prev;
        CurrentSA->Prev = NewSA;
    }

    if (CurrentSA == SecurityAssociationList) {
        //
        // Still at the front of the list.
        // New entry becomes new list head.
        //
        NewSA->Prev = NULL;
        SecurityAssociationList = NewSA;
    } else {
        //
        // Add new entry after 'previous'.
        //
        NewSA->Prev = PrevSA;
        PrevSA->Next = NewSA;
    }

    InvalidateSecurityState();

    return TRUE;
}


//* FindSecurityPolicyMatch - Find matching SP entry.
//
//  Called with security lock held.
//
SecurityPolicy *
FindSecurityPolicyMatch(
    SecurityPolicy *Start,  // Head of list to search.
    uint InterfaceIndex,    // Interface number to match, 0 to wildcard.
    uint PolicyIndex)       // Policy number to match, 0 to wildcard.
{
    SecurityPolicy *ThisSP;

    //
    // Search the Security Policy List for a match.
    //
    for (ThisSP = Start; ThisSP != NULL; ThisSP = ThisSP->Next) {
        //
        // Desired policy must be wildcarded or match.
        //
        if ((PolicyIndex != 0) && (PolicyIndex != ThisSP->Index))
            continue;
        //
        // Interface must be wildcarded or match.  Note that the policy,
        // as well as the query, may have a wildcarded interface index.
        //
        if ((InterfaceIndex != 0) && (ThisSP->IFIndex != 0) &&
            (InterfaceIndex != ThisSP->IFIndex))
            continue;

        break;  // Match.
    }

    return ThisSP;
}


//* FindSecurityAssociationMatch - Find SA Entry corresponding to index value.
//
//  Called with security lock held.
//
SecurityAssociation *
FindSecurityAssociationMatch(
    ulong Index)  // Association number to match, 0 to wildcard.
{
    SecurityAssociation *ThisSA;

    //
    // Search the Security Association List starting with the first SA.
    //
    for (ThisSA = SecurityAssociationList; ThisSA != NULL;
         ThisSA = ThisSA->Next) {
        //
        // Desired association must be wildcarded or match.
        //
        if ((Index == 0) || (Index == ThisSA->Index))
            break;
    }

    return ThisSA;
}


//* GetSecurityPolicyIndex - Return SP Index or NONE.
//
ulong
GetSecurityPolicyIndex(
    SecurityPolicy *SP)
{
    ulong Index = NONE;

    // Get Index from SP.
    if (SP != NULL) {
        Index = SP->Index;
    }

    return Index;
}


//* IPSecInit - Initialize the Common SPD.
//
int
IPSecInit(void)
{
    SecurityPolicy *SP;

    // Allocate memory for Security Policy.
    SP = ExAllocatePool(NonPagedPool, sizeof *SP);
    if (SP == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPSecInit - couldn't allocate pool for SP!?!\n"));
        return FALSE;
    }

    //
    // Initialize a default common policy that allows everything.
    //
    SP->Next = NULL;
    SP->Prev = NULL;

    SP->RemoteAddrField = WILDCARD_VALUE;
    SP->RemoteAddr = UnspecifiedAddr;
    SP->RemoteAddrData = UnspecifiedAddr;
    SP->RemoteAddrSelector = POLICY_SELECTOR;

    SP->LocalAddrField = WILDCARD_VALUE;
    SP->LocalAddr = UnspecifiedAddr;
    SP->LocalAddrData = UnspecifiedAddr;
    SP->LocalAddrSelector = POLICY_SELECTOR;

    SP->TransportProto = NONE;
    SP->TransportProtoSelector = POLICY_SELECTOR;

    SP->RemotePortField = WILDCARD_VALUE;
    SP->RemotePort = NONE;
    SP->RemotePortData = NONE;
    SP->RemotePortSelector = POLICY_SELECTOR;

    SP->LocalPortField = WILDCARD_VALUE;
    SP->LocalPort = NONE;
    SP->LocalPortData = NONE;
    SP->LocalPortSelector = POLICY_SELECTOR;

    SP->SecPolicyFlag = IPSEC_BYPASS;

    SP->IPSecSpec.Protocol = NONE;
    SP->IPSecSpec.Mode = NONE;
    SP->IPSecSpec.RemoteSecGWIPAddr = UnspecifiedAddr;

    SP->DirectionFlag = BIDIRECTIONAL;
    SP->OutboundSA = NULL;
    SP->InboundSA = NULL;
    SP->SABundle = NULL;
    SP->Index = 1;
    SP->RefCnt = 0;
    SP->IFIndex = 0;

    //
    // Initialize the global Security Policy list with the default policy.
    //
    SecurityPolicyList = SP;

    KeInitializeSpinLock(&IPSecLock);

    //
    // Initialize the security algorithms table.
    //
    AlgorithmsInit();

    return(TRUE);
}


//* IPSecUnload
//
//  Cleanup and prepare for stack unload.
//
void
IPSecUnload(void)
{
    KIRQL OldIrql;

    // Get Security Lock.
    KeAcquireSpinLock(&IPSecLock, &OldIrql);

    //
    // Delete all the policies on the global Security Policy list.
    // This will take out any associations hanging off them as well.
    //
    while (SecurityPolicyList != NULL) {
        DeleteSP(SecurityPolicyList);
    }

    // Release lock.
    KeReleaseSpinLock(&IPSecLock, OldIrql);
}


//* IPSecBytesToInsert
//
uint
IPSecBytesToInsert(
    IPSecProc *IPSecToDo,
    uint *TunnelStart,
    uint *TrailerLength)
{
    uint i, Padding;
    uint BytesInHeader, BytesToInsert = 0, BytesForTrailer = 0;
    SecurityAlgorithm *Alg;
    SecurityAssociation *SA;
    uint IPSEC_TUNNEL = FALSE;

    for (i = 0; i < IPSecToDo->BundleSize; i++) {
        SA = IPSecToDo[i].SA;
        Alg = &AlgorithmTable[SA->AlgorithmId];

        //
        // Calculate bytes to insert for each IPSec header..
        //

        // Check if this is tunnel or transport mode.
        if (IPSecToDo[i].Mode == TUNNEL) {
            // Outer IPv6 header.
            BytesToInsert += sizeof(IPv6Header);

            if (!IPSEC_TUNNEL) {
                // Set the tunnel start location.
                *TunnelStart = i;
                IPSEC_TUNNEL = TRUE;
            }
        }

        // Check which IPSec protocol.
        if (SA->IPSecProto == IP_PROTOCOL_AH) {
            BytesInHeader = (sizeof(AHHeader) + Alg->ResultSize);

            //
            // The AH header must be a integral multiple of 64 bits in length.
            // Check if padding needs to be added to the ICV result to make
            // the Auth Data field a legitimate length.
            //
            Padding = BytesInHeader % 8;
            if (Padding != 0) {
                BytesInHeader += (8 - Padding);
            }
            ASSERT(BytesInHeader % 8 == 0);

        } else {
            BytesInHeader = sizeof(ESPHeader);
            BytesForTrailer += (sizeof(ESPTrailer) + Alg->ResultSize);
        }

        // Store the byte size of the IPSec header.
        IPSecToDo[i].ByteSize = BytesInHeader;

        // Add the IPSec header size to the total bytes to insert.
        BytesToInsert += BytesInHeader;
    }

    // See if our caller wants the trailer length too.
    if (TrailerLength != NULL)
        *TrailerLength = BytesForTrailer;

    return BytesToInsert;
}


//* IPSecInsertHeaders
//
uint
IPSecInsertHeaders(
    uint Mode,              // Transport or Tunnel.
    IPSecProc *IPSecToDo,
    uchar **InsertPoint,
    uchar *NewMemory,
    PNDIS_PACKET Packet,
    uint *TotalPacketSize,
    uchar *PrevNextHdr,
    uint TunnelStart,
    uint *BytesInserted,
    uint *NumESPTrailers,
    uint *JUST_ESP)
{
    uint i, NumHeaders = 0;
    AHHeader *AH;
    ESPHeader *ESP;
    uchar NextHeader;
    uint Padding, j;
    ESPTrailer *ESPTlr;
    PNDIS_BUFFER ESPTlrBuffer;
    uchar *ESPTlrMemory;
    uint ESPTlrBufSize;
    NDIS_STATUS Status;
    SecurityAlgorithm *Alg;
    SecurityAssociation *SA;
    uint Action = LOOKUP_CONT;

    NextHeader = *PrevNextHdr;

    if (Mode == TRANSPORT) {
        i = 0;
        if (TunnelStart != NO_TUNNEL) {
            NumHeaders = TunnelStart;
        } else {
            NumHeaders = IPSecToDo->BundleSize;
        }
    } else {
        // Tunnel.
        i = TunnelStart;
        // Get the end of the tunnels.
        for (j = TunnelStart + 1; j < IPSecToDo->BundleSize; j++) {
            if (IPSecToDo[j].Mode == TUNNEL) {
                // Another tunnel.
                NumHeaders = j;
                break;
            }
        }
        if (NumHeaders == 0) {
            // No other tunnels.
            NumHeaders = IPSecToDo->BundleSize;
        }
    }

    *JUST_ESP = TRUE;

    for (i; i < NumHeaders; i++) {
        SA = IPSecToDo[i].SA;

        if (SA->IPSecProto == IP_PROTOCOL_AH) {
            *JUST_ESP = FALSE;

            // Move insert point up to start of AH Header.
            *InsertPoint -= IPSecToDo[i].ByteSize;

            *BytesInserted += IPSecToDo[i].ByteSize;

            AH = (AHHeader *)(*InsertPoint);

            //
            // Insert AH Header.
            //
            AH->NextHeader = NextHeader;
            // Set previous header's next header field to AH.
            NextHeader = IP_PROTOCOL_AH;
            // Payload length is in 32 bit counts.
            AH->PayloadLen = (IPSecToDo[i].ByteSize / 4) - 2;
            AH->Reserved = 0;
            AH->SPI = net_long(SA->SPI);
            // TBD: Note that when we add support for dynamic keying,
            // TBD: we'll also need to check for sequence number wrap here.
            AH->Seq = net_long(InterlockedIncrement((PLONG)&SA->SequenceNum));

            //
            // Store point where to put AH Auth Data after authentication.
            //
            IPSecToDo[i].AuthData = (*InsertPoint) + sizeof(AHHeader);

            //
            // Zero out Auth Data and padding.
            // The Auth Data value will be filled in later.
            //
            RtlZeroMemory(IPSecToDo[i].AuthData,
                          IPSecToDo[i].ByteSize - sizeof(AHHeader));

        } else {
            // ESP.
            Alg = &AlgorithmTable[SA->AlgorithmId];

            // Move insert point up to start of ESP Header.
            *InsertPoint -= IPSecToDo[i].ByteSize;

            *BytesInserted += IPSecToDo[i].ByteSize;

            ESP = (ESPHeader *)(*InsertPoint);

            //
            // Insert ESP Header.
            //
            ESP->SPI = net_long(SA->SPI);
            // TBD: Note that when we add support for dynamic keying,
            // TBD: we'll also need to check for sequence number wrap here.
            ESP->Seq = net_long(InterlockedIncrement((PLONG)&SA->SequenceNum));

            //
            // Compute padding that needs to be added in ESP Trailer.
            // The PadLength and Next header must end of a 4-byte boundary
            // with respect to the start of the IPv6 header.
            // TotalPacketSize is the length of everything in the original
            // packet from the start of the IPv6 header.
            //
            Padding = *TotalPacketSize % 4;

            if (Padding == 0) {
                Padding = 2;
            } else if (Padding == 2) {
                Padding = 0;
            }

            // Adjust total packet size to account for padding.
            *TotalPacketSize += Padding;

            // Where to start the Authentication for this ESP header.
            IPSecToDo[i].Offset = (uint)((*InsertPoint) - NewMemory);

            ESPTlrBufSize = Padding + sizeof(ESPTrailer) + Alg->ResultSize;

            *BytesInserted += ESPTlrBufSize;

            //
            // Allocate ESP Trailer.
            //
            ESPTlrMemory = ExAllocatePool(NonPagedPool, ESPTlrBufSize);
            if (ESPTlrMemory == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "InsertTransportIPSec: "
                           "Couldn't allocate ESPTlrMemory!?!\n"));
                Action = LOOKUP_DROP;
                break;
            }

            NdisAllocateBuffer(&Status, &ESPTlrBuffer, IPv6BufferPool,
                               ESPTlrMemory, ESPTlrBufSize);
            if (Status != NDIS_STATUS_SUCCESS) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "InsertTransportIPSec: "
                           "Couldn't allocate ESP Trailer buffer!?!\n"));
                ExFreePool(ESPTlrMemory);
                Action = LOOKUP_DROP;
                break;
            }

            // Format Padding.
            for (j = 0; j < Padding; j++) {
                // Add padding.
                *(ESPTlrMemory + j) = j + 1;
            }

            ESPTlr = (ESPTrailer *)(ESPTlrMemory + Padding);

            //
            // Format ESP Trailer.
            //
            ESPTlr->PadLength = (uchar)j;
            ESPTlr->NextHeader = NextHeader;
            // Set previous header's next header field to ESP.
            NextHeader = IP_PROTOCOL_ESP;

            //
            // Store pointer of where to put ESP Authentication Data.
            //
            IPSecToDo[i].AuthData = ESPTlrMemory + Padding +
                sizeof(ESPTrailer);

            // Set Authentication Data to 0s (MUTABLE).
            RtlZeroMemory(IPSecToDo[i].AuthData, Alg->ResultSize);

            // Link the ESP trailer to the back of the buffer chain.
            NdisChainBufferAtBack(Packet, ESPTlrBuffer);

            // Increment the number of ESP trailers present.
            *NumESPTrailers += 1;

        } // end of else
    } // end of for (i; i < NumHeaders; i++)

    *PrevNextHdr = NextHeader;

    return Action;
}


//* IPSecAdjustMutableFields
//
uint
IPSecAdjustMutableFields(
    uchar *Data,
    IPv6RoutingHeader *SavedRtHdr)
{
    uint i;
    uchar NextHeader;
    IPv6Header UNALIGNED *IP;

    //
    // Walk original buffer starting at IP header and continuing to the end
    // of the mutable headers, zeroing the mutable fields.
    //

    IP = (IPv6Header UNALIGNED *)Data;

    // In VersClassFlow, only the IP version is immutable, so zero the rest.
    IP->VersClassFlow = IP_VERSION;

    // Hop limit is mutable.
    IP->HopLimit = 0;

    NextHeader = IP->NextHeader;

    Data = (uchar *)(IP + 1);

    //
    // Loop through the original headers.  Zero out the mutable fields.
    //
    for (;;) {
        switch (NextHeader) {

        case IP_PROTOCOL_AH:
        case IP_PROTOCOL_ESP:
            // done.
            return LOOKUP_CONT;

        case IP_PROTOCOL_HOP_BY_HOP:
        case IP_PROTOCOL_DEST_OPTS: {
            IPv6OptionsHeader *NewOptHdr;
            uint HdrLen, Amount;
            uchar *Current;

            NewOptHdr = (IPv6OptionsHeader *)Data;
            HdrLen = (NewOptHdr->HeaderExtLength + 1) * EXT_LEN_UNIT;
            Data += HdrLen;

            //
            // Run through options to see if any are mutable.
            //
            Current = (uchar *)NewOptHdr + sizeof(IPv6OptionsHeader);
            HdrLen -= sizeof(IPv6OptionsHeader);
            while (HdrLen) {
                if (*Current == OPT6_PAD_1) {
                    //
                    // This is the special one byte pad option.  Immutable.
                    //
                    Current++;
                    HdrLen--;
                    continue;
                }

                if (OPT6_ISMUTABLE(*Current)) {
                    //
                    // This option's data is mutable.  Everything preceeding
                    // the option data is not.
                    //
                    Current++;  // Now on option data length byte.
                    Amount = *Current;  // Mutable amount.
                    Current++;  // Now on first data byte.
                    RtlZeroMemory(Current, Amount);

                    HdrLen -= Amount + 2;
                    Current += Amount;

                } else {
                    //
                    // This option's data is not mutable.
                    // Just skip over it.
                    //
                    Current++;  // Now on option data length byte.
                    Amount = *Current;
                    HdrLen -= Amount + 2;
                    Current += Amount + 1;
                }
            }

            NextHeader = NewOptHdr->NextHeader;

            break;
        }
        case IP_PROTOCOL_ROUTING: {
            IPv6RoutingHeader *NewRtHdr;
            IPv6Addr *RecvRtAddr, *SendRtAddr;

            // Verify there is a SavedRtHdr.
            if (SavedRtHdr == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                           "IPSecAdjustMutableFields: "
                           "No Saved routing header"));
                return LOOKUP_DROP;
            }

            // Point to the saved first routing address.
            SendRtAddr = (IPv6Addr *)(SavedRtHdr + 1);

            // New buffer routing header.
            NewRtHdr = (IPv6RoutingHeader *)Data;
            // Point to the first routing address.
            RecvRtAddr = (IPv6Addr *)(NewRtHdr + 1);

            NewRtHdr->SegmentsLeft = 0;

            // Copy the IP dest addr to first routing address.
            RtlCopyMemory(RecvRtAddr, &IP->Dest, sizeof(IPv6Addr));

            for (i = 0; i < (uint)(SavedRtHdr->SegmentsLeft - 1); i++) {
                //
                // Copy the routing addresses as they will look
                // at receive.
                //
                RtlCopyMemory(&RecvRtAddr[i+1], &SendRtAddr[i],
                              sizeof(IPv6Addr));
            }

            // Copy the last routing address to the IP dest address.
            RtlCopyMemory(&IP->Dest, &SendRtAddr[i], sizeof(IPv6Addr));

            Data += (NewRtHdr->HeaderExtLength + 1) * 8;
            NextHeader = NewRtHdr->NextHeader;
            break;
        }
        default:
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "IPSecAdjustMutableFields: Don't support header %d\n",
                       NextHeader));
            return LOOKUP_DROP;
        }// end of switch(NextHeader);
    } // end of for (;;)
}


//* IPSecAuthenticatePacket
//
void
IPSecAuthenticatePacket(
    uint Mode,
    IPSecProc *IPSecToDo,
    uchar *InsertPoint,
    uint *TunnelStart,
    uchar *NewMemory,
    uchar *EndNewMemory,
    PNDIS_BUFFER NewBuffer1)
{
    uchar *Data;
    uint i, NumHeaders = 0, DataLen, j;
    void *Context;
    void *VirtualAddr;
    PNDIS_BUFFER NextBuffer;
    SecurityAlgorithm *Alg;
    SecurityAssociation *SA;

    if (Mode == TRANSPORT) {
        i = 0;
        if (*TunnelStart != NO_TUNNEL) {
            NumHeaders = *TunnelStart;
        } else {
            NumHeaders = IPSecToDo->BundleSize;
        }
    } else {
        // Tunnel.
        i = *TunnelStart;
        // Get the end of the tunnels.
        for (j = *TunnelStart + 1; j < IPSecToDo->BundleSize; j++) {
            if (IPSecToDo[j].Mode == TUNNEL) {
                // Another tunnel.
                NumHeaders = j;
                break;
            }
        }
        if (NumHeaders == 0) {
            // No other tunnels.
            NumHeaders = IPSecToDo->BundleSize;
        }

        // Set TunnelStart for loop in IPv6Send2().
        *TunnelStart = NumHeaders;
    }

    for (i; i < NumHeaders; i++) {
        SA = IPSecToDo[i].SA;
        Alg = &AlgorithmTable[SA->AlgorithmId];

        if (SA->IPSecProto == IP_PROTOCOL_AH) {
            uint FirstIPSecHeader = NumHeaders - 1;

            // AH starts at the IP header.
            Data = InsertPoint;

            //
            // Check if there are other IPSec headers after this in the 
            // same IP area (IP_"after"<IP Area>_Data).  Other IPSec headers
            // need to be ignored in the authentication calculation.
            // NOTE: This is not a required IPSec header combination.
            //
            if (i < FirstIPSecHeader) {
                uchar *StopPoint;
                uint n;

                n = i + 1;

                //
                // There are some other IPSec headers.
                // Need to authenticate from the IP header to
                // the last header before the first IPSec header hit.
                // Then if there is no ESP, just authenticate from the
                // current IPSec header to the end of the packet.
                // If there is ESP, need to ignore the ESP trailers.
                //

                //
                // Calculate start of first IPSec header.
                //
                if (IPSecToDo[FirstIPSecHeader].SA->IPSecProto ==
                    IP_PROTOCOL_AH) {
                    StopPoint = (IPSecToDo[FirstIPSecHeader].AuthData -
                                 sizeof(AHHeader));
                } else {
                    StopPoint = NewMemory + IPSecToDo[FirstIPSecHeader].Offset;
                }

                // Length from IP to first IPSec header.
                DataLen = (uint)(StopPoint - Data);

                // Initialize Context.
                Context = alloca(Alg->ContextSize);
                (*Alg->Initialize)(Context, SA->Key);

                // Authentication to the first IPSec header.
                (*Alg->Operate)(Context, SA->Key, Data, DataLen);

                // Set the data start to the current IPSec header.
                Data = IPSecToDo[i].AuthData - sizeof(AHHeader);
                DataLen = (uint)(EndNewMemory - Data);

                //
                // Authenticate from current IPSec header to the
                // end of the new allocated buffer.
                //
                (*Alg->Operate)(Context, SA->Key, Data, DataLen);

                //
                // Need to authenticate other buffers if there are any.
                // Ignore the ESP trailers.
                //

                // Check for an ESP header closest to the current IPSec header.
                while (n < NumHeaders) {
                    if (IPSecToDo[n].SA->IPSecProto == IP_PROTOCOL_ESP) {
                        break;
                    }
                    n++;
                }

                // Get the next buffer in the packet.
                NdisGetNextBuffer(NewBuffer1, &NextBuffer);

                while (NextBuffer != NULL) {
                    // Get the start of the data and the data length.
                    NdisQueryBuffer(NextBuffer, &VirtualAddr, &DataLen);
                    Data = (uchar *)VirtualAddr;

                    //
                    // Check if this is the ESP Trailer by seeing if the
                    // AuthData storage is in the buffer.
                    //
                    if (n < NumHeaders)
                    if (IPSecToDo[n].AuthData > Data &&
                        IPSecToDo[n].AuthData < (Data + DataLen)) {

                        // Stop here this is the ESP trailer.
                        break;
                    }

                    // Feed the buffer to the Authentication function.
                    (*Alg->Operate)(Context, SA->Key, Data, DataLen);

                    // Get the next buffer in the packet.
                    NdisGetNextBuffer(NextBuffer, &NextBuffer)
                } // end of while (NextBuffer != NULL)

                // Get the Authentication Data.
                (*Alg->Finalize)(Context, SA->Key, IPSecToDo[i].AuthData);

                // Resume loop for other IPSec headers.
                continue;
            }
        } else { // ESP.
            // ESP starts the authentication at the ESP header.
            Data = NewMemory + IPSecToDo[i].Offset;
        }

        DataLen = (uint)(EndNewMemory - Data);

        // Initialize Context.
        Context = alloca(Alg->ContextSize);
        (*Alg->Initialize)(Context, SA->Key);

#ifdef IPSEC_DEBUG
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "\nSend Data[%d]:\n", i));
        dump_encoded_mesg(Data, DataLen);
#endif

        // Feed the new buffer to the Authentication function.
        (*Alg->Operate)(Context, SA->Key, Data, DataLen);

        // Get the next buffer in the packet.
        NdisGetNextBuffer(NewBuffer1, &NextBuffer);

        while (NextBuffer != NULL) {
            // Get the start of the data and the data length.
            NdisQueryBuffer(NextBuffer, &VirtualAddr, &DataLen);
            Data = (uchar *)VirtualAddr;

            //
            // Check if this is the ESP Trailer by seeing if the
            // AuthData storage is in the buffer.
            //
            if (SA->IPSecProto == IP_PROTOCOL_ESP &&
                IPSecToDo[i].AuthData > Data &&
                IPSecToDo[i].AuthData < (Data + DataLen)) {
                // Don't include the Authentication Data
                // in the ICV calculation.
                DataLen = (uint)(IPSecToDo[i].AuthData - Data);
#ifdef IPSEC_DEBUG
                dump_encoded_mesg(Data, DataLen);
#endif
                // Feed the buffer to the Authentication function.
                (*Alg->Operate)(Context, SA->Key, Data, DataLen);
                break;
            }
#ifdef IPSEC_DEBUG
            dump_encoded_mesg(Data, DataLen);
#endif
            // Feed the buffer to the Authentication function.
            (*Alg->Operate)(Context, SA->Key, Data, DataLen);

            // Get the next buffer in the packet.
            NdisGetNextBuffer(NextBuffer, &NextBuffer)
        } // end of while (NextBuffer != NULL)

        // Get the Authentication Data.
        (*Alg->Finalize)(Context, SA->Key, IPSecToDo[i].AuthData);

#ifdef IPSEC_DEBUG
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "Send Key (%d bytes): ", SA->RawKeyLength));
        DumpKey(SA->RawKey, SA->RawKeyLength);
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_IPSEC,
                   "Send AuthData:\n"));
        dump_encoded_mesg(IPSecToDo[i].AuthData, Alg->ResultSize);
#endif
    } // end of for (i = 0; ...)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\select.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Source address selection and destination address ordering.
//

#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "route.h"
#include "select.h"

KSPIN_LOCK SelectLock;
PrefixPolicyEntry *PrefixPolicyTable;
PrefixPolicyEntry PrefixPolicyNull;

//* InitSelect
//
//  Initialize the address selection module.
//
void
InitSelect(void)
{
    KeInitializeSpinLock(&SelectLock);

    //
    // The default prefix policy, when nothing in the table matches.
    // (Normally there will be a ::/0 policy.)
    //
    PrefixPolicyNull.Precedence = (uint) -1;
    PrefixPolicyNull.SrcLabel = (uint) -1;
    PrefixPolicyNull.DstLabel = (uint) -1;

    //
    // Configure persistent policies from the registry.
    //
    ConfigurePrefixPolicies();
}


//* UnloadSelect
//
//  Called when the IPv6 stack is unloading.
//
void
UnloadSelect(void)
{
    PrefixPolicyReset();
}


//* PrefixPolicyReset
//
//  Deletes all prefix policies.
//  Called with no locks held.
//
void
PrefixPolicyReset(void)
{
    PrefixPolicyEntry *List;
    PrefixPolicyEntry *PPE;
    KIRQL OldIrql;

    //
    // Free the prefix policies.
    //
    KeAcquireSpinLock(&SelectLock, &OldIrql);
    List = PrefixPolicyTable;
    PrefixPolicyTable = NULL;
    KeReleaseSpinLock(&SelectLock, OldIrql);

    while ((PPE = List) != NULL) {
        List = PPE->Next;
        ExFreePool(PPE);
    }
}


//* PrefixPolicyUpdate
//
//  Updates the prefix policy table by creating a new policy entry
//  or updating an existing entry.
//
void
PrefixPolicyUpdate(
    const IPv6Addr *PolicyPrefix,
    uint PrefixLength,
    uint Precedence,
    uint SrcLabel,
    uint DstLabel)
{
    IPv6Addr Prefix;
    PrefixPolicyEntry *PPE;
    KIRQL OldIrql;

    ASSERT((Precedence != (uint)-1) &&
           (SrcLabel != (uint)-1) &&
           (DstLabel != (uint)-1));

    //
    // Ensure that the unused prefix bits are zero.
    // This makes the prefix comparisons below safe.
    //
    CopyPrefix(&Prefix, PolicyPrefix, PrefixLength);

    KeAcquireSpinLock(&SelectLock, &OldIrql);

    for (PPE = PrefixPolicyTable; ; PPE = PPE->Next) {

        if (PPE == NULL) {
            //
            // The prefix policy does not exist, so create it.
            //
            PPE = ExAllocatePool(NonPagedPool, sizeof *PPE);
            if (PPE == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "PrefixPolicyUpdate: out of pool\n"));
                break;
            }

            PPE->Prefix = Prefix;
            PPE->PrefixLength = PrefixLength;
            PPE->Precedence = Precedence;
            PPE->SrcLabel = SrcLabel;
            PPE->DstLabel = DstLabel;

            PPE->Next = PrefixPolicyTable;
            PrefixPolicyTable = PPE;
            break;
        }

        if ((PPE->PrefixLength == PrefixLength) &&
            IP6_ADDR_EQUAL(&PPE->Prefix, &Prefix)) {
            //
            // Update the existing policy.
            //
            PPE->Precedence = Precedence;
            PPE->SrcLabel = SrcLabel;
            PPE->DstLabel = DstLabel;
            break;
        }
    }

    KeReleaseSpinLock(&SelectLock, OldIrql);
}


//* PrefixPolicyDelete
//
//  Updates the prefix policy table by deleting a policy entry.
//
void
PrefixPolicyDelete(
    const IPv6Addr *PolicyPrefix,
    uint PrefixLength)
{
    IPv6Addr Prefix;
    PrefixPolicyEntry **PrevPPE;
    PrefixPolicyEntry *PPE;
    KIRQL OldIrql;

    //
    // Ensure that the unused prefix bits are zero.
    // This makes the prefix comparisons below safe.
    //
    CopyPrefix(&Prefix, PolicyPrefix, PrefixLength);

    KeAcquireSpinLock(&SelectLock, &OldIrql);

    for (PrevPPE = &PrefixPolicyTable; ; PrevPPE = &PPE->Next) {
        PPE = *PrevPPE;

        if (PPE == NULL) {
            //
            // The prefix policy does not exist, so do nothing.
            //
            break;
        }

        if ((PPE->PrefixLength == PrefixLength) &&
            IP6_ADDR_EQUAL(&PPE->Prefix, &Prefix)) {
            //
            // Delete the prefix policy.
            //
            *PrevPPE = PPE->Next;
            ExFreePool(PPE);
            break;
        }
    }

    KeReleaseSpinLock(&SelectLock, OldIrql);
}

void
PrefixPolicyLookup(
    const IPv6Addr *Addr,
    uint *Precedence,
    uint *SrcLabel,
    uint *DstLabel)
{
    PrefixPolicyEntry *PPE, *BestPPE = NULL;
    KIRQL OldIrql;

    KeAcquireSpinLock(&SelectLock, &OldIrql);

    for (PPE = PrefixPolicyTable; PPE != NULL; PPE = PPE->Next) {

        if (HasPrefix(Addr, &PPE->Prefix, PPE->PrefixLength)) {

            if ((BestPPE == NULL) ||
                (BestPPE->PrefixLength < PPE->PrefixLength)) {
                //
                // So far this is our best match.
                //
                BestPPE = PPE;
            }
        }
    }

    if (BestPPE == NULL) {
        //
        // There were no matches, so return default values.
        //
        BestPPE = &PrefixPolicyNull;
    }

    //
    // Return information from the best matching policy.
    //
    if (Precedence != NULL)
        *Precedence = BestPPE->Precedence;
    if (SrcLabel != NULL)
        *SrcLabel = BestPPE->SrcLabel;
    if (DstLabel != NULL)
        *DstLabel = BestPPE->DstLabel;

    KeReleaseSpinLock(&SelectLock, OldIrql);
}

//* FindBestSourceAddress
//
//  Given an outgoing interface and a destination address,
//  finds the best source address (NTE) to use.
//
//  May be called with the route cache lock held.
//
//  If found, returns a reference for the NTE.
//
NetTableEntry *
FindBestSourceAddress(
    Interface *IF,              // Interface we're sending from.
    const IPv6Addr *Dest)       // Destination we're sending to.
{
    NetTableEntry *BestNTE = NULL;
    ushort DestScope;
    uint Length, BestLength = 0;
    uint DstLabel, SrcLabel, BestSrcLabel = 0;
    AddressEntry *ADE;
    NetTableEntry *NTE;
    KIRQL OldIrql;

    DestScope = AddressScope(Dest);

    PrefixPolicyLookup(Dest, NULL, NULL, &DstLabel);

    KeAcquireSpinLock(&IF->Lock, &OldIrql);

    for (ADE = IF->ADE; ADE != NULL; ADE = ADE->Next) {
        NTE = (NetTableEntry *)ADE;

        //
        // Only consider valid (preferred & deprecated) unicast addresses.
        //
        if ((NTE->Type == ADE_UNICAST) && IsValidNTE(NTE)) {

            Length = CommonPrefixLength(Dest, &NTE->Address);
            if (Length == IPV6_ADDRESS_LENGTH) {
                //
                // Rule 1: Prefer same address.
                // No need to keep looking.
                //
                BestNTE = NTE;
                break;
            }

            PrefixPolicyLookup(&NTE->Address, NULL, &SrcLabel, NULL);

            if (BestNTE == NULL) {
                //
                // We don't have a choice yet, so take what we can get.
                //
            FoundAddress:
                BestNTE = NTE;
                BestSrcLabel = SrcLabel;
                BestLength = Length;
            }
            else if (BestNTE->Scope != NTE->Scope) {
                //
                // Rule 2: Prefer appropriate scope.
                // If one is bigger & one smaller than the destination,
                // we should use the address that is bigger.
                // If both are bigger than the destination,
                // we should use the address with smaller scope.
                // If both are smaller than the destination,
                // we should use the address with larger scope.
                //
                if (BestNTE->Scope < NTE->Scope) {
                    if (BestNTE->Scope < DestScope)
                        goto FoundAddress;
                }
                else {
                    if (DestScope <= NTE->Scope)
                        goto FoundAddress;
                }
            }
            else if (BestNTE->DADState != NTE->DADState) {
                //
                // Rule 3: Avoid deprecated addresses.
                //
                if (BestNTE->DADState < NTE->DADState)
                    goto FoundAddress;
            }
                //
                // Rule 4: Prefer home addresses.
                // Not yet implemented, pending mobility support.
                //
                // Rule 5: Prefer outgoing interface.
                // Not needed, because we only consider addresses
                // assigned to the outgoing interface.
                //
            else if ((BestSrcLabel == DstLabel) != (SrcLabel == DstLabel)) {
                //
                // Rule 6: Prefer matching label.
                // One source address has a label matching
                // the destination, and the other doesn't.
                // Choose the one with the matching label.
                //
                if (SrcLabel == DstLabel)
                    goto FoundAddress;
            }
            else if ((BestNTE->AddrConf == ADDR_CONF_TEMPORARY) !=
                     (NTE->AddrConf == ADDR_CONF_TEMPORARY)) {
                //
                // Rule 7: Prefer temporary addresses.
                //
                if (NTE->AddrConf == ADDR_CONF_TEMPORARY)
                    goto FoundAddress;
            }
            else {
                //
                // Rule 8: Use longest matching prefix.
                //
                if (BestLength < Length)
                    goto FoundAddress;
            }
        }
    }

    if (BestNTE != NULL)
        AddRefNTE(BestNTE);

    KeReleaseSpinLock(&IF->Lock, OldIrql);

    return BestNTE;
}

//* ProcessSiteLocalAddresses
//
//  Examines the input array of addresses
//  and either removes unqualified site-local addresses
//  or qualifies them with the appropriate site scope-id,
//  depending on whether there are any global addresses
//  in the array that match in the site prefix table.
//
//  Rearranges the key array, not the input address array.
//  Modifies the scope-ids of site-local addresses in the array.
//
void
ProcessSiteLocalAddresses(
    TDI_ADDRESS_IP6 *Addrs,
    uint *Key,
    uint *pNumAddrs)
{
    uint NumAddrs = *pNumAddrs;
    int SawSiteLocal = FALSE;
    int SawGlobal = FALSE;
    uint i;

    //
    // First see if there are unqualified site-local addresses
    // and global addresses in the array.
    //
    for (i = 0; i < NumAddrs; i++) {
        TDI_ADDRESS_IP6 *Tdi = &Addrs[Key[i]];
        IPv6Addr *Addr = (IPv6Addr *) &Tdi->sin6_addr;

        if (IsGlobal(Addr))
            SawGlobal = TRUE;
        else if (IsSiteLocal(Addr)) {
            if (Tdi->sin6_scope_id == 0)
                SawSiteLocal = TRUE;
        }
    }

    if (SawSiteLocal && SawGlobal) {
        uint ScopeId = 0;

        //
        // Check the global addresses against the site-prefix table,
        // to determine the appropriate site scope-id.
        // If we don't find a matching global address,
        // we remove the site-local addresses.
        // If we do find matching global addresses
        // (all with the same site scope-id),
        // then we update the site-local addresses' scope-id.
        //

        for (i = 0; i < NumAddrs; i++) {
            TDI_ADDRESS_IP6 *Tdi = &Addrs[Key[i]];
            IPv6Addr *Addr = (IPv6Addr *) &Tdi->sin6_addr;

            if (IsGlobal(Addr)) {
                uint ThisScopeId;

                ThisScopeId = SitePrefixMatch(Addr);
                if (ThisScopeId != 0) {
                    //
                    // This global address matches a site prefix.
                    //
                    if (ScopeId == 0) {
                        //
                        // Save the scope-id, but keep looking.
                        //
                        ScopeId = ThisScopeId;
                    }
                    else if (ScopeId != ThisScopeId) {
                        //
                        // We have found an inconsistency, so remove
                        // all unqualified site-local addresses.
                        //
                        ScopeId = 0;
                        break;
                    }
                }
            }
        }

        if (ScopeId == 0) {
            uint j = 0;

            //
            // Remove all unqualified site-local addresses.
            //
            for (i = 0; i < NumAddrs; i++) {
                TDI_ADDRESS_IP6 *Tdi = &Addrs[Key[i]];
                IPv6Addr *Addr = (IPv6Addr *) &Tdi->sin6_addr;

                if (IsSiteLocal(Addr) &&
                    (Tdi->sin6_scope_id == 0)) {
                    //
                    // Exclude this address from the key array.
                    //
                    ;
                }
                else {
                    //
                    // Include this address in the key array.
                    //
                    Key[j++] = Key[i];
                }
            }
            *pNumAddrs = j;
        }
        else {
            //
            // Set the scope-id of unqualified site-local addresses.
            //
            for (i = 0; i < NumAddrs; i++) {
                TDI_ADDRESS_IP6 *Tdi = &Addrs[Key[i]];
                IPv6Addr *Addr = (IPv6Addr *) &Tdi->sin6_addr;

                if (IsSiteLocal(Addr) &&
                    (Tdi->sin6_scope_id == 0))
                    Tdi->sin6_scope_id = ScopeId;
            }
        }
    }
}

//
//  Records some information about a destination address:
//  Its precedence, whether the preferred source address
//  for the destination "matches" the destination,
//  and if it does match, the common prefix length
//  of the two addresses.
//
typedef struct SortAddrInfo {
    uint Preference;
    uint Precedence;            // -1 indicates no precedence.
    ushort Scope;
    uchar Flags;
    uchar CommonPrefixLen;      // Valid if not SAI_FLAG_DONTUSE.
} SortAddrInfo;

#define SAI_FLAG_DONTUSE        0x1
#define SAI_FLAG_SCOPE_MISMATCH 0x2
#define SAI_FLAG_DEPRECATED     0x4
#define SAI_FLAG_LABEL_MISMATCH 0x8

//* CompareSortAddrInfo
//
//  Compares two addresses A & B and returns
//  an indication of their relative desirability
//  as destination addresses:
//  >0 means A is preferred,
//  0 means no preference,
//  <0 means B is preferred.
//
//  Instead of looking directly at the addresses,
//  we look at some precomputed information.
//
int
CompareSortAddrInfo(SortAddrInfo *A, SortAddrInfo *B)
{
    //
    // Rule 1: Avoid unusable destinations.
    //
    if (A->Flags & SAI_FLAG_DONTUSE) {
        if (B->Flags & SAI_FLAG_DONTUSE)
            return 0;   // No preference.
        else
            return -1;  // Prefer B.
    }
    else {
        if (B->Flags & SAI_FLAG_DONTUSE)
            return 1;   // Prefer A.
        else
            ;           // Fall through to code below.
    }

    if ((A->Flags & SAI_FLAG_SCOPE_MISMATCH) !=
                        (B->Flags & SAI_FLAG_SCOPE_MISMATCH)) {
        //
        // Rule 2: Prefer matching scope.
        //
        if (A->Flags & SAI_FLAG_SCOPE_MISMATCH)
            return -1;  // Prefer B.
        else
            return 1;   // Prefer A.
    }

    if ((A->Flags & SAI_FLAG_DEPRECATED) !=
                        (B->Flags & SAI_FLAG_DEPRECATED)) {
        //
        // Rule 3: Avoid deprecated addresses.
        //
        if (A->Flags & SAI_FLAG_DEPRECATED)
            return -1;  // Prefer B.
        else
            return 1;   // Prefer A.
    }

    //
    // Rule 4: Prefer home addresses.
    // Not yet implemented, pending mobility support.
    //

    if ((A->Flags & SAI_FLAG_LABEL_MISMATCH) !=
                        (B->Flags & SAI_FLAG_LABEL_MISMATCH)) {
        //
        // Rule 5: Prefer matching label.
        //
        if (A->Flags & SAI_FLAG_LABEL_MISMATCH)
            return -1;  // Prefer B.
        else
            return 1;   // Prefer A.
    }

    if ((A->Precedence != (uint)-1) &&
        (B->Precedence != (uint)-1) &&
        (A->Precedence != B->Precedence)) {
        //
        // Rule 6: Prefer higher precedence.
        //
        if (A->Precedence > B->Precedence)
            return 1;   // Prefer A.
        else
            return -1;  // Prefer B.
    }

    if (A->Preference != B->Preference) {
        //
        // Rule 7: Prefer *lower* preference.
        // For example, this is used to prefer destinations reached via
        // physical (native) interfaces over virtual (tunnel) interfaces.
        //
        if (A->Preference < B->Preference)
            return 1;   // Prefer A.
        else
            return -1;  // Prefer B.
    }

    if (A->Scope != B->Scope) {
        //
        // Rule 8: Prefer smaller scope.
        //
        if (A->Scope < B->Scope)
            return 1;   // Prefer A.
        else
            return -1;  // Prefer B.
    }

    if (A->CommonPrefixLen != B->CommonPrefixLen) {
        //
        // Rule 9: Use longest matching prefix.
        //
        if (A->CommonPrefixLen > B->CommonPrefixLen)
            return 1;   // Prefer A.
        else
            return -1;  // Prefer B.
    }

    //
    // We have no preference.
    //
    return 0;
}

//* SortDestAddresses
//
//  Sorts the input array of addresses,
//  from most preferred destination to least preferred.
//
//  The address array is read-only;
//  the Key array of indices is sorted.
//
void
SortDestAddresses(
    const TDI_ADDRESS_IP6 *Addrs,
    uint *Key,
    uint NumAddrs)
{
    SortAddrInfo *Info;
    uint i, j;

    Info = ExAllocatePool(NonPagedPool, sizeof *Info * NumAddrs);
    if (Info == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "SortDestAddresses: no pool\n"));
        return;
    }

    //
    // Calculate some information about each destination address.
    // This will be the basis for our sort.
    //

    for (i = 0; i < NumAddrs; i++) {
        SortAddrInfo *info = &Info[i];
        const TDI_ADDRESS_IP6 *Tdi = &Addrs[Key[i]];
        const IPv6Addr *Addr = (const IPv6Addr *) &Tdi->sin6_addr;
        uint DstLabel, SrcLabel;

        //
        // Lookup the precedence of this destination address and
        // the desired label for source addresses used
        // with this destination.
        //
        PrefixPolicyLookup(Addr, &info->Precedence, NULL, &DstLabel);

        if (IsV4Mapped(Addr)) {
            IPAddr V4Dest = ExtractV4Address(Addr);
            IPAddr V4Source;

            info->Scope = V4AddressScope(V4Dest);

            if (TunnelGetSourceAddress(V4Dest, &V4Source)) {
                IPv6Addr Source;

                //
                // Create an IPv4-mapped address.
                //
                CreateV4Mapped(&Source, V4Source);

                info->Flags = 0;
                info->CommonPrefixLen = (uchar)
                    CommonPrefixLength(Addr, &Source);

                if (V4AddressScope(V4Source) != info->Scope)
                    info->Flags |= SAI_FLAG_SCOPE_MISMATCH;

                //
                // Lookup the label of the preferred source address.
                //
                PrefixPolicyLookup(&Source, NULL, &SrcLabel, NULL);

                //
                // We do not know interface/route metrics
                // for IPv4, so just use zero.
                //
                info->Preference = 0;

                if ((DstLabel != (uint)-1) &&
                    (SrcLabel != (uint)-1) &&
                    (DstLabel != SrcLabel)) {
                    //
                    // The best source address for this destination
                    // does not match the destination.
                    //
                    info->Flags |= SAI_FLAG_LABEL_MISMATCH;
                }
            }
            else
                info->Flags = SAI_FLAG_DONTUSE;
        }
        else {
            RouteCacheEntry *RCE;

            info->Scope = AddressScope(Addr);

            //
            // Find the preferred source address for this destination.
            //
            if (RouteToDestination(Addr, Tdi->sin6_scope_id,
                                   NULL, 0, &RCE) == IP_SUCCESS) {
                const IPv6Addr *Source = &RCE->NTE->Address;
                Interface *IF = RCE->NCE->IF;

                info->Flags = 0;
                info->CommonPrefixLen = (uchar)
                    CommonPrefixLength(Addr, Source);

                if (RCE->NTE->Scope != info->Scope)
                    info->Flags |= SAI_FLAG_SCOPE_MISMATCH;

                if (RCE->NTE->DADState != DAD_STATE_PREFERRED)
                    info->Flags |= SAI_FLAG_DEPRECATED;

                //
                // Lookup the label of the preferred source address.
                //
                PrefixPolicyLookup(Source, NULL, &SrcLabel, NULL);

                //
                // REVIEW - Instead of using interface preference,
                // would it be better to cache interface+route preference
                // in the RCE?
                //
                info->Preference = IF->Preference;

                //
                // If the next-hop is definitely unreachable,
                // then we don't want to use this destination.
                // NB: No locking here, this is a heuristic check.
                //
                if ((IF->Flags & IF_FLAG_MEDIA_DISCONNECTED) ||
                    RCE->NCE->IsUnreachable)
                    info->Flags |= SAI_FLAG_DONTUSE;

                ReleaseRCE(RCE);

                if ((DstLabel != (uint)-1) &&
                    (SrcLabel != (uint)-1) &&
                    (DstLabel != SrcLabel)) {
                    //
                    // The best source address for this destination
                    // does not match the destination.
                    //
                    info->Flags |= SAI_FLAG_LABEL_MISMATCH;
                }
            }
            else
                info->Flags = SAI_FLAG_DONTUSE;
        }
    }

    //
    // Perform the actual sort operation.
    // Because we expect NumAddrs to be small,
    // we use a simple quadratic sort.
    //
    ASSERT(NumAddrs > 0);
    for (i = 0; i < NumAddrs - 1; i++) {
        for (j = i + 1; j < NumAddrs; j++) {
            int Compare;

            //
            // As a tie-breaker, if the comparison function
            // has no preference we look at the original
            // position of the two addresses and prefer
            // the one that came first.
            //
            Compare = CompareSortAddrInfo(&Info[i], &Info[j]);
            if ((Compare < 0) ||
                ((Compare == 0) && (Key[j] < Key[i]))) {
                uint TempKey;
                SortAddrInfo TempInfo;

                //
                // Address j is preferred over address i,
                // so swap addresses i & j to put j first.
                //
                TempKey = Key[i];
                Key[i] = Key[j];
                Key[j] = TempKey;

                //
                // We also have to swap the address info.
                //
                TempInfo = Info[i];
                Info[i] = Info[j];
                Info[j] = TempInfo;
            }
        }
    }

    ExFreePool(Info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\receive.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Receive routines for Internet Protocol Version 6.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "icmp.h"
#include "route.h"
#include "fragment.h"
#include "mobile.h"
#include "security.h"
#include "info.h"

#include "ipsec.h"

struct ReassemblyList ReassemblyList;

typedef struct Options {
    uint JumboLength;             // Length of packet excluding IPv6 header.
    IPv6RouterAlertOption UNALIGNED *Alert;
    IPv6HomeAddressOption UNALIGNED *HomeAddress;
    IPv6BindingUpdateOption UNALIGNED *BindingUpdate;
} Options;

int  
ParseOptions(
    IPv6Packet *Packet,     // The packet handed to us by IPv6Receive.
    uchar HdrType,          // Hop-by-hop or destination.
    IPv6OptionsHeader *Hdr, // Header with following data.
    uint HdrLength,         // Length of the entire options area.
    Options *Opts);         // Return option values to caller.

extern void TCPRcvComplete(void);

//* IPv6ReceiveComplete - Handle a receive complete.
//
//  Called by the lower layer when receives are temporarily done.
//
void
IPv6ReceiveComplete(void)
{
    // REVIEW: Original IP implementation had code here to call every
    // REVIEW: UL protocol's receive complete routine (yes, all of them) here.

    TCPRcvComplete();
}

//
// By default, test pullup in checked builds.
//
#ifndef PULLUP_TEST
#define PULLUP_TEST        DBG
#endif

#if PULLUP_TEST

#define PULLUP_TEST_MAX_BUFFERS                8
#define PULLUP_TEST_MAX_BUFFER_SIZE            32

//* PullupTestChooseDistribution
//
//  Choose a random distribution.
//  Divides Size bytes into NumBuffers pieces,
//  and returns the result in the Counts array.
//
void
PullupTestChooseDistribution(
    uint Counts[],
    uint NumBuffers,
    uint Size)
{
    uint i;
    uint ThisBuffer;

    //
    // We are somewhat biased towards cutting the packet
    // up into small pieces with a large remainder.
    // This puts the fragment boundaries at the beginning,
    // where the headers are.
    //

    for (i = 0; i < NumBuffers - 1; i++) {
        ThisBuffer = RandomNumber(1, PULLUP_TEST_MAX_BUFFER_SIZE);

        //
        // Make sure that each segment has non-zero length.
        //
        if (ThisBuffer > Size - (NumBuffers - 1 - i))
            ThisBuffer = Size - (NumBuffers - 1 - i);

        Counts[i] = ThisBuffer;
        Size -= ThisBuffer;
    }
    Counts[i] = Size;
}

//* PullupTestCreatePacket
//
//  Given an IPv6 packet, creates a new IPv6 packet
//  that can be handed up the receive path.
//
//  We randomly fragment the IPv6 packet into multiple buffers.
//  This tests pull-up processing in the receive path.
//
//  Returns NULL if any memory allocation fails.
//
IPv6Packet *
PullupTestCreatePacket(IPv6Packet *Packet)
{
    IPv6Packet *TestPacket;

    //
    // We mostly want to test discontiguous packets.
    // But occasionally test a contiguous packet.
    //
    if (RandomNumber(0, 10) == 0) {
        //
        // We need to create a contiguous packet.
        //
        uint Padding;
        uint MemLen;
        void *Mem;

        //
        // We insert some padding to vary the alignment.
        //
        Padding = RandomNumber(0, 16);
        MemLen = sizeof *TestPacket + Padding + Packet->TotalSize;
        TestPacket = ExAllocatePoolWithTagPriority(NonPagedPool, MemLen,
                                                   IP6_TAG, LowPoolPriority);
        if (TestPacket == NULL)
            return NULL;
        Mem = (void *)((uchar *)(TestPacket + 1) + Padding);

        if (Packet->NdisPacket == NULL) {
            RtlCopyMemory(Mem, Packet->Data, Packet->TotalSize);
        }
        else {
            PNDIS_BUFFER NdisBuffer;
            uint Offset;
            int Ok;

            NdisBuffer = NdisFirstBuffer(Packet->NdisPacket);
            Offset = Packet->Position;
            Ok = CopyNdisToFlat(Mem, NdisBuffer, Offset, Packet->TotalSize,
                                &NdisBuffer, &Offset);
            ASSERT(Ok);
        }

        RtlZeroMemory(TestPacket, sizeof *TestPacket);
        TestPacket->Data = TestPacket->FlatData = Mem;
        TestPacket->ContigSize = TestPacket->TotalSize = Packet->TotalSize;
        TestPacket->NTEorIF = Packet->NTEorIF;
        TestPacket->Flags = Packet->Flags;
    }
    else {
        //
        // Create a packet with multiple NDIS buffers.
        // Start with an over-estimate of the size of the MDLs we need.
        //
        uint NumPages = (Packet->TotalSize >> PAGE_SHIFT) + 2;
        uint MdlRawSize = sizeof(MDL) + (NumPages * sizeof(PFN_NUMBER));
        uint MdlAlign = __builtin_alignof(MDL) - 1;
        uint MdlSize = (MdlRawSize + MdlAlign) &~ MdlAlign;
        uint Padding;
        uint MemLen;
        uint Counts[PULLUP_TEST_MAX_BUFFERS];
        uint NumBuffers;
        void *Mem;
        PNDIS_PACKET NdisPacket;
        PNDIS_BUFFER NdisBuffer;
        uint Garbage = 0xdeadbeef;
        uint i;

        //
        // Choose the number of buffers/MDLs that we will use
        // and the distribution of bytes into those buffers.
        //
        NumBuffers = RandomNumber(1, PULLUP_TEST_MAX_BUFFERS);
        PullupTestChooseDistribution(Counts, NumBuffers, Packet->TotalSize);

        //
        // Allocate all the memory that we will need.
        // (Actually a bit of an over-estimate.)
        // We insert some padding to vary the initial alignment.
        //
        Padding = RandomNumber(0, 16);
        MemLen = (sizeof *TestPacket + sizeof(NDIS_PACKET) + 
                  NumBuffers * (MdlSize + sizeof Garbage) +
                  Padding + Packet->TotalSize);
        TestPacket = ExAllocatePoolWithTagPriority(NonPagedPool, MemLen,
                                                   IP6_TAG, LowPoolPriority);
        if (TestPacket == NULL)
            return NULL;
        NdisPacket = (PNDIS_PACKET)(TestPacket + 1);
        NdisBuffer = (PNDIS_BUFFER)(NdisPacket + 1);
        Mem = (void *)((uchar *)NdisBuffer + NumBuffers * MdlSize + Padding);

        //
        // Initialize the NDIS packet and buffers.
        //
        RtlZeroMemory(NdisPacket, sizeof *NdisPacket);
        for (i = 0; i < NumBuffers; i++) {
            MmInitializeMdl(NdisBuffer, Mem, Counts[i]);
            MmBuildMdlForNonPagedPool(NdisBuffer);
            NdisChainBufferAtBack(NdisPacket, NdisBuffer);
            RtlCopyMemory((uchar *)Mem + Counts[i], &Garbage, sizeof Garbage);

            (uchar *)Mem += Counts[i] + sizeof Garbage;
            (uchar *)NdisBuffer += MdlSize;
        }

        //
        // Copy data to the new packet.
        //
        CopyToBufferChain((PNDIS_BUFFER)(NdisPacket + 1), 0,
                          Packet->NdisPacket, Packet->Position,
                          Packet->FlatData, Packet->TotalSize);

        //
        // Initialize the new packet.
        //
        InitializePacketFromNdis(TestPacket, NdisPacket, 0);
        TestPacket->NTEorIF = Packet->NTEorIF;
        TestPacket->Flags = Packet->Flags;
    }

    return TestPacket;
}
#endif // PULLUP_TEST


//* IPv6Receive - Receive an incoming IPv6 datagram.
//
//  This is the routine called by the link layer module when an incoming IPv6
//  datagram is to be processed.  We validate the datagram and decide what to
//  do with it.
//
//  The Packet->NTEorIF field holds the NTE or interface that is receiving
//  the packet. Typically this is an interface, but there are some tunnel
//  situations where the link layer has already found an NTE.
//
//  Either the caller should hold a reference to the NTE or interface
//  across the call, or the caller can place a reference in the Packet
//  with PACKET_HOLDS_REF. If the caller specifies PACKET_HOLDS_REF,
/// IPv6Receive will release the reference.
//
//  There is one exception: the caller can supply an interface
//  with zero references (not using PACKET_HOLDS_REF),
//  if the interface is being destroyed but IF->Cleanup has not yet returned.
//
//  NB: The datagram may either be held in a NDIS_PACKET allocated by the
//  link-layer or the interface driver (in which case 'Packet->NdisPacket'
//  is non-NULL and 'Data' points to the first data buffer in the buffer
//  chain), or the datagram may still be held by NDIS (in which case
//  'Packet->NdisPacket' is NULL and 'Data' points to a buffer containing
//  the entire datagram).
//
//  NB: We do NOT check for link-level multi/broadcasts to
//  IPv6 unicast destinations.  In the IPv4 world, receivers dropped
//  such packets, but in the IPv6 world they are accepted.
//
//  Returns count of references for the packet.
//  For now, this should always be zero.
//  Someday in the future this might be used to indicate
//  that the IPv6 layer has not finished its receive processing.
//
//  Callable from DPC context, not from thread context.
//
int
IPv6Receive(IPv6Packet *Packet)
{
    uchar NextHeader;            // Current header's NextHeader field.
    uchar (*Handler)();
    SALinkage *ThisSA, *NextSA;
    int PktRefs;

    ASSERT((Packet->FlatData == NULL) != (Packet->NdisPacket == NULL));
    ASSERT(Packet->NTEorIF != NULL);
    ASSERT(Packet->SAPerformed == NULL);

    IPSIncrementInReceiveCount();

    //
    // Ensure that the packet is accessible in the kernel address space.
    // If any mappings fail, just drop the packet.
    // In practice, the packet buffers are usually already mapped.
    // But they may not be, for example in loopback.
    //
    if (Packet->NdisPacket != NULL) {
        NDIS_BUFFER *Buffer;

        Buffer = NdisFirstBuffer(Packet->NdisPacket);
        if (! MapNdisBuffers(Buffer)) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "IPv6Receive(%p): buffer mapping failed\n",
                       Packet));
            IPSInfo.ipsi_indiscards++;
            return 0; // Drop the packet.
        }
    }

#if PULLUP_TEST
    Packet = PullupTestCreatePacket(Packet);
    if (Packet == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6Receive(%p): PullupTestCreatePacket failed\n",
                   Packet));
        IPSInfo.ipsi_indiscards++;
        return 0; // Drop the packet.
    }
#endif

    //
    // Iteratively switch out to the handler for each successive next header
    // until we reach a handler that reports no more headers follow it.
    //
    // NB: We do NOT check NTE->DADStatus here.
    // That is the responsibility of higher-level protocols.
    //
    NextHeader = IP_PROTOCOL_V6;  // Always first header in packet.
    do {
        //
        // Current header indicates that another header follows.
        // See if we have a handler for it.
        //
        Handler = ProtocolSwitchTable[NextHeader].DataReceive;
        if (Handler == NULL) {

            //
            // We don't have a handler for this header type,
            // so see if there is a raw receiver for it.
            //
            if (!RawReceive(Packet, NextHeader)) {

                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                           "IPv6 Receive: Next Header type %u not handled.\n",
                           NextHeader));
            
                //
                // There isn't a raw receiver either.
                // Send an ICMP error message.
                // ICMP Pointer value is the offset from the start of the
                // incoming packet's IPv6 header to the offending field.
                //
                ICMPv6SendError(Packet,
                                ICMPv6_PARAMETER_PROBLEM, 
                                ICMPv6_UNRECOGNIZED_NEXT_HEADER,
                                Packet->NextHeaderPosition -
                                Packet->IPPosition,
                                NextHeader, FALSE);

                IPSInfo.ipsi_inunknownprotos++;
            } else {
                IPSIncrementInDeliverCount();
            }

            break;  // We can't do anything more with this packet.
        }

        NextHeader = (*Handler)(Packet);
    } while (NextHeader != IP_PROTOCOL_NONE);

    //
    // If this packet holds a reference, free it now.
    //
    if (Packet->Flags & PACKET_HOLDS_REF) {
        if (IsNTE(Packet->NTEorIF))
            ReleaseNTE(CastToNTE(Packet->NTEorIF));
        else
            ReleaseIF(CastToIF(Packet->NTEorIF));
    }

    //
    // Clean up any contiguous regions left by PacketPullup.
    //
    PacketPullupCleanup(Packet);

    //
    // Clean up list of SA's performed.
    //
    for (ThisSA = Packet->SAPerformed; ThisSA != NULL; ThisSA = NextSA) {
        ReleaseSA(ThisSA->This);
        NextSA = ThisSA->Next;
        ExFreePool(ThisSA);
    }

    PktRefs = Packet->RefCnt;
#if PULLUP_TEST
    ExFreePool(Packet);
#endif
    return PktRefs;
}


//* IPv6HeaderReceive - Handle a IPv6 header.
//
//  This is the routine called to process an IPv6 header, a next header
//  value of 41 (e.g. as would be encountered with v6 in v6 tunnels).  To
//  avoid code duplication, it is also used to process the initial IPv6
//  header found in all IPv6 packets, in which mode it may be viewed as
//  a continuation of IPv6Receive.
//
uchar
IPv6HeaderReceive(
    IPv6Packet *Packet)      // Packet handed to us by IPv6Receive.
{
    uint PayloadLength;
    uchar NextHeader;
    int Forwarding;     // TRUE means Forwarding, FALSE means Receiving.

    //
    // Sanity-check ContigSize & TotalSize.
    // Higher-level code in the receive path relies on these conditions.
    //
    ASSERT(Packet->ContigSize <= Packet->TotalSize);

    //
    // If we are decapsulating a packet,
    // remember that this packet was originally tunneled.
    //
    // Some argue that decapsulating and receiving
    // the inner packet on the same interface as the outer packet
    // is incorrect: the inner packet should be received
    // on a tunnel interface distinct from the original interface.
    // (This approach introduces some issues with handling
    // IPsec encapsulation, especially tunnel-mode IPsec between peers
    // where you want the inner & outer source address to be the same.)
    //
    // In any case, for now we receive the inner packet on the original
    // interface. However, this introduces a potential security
    // problem. An off-link node can send an encapsulated packet
    // that when decapsulated, appears to have originated from
    // an on-link neighbor. This is a security problem for ND.
    // We can not conveniently decrement the HopLimit (to make ND's
    // check against 255 effective in this case), because the packet
    // is read-only. Instead, we remember that the packet is tunneled
    // and check this flag bit in the ND code.
    //
    if (Packet->IP != NULL) {
        Packet->Flags |= PACKET_TUNNELED;
        Packet->Flags &= ~PACKET_SAW_HA_OPT;  // Forget if we saw one.
        Packet->SkippedHeaderLength = 0;

        //
        // If we've already done some IPSec processing on this packet,
        // then this is a tunnel header and the preceeding IPSec header
        // is operating in tunnel mode.
        //
        if (Packet->SAPerformed != NULL)
            Packet->SAPerformed->Mode = TUNNEL;
    } else {
        //
        // In the reassembly path, we remember if the fragments were
        // tunneled but we do not have a Packet->IP.
        //
        ASSERT((((Packet->Flags & PACKET_TUNNELED) == 0) ||
                (Packet->Flags & PACKET_REASSEMBLED)) &&
               ((Packet->Flags & PACKET_SAW_HA_OPT) == 0) &&
               (Packet->SAPerformed == NULL));
    }

    //
    // Make sure we have enough contiguous bytes for an IPv6 header, otherwise
    // attempt to pullup that amount.  Then stash away a pointer to the header
    // and also remember the offset into the packet at which it begins (needed
    // to calculate an offset for certain ICMP error messages).
    //
    if (! PacketPullup(Packet, sizeof(IPv6Header),
                       __builtin_alignof(IPv6Addr), 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof(IPv6Header))
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "IPv6HeaderReceive: "
                       "Packet too small to contain IPv6 header\n"));
        IPSInfo.ipsi_inhdrerrors++;
        return IP_PROTOCOL_NONE;
    }
    Packet->IP = (IPv6Header UNALIGNED *)Packet->Data;
    Packet->IPPosition = Packet->Position;
    Packet->NextHeaderPosition = Packet->Position +
        FIELD_OFFSET(IPv6Header, NextHeader);

    //
    // Skip over IPv6 header (note we keep our pointer to it).
    //
    AdjustPacketParams(Packet, sizeof(IPv6Header));

    //
    // Check the IP version is correct.
    // We specifically do NOT check HopLimit.
    // HopLimit is only checked when forwarding.
    //
    if ((Packet->IP->VersClassFlow & IP_VER_MASK) != IP_VERSION) {
        // Silently discard the packet.
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "IPv6HeaderReceive: bad version\n"));
        IPSInfo.ipsi_inhdrerrors++;
        return IP_PROTOCOL_NONE;
    }

    //
    // We use a separate pointer to refer to the source address so that
    // later options can change it.
    //
    Packet->SrcAddr = AlignAddr(&Packet->IP->Source);

    //
    // Protect against attacks that use bogus source addresses.
    //
    if (IsInvalidSourceAddress(Packet->SrcAddr)) {
        // Silently discard the packet.
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "IPv6HeaderReceive: source address is invalid\n"));
        return IP_PROTOCOL_NONE;
    }
    if (IsLoopback(Packet->SrcAddr) &&
        ((Packet->Flags & PACKET_LOOPED_BACK) == 0)) {
        // Silently discard the packet.
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "IPv6HeaderReceive: loopback source addr from wire?\n"));
        return IP_PROTOCOL_NONE;
    }

    if (IsNTE(Packet->NTEorIF)) {
        NetTableEntry *NTE;

        //
        // We were called with an NTE.
        // Our caller (or the packet itself) should be holding a reference.
        // The NTE holds an interface reference.
        //
        NTE = CastToNTE(Packet->NTEorIF);

        //
        // Verify that the packet's destination address is
        // consistent with this NTE.
        //
        if (!IP6_ADDR_EQUAL(AlignAddr(&Packet->IP->Dest), &NTE->Address)) {
            Interface *IF = NTE->IF;

            //
            // We can't accept this new header on this NTE.
            // Convert to an Interface and punt to forwarding code below.
            //
            if (Packet->Flags & PACKET_HOLDS_REF) {
                AddRefIF(IF);
                ReleaseNTE(NTE);
            }
            else {
                //
                // Our caller holds a reference for the NTE,
                // which holds a reference for the interface.
                // So the packet does not need to hold a reference.
                //
            }
            Packet->NTEorIF = CastFromIF(IF);
            goto Forward;
        }

        //
        // We are Receiving the packet.
        //
        Forwarding = FALSE;

    } else {
        NetTableEntryOrInterface *NTEorIF;
        ushort Type;

        //
        // We were called with an Interface.
        // In some situations, there is no reference for this interface
        // and the interface is being destroyed. FindAddressOnInterface
        // will return NULL in that case. After this point, we must ensure
        // that the interface does have a reference, by having the packet
        // hold a reference for the interface or a reference for an NTE
        // on the interface.
        //
        NTEorIF = FindAddressOnInterface(CastToIF(Packet->NTEorIF),
                                         AlignAddr(&Packet->IP->Dest), &Type);
        if (NTEorIF == NULL) {
            //
            // The interface is being destroyed.
            //
            IPSInfo.ipsi_indiscards++;
            return IP_PROTOCOL_NONE;
        }

        //
        // FindAddressOnInterface returned a reference to NTEorIF
        // (which could be an interface or an NTE). We either need
        // to put this reference into the packet, or release it
        // if the packet already holds an appropriate reference.
        //

        if (Type == ADE_NONE) {
            //
            // If the packet does not hold a reference for the interface,
            // give it one now.
            //
            ASSERT(NTEorIF == Packet->NTEorIF);
            if (Packet->Flags & PACKET_HOLDS_REF) {
                //
                // The packet already holds an interface reference,
                // so our reference is not neeeded.
                //
                ReleaseIF(CastToIF(NTEorIF));
            }
            else {
                //
                // Give the packet our interface reference.
                //
                Packet->Flags |= PACKET_HOLDS_REF;
            }

            //
            // The address is not assigned to this interface.  Check to see
            // if it is appropriate for us to forward this packet.
            // If not, drop it.  At this point, we are fairly
            // conservative about what we will forward.
            //
Forward:
            if (!(CastToIF(Packet->NTEorIF)->Flags & IF_FLAG_FORWARDS) ||
                (Packet->Flags & PACKET_NOT_LINK_UNICAST) ||
                IsUnspecified(AlignAddr(&Packet->IP->Source)) ||
                IsLoopback(AlignAddr(&Packet->IP->Source))) {
                //
                // Drop the packet with no ICMP error.
                //
                IPSInfo.ipsi_inaddrerrors++;
                return IP_PROTOCOL_NONE;
            }

            //
            // No support yet for forwarding multicast packets.
            //
            if (IsUnspecified(AlignAddr(&Packet->IP->Dest)) ||
                IsLoopback(AlignAddr(&Packet->IP->Dest)) ||
                IsMulticast(AlignAddr(&Packet->IP->Dest))) {
                //
                // Send an ICMP error.
                //
                ICMPv6SendError(Packet,
                                ICMPv6_DESTINATION_UNREACHABLE,
                                ICMPv6_COMMUNICATION_PROHIBITED,
                                0, Packet->IP->NextHeader, FALSE);
                IPSInfo.ipsi_inaddrerrors++;
                return IP_PROTOCOL_NONE;
            }

            //
            // We do the actual forwarding below...
            //
            Forwarding = TRUE;

        } else {
            //
            // If we found a unicast ADE, then remember the NTE.
            // Conceptually, we think of the packet as holding
            // the reference to the NTE. Normally for multicast/anycast
            // addresses, we delay our choice of an appropriate NTE
            // until it is time to reply to the packet.
            //
            if (IsNTE(NTEorIF)) {
                NetTableEntry *NTE = CastToNTE(NTEorIF);
                Interface *IF = NTE->IF;

                ASSERT(CastFromIF(IF) == Packet->NTEorIF);

                if (!IsValidNTE(NTE)) {
                    //
                    // The unicast address is not valid, so it can't
                    // receive packets. The address may be assigned
                    // to some other node, so forwarding is appropriate.
                    //
                    // Ensure that the packet holds an interface reference.
                    //
                    if (!(Packet->Flags & PACKET_HOLDS_REF)) {
                        //
                        // The packet does not already hold an interface ref,
                        // so give it one.
                        //
                        AddRefIF(IF);
                        Packet->Flags |= PACKET_HOLDS_REF;
                    }
                    //
                    // Now our NTE reference is not needed.
                    //
                    ReleaseNTE(NTE);
                    goto Forward;
                }

                //
                // Ensure that the packet holds a reference for the NTE,
                // which holds an interface reference.
                //
                if (Packet->Flags & PACKET_HOLDS_REF) {
                    //
                    // The packet already holds an interface reference.
                    // Release that reference and give the packet
                    // our NTE reference.
                    //
                    ReleaseIF(IF);
                }
                else {
                    //
                    // The packet does not hold a reference.
                    // Give the packet our NTE reference.
                    //
                    Packet->Flags |= PACKET_HOLDS_REF;
                }
                Packet->NTEorIF = CastFromNTE(NTE);
            }
            else {
                //
                // Ensure that the packet holds an interface reference.
                //
                ASSERT(NTEorIF == Packet->NTEorIF);
                if (Packet->Flags & PACKET_HOLDS_REF) {
                    //
                    // The packet already holds an interface reference,
                    // so our reference is not needed.
                    //
                    ReleaseIF(CastToIF(NTEorIF));
                }
                else {
                    //
                    // Give our interface reference to the packet.
                    //
                    Packet->Flags |= PACKET_HOLDS_REF;
                }
            }

            //
            // We found an ADE on this IF to accept the packet,
            // so we will be Receiving it.
            //
            Forwarding = FALSE;
        }
    }

    //
    // At this point, the Forwarding variable tells us
    // if we are forwarding or receiving the packet.
    //

    //
    // Before processing any headers, including Hop-by-Hop,
    // check that the amount of payload the IPv6 header thinks is present
    // can actually fit inside the packet data area that the link handed us.
    // Note that a Payload Length of zero *might* mean a Jumbo Payload option.
    //
    PayloadLength = net_short(Packet->IP->PayloadLength);
    if (PayloadLength > Packet->TotalSize) {
        // Silently discard the packet.
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "IPv6HeaderReceive: Header's PayloadLength is greater than "
                   "the amount of data received\n"));
        IPSInfo.ipsi_inhdrerrors++;
        return IP_PROTOCOL_NONE;
    }

    //
    // Check for Hop-by-Hop Options.
    //
    if (Packet->IP->NextHeader == IP_PROTOCOL_HOP_BY_HOP) {
        int RetVal;

        //
        // If there is a Jumbo Payload option, HopByHopOptionsReceive
        // will adjust the packet size. Otherwise we take care of it
        // now, before reading the Hop-by-Hop header.
        //
        if (PayloadLength != 0) {
            Packet->TotalSize = PayloadLength;
            if (Packet->ContigSize > PayloadLength)
                Packet->ContigSize = PayloadLength;
        }

        //
        // Parse the Hop-by-Hop options.
        //
        RetVal = HopByHopOptionsReceive(Packet);
        if (RetVal < 0) {
            //
            // The packet had bad Hop-by-Hop Options.
            // Drop it.
            //
            IPSInfo.ipsi_inhdrerrors++;
            return IP_PROTOCOL_NONE;
        }
        NextHeader = (uchar)RetVal; // Truncate to 8 bits.

    } else {
        //
        // No Jumbo Payload option. Adjust the packet size.
        //
        Packet->TotalSize = PayloadLength;
        if (Packet->ContigSize > PayloadLength)
            Packet->ContigSize = PayloadLength;

        //
        // No Hop-by-Hop options.
        //
        NextHeader = Packet->IP->NextHeader;
    }

    //
    // Check if we are forwarding this packet.
    //
    if (Forwarding) {
        IPv6Header UNALIGNED *FwdIP;
        NDIS_PACKET *FwdPacket;
        NDIS_STATUS NdisStatus;
        uint Offset;
        uint MemLen;
        uchar *Mem;
        uint TunnelStart = NO_TUNNEL, IPSecBytes = 0;
        IPSecProc *IPSecToDo;
        uint Action;
        RouteCacheEntry *RCE;
        IP_STATUS Status;

        //
        // Verify IPSec was performed.
        //
        if (InboundSecurityCheck(Packet, 0, 0, 0,
                                 CastToIF(Packet->NTEorIF)) != TRUE) {
            // 
            // No policy was found or the policy indicated to drop the packet.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "IPv6Receive: "
                       "IPSec lookup failed or policy was to drop\n"));        
            IPSInfo.ipsi_inaddrerrors++;
            return IP_PROTOCOL_NONE;
        }

        //
        // At this time, we need to copy the incoming packet,
        // for several reasons: We can't hold the Packet
        // once IPv6HeaderReceive returns, yet we need to queue
        // packet to forward it.  We need to modify the packet
        // (in IPv6Forward) by decrementing the hop count,
        // yet our incoming packet is read-only.  Finally,
        // we need space in the outgoing packet for the outgoing
        // interface's link-level header, which may differ in size
        // from that of the incoming interface.  Someday, we can
        // implement support for returning a non-zero reference
        // count from IPv6Receive and only copy the incoming
        // packet's header to construct the outgoing packet.
        //       

        //
        // Find a route to the new destination.
        //
        Status = RouteToDestination(AlignAddr(&Packet->IP->Dest),
                                    0, Packet->NTEorIF,
                                    RTD_FLAG_LOOSE, &RCE);
        if (Status != IP_SUCCESS) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "IPv6HeaderReceive: "
                       "No route to destination for forwarding.\n"));  
            ICMPv6SendError(Packet,
                            ICMPv6_DESTINATION_UNREACHABLE,
                            ICMPv6_NO_ROUTE_TO_DESTINATION,
                            0, NextHeader, FALSE);
            IPSInfo.ipsi_outnoroutes++;
            return IP_PROTOCOL_NONE;
        }

        //
        // Find the Security Policy for this outbound traffic.
        //
        IPSecToDo = OutboundSPLookup(AlignAddr(&Packet->IP->Source),
                                     AlignAddr(&Packet->IP->Dest), 
                                     0, 0, 0, RCE->NCE->IF, &Action);

        if (IPSecToDo == NULL) {
            //
            // Check Action.
            //
            if (Action == LOOKUP_DROP) {
                // Drop packet.                            
                ReleaseRCE(RCE);
                IPSInfo.ipsi_inaddrerrors++;
                return IP_PROTOCOL_NONE;
            } else {
                if (Action == LOOKUP_IKE_NEG) {
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                               "IPv6HeaderReceive: IKE not supported yet.\n"));
                    ReleaseRCE(RCE);
                    IPSInfo.ipsi_inaddrerrors++;
                    return IP_PROTOCOL_NONE;
                }
            }

            //
            // With no IPSec to perform, IPv6Forward won't be changing the
            // outgoing interface from what we currently think it will be.
            // So we can use the exact size of its link-level header.
            //
            Offset = RCE->NCE->IF->LinkHeaderSize;

        } else {
            //
            // Calculate the space needed for the IPSec headers.
            //
            IPSecBytes = IPSecBytesToInsert(IPSecToDo, &TunnelStart, NULL);

            if (TunnelStart != 0) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                           "IPv6HeaderReceive: IPSec Tunnel mode only.\n"));
                FreeIPSecToDo(IPSecToDo, IPSecToDo->BundleSize);
                ReleaseRCE(RCE);
                IPSInfo.ipsi_inaddrerrors++;
                return IP_PROTOCOL_NONE;
            }

            //
            // The IPSec code in IPv6Forward might change the outgoing
            // interface from what we currently think it will be.
            // Leave the max amount of space for its link-level header.
            //
            Offset = MAX_LINK_HEADER_SIZE;
        }

        PayloadLength = Packet->TotalSize;
        MemLen = Offset + sizeof(IPv6Header) + PayloadLength + IPSecBytes;

        NdisStatus = IPv6AllocatePacket(MemLen, &FwdPacket, &Mem);
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            if (IPSecToDo) {
                FreeIPSecToDo(IPSecToDo, IPSecToDo->BundleSize);
            }
            ReleaseRCE(RCE);
            IPSInfo.ipsi_indiscards++;
            return IP_PROTOCOL_NONE;  // We can't forward.
        }

        FwdIP = (IPv6Header UNALIGNED *)(Mem + Offset + IPSecBytes);

        //
        // Copy from the incoming packet to the outgoing packet.
        //
        CopyPacketToBuffer((uchar *)FwdIP, Packet,
                           sizeof(IPv6Header) + PayloadLength,
                           Packet->IPPosition);

        //
        // Send the outgoing packet.
        //
        IPv6Forward(Packet->NTEorIF, FwdPacket, Offset + IPSecBytes, FwdIP,
                    PayloadLength, TRUE, // OK to Redirect.
                    IPSecToDo, RCE);

        if (IPSecToDo) {
            FreeIPSecToDo(IPSecToDo, IPSecToDo->BundleSize);
        }

        ReleaseRCE(RCE);

        return IP_PROTOCOL_NONE;
    } // end of if (Forwarding)

    //
    // Packet is for this node.
    // Note: We may only be an intermediate node and not the packet's final
    // destination, if there is a routing header.
    //
    return NextHeader;
}


//* ReassemblyInit
//
//  Initialize data structures required for fragment reassembly.
//
void
ReassemblyInit(void)
{
    KeInitializeSpinLock(&ReassemblyList.Lock);
    ReassemblyList.First = ReassemblyList.Last = SentinelReassembly;
    KeInitializeSpinLock(&ReassemblyList.LockSize);
}


//* ReassemblyUnload
//
//  Cleanup the fragment reassembly data structures and
//  prepare for stack unload.
//
void
ReassemblyUnload(void)
{
    //
    // We are called after all interfaces have been destroyed,
    // so the reassemblies should already be gone.
    //

    ASSERT(ReassemblyList.Last == SentinelReassembly);
    ASSERT(ReassemblyList.Size == 0);
}


//* ReassemblyRemove
//
//  Cleanup the fragment reassembly data structures
//  when an interface becomes invalid.
//
//  Callable from DPC or thread context.
//
void
ReassemblyRemove(Interface *IF)
{
    Reassembly *DeleteList = NULL;
    Reassembly *Reass, *NextReass;
    KIRQL OldIrql;

    KeAcquireSpinLock(&ReassemblyList.Lock, &OldIrql);
    for (Reass = ReassemblyList.First;
         Reass != SentinelReassembly;
         Reass = NextReass) {
        NextReass = Reass->Next;

        if (Reass->IF == IF) {
            //
            // Remove this reassembly.
            // If it is not already being deleted,
            // put it on our temporary list.
            //
            RemoveReassembly(Reass);
            KeAcquireSpinLockAtDpcLevel(&Reass->Lock);
            if (Reass->State == REASSEMBLY_STATE_DELETING) {
                //
                // Note that it has been removed from the list.
                //
                Reass->State = REASSEMBLY_STATE_REMOVED;
            }
            else {
                Reass->Next = DeleteList;
                DeleteList = Reass;
            }
            KeReleaseSpinLockFromDpcLevel(&Reass->Lock);
        }
    }
    KeReleaseSpinLock(&ReassemblyList.Lock, OldIrql);

    //
    // Actually free the reassemblies that we removed above.
    //
    while ((Reass = DeleteList) != NULL) {
        DeleteList = Reass->Next;
        DeleteReassembly(Reass);
    }
}


//* FragmentReceive - Handle a IPv6 datagram fragment.
// 
//  This is the routine called by IPv6 when it receives a fragment of an
//  IPv6 datagram, i.e. a next header value of 44.  Here we attempt to 
//  reassemble incoming fragments into complete IPv6 datagrams.
//
//  If a later fragment provides data that conflicts with an earlier
//  fragment, then we use the first-arriving data.
//
//  We silently drop the fragment and stop reassembly in several
//  cases that are not specified in the spec, to prevent DoS attacks.
//  These include partially overlapping fragments and fragments
//  that carry no data. Legitimate senders should never generate them.
//
uchar
FragmentReceive(
    IPv6Packet *Packet)         // Packet handed to us by IPv6Receive.
{
    Interface *IF = Packet->NTEorIF->IF;
    FragmentHeader UNALIGNED *Frag;
    Reassembly *Reass;
    ushort FragOffset;
    PacketShim *Shim, *ThisShim, **MoveShim;
    uint NextHeaderPosition;

    IPSInfo.ipsi_reasmreqds++;

    //
    // We can not reassemble fragments that have had IPsec processing.
    // It can't work because the IPsec headers in the unfragmentable part
    // of the offset-zero fragment will authenticate/decrypt that fragment.
    // Then the same headers would be copied to the reassembled packet.
    // They couldn't possibly successfully authenticate/decrypt again.
    // Also see RFC 2401 B.2.
    //
    if (Packet->SAPerformed != NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "FragmentReceive: IPsec on fragment\n"));
        //
        // The spec does not tell us what ICMP error to generate in this case,
        // but flagging the fragment header seems reasonable.
        //
        goto BadFragment;
    }

    // 
    // If a jumbo payload option was seen, send an ICMP error.
    // Set ICMP pointer to the offset of the fragment header.
    //
    if (Packet->Flags & PACKET_JUMBO_OPTION) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "FragmentReceive: jumbo fragment\n"));

    BadFragment:
        //
        // The NextHeader value passed to ICMPv6SendError
        // is IP_PROTOCOL_FRAGMENT because we haven't moved
        // past the fragment header yet.
        //
        ICMPv6SendError(Packet,
                        ICMPv6_PARAMETER_PROBLEM,
                        ICMPv6_ERRONEOUS_HEADER_FIELD,
                        Packet->Position - Packet->IPPosition,
                        IP_PROTOCOL_FRAGMENT, FALSE);
        goto Failed; // Drop packet.
    }

    //
    // Verify that we have enough contiguous data to overlay a FragmentHeader
    // structure on the incoming packet.  Then do so.
    //
    if (! PacketPullup(Packet, sizeof *Frag, 1, 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof *Frag)
            ICMPv6SendError(Packet,
                            ICMPv6_PARAMETER_PROBLEM,
                            ICMPv6_ERRONEOUS_HEADER_FIELD,
                            FIELD_OFFSET(IPv6Header, PayloadLength),
                            IP_PROTOCOL_NONE, FALSE);
        goto Failed; // Drop packet.
    }
    Frag = (FragmentHeader UNALIGNED *) Packet->Data;

    //
    // Remember offset to this header's NextHeader field.
    // But don't overwrite offset to previous header's NextHeader just yet.
    //
    NextHeaderPosition = Packet->Position + 
        FIELD_OFFSET(FragmentHeader, NextHeader);

    //
    // Skip over fragment header.
    //
    AdjustPacketParams(Packet, sizeof *Frag);

    //
    // Lookup this fragment triple (Source Address, Destination
    // Address, and Identification field) per-interface to see if
    // we've already received other fragments of this packet.
    //
    Reass = FragmentLookup(IF, Frag->Id,
                           AlignAddr(&Packet->IP->Source),
                           AlignAddr(&Packet->IP->Dest));
    if (Reass == NULL) {
        //
        // We hold the global reassembly list lock.
        //
        // Handle a special case first: if this is the first, last, and only
        // fragment, then we can just continue parsing without reassembly.
        // Test both paths in checked builds.
        //
        if ((Frag->OffsetFlag == 0)
#if DBG
            && ((int)Random() < 0)
#endif
            ) {
            //
            // Return next header value.
            //
            KeReleaseSpinLockFromDpcLevel(&ReassemblyList.Lock);
            Packet->NextHeaderPosition = NextHeaderPosition;
            Packet->SkippedHeaderLength += sizeof(FragmentHeader);
            IPSInfo.ipsi_reasmoks++;
            return Frag->NextHeader;
        }

        //
        // We must avoid creating new reassembly records
        // if the interface is going away, to prevent races
        // with DestroyIF/ReassemblyRemove.
        //
        if (IsDisabledIF(IF)) {
            KeReleaseSpinLockFromDpcLevel(&ReassemblyList.Lock);
            goto Failed;
        }

        //
        // This is the first fragment of this datagram we've received.
        // Allocate a reassembly structure to keep track of the pieces.
        //
        Reass = ExAllocatePoolWithTagPriority(
                                NonPagedPool, sizeof(struct Reassembly),
                                IP6_TAG, LowPoolPriority);
        if (Reass == NULL) {
            KeReleaseSpinLockFromDpcLevel(&ReassemblyList.Lock);
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "FragmentReceive: Couldn't allocate memory!?!\n"));
            goto Failed;
        }

        KeInitializeSpinLock(&Reass->Lock);
        Reass->State = REASSEMBLY_STATE_NORMAL;

        RtlCopyMemory(&Reass->IPHdr, Packet->IP, sizeof(IPv6Header));
        Reass->IF = IF;
        Reass->Id = Frag->Id;
        Reass->ContigList = NULL;
#if DBG
        Reass->ContigEnd = NULL;
#endif
        Reass->GapList = NULL;
        Reass->Timer = DEFAULT_REASSEMBLY_TIMEOUT;
        Reass->Marker = 0;
        Reass->MaxGap = 0;
        //
        // We must initialize DataLength to an invalid value.
        // Initializing to zero doesn't work.
        //
        Reass->DataLength = (uint)-1;
        Reass->UnfragmentLength = 0;
        Reass->UnfragData = NULL;
        Reass->Flags = 0;
        Reass->Size = REASSEMBLY_SIZE_PACKET;

        //
        // Add new Reassembly struct to front of the ReassemblyList.
        // Acquires the reassembly record lock and
        // releases the global reassembly list lock.
        //
        AddToReassemblyList(Reass);
    }
    else {
        //
        // We have found and locked an existing reassembly structure.
        // Because we remove the reassembly structure in every
        // error situation below, an existing reassembly structure
        // must have a shim that has been successfully added to it.
        //
        ASSERT((Reass->ContigList != NULL) || (Reass->GapList != NULL));
    }

    //
    // At this point, we have a locked reassembly record.
    // We do not hold the global reassembly list lock
    // while we perform the relatively expensive work
    // of copying the fragment.
    //
    ASSERT(Reass->State == REASSEMBLY_STATE_NORMAL);

    //
    // Update the saved packet flags from this fragment packet.
    // We are really only interested in PACKET_NOT_LINK_UNICAST.
    //
    Reass->Flags |= Packet->Flags;

    FragOffset = net_short(Frag->OffsetFlag) & FRAGMENT_OFFSET_MASK;

    // 
    // Send ICMP error if this fragment causes the total packet length 
    // to exceed 65,535 bytes.  Set ICMP pointer equal to the offset to
    // the Fragment Offset field.
    //
    if (FragOffset + Packet->TotalSize > MAX_IPv6_PAYLOAD) {
        DeleteFromReassemblyList(Reass);
        ICMPv6SendError(Packet,
                        ICMPv6_PARAMETER_PROBLEM,
                        ICMPv6_ERRONEOUS_HEADER_FIELD,
                        (Packet->Position - sizeof(FragmentHeader) +
                         (uint)FIELD_OFFSET(FragmentHeader, OffsetFlag) -
                         Packet->IPPosition),
                        ((FragOffset == 0) ?
                         Frag->NextHeader : IP_PROTOCOL_NONE),
                        FALSE);
        goto Failed;
    }

    if ((Packet->TotalSize == 0) && (Frag->OffsetFlag != 0)) {
        //
        // We allow a moot fragment header (Frag->OffsetFlag == 0),
        // because some test programs might generate them.
        // (The first/last/only check above catches this in free builds.)
        // But otherwise, we disallow fragments that do not actually
        // carry any data for DoS protection.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "FragmentReceive: zero data fragment\n"));
        DeleteFromReassemblyList(Reass);
        return IP_PROTOCOL_NONE;
    }

    //
    // If this is the last fragment (more fragments bit not set), then
    // remember the total data length, else, check that the length
    // is a multiple of 8 bytes.
    //
    if ((net_short(Frag->OffsetFlag) & FRAGMENT_FLAG_MASK) == 0) {
        if (Reass->DataLength != (uint)-1) {
            //
            // We already received a last fragment.
            // This can happen if a packet is duplicated.
            //
            if (FragOffset + Packet->TotalSize != Reass->DataLength) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                           "FragmentReceive: second last fragment\n"));
                DeleteFromReassemblyList(Reass);
                return IP_PROTOCOL_NONE;
            }
        }
        else {
            //
            // Set expected data length from this fragment.
            //
            Reass->DataLength = FragOffset + Packet->TotalSize;

            //
            // Do we have any fragments beyond this length?
            //
            if ((Reass->Marker > Reass->DataLength) ||
                (Reass->MaxGap > Reass->DataLength))
                goto BadFragmentBeyondData;
        }
    } else {
        if ((Packet->TotalSize % 8) != 0) {
            //
            // Length is not multiple of 8, send ICMP error with a pointer 
            // value equal to offset of payload length field in IP header.
            //
            DeleteFromReassemblyList(Reass);
            ICMPv6SendError(Packet,
                            ICMPv6_PARAMETER_PROBLEM, 
                            ICMPv6_ERRONEOUS_HEADER_FIELD,
                            FIELD_OFFSET(IPv6Header, PayloadLength),
                            ((FragOffset == 0) ?
                             Frag->NextHeader : IP_PROTOCOL_NONE),
                            FALSE);
            goto Failed; // Drop packet.
        }

        if ((Reass->DataLength != (uint)-1) &&
            (FragOffset + Packet->TotalSize > Reass->DataLength)) {
            //
            // This fragment falls beyond the data length.
            // As part of our DoS prevention, drop the reassembly.
            //
        BadFragmentBeyondData:
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "FragmentReceive: fragment beyond data length\n"));
            DeleteFromReassemblyList(Reass);
            return IP_PROTOCOL_NONE;
        }
    }

    //
    // Allocate and initialize a shim structure to hold the fragment data.
    //
    Shim = ExAllocatePoolWithTagPriority(
                        NonPagedPool, sizeof *Shim + Packet->TotalSize,
                        IP6_TAG, LowPoolPriority);
    if (Shim == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "FragmentReceive: Couldn't allocate memory!?!\n"));
        DeleteFromReassemblyList(Reass);
        goto Failed;
    }

    IncreaseReassemblySize(Reass, REASSEMBLY_SIZE_FRAG + Packet->TotalSize);
    Shim->Len = (ushort)Packet->TotalSize;
    Shim->Offset = FragOffset;
    Shim->Next = NULL;

    //
    // Determine where this fragment fits among the previous ones.
    //
    // There is no good reason for senders to ever generate overlapping
    // fragments. However, packets may sometimes be duplicated in the network.
    // If we receive a fragment that duplicates previously received fragments,
    // then we just discard it. If we receive a fragment that only partially
    // overlaps previously received fragments, then we assume a malicious
    // sender and just drop the reassembly. This gives us better behavior
    // under some kinds of DoS attacks, although the upper bound on reassembly
    // buffers (see CheckReassemblyQuota) is the ultimate protection.
    // 
    if (FragOffset == Reass->Marker) {
        //
        // This fragment extends the contiguous list.
        //

        if (Reass->ContigList == NULL) {
            //
            // We're first on the list.
            // We use info from the (first) offset zero fragment to recreate
            // the original datagram. Info in a second offset zero fragment
            // is ignored.
            //
            ASSERT(FragOffset == 0);
            ASSERT(Reass->UnfragData == NULL);
            Reass->ContigList = Shim;

            // Save the next header value.
            Reass->NextHeader = Frag->NextHeader;

            //
            // Grab the unfragmentable data, i.e. the extension headers that
            // preceded the fragment header.
            //
            Reass->UnfragmentLength = (ushort)
                ((Packet->Position - sizeof(FragmentHeader)) -
                (Packet->IPPosition + sizeof(IPv6Header)));

            if (Reass->UnfragmentLength != 0) {
                Reass->UnfragData = ExAllocatePoolWithTagPriority(
                                        NonPagedPool, Reass->UnfragmentLength,
                                        IP6_TAG, LowPoolPriority);
                if (Reass->UnfragData == NULL) {
                    // Out of memory!?!  Clean up and drop packet.
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                               "FragmentReceive: "
                               "Couldn't allocate memory?\n"));
                    // Will also free Shim because of Reass->ContigList.
                    DeleteFromReassemblyList(Reass);
                    goto Failed;
                }
                IncreaseReassemblySize(Reass, Reass->UnfragmentLength);
                CopyPacketToBuffer(Reass->UnfragData, Packet,
                                   Reass->UnfragmentLength,
                                   Packet->IPPosition + sizeof(IPv6Header));

                Reass->NextHeaderOffset = Packet->NextHeaderPosition -
                    Packet->IPPosition;
            } else
                Reass->NextHeaderOffset = FIELD_OFFSET(IPv6Header, NextHeader);

            //
            // We need to have the IP header of the offset-zero fragment.
            // (Every fragment normally will have the same IP header,
            // except for PayloadLength, and unfragmentable headers,
            // but they might not.) ReassembleDatagram and
            // CreateFragmentPacket both need it.
            //
            // Of the 40 bytes in the header, the 32 bytes in the source
            // and destination addresses are already correct.
            // So we just copy the other 8 bytes now.
            //
            RtlCopyMemory(&Reass->IPHdr, Packet->IP, 8);

        } else {
            //
            // Add us to the end of the list.
            //
            Reass->ContigEnd->Next = Shim;
        }
        Reass->ContigEnd = Shim;

        //
        // Increment our contiguous extent marker.
        //
        Reass->Marker += (ushort)Packet->TotalSize;

        //
        // Now peruse the non-contiguous list here to see if we already
        // have the next fragment to extend the contiguous list, and if so,
        // move it on over.  Repeat until we can't.
        //
        MoveShim = &Reass->GapList;
        while ((ThisShim = *MoveShim) != NULL) {
            if (ThisShim->Offset == Reass->Marker) {
                //
                // This fragment now extends the contiguous list.
                // Add it to the end of the list.
                //
                Reass->ContigEnd->Next = ThisShim;
                Reass->ContigEnd = ThisShim;
                Reass->Marker += ThisShim->Len;

                //
                // Remove it from non-contiguous list.
                //
                *MoveShim = ThisShim->Next;
                ThisShim->Next = NULL;
            }
            else if (ThisShim->Offset > Reass->Marker) {
                //
                // This fragment lies beyond the contiguous list.
                // Because the gap list is sorted, we can stop now.
                //
                break;
            }
            else {
                //
                // This fragment overlaps the contiguous list.
                // For DoS prevention, drop the reassembly.
                //
            BadFragmentOverlap:
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                           "FragmentReceive: overlapping fragment\n"));
                DeleteFromReassemblyList(Reass);
                return IP_PROTOCOL_NONE;
            }
        }
    } else {
        //
        // Check whether the fragment duplicates data already in
        // the contiguous list.
        //
        if (Shim->Offset <= Reass->Marker) {
            if (Shim->Offset + Shim->Len > Reass->Marker) {
                //
                // We have a partial overlap.
                //
                ExFreePool(Shim);
                goto BadFragmentOverlap;
            }

            //
            // We already have all the data.  Don't bother distinguishing
            // between an exact duplicate and a partial overlap, just
            // ignore the new fragment.
            //
            goto Duplicate;
        }
    
        //
        // Exile this fragment to the non-contiguous (gap) list.
        // The gap list is sorted by Offset.
        //
        MoveShim = &Reass->GapList;
        for (;;) {
            ThisShim = *MoveShim;
            if (ThisShim == NULL) {
                //
                // Insert Shim at the end of the gap list.
                //
                Reass->MaxGap = Shim->Offset + Shim->Len;
                break;
            }

            if (Shim->Offset < ThisShim->Offset) {
                //
                // Check for partial overlap.
                //
                if (Shim->Offset + Shim->Len > ThisShim->Offset) {
                    ExFreePool(Shim);
                    goto BadFragmentOverlap;
                }

                //
                // OK, insert Shim before ThisShim.
                //
                break;
            }
            else if (ThisShim->Offset < Shim->Offset) {
                //
                // Check for partial overlap.
                //
                if (ThisShim->Offset + ThisShim->Len > Shim->Offset) {
                    ExFreePool(Shim);
                    goto BadFragmentOverlap;
                }

                //
                // OK, insert Shim somewhere after ThisShim.
                // Keep looking for the right spot.
                //
                MoveShim = &ThisShim->Next;
            }
            else {
                //
                // If the new fragment duplicates the old,
                // then just ignore the new fragment.
                //
                if (Shim->Len == ThisShim->Len) {
                Duplicate:
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                               "FragmentReceive: duplicate fragment\n"));
                    ExFreePool(Shim);
                    KeReleaseSpinLockFromDpcLevel(&Reass->Lock);
                    return IP_PROTOCOL_NONE;
                }
                else {
                    ExFreePool(Shim);
                    goto BadFragmentOverlap;
                }
            }
        }

        Shim->Next = *MoveShim;
        *MoveShim = Shim;
    }

    //
    // Now that we have added the shim to the reassembly record
    // and passed various checks (particularly DoS checks),
    // copy the actual fragment data to the shim.
    //
    CopyPacketToBuffer(PacketShimData(Shim), Packet,
                       Packet->TotalSize, Packet->Position);

    if (Reass->Marker == Reass->DataLength) {
        //
        // We have received all the fragments.
        // Because of the overlapping/data-length/zero-size sanity checks
        // above, when this happens there should be no fragments
        // left on the gap list. However, ReassembleDatagram does not
        // rely on having an empty gap list.
        //
        ASSERT(Reass->GapList == NULL);
        ReassembleDatagram(Packet, Reass);
    }
    else {
        //
        // Finally, check if we're too close to our limit for 
        // reassembly buffers.  If so, drop this packet.  Otherwise,
        // wait for more fragments to arrive.
        //
        CheckReassemblyQuota(Reass);
    }
    return IP_PROTOCOL_NONE;

Failed:
    IPSInfo.ipsi_reasmfails++;
    return IP_PROTOCOL_NONE;
}


//* FragmentLookup - look for record of previous fragments from this datagram.
//
//  A datagram on an interface is uniquely identified by its
//  {source address, destination address, identification field} triple.
//  This function checks our reassembly list for previously
//  received fragments of a given datagram.
//
//  If an existing reassembly record is found,
//  it is returned locked.
//
//  If there is no existing reassembly record, returns NULL
//  and leaves the global reassembly list locked.
//
//  Callable from DPC context, not from thread context.
//
Reassembly *
FragmentLookup(
    Interface *IF,        // Receiving interface.
    ulong Id,             // Fragment identification field to match.
    const IPv6Addr *Src,  // Source address to match.
    const IPv6Addr *Dst)  // Destination address to match.
{
    Reassembly *Reass;

    KeAcquireSpinLockAtDpcLevel(&ReassemblyList.Lock);

    for (Reass = ReassemblyList.First;; Reass = Reass->Next) {
        if (Reass == SentinelReassembly) {
            //
            // Return with the global reassembly list lock still held.
            //
            return NULL;
        }

        if ((Reass->IF == IF) &&
            (Reass->Id == Id) &&
            IP6_ADDR_EQUAL(&Reass->IPHdr.Source, Src) &&
            IP6_ADDR_EQUAL(&Reass->IPHdr.Dest, Dst)) {
            //
            // Is this reassembly record being deleted?
            // If so, ignore it.
            //
            KeAcquireSpinLockAtDpcLevel(&Reass->Lock);
            ASSERT((Reass->State == REASSEMBLY_STATE_NORMAL) ||
                   (Reass->State == REASSEMBLY_STATE_DELETING));

            if (Reass->State == REASSEMBLY_STATE_DELETING) {
                KeReleaseSpinLockFromDpcLevel(&Reass->Lock);
                continue;
            }

            //
            // Return with the reassembly record lock still held.
            //
            KeReleaseSpinLockFromDpcLevel(&ReassemblyList.Lock);
            return Reass;
        }
    }
}


//* AddToReassemblyList
//
//  Add the reassembly record to the list.
//  It must NOT already be on the list.
//
//  Called with the global reassembly list lock held.
//  Returns with the reassembly record lock held.
//
//  Callable from DPC context, not from thread context.
//
void
AddToReassemblyList(Reassembly *Reass)
{
    Reassembly *AfterReass = SentinelReassembly;

    Reass->Prev = AfterReass;
    (Reass->Next = AfterReass->Next)->Prev = Reass;
    AfterReass->Next = Reass;

    KeAcquireSpinLockAtDpcLevel(&ReassemblyList.LockSize);
    ReassemblyList.Size += Reass->Size;
    KeReleaseSpinLockFromDpcLevel(&ReassemblyList.LockSize);

    //
    // We must acquire the reassembly record lock
    // *before* releasing the global reassembly list lock,
    // to prevent the reassembly from diappearing underneath us.
    //
    KeAcquireSpinLockAtDpcLevel(&Reass->Lock);
    KeReleaseSpinLockFromDpcLevel(&ReassemblyList.Lock);
}


//* RemoveReassembly
//
//  Remove a reassembly record from the list.
//
//  Called with the global reassembly lock held.
//  The reassembly record lock may be held.
//
void
RemoveReassembly(Reassembly *Reass)
{
    Reass->Prev->Next = Reass->Next;
    Reass->Next->Prev = Reass->Prev;

    KeAcquireSpinLockAtDpcLevel(&ReassemblyList.LockSize);
    ReassemblyList.Size -= Reass->Size;
    KeReleaseSpinLockFromDpcLevel(&ReassemblyList.LockSize);
}


//* IncreaseReassemblySize
//
//  Increase the size of the reassembly record.
//  Called with the reassembly record lock held.
//
//  Callable from DPC context, not from thread context.
//
void
IncreaseReassemblySize(Reassembly *Reass, uint Size)
{
    Reass->Size += Size;
    KeAcquireSpinLockAtDpcLevel(&ReassemblyList.LockSize);
    ReassemblyList.Size += Size;
    KeReleaseSpinLockFromDpcLevel(&ReassemblyList.LockSize);
}


//* DeleteReassembly
//
//  Delete a reassembly record.
//
void
DeleteReassembly(Reassembly *Reass)
{
    PacketShim *ThisShim, *PrevShim;

    //
    // Free ContigList if populated.
    //
    PrevShim = ThisShim = Reass->ContigList;
    while (ThisShim != NULL) {
        PrevShim = ThisShim;
        ThisShim = ThisShim->Next;
        ExFreePool(PrevShim);
    }

    //
    // Free GapList if populated.
    //
    PrevShim = ThisShim = Reass->GapList;
    while (ThisShim != NULL) {
        PrevShim = ThisShim;
        ThisShim = ThisShim->Next;
        ExFreePool(PrevShim);
    }

    //
    // Free unfragmentable data.
    //
    if (Reass->UnfragData != NULL)
        ExFreePool(Reass->UnfragData);

    ExFreePool(Reass);
}


//* DeleteFromReassemblyList
//
//  Remove and delete the reassembly record.
//  The reassembly record MUST be on the list.
//
//  Callable from DPC context, not from thread context.
//  Called with the reassembly record lock held,
//  but not the global reassembly list lock.
//
void
DeleteFromReassemblyList(Reassembly *Reass)
{
    //
    // Mark the reassembly as being deleted.
    // This will prevent someone else from freeing it.
    //
    ASSERT(Reass->State == REASSEMBLY_STATE_NORMAL);
    Reass->State = REASSEMBLY_STATE_DELETING;
    KeReleaseSpinLockFromDpcLevel(&Reass->Lock);

    KeAcquireSpinLockAtDpcLevel(&ReassemblyList.Lock);
    KeAcquireSpinLockAtDpcLevel(&Reass->Lock);
    ASSERT((Reass->State == REASSEMBLY_STATE_DELETING) ||
           (Reass->State == REASSEMBLY_STATE_REMOVED));

    //
    // Remove the reassembly record from the list,
    // if someone else hasn't already removed it.
    //
    if (Reass->State != REASSEMBLY_STATE_REMOVED)
        RemoveReassembly(Reass);

    KeReleaseSpinLockFromDpcLevel(&Reass->Lock);
    KeReleaseSpinLockFromDpcLevel(&ReassemblyList.Lock);

    //
    // Delete the reassembly record.
    //
    DeleteReassembly(Reass);
}

//* CheckReassemblyQuota
//
//  Delete reassembly record if necessary,
//  to keep the reassembly buffering under quota.
//
//  Callable from DPC context, not from thread context.
//  Called with the reassembly record lock held,
//  but not the global reassembly list lock.
//
void
CheckReassemblyQuota(Reassembly *Reass)
{
    int Prune = FALSE;
    uint Threshold = ReassemblyList.Limit / 2;

    //
    // Decide whether to drop the reassembly record based on a RED-like 
    // algorithm.  If the total size is less than 50% of the max, never 
    // drop.  If the total size is over the max, always drop.  If between 
    // 50% and 100% full, drop based on a probability proportional to the
    // amount over 50%.  This is an O(1) algorithm which is proportionally
    // biased against large packets, and against sources which send more
    // packets.  This should provide a decent level of protection against
    // DoS attacks.
    //
    KeAcquireSpinLockAtDpcLevel(&ReassemblyList.LockSize);
    if ((ReassemblyList.Size > Threshold) &&
        (RandomNumber(0, Threshold) < ReassemblyList.Size - Threshold))
        Prune = TRUE;
    KeReleaseSpinLockFromDpcLevel(&ReassemblyList.LockSize);

    if (Prune) {
        //
        // Delete this reassembly record.
        // We do not send ICMP errors in this situation.
        // The reassembly timer has not expired.
        // This is more analogous to a router dropping packets
        // when a queue gets full, and no ICMP error is sent
        // in that situation.
        //
#if DBG
        char Buffer1[INET6_ADDRSTRLEN], Buffer2[INET6_ADDRSTRLEN];

        FormatV6AddressWorker(Buffer1, &Reass->IPHdr.Source);
        FormatV6AddressWorker(Buffer2, &Reass->IPHdr.Dest);
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "CheckReassemblyQuota: Src %s Dst %s Id %x\n",
                   Buffer1, Buffer2, Reass->Id));
#endif
        DeleteFromReassemblyList(Reass);
    } 
    else
        KeReleaseSpinLockFromDpcLevel(&Reass->Lock);
}

typedef struct ReassembledReceiveContext {
    WORK_QUEUE_ITEM WQItem;
    IPv6Packet Packet;
    uchar Data[];
} ReassembledReceiveContext;

//* ReassembledReceive
//
//  Receive a reassembled packet.
//  This function is called from a kernel worker thread context.
//  It prevents "reassembly recursion".
//
void
ReassembledReceive(PVOID Context)
{
    ReassembledReceiveContext *rrc = (ReassembledReceiveContext *) Context;
    KIRQL Irql;
    int PktRefs;

    //
    // All receive processing normally happens at DPC level,
    // so we must pretend to be a DPC, so we raise IRQL.
    // (System worker threads typically run at PASSIVE_LEVEL).
    //
    KeRaiseIrql(DISPATCH_LEVEL, &Irql);
    PktRefs = IPv6Receive(&rrc->Packet);
    ASSERT(PktRefs == 0);
    KeLowerIrql(Irql);
    ExFreePool(rrc);
}


//* ReassembleDatagram - put all the fragments together.
//
//  Called when we have all the fragments to complete a datagram.
//  Patch them together and pass the packet up.
//
//  We allocate a single contiguous buffer and copy the fragments
//  into this buffer.
//  REVIEW: Instead use ndis buffers to chain the fragments?
//
//  Callable from DPC context, not from thread context.
//  Called with the reassembly record lock held,
//  but not the global reassembly list lock.
//
//  Deletes the reassembly record.
//
void
ReassembleDatagram(
    IPv6Packet *Packet,      // The packet being currently received.
    Reassembly *Reass)       // Reassembly record for fragmented datagram.
{
    uint DataLen;
    uint TotalLength;
    uint memptr = sizeof(IPv6Header);
    PacketShim *ThisShim, *PrevShim;
    ReassembledReceiveContext *rrc;
    IPv6Packet *ReassPacket;
    uchar *ReassBuffer;
    uchar *pNextHeader;

    DataLen = Reass->DataLength + Reass->UnfragmentLength;
    ASSERT(DataLen <= MAX_IPv6_PAYLOAD);
    TotalLength = sizeof(IPv6Header) + DataLen;

    //
    // Allocate memory for buffer and copy fragment data into it.
    // At the same time we allocate space for context information
    // and an IPv6 packet structure.
    //
    rrc = ExAllocatePoolWithTagPriority(
                        NonPagedPool, sizeof *rrc + TotalLength,
                        IP6_TAG, LowPoolPriority);
    if (rrc == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "ReassembleDatagram: Couldn't allocate memory!?!\n"));
        DeleteFromReassemblyList(Reass);
        IPSInfo.ipsi_reasmfails++;
        return;
    }

    //
    // We must take a reference on the interface before
    // DeleteFromReassemblyList releases the record lock.
    //
    ReassPacket = &rrc->Packet;
    ReassBuffer = rrc->Data;

    //
    // Generate the original IP hdr and copy it and any unfragmentable
    // data into the new packet.  Note we have to update the next header
    // field in the last unfragmentable header (or the IP hdr, if none).
    //
    Reass->IPHdr.PayloadLength = net_short((ushort)DataLen);
    RtlCopyMemory(ReassBuffer, (uchar *)&Reass->IPHdr, sizeof(IPv6Header));

    RtlCopyMemory(ReassBuffer + memptr, Reass->UnfragData,
                  Reass->UnfragmentLength);
    memptr += Reass->UnfragmentLength;

    pNextHeader = ReassBuffer + Reass->NextHeaderOffset;
    ASSERT(*pNextHeader == IP_PROTOCOL_FRAGMENT);
    *pNextHeader = Reass->NextHeader;

    //
    // Run through the contiguous list, copying data over to our new packet.
    //
    PrevShim = ThisShim = Reass->ContigList;
    while(ThisShim != NULL) {
        RtlCopyMemory(ReassBuffer + memptr, PacketShimData(ThisShim),
                      ThisShim->Len);
        memptr += ThisShim->Len;
        if (memptr > TotalLength) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "ReassembleDatagram: packets don't add up\n"));
        }
        PrevShim = ThisShim;
        ThisShim = ThisShim->Next;

        ExFreePool(PrevShim);
    }

    //
    // Initialize the reassembled packet structure.
    //
    RtlZeroMemory(ReassPacket, sizeof *ReassPacket);
    AddRefIF(Reass->IF);
    ReassPacket->NTEorIF = CastFromIF(Reass->IF);
    ReassPacket->FlatData = ReassBuffer;
    ReassPacket->Data = ReassBuffer;
    ReassPacket->ContigSize = TotalLength;
    ReassPacket->TotalSize = TotalLength;
    ReassPacket->Flags = PACKET_HOLDS_REF | PACKET_REASSEMBLED |
        (Reass->Flags & PACKET_INHERITED_FLAGS);

    //
    // Explicitly null out the ContigList which was freed above and
    // clean up the reassembly struct. This also drops our lock
    // on the reassembly struct.
    //
    Reass->ContigList = NULL;
    DeleteFromReassemblyList(Reass);

    IPSInfo.ipsi_reasmoks++;

    //
    // Receive the reassembled packet.
    // If the current fragment was reassembled,
    // then we should avoid another level of recursion.
    // We must prevent "reassembly recursion".
    // Test both paths in checked builds.
    //
    if ((Packet->Flags & PACKET_REASSEMBLED)
#if DBG
        || ((int)Random() < 0)
#endif
        ) {
        ExInitializeWorkItem(&rrc->WQItem, ReassembledReceive, rrc);
        ExQueueWorkItem(&rrc->WQItem, CriticalWorkQueue);
    }
    else {
        int PktRefs = IPv6Receive(ReassPacket);
        ASSERT(PktRefs == 0);
        UNREFERENCED_PARAMETER(PktRefs);
        ExFreePool(rrc);
    }
}


//* CreateFragmentPacket
//
//  Recreates the first fragment packet for purposes of notifying a source
//  of a 'fragment reassembly time exceeded'.
//
IPv6Packet *
CreateFragmentPacket(
    Reassembly *Reass)
{
    PacketShim *FirstFrag;
    IPv6Packet *Packet;
    FragmentHeader *FragHdr;
    uint PayloadLength;
    uint PacketLength;
    uint MemLen;
    uchar *Mem;

    //
    // There must be a first (offset-zero) fragment.
    //
    FirstFrag = Reass->ContigList;
    ASSERT((FirstFrag != NULL) && (FirstFrag->Offset == 0));

    //
    // Allocate memory for creating the first fragment, i.e. the first
    // buffer in our contig list. We include space for an IPv6Packet.
    //
    PayloadLength = (Reass->UnfragmentLength + sizeof(FragmentHeader) +
                     FirstFrag->Len);
    PacketLength = sizeof(IPv6Header) + PayloadLength;
    MemLen = sizeof(IPv6Packet) + PacketLength;
    Mem = ExAllocatePoolWithTagPriority(NonPagedPool, MemLen,
                                        IP6_TAG, LowPoolPriority);
    if (Mem == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "CreateFragmentPacket: Couldn't allocate memory!?!\n"));
        return NULL;
    }

    Packet = (IPv6Packet *) Mem;
    Mem += sizeof(IPv6Packet);

    Packet->Next = NULL;
    Packet->IP = (IPv6Header UNALIGNED *) Mem;
    Packet->IPPosition = 0;
    Packet->Data = Packet->FlatData = Mem;
    Packet->Position = 0;
    Packet->ContigSize = Packet->TotalSize = PacketLength;
    Packet->NdisPacket = NULL;
    Packet->AuxList = NULL;
    Packet->Flags = 0;
    Packet->SrcAddr = AlignAddr(&Packet->IP->Source);
    Packet->SAPerformed = NULL;
    // Our caller must initialize Packet->NTEorIF.
    AdjustPacketParams(Packet, sizeof(IPv6Header));

    //
    // Copy the original IPv6 header into the packet.
    // Note that FragmentReceive ensures that
    // Reass->IPHdr, Reass->UnfragData, and FirstFrag
    // are all consistent.
    //
    RtlCopyMemory(Mem, (uchar *)&Reass->IPHdr, sizeof(IPv6Header));
    Mem += sizeof(IPv6Header);

    ASSERT(Reass->IPHdr.PayloadLength == net_short((ushort)PayloadLength));

    //
    // Copy the unfragmentable data into the packet.
    //
    RtlCopyMemory(Mem, Reass->UnfragData, Reass->UnfragmentLength);
    Mem += Reass->UnfragmentLength;

    //
    // Create a fragment header in the packet.
    //
    FragHdr = (FragmentHeader *) Mem;
    Mem += sizeof(FragmentHeader);

    //
    // Note that if the original offset-zero fragment had
    // a non-zero value in the Reserved field, then we will
    // not recreate it properly. It shouldn't do that.
    //
    FragHdr->NextHeader = Reass->NextHeader;
    FragHdr->Reserved = 0;
    FragHdr->OffsetFlag = net_short(FRAGMENT_FLAG_MASK);
    FragHdr->Id = Reass->Id;

    //
    // Copy the original fragment data into the packet.
    //
    RtlCopyMemory(Mem, PacketShimData(FirstFrag), FirstFrag->Len);

    return Packet;
}


//* ReassemblyTimeout - Handle a reassembly timer event.
//
//  This routine is called periodically by IPv6Timeout to check for
//  timed out fragments.
//
void
ReassemblyTimeout(void)
{
    Reassembly *ThisReass, *NextReass; 
    Reassembly *Expired = NULL;

    //
    // Scan the ReassemblyList checking for expired reassembly contexts.
    //
    KeAcquireSpinLockAtDpcLevel(&ReassemblyList.Lock);
    for (ThisReass = ReassemblyList.First;
         ThisReass != SentinelReassembly;
         ThisReass = NextReass) {
        NextReass = ThisReass->Next;

        //
        // First decrement the timer then check if it has expired.  If so,
        // remove the reassembly record.  This is basically the same code 
        // as in DeleteFromReassemblyList().
        //
        ThisReass->Timer--;

        if (ThisReass->Timer == 0) {
            RemoveReassembly(ThisReass);

            KeAcquireSpinLockAtDpcLevel(&ThisReass->Lock);
            ASSERT((ThisReass->State == REASSEMBLY_STATE_NORMAL) ||
                   (ThisReass->State == REASSEMBLY_STATE_DELETING));

            if (ThisReass->State == REASSEMBLY_STATE_DELETING) {
                //
                // Note that we've removed it from the list already.
                //
                ThisReass->State = REASSEMBLY_STATE_REMOVED;
            }
            else {
                //
                // Move this reassembly context to the expired list.
                // We must take a reference on the interface
                // before releasing the reassembly record lock.
                //
                AddRefIF(ThisReass->IF);
                ThisReass->Next = Expired;
                Expired = ThisReass;
            }
            KeReleaseSpinLockFromDpcLevel(&ThisReass->Lock);
        }
    }
    KeReleaseSpinLockFromDpcLevel(&ReassemblyList.Lock);

    //
    // Now that we no longer need the reassembly list lock,
    // we can send ICMP errors at our leisure.
    //

    while ((ThisReass = Expired) != NULL) {
        Interface *IF = ThisReass->IF;
#if DBG
        char Buffer1[INET6_ADDRSTRLEN], Buffer2[INET6_ADDRSTRLEN];

        FormatV6AddressWorker(Buffer1, &ThisReass->IPHdr.Source);
        FormatV6AddressWorker(Buffer2, &ThisReass->IPHdr.Dest);
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "ReassemblyTimeout: Src %s Dst %s Id %x\n",
                   Buffer1, Buffer2, ThisReass->Id));
#endif

        Expired = ThisReass->Next;

        //
        // Send ICMP error IF we have received the first fragment.
        // NB: Checking Marker != 0 is wrong, because we might have
        // received a zero-length first fragment.
        //
        if (ThisReass->ContigList != NULL) {
            IPv6Packet *Packet;

            Packet = CreateFragmentPacket(ThisReass);
            if (Packet != NULL) {
                NetTableEntryOrInterface *NTEorIF;
                ushort Type;

                NTEorIF = FindAddressOnInterface(IF,
                                                 &ThisReass->IPHdr.Dest,
                                                 &Type);
                if (NTEorIF != NULL) {
                    Packet->NTEorIF = NTEorIF;

                    ICMPv6SendError(Packet,
                                    ICMPv6_TIME_EXCEEDED,
                                    ICMPv6_REASSEMBLY_TIME_EXCEEDED, 0,
                                    Packet->IP->NextHeader, FALSE);

                    if (IsNTE(NTEorIF))
                        ReleaseNTE(CastToNTE(NTEorIF));
                    else
                        ReleaseIF(CastToIF(NTEorIF));
                }

                ExFreePool(Packet);
            }
        }

        //
        // Delete the reassembly record.
        //
        ReleaseIF(IF);
        DeleteReassembly(ThisReass);
    }
}


//* DestinationOptionsReceive - Handle IPv6 Destination options.
// 
//  This is the routine called to process a Destination Options Header,
//  a next header value of 60.
// 
uchar
DestinationOptionsReceive(
    IPv6Packet *Packet)         // Packet handed to us by IPv6Receive.
{
    IPv6OptionsHeader *DestOpt;
    uint ExtLen;
    Options Opts;

    //
    // Verify that we have enough contiguous data to overlay a Destination
    // Options Header structure on the incoming packet.  Then do so.
    //
    if (! PacketPullup(Packet, sizeof *DestOpt,
                       __builtin_alignof(IPv6OptionsHeader), 0)) {
        if (Packet->TotalSize < sizeof *DestOpt) {
        BadPayloadLength:
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "DestinationOptionsReceive: Incoming packet too small"
                       " to contain destination options header\n"));
            ICMPv6SendError(Packet,
                            ICMPv6_PARAMETER_PROBLEM,
                            ICMPv6_ERRONEOUS_HEADER_FIELD,
                            FIELD_OFFSET(IPv6Header, PayloadLength),
                            IP_PROTOCOL_NONE, FALSE);
        }
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    DestOpt = (IPv6OptionsHeader *) Packet->Data;

    //
    // Check that length of destination options also fit in remaining data.
    // The options must also be aligned for any addresses in them.
    //
    ExtLen = (DestOpt->HeaderExtLength + 1) * EXT_LEN_UNIT;
    if (! PacketPullup(Packet, ExtLen,
                       MAX(__builtin_alignof(IPv6OptionsHeader),
                           __builtin_alignof(IPv6Addr)), 0)) {
        if (Packet->TotalSize < ExtLen)
            goto BadPayloadLength;
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    DestOpt = (IPv6OptionsHeader *) Packet->Data;

    //
    // Remember offset to this header's NextHeader field.
    //
    Packet->NextHeaderPosition = Packet->Position +
        FIELD_OFFSET(IPv6OptionsHeader, NextHeader);

    //
    // Skip over the extension header.
    // We need to do this now so subsequent ICMP error generation works.
    //
    AdjustPacketParams(Packet, ExtLen);

    //
    // Parse options in this extension header.  If an error occurs 
    // while parsing the options, discard packet.
    //
    if (!ParseOptions(Packet, IP_PROTOCOL_DEST_OPTS, DestOpt, ExtLen, &Opts)) {
        return IP_PROTOCOL_NONE;  // Drop packet.
    }

    //
    // The processing of any additional options should be added here,
    // before the home address option.
    //

    //
    // Process the home address option.
    //
    if (Opts.HomeAddress) {
        if (IPv6RecvHomeAddress(Packet, Opts.HomeAddress)) {
            //
            // Couldn't process the home address option.  Drop the packet.
            //
            return IP_PROTOCOL_NONE;
        }
    }

    //
    // Process binding update option.
    //
    // Note that the Mobile IP spec says that the effects of processing the
    // Home Address option should not be visible until all other options in
    // the same Destination Options header have been processed.  Although
    // we process the Binding Update option after the Home Address option,
    // we achieve the same effect by requiring IPv6RecvBindingUpdate to
    // know that the Packet->SrcAddr has already been updated.
    //
    if (Opts.BindingUpdate) {
        if (IPv6RecvBindingUpdate(Packet, Opts.BindingUpdate)) {
            //
            // Couldn't process the binding update.  Drop the packet.
            //
            return IP_PROTOCOL_NONE;
        }
    }

    //
    // Return next header value.
    //
    return DestOpt->NextHeader;
}


//* HopByHopOptionsReceive - Handle a IPv6 Hop-by-Hop Options.
//
//  This is the routine called to process a Hop-by-Hop Options Header,
//  next header value of 0.
//
//  Note that this routine is not a normal handler in the Protocol Switch
//  Table.  Instead, it receives special treatment in IPv6HeaderReceive. 
//  Because of this, it returns -1 instead of IP_PROTOCOL_NONE on error.
//
int
HopByHopOptionsReceive(
    IPv6Packet *Packet)         // Packet handed to us by IPv6Receive.
{
    IPv6OptionsHeader *HopByHop;
    uint ExtLen;
    Options Opts;

    //
    // Verify that we have enough contiguous data to overlay a minimum
    // length Hop-by-Hop Options Header.  Then do so.
    //
    if (! PacketPullup(Packet, sizeof *HopByHop,
                       __builtin_alignof(IPv6OptionsHeader), 0)) {
        if (Packet->TotalSize < sizeof *HopByHop) {
        BadPayloadLength:
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "HopByHopOptionsReceive: Incoming packet too small"
                       " to contain Hop-by-Hop Options header\n"));
            ICMPv6SendError(Packet,
                            ICMPv6_PARAMETER_PROBLEM,
                            ICMPv6_ERRONEOUS_HEADER_FIELD,
                            FIELD_OFFSET(IPv6Header, PayloadLength),
                            IP_PROTOCOL_NONE, FALSE);
        }
        return -1;  // Drop packet.
    }
    HopByHop = (IPv6OptionsHeader *) Packet->Data;

    //
    // Check that length of the Hop-by-Hop options also fits in remaining data.
    // The options must also be aligned for any addresses in them.
    //
    ExtLen = (HopByHop->HeaderExtLength + 1) * EXT_LEN_UNIT;
    if (! PacketPullup(Packet, ExtLen,
                       MAX(__builtin_alignof(IPv6OptionsHeader),
                           __builtin_alignof(IPv6Addr)), 0)) {
        if (Packet->TotalSize < ExtLen)
            goto BadPayloadLength;
        return -1;  // Drop packet.
    }
    HopByHop = (IPv6OptionsHeader *) Packet->Data;

    //
    // Remember offset to this header's NextHeader field.
    //
    Packet->NextHeaderPosition = Packet->Position +
        FIELD_OFFSET(IPv6OptionsHeader, NextHeader);

    //
    // Skip over the extension header.
    // We need to do this now so subsequent ICMP error generation works.
    //
    AdjustPacketParams(Packet, ExtLen);

    //
    // Parse options in this extension header.  If an error occurs 
    // while parsing the options, discard packet.
    //
    if (!ParseOptions(Packet, IP_PROTOCOL_HOP_BY_HOP, HopByHop,
                      ExtLen, &Opts)) {
        return -1;  // Drop packet.
    }

    //
    // If we have a valid Jumbo Payload Option, use its value as
    // the packet PayloadLength.
    //
    if (Opts.JumboLength) {
        uint PayloadLength = Opts.JumboLength;

        ASSERT(Packet->IP->PayloadLength == 0);

        //
        // Check that the jumbo length is big enough to include
        // the extension header length. This must be true because
        // the extension-header length is at most 11 bits,
        // while the jumbo length is at least 16 bits.
        //
        ASSERT(PayloadLength > ExtLen);
        PayloadLength -= ExtLen;

        //
        // Check that the amount of payload specified in the Jumbo
        // Payload value fits in the buffer handed to us.
        //
        if (PayloadLength > Packet->TotalSize) {
            //  Silently discard data.
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "HopByHopOptionsReceive: "
                       "Jumbo payload length too big\n"));
            return -1;
        }

        //
        // As in IPv6HeaderReceive, adjust the TotalSize to be exactly the 
        // IP payload size (assume excess is media padding).
        //
        Packet->TotalSize = PayloadLength;
        if (Packet->ContigSize > PayloadLength)
            Packet->ContigSize = PayloadLength;

        //
        // Set the jumbo option packet flag.
        //
        Packet->Flags |= PACKET_JUMBO_OPTION;
    }
    else if (Packet->IP->PayloadLength == 0) {
        //
        // We should have a Jumbo Payload option,
        // but we didn't find it. Send an ICMP error.
        //
        ICMPv6SendError(Packet,
                        ICMPv6_PARAMETER_PROBLEM,
                        ICMPv6_ERRONEOUS_HEADER_FIELD,
                        FIELD_OFFSET(IPv6Header, PayloadLength),
                        HopByHop->NextHeader, FALSE);
        return -1;
    }

    //
    // Return next header value.
    //
    return HopByHop->NextHeader;
}


//* ParseOptions - Routine for generic header options parsing.
//
//  Returns TRUE if the options were successfully parsed.
//  Returns FALSE if the packet should be discarded.
//
int
ParseOptions(
    IPv6Packet *Packet,     // The packet handed to us by IPv6Receive.
    uchar HdrType,          // Hop-by-hop or destination.
    IPv6OptionsHeader *Hdr, // Header with following data.
    uint HdrLength,         // Length of the entire options area.
    Options *Opts)          // Return option values to caller.
{
    uchar *OptPtr;
    uint OptSizeLeft;
    OptionHeader *OptHdr;
    uint OptLen;

    ASSERT((HdrType == IP_PROTOCOL_DEST_OPTS) ||
           (HdrType == IP_PROTOCOL_HOP_BY_HOP));

    //
    // Zero out the Options struct that is returned.
    //
    RtlZeroMemory(Opts, sizeof *Opts);

    //
    // Skip over the extension header.
    //
    OptPtr = (uchar *)(Hdr + 1);
    OptSizeLeft = HdrLength - sizeof *Hdr;

    //
    // Note that if there are multiple options
    // of the same type, we just use the last one encountered
    // unless the spec says specifically it is an error.
    //

    while (OptSizeLeft > 0) {

        //
        // First we check the option length and ensure that it fits.
        // We move OptPtr past this option while leaving OptHdr
        // for use by the option processing code below.
        //

        OptHdr = (OptionHeader *) OptPtr;
        if (OptHdr->Type == OPT6_PAD_1) {
            //
            // This is a special pad option which is just a one byte field, 
            // i.e. it has no length or data field.
            //
            OptLen = 1;
        }
        else {
            //
            // This is a multi-byte option.
            //
            if ((sizeof *OptHdr > OptSizeLeft) ||
                ((OptLen = sizeof *OptHdr + OptHdr->DataLength) >
                 OptSizeLeft)) {
                //
                // Bad length, generate error and discard packet.
                //
                ICMPv6SendError(Packet,
                                ICMPv6_PARAMETER_PROBLEM,
                                ICMPv6_ERRONEOUS_HEADER_FIELD,
                                (GetPacketPositionFromPointer(Packet,
                                                              &Hdr->HeaderExtLength) - 
                                 Packet->IPPosition),
                                Hdr->NextHeader, FALSE);
                return FALSE;
            }
        }
        OptPtr += OptLen;
        OptSizeLeft -= OptLen;

        switch (OptHdr->Type) {
        case OPT6_PAD_1:
        case OPT6_PAD_N:
            break;

        case OPT6_JUMBO_PAYLOAD:
            if (HdrType != IP_PROTOCOL_HOP_BY_HOP)
                goto BadOptionType;

            if (OptHdr->DataLength != sizeof Opts->JumboLength)
                goto BadOptionLength;

            if (Packet->IP->PayloadLength != 0) {
                //
                // Jumbo option encountered when IP payload is not zero.
                // Send ICMP error, set pointer to offset of this option type.
                //
                goto BadOptionType;
            }

            Opts->JumboLength = net_long(*(ulong UNALIGNED *)(OptHdr + 1));
            if (Opts->JumboLength <= MAX_IPv6_PAYLOAD) {
                //
                // Jumbo payload length is not jumbo, send ICMP error.
                // ICMP pointer is set to offset of jumbo payload len field.
                //
                goto BadOptionData;
            }
            break;

        case OPT6_ROUTER_ALERT:
            if (HdrType != IP_PROTOCOL_HOP_BY_HOP)
                goto BadOptionType;

            if (OptLen != sizeof *Opts->Alert)
                goto BadOptionLength;

            if (Opts->Alert != NULL) {
                //
                // Can only have one router alert option.
                //
                goto BadOptionType;
            }

            //
            // Return the pointer to the router alert struct.
            //
            Opts->Alert = (IPv6RouterAlertOption UNALIGNED *)(OptHdr + 1);
            break;

        case OPT6_HOME_ADDRESS:
            if (!(MobileIPv6Mode & MOBILE_CORRESPONDENT))
                goto BadOptionType;

            if (HdrType != IP_PROTOCOL_DEST_OPTS)
                goto BadOptionType;

            if (OptLen < sizeof *Opts->HomeAddress)
                goto BadOptionLength;

            //
            // Return the pointer to the home address option
            // after checking to make sure the address is reasonable.
            // The option must be aligned so that the home address
            // is appropriately aligned.
            //
            Opts->HomeAddress = (IPv6HomeAddressOption UNALIGNED *)OptHdr;
            if (((UINT_PTR)&Opts->HomeAddress->HomeAddress % __builtin_alignof(IPv6Addr)) != 0) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                           "ParseOptions: misaligned home address\n"));
                goto BadOptionType;
            }
            if (IsInvalidSourceAddress(AlignAddr(&Opts->HomeAddress->HomeAddress)) ||
                IsUnspecified(AlignAddr(&Opts->HomeAddress->HomeAddress)) ||
                IsLoopback(AlignAddr(&Opts->HomeAddress->HomeAddress))) {
                //
                // Address contained in option is invalid.
                // Send ICMP error, set pointer to offset of home address.
                //
                goto BadOptionData;
            }
            break;

        case OPT6_BINDING_UPDATE:
            if (!(MobileIPv6Mode & MOBILE_CORRESPONDENT))
                goto BadOptionType;

            if (HdrType != IP_PROTOCOL_DEST_OPTS)
                goto BadOptionType;

            //
            // At a minimum, the binding update must include all of the
            // base header fields.
            //
            if (OptLen < sizeof(IPv6BindingUpdateOption)) {
                //
                // draft-ietf-mobileip-ipv6-13 sec 8.2 says we must
                // silently drop the packet. Normally we would
                // goto BadOptionLength to send an ICMP error.
                //
                return FALSE;
            }

            //
            // Save pointer to the binding update option.  Note we still
            // need to do further length checking.
            //
            Opts->BindingUpdate = (IPv6BindingUpdateOption UNALIGNED *)OptHdr;
            break;

        default:
            if (OPT6_ACTION(OptHdr->Type) == OPT6_A_SKIP) {
                //
                // Ignore the unrecognized option.
                //
                break;
            }
            else if (OPT6_ACTION(OptHdr->Type) == OPT6_A_DISCARD) {
                //
                // Discard the packet.
                //
                return FALSE;
            }
            else {
                //
                // Send an ICMP error.
                //
                ICMPv6SendError(Packet,
                                ICMPv6_PARAMETER_PROBLEM,
                                ICMPv6_UNRECOGNIZED_OPTION,
                                (GetPacketPositionFromPointer(Packet,
                                                              &OptHdr->Type) -
                                 Packet->IPPosition),
                                Hdr->NextHeader,
                                OPT6_ACTION(OptHdr->Type) == 
                                OPT6_A_SEND_ICMP_ALL);
                return FALSE;  // discard the packet.
            }
        }
    }

    return TRUE;

BadOptionType:
    ICMPv6SendError(Packet,
                    ICMPv6_PARAMETER_PROBLEM,
                    ICMPv6_ERRONEOUS_HEADER_FIELD,
                    (GetPacketPositionFromPointer(Packet,
                                                  &OptHdr->Type) -
                     Packet->IPPosition),
                    Hdr->NextHeader, FALSE);
    return FALSE;  // discard packet.

BadOptionLength:
    ICMPv6SendError(Packet,
                    ICMPv6_PARAMETER_PROBLEM,
                    ICMPv6_ERRONEOUS_HEADER_FIELD,
                    (GetPacketPositionFromPointer(Packet,
                                                  &OptHdr->DataLength) -
                     Packet->IPPosition),
                    Hdr->NextHeader, FALSE);
    return FALSE;  // discard packet.

BadOptionData:
    ICMPv6SendError(Packet,
                    ICMPv6_PARAMETER_PROBLEM,
                    ICMPv6_ERRONEOUS_HEADER_FIELD,
                    (GetPacketPositionFromPointer(Packet,
                                                  (uchar *)(OptHdr + 1)) -
                     Packet->IPPosition),
                    Hdr->NextHeader, FALSE);
    return FALSE;  // discard packet.
}


//* ExtHdrControlReceive - generic extension header skip-over routine.
//
//  Routine for processing the extension headers in an ICMP error message
//  before delivering the error message to the upper-layer protocol.
//
uchar
ExtHdrControlReceive(
    IPv6Packet *Packet,         // Packet handed to us by ICMPv6ErrorReceive.
    StatusArg *StatArg)         // ICMP Error code and offset pointer.
{
    uchar NextHdr = StatArg->IP->NextHeader;
    uint HdrLen;

    for (;;) {
        switch (NextHdr) {
        case IP_PROTOCOL_HOP_BY_HOP:
        case IP_PROTOCOL_DEST_OPTS:
        case IP_PROTOCOL_ROUTING: {
            ExtensionHeader *ExtHdr;  // Generic exension header.

            //
            // Here we take advantage of the fact that all of these extension
            // headers share the same first two fields (except as noted below).
            // Since those two fields (Next Header and Header Extension Length)
            // provide us with all the information we need to skip over the
            // header, they're all we need to look at here.
            //
            if (! PacketPullup(Packet, sizeof *ExtHdr,
                               __builtin_alignof(ExtensionHeader), 0)) {
                if (Packet->TotalSize < sizeof *ExtHdr) {
                PacketTooSmall:
                    //
                    // Pullup failed.  There isn't enough of the invoking
                    // packet included in the error message to figure out
                    // what upper layer protocol it originated with.
                    //
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                               "ExtHdrControlReceive: "
                               "Incoming ICMP error packet "
                               "doesn't contain enough of invoking packet\n"));
                }
                return IP_PROTOCOL_NONE;  // Drop packet.
            }

            ExtHdr = (ExtensionHeader *) Packet->Data;
            HdrLen = (ExtHdr->HeaderExtLength + 1) * EXT_LEN_UNIT;

            //
            // Now that we know the actual length of this extension header,
            // skip over it.
            //
            // REVIEW: We could rework this to use PositionPacketAt
            // REVIEW: here instead of PacketPullup as we don't need to
            // REVIEW: look at the data we're skipping over.  Better?
            //
            if (! PacketPullup(Packet, HdrLen, 1, 0)) {
                if (Packet->TotalSize < HdrLen)
                    goto PacketTooSmall;
                return IP_PROTOCOL_NONE;  // Drop packet.
            }

            NextHdr = ExtHdr->NextHeader;
            break;
        }

        case IP_PROTOCOL_FRAGMENT: {
            FragmentHeader UNALIGNED *FragHdr;

            if (! PacketPullup(Packet, sizeof *FragHdr, 1, 0)) {
                if (Packet->TotalSize < sizeof *FragHdr)
                    goto PacketTooSmall;
                return IP_PROTOCOL_NONE;  // Drop packet.
            }

            FragHdr = (FragmentHeader UNALIGNED *) Packet->Data;

            if ((net_short(FragHdr->OffsetFlag) & FRAGMENT_OFFSET_MASK) != 0) {
                //
                // We can only continue parsing if this
                // fragment has offset zero.
                //
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                           "ExtHdrControlReceive: "
                           "non-zero-offset fragment\n"));
                return IP_PROTOCOL_NONE;
            }

            HdrLen = sizeof *FragHdr;
            NextHdr = FragHdr->NextHeader;
            break;
        }

        case IP_PROTOCOL_AH: {
            AHHeader UNALIGNED *AH;

            //
            // Skip over Authentication Header proper.
            //
            if (!PacketPullup(Packet, sizeof(AHHeader), 1, 0)) {
                if (Packet->TotalSize < sizeof(AHHeader))
                    goto PacketTooSmall;
                return IP_PROTOCOL_NONE;  // Drop packet.
            }

            AH = (AHHeader UNALIGNED *)Packet->Data;
            AdjustPacketParams(Packet, sizeof(AHHeader));

            //
            // Skip over Authentication Data.
            // Note: we don't attempt any verification of this packet.
            //
            // In the event of a bad packet, HdrLen could underflow here,
            // but this is okay since (being unsigned) it will fail the
            // subsequent PacketPullup and length check.
            //
            HdrLen = ((AH->PayloadLen + 2) * 4) - sizeof(AHHeader);
            if (!PacketPullup(Packet, HdrLen, 1, 0)) {
                if (Packet->TotalSize < HdrLen)
                    goto PacketTooSmall;
                return IP_PROTOCOL_NONE;  // Drop packet.
            }

            NextHdr = AH->NextHeader;
            break;
        }

        case IP_PROTOCOL_ESP:
            //
            // REVIEW - What is the correct thing here?
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "ExtHdrControlReceive: found ESP\n"));
            return IP_PROTOCOL_NONE;

        default:
            //
            // We came to a header that we do not recognize,
            // so we can not continue parsing here.
            // But our caller might recognize this header type.
            //
            return NextHdr;
        }

        //
        // Move past this extension header.
        //
        AdjustPacketParams(Packet, HdrLen);
    }
}


//* RoutingReceive - Handle the IPv6 Routing Header.
//
//  Called from IPv6Receive when we encounter a Routing Header,
//  next header value of 43.
//
uchar
RoutingReceive(
    IPv6Packet *Packet)         // Packet handed to us by link layer.
{
    IPv6RoutingHeader *RH;
    uint HeaderLength;
    uint SegmentsLeft;
    uint NumAddresses, i;
    IPv6Addr *Addresses;
    IP_STATUS Status;
    uchar *Mem;
    uint MemLen, Offset;
    NDIS_PACKET *FwdPacket;
    NDIS_STATUS NdisStatus;
    IPv6Header UNALIGNED *FwdIP;
    IPv6RoutingHeader UNALIGNED *FwdRH;
    IPv6Addr UNALIGNED *FwdAddresses;
    IPv6Addr FwdDest;
    int Delta;
    uint PayloadLength;
    uint TunnelStart = NO_TUNNEL, IPSecBytes = 0;
    IPSecProc *IPSecToDo;
    RouteCacheEntry *RCE;
    uint Action;

    //
    // Verify that we have enough contiguous data,
    // then get a pointer to the routing header.
    //
    if (! PacketPullup(Packet, sizeof *RH,
                       __builtin_alignof(IPv6RoutingHeader), 0)) {
        if (Packet->TotalSize < sizeof *RH) {
        BadPayloadLength:
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "RoutingReceive: Incoming packet too small"
                       " to contain routing header\n"));
            ICMPv6SendError(Packet,
                            ICMPv6_PARAMETER_PROBLEM,
                            ICMPv6_ERRONEOUS_HEADER_FIELD,
                            FIELD_OFFSET(IPv6Header, PayloadLength),
                            IP_PROTOCOL_NONE, FALSE);
        }
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    RH = (IPv6RoutingHeader *) Packet->Data;

    //
    // Now get the entire routing header.
    // Also align for the address array.
    //
    HeaderLength = (RH->HeaderExtLength + 1) * EXT_LEN_UNIT;
    if (! PacketPullup(Packet, HeaderLength,
                       MAX(__builtin_alignof(IPv6RoutingHeader),
                           __builtin_alignof(IPv6Addr)), 0)) {
        if (Packet->TotalSize < HeaderLength)
            goto BadPayloadLength;
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    RH = (IPv6RoutingHeader *) Packet->Data;

    //
    // Remember offset to this header's NextHeader field.
    //
    Packet->NextHeaderPosition = Packet->Position +
        FIELD_OFFSET(IPv6RoutingHeader, NextHeader);

    //
    // Move past the routing header.
    // We need to do this now so subsequent ICMP error generation works.
    //
    AdjustPacketParams(Packet, HeaderLength);

    //
    // If SegmentsLeft is zero, we proceed directly to the next header.
    // We must not check the Type value or HeaderLength.
    //
    SegmentsLeft = RH->SegmentsLeft;
    if (SegmentsLeft == 0) {
        //
        // Return next header value.
        //
        return RH->NextHeader;
    }

    //
    // If we do not recognize the Type value, generate an ICMP error.
    //
    if (RH->RoutingType != 0) {
        ICMPv6SendError(Packet,
                        ICMPv6_PARAMETER_PROBLEM,
                        ICMPv6_ERRONEOUS_HEADER_FIELD,
                        (GetPacketPositionFromPointer(Packet,
                                                      &RH->RoutingType) -
                         Packet->IPPosition),
                        RH->NextHeader, FALSE);
        return IP_PROTOCOL_NONE;  // No further processing of this packet.
    }

    //
    // We must have an integral number of IPv6 addresses
    // in the routing header.
    //
    if (RH->HeaderExtLength & 1) {
        ICMPv6SendError(Packet,
                        ICMPv6_PARAMETER_PROBLEM,
                        ICMPv6_ERRONEOUS_HEADER_FIELD,
                        (GetPacketPositionFromPointer(Packet,
                                                      &RH->HeaderExtLength) -
                         Packet->IPPosition),
                        RH->NextHeader, FALSE);
        return IP_PROTOCOL_NONE;  // No further processing of this packet.
    }

    NumAddresses = RH->HeaderExtLength / 2;

    //
    // Sanity check SegmentsLeft.
    //
    if (SegmentsLeft > NumAddresses) {
        ICMPv6SendError(Packet,
                        ICMPv6_PARAMETER_PROBLEM,
                        ICMPv6_ERRONEOUS_HEADER_FIELD,
                        (GetPacketPositionFromPointer(Packet,
                                                      &RH->SegmentsLeft) -
                         Packet->IPPosition),
                        RH->NextHeader, FALSE);
        return IP_PROTOCOL_NONE;  // No further processing of this packet.
    }

    //
    // Sanity check the destination address.
    // Packets carrying a Type 0 Routing Header must not
    // be sent to a multicast destination.
    //
    if (IsMulticast(AlignAddr(&Packet->IP->Dest))) {
        //
        // Just drop the packet, no ICMP error in this case.
        //
        return IP_PROTOCOL_NONE;  // No further processing of this packet.
    }

    i = NumAddresses - SegmentsLeft;
    Addresses = AlignAddr((IPv6Addr UNALIGNED *) (RH + 1));

    //
    // Sanity check the new destination.
    // RFC 2460 doesn't mention checking for an unspecified address,
    // but I think it's a good idea. Similarly, for security reasons,
    // we also check the scope of the destination. This allows
    // applications to check the scope of the eventual destination address
    // and know that the packet originated within that scope.
    // RFC 2460 says to discard the packet without an ICMP error
    // (at least when the new destination is multicast),
    // but I think an ICMP error is helpful in this situation.
    //
    if (IsMulticast(&Addresses[i]) ||
        IsUnspecified(&Addresses[i]) ||
        (UnicastAddressScope(&Addresses[i]) <
         UnicastAddressScope(AlignAddr(&Packet->IP->Dest)))) {

        ICMPv6SendError(Packet,
                        ICMPv6_PARAMETER_PROBLEM,
                        ICMPv6_ERRONEOUS_HEADER_FIELD,
                        (GetPacketPositionFromPointer(Packet, (uchar *)
                                                      &Addresses[i]) -
                         Packet->IPPosition),
                        RH->NextHeader, FALSE);
        return IP_PROTOCOL_NONE;  // No further processing of this packet.
    }

    //
    // Verify IPSec was performed.
    //
    if (InboundSecurityCheck(Packet, 0, 0, 0, Packet->NTEorIF->IF) != TRUE) {
        //
        // No policy was found or the policy indicated to drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "RoutingReceive: "
                   "IPSec lookup failed or policy was to drop\n"));
        return IP_PROTOCOL_NONE;  // Drop packet.
    }

    //
    // Find a route to the new destination.
    //
    Status = RouteToDestination(&Addresses[i],
                                0, Packet->NTEorIF,
                                RTD_FLAG_LOOSE, &RCE);
    if (Status != IP_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "RoutingReceive: "
                   "No route to destination for forwarding.\n"));
        ICMPv6SendError(Packet,
                        ICMPv6_DESTINATION_UNREACHABLE,
                        ICMPv6_NO_ROUTE_TO_DESTINATION,
                        0, RH->NextHeader, FALSE);
        return IP_PROTOCOL_NONE;
    }

    //
    // For security reasons, we prevent source routing
    // in some situations. Check those now.
    //
    if (Packet->NTEorIF->IF->Flags & IF_FLAG_FORWARDS) {
        //
        // The interface is forwarding, so source-routing is allowed.
        //
    }
    else if ((Packet->NTEorIF->IF == RCE->NCE->IF) &&
             (SegmentsLeft == 1) &&
             IP6_ADDR_EQUAL(&Addresses[i], AlignAddr(&Packet->IP->Source))) {
        //
        // Same-interface rule says source-routing is allowed,
        // because the host is not acting as a conduit
        // between two networks. See RFC 1122 section 3.3.5.
        // Furthermore, we only allow round-trip source-routing
        // because that's the only useful scenario that we know of
        // for hosts. This prevents unanticipated bad uses.
        //
    }
    else {
        //
        // We can not allow this use of source-routing.
        // Instead of reporting an error, we could
        // redo RouteToDestination with RTD_FLAG_STRICT
        // to constrain to the same interface.
        // However, an ICMP error is more in keeping
        // with the treatment of scoped source addresses,
        // which can produce a destination-unreachable error.
        //
        ReleaseRCE(RCE);
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "RoutingReceive: Inappropriate route.\n"));
        ICMPv6SendError(Packet,
                        ICMPv6_DESTINATION_UNREACHABLE,
                        ICMPv6_COMMUNICATION_PROHIBITED,
                        0, RH->NextHeader, FALSE);
        return IP_PROTOCOL_NONE;
    }

    //
    // Find the Security Policy for this outbound traffic.
    // The source address is the same but the destination address is the
    // next hop from the routing header.
    //
    IPSecToDo = OutboundSPLookup(AlignAddr(&Packet->IP->Source),
                                 &Addresses[i],
                                 0, 0, 0, RCE->NCE->IF, &Action);

    if (IPSecToDo == NULL) {
        //
        // Check Action.
        //
        if (Action == LOOKUP_DROP) {
            // Drop packet.
            ReleaseRCE(RCE);
            return IP_PROTOCOL_NONE;
        } else {
            if (Action == LOOKUP_IKE_NEG) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                           "RoutingReceive: IKE not supported yet.\n"));
                ReleaseRCE(RCE);
                return IP_PROTOCOL_NONE;
            }
        }

        //
        // With no IPSec to perform, IPv6Forward won't be changing the
        // outgoing interface from what we currently think it will be.
        // So we can use the exact size of its link-level header.
        //
        Offset = RCE->NCE->IF->LinkHeaderSize;

    } else {
        //
        // Calculate the space needed for the IPSec headers.
        //
        IPSecBytes = IPSecBytesToInsert(IPSecToDo, &TunnelStart, NULL);

        if (TunnelStart != 0) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "RoutingReceive: IPSec Tunnel mode only.\n"));
            FreeIPSecToDo(IPSecToDo, IPSecToDo->BundleSize);
            ReleaseRCE(RCE);
            return IP_PROTOCOL_NONE;
        }

        //
        // The IPSec code in IPv6Forward might change the outgoing
        // interface from what we currently think it will be.  Play it
        // safe and leave the max amount of space for its link-level header.
        //
        Offset = MAX_LINK_HEADER_SIZE;
    }

    //
    // The packet has passed all our checks.
    // We can construct a revised packet for transmission.
    // First we allocate a packet, buffer, and memory.
    //
    // NB: The original packet is read-only for us. Furthermore
    // we can not keep a pointer to it beyond the return of this
    // function. So we must copy the packet and then modify it.
    //

    // Packet->IP->PayloadLength might be zero with jumbograms.
    Delta = Packet->Position - Packet->IPPosition;
    PayloadLength = Packet->TotalSize + Delta - sizeof(IPv6Header);
    MemLen = Offset + sizeof(IPv6Header) + PayloadLength + IPSecBytes;

    NdisStatus = IPv6AllocatePacket(MemLen, &FwdPacket, &Mem);
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        if (IPSecToDo) {
            FreeIPSecToDo(IPSecToDo, IPSecToDo->BundleSize);
        }
        ReleaseRCE(RCE);
        return IP_PROTOCOL_NONE; // No further processing of this packet.
    }

    FwdIP = (IPv6Header UNALIGNED *)(Mem + Offset + IPSecBytes);
    FwdRH = (IPv6RoutingHeader UNALIGNED *)
        ((uchar *)FwdIP + Delta - HeaderLength);
    FwdAddresses = (IPv6Addr UNALIGNED *) (FwdRH + 1);

    //
    // Now we copy from the original packet to the new packet.
    //
    CopyPacketToBuffer((uchar *)FwdIP, Packet,
                       sizeof(IPv6Header) + PayloadLength,
                       Packet->IPPosition);

    //
    // Fix up the new packet - put in the new destination address
    // and decrement SegmentsLeft.
    // NB: We pass the Reserved field through unmodified!
    // This violates a strict reading of the spec,
    // but Steve Deering has confirmed that this is his intent.
    //
    FwdDest = *AlignAddr(&FwdAddresses[i]);
    *AlignAddr(&FwdAddresses[i]) = *AlignAddr(&FwdIP->Dest);
    *AlignAddr(&FwdIP->Dest) = FwdDest;
    FwdRH->SegmentsLeft--;

    //
    // Forward the packet. This decrements the Hop Limit and generates
    // any applicable ICMP errors (Time Limit Exceeded, Destination
    // Unreachable, Packet Too Big). Note that previous ICMP errors
    // that we generated were based on the unmodified incoming packet,
    // while from here on the ICMP errors are based on the new FwdPacket.
    //
    IPv6Forward(Packet->NTEorIF, FwdPacket, Offset + IPSecBytes, FwdIP,
                PayloadLength, FALSE, // Don't Redirect.
                IPSecToDo, RCE);

    if (IPSecToDo) {
        FreeIPSecToDo(IPSecToDo, IPSecToDo->BundleSize);
    }

    ReleaseRCE(RCE);
    return IP_PROTOCOL_NONE;  // No further processing of this packet.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\send.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Transmit routines for Internet Protocol Version 6.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "route.h"
#include "select.h"
#include "icmp.h"
#include "neighbor.h"
#include "fragment.h"
#include "security.h"  
#include "ipsec.h"
#include "md5.h"
#include "info.h"

//
// Structure of completion data for "Care Of" packets.
//
typedef struct CareOfCompletionInfo {
    void (*SavedCompletionHandler)(PNDIS_PACKET Packet, IP_STATUS Status);
                                        // Original handler.
    void *SavedCompletionData;          // Original data.
    PNDIS_BUFFER SavedFirstBuffer;
    uint NumESPTrailers;
} CareOfCompletionInfo;


ulong FragmentId = 0;

//* NewFragmentId - generate a unique fragment identifier.
//
//  Returns a fragment id.
//
__inline
ulong
NewFragmentId(void)
{
    return InterlockedIncrement((PLONG)&FragmentId);
}


//* IPv6AllocatePacket
//
//  Allocates a single-buffer packet.
//
//  The completion handler for the packet is set to IPv6PacketComplete,
//  although the caller can easily change that if desired.
//
NDIS_STATUS
IPv6AllocatePacket(
    uint Length,
    PNDIS_PACKET *pPacket,
    void **pMemory)
{
    PNDIS_PACKET Packet;
    PNDIS_BUFFER Buffer;
    void *Memory;
    NDIS_STATUS Status;

    NdisAllocatePacket(&Status, &Packet, IPv6PacketPool);
    if (Status != NDIS_STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6AllocatePacket - couldn't allocate header!?!\n"));
        return Status;
    }

    Memory = ExAllocatePoolWithTagPriority(NonPagedPool, Length,
                                           IP6_TAG, LowPoolPriority);
    if (Memory == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6AllocatePacket - couldn't allocate pool!?!\n"));
        NdisFreePacket(Packet);
        return NDIS_STATUS_RESOURCES;
    }

    NdisAllocateBuffer(&Status, &Buffer, IPv6BufferPool,
                       Memory, Length);
    if (Status != NDIS_STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6AllocatePacket - couldn't allocate buffer!?!\n"));
        ExFreePool(Memory);
        NdisFreePacket(Packet);
        return Status;
    }

    InitializeNdisPacket(Packet);
    PC(Packet)->CompletionHandler = IPv6PacketComplete;
    NdisChainBufferAtFront(Packet, Buffer);
    *pPacket = Packet;
    *pMemory = Memory;
    return NDIS_STATUS_SUCCESS;
}


//* IPv6FreePacket - free an IPv6 packet.
//
//  Frees a packet whose buffers were allocated from the IPv6BufferPool.
//
void
IPv6FreePacket(PNDIS_PACKET Packet)
{
    PNDIS_BUFFER Buffer, NextBuffer;

    //
    // Free all the buffers in the packet.
    // Start with the first buffer in the packet and follow the chain.
    //
    NdisQueryPacket(Packet, NULL, NULL, &Buffer, NULL);
    for (; Buffer != NULL; Buffer = NextBuffer) {
        VOID *Mem;
        UINT Unused;

        //
        // Free the buffer descriptor back to IPv6BufferPool and its
        // associated memory back to the heap.  Not clear if it would be
        // safe to free the memory before the buffer (because the buffer
        // references the memory), but this order should definitely be safe.
        //
        NdisGetNextBuffer(Buffer, &NextBuffer);
        NdisQueryBuffer(Buffer, &Mem, &Unused);
        NdisFreeBuffer(Buffer);
        ExFreePool(Mem);
    }

    //
    // Free the packet back to IPv6PacketPool.
    //
    NdisFreePacket(Packet);
}


//* IPv6PacketComplete
//
//  Generic packet completion handler.
//  Just frees the packet.
//
void
IPv6PacketComplete(
    PNDIS_PACKET Packet,
    IP_STATUS Status)
{
    UNREFERENCED_PARAMETER(Status);
    IPv6FreePacket(Packet);
}


//* IPv6CareOfComplete - Completion handler for "Care Of" packets.
//
//  Completion handler for packets that had a routing header inserted
//  because of a Binding Cache Entry.
//
void  //  Returns: Nothing.
IPv6CareOfComplete(
    PNDIS_PACKET Packet,
    IP_STATUS Status)
{
    PNDIS_BUFFER Buffer;
    uchar *Memory;
    uint Length;

    CareOfCompletionInfo *CareOfInfo = 
        (CareOfCompletionInfo *)PC(Packet)->CompletionData;

    ASSERT(CareOfInfo->SavedFirstBuffer != NULL);
    
    //
    // Remove the first buffer that IPv6Send created, re-chain
    // the original first buffer, and restore the original packet
    // completion info.
    //
    NdisUnchainBufferAtFront(Packet, &Buffer);
    NdisChainBufferAtFront(Packet, CareOfInfo->SavedFirstBuffer);
    PC(Packet)->CompletionHandler = CareOfInfo->SavedCompletionHandler;
    PC(Packet)->CompletionData = CareOfInfo->SavedCompletionData;

    //
    // Now free the removed buffer and its memory.
    //
    NdisQueryBuffer(Buffer, &Memory, &Length);
    NdisFreeBuffer(Buffer);
    ExFreePool(Memory);

    //
    // Check if there are any ESP trailers that need to be freed.
    //
    for ( ; CareOfInfo->NumESPTrailers > 0; CareOfInfo->NumESPTrailers--) {
        // Remove the ESP Trailer.
        NdisUnchainBufferAtBack(Packet, &Buffer);
        //
        // Free the removed buffer and its memory.
        //
        NdisQueryBuffer(Buffer, &Memory, &Length);
        NdisFreeBuffer(Buffer);
        ExFreePool(Memory);
    }

    //
    // Free care-of completion data.
    //
    ExFreePool(CareOfInfo);

    //
    // The packet should now have it's original completion handler
    // specified for us to call.
    //
    ASSERT(PC(Packet)->CompletionHandler != NULL);

    //
    // Call the packet's designated completion handler.
    //
    (*PC(Packet)->CompletionHandler)(Packet, Status);
}


//* IPv6SendComplete - IP send complete handler.
//
//  Called by the link layer when a send completes.  We're given a pointer to
//  a net structure, as well as the completing send packet and the final status
//  of the send.
//
//  The Context argument is NULL if and only if the Packet has not
//  actually been handed via IPv6SendLL to a link.
//
//  The Status argument is usually one of three values:
//      IP_SUCCESS
//      IP_PACKET_TOO_BIG
//      IP_GENERAL_FAILURE
//
//  May be called in a DPC or thread context.
//
//  To prevent recursion, send-completion routines should
//  avoid sending packets directly. Schedule a DPC instead.
//
void                      //  Returns: Nothing.
IPv6SendComplete(
    void *Context,        // Context we gave to the link layer on registration.
    PNDIS_PACKET Packet,  // Packet completing send.
    IP_STATUS Status)     // Final status of send.
{
    Interface *IF = PC(Packet)->IF;

    ASSERT(Context == IF);
    UNREFERENCED_PARAMETER(Context);

    if ((IF != NULL) && !(PC(Packet)->Flags & NDIS_FLAGS_DONT_LOOPBACK)) {
        //
        // Send the packet via loopback also.
        // The loopback code will call IPv6SendComplete again,
        // after setting NDIS_FLAGS_DONT_LOOPBACK.
        //
        LoopQueueTransmit(Packet);
        return;
    }

    //
    // The packet should have a completion handler specified for us to call.
    //
    ASSERT(PC(Packet)->CompletionHandler != NULL);

    //
    // Call the packet's designated completion handler.
    // This should free the packet.
    //
    (*PC(Packet)->CompletionHandler)(Packet, Status);

    //
    // Release the packet's reference for the sending interface,
    // if this packet has actually been sent.
    // If the packet is completed before transmission,
    // it does not hold a reference for the interface.
    //
    if (IF != NULL)
        ReleaseIF(IF);
}


//* IPv6SendLL
//
//  Hands a packet down to the link-layer and/or the loopback module.
//
//  Callable from thread or DPC context.
//  Must be called with no locks held.
//
void
IPv6SendLL(
    Interface *IF,
    PNDIS_PACKET Packet,
    uint Offset,
    const void *LinkAddress)
{
    //
    // The packet needs to hold a reference to the sending interface,
    // because the transmit is asynchronous.
    //
    AddRefIF(IF);
    ASSERT(PC(Packet)->IF == NULL);
    PC(Packet)->IF = IF;
    PC(Packet)->pc_offset = Offset;

    //
    // Are we sending the packet via loopback or via the link?
    // NDIS_FLAGS_LOOPBACK_ONLY means do NOT send via the link.
    // NDIS_FLAGS_DONT_LOOPBACK means do NOT send via loopback.
    // Finalize these flag bits here.
    // NB: One or both may already be set.
    //
    if (PC(Packet)->Flags & NDIS_FLAGS_MULTICAST_PACKET) {
        //
        // Multicast packets are sent both ways by default.
        // If the interface is not receiving this address,
        // then don't bother with loopback.
        //
        if (! CheckLinkLayerMulticastAddress(IF, LinkAddress))
            PC(Packet)->Flags |= NDIS_FLAGS_DONT_LOOPBACK;
    }
    else {
        //
        // Unicast packets are either sent via loopback
        // or via the link, but not both.
        //
        if (RtlCompareMemory(IF->LinkAddress, LinkAddress,
                             IF->LinkAddressLength) == IF->LinkAddressLength)
            PC(Packet)->Flags |= NDIS_FLAGS_LOOPBACK_ONLY;
        else
            PC(Packet)->Flags |= NDIS_FLAGS_DONT_LOOPBACK;
    }

    //
    // If a packet is both looped-back and sent via the link,
    // we hand it to the link first and then IPv6SendComplete
    // handles the loopback.
    //
    if (!(PC(Packet)->Flags & NDIS_FLAGS_LOOPBACK_ONLY)) {
        //
        // Send it via the link.
        //
        (*IF->Transmit)(IF->LinkContext, Packet, Offset, LinkAddress);
    }
    else if (!(PC(Packet)->Flags & NDIS_FLAGS_DONT_LOOPBACK)) {
        //
        // Send it via loopback.
        //
        LoopQueueTransmit(Packet);
    }
    else {
        //
        // We do not send this packet.
        //
        IPv6SendComplete(IF, Packet, IP_SUCCESS);
    }
}

//
// We store the Interface in our own field
// instead of using PC(Packet)->IF to maintain
// an invariant for IPv6SendLL and IPv6SendComplete:
// PC(Packet)->IF is only set when the packet
// is actually transmitted.
//
typedef struct IPv6SendLaterInfo {
    KDPC Dpc;
    KTIMER Timer;
    Interface *IF;
    PNDIS_PACKET Packet;
    uchar LinkAddress[];
} IPv6SendLaterInfo;

//* IPv6SendLaterWorker
//
//  Finishes the work of IPv6SendLater by calling IPv6SendLL.
//
//  Called in a DPC context.
//
void
IPv6SendLaterWorker(
    PKDPC MyDpcObject,  // The DPC object describing this routine.
    void *Context,      // The argument we asked to be called with.
    void *Unused1,
    void *Unused2)
{
    IPv6SendLaterInfo *Info = (IPv6SendLaterInfo *) Context;
    Interface *IF = Info->IF;
    NDIS_PACKET *Packet = Info->Packet;

    UNREFERENCED_PARAMETER(MyDpcObject);
    UNREFERENCED_PARAMETER(Unused1);
    UNREFERENCED_PARAMETER(Unused2);

    //
    // Finally, transmit the packet.
    //
    IPv6SendLL(IF, Packet, PC(Packet)->pc_offset, Info->LinkAddress);

    ReleaseIF(IF);
    ExFreePool(Info);
}


//* IPv6SendLater
//
//  Like IPv6SendLL, but defers the actual transmit until later.
//  This is useful in two scenarios. First, the caller
//  may hold a spinlock (like an interface lock), preventing
//  direct use of IPv6SendLL. Second, our caller may wish
//  to delay the transmit for a small period of time.
//
//  Because this function performs memory allocation, it can fail.
//  If it fails, the caller must dispose of the packet.
//
//  Callable from thread or DPC context.
//  May be called with locks held.
//
NDIS_STATUS
IPv6SendLater(
    LARGE_INTEGER Time,         // Zero means immediately.
    Interface *IF,
    PNDIS_PACKET Packet,
    uint Offset,
    const void *LinkAddress)
{
    IPv6SendLaterInfo *Info;

    Info = ExAllocatePoolWithTagPriority(
                        NonPagedPool, sizeof *Info + IF->LinkAddressLength,
                        IP6_TAG, LowPoolPriority);
    if (Info == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6SendLater: no pool\n"));
        return NDIS_STATUS_RESOURCES;
    }

    AddRefIF(IF);
    Info->IF = IF;
    PC(Packet)->pc_offset = Offset;
    Info->Packet = Packet;
    RtlCopyMemory(Info->LinkAddress, LinkAddress, IF->LinkAddressLength);

    KeInitializeDpc(&Info->Dpc, IPv6SendLaterWorker, Info);

    if (Time.QuadPart == 0) {
        //
        // Queue the DPC for immediate execution.
        //
        KeInsertQueueDpc(&Info->Dpc, NULL, NULL);
    }
    else {
        //
        // Initialize a timer that will queue the DPC later.
        //
        KeInitializeTimer(&Info->Timer);
        KeSetTimer(&Info->Timer, Time, &Info->Dpc);
    }

    return NDIS_STATUS_SUCCESS;
}


//* IPv6SendND
//
//  IPv6 primitive for sending via Neighbor Discovery.
//  We already know the first-hop destination and have a completed
//  packet ready to send.  All we really do here is check & update the
//  NCE's neighbor discovery state.
//
//  Discovery Address is the source address to use in neighbor 
//  discovery solicitations.
//
//  If DiscoveryAddress is not NULL, it must NOT be the address
//  of the packet's source address, because that memory might
//  be gone might by the time we reference it in NeighborSolicitSend.
//  It must point to memory that will remain valid across
//  IPv6SendND's entire execution.
//
//  If DiscoveryAddress is NULL, then the Packet must be well-formed.
//  It must have a valid IPv6 header. For example, the raw header-include
//  path can NOT pass in NULL.
//
//  Whether the Packet is well-formed or not, the first 40 bytes
//  of data must be accessible in the kernel. This is because
//  an ND failure will lead to IPv6SendAbort, which uses GetIPv6Header,
//  which calls GetDataFromNdis, which calls NdisQueryBuffer,
//  which bugchecks when the buffer can not be mapped.
//
//  REVIEW - Should IPv6SendND live in send.c or neighbor.c?
//
//  Callable from thread or DPC context.
//
void
IPv6SendND(
    PNDIS_PACKET Packet,        // Packet to send.
    uint Offset,                // Offset from start of Packet to IP header.
    NeighborCacheEntry *NCE,    // First-hop neighbor information.
    const IPv6Addr *DiscoveryAddress) // Address to use for neighbor discovery.
{
    NDIS_PACKET *PacketList;
    IPv6Addr DiscoveryAddressBuffer;
    KIRQL OldIrql;      // For locking the interface's neighbor cache.
    Interface *IF;      // Interface to send via.

    ASSERT(NCE != NULL);
    IF = NCE->IF;

    //
    // Are we sending to a multicast IPv6 destination?
    // Pass this information to IPv6SendLL.
    //
    if (IsMulticast(&NCE->NeighborAddress))
        PC(Packet)->Flags |= NDIS_FLAGS_MULTICAST_PACKET;

RetryRequest:
    KeAcquireSpinLock(&IF->LockNC, &OldIrql);

    //
    // If the interface is disabled, we can't send packets.
    //
    if (IsDisabledIF(IF)) {
        KeReleaseSpinLock(&IF->LockNC, OldIrql);

    AbortRequest:
        IPSInfo.ipsi_outdiscards++;
        IPv6SendComplete(NULL, Packet, IP_GENERAL_FAILURE);
        return;
    }

    //
    // Check the Neighbor Discovery Protocol state of our Neighbor to
    // insure that we have current information to work with.  We don't
    // have a timer going off to drive this in the common case, but
    // instead check the reachability timestamp directly here.
    //
    switch (NCE->NDState) {
    case ND_STATE_PERMANENT:
        //
        // This neighbor is always valid.
        //
        break;

    case ND_STATE_REACHABLE:
        //
        // Common case.  We've verified neighbor reachability within
        // the last 'ReachableTime' ticks of the system interval timer.
        // If the time limit hasn't expired, we're free to go.
        //
        // Note that the following arithmetic will correctly handle wraps
        // of the IPv6 tick counter.
        //
        if ((uint)(IPv6TickCount - NCE->LastReachability) <=
                                                IF->ReachableTime) {
            //
            // Got here within the time limit.  Just send it.
            //
            break;
        }

        //
        // Too long since last send.  Entry went stale.  Conceptually,
        // we've been in the STALE state since the above quantity went
        // positive.  So just drop on into it now...
        // 

    case ND_STATE_STALE:
        //
        // We have a stale entry in our neighbor cache.  Go into DELAY
        // state, start the delay timer, and send the packet anyway.
        // NB: Internally we use PROBE state instead of DELAY.
        //
        NCE->NDState = ND_STATE_PROBE;
        NCE->NSTimer = DELAY_FIRST_PROBE_TIME;
        NCE->NSLimit = MAX_UNICAST_SOLICIT;
        NCE->NSCount = 0;
        break;

    case ND_STATE_PROBE:
        //
        // While in the PROBE state, we continue to send to our
        // cached address and hope for the best.
        //
        // First, check NSLimit. It might be MAX_UNREACH_SOLICIT or
        // MAX_UNICAST_SOLICIT. Ensure it's at least MAX_UNICAST_SOLICIT.
        //
        if (NCE->NSLimit < MAX_UNICAST_SOLICIT)
            NCE->NSLimit = MAX_UNICAST_SOLICIT;
        //
        // Second, if we have not started actively probing yet, ensure
        // we do not wait longer than DELAY_FIRST_PROBE_TIME to start.
        //
        if ((NCE->NSCount == 0) && (NCE->NSTimer > DELAY_FIRST_PROBE_TIME))
            NCE->NSTimer = DELAY_FIRST_PROBE_TIME;
        break;

    case ND_STATE_INCOMPLETE: {
        PNDIS_PACKET OldPacket;
        int SendSolicit;

        if (!(IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS)) {
            //
            // This interface does not support Neighbor Discovery.
            // We can not resolve the address.
            // Mark the neighbor unreachable and invalidate the route cache.
            // This gives FindNextHop an opportunity to round-robin.
            //
            NCE->IsUnreachable = TRUE;
            NCE->LastReachability = IPv6TickCount; // Timestamp it.
            NCE->DoRoundRobin = TRUE;
            InvalidateRouteCache();
            
            KeReleaseSpinLock(&IF->LockNC, OldIrql);
            IPSInfo.ipsi_outnoroutes++;

            IPv6SendAbort(CastFromIF(IF), Packet, Offset,
                          ICMPv6_DESTINATION_UNREACHABLE,
                          ICMPv6_ADDRESS_UNREACHABLE, 0, FALSE);
            return;
        }

        //
        // Get DiscoveryAddress from the packet
        // if we don't already have it.
        // We SHOULD use the packet's source address if possible.
        //
        if (DiscoveryAddress == NULL) {
            IPv6Header UNALIGNED *IP;
            IPv6Header HdrBuffer;
            NetTableEntry *NTE;
            int IsValid;

            KeReleaseSpinLock(&IF->LockNC, OldIrql);

            DiscoveryAddress = &DiscoveryAddressBuffer;

            //
            // Get the packet's source address.
            // Anyone sending possibly-malformed packets (eg RawSend)
            // must specify DiscoveryAddress, so GetIPv6Header
            // will always succeed.
            //
            IP = GetIPv6Header(Packet, Offset, &HdrBuffer);
            ASSERT(IP != NULL);
            DiscoveryAddressBuffer = IP->Source;

            //
            // Check that the address is a valid unicast address
            // assigned to the outgoing interface.
            //
            KeAcquireSpinLock(&IF->Lock, &OldIrql);
            NTE = (NetTableEntry *) *FindADE(IF, DiscoveryAddress);
            IsValid = ((NTE != NULL) &&
                       (NTE->Type == ADE_UNICAST) &&
                       IsValidNTE(NTE));
            KeReleaseSpinLock(&IF->Lock, OldIrql);

            if (! IsValid) {
                //
                // Can't use the packet's source address.
                // Try the interface's link-local address.
                //
                if (! GetLinkLocalAddress(IF, &DiscoveryAddressBuffer)) {
                    //
                    // Without a valid link-local address, give up.
                    //
                    goto AbortRequest;
                }
            }

            //
            // Now that we have a valid DiscoveryAddress,
            // start over.
            //
            goto RetryRequest;
        }

        //
        // We do not have a valid link-layer address for the neighbor.
        // We must queue the packet, pending neighbor discovery.
        // Remember the packet's offset in the Packet6Context area.
        // REVIEW: For now, wait queue is just one packet deep.
        //
        OldPacket = NCE->WaitQueue;
        PC(Packet)->pc_offset = Offset;
        PC(Packet)->DiscoveryAddress = *DiscoveryAddress;
        NCE->WaitQueue = Packet;

        //
        // If we have not started neighbor discovery yet,
        // do so now by sending the first solicit.
        // It would be simpler to let NeighborCacheEntryTimeout
        // send the first solicit but that would introduce latency.
        //
        SendSolicit = (NCE->NSCount == 0);
        if (SendSolicit) {
            //
            // We send the first solicit below.
            //
            NCE->NSCount = 1;
            //
            // If NSTimer is zero, we need to initialize NSLimit.
            //
            if (NCE->NSTimer == 0)
                NCE->NSLimit = MAX_MULTICAST_SOLICIT;
            NCE->NSTimer = (ushort)IF->RetransTimer;
        }
        //
        // NSLimit might be MAX_MULTICAST_SOLICIT or MAX_UNREACH_SOLICIT.
        // Ensure that it is at least MAX_MULTICAST_SOLICIT.
        //
        if (NCE->NSLimit < MAX_MULTICAST_SOLICIT)
            NCE->NSLimit = MAX_MULTICAST_SOLICIT;

        //
        // If there are any packets waiting to be completed, take
        // this opportunity. With an active DoS attack, we want
        // to do this more frequently than NeighborCacheTimeout will.
        // 
        PacketList = IF->PacketList;
        IF->PacketList = NULL;
        KeReleaseSpinLock(&IF->LockNC, OldIrql);
        NeighborCacheCompletePackets(IF, PacketList);

        if (SendSolicit)
            NeighborSolicitSend(NCE, DiscoveryAddress);

        if (OldPacket != NULL) {
            //
            // This queue overflow is congestion of a sort,
            // so we must not send an ICMPv6 error.
            //
            IPSInfo.ipsi_outdiscards++;
            IPv6SendComplete(NULL, OldPacket, IP_GENERAL_FAILURE);
        }
        return;
    }

    default:
        //
        // Should never happen.
        //
        ABORTMSG("IPv6SendND: Invalid Neighbor Cache NDState field!\n");
    }

    //
    // Move the NCE to the head of the LRU list,
    // because we are using it to send a packet.
    //
    if (NCE != IF->FirstNCE) {
        //
        // Remove NCE from the list.
        //
        NCE->Next->Prev = NCE->Prev;
        NCE->Prev->Next = NCE->Next;

        //
        // Add NCE to the head of the list.
        //
        NCE->Next = IF->FirstNCE;
        NCE->Next->Prev = NCE;
        NCE->Prev = SentinelNCE(IF);
        NCE->Prev->Next = NCE;
        ASSERT(IF->FirstNCE == NCE);
    }

    //
    // Unlock before transmitting the packet.
    // This means that there is a very small chance that NCE->LinkAddress
    // could change out from underneath us. (For example, if we process
    // an advertisement changing the link-layer address.)
    // In practice this won't happen, and if it does the worst that
    // will happen is that we'll send a packet somewhere strange.
    // The best alternative is copying the LinkAddress.
    //
    KeReleaseSpinLock(&IF->LockNC, OldIrql);

    IPv6SendLL(IF, Packet, Offset, NCE->LinkAddress);
}


//
// Context information that is used for fragmentation.
// This information is carried between calls to IPv6SendFragment.
//
typedef struct FragmentationInfo {
    PNDIS_PACKET Packet;        // Unfragmented packet.
    long NumLeft;               // Number of uncompleted fragments.
    IP_STATUS Status;           // Current status.
} FragmentationInfo;


//* IPv6SendFragmentComplete
//
//  Completion handler, called when a fragment has been sent.
//
void
IPv6SendFragmentComplete(
    PNDIS_PACKET Packet,
    IP_STATUS Status)
{
    FragmentationInfo *Info = PC(Packet)->CompletionData;

    //
    // Free the fragment packet.
    //
    IPv6FreePacket(Packet);

    //
    // Update the current cumulative status.
    //
    InterlockedCompareExchange((PLONG)&Info->Status, Status, IP_SUCCESS);

    if (InterlockedDecrement(&Info->NumLeft) == 0) {
        //
        // This is the last fragment to complete.
        //
        IPv6SendComplete(NULL, Info->Packet, Info->Status);
        ExFreePool(Info);
    }
}


//* IPv6SendFragments - Fragment an IPv6 datagram.
//
//  Helper routine for creating and sending IPv6 fragments.
//  Called from IPv6Send when the datagram is bigger than the path MTU.
//
//  The PathMTU is passed separately so that we use a consistent value.
//  The value in the RCE is subject to change.
//
//  NB: We assume that the packet has well-formed, contiguous headers.
//
void
IPv6SendFragments(
    PNDIS_PACKET Packet,        // Packet to send.
    uint Offset,                // Offset from start of Packet to IP header.
    IPv6Header UNALIGNED *IP,   // Pointer to Packet's IPv6 header.
    uint PayloadLength,         // Packet payload length.
    RouteCacheEntry *RCE,       // First-hop neighbor information.
    uint PathMTU)               // PathMTU to use when fragmenting.
{
    FragmentationInfo *Info;
    NeighborCacheEntry *NCE = RCE->NCE;
    NDIS_STATUS NdisStatus;
    IP_STATUS IPStatus;
    PNDIS_PACKET FragPacket;
    FragmentHeader FragHdr;
    uchar *Mem;
    uint MemLen;
    uint PktOffset;
    uint UnfragBytes;
    uint BytesLeft;
    uint BytesSent;
    uchar HdrType;
    uchar *tbuf;
    PNDIS_BUFFER SrcBuffer;
    uint SrcOffset;
    uint NextHeaderOffset;
    uint FragPayloadLength;

    //
    // A PathMTU value of zero is special -
    // it means that we should use the minimum MTU
    // and always include a fragment header.
    //
    if (PathMTU == 0)
        PathMTU = IPv6_MINIMUM_MTU;
    else
        ASSERT(PathMTU >= IPv6_MINIMUM_MTU);

    //
    // Determine the 'unfragmentable' portion of this packet.
    // We do this by scanning through all extension headers,
    // and noting the last occurrence, if any, of
    // a routing or hop-by-hop header.
    // We do not assume the extension headers are in recommended order,
    // but otherwise we assume that the headers are well-formed.
    // We also assume that they are contiguous.
    //
    UnfragBytes = sizeof *IP;
    HdrType = IP->NextHeader;
    NextHeaderOffset = (uint)((uchar *)&IP->NextHeader - (uchar *)IP);
    tbuf = (uchar *)(IP + 1);
    while ((HdrType == IP_PROTOCOL_HOP_BY_HOP) ||
           (HdrType == IP_PROTOCOL_ROUTING) ||
           (HdrType == IP_PROTOCOL_DEST_OPTS)) {
        ExtensionHeader *EHdr = (ExtensionHeader *) tbuf;
        uint EHdrLen = (EHdr->HeaderExtLength + 1) * 8;

        tbuf += EHdrLen;
        if (HdrType != IP_PROTOCOL_DEST_OPTS) {
            UnfragBytes = (uint)(tbuf - (uchar *)IP);
            NextHeaderOffset = (uint)((uchar *)&EHdr->NextHeader - (uchar *)IP);
        }
        HdrType = EHdr->NextHeader;
    }

    //
    // Suppose we have a routing header followed by
    // a destination-options header. Then the routing header
    // is unfragmentable but the destination options are
    // fragmentable, so HdrType should be IP_PROTOCOL_DEST_OPTS.
    //
    HdrType = *((uchar *)IP + NextHeaderOffset);

    //
    // Check that we can actually fragment this packet.
    // If the unfragmentable part is too large, we can't.
    // We need to send at least 8 bytes of fragmentable data
    // in each fragment.
    //
    if (UnfragBytes + sizeof(FragmentHeader) + 8 > PathMTU) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "IPv6SendFragments: can't fragment\n"));
        IPStatus = IP_GENERAL_FAILURE;
        goto ErrorExit;
    }

    FragHdr.NextHeader = HdrType;
    FragHdr.Reserved = 0;
    FragHdr.Id = net_long(NewFragmentId());

    //
    // Initialize SrcBuffer and SrcOffset, which point
    // to the fragmentable data in the packet.
    // SrcOffset is the offset into SrcBuffer's data,
    // NOT an offset into the packet.
    //
    SrcBuffer = NdisFirstBuffer(Packet);
    SrcOffset = Offset + UnfragBytes;

    //
    // Create new packets of MTU size until all data is sent.
    //
    BytesLeft = sizeof *IP + PayloadLength - UnfragBytes;
    PktOffset = 0; // relative to fragmentable part of original packet

    //
    // We need a completion context for the fragments.
    //
    Info = ExAllocatePoolWithTagPriority(NonPagedPool, sizeof *Info,
                                         IP6_TAG, LowPoolPriority);
    if (Info == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6SendFragments: no pool\n"));
        IPStatus = IP_NO_RESOURCES;
        goto ErrorExit;
    }

    Info->Packet = Packet;
    Info->NumLeft = 1;          // A reference for our own processing.
    Info->Status = IP_SUCCESS;

    while (BytesLeft != 0) {
        //
        // Determine new IP payload length (a multiple of 8) and 
        // and set the Fragment Header offset.
        //
        if ((BytesLeft + UnfragBytes + sizeof(FragmentHeader)) > PathMTU) {
            BytesSent = (PathMTU - UnfragBytes - sizeof(FragmentHeader)) &~ 7;
            // Not the last fragment, so turn on the M bit.
            FragHdr.OffsetFlag = net_short((ushort)(PktOffset | 1));
        } else {
            BytesSent = BytesLeft;
            FragHdr.OffsetFlag = net_short((ushort)PktOffset);
        }

        //
        // Allocate packet (and a buffer) and Memory for new fragment
        //
        MemLen = Offset + UnfragBytes + sizeof(FragmentHeader) + BytesSent;
        NdisStatus = IPv6AllocatePacket(MemLen, &FragPacket, &Mem);
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            InterlockedCompareExchange((PLONG)&Info->Status,
                                       IP_NO_RESOURCES, IP_SUCCESS);
            break;
        }

        //
        // Copy IP header, Frag Header, and a portion of data to fragment.
        //
        RtlCopyMemory(Mem + Offset, IP, UnfragBytes);
        RtlCopyMemory(Mem + Offset + UnfragBytes, &FragHdr,
                      sizeof FragHdr);
        if (! CopyNdisToFlat(Mem + Offset + UnfragBytes + sizeof FragHdr,
                             SrcBuffer, SrcOffset, BytesSent,
                             &SrcBuffer, &SrcOffset)) {
            IPv6FreePacket(FragPacket);
            InterlockedCompareExchange((PLONG)&Info->Status,
                                       IP_NO_RESOURCES, IP_SUCCESS);
            break;
        }

        //
        // Correct the PayloadLength and NextHeader fields.
        //
        FragPayloadLength = UnfragBytes + sizeof(FragmentHeader) +
                                BytesSent - sizeof(IPv6Header);
        ASSERT(FragPayloadLength <= MAX_IPv6_PAYLOAD);
        ((IPv6Header UNALIGNED *)(Mem + Offset))->PayloadLength =
            net_short((ushort) FragPayloadLength);
        ASSERT(Mem[Offset + NextHeaderOffset] == HdrType);
        Mem[Offset + NextHeaderOffset] = IP_PROTOCOL_FRAGMENT;

        BytesLeft -= BytesSent;
        PktOffset += BytesSent;

        //
        // Pick up any flags (like loopback-only) from the original packet.
        //
        PC(FragPacket)->Flags = PC(Packet)->Flags;

        //
        // Setup our completion handler and increment
        // the number of outstanding users of the completion data.
        //
        PC(FragPacket)->CompletionHandler = IPv6SendFragmentComplete;
        PC(FragPacket)->CompletionData = Info;
        InterlockedIncrement(&Info->NumLeft);

        //
        // Send the fragment.
        //
        IPSInfo.ipsi_fragcreates++;
        IPv6SendND(FragPacket, Offset, NCE, NULL);
    }

    if (InterlockedDecrement(&Info->NumLeft) == 0) {
        //
        // Amazingly, the fragments have already completed.
        // Complete the original packet now.
        //
        IPv6SendComplete(NULL, Packet, Info->Status);
        ExFreePool(Info);
    }
    else {
        //
        // IPv6SendFragmentComplete will complete the original packet
        // when all the fragments are completed.
        //
    }
    IPSInfo.ipsi_fragoks++;
    return;

  ErrorExit:
    IPSInfo.ipsi_fragfails++;
    IPv6SendComplete(NULL, Packet, IPStatus);
}


//* IPv6Send
//
//  High-level IPv6 send routine.  We have a completed datagram and a
//  RCE indicating where to direct it to.  Here we deal with any packetization
//  issues (inserting a Jumbo Payload option, fragmentation, etc.) that are
//  necessary, and pick a NCE for the first hop.
//
//  We also add any additional extension headers to the packet that may be
//  required for mobility (routing header) or security (AH, ESP header).
//  TBD: This design may change to move those header inclusions elsewhere.
//
//  Note that this routine expects a properly formatted IPv6 packet, and
//  also that all of the headers are contained within the first NDIS buffer.
//  It performs no checking of these requirements.
//
void
IPv6Send(
    PNDIS_PACKET Packet,       // Packet to send.
    uint Offset,               // Offset from start of Packet to IP header.
    IPv6Header UNALIGNED *IP,  // Pointer to Packet's IPv6 header.
    uint PayloadLength,        // Packet payload length.
    RouteCacheEntry *RCE,      // First-hop neighbor information.
    uint Flags,                // Flags for special handling.
    ushort TransportProtocol,
    ushort SourcePort,
    ushort DestPort)
{
    uint PacketLength;        // Size of complete IP packet in bytes.
    NeighborCacheEntry *NCE;  // First-hop neighbor information.
    uint PathMTU;
    PNDIS_BUFFER OrigBuffer1, NewBuffer1;
    uchar *OrigMemory, *NewMemory,
        *EndOrigMemory, *EndNewMemory, *InsertPoint;
    uint OrigBufSize, NewBufSize, TotalPacketSize, Size, RtHdrSize = 0;
    IPv6RoutingHeader *SavedRtHdr = NULL, *RtHdr = NULL;
    IPv6Header UNALIGNED *IPNew;
    uint BytesToInsert = 0;
    uchar *BufPtr, *PrevNextHdr;
    ExtensionHeader *EHdr;
    uint EHdrLen;
    uchar HdrType;
    NDIS_STATUS Status;
    RouteCacheEntry *CareOfRCE = NULL;
    RouteCacheEntry *TunnelRCE = NULL;
    CareOfCompletionInfo *CareOfInfo;
    KIRQL OldIrql;
    IPSecProc *IPSecToDo;
    uint Action;
    uint i;
    uint TunnelStart = NO_TUNNEL;
    uint JUST_ESP = FALSE;
    uint IPSEC_TUNNEL = FALSE;
    uint NumESPTrailers = 0;

    IPSIncrementOutRequestCount();

    //
    // Find the Security Policy for this outbound traffic.
    // Current Mobile IPv6 draft says to use a mobile node's home address
    // and not its care-of address as the selector for security policy lookup.
    //
    IPSecToDo = OutboundSPLookup(AlignAddr(&IP->Source),
                                 AlignAddr(&IP->Dest),
                                 TransportProtocol,
                                 SourcePort, DestPort,
                                 RCE->NTE->IF, &Action);
    if (IPSecToDo == NULL) {
        //
        // Check Action.
        // Just fall through for LOOKUP_BYPASS.
        //
        if (Action == LOOKUP_DROP) {
            // Drop packet.
            goto AbortSend;
        }
        if (Action == LOOKUP_IKE_NEG) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "IPv6Send: IKE not supported yet.\n"));
            goto AbortSend;
        }

    } else {
        //
        // Calculate the space needed for the IPSec headers.
        //
        BytesToInsert = IPSecBytesToInsert(IPSecToDo, &TunnelStart, NULL);

        if (TunnelStart != NO_TUNNEL) {
            IPSEC_TUNNEL = TRUE;
        }
    }

    //
    // If this packet is being sent to a mobile node's care-of address,
    // then we'll use the CareOfRCE instead of the one our caller gave us.
    //
    if ((RCE->BCE != NULL) &&
        !(Flags & SEND_FLAG_BYPASS_BINDING_CACHE)) {
        KeAcquireSpinLock(&RouteCacheLock, &OldIrql);
        if (RCE->BCE != NULL) {
            MoveToFrontBCE(RCE->BCE);
            CareOfRCE = RCE->BCE->CareOfRCE;
            AddRefRCE(CareOfRCE);
            KeReleaseSpinLock(&RouteCacheLock, OldIrql);

            RCE = CareOfRCE;
        } else
            KeReleaseSpinLock(&RouteCacheLock, OldIrql);
    }

    //
    // Step through headers.
    //
    HdrType = IP->NextHeader;
    PrevNextHdr = &IP->NextHeader;
    BufPtr = (uchar *)(IP + 1);

    //
    // Skip the hop-by-hop header if it exists.  Don't skip
    // dest options, since dest options (e.g. BindAck) usually
    // want IPsec and need to go after the RH/AH/ESP.  As a result,
    // the only current way to get intermediate destination options
    // is to compose the packet before calling IPv6Send.
    //
    while (HdrType == IP_PROTOCOL_HOP_BY_HOP) {
        EHdr = (ExtensionHeader *) BufPtr;
        EHdrLen = (EHdr->HeaderExtLength + 1) * 8;
        BufPtr += EHdrLen;
        HdrType = EHdr->NextHeader;
        PrevNextHdr = &EHdr->NextHeader;
    }

    //
    // Check if there is a routing header.  If this packet is being sent
    // to a care-of address, then it must contain a routing extension header.
    // If one already exists then add the destination address as the last
    // entry. If no routing header exists insert one with the home address as
    // the first (and only) address.
    //
    // This code assumes that the packet is contiguous at least up to the
    // insertion point.
    //
    if (HdrType == IP_PROTOCOL_ROUTING) {
        EHdr = (ExtensionHeader *) BufPtr;
        EHdrLen = (EHdr->HeaderExtLength + 1) * 8;

        RtHdrSize = EHdrLen;

        PrevNextHdr = &EHdr->NextHeader;

        //
        // Check if this header will be modified due to mobility.
        //
        if (CareOfRCE) {

            // Save Routing Header location for later use.
            RtHdr = (IPv6RoutingHeader *)BufPtr;

            //
            // Check if there is room to store the Home Address.
            // REVIEW: Is this necessary, what should happen
            // REVIEW: if the routing header is full?
            //
            if (RtHdr->HeaderExtLength / 2 < 23) {
                BytesToInsert += sizeof (IPv6Addr);
            }
        } else {
            // Adjust BufPtr to end of routing header.
            BufPtr += EHdrLen;
        }
    } else {
        //
        // No routing header present, but check if one needs to be
        // inserted due to mobility.
        //
        if (CareOfRCE) {
            BytesToInsert += (sizeof (IPv6RoutingHeader) + sizeof (IPv6Addr));
        }
    }

    // Only will happen for IPSec bypass mode with no mobility.
    if (BytesToInsert == 0) {
        //
        // Nothing to do.
        //
        Action = LOOKUP_CONT;
        goto ContinueSend;
    }

    //
    // We have something to insert.  We will replace the packet's
    // first NDIS_BUFFER with a new buffer that we allocate to hold the
    // all data from the existing first buffer plus the inserted data.
    //

    //
    // We get the first buffer and determine its size, then
    // allocate memory for the new buffer.
    //
    NdisGetFirstBufferFromPacket(Packet, &OrigBuffer1, &OrigMemory,
                                 &OrigBufSize, &TotalPacketSize);
    TotalPacketSize -= Offset;
    NewBufSize = (OrigBufSize - Offset) + MAX_LINK_HEADER_SIZE + BytesToInsert;
    Offset = MAX_LINK_HEADER_SIZE;
    NewMemory = ExAllocatePoolWithTagPriority(NonPagedPool, NewBufSize,
                                              IP6_TAG, LowPoolPriority);
    if (NewMemory == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6Send: - couldn't allocate pool!?!\n"));
        goto AbortSend;
    }

    NdisAllocateBuffer(&Status, &NewBuffer1, IPv6BufferPool, NewMemory,
                       NewBufSize);
    if (Status != NDIS_STATUS_SUCCESS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6Send - couldn't allocate buffer!?!\n"));
        ExFreePool(NewMemory);
        goto AbortSend;
    }

    //
    // We've sucessfully allocated a new buffer.  Now copy the data from
    // the existing buffer to the new one.  First we copy all data after
    // the insertion point.  This is essentially the transport layer data
    // (no Extension headers).
    //

    //
    // Calculate Insertion Point for upper layer data.
    //
    EndOrigMemory = OrigMemory + OrigBufSize;
    EndNewMemory = NewMemory + NewBufSize;
    Size = (uint)(EndOrigMemory - BufPtr);
    InsertPoint = EndNewMemory - Size;

    // Copy upper layer data to end of new buffer.
    RtlCopyMemory(InsertPoint, BufPtr, Size);

    BytesToInsert = 0;

    //
    // Insert Transport IPSec headers.
    //
    if (IPSecToDo) {
        Action = IPSecInsertHeaders(TRANSPORT, IPSecToDo, &InsertPoint,
                                    NewMemory, Packet, &TotalPacketSize,
                                    PrevNextHdr, TunnelStart, &BytesToInsert,
                                    &NumESPTrailers, &JUST_ESP);
        if (Action == LOOKUP_DROP) {
            NdisFreeBuffer(NewBuffer1);
            ExFreePool(NewMemory);
            goto AbortSend;
        }
    } // end of if (IPSecToDo).

    //
    // Check if mobility needs to be done.
    //
    if (CareOfRCE) {
        // Check if routing header is already present in original buffer..
        if (RtHdr != NULL) {
            //
            // Need to insert the home address in the routing header.
            //
            RtHdrSize += sizeof (IPv6Addr);
            // Move insert point up to start of routing header.
            InsertPoint -= RtHdrSize;

            BytesToInsert += sizeof(IPv6Addr);

            // Insert the routing header.
            RtlCopyMemory(InsertPoint, RtHdr, RtHdrSize - sizeof(IPv6Addr));

            // Insert the Home address.
            RtlCopyMemory(InsertPoint + RtHdrSize - sizeof (IPv6Addr),
                          &IP->Dest, sizeof (IPv6Addr));

            RtHdr = (IPv6RoutingHeader *)InsertPoint;

            // Adjust size of routing header.
            RtHdr->HeaderExtLength += 2;

        } else {
            //
            // No routing header present - need to create new Routing header.
            //
            RtHdrSize = sizeof (IPv6RoutingHeader) + sizeof(IPv6Addr);

            // Move insert point up to start of routing header.
            InsertPoint -= RtHdrSize;

            BytesToInsert += RtHdrSize;

            //
            // Insert an entire routing header.
            //
            RtHdr = (IPv6RoutingHeader *)InsertPoint;
            RtHdr->NextHeader = *PrevNextHdr;
            RtHdr->HeaderExtLength = 2;
            RtHdr->RoutingType = 0;
            RtlZeroMemory(&RtHdr->Reserved, sizeof RtHdr->Reserved);
            RtHdr->SegmentsLeft = 1;
            // Insert the home address.
            RtlCopyMemory(RtHdr + 1, &IP->Dest, sizeof (IPv6Addr));

            //
            // Fix the previous NextHeader field to indicate that it now points
            // to a routing header.
            //
            *(PrevNextHdr) = IP_PROTOCOL_ROUTING;
        }

        // Change the destination IPv6 address to the care-of address.
        RtlCopyMemory(&IP->Dest, &CareOfRCE->Destination, sizeof (IPv6Addr));
    } // end of if (CareOfRCE)

    //
    // Copy original IP plus any extension headers.
    // If a care-of address was added, the Routing header is not part
    // of this copy because it has already been copied.
    //
    Size = (uint)(BufPtr - (uchar *)IP);
    // Move insert point up to start of IP.
    InsertPoint -= Size;

    // Adjust length of payload.
    PayloadLength += BytesToInsert;

    // Set the new IP payload length.
    IP->PayloadLength = net_short((ushort)PayloadLength);

    RtlCopyMemory(InsertPoint, (uchar *)IP, Size);

    IPNew = (IPv6Header UNALIGNED *)InsertPoint;

    //
    // Check if any Transport mode IPSec was performed and
    // if mutable fields need to be adjusted.
    //
    if (TunnelStart != 0 && IPSecToDo && !JUST_ESP) {
        if (RtHdr) {
            //
            // Save the new routing header so it can be restored after
            // authenticating.
            //
            SavedRtHdr = ExAllocatePoolWithTagPriority(
                                        NonPagedPool, RtHdrSize,
                                        IP6_TAG, LowPoolPriority);
            if (SavedRtHdr == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "IPv6Send: - couldn't allocate SavedRtHdr!?!\n"));
                NdisFreeBuffer(NewBuffer1);
                ExFreePool(NewMemory);
                goto AbortSend;
            }
            
            RtlCopyMemory(SavedRtHdr, RtHdr, RtHdrSize);
        }

        //
        // Adjust mutable fields before doing Authentication.
        //
        Action = IPSecAdjustMutableFields(InsertPoint, SavedRtHdr);

        if (Action == LOOKUP_DROP) {
            NdisFreeBuffer(NewBuffer1);
            ExFreePool(NewMemory);
            goto AbortSend;
        }
    } // end of if(IPSecToDo && !JUST_ESP)

    //
    // We need to save the existing completion handler & data.  We'll
    // use these fields here, and restore them in IPv6CareOfComplete.
    //
    CareOfInfo = ExAllocatePoolWithTagPriority(
                        NonPagedPool, sizeof(*CareOfInfo),
                        IP6_TAG, LowPoolPriority);
    if (CareOfInfo == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "IPv6Send - couldn't allocate completion info!?!\n"));
        NdisFreeBuffer(NewBuffer1);
        ExFreePool(NewMemory);
        goto AbortSend;
    }

    CareOfInfo->SavedCompletionHandler = PC(Packet)->CompletionHandler;
    CareOfInfo->SavedCompletionData = PC(Packet)->CompletionData;
    CareOfInfo->SavedFirstBuffer = OrigBuffer1;
    CareOfInfo->NumESPTrailers = NumESPTrailers;
    PC(Packet)->CompletionHandler = IPv6CareOfComplete;
    PC(Packet)->CompletionData = CareOfInfo;

    // Unchain the original first buffer from the packet.
    NdisUnchainBufferAtFront(Packet, &OrigBuffer1);
    // Chain the new buffer to the front of the packet.
    NdisChainBufferAtFront(Packet, NewBuffer1);

    //
    // Do authentication for transport mode IPSec.
    //
    if (IPSecToDo) {         
        IPSecAuthenticatePacket(TRANSPORT, IPSecToDo, InsertPoint,
                                &TunnelStart, NewMemory, EndNewMemory,
                                NewBuffer1);
        
        if (!JUST_ESP) {
            //
            // Reset the mutable fields to correct values.
            // Just copy from old packet to new packet for IP and
            // unmodified Ext. headers.
            //
            RtlCopyMemory(InsertPoint, (uchar *)IP, Size);

            // Check if the Routing header needs to be restored.
            if (CareOfRCE) {
                // Copy the saved routing header to the new buffer.
                RtlCopyMemory(RtHdr, SavedRtHdr, RtHdrSize);
            }
        }
    } // end of if (IPSecToDo)

    //
    // We're done with the transport copy.
    //

    //
    // Insert tunnel IPSec headers.
    //
    if (IPSEC_TUNNEL) {
        i = 0;

        // Loop through the different Tunnels.
        while (TunnelStart < IPSecToDo->BundleSize) {
            uchar NextHeader = IP_PROTOCOL_V6;

            NumESPTrailers = 0;

            i++;

            // Reset byte count.
            BytesToInsert = 0;

            Action = IPSecInsertHeaders(TUNNEL, IPSecToDo, &InsertPoint,
                                        NewMemory, Packet, &TotalPacketSize,
                                        &NextHeader, TunnelStart,
                                        &BytesToInsert, &NumESPTrailers,
                                        &JUST_ESP);
            if (Action == LOOKUP_DROP) {
                goto AbortSend;
            }

            // Add the ESP trailer header number.
            CareOfInfo->NumESPTrailers += NumESPTrailers;

            // Move insert point up to start of IP.
            InsertPoint -= sizeof(IPv6Header);

            //
            // Adjust length of payload.
            //
            PayloadLength = BytesToInsert + PayloadLength + sizeof(IPv6Header);

            // Insert IP header fields.
            IPNew = (IPv6Header UNALIGNED *)InsertPoint;

            IPNew->PayloadLength = net_short((ushort)PayloadLength);
            IPNew->NextHeader = NextHeader;

            if (!JUST_ESP) {
                // Adjust mutable fields.
                IPNew->VersClassFlow = IP_VERSION;
                IPNew->HopLimit = 0;
            } else {
                IPNew->VersClassFlow = IP->VersClassFlow;
                IPNew->HopLimit = IP->HopLimit - i;
            }

            // Source address same as inner header.
            RtlCopyMemory(&IPNew->Source, &IP->Source, sizeof (IPv6Addr));
            // Dest address to the tunnel end point.
            RtlCopyMemory(&IPNew->Dest, &IPSecToDo[TunnelStart].SA->SADestAddr,
                          sizeof (IPv6Addr));

            //
            // Do authentication for tunnel mode IPSec.
            //
            IPSecAuthenticatePacket(TUNNEL, IPSecToDo, InsertPoint,
                                    &TunnelStart, NewMemory, EndNewMemory,
                                    NewBuffer1);

            if (!JUST_ESP) {
                //
                // Reset the mutable fields to correct values.
                //
                IPNew->VersClassFlow = IP->VersClassFlow;
                IPNew->HopLimit = IP->HopLimit - i;
            }
        } // end of while (TunnelStart < IPSecToDo->BundleSize)

        //
        // Check if a new RCE is needed due to the tunnel.
        //
        if (!(IP6_ADDR_EQUAL(AlignAddr(&IPNew->Dest), AlignAddr(&IP->Dest)))) {
            // Get a new route to the tunnel end point.
            Status = RouteToDestination(AlignAddr(&IPNew->Dest), 0, NULL,
                                        RTD_FLAG_NORMAL, &TunnelRCE);
            if (Status != IP_SUCCESS) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                           "IPv6Send: No route to IPSec tunnel dest."));
                IPv6SendAbort(CastFromNTE(RCE->NTE), Packet, Offset,
                              ICMPv6_DESTINATION_UNREACHABLE,
                              ICMPv6_NO_ROUTE_TO_DESTINATION, 0, FALSE);
                goto AbortSend;
            }

            // Set new RCE;
            RCE = TunnelRCE;
        }

    } // end of if (IPSEC_TUNNEL)
    

    // Set the IP pointer to the new IP pointer.
    IP = IPNew;

    if (IPSecToDo) {
        // Free IPSecToDo.
        FreeIPSecToDo(IPSecToDo, IPSecToDo->BundleSize);

        if (SavedRtHdr) {
            // Free the saved routing header.
            ExFreePool(SavedRtHdr);
        }
    }

ContinueSend:

    if (Action == LOOKUP_DROP) {
      AbortSend:
        // Error occured.        
        IPSInfo.ipsi_outdiscards++;
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "IPv6Send: Drop packet.\n"));
        IPv6SendComplete(NULL, Packet, IP_GENERAL_FAILURE);
        if (CareOfRCE) {
            ReleaseRCE(CareOfRCE);
        }
        if (TunnelRCE)
            ReleaseRCE(TunnelRCE);
        
        if (IPSecToDo) {
            // Free IPSecToDo.
            FreeIPSecToDo(IPSecToDo, IPSecToDo->BundleSize);

            if (SavedRtHdr) {
                // Free the saved routing header.
                ExFreePool(SavedRtHdr);
            }
        }
        return;
    }

    //
    // We only have one NCE per RCE for now,
    // so picking one is really easy...
    //
    NCE = RCE->NCE;

    //
    // Prevent the packet from actually going out onto a link,
    // in several situations. Also see IsLoopbackAddress.
    //
    if ((IP->HopLimit == 0) ||
        IsLoopback(AlignAddr(&IP->Dest)) ||
        IsInterfaceLocalMulticast(AlignAddr(&IP->Dest))) {

        PC(Packet)->Flags |= NDIS_FLAGS_LOOPBACK_ONLY;
    }

    //
    // See if we need to insert a Jumbo Payload option.
    //
    if (PayloadLength > MAX_IPv6_PAYLOAD) {
        // Add code to insert a Jumbo Payload hop-by-hop option here.
        IPSInfo.ipsi_outdiscards++;
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "IPv6Send: attempted to send a Jumbo Payload!\n"));
        IPv6SendComplete(NULL, Packet, IP_PACKET_TOO_BIG);        
        return;
    }

    //
    // Check the path's MTU.  If we're larger, fragment.
    //
    PacketLength = PayloadLength + sizeof(IPv6Header);
    PathMTU = GetPathMTUFromRCE(RCE);
    if (PacketLength > PathMTU) {

        IPv6SendFragments(Packet, Offset, IP, PayloadLength, RCE, PathMTU);

    } else {
        //
        // Fill in packet's PayloadLength field.
        // We already set the IP->PayloadLength if IPSec was done.
        //
        if (!IPSecToDo) {
            IP->PayloadLength = net_short((ushort)PayloadLength);
        }

        IPv6SendND(Packet, Offset, NCE, NULL);
    }

    if (CareOfRCE)
        ReleaseRCE(CareOfRCE);
    if (TunnelRCE)
        ReleaseRCE(TunnelRCE);
}


//* IPv6Forward - Forward a packet onto a new link.
//
//  Somewhat like IPv6Send, but for forwarding packets
//  instead of sending freshly-generated packets.
//
//  We are given ownership of the packet. The packet data
//  must be writable and the IP header must be contiguous.
//
//  We can generate several possible ICMP errors:
//  Time Limit Exceeded, Destination Unreachable, Packet Too Big.
//  We decrement the hop limit.
//  We do not fragment the packet.
//
//  We assume that our caller has already sanity-checked
//  the packet's destination address. Routing-header forwarding
//  may allow some cases (like link-local or loopback destinations)
//  that normal router forwarding does not permit.
//  Our caller provides the NCE of the next hop for the packet.
//
void
IPv6Forward(
    NetTableEntryOrInterface *RecvNTEorIF,
    PNDIS_PACKET Packet,
    uint Offset,
    IPv6Header UNALIGNED *IP,
    uint PayloadLength,
    int Redirect,
    IPSecProc *IPSecToDo,
    RouteCacheEntry *RCE)
{
    uint PacketLength;
    uint LinkMTU, IPSecBytesInserted = 0;
    IP_STATUS Status;
    uint IPSecOffset = Offset;    
    NeighborCacheEntry *NCE = RCE->NCE;
    RouteCacheEntry *TunnelRCE = NULL;
    ushort SrcScope;

    IPSIncrementForwDatagramCount();

    ASSERT(IP == GetIPv6Header(Packet, Offset, NULL));

    //
    // Check for "scope" errors.  We can't allow a packet with a scoped
    // source address to leave its scope.
    //
    SrcScope = AddressScope(AlignAddr(&IP->Source));
    if (NCE->IF->ZoneIndices[SrcScope] !=
                        RecvNTEorIF->IF->ZoneIndices[SrcScope]) {
        IPv6SendAbort(RecvNTEorIF, Packet, Offset,
                      ICMPv6_DESTINATION_UNREACHABLE, ICMPv6_SCOPE_MISMATCH,
                      0, FALSE);
        return;
    }

    //
    // Are we forwarding the packet out the link on which it arrived,
    // and we should consider a Redirect? Redirect will be false
    // if the forwarding is happening because of source-routing.
    //
    if ((NCE->IF == RecvNTEorIF->IF) && Redirect) {
        Interface *IF = NCE->IF;

        //
        // We do not want to forward a packet back onto a p2p link,
        // because it will very often lead to a loop.
        // One example: a prefix is on-link to a p2p link between routers
        // and someone sends a packet to an address in the prefix
        // that is not assigned to either end of the link.
        //
        if (IF->Flags & IF_FLAG_P2P) {
            IPv6SendAbort(RecvNTEorIF, Packet, Offset,
                          ICMPv6_DESTINATION_UNREACHABLE,
                          (IP6_ADDR_EQUAL(&NCE->NeighborAddress,
                                          &RCE->Destination) ?
                           ICMPv6_ADDRESS_UNREACHABLE :
                           ICMPv6_NO_ROUTE_TO_DESTINATION),
                          0, FALSE);
            return;
        }

        //
        // We SHOULD send a Redirect, whenever
        // 1. The Source address of the packet specifies a neighbor, and
        // 2. A better first-hop resides on the same link, and
        // 3. The Destination address is not multicast.
        // See Section 8.2 of the ND spec.
        //
        if ((IF->Flags & IF_FLAG_ROUTER_DISCOVERS) &&
            !IsMulticast(AlignAddr(&IP->Dest))) {
            RouteCacheEntry *SrcRCE;
            NeighborCacheEntry *SrcNCE;

            //
            // Get an RCE for the Source of this packet.
            //
            Status = RouteToDestination(AlignAddr(&IP->Source), 0,
                                        RecvNTEorIF, RTD_FLAG_STRICT,
                                        &SrcRCE);
            if (Status == IP_SUCCESS) {
                //
                // Because of RTD_FLAG_STRICT.
                //
                ASSERT(SrcRCE->NTE->IF == IF);

                SrcNCE = SrcRCE->NCE;
                if (IP6_ADDR_EQUAL(&SrcNCE->NeighborAddress,
                                   AlignAddr(&IP->Source))) {
                    //
                    // The source of this packet is on-link,
                    // so send a Redirect to the source.
                    // Unless rate-limiting prevents it.
                    //
                    if (ICMPv6RateLimit(SrcRCE)) {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                                   "RedirectSend - rate limit %s\n",
                                   FormatV6Address(&SrcRCE->Destination)));
                    } else {
                        RedirectSend(SrcNCE, NCE,
                                     AlignAddr(&IP->Dest), RecvNTEorIF,
                                     Packet, Offset, PayloadLength);
                    }
                }
                ReleaseRCE(SrcRCE);
            }
        }
    }

    //
    // Check that the hop limit allows the packet to be forwarded.
    //
    if (IP->HopLimit <= 1) {
        //
        // It seems to be customary in this case to have the hop limit
        // in the ICMP error's payload be zero.
        //
        IP->HopLimit = 0;

        IPv6SendAbort(RecvNTEorIF, Packet, Offset, ICMPv6_TIME_EXCEEDED,
                      ICMPv6_HOP_LIMIT_EXCEEDED, 0, FALSE);
        return;
    }

    //
    // Note that subsequent ICMP errors (Packet Too Big, Address Unreachable)
    // will show the decremented hop limit. They are also generated
    // from the perspective of the outgoing link. That is, the source address
    // in the ICMP error is an address assigned to the outgoing link.
    //
    IP->HopLimit--;

    // Check if there is IPSec to be done.
    if (IPSecToDo) {
        PNDIS_BUFFER Buffer;
        uchar *Memory, *EndMemory, *InsertPoint;
        uint BufSize, TotalPacketSize, BytesInserted;
        IPv6Header UNALIGNED *IPNew = NULL;
        uint JUST_ESP, Action, TunnelStart = 0, i = 0;
        NetTableEntry *NTE;
        uint NumESPTrailers = 0; // not used here.     

        // Set the insert point to the start of the IP header.
        InsertPoint = (uchar *)IP;
        // Get the first buffer.
        NdisGetFirstBufferFromPacket(Packet, &Buffer, &Memory, &BufSize,
                                     &TotalPacketSize);
        TotalPacketSize -= Offset;

        // End of this buffer.
        EndMemory = Memory + BufSize;

        // Loop through the different Tunnels.
        while (TunnelStart < IPSecToDo->BundleSize) {
            uchar NextHeader = IP_PROTOCOL_V6;
            BytesInserted = 0;

            i++;

            //
            // Insert Tunnel mode IPSec.
            //
            Action = IPSecInsertHeaders(TUNNEL, IPSecToDo, &InsertPoint,
                                        Memory, Packet, &TotalPacketSize,
                                        &NextHeader, TunnelStart,
                                        &BytesInserted, &NumESPTrailers,
                                        &JUST_ESP);
            if (Action == LOOKUP_DROP) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                           "IPv6Forward: IPSec drop packet.\n"));
                return;
            }

            // Move insert point up to start of IP.
            InsertPoint -= sizeof(IPv6Header);

            // Reset the Offset value to the correct link-layer size.
            IPSecOffset = (uint)(InsertPoint - Memory);

            // Adjust length of payload.
            PayloadLength = BytesInserted + PayloadLength + sizeof(IPv6Header);

            // Insert IP header fields.
            IPNew = (IPv6Header UNALIGNED *)InsertPoint;

            IPNew->PayloadLength = net_short((ushort)PayloadLength);
            IPNew->NextHeader = NextHeader;

            if (!JUST_ESP) {
                // Adjust mutable fields.
                IPNew->VersClassFlow = IP_VERSION;
                IPNew->HopLimit = 0;
            } else {
                IPNew->VersClassFlow = IP->VersClassFlow;
                IPNew->HopLimit = IP->HopLimit - i;
            }

            // Dest address to the tunnel end point.
            RtlCopyMemory(&IPNew->Dest, &IPSecToDo[TunnelStart].SA->SADestAddr,
                          sizeof (IPv6Addr));

            // Figure out what source address to use.
            NTE = FindBestSourceAddress(NCE->IF, AlignAddr(&IPNew->Dest));
            if (NTE == NULL) {
                //
                // We have no valid source address to use!
                //
                return;
            }

            // Source address is the address of the forwarding interface.
            RtlCopyMemory(&IPNew->Source, &NTE->Address, sizeof (IPv6Addr));

            // Release NTE.
            ReleaseNTE(NTE);

            //
            // Do authentication for tunnel mode IPSec.
            //
            IPSecAuthenticatePacket(TUNNEL, IPSecToDo, InsertPoint,
                                    &TunnelStart, Memory, EndMemory, Buffer);

            if (!JUST_ESP) {
                //
                // Reset the mutable fields to correct values.
                //
                IPNew->VersClassFlow = IP->VersClassFlow;
                IPNew->HopLimit = IP->HopLimit - i;
            }

            IPSecBytesInserted += (BytesInserted + sizeof(IPv6Header));
        } // end of while (TunnelStart < IPSecToDo->BundleSize)

        //
        // Check if a new RCE is needed.
        //
        if (!(IP6_ADDR_EQUAL(AlignAddr(&IPNew->Dest), AlignAddr(&IP->Dest)))) {
            // Get a new route to the tunnel end point.
            Status = RouteToDestination(AlignAddr(&IPNew->Dest), 0, NULL,
                                        RTD_FLAG_NORMAL, &TunnelRCE);
            if (Status != IP_SUCCESS) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                           "IPv6Forward: No route to IPSec tunnel dest."));
                IPv6SendAbort(RecvNTEorIF, Packet, Offset,
                              ICMPv6_DESTINATION_UNREACHABLE,
                              ICMPv6_NO_ROUTE_TO_DESTINATION, 0, FALSE);
                return;
            }

            // Set the new RCE.
            RCE = TunnelRCE;
            // Set new NCE;
            NCE = RCE->NCE;
        }

    } // end of if (IPSecToDo)

    //
    // Check that the packet is not too big for the outgoing link.
    // Note that IF->LinkMTU is volatile, so we capture
    // it in a local variable for consistency.
    //
    PacketLength = PayloadLength + sizeof(IPv6Header);
    LinkMTU = NCE->IF->LinkMTU;
    if (PacketLength > LinkMTU) {
        // Change the LinkMTU to account for the IPSec headers.
        LinkMTU -= IPSecBytesInserted;

        //
        // Note that MulticastOverride is TRUE for Packet Too Big errors.
        // This allows Path MTU Discovery to work for multicast.
        //
        IPv6SendAbort(RecvNTEorIF, Packet, Offset, ICMPv6_PACKET_TOO_BIG,
                      0, LinkMTU, TRUE); // MulticastOverride.
    } else {

        IPv6SendND(Packet, IPSecOffset, NCE, NULL);
        IPSInfo.ipsi_forwdatagrams++;
    }

    if (TunnelRCE)
        ReleaseRCE(TunnelRCE);
}


//* IPv6SendAbort
//
//  Abort an attempt to send a packet and instead
//  generate an ICMP error. In most situations this function
//  is called before the packet has been sent (so PC(Packet)->IF is NULL)
//  but it can also be used after sending the packet, if the link layer
//  reports failure.
//
//  Disposes of the aborted packet.
//
//  The caller can specify the source address of the ICMP error,
//  by specifying an NTE, or the caller can provide an interface
//  from which which the best source address is selected.
//
//  Callable from thread or DPC context.
//  Must be called with no locks held.
//
void
IPv6SendAbort(
    NetTableEntryOrInterface *NTEorIF,
    PNDIS_PACKET Packet,        // Aborted packet.
    uint Offset,                // Offset of IPv6 header in aborted packet.
    uchar ICMPType,             // ICMP error type.
    uchar ICMPCode,             // ICMP error code pertaining to type.
    ulong ErrorParameter,       // Parameter included in the error.
    int MulticastOverride)      // Allow replies to multicast packets?
{
    IPv6Header UNALIGNED *IP;
    IPv6Packet DummyPacket;
    IPv6Header HdrBuffer;

    //
    // It's possible for GetIPv6Header to fail
    // when we are sending "raw" packets.
    //
    IP = GetIPv6Header(Packet, Offset, &HdrBuffer);
    if (IP != NULL) {
        InitializePacketFromNdis(&DummyPacket, Packet, Offset);
        DummyPacket.IP = IP;
        DummyPacket.SrcAddr = AlignAddr(&IP->Source);
        DummyPacket.IPPosition = Offset;
        AdjustPacketParams(&DummyPacket, sizeof *IP);
        DummyPacket.NTEorIF = NTEorIF;

        ICMPv6SendError(&DummyPacket, ICMPType, ICMPCode, ErrorParameter,
                        IP->NextHeader, MulticastOverride);
    }

    IPv6SendComplete(PC(Packet)->IF, Packet, IP_GENERAL_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\tunnel.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Generic support for running IPv6 over IPv4.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "llip6if.h"
#include "tdi.h"
#include "tdiinfo.h"
#include "tdikrnl.h"
#include "tdistat.h"
#include "tunnel.h"
#include "ntddtcp.h"
#include "tcpinfo.h"
#include "icmp.h"
#include "neighbor.h"
#include "route.h"
#include "security.h"
#include <stdio.h>
#include "ntddip6.h"
#include "icmp.h"

//
// Our globals are all in one structure.
//

TunnelGlobals Tunnel;

//* TunnelSetAddressObjectInformation
//
//  Set information on the TDI address object.
//
//  Our caller should initialize the ID.toi_id, BufferSize, Buffer
//  fields of the SetInfo structure, but we initialize the rest.
//
NTSTATUS
TunnelSetAddressObjectInformation(
    PFILE_OBJECT AO,
    PTCP_REQUEST_SET_INFORMATION_EX SetInfo,
    ULONG SetInfoSize)
{
    IO_STATUS_BLOCK iosb;
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    //
    // Finish initialization of the request structure for this IOCTL.
    //
    SetInfo->ID.toi_entity.tei_entity = CL_TL_ENTITY;
    SetInfo->ID.toi_entity.tei_instance = 0;
    SetInfo->ID.toi_class = INFO_CLASS_PROTOCOL;
    SetInfo->ID.toi_type = INFO_TYPE_ADDRESS_OBJECT;

    //
    // Initialize the event that we use to wait.
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Create and initialize the IRP for this operation.
    //
    irp = IoBuildDeviceIoControlRequest(IOCTL_TCP_SET_INFORMATION_EX,
                                        AO->DeviceObject,
                                        SetInfo,
                                        SetInfoSize,
                                        NULL,   // output buffer
                                        0,      // output buffer length
                                        FALSE,  // internal device control?
                                        &event,
                                        &iosb);
    if (irp == NULL)
        return STATUS_INSUFFICIENT_RESOURCES;

    iosb.Status = STATUS_UNSUCCESSFUL;
    iosb.Information = (ULONG)-1;

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = AO;

    //
    // Make the IOCTL, waiting for it to finish if necessary.
    //
    status = IoCallDriver(AO->DeviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode,
                              FALSE, NULL);
        status = iosb.Status;
    }

    return status;
}

//* TunnelSetAddressObjectUCastIF
//
//  Binds the TDI address object to a particular interface.
//
NTSTATUS
TunnelSetAddressObjectUCastIF(PFILE_OBJECT AO, IPAddr Address)
{
    PTCP_REQUEST_SET_INFORMATION_EX setInfo;
    union { // get correct alignment
        TCP_REQUEST_SET_INFORMATION_EX setInfo;
        char bytes[sizeof *setInfo - sizeof setInfo->Buffer + sizeof(IPAddr)];
    } buffer;

    setInfo = &buffer.setInfo;
    setInfo->ID.toi_id = AO_OPTION_IP_UCASTIF;
    setInfo->BufferSize = sizeof(IPAddr);
    * (IPAddr *) setInfo->Buffer = Address;

    return TunnelSetAddressObjectInformation(AO, setInfo, sizeof buffer);
}

//* TunnelSetAddressObjectTTL
//
//  Set the unicast TTL on a TDI address object.
//  This sets the v4 header TTL that will be used
//  for unicast packets sent via this TDI address object.
//
NTSTATUS
TunnelSetAddressObjectTTL(PFILE_OBJECT AO, uchar TTL)
{
    TCP_REQUEST_SET_INFORMATION_EX setInfo;

    setInfo.ID.toi_id = AO_OPTION_TTL;
    setInfo.BufferSize = 1;
    setInfo.Buffer[0] = TTL;

    return TunnelSetAddressObjectInformation(AO, &setInfo, sizeof setInfo);
}

//* TunnelSetAddressObjectMCastTTL
//
//  Set the multicast TTL on a TDI address object.
//  This sets the v4 header TTL that will be used
//  for multicast packets sent via this TDI address object.
//
NTSTATUS
TunnelSetAddressObjectMCastTTL(PFILE_OBJECT AO, uchar TTL)
{
    TCP_REQUEST_SET_INFORMATION_EX setInfo;

    setInfo.ID.toi_id = AO_OPTION_MCASTTTL;
    setInfo.BufferSize = 1;
    setInfo.Buffer[0] = TTL;

    return TunnelSetAddressObjectInformation(AO, &setInfo, sizeof setInfo);
}

//* TunnelSetAddressObjectMCastIF
//
//  Set the multicast interface on a TDI address object.
//  This sets the v4 source address that will be used
//  for multicast packets sent via this TDI address object.
//
NTSTATUS
TunnelSetAddressObjectMCastIF(PFILE_OBJECT AO, IPAddr Address)
{
    PTCP_REQUEST_SET_INFORMATION_EX setInfo;
    UDPMCastIFReq *req;
    union { // get correct alignment
        TCP_REQUEST_SET_INFORMATION_EX setInfo;
        char bytes[sizeof *setInfo - sizeof setInfo->Buffer + sizeof *req];
    } buffer;

    setInfo = &buffer.setInfo;
    setInfo->ID.toi_id = AO_OPTION_MCASTIF;
    setInfo->BufferSize = sizeof *req;
    req = (UDPMCastIFReq *) setInfo->Buffer;
    req->umi_addr = Address;

    return TunnelSetAddressObjectInformation(AO, setInfo, sizeof buffer);
}

//* TunnelSetAddressObjectMCastLoop
//
//  Controls multicast loopback on a TDI address object.
//  This controls whether looped-back multicast packets
//  can be received via this address object.
//  (IPv4 multicast loopback uses Winsock semantics, not BSD semantics.)
//
NTSTATUS
TunnelSetAddressObjectMCastLoop(PFILE_OBJECT AO, int Loop)
{
    TCP_REQUEST_SET_INFORMATION_EX setInfo;

    setInfo.ID.toi_id = AO_OPTION_MCASTLOOP;
    setInfo.BufferSize = 1;
    setInfo.Buffer[0] = (uchar)Loop;

    return TunnelSetAddressObjectInformation(AO, &setInfo, sizeof setInfo);
}

//* TunnelAddMulticastAddress
//
//  Indicate to the v4 stack that we would like to receive
//  on a multicast address.
//
NTSTATUS
TunnelAddMulticastAddress(
    PFILE_OBJECT AO,
    IPAddr IfAddress,
    IPAddr MCastAddress)
{
    PTCP_REQUEST_SET_INFORMATION_EX setInfo;
    UDPMCastReq *req;
    union { // get correct alignment
        TCP_REQUEST_SET_INFORMATION_EX setInfo;
        char bytes[sizeof *setInfo - sizeof setInfo->Buffer + sizeof *req];
    } buffer;

    setInfo = &buffer.setInfo;
    setInfo->ID.toi_id = AO_OPTION_ADD_MCAST;
    setInfo->BufferSize = sizeof *req;
    req = (UDPMCastReq *) setInfo->Buffer;
    req->umr_if = IfAddress;
    req->umr_addr = MCastAddress;

    return TunnelSetAddressObjectInformation(AO, setInfo, sizeof buffer);
}

//* TunnelDelMulticastAddress
//
//  Indicate to the v4 stack that we are no longer
//  interested in a multicast address.
//
NTSTATUS
TunnelDelMulticastAddress(
    PFILE_OBJECT AO,
    IPAddr IfAddress,
    IPAddr MCastAddress)
{
    PTCP_REQUEST_SET_INFORMATION_EX setInfo;
    UDPMCastReq *req;
    union { // get correct alignment
        TCP_REQUEST_SET_INFORMATION_EX setInfo;
        char bytes[sizeof *setInfo - sizeof setInfo->Buffer + sizeof *req];
    } buffer;

    setInfo = &buffer.setInfo;
    setInfo->ID.toi_id = AO_OPTION_DEL_MCAST;
    setInfo->BufferSize = sizeof *req;
    req = (UDPMCastReq *) setInfo->Buffer;
    req->umr_if = IfAddress;
    req->umr_addr = MCastAddress;

    return TunnelSetAddressObjectInformation(AO, setInfo, sizeof buffer);
}

//* TunnelGetAddressObjectInformation
//
//  Get information from the TDI address object.
//
//  Callable from thread context, not DPC context.
//
NTSTATUS
TunnelGetAddressObjectInformation(
    PFILE_OBJECT AO,
    PTCP_REQUEST_QUERY_INFORMATION_EX GetInfo,
    ULONG GetInfoSize,
    PVOID Buffer,
    ULONG BufferSize)
{
    IO_STATUS_BLOCK iosb;
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    //
    // Initialize the event that we use to wait.
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Create and initialize the IRP for this operation.
    //
    irp = IoBuildDeviceIoControlRequest(IOCTL_TCP_QUERY_INFORMATION_EX,
                                        AO->DeviceObject,
                                        GetInfo,
                                        GetInfoSize,
                                        Buffer,     // output buffer
                                        BufferSize, // output buffer length
                                        FALSE,  // internal device control?
                                        &event,
                                        &iosb);
    if (irp == NULL)
        return STATUS_INSUFFICIENT_RESOURCES;

    iosb.Status = STATUS_UNSUCCESSFUL;
    iosb.Information = (ULONG)-1;

    irpSp = IoGetNextIrpStackLocation(irp);
    irpSp->FileObject = AO;

    //
    // Make the IOCTL, waiting for it to finish if necessary.
    //
    status = IoCallDriver(AO->DeviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode,
                              FALSE, NULL);
        status = iosb.Status;
    }

    return status;
}

//* TunnelGetSourceAddress
//
//  Finds the source address that the IPv4 stack
//  would use to send to the destination address.
//  Returns FALSE upon failure.
//
//  Callable from thread context, not DPC context.
//
int
TunnelGetSourceAddress(IPAddr Dest, IPAddr *Source)
{
    PTCP_REQUEST_QUERY_INFORMATION_EX getInfo;
    IPAddr *req;
    union { // get correct alignment
        TCP_REQUEST_QUERY_INFORMATION_EX getInfo;
        char bytes[sizeof *getInfo - sizeof getInfo->Context + sizeof *req];
    } buffer;

    getInfo = &buffer.getInfo;
    getInfo->ID.toi_entity.tei_entity = CL_NL_ENTITY;
    getInfo->ID.toi_entity.tei_instance = 0;
    getInfo->ID.toi_class = INFO_CLASS_PROTOCOL;
    getInfo->ID.toi_type = INFO_TYPE_PROVIDER;
    getInfo->ID.toi_id = IP_GET_BEST_SOURCE;

    req = (IPAddr *) &getInfo->Context;
    *req = Dest;

    return (NT_SUCCESS(TunnelGetAddressObjectInformation(
                                Tunnel.List.AOFile,
                                getInfo, sizeof buffer,
                                Source, sizeof *Source)) &&
            (*Source != INADDR_ANY));
}

//* TunnelOpenAddressObject
//
//  Opens a raw IPv4 address object,
//  returning a handle (or NULL on error).
//
HANDLE
TunnelOpenAddressObject(IPAddr Address, WCHAR *DeviceName)
{
    UNICODE_STRING objectName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    PTRANSPORT_ADDRESS transportAddress;
    TA_IP_ADDRESS taIPAddress;
    union { // get correct alignment
        FILE_FULL_EA_INFORMATION ea;
        char bytes[sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                  TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                  sizeof taIPAddress];
    } eaBuffer;
    PFILE_FULL_EA_INFORMATION ea = &eaBuffer.ea;
    HANDLE tdiHandle;
    NTSTATUS status;

    //
    // Initialize an IPv4 address.
    //
    taIPAddress.TAAddressCount = 1;
    taIPAddress.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    taIPAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    taIPAddress.Address[0].Address[0].sin_port = 0;
    taIPAddress.Address[0].Address[0].in_addr = Address;

    //
    // Initialize the extended-attributes information,
    // to indicate that we are opening an address object
    // with the specified IPv4 address.
    //
    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    ea->EaValueLength = (USHORT)sizeof taIPAddress;

    RtlMoveMemory(ea->EaName, TdiTransportAddress, ea->EaNameLength + 1);

    transportAddress = (PTRANSPORT_ADDRESS)(&ea->EaName[ea->EaNameLength + 1]);

    RtlMoveMemory(transportAddress, &taIPAddress, sizeof taIPAddress);

    //
    // Open a raw IP address object.
    //

    RtlInitUnicodeString(&objectName, DeviceName);

    InitializeObjectAttributes(&objectAttributes,
                               &objectName,
                               OBJ_CASE_INSENSITIVE,    // Attributes
                               NULL,                    // RootDirectory
                               NULL);                   // SecurityDescriptor

    status = ZwCreateFile(&tdiHandle,
                          GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                          &objectAttributes,
                          &iosb,
                          NULL,                         // AllocationSize
                          0,                            // FileAttributes
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_CREATE,
                          0,                            // CreateOptions
                          ea,
                          sizeof eaBuffer);
    if (!NT_SUCCESS(status))
        return NULL;

    return tdiHandle;
}

//* TunnelObjectAddRef
//
//  Adds another reference to an existing file object.
//
//  Callable from thread or DPC context.
//
void
TunnelObjectAddRef(FILE_OBJECT *File)
{
    NTSTATUS Status;

    Status = ObReferenceObjectByPointer(File, 
                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                    NULL,           // object type
                    KernelMode);
    ASSERT(NT_SUCCESS(Status));
}

//* TunnelObjectFromHandle
//
//  Converts a handle to an object pointer.
//
FILE_OBJECT *
TunnelObjectFromHandle(HANDLE Handle)
{
    PVOID Object;
    NTSTATUS Status;

    Status = ObReferenceObjectByHandle(
                    Handle,
                    GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                    NULL,           // object type
                    KernelMode,
                    &Object,
                    NULL);          // handle info
    ASSERT(NT_SUCCESS(Status));
    ASSERT(Object != NULL);

    return Object;
}

typedef struct TunnelOpenAddressContext {
    WORK_QUEUE_ITEM WQItem;
    IPAddr Addr;
    HANDLE AOHandle;
    FILE_OBJECT *AOFile;
    KEVENT Event;
} TunnelOpenAddressContext;

//* TunnelOpenAddressHelper
//
//  Opens a tunnel address object.
//
//  Callable from thread context, not DPC context.
//  Callable in kernel process context only.
//  Called with the tunnel mutex held.
//
void
TunnelOpenAddressHelper(TunnelOpenAddressContext *oac)
{
    oac->AOHandle = TunnelOpenAddressObject(oac->Addr,
                                TUNNEL_DEVICE_NAME(IP_PROTOCOL_V6));
    if (oac->AOHandle != NULL)
        oac->AOFile = TunnelObjectFromHandle(oac->AOHandle);
    else
        oac->AOFile = NULL;
}

//* TunnelOpenAddressWorker
//
//  Executes the open operations in a worker thread context.
//
void
TunnelOpenAddressWorker(void *Context)
{
    TunnelOpenAddressContext *oac =
        (TunnelOpenAddressContext *) Context;

    TunnelOpenAddressHelper(oac);
    KeSetEvent(&oac->Event, 0, FALSE);
}

//* TunnelOpenAddress
//
//  Address objects must be opened in the kernel process context,
//  so they will not be tied to a particular user process.
//
//  The main input is tc->SrcAddr, but also uses tc->DstAddr.
//  Initializes tc->AOHandle and tc->AOFile.
//  If there is an error opening the address object,
//  they are both initialized to NULL.
//
//  Callable from thread context, not DPC context.
//
void
TunnelOpenAddress(TunnelContext *tc)
{
    TunnelOpenAddressContext oac;
    KIRQL OldIrql;
    NTSTATUS Status;

    oac.Addr = tc->SrcAddr;

    if (IoGetCurrentProcess() != Tunnel.KernelProcess) {
        //
        // We are in the wrong process context, so
        // punt this operation to a worker thread.
        // Initialize and queue the work item -
        // it will execute asynchronously.
        //
        ExInitializeWorkItem(&oac.WQItem, TunnelOpenAddressWorker, &oac);
        KeInitializeEvent(&oac.Event, SynchronizationEvent, FALSE);
        ExQueueWorkItem(&oac.WQItem, CriticalWorkQueue);

        //
        // Wait for the work item to finish.
        //
        (void) KeWaitForSingleObject(&oac.Event, UserRequest,
                                     KernelMode, FALSE, NULL);
    }
    else {
        //
        // It's safe for us to open the address object directly.
        //
        TunnelOpenAddressHelper(&oac);
    }

    if (oac.AOFile != NULL) {
        //
        // Tunnel.V4Device might be null if TunnelOpenV4 failed.
        // Which would be bizarre but conceivable.
        // It would mean we could send tunneled packets but not receive.
        //
        ASSERT((Tunnel.V4Device == NULL) ||
               (oac.AOFile->DeviceObject == Tunnel.V4Device));

        //
        // Finish initializing the new address object.
        //
        Status = TunnelSetAddressObjectUCastIF(oac.AOFile, oac.Addr);
        if (! NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "TunnelOpenAddress(%s): "
                       "TunnelSetAddressObjectUCastIF -> %x\n",
                       FormatV4Address(oac.Addr), Status));
        }

        //
        // For 6over4 interfaces, set additional options.
        //
        if (tc->DstAddr == INADDR_ANY) {

            Status = TunnelSetAddressObjectTTL(oac.AOFile,
                                               TUNNEL_6OVER4_TTL);
            if (! NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "TunnelOpenAddress(%s): "
                           "TunnelSetAddressObjectTTL -> %x\n",
                           FormatV4Address(oac.Addr), Status));
            }

            Status = TunnelSetAddressObjectMCastTTL(oac.AOFile,
                                                    TUNNEL_6OVER4_TTL);
            if (! NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "TunnelOpenAddress(%s): "
                           "TunnelSetAddressObjectMCastTTL -> %x\n",
                           FormatV4Address(oac.Addr), Status));
            }

            Status = TunnelSetAddressObjectMCastIF(oac.AOFile, oac.Addr);
            if (! NT_SUCCESS(Status)) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "TunnelOpenAddress(%s): "
                           "TunnelSetAddressObjectMCastIF -> %x\n",
                           FormatV4Address(oac.Addr), Status));
            }
        }
    }

    //
    // Now that the address object is initialized,
    // we can update the tunnel context.
    // We need both the mutex and spinlock for update.
    // NB: In some paths, the tunnel context is not yet
    // on a list and so the locks are not needed.
    //
    KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
    tc->AOHandle = oac.AOHandle;
    tc->AOFile = oac.AOFile;
    KeReleaseSpinLock(&Tunnel.Lock, OldIrql);
}

typedef struct TunnelCloseAddressObjectContext {
    WORK_QUEUE_ITEM WQItem;
    HANDLE Handle;
    KEVENT Event;
} TunnelCloseAddressObjectContext;

//* TunnelCloseAddressObjectWorker
//
//  Executes the close operation in a worker thread context.
//
void
TunnelCloseAddressObjectWorker(void *Context)
{
    TunnelCloseAddressObjectContext *chc =
        (TunnelCloseAddressObjectContext *) Context;

    ZwClose(chc->Handle);
    KeSetEvent(&chc->Event, 0, FALSE);
}

//* TunnelCloseAddressObject
//
//  Because the address object handles are opened in the kernel process
//  context, we must always close them in the kernel process context.
//
//  Callable from thread context, not DPC context.
//
void
TunnelCloseAddressObject(HANDLE Handle)
{
    if (IoGetCurrentProcess() != Tunnel.KernelProcess) {
        TunnelCloseAddressObjectContext chc;

        //
        // We are in the wrong process context, so
        // punt this operation to a worker thread.
        //

        //
        // Initialize and queue the work item -
        // it will execute asynchronously.
        //
        ExInitializeWorkItem(&chc.WQItem,
                             TunnelCloseAddressObjectWorker, &chc);
        chc.Handle = Handle;
        KeInitializeEvent(&chc.Event, SynchronizationEvent, FALSE);
        ExQueueWorkItem(&chc.WQItem, CriticalWorkQueue);

        //
        // Wait for the work item to finish.
        //
        (void) KeWaitForSingleObject(&chc.Event, UserRequest,
                                     KernelMode, FALSE, NULL);
    }
    else {
        //
        // It's safe for us to close the handle directly.
        //
        ZwClose(Handle);
    }
}

//* TunnelInsertTunnel
//
//  Insert a tunnel on the global list.
//  Called with both tunnel locks held.
//
void
TunnelInsertTunnel(TunnelContext *tc, TunnelContext *List)
{
    tc->Next = List->Next;
    tc->Prev = List;
    List->Next->Prev = tc;
    List->Next = tc;
}

//* TunnelRemoveTunnel
//
//  Remove a tunnel from the global list.
//  Called with both tunnel locks held.
//
void
TunnelRemoveTunnel(TunnelContext *tc)
{
    tc->Next->Prev = tc->Prev;
    tc->Prev->Next = tc->Next;
}

//
// Context information that we pass to the IPv4 stack
// when transmitting.
//
typedef struct TunnelTransmitContext {
    PNDIS_PACKET Packet;
    TA_IP_ADDRESS taIPAddress;
    TDI_CONNECTION_INFORMATION tdiConnInfo;
} TunnelTransmitContext;

//* TunnelTransmitComplete
//
//  Completion function for TunnelTransmit,
//  called when the IPv4 stack completes our IRP.
//
NTSTATUS
TunnelTransmitComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context)
{
    TunnelTransmitContext *ttc = (TunnelTransmitContext *) Context;
    PNDIS_PACKET Packet = ttc->Packet;
    TDI_STATUS TDIStatus = Irp->IoStatus.Status;
    IP_STATUS IPStatus;

    UNREFERENCED_PARAMETER(DeviceObject);

    //
    // Free the state that we allocated in TunnelTransmit.
    //
    ExFreePool(ttc);
    IoFreeIrp(Irp);

    //
    // Undo our adjustment before letting upper-layer code
    // see the packet.
    //
    UndoAdjustPacketBuffer(Packet);

    //
    // Convert the error code.
    // For some errors, we send an ICMPv6 message so that the error
    // can be forwarded. For most errors we just complete the packet.
    //
    switch (TDIStatus) {
    case TDI_SUCCESS:
        IPStatus = IP_SUCCESS;
        goto CallSendComplete;
    case TDI_BUFFER_TOO_BIG:
        //
        // TODO: It would be preferable to generate an ICMPv6 Packet Too Big,
        // but TDI does not give us the MTU value. This needs to be solved
        // before we can set the dont-fragment bit and do PMTU discovery.
        //
        IPStatus = IP_PACKET_TOO_BIG;
        goto CallSendComplete;
    default:
        IPStatus = IP_GENERAL_FAILURE;

    CallSendComplete:
        //
        // Let IPv6 know that the send completed.
        //
        IPv6SendComplete(PC(Packet)->IF, Packet, IPStatus);
        break;

    case TDI_DEST_NET_UNREACH:
    case TDI_DEST_HOST_UNREACH:
    case TDI_DEST_PROT_UNREACH:
    case TDI_DEST_PORT_UNREACH:
        //
        // Generate an ICMPv6 error.
        // Because this is a link-specific error,
        // we use address-unreachable.
        // NB: At the moment, the IPv4 stack does
        // not return these errors to us.
        // This will call IPv6SendComplete for us.
        //
        IPv6SendAbort(CastFromIF(PC(Packet)->IF),
                      Packet,
                      PC(Packet)->pc_offset,
                      ICMPv6_DESTINATION_UNREACHABLE,
                      ICMPv6_ADDRESS_UNREACHABLE,
                      0, FALSE);
        break;
    }

    //
    // Tell IoCompleteRequest to stop working on the IRP.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

//* TunnelTransmitViaAO
//
//  Encapsulate a v6 packet in a v4 packet and send it
//  to the specified v4 address, using the specified
//  TDI address object. The address object may be bound
//  to a v4 address, or else the v4 stack chooses
//  the v4 source address.
//
//  Callable from thread or DPC context.
//
void
TunnelTransmitViaAO(
    FILE_OBJECT *File,          // Pointer to TDI address object.
    PNDIS_PACKET Packet,        // Pointer to packet to be transmitted.
    uint Offset,                // Offset from start of packet to IPv6 header.
    IPAddr Address)             // Link-layer (IPv4) destination address.
{
    TunnelTransmitContext *ttc;
    PIRP irp;
    PMDL mdl;
    UINT SendLen;

    //
    // We do not need any space for a link-layer header,
    // because the IPv4 code takes care of that transparently.
    //
    (void) AdjustPacketBuffer(Packet, Offset, 0);

    //
    // TdiBuildSendDatagram needs an MDL and the total amount
    // of data that the MDL represents.
    //
    NdisQueryPacket(Packet, NULL, NULL, &mdl, &SendLen);

    //
    // Allocate the context that we will pass to the IPv4 stack.
    //
    ttc = ExAllocatePoolWithTagPriority(NonPagedPool, sizeof *ttc,
                                        IP6_TAG, LowPoolPriority);
    if (ttc == NULL) {
    ErrorReturn:
        UndoAdjustPacketBuffer(Packet);
        IPv6SendComplete(PC(Packet)->IF, Packet, IP_GENERAL_FAILURE);
        return;
    }

    //
    // Allocate an IRP that we will pass to the IPv4 stack.
    //
    irp = IoAllocateIrp(File->DeviceObject->StackSize, FALSE);
    if (irp == NULL) {
        ExFreePool(ttc);
        goto ErrorReturn;
    }

    //
    // Initialize the context information.
    // Note that many fields of the "connection info" are unused.
    //
    ttc->Packet = Packet;

    ttc->taIPAddress.TAAddressCount = 1;
    ttc->taIPAddress.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    ttc->taIPAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    ttc->taIPAddress.Address[0].Address[0].sin_port = 0;
    ttc->taIPAddress.Address[0].Address[0].in_addr = Address;

    ttc->tdiConnInfo.RemoteAddressLength = sizeof ttc->taIPAddress;
    ttc->tdiConnInfo.RemoteAddress = &ttc->taIPAddress;

    //
    // Initialize the IRP.
    //
    TdiBuildSendDatagram(irp,
                         File->DeviceObject, File,
                         TunnelTransmitComplete, ttc,
                         mdl, SendLen, &ttc->tdiConnInfo);

    //
    // Pass the IRP to the IPv4 stack.
    // Note that unlike NDIS's asynchronous operations,
    // our completion routine will always be called,
    // no matter what the return code from IoCallDriver.
    //
    (void) IoCallDriver(File->DeviceObject, irp);
}

//* TunnelTransmitViaTC
//
//  Extracts a file object reference from a tunnel context
//  and calls TunnelTransmitViaAO.
//
void
TunnelTransmitViaTC(
    TunnelContext *tc,
    PNDIS_PACKET Packet,        // Pointer to packet to be transmitted.
    uint Offset,                // Offset from start of packet to IPv6 header.
    IPAddr Address)             // Link-layer (IPv4) destination address.
{
    Interface *IF = tc->IF;
    PFILE_OBJECT File;
    KIRQL OldIrql;

    //
    // Get a reference to the TDI address object.
    //
    KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
    File = tc->AOFile;
    if (File == NULL) {
        ASSERT(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED);
        KeReleaseSpinLock(&Tunnel.Lock, OldIrql);

        IPv6SendComplete(IF, Packet, IP_GENERAL_FAILURE);
        return;
    }

    TunnelObjectAddRef(File);
    KeReleaseSpinLock(&Tunnel.Lock, OldIrql);

    TunnelTransmitViaAO(File, Packet, Offset, Address);

    ObDereferenceObject(File);
}

//* TunnelSearchAOList
//
//  Search the list of TDI address objects
//  for one bound to the specified v4 address.
//  If successful, the TDI address object
//  is returned with a reference for the caller.
//
//  REVIEW: This design is inefficient on
//  machines with thousands of v4 addresses.
//
FILE_OBJECT *
TunnelSearchAOList(IPAddr Addr)
{
    FILE_OBJECT *File;
    TunnelContext *tc;
    KIRQL OldIrql;

    KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
    for (tc = Tunnel.AOList.Next; ; tc = tc->Next) {

        if (tc == &Tunnel.AOList) {
            File = NULL;
            break;
        }

        if (tc->SrcAddr == Addr) {
            File = tc->AOFile;
            TunnelObjectAddRef(File);
            break;
        }
    }
    KeReleaseSpinLock(&Tunnel.Lock, OldIrql);

    return File;
}

//* TunnelTransmit
//
//  Translates the arguments of our link-layer transmit function
//  to the internal TunnelTransmitViaTC/AO.
//
void
TunnelTransmit(
    void *Context,              // Pointer to tunnel interface.
    PNDIS_PACKET Packet,        // Pointer to packet to be transmitted.
    uint Offset,                // Offset from start of packet to IPv6 header.
    const void *LinkAddress)    // Link-layer address.
{
    TunnelContext *tc = (TunnelContext *) Context;
    IPAddr Address = * (IPAddr *) LinkAddress;

    //
    // Suppress packets sent to various illegal destination types.
    // REVIEW - It would be good to suppress subnet broadcasts,
    // but we don't know the v4 net mask.
    //
    if ((Address == INADDR_ANY) ||
        IsV4Broadcast(Address) ||
        IsV4Multicast(Address)) {

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                   "TunnelTransmit: illegal destination %s\n",
                   FormatV4Address(Address)));
        IPv6SendAbort(CastFromIF(tc->IF), Packet, Offset,
                      ICMPv6_DESTINATION_UNREACHABLE,
                      ICMPv6_COMMUNICATION_PROHIBITED,
                      0,
                      FALSE);
        return;
    }

    //
    // It would be nice to suppress transmission of packets
    // that will result in v4 loopback, but we don't have a
    // convenient way of doing that here. We could check
    // if Address == tc->SrcAddr, but that won't catch most cases.
    // Instead TunnelReceivePacket checks for this.
    //

    if ((tc->IF->Type == IF_TYPE_TUNNEL_AUTO) ||
        (tc->IF->Type == IF_TYPE_TUNNEL_6TO4)) {
        IPv6Header Buffer;
        IPv6Header UNALIGNED *IP;
        IPAddr DesiredSrc = INADDR_ANY;
        FILE_OBJECT *File;

        //
        // tc->AOFile is not bound to a particular v4 address,
        // so the v4 stack can choose a source address.
        // But it might choose a source address that is not
        // consistent with the v6 source address.
        // To prevent this, we keep a stash of TDI address
        // objects bound to v4 addresses and when appropriate,
        // use a bound TDI address object.
        //
        IP = GetIPv6Header(Packet, Offset, &Buffer);
        if (IP == NULL)
            goto TransmitViaTC;

        if (tc->IF->Type == IF_TYPE_TUNNEL_AUTO) {
            if (IsV4Compatible(AlignAddr(&IP->Source)) ||
                IsISATAP(AlignAddr(&IP->Source))) {
                DesiredSrc = ExtractV4Address(AlignAddr(&IP->Source));
            }
        } else {
            ASSERT(tc->IF->Type == IF_TYPE_TUNNEL_6TO4);
            if (Is6to4(AlignAddr(&IP->Source))) {
                DesiredSrc = Extract6to4Address(AlignAddr(&IP->Source));
            }
        }            

        if (DesiredSrc == INADDR_ANY)
            goto TransmitViaTC;
            
        //
        // Search for a TDI address object bound to
        // the desired v4 source address.
        //
        File = TunnelSearchAOList(DesiredSrc);
        if (File != NULL) {
            
            //
            // Encapsulate and transmit the packet,
            // using the desired v4 source address.
            //
            TunnelTransmitViaAO(File, Packet, Offset, Address);
            ObDereferenceObject(File);
            return;
        }
    }

TransmitViaTC:
    //
    // Encapsulate and transmit the packet.
    //
    TunnelTransmitViaTC(tc, Packet, Offset, Address);
}

//* TunnelTransmitND
//
//  Translates the arguments of our link-layer transmit function
//  to the internal TunnelTransmitViaTC.
//
//  This is just like TunnelTransmit, except it doesn't have
//  the checks for bad destination addresses. 6over4 destination
//  addresses are handled via Neighbor Discovery and
//  multicast is needed.
//
void
TunnelTransmitND(
    void *Context,              // Pointer to tunnel interface.
    PNDIS_PACKET Packet,        // Pointer to packet to be transmitted.
    uint Offset,                // Offset from start of packet to IPv6 header.
    const void *LinkAddress)    // Link-layer address.
{
    TunnelContext *tc = (TunnelContext *) Context;
    IPAddr Address = * (IPAddr *) LinkAddress;

    //
    // Encapsulate and transmit the packet.
    //
    TunnelTransmitViaTC(tc, Packet, Offset, Address);
}

//* TunnelCreateReceiveIrp
//
//  Creates an IRP for TunnelReceive/TunnelReceiveComplete.
//
PIRP
TunnelCreateReceiveIrp(DEVICE_OBJECT *Device)
{
    PIRP irp;
    PMDL mdl;
    void *buffer;

    irp = IoAllocateIrp(Device->StackSize, FALSE);
    if (irp == NULL)
        goto ErrorReturn;

    buffer = ExAllocatePoolWithTagPriority(NonPagedPool, TUNNEL_RECEIVE_BUFFER,
                                           IP6_TAG, LowPoolPriority);
    if (buffer == NULL)
        goto ErrorReturnFreeIrp;

    mdl = IoAllocateMdl(buffer, TUNNEL_RECEIVE_BUFFER,
                        FALSE, // This is the irp's primary MDL.
                        FALSE, // Do not charge quota.
                        irp);
    if (mdl == NULL)
        goto ErrorReturnFreeBuffer;

    MmBuildMdlForNonPagedPool(mdl);

    return irp;

  ErrorReturnFreeBuffer:
    ExFreePool(buffer);
  ErrorReturnFreeIrp:
    IoFreeIrp(irp);
  ErrorReturn:
    return NULL;
}

//* TunnelSelectTunnel
//
//  Try to choose a tunnel on which to deliver a packet.
//
//  Called with the tunnel lock held.
//
NetTableEntryOrInterface *
TunnelSelectTunnel(
    IPv6Addr *V6Dest,   // May be NULL.
    IPAddr V4Dest,
    IPAddr V4Src,
    uint Flags)
{
    TunnelContext *tc;
    Interface *IF;

    //
    // First try to receive the packet on a point-to-point interface.
    //
    for (tc = Tunnel.List.Next;
         tc != &Tunnel.List;
         tc = tc->Next) {
        IF = tc->IF;

        //
        // Restrict the point-to-point tunnel to only receiving
        // packets that are sent from & to the proper link-layer
        // addresses. That is, make it really point-to-point.
        //
        if (((IF->Flags & Flags) == Flags) &&
            (IF->Type == IF_TYPE_TUNNEL_V6V4) &&
            (V4Src == tc->DstAddr) &&
            (V4Dest == tc->SrcAddr)) {

            AddRefIF(IF);
            return CastFromIF(IF);
        }
    }

    //
    // Next try to receive the packet on a 6-over-4 interface.
    //
    for (tc = Tunnel.List.Next;
         tc != &Tunnel.List;
         tc = tc->Next) {
        IF = tc->IF;

        //
        // Restrict the 6-over-4 interface to only receiving
        // packets that are sent to proper link-layer addresses.
        // This is our v4 address and multicast addresses
        // from TunnelConvertAddress.
        //
        if (((Flags == 0) || (IF->Flags & Flags)) &&
            (IF->Type == IF_TYPE_TUNNEL_6OVER4) &&
            ((V4Dest == tc->SrcAddr) ||
             ((((uchar *)&V4Dest)[0] == 239) &&
              (((uchar *)&V4Dest)[1] == 192)))) {

            AddRefIF(IF);
            return CastFromIF(IF);
        }
    }

    //
    // Finally, try to receive the packet on a tunnel pseudo-interface.
    // This is a fall-back for forwarding situations
    // or when V6Dest is NULL. In the latter case,
    // we only consider automatic tunneling interfaces
    // because they usually have link-local addresses.
    //
    for (tc = Tunnel.List.Next;
         tc != &Tunnel.List;
         tc = tc->Next) {
        IF = tc->IF;

        if (((Flags == 0) || (IF->Flags & Flags)) &&
            ((IF->Type == IF_TYPE_TUNNEL_AUTO) ||
             ((V6Dest != NULL) && (IF->Type == IF_TYPE_TUNNEL_6TO4)))) {

            AddRefIF(IF);
            return CastFromIF(IF);
        }
    }

    return NULL;
}

//* TunnelFindReceiver
//
//  Finds the NTEorIF that should receive an encapsulated packet.
//  Returns the NTEorIF with a reference, or NULL.
//  Called at DPC level.
//
NetTableEntryOrInterface *
TunnelFindReceiver(
    IPv6Addr *V6Dest,   // May be NULL.
    IPAddr V4Dest,
    IPAddr V4Src)
{
    NetTableEntryOrInterface *NTEorIF;
    TunnelContext *tc;

    //
    // So we can access the global list of tunnels.
    //
    KeAcquireSpinLockAtDpcLevel(&Tunnel.Lock);

    if (V6Dest != NULL) {
        //
        // First try to receive the packet directly (not forwarding)
        // on a tunnel pseudo-interface.
        //
        for (tc = Tunnel.List.Next;
             tc != &Tunnel.List;
             tc = tc->Next) {
            Interface *IF = tc->IF;

            if ((IF->Type == IF_TYPE_TUNNEL_AUTO) ||
                (IF->Type == IF_TYPE_TUNNEL_6TO4)) {
                ushort Type;

                NTEorIF = FindAddressOnInterface(IF, V6Dest, &Type);
                if (NTEorIF != NULL) {
                    if (Type != ADE_NONE)
                        goto UnlockAndReturn;
                    ReleaseIF(CastToIF(NTEorIF));
                }
            }
        }
    }

    //
    // Next try to receive the packet on a tunnel interface which
    // is marked as forwarding.
    //
    NTEorIF = TunnelSelectTunnel(V6Dest, V4Dest, V4Src, IF_FLAG_FORWARDS);
    if (NTEorIF != NULL)
        goto UnlockAndReturn;

    //
    // Finally try to receive the packet on any matching tunnel interface.
    //
    NTEorIF = TunnelSelectTunnel(V6Dest, V4Dest, V4Src, 0);

UnlockAndReturn:
    KeReleaseSpinLockFromDpcLevel(&Tunnel.Lock);
    return NTEorIF;
}

//* TunnelReceiveIPv6Helper
//
//  Called when we receive an encapsulated IPv6 packet,
//  when we have identified the IPv6 header and found
//  the NTEorIF that will receive the packet.
//
//  Called at DPC level.
//
void
TunnelReceiveIPv6Helper(
    IPHeader UNALIGNED *IPv4H,
    IPv6Header UNALIGNED *IPv6H,
    NetTableEntryOrInterface *NTEorIF,
    void *Data,
    uint Length)
{
    IPv6Packet IPPacket;
    uint Flags;

    //
    // Check if the packet was received as a link-layer multicast/broadcast.
    //
    if (IsV4Broadcast(IPv4H->iph_dest) ||
        IsV4Multicast(IPv4H->iph_dest))
        Flags = PACKET_NOT_LINK_UNICAST;
    else
        Flags = 0;

    RtlZeroMemory(&IPPacket, sizeof IPPacket);
    IPPacket.FlatData = Data;
    IPPacket.Data = Data;
    IPPacket.ContigSize = Length;
    IPPacket.TotalSize = Length;
    IPPacket.Flags = Flags;
    IPPacket.NTEorIF = NTEorIF;

    //
    // We want to prevent any loopback in the v4 stack.
    // Loopback should be handled in our v6 routing table.
    // For example, we want to prevent loops where 6to4
    // addresses are routed around and around and around.
    // Without this code, the hop count would eventually
    // catch the loop and report a strange ICMP error.
    //
    if (IPv4H->iph_dest == IPv4H->iph_src) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "TunnelReceiveIPv6Helper: suppressed loopback\n"));

        //
        // Send an ICMP error. This requires some setup.
        //
        IPPacket.IP = IPv6H;
        IPPacket.SrcAddr = AlignAddr(&IPv6H->Source);
        IPPacket.IPPosition = IPPacket.Position;
        AdjustPacketParams(&IPPacket, sizeof(IPv6Header));

        ICMPv6SendError(&IPPacket,
                        ICMPv6_DESTINATION_UNREACHABLE,
                        ICMPv6_NO_ROUTE_TO_DESTINATION,
                        0, IPv6H->NextHeader, FALSE);
    }
    else {
        int PktRefs;

        PktRefs = IPv6Receive(&IPPacket);
        ASSERT(PktRefs == 0);
    }
}

//* TunnelReceiveIPv6
//
//  Called when we receive an encapsulated IPv6 packet.
//  Called at DPC level.
//
//  We select a single tunnel interface to receive the packet.
//  It's difficult to select the correct interface in all situations.
//
void
TunnelReceiveIPv6(
    IPHeader UNALIGNED *IPv4H,
    void *Data,
    uint Length)
{
    IPv6Header UNALIGNED *IPv6H;
    NetTableEntryOrInterface *NTEorIF;

    //
    // If the packet does not contain a full IPv6 header,
    // just ignore it. We need to look at the IPv6 header
    // below to demultiplex the packet to the proper
    // tunnel interface.
    //
    if (Length < sizeof *IPv6H) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "TunnelReceiveIPv6: too small to contain IPv6 hdr\n"));
        return;
    }
    IPv6H = (IPv6Header UNALIGNED *) Data;

    //
    // Find the NTEorIF that will receive the packet.
    //
    NTEorIF = TunnelFindReceiver(AlignAddr(&IPv6H->Dest),
                                 IPv4H->iph_dest,
                                 IPv4H->iph_src);
    if (NTEorIF == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "TunnelReceiveIPv6: no receiver\n"));
        return;
    }

    TunnelReceiveIPv6Helper(IPv4H, IPv6H, NTEorIF, Data, Length);

    if (IsNTE(NTEorIF))
        ReleaseNTE(CastToNTE(NTEorIF));
    else
        ReleaseIF(CastToIF(NTEorIF));
}

//* TunnelFindPutativeSource
//
//  Finds an address to use as the "source" of an error
//  for completed echo requests.
//  Returns FALSE if no address is available.
//
int
TunnelFindPutativeSource(
    IPAddr V4Dest,
    IPAddr V4Src,
    IPv6Addr *Source,
    uint *ScopeId)
{
    NetTableEntryOrInterface *NTEorIF;
    Interface *IF;
    int rc;

    //
    // First find an interface that would receive
    // a tunneled packet.
    //
    NTEorIF = TunnelFindReceiver(NULL, V4Dest, V4Src);
    if (NTEorIF == NULL)
        return FALSE;

    IF = NTEorIF->IF;

    //
    // Then get a link-local address on the interface.
    //
    rc = GetLinkLocalAddress(IF, Source);
    *ScopeId = IF->ZoneIndices[ADE_LINK_LOCAL];

    if (IsNTE(NTEorIF))
        ReleaseNTE(CastToNTE(NTEorIF));
    else
        ReleaseIF(IF);

    return rc;
}

//* TunnelFindSourceAddress
//
//  Finds a source address to use in a constructed ICMPv6 error,
//  given the NTEorIF that is receiving the ICMPv6 error
//  and the IPv6 destination of the error.
//  Returns FALSE if no address is available.
//
int
TunnelFindSourceAddress(
    NetTableEntryOrInterface *NTEorIF,
    IPv6Addr *V6Dest,
    IPv6Addr *V6Src)
{
    RouteCacheEntry *RCE;
    IP_STATUS Status;

    //
    // REVIEW: In the MIPV6 code base, eliminate this check.
    //
    if (IsNTE(NTEorIF)) {
        *V6Src = CastToNTE(NTEorIF)->Address;
        return TRUE;
    }

    Status = RouteToDestination(V6Dest, 0, NTEorIF, RTD_FLAG_NORMAL, &RCE);
    if (Status != IP_SUCCESS)
        return FALSE;

    *V6Src = RCE->NTE->Address;
    ReleaseRCE(RCE);
    return TRUE;
}

//* TunnelReceiveICMPv4
//
//  Called when we receive an ICMPv4 packet.
//  Called at DPC level.
//
//  If an encapsulated IPv6 packet triggered
//  this ICMPv4 error, then we construct an ICMPv6 error
//  based on the ICMPv4 error and process the constructed packet.
//
void
TunnelReceiveICMPv4(
    IPHeader UNALIGNED *IPv4H,
    void *Data,
    uint Length)
{
    ICMPHeader UNALIGNED *ICMPv4H;
    IPHeader UNALIGNED *ErrorIPv4H;
    uint ErrorHeaderLength;
    IPv6Header UNALIGNED *ErrorIPv6H;
    void *NewData;
    uint NewLength;
    uint NewPayloadLength;
    IPv6Header *NewIPv6H;
    ICMPv6Header *NewICMPv6H;
    uint *NewICMPv6Param;
    void *NewErrorData;
    IPv6Addr V6Src;
    NetTableEntryOrInterface *NTEorIF;

    //
    // If the packet does not contain a full ICMPv4 header,
    // just ignore it.
    //
    if (Length < sizeof *ICMPv4H) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "TunnelReceiveICMPv4: too small to contain ICMPv4 hdr\n"));
        return;
    }
    ICMPv4H = (ICMPHeader UNALIGNED *) Data;
    Length -= sizeof *ICMPv4H;
    (char *)Data += sizeof *ICMPv4H;

    //
    // Ignore everything but selected ICMP errors.
    //
    if ((ICMPv4H->ich_type != ICMP_DEST_UNREACH) &&
        (ICMPv4H->ich_type != ICMP_SOURCE_QUENCH) &&
        (ICMPv4H->ich_type != ICMP_TIME_EXCEED) &&
        (ICMPv4H->ich_type != ICMP_PARAM_PROBLEM))
        return;

    //
    // We need sufficient data from the error packet:
    // at least the IPv4 header.
    //
    if (Length < sizeof *ErrorIPv4H) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "TunnelReceiveICMPv4: "
                   "too small to contain error IPv4 hdr\n"));
        return;
    }
    ErrorIPv4H = (IPHeader UNALIGNED *) Data;
    ErrorHeaderLength = ((ErrorIPv4H->iph_verlen & 0xf) << 2);
    if ((ErrorHeaderLength < sizeof *ErrorIPv4H) ||
        (ErrorIPv4H->iph_length < ErrorHeaderLength)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "TunnelReceiveICMPv4: "
                   "error IPv4 hdr length too small\n"));
        return;
    }

    //
    // We are only interested if this error is in response
    // to an IPv6-in-IPv4 packet.
    //
    if (ErrorIPv4H->iph_protocol != IP_PROTOCOL_V6)
        return;

    //
    // Ignore the packet if the ICMPv4 checksum fails.
    // We do this check after the cheaper checks above,
    // when we know that we really want to process the error.
    //
    if (Cksum(ICMPv4H, sizeof *ICMPv4H + Length) != 0xffff) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "TunnelReceiveICMPv4: bad checksum\n"));
        return;
    }

    //
    // Ensure that we do not look at garbage bytes
    // at the end of the ICMP packet.
    // We must adjust Length after checking the checksum.
    //
    if (ErrorIPv4H->iph_length < Length)
        Length = ErrorIPv4H->iph_length;

    //
    // Ideally we also have the source address in the encapsulated IPv6 header.
    // But often IPv4 routers will return insufficient information.
    // In that case, we make a best effort to identify
    // and complete any outstanding echo requests.
    // Yes, this is a hack.
    //
    
    if (Length < (ErrorHeaderLength +
                  (FIELD_OFFSET(IPv6Header, Source) + sizeof(IPv6Addr)))) {
        uint ScopeId;
        IP_STATUS Status;

        if (! TunnelFindPutativeSource(IPv4H->iph_dest,
                                       ErrorIPv4H->iph_dest,
                                       &V6Src,
                                       &ScopeId)) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "TunnelReceiveICMPv4: no putative source\n"));
            return;
        }

        //
        // The status code here should be the same as if
        // we constructed an ICMPv6 error below and then
        // converted to a status code in ICMPv6ErrorReceive.
        //
        if ((ICMPv4H->ich_type == ICMP_DEST_UNREACH) &&
            (ICMPv4H->ich_code == ICMP_FRAG_NEEDED) &&
            (net_long(ICMPv4H->ich_param) >=
                                ErrorHeaderLength + IPv6_MINIMUM_MTU))
            Status = IP_PACKET_TOO_BIG;
        else
            Status = IP_DEST_ADDR_UNREACHABLE;

        ICMPv6ProcessTunnelError(ErrorIPv4H->iph_dest,
                                 &V6Src, ScopeId,
                                 Status);
        return;
    }

    //
    // Move past the IPv4 header in the error data.
    // Everything past this point, including the error IPv6 header,
    // will become data in the constructed ICMPv6 error.
    //
    Length -= ErrorHeaderLength;
    (char *)Data += ErrorHeaderLength;
    ErrorIPv6H = (IPv6Header UNALIGNED *) Data;

    //
    // Note that Length is guaranteed to be sufficient for Data to include
    // the IPv6 source address, but not the IPv6 destination address.
    // It would be an error to access ErrorIPv6H->Dest.
    //

    //
    // Determine who will receive the constructed ICMPv6 error.
    //
    NTEorIF = TunnelFindReceiver(AlignAddr(&ErrorIPv6H->Source),
                                 IPv4H->iph_dest,
                                 ErrorIPv4H->iph_dest);
    if (NTEorIF == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "TunnelReceiveICMPv4: no receiver\n"));
        return;
    }

    //
    // Find a source address for the constructed ICMPv6 error.
    //
    if (! TunnelFindSourceAddress(NTEorIF, AlignAddr(&ErrorIPv6H->Source),
                                  &V6Src)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "TunnelReceiveICMPv4: no source address\n"));
        goto ReleaseAndReturn;
    }

    //
    // Allocate memory for the constructed ICMPv6 error.
    //
    NewPayloadLength = sizeof *NewICMPv6H + sizeof *NewICMPv6Param + Length;
    NewLength = sizeof *NewIPv6H + NewPayloadLength;
    NewData = ExAllocatePoolWithTagPriority(NonPagedPool, NewLength,
                                            IP6_TAG, LowPoolPriority);
    if (NewData == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TunnelReceiveICMPv4: no pool\n"));
        goto ReleaseAndReturn;
    }

    //
    // Build the IPv6 header.
    //
    NewIPv6H = (IPv6Header *) NewData;
    NewIPv6H->VersClassFlow = IP_VERSION;
    NewIPv6H->PayloadLength = net_short((ushort)NewPayloadLength);
    NewIPv6H->NextHeader = IP_PROTOCOL_ICMPv6;
    NewIPv6H->HopLimit = DEFAULT_CUR_HOP_LIMIT;
    NewIPv6H->Source = V6Src;
    NewIPv6H->Dest = ErrorIPv6H->Source;

    //
    // Build the ICMPv6 header.
    //
    NewICMPv6H = (ICMPv6Header *) (NewIPv6H + 1);
    NewICMPv6Param = (uint *) (NewICMPv6H + 1);

    if ((ICMPv4H->ich_type == ICMP_DEST_UNREACH) &&
        (ICMPv4H->ich_code == ICMP_FRAG_NEEDED)) {
        uint MTU;

        //
        // Calculate the MTU as seen by the IPv6 packet.
        // The MTU can not be smaller than IPv6_MINIMUM_MTU.
        // NB: In old-style frag-needed errors,
        // ich_param should be zero.
        // NB: Actually, this code should not be exercised since
        // we do not set the dont-fragment bit in our IPv4 packets.
        //
        MTU = net_long(ICMPv4H->ich_param);
        if (MTU < ErrorHeaderLength + IPv6_MINIMUM_MTU) {
            //
            // If we were setting the dont-fragment bit,
            // we should clear it in this case.
            // We need to allow the IPv4 layer to fragment.
            //
            goto GenerateAddressUnreachable;
        }
        MTU -= ErrorHeaderLength;

        NewICMPv6H->Type = ICMPv6_PACKET_TOO_BIG;
        NewICMPv6H->Code = 0;
        *NewICMPv6Param = net_long(MTU);
    }
    else {
        //
        // For everything else, we use address-unreachable.
        // It is the appropriate code for a link-specific error.
        //
    GenerateAddressUnreachable:
        NewICMPv6H->Type = ICMPv6_DESTINATION_UNREACHABLE;
        NewICMPv6H->Code = ICMPv6_ADDRESS_UNREACHABLE;
        *NewICMPv6Param = 0;
    }

    //
    // Copy the error data to the new packet.
    //
    NewErrorData = (void *) (NewICMPv6Param + 1);
    RtlCopyMemory(NewErrorData, Data, Length);

    //
    // Calculate the ICMPv6 checksum.
    //
    NewICMPv6H->Checksum = 0;
    NewICMPv6H->Checksum = ChecksumPacket(NULL, 0,
                (uchar *)NewICMPv6H, NewPayloadLength,
                &NewIPv6H->Source, &NewIPv6H->Dest,
                IP_PROTOCOL_ICMPv6);

    //
    // Receive the constructed packet.
    //
    TunnelReceiveIPv6Helper(IPv4H, NewIPv6H, NTEorIF, NewData, NewLength);

    ExFreePool(NewData);
ReleaseAndReturn:
    if (IsNTE(NTEorIF))
        ReleaseNTE(CastToNTE(NTEorIF));
    else
        ReleaseIF(CastToIF(NTEorIF));
}

//* TunnelReceivePacket
//
//  Called when we receive an encapsulated IPv6 packet OR
//  we receive an ICMPv4 packet.
//  Called at DPC level.
//
//  We select a single tunnel interface to receive the packet.
//  It's difficult to select the correct interface in all situations.
//
void
TunnelReceivePacket(void *Data, uint Length)
{
    IPHeader UNALIGNED *IPv4H;
    uint HeaderLength;

    //
    // The incoming data includes the IPv4 header.
    // We should only get properly-formed IPv4 packets.
    //
    ASSERT(Length >= sizeof *IPv4H);
    IPv4H = (IPHeader UNALIGNED *) Data;
    HeaderLength = ((IPv4H->iph_verlen & 0xf) << 2);
    ASSERT(Length >= HeaderLength);
    Length -= HeaderLength;
    (char *)Data += HeaderLength;

    if (IPv4H->iph_src == INADDR_ANY) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "TunnelReceivePacket: null v4 source\n"));
        return;
    }

    if (IPv4H->iph_protocol == IP_PROTOCOL_V6) {
        //
        // Process the encapsulated IPv6 packet.
        //
        TunnelReceiveIPv6(IPv4H, Data, Length);
    }
    else if (IPv4H->iph_protocol == IP_PROTOCOL_ICMPv4) {
        //
        // Process the ICMPv4 packet.
        //
        TunnelReceiveICMPv4(IPv4H, Data, Length);
    }
    else {
        //
        // We should not receive stray packets.
        //
        ABORTMSG("bad iph_protocol");
    }
}

//* TunnelReceiveComplete
//
//  Completion function for TunnelReceive,
//  called when the IPv4 stack completes our IRP.
//
NTSTATUS
TunnelReceiveComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context)
{
    TDI_STATUS status = Irp->IoStatus.Status;
    void *Data;
    ULONG BytesRead;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Context);

    ASSERT(Context == NULL);

    if (status == TDI_SUCCESS) {
        //
        // The incoming data includes the IPv4 header.
        // We should only get properly-formed IPv4 packets.
        //
        BytesRead = (ULONG)Irp->IoStatus.Information;
        Data = Irp->MdlAddress->MappedSystemVa;

        TunnelReceivePacket(Data, BytesRead);
    }

    //
    // Put the IRP back so that TunnelReceive can use it again.
    //
    KeAcquireSpinLockAtDpcLevel(&Tunnel.Lock);
    ASSERT(Tunnel.ReceiveIrp == NULL);
    Tunnel.ReceiveIrp = Irp;
    KeReleaseSpinLockFromDpcLevel(&Tunnel.Lock);

    //
    // Tell IoCompleteRequest to stop working on the IRP.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

//* TunnelReceive
//
//  Called from the IPv4 protocol stack, when it receives
//  an encapsulated v6 packet.
//
NTSTATUS
TunnelReceive(
    IN PVOID TdiEventContext,       // The event context
    IN LONG SourceAddressLength,    // Length of SourceAddress field.
    IN PVOID SourceAddress,         // Describes the datagram's originator.
    IN LONG OptionsLength,          // Length of Options field.
    IN PVOID Options,               // Options for the receive.
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // Number of bytes this indication.
    IN ULONG BytesAvailable,        // Number of bytes in complete Tsdu.
    OUT ULONG *BytesTaken,          // Number of bytes used.
    IN PVOID Tsdu,                  // Pointer describing this TSDU,
                                    // typically a lump of bytes
    OUT PIRP *IoRequestPacket)      // TdiReceive IRP if
                                    // MORE_PROCESSING_REQUIRED.
{
    PIRP irp;

    UNREFERENCED_PARAMETER(TdiEventContext);
    UNREFERENCED_PARAMETER(SourceAddressLength);
    UNREFERENCED_PARAMETER(SourceAddress);
    UNREFERENCED_PARAMETER(OptionsLength);
    UNREFERENCED_PARAMETER(Options);
    UNREFERENCED_PARAMETER(ReceiveDatagramFlags);

    ASSERT(TdiEventContext == NULL);
    ASSERT(BytesIndicated <= BytesAvailable);

    //
    // If the packet is too large, refuse to receive it.
    //
    if (BytesAvailable > TUNNEL_RECEIVE_BUFFER) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                   "TunnelReceive - too big %x\n", BytesAvailable));
        *BytesTaken = BytesAvailable;
        return STATUS_SUCCESS;
    }

    //
    // Check if we already have the entire packet to work with.
    // If so, we can directly call TunnelReceivePacket.
    //
    if (BytesIndicated == BytesAvailable) {

        TunnelReceivePacket(Tsdu, BytesIndicated);

        //
        // Tell our caller that we took the data
        // and that we are done.
        //
        *BytesTaken = BytesAvailable;
        return STATUS_SUCCESS;
    }

    //
    // We need an IRP to receive the entire packet.
    // The IRP has a pre-allocated MDL.
    //
    // NB: We may get here before TunnelOpenV4 has
    // finished initializing. In that case,
    // we will not find an IRP.
    //
    KeAcquireSpinLockAtDpcLevel(&Tunnel.Lock);
    irp = Tunnel.ReceiveIrp;
    Tunnel.ReceiveIrp = NULL;
    KeReleaseSpinLockFromDpcLevel(&Tunnel.Lock);

    //
    // If we don't have an IRP available to us,
    // just drop the packet. This doesn't happen in practice.
    //
    if (irp == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "TunnelReceive - no irp\n"));
        *BytesTaken = BytesAvailable;
        return STATUS_SUCCESS;
    }

    //
    // Build the receive datagram request.
    //
    TdiBuildReceiveDatagram(irp,
                            Tunnel.V4Device,
                            Tunnel.List.AOFile,
                            TunnelReceiveComplete,
                            NULL,       // Context
                            irp->MdlAddress,
                            BytesAvailable,
                            &Tunnel.ReceiveInputInfo,
                            &Tunnel.ReceiveOutputInfo,
                            0);         // ReceiveFlags

    //
    // Make the next stack location current.  Normally IoCallDriver would
    // do this, but since we're bypassing that, we do it directly.
    //
    IoSetNextIrpStackLocation(irp);

    //
    // Return the irp to our caller.
    //
    *IoRequestPacket = irp;
    *BytesTaken = 0;
    return STATUS_MORE_PROCESSING_REQUIRED;
}

//* TunnelSetReceiveHandler
//
//  Request notification of received IPv4 datagrams
//  using the specified TDI address object.
//
NTSTATUS
TunnelSetReceiveHandler(
    FILE_OBJECT *File,  // TDI address object.
    PVOID EventHandler) // Receive handler.
{
    IO_STATUS_BLOCK iosb;
    KEVENT event;
    NTSTATUS status;
    PIRP irp;

    //
    // Initialize the event that we use to wait.
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Create and initialize the IRP for this operation.
    //
    irp = IoBuildDeviceIoControlRequest(0,      // dummy ioctl
                                        File->DeviceObject,
                                        NULL,   // input buffer
                                        0,      // input buffer length
                                        NULL,   // output buffer
                                        0,      // output buffer length
                                        TRUE,   // internal device control?
                                        &event,
                                        &iosb);
    if (irp == NULL)
        return STATUS_INSUFFICIENT_RESOURCES;

    iosb.Status = STATUS_UNSUCCESSFUL;
    iosb.Information = (ULONG)-1;

    TdiBuildSetEventHandler(irp,
                            File->DeviceObject, File,
                            NULL, NULL, // comp routine/context
                            TDI_EVENT_RECEIVE_DATAGRAM,
                            EventHandler, NULL);

    //
    // Make the IOCTL, waiting for it to finish if necessary.
    //
    status = IoCallDriver(File->DeviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode,
                              FALSE, NULL);
        status = iosb.Status;
    }

    return status;
}

//* TunnelCreateToken
//
//  Given a link-layer address, creates a 64-bit "interface token"
//  in the low eight bytes of an IPv6 address.
//  Does not modify the other bytes in the IPv6 address.
//
void
TunnelCreateToken(
    void *Context,
    IPv6Addr *Address)
{
    TunnelContext *tc = (TunnelContext *)Context;

    //
    // Embed the link's interface index in the interface identifier.
    // This makes the interface identifier unique.
    // Otherwise point-to-point tunnel and 6-over-4 links
    // could have the same link-layer address,
    // which is awkward.
    //
    *(ULONG UNALIGNED *)&Address->s6_bytes[8] = net_long(tc->IF->Index);
    *(IPAddr UNALIGNED *)&Address->s6_bytes[12] = tc->TokenAddr;
}

//* TunnelCreateIsatapToken
//
//  Given a link-layer address, creates a 64-bit "interface token"
//  in the low eight bytes of an IPv6 address.
//  Does not modify the other bytes in the IPv6 address.
//
void
TunnelCreateIsatapToken(
    void *Context,
    IPv6Addr *Address)
{
    TunnelContext *tc = (TunnelContext *)Context;

    ASSERT(tc->IF->Type == IF_TYPE_TUNNEL_AUTO);

    Address->s6_words[4] = 0;
    Address->s6_words[5] = 0xfe5e;
    * (IPAddr UNALIGNED *) &Address->s6_words[6] = tc->TokenAddr;
}

//* TunnelReadLinkLayerAddressOption
//
//  Parses a Neighbor Discovery link-layer address option
//  and if valid, returns a pointer to the link-layer address.
//
const void *
TunnelReadLinkLayerAddressOption(
    void *Context,
    const uchar *OptionData)
{
    UNREFERENCED_PARAMETER(Context);

    //
    // Check that the option length is correct.
    //
    if (OptionData[1] != 1)
        return NULL;

    //
    // Check the must-be-zero padding bytes.
    //
    if ((OptionData[2] != 0) || (OptionData[3] != 0))
        return NULL;

    //
    // Return a pointer to the embedded IPv4 address.
    //
    return OptionData + 4;
}

//* TunnelWriteLinkLayerAddressOption
//
//  Creates a Neighbor Discovery link-layer address option.
//  Our caller takes care of the option type & length fields.
//  We handle the padding/alignment/placement of the link address
//  into the option data.
//
//  (Our caller allocates space for the option by adding 2 to the
//  link address length and rounding up to a multiple of 8.)
//
void
TunnelWriteLinkLayerAddressOption(
    void *Context,
    uchar *OptionData,
    const void *LinkAddress)
{
    const uchar *IPAddress = (uchar *)LinkAddress;

    UNREFERENCED_PARAMETER(Context);

    //
    // Place the address after the option type/length bytes
    // and two bytes of zero padding.
    //
    OptionData[2] = 0;
    OptionData[3] = 0;
    OptionData[4] = IPAddress[0];
    OptionData[5] = IPAddress[1];
    OptionData[6] = IPAddress[2];
    OptionData[7] = IPAddress[3];
}

//* TunnelConvertAddress
//
//  Converts an IPv6 address to a link-layer address.
//
ushort
TunnelConvertAddress(
    void *Context,
    const IPv6Addr *Address,
    void *LinkAddress)
{
    TunnelContext *tc = (TunnelContext *)Context;
    Interface *IF = tc->IF;
    IPAddr UNALIGNED *IPAddress = (IPAddr UNALIGNED *)LinkAddress;

    switch (IF->Type) {
    case IF_TYPE_TUNNEL_AUTO:
        if (IsV4Compatible(Address) || IsISATAP(Address)) {
            //
            // Extract the IPv4 address from the interface identifier.
            //
            *IPAddress = ExtractV4Address(Address);

            //
            // We create all such neighbor entries in the PERMANENT state,
            // even those that map to our own link-layer (IPv4) address.
            // Neighbors causing IPv4 loopback result in packets being dropped
            // in TunnelReceiveIPv6Helper.  This is more desirable than
            // creating such neighbors in the INCOMPLETE state since that might
            // cause RouteToDestination to forward packets for the neighbor's
            // destination address out another interface.  These packets would
            // eventually get routed back to us since the IPv6 address maps
            // statically to one of our IPv4 address.  At that point we'll
            // either drop it (if we are a host) or, what's worse, forward it
            // on (if we are a router).
            //
            return ND_STATE_PERMANENT;
        }
        else if ((tc->DstAddr != INADDR_ANY) && 
                 IP6_ADDR_EQUAL(Address, &AllRoutersOnLinkAddr)) {
            //
            // Return the IPv4 address from TunnelSetRouterLLAddress.
            //
            *IPAddress = tc->DstAddr;
            return ND_STATE_PERMANENT;
        }
        else {
            //
            // We can't guess at the correct link-layer address.
            // This value will cause IPv6SendND to drop the packet.
            //
            return ND_STATE_INCOMPLETE;
        }

    case IF_TYPE_TUNNEL_6TO4:
        if (Is6to4(Address)) {
            //
            // Extract the IPv4 address from the prefix.
            //
            *IPAddress = Extract6to4Address(Address);
            
            //
            // We create all such neighbor entries in the PERMANENT state,
            // even those that map to our own link-layer (IPv4) address.
            // Neighbors causing IPv4 loopback result in packets being dropped
            // in TunnelReceiveIPv6Helper.  This is more desirable than
            // creating such neighbors in the INCOMPLETE state since that might
            // cause RouteToDestination to forward packets for the neighbor's
            // destination address out another interface.  These packets would
            // eventually get routed back to us since the IPv6 address maps
            // statically to one of our IPv4 address.  At that point we'll
            // either drop it (if we are a host) or, what's worse, forward it
            // on (if we are a router).
            //
            return ND_STATE_PERMANENT;
        }
        else {
            //
            // We can't guess at the correct link-layer address.
            // This value will cause IPv6SendND to drop the packet.
            //
            return ND_STATE_INCOMPLETE;
        }

    case IF_TYPE_TUNNEL_6OVER4:
        //
        // This is a 6-over-4 link, which uses IPv4 multicast.
        //
        if (IsMulticast(Address)) {
            uchar *IPAddressBytes = (uchar *)LinkAddress;

            IPAddressBytes[0] = 239;
            IPAddressBytes[1] = 192; // REVIEW: or 128 or 64??
            IPAddressBytes[2] = Address->s6_bytes[14];
            IPAddressBytes[3] = Address->s6_bytes[15];
            return ND_STATE_PERMANENT;
        }
        else {
            //
            // Let Neighbor Discovery do its thing for unicast.
            //
            return ND_STATE_INCOMPLETE;
        }

    case IF_TYPE_TUNNEL_V6V4:
        //
        // This is a point-to-point tunnel, so write in
        // the address of the other side of the tunnel.
        //
        *IPAddress = tc->DstAddr;
        if (!(IF->Flags & IF_FLAG_NEIGHBOR_DISCOVERS) || IsMulticast(Address))
            return ND_STATE_PERMANENT;
        else
            return ND_STATE_STALE;

    default:
        ABORTMSG("TunnelConvertAddress: bad IF type");
        return ND_STATE_INCOMPLETE;
    }
}

//* TunnelSetMulticastAddressList
//
//  Takes an array of link-layer multicast addresses
//  (from TunnelConvertAddress) from which we should
//  receive packets. Passes them to the IPv4 stack.
//
//  Callable from thread context, not DPC context.
//
NDIS_STATUS
TunnelSetMulticastAddressList(
    void *Context,
    const void *LinkAddresses,
    uint NumKeep,
    uint NumAdd,
    uint NumDel)
{
    TunnelContext *tc = (TunnelContext *)Context;
    IPAddr *Addresses = (IPAddr *)LinkAddresses;
    NTSTATUS Status;
    uint i;

    //
    // We only do something for 6-over-4 links.
    //
    ASSERT(tc->IF->Type == IF_TYPE_TUNNEL_6OVER4);

    //
    // The IPv6 layer serializes calls to TunnelSetMulticastAddressList
    // and TunnelResetMulticastAddressListDone, so we can safely check
    // SetMCListOK to handle races with TunnelOpenV4.
    //
    if (tc->SetMCListOK) {
        //
        // We add the multicast addresses to Tunnel.List.AOFile,
        // instead of tc->AOFile, because we are only receiving
        // from the first address object.
        //
        for (i = 0; i < NumAdd; i++) {
            Status = TunnelAddMulticastAddress(
                                Tunnel.List.AOFile,
                                tc->SrcAddr,
                                Addresses[NumKeep + i]);
            if (! NT_SUCCESS(Status))
                goto Return;
        }

        for (i = 0; i < NumDel; i++) {
            Status = TunnelDelMulticastAddress(
                                Tunnel.List.AOFile,
                                tc->SrcAddr,
                                Addresses[NumKeep + NumAdd + i]);
            if (! NT_SUCCESS(Status))
                goto Return;
        }
    }

    Status = STATUS_SUCCESS;
Return:
    return (NDIS_STATUS) Status;
}

//* TunnelResetMulticastAddressListDone
//
//  Indicates that RestartLinkLayerMulticast has finished,
//  and subsequent calls to TunnelSetMulticastAddressList
//  will inform us of the link-layer multicast addresses.
//
//  Callable from thread context, not DPC context.
//
void
TunnelResetMulticastAddressListDone(void *Context)
{
    TunnelContext *tc = (TunnelContext *)Context;

    tc->SetMCListOK = TRUE;
}

//* TunnelClose
//
//  Shuts down a tunnel.
//
//  Callable from thread context, not DPC context.
//
void
TunnelClose(void *Context)
{
    TunnelContext *tc = (TunnelContext *)Context;
    KIRQL OldIrql;

    //
    // Remove the tunnel from our data structures.
    //
    KeWaitForSingleObject(&Tunnel.Mutex, Executive, KernelMode, FALSE, NULL);
    KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
    TunnelRemoveTunnel(tc);
    KeReleaseSpinLock(&Tunnel.Lock, OldIrql);
    KeReleaseMutex(&Tunnel.Mutex, FALSE);

    ReleaseIF(tc->IF);
}


//* TunnelCleanup
//
//  Performs final cleanup of the tunnel context.
//
void
TunnelCleanup(void *Context)
{
    TunnelContext *tc = (TunnelContext *)Context;

    if (tc->AOHandle == NULL) {
        //
        // No references to release.
        //
        ASSERT(tc->AOFile == NULL);
    }
    else if (tc->AOHandle == Tunnel.List.AOHandle) {
        //
        // No references to release.
        //
        ASSERT(tc->AOFile == Tunnel.List.AOFile);
    }
    else {
        ObDereferenceObject(tc->AOFile);
        TunnelCloseAddressObject(tc->AOHandle);
    }

    ExFreePool(tc);
}


//* TunnelSetRouterLLAddress
//
// Sets the ISATAP router's IPv4 address.
//
NTSTATUS
TunnelSetRouterLLAddress(
    void *Context, 
    const void *TokenLinkAddress,
    const void *RouterLinkAddress)
{
    TunnelContext *tc = (TunnelContext *) Context;
    IPv6Addr LinkLocalAddress;
    KIRQL OldIrql;
    NetTableEntry *NTE;
    Interface *IF = tc->IF;

    ASSERT(IF->Type == IF_TYPE_TUNNEL_AUTO);

    //
    // We should not set/reset one without the other.
    //
    if ((*((IPAddr *) RouterLinkAddress) == INADDR_ANY) !=
        (*((IPAddr *) TokenLinkAddress) == INADDR_ANY))
        return STATUS_INVALID_PARAMETER;    
    
    RtlCopyMemory(&tc->DstAddr, RouterLinkAddress, sizeof(IPAddr));
    RtlCopyMemory(&tc->TokenAddr, TokenLinkAddress, sizeof(IPAddr));

    KeAcquireSpinLock(&IF->Lock, &OldIrql);
    
    if (tc->DstAddr != INADDR_ANY) {
        //
        // Look for a link-local NTE matching the TokenAddr.
        // If we find one, set the preferred link-local NTE to that one,
        // so that the IPv6 source address of RS's will match the IPv4
        // source address of the outer header.
        //
        LinkLocalAddress = LinkLocalPrefix;
        TunnelCreateIsatapToken(Context, &LinkLocalAddress);
        NTE = (NetTableEntry *) *FindADE(IF, &LinkLocalAddress);
        if ((NTE != NULL) && (NTE->Type == ADE_UNICAST))
            IF->LinkLocalNTE = NTE;

        //
        // Enable address auto-configuration.
        //
        IF->CreateToken = TunnelCreateIsatapToken;

        //
        // Enable Router Discovery.
        //
        IF->Flags |= IF_FLAG_ROUTER_DISCOVERS;
        
        //
        // Trigger a Router Solicitation.
        //
        if (!(IF->Flags & IF_FLAG_ADVERTISES)) {
            IF->RSCount = 0;
            IF->RSTimer = 1;
        }
    }
    else {
        //
        // Disable address auto-configuration.
        //
        IF->CreateToken = NULL;

        //
        // Disable Router Discovery.
        //
        IF->Flags &= ~IF_FLAG_ROUTER_DISCOVERS;

        //
        // Stop sending Router Solicitations.
        //
        if (!(IF->Flags & IF_FLAG_ADVERTISES)) {
            IF->RSTimer = 0;
        }
    }
    
    //
    // Remove addresses & routes that were auto-configured from
    // Router Advertisements.
    //
    AddrConfResetAutoConfig(IF, 0);
    RouteTableResetAutoConfig(IF, 0);
    InterfaceResetAutoConfig(IF);        

    KeReleaseSpinLock(&IF->Lock, OldIrql);

    return STATUS_SUCCESS;
}


//* TunnelCreatePseudoInterface
//
//  Creates a pseudo-interface. Type can either be
//  IF_TYPE_TUNNEL_AUTO (v4-compatible/ISATAP) or
//  IF_TYPE_TUNNEL_6TO4 (6to4 tunneling).
//
//  Callable from thread context, not DPC context.
//
//  Return codes:
//      STATUS_INSUFFICIENT_RESOURCES
//      STATUS_UNSUCCESSFUL
//      STATUS_SUCCESS
//
NTSTATUS
TunnelCreatePseudoInterface(const char *InterfaceName, uint Type)
{
    GUID Guid;
    LLIPv6BindInfo BindInfo;
    TunnelContext *tc;
    NTSTATUS Status;
    KIRQL OldIrql;

    ASSERT((Type == IF_TYPE_TUNNEL_AUTO) ||
           (Type == IF_TYPE_TUNNEL_6TO4));

    //
    // Allocate memory for the TunnelContext.
    //
    tc = ExAllocatePool(NonPagedPool, sizeof *tc);
    if (tc == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorReturn;
    }

    //
    // Tunnel pseudo-interfaces need a dummy link-layer address.
    // It must be distinct from any address assigned to other nodes,
    // so that the loopback check in IPv6SendLL works.
    //
    tc->SrcAddr = INADDR_LOOPBACK;
    tc->TokenAddr = INADDR_ANY;
    tc->DstAddr = INADDR_ANY;
    tc->SetMCListOK = FALSE;

    //
    // Prepare the binding info for CreateInterface.
    //
    BindInfo.lip_context = tc;
    BindInfo.lip_maxmtu = TUNNEL_MAX_MTU;
    BindInfo.lip_defmtu = TUNNEL_DEFAULT_MTU;
    BindInfo.lip_flags = IF_FLAG_PSEUDO;
    BindInfo.lip_type = Type;
    BindInfo.lip_hdrsize = 0;
    BindInfo.lip_addrlen = sizeof(IPAddr);
    BindInfo.lip_addr = (uchar *) &tc->SrcAddr;
    BindInfo.lip_dadxmit = 0;
    BindInfo.lip_pref = TUNNEL_DEFAULT_PREFERENCE;
    BindInfo.lip_token = NULL;
    BindInfo.lip_rdllopt = NULL;
    BindInfo.lip_wrllopt = NULL;
    BindInfo.lip_cvaddr = TunnelConvertAddress;
    if (Type == IF_TYPE_TUNNEL_AUTO)
        BindInfo.lip_setrtrlladdr = TunnelSetRouterLLAddress;
    else
        BindInfo.lip_setrtrlladdr = NULL;
    BindInfo.lip_transmit = TunnelTransmit;
    BindInfo.lip_mclist = NULL;
    BindInfo.lip_close = TunnelClose;
    BindInfo.lip_cleanup = TunnelCleanup;

    CreateGUIDFromName(InterfaceName, &Guid);

    //
    // Prevent races with TunnelClose by taking the mutex
    // before calling CreateInterface.
    //
    KeWaitForSingleObject(&Tunnel.Mutex, Executive, KernelMode, FALSE, NULL);

    if (Tunnel.List.AOHandle == NULL) {
        //
        // TunnelOpenV4 has not yet happened.
        // Create the interface in the disconnected state.
        //
        tc->AOHandle = NULL;
        tc->AOFile = NULL;
        BindInfo.lip_flags |= IF_FLAG_MEDIA_DISCONNECTED;
    }
    else {
        //
        // No need to open a new address object.
        // Just reuse the global Tunnel.List address object.
        //
        tc->AOHandle = Tunnel.List.AOHandle;
        tc->AOFile = Tunnel.List.AOFile;
    }

    //
    // Create the IPv6 interface.
    // We can hold the mutex across this call, but not a spinlock.
    //
    Status = CreateInterface(&Guid, &BindInfo, (void **)&tc->IF);
    if (! NT_SUCCESS(Status))
        goto ErrorReturnUnlock;

    //
    // Once we unlock, the interface could be gone.
    //
    KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
    TunnelInsertTunnel(tc, &Tunnel.List);
    KeReleaseSpinLock(&Tunnel.Lock, OldIrql);
    KeReleaseMutex(&Tunnel.Mutex, FALSE);

    return STATUS_SUCCESS;

ErrorReturnUnlock:
    KeReleaseMutex(&Tunnel.Mutex, FALSE);
    ExFreePool(tc);
ErrorReturn:
    return Status;
}


//* TunnelOpenV4
//
//  Establishes our connection to the IPv4 stack,
//  so we can send and receive tunnelled packets.
//
//  Called with the tunnel mutex held.
//
void
TunnelOpenV4(void)
{
    HANDLE Handle, IcmpHandle;
    FILE_OBJECT *File, *IcmpFile;
    DEVICE_OBJECT *Device;
    IRP *ReceiveIrp;
    TunnelContext *tc;
    KIRQL OldIrql;
    NTSTATUS Status;

    //
    // We use a single address object to receive all tunnelled packets.
    //
    Handle = TunnelOpenAddressObject(INADDR_ANY,
                                     TUNNEL_DEVICE_NAME(IP_PROTOCOL_V6));
    if (Handle == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TunnelOpenV4: TunnelOpenAddressObject(%u) failed\n",
                   IP_PROTOCOL_V6));
        return;
    }

    File = TunnelObjectFromHandle(Handle);

    //
    // We use a second address object to receive ICMPv4 packets.
    //
    IcmpHandle = TunnelOpenAddressObject(INADDR_ANY,
                                TUNNEL_DEVICE_NAME(IP_PROTOCOL_ICMPv4));
    if (IcmpHandle == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TunnelOpenV4: TunnelOpenAddressObject(%u) failed\n",
                   IP_PROTOCOL_ICMPv4));
        goto ReturnReleaseHandle;
    }

    IcmpFile = TunnelObjectFromHandle(IcmpHandle);

    //
    // Disable reception of multicast loopback packets.
    //
    Status = TunnelSetAddressObjectMCastLoop(File, FALSE);
    if (! NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TunnelOpenV4: "
                   "TunnelSetAddressObjectMCastLoop: %x\n", Status));
        goto ReturnReleaseBothHandles;
    }

    //
    // After TunnelSetReceiveHandler, we will start receiving
    // encapsulated v6 packets. However they will be dropped
    // until we finish our initialization here.
    //
    Status = TunnelSetReceiveHandler(File, TunnelReceive);
    if (! NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TunnelOpenV4: "
                   "TunnelSetReceiveHandler: %x\n", Status));
        goto ReturnReleaseBothHandles;
    }

    Status = TunnelSetReceiveHandler(IcmpFile, TunnelReceive);
    if (! NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TunnelOpenV4: "
                   "TunnelSetReceiveHandler(2): %x\n", Status));
        goto ReturnReleaseBothHandles;
    }

    Device = File->DeviceObject;
    ASSERT(Device == IcmpFile->DeviceObject);
    ReceiveIrp = TunnelCreateReceiveIrp(Device);
    if (ReceiveIrp == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TunnelOpenV4: TunnelCreateReceiveIrp failed\n"));

    ReturnReleaseBothHandles:
        ObDereferenceObject(IcmpFile);
        TunnelCloseAddressObject(IcmpHandle);
    ReturnReleaseHandle:
        ObDereferenceObject(File);
        TunnelCloseAddressObject(Handle);
        return;
    }

    //
    // We have successfully opened a connection to the IPv4 stack.
    // Update our data structures.
    //
    KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
    Tunnel.List.AOHandle = Handle;
    Tunnel.List.AOFile = File;
    Tunnel.V4Device = Device;
    Tunnel.ReceiveIrp = ReceiveIrp;
    Tunnel.IcmpHandle = IcmpHandle;
    Tunnel.IcmpFile = IcmpFile;
    KeReleaseSpinLock(&Tunnel.Lock, OldIrql);

    //
    // Now search our list of interfaces and transition
    // pseudo-interfaces to the connected state.
    //
    for (tc = Tunnel.List.Next;
         tc != &Tunnel.List;
         tc = tc->Next) {
        Interface *IF = tc->IF;

        if ((IF->Type == IF_TYPE_TUNNEL_AUTO) ||
            (IF->Type == IF_TYPE_TUNNEL_6TO4)) {
            //
            // The pseudo-interface contexts do not hold
            // separate references for the main TDI address object.
            //
            ASSERT(tc->AOHandle == NULL);
            ASSERT(tc->AOFile == NULL);
            KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
            tc->AOHandle = Handle;
            tc->AOFile = File;
            KeReleaseSpinLock(&Tunnel.Lock, OldIrql);

            SetInterfaceLinkStatus(IF, TRUE);
        }
        else if (IF->Type == IF_TYPE_TUNNEL_6OVER4) {
            //
            // We must start listening to multicast addresses
            // for this 6over4 interface.
            //
            RestartLinkLayerMulticast(IF, TunnelResetMulticastAddressListDone);
        }
    }
}


//* TunnelAddAddress
//
//  Called by TDI when a transport registers an address.
//
void
TunnelAddAddress(
    TA_ADDRESS *Address,
    UNICODE_STRING *DeviceName,
    TDI_PNP_CONTEXT *Context)
{
    UNREFERENCED_PARAMETER(DeviceName);
    UNREFERENCED_PARAMETER(Context);

    if (Address->AddressType == TDI_ADDRESS_TYPE_IP) {
        TDI_ADDRESS_IP *TdiAddr = (TDI_ADDRESS_IP *) Address->Address;
        IPAddr V4Addr = TdiAddr->in_addr;
        TunnelContext *tc;
        KIRQL OldIrql;

        KeWaitForSingleObject(&Tunnel.Mutex, Executive, KernelMode,
                              FALSE, NULL);

        //
        // First, open a connection to the IPv4 stack if needed.
        //
        if (Tunnel.List.AOHandle == NULL)
            TunnelOpenV4();

        //
        // Next, search for disconnected interfaces that should be connected.
        //
        for (tc = Tunnel.List.Next;
             tc != &Tunnel.List;
             tc = tc->Next) {
            if (tc->SrcAddr == V4Addr) {
                Interface *IF = tc->IF;

                if (tc->AOHandle == NULL) {
                    ASSERT(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED);

                    TunnelOpenAddress(tc);

                    //
                    // Did TunnelOpenAddress succeed?
                    // If not, leave the interface disconnected.
                    //
                    if (tc->AOHandle == NULL) {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                                   "TunnelAddAddress(%s): "
                                   "TunnelOpenAddress failed\n",
                                   FormatV4Address(V4Addr)));
                    }
                    else {
                        //
                        // Connect the interface.
                        //
                        SetInterfaceLinkStatus(IF, TRUE);
                    }
                }
                else {
                    //
                    // This is unusual... it indicates a race
                    // with TunnelCreateTunnel.
                    //
                    ASSERT(!(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED));
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                               "TunnelAddAddress(%s) IF %p connected?\n",
                               FormatV4Address(V4Addr), IF));
                }
            }
        }

        //
        // Finally, add an address object to the list.
        // Maintain the invariant that an address is present at most once.
        //
        for (tc = Tunnel.AOList.Next; ; tc = tc->Next) {

            if (tc == &Tunnel.AOList) {
                //
                // Add a new address object.
                //
                tc = ExAllocatePool(NonPagedPool, sizeof *tc);
                if (tc != NULL) {

                    //
                    // Open the address object.
                    //
                    tc->SrcAddr = V4Addr;
                    tc->DstAddr = V4Addr;
                    TunnelOpenAddress(tc);

                    if (tc->AOFile != NULL) {
                        //
                        // Put the address object on the list.
                        //
                        KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
                        TunnelInsertTunnel(tc, &Tunnel.AOList);
                        KeReleaseSpinLock(&Tunnel.Lock, OldIrql);
                    }
                    else {
                        //
                        // Cleanup the context. We will not
                        // put an address object on the list.
                        //
                        ExFreePool(tc);
                    }
                }
                break;
            }

            if (tc->SrcAddr == V4Addr) {
                //
                // It already exists.
                // REVIEW: Can this happen?
                //
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                           "TunnelAddAddress(%s) already on AOList?\n",
                           FormatV4Address(V4Addr)));
                break;
            }
        }

        KeReleaseMutex(&Tunnel.Mutex, FALSE);
    }
}


//* TunnelDelAddress
//
//  Called by TDI when a transport unregisters an address.
//
void
TunnelDelAddress(
    TA_ADDRESS *Address,
    UNICODE_STRING *DeviceName,
    TDI_PNP_CONTEXT *Context)
{
    UNREFERENCED_PARAMETER(DeviceName);
    UNREFERENCED_PARAMETER(Context);

    if (Address->AddressType == TDI_ADDRESS_TYPE_IP) {
        TDI_ADDRESS_IP *TdiAddr = (TDI_ADDRESS_IP *) Address->Address;
        IPAddr V4Addr = TdiAddr->in_addr;
        TunnelContext *tc;
        KIRQL OldIrql;

        KeWaitForSingleObject(&Tunnel.Mutex, Executive, KernelMode,
                              FALSE, NULL);

        //
        // Search for connected interfaces that should be disconnected.
        //
        for (tc = Tunnel.List.Next;
             tc != &Tunnel.List;
             tc = tc->Next) {
            if (tc->SrcAddr == V4Addr) {
                Interface *IF = tc->IF;

                if (tc->AOHandle == NULL) {
                    //
                    // The interface is already disconnected.
                    //
                    ASSERT(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED);
                }
                else {
                    HANDLE Handle;
                    FILE_OBJECT *File;

                    //
                    // The interface is connected.
                    //
                    ASSERT(!(IF->Flags & IF_FLAG_MEDIA_DISCONNECTED));

                    //
                    // Disconnect the interface.
                    //
                    SetInterfaceLinkStatus(IF, FALSE);

                    //
                    // Release the address object.
                    //

                    Handle = tc->AOHandle;
                    File = tc->AOFile;

                    KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
                    tc->AOHandle = NULL;
                    tc->AOFile = NULL;
                    KeReleaseSpinLock(&Tunnel.Lock, OldIrql);

                    ObDereferenceObject(File);
                    TunnelCloseAddressObject(Handle);
                }
            }
        }

        //
        // Remove an address object from the list.
        // There can be at most one.
        //
        for (tc = Tunnel.AOList.Next;
             tc != &Tunnel.AOList;
             tc = tc->Next) {
            if (tc->SrcAddr == V4Addr) {
                //
                // Remove this cache entry.
                //
                KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
                TunnelRemoveTunnel(tc);
                KeReleaseSpinLock(&Tunnel.Lock, OldIrql);

                ObDereferenceObject(tc->AOFile);
                TunnelCloseAddressObject(tc->AOHandle);
                ExFreePool(tc);
                break;
            }
        }

        KeReleaseMutex(&Tunnel.Mutex, FALSE);
    }
}


//* TunnelInit - Initialize the tunnel module.
//
//  This functions initializes the tunnel module.
//
//  Returns FALSE if we fail to init.
//  This should "never" happen, so we are not
//  careful about cleanup in that case.
//
//  Note we return TRUE if IPv4 is not available,
//  but then tunnel functionality will not be available.
//
int
TunnelInit(void)
{
    TDI_CLIENT_INTERFACE_INFO Handlers;
    NTSTATUS status;

    Tunnel.KernelProcess = IoGetCurrentProcess();

    KeInitializeSpinLock(&Tunnel.Lock);
    KeInitializeMutex(&Tunnel.Mutex, 0);

    //
    // Initialize the global list of tunnels.
    //
    Tunnel.List.Next = Tunnel.List.Prev = &Tunnel.List;

    //
    // Initialize the global list of address objects.
    //
    Tunnel.AOList.Next = Tunnel.AOList.Prev = &Tunnel.AOList;

    //
    // Initialize the pseudo-interfaces used
    // for automatic/ISATAP tunneling
    // and 6to4 tunneling.
    //

    status = TunnelCreatePseudoInterface("Auto Tunnel Pseudo-Interface",
                                         IF_TYPE_TUNNEL_AUTO);
    if (! NT_SUCCESS(status))
        return FALSE;
    ASSERT(IFList->Index == 2); // 6to4svc and scripts depend on this.

    status = TunnelCreatePseudoInterface("6to4 Tunnel Pseudo-Interface",
                                         IF_TYPE_TUNNEL_6TO4);
    if (! NT_SUCCESS(status))
        return FALSE;
    ASSERT(IFList->Index == 3); // 6to4svc and scripts depend on this.

    //
    // Request address notifications from TDI.
    // REVIEW - What should ClientName be? Does it matter?
    //

    memset(&Handlers, 0, sizeof Handlers);
    Handlers.MajorTdiVersion = TDI_CURRENT_MAJOR_VERSION;
    Handlers.MinorTdiVersion = TDI_CURRENT_MINOR_VERSION;
    Handlers.ClientName = &Tunnel.List.Next->IF->DeviceName;
    Handlers.AddAddressHandlerV2 = TunnelAddAddress;
    Handlers.DelAddressHandlerV2 = TunnelDelAddress;

    status = TdiRegisterPnPHandlers(&Handlers, sizeof Handlers,
                                    &Tunnel.TdiHandle);
    if (!NT_SUCCESS(status))
        return FALSE;

    return TRUE;
}


//* TunnelUnload
//
//  Called to cleanup when the driver is unloading.
//
//  Callable from thread context, not DPC context.
//
void
TunnelUnload(void)
{
    TunnelContext *tc;

    //
    // All interfaces are already destroyed.
    //
    ASSERT(Tunnel.List.Next == &Tunnel.List);
    ASSERT(Tunnel.List.Prev == &Tunnel.List);

    //
    // Stop TDI notifications.
    // REVIEW: How to handle failure, esp. STATUS_NETWORK_BUSY?
    //
    (void) TdiDeregisterPnPHandlers(Tunnel.TdiHandle);

    //
    // Cleanup any remaining address objects.
    //
    while ((tc = Tunnel.AOList.Next) != &Tunnel.AOList) {
        TunnelRemoveTunnel(tc);
        ObDereferenceObject(tc->AOFile);
        TunnelCloseAddressObject(tc->AOHandle);
        ExFreePool(tc);
    }
    ASSERT(Tunnel.AOList.Prev == &Tunnel.AOList);

    //
    // Cleanup if TunnelOpenV4 has succeeded.
    //
    if (Tunnel.List.AOHandle != NULL) {
        void *buffer;

        //
        // Stop receiving encapsulated (v6 in v4) and ICMPv4 packets.
        // This should block until any current TunnelReceive
        // callbacks return, and prevent new callbacks.
        // REVIEW: It is really legal to change a receive handler?
        // Would just closing the address objects have the proper
        // synchronization behavior?
        //
        (void) TunnelSetReceiveHandler(Tunnel.IcmpFile, NULL);
        (void) TunnelSetReceiveHandler(Tunnel.List.AOFile, NULL);

        ObDereferenceObject(Tunnel.IcmpFile);
        TunnelCloseAddressObject(Tunnel.IcmpHandle);

        ObDereferenceObject(Tunnel.List.AOFile);
        TunnelCloseAddressObject(Tunnel.List.AOHandle);

        buffer = Tunnel.ReceiveIrp->MdlAddress->MappedSystemVa;
        IoFreeMdl(Tunnel.ReceiveIrp->MdlAddress);
        IoFreeIrp(Tunnel.ReceiveIrp);
        ExFreePool(buffer);
    }
}


//* TunnelCreateTunnel
//
//  Creates a tunnel. If DstAddr is INADDR_ANY,
//  then it's a 6-over-4 tunnel. Otherwise it's point-to-point.
//
//  Callable from thread context, not DPC context.
//
//  Return codes:
//      STATUS_ADDRESS_ALREADY_EXISTS   The tunnel already exists.
//      STATUS_INSUFFICIENT_RESOURCES
//      STATUS_UNSUCCESSFUL
//      STATUS_SUCCESS
//
NTSTATUS
TunnelCreateTunnel(IPAddr SrcAddr, IPAddr DstAddr,
                   uint Flags, Interface **ReturnIF)
{
    char SrcAddrStr[16], DstAddrStr[16];
    char InterfaceName[128];
    GUID Guid;
    LLIPv6BindInfo BindInfo;
    TunnelContext *tc, *tcTmp;
    KIRQL OldIrql;
    NTSTATUS Status;

    //
    // 6over4 interfaces must use Neighbor Discovery
    // and may use Router Discovery but should not have other flags set.
    // p2p interfaces may use ND, RD, and/or periodic MLD.
    //
    ASSERT(SrcAddr != INADDR_ANY);
    ASSERT((DstAddr == INADDR_ANY) ?
           ((Flags & IF_FLAG_NEIGHBOR_DISCOVERS) &&
            !(Flags &~ IF_FLAGS_DISCOVERS)) :
           !(Flags &~ (IF_FLAGS_DISCOVERS|IF_FLAG_PERIODICMLD)));

    FormatV4AddressWorker(SrcAddrStr, SrcAddr);
    FormatV4AddressWorker(DstAddrStr, DstAddr);

    tc = ExAllocatePool(NonPagedPool, sizeof *tc);
    if (tc == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorReturn;
    }

    tc->DstAddr = DstAddr;
    tc->TokenAddr = tc->SrcAddr = SrcAddr;
    tc->SetMCListOK = FALSE;

    //
    // Prepare the binding info for CreateInterface.
    //
    BindInfo.lip_context = tc;
    BindInfo.lip_maxmtu = TUNNEL_MAX_MTU;
    BindInfo.lip_defmtu = TUNNEL_DEFAULT_MTU;
    if (DstAddr == INADDR_ANY) {
        BindInfo.lip_type = IF_TYPE_TUNNEL_6OVER4;
        BindInfo.lip_flags = IF_FLAG_MULTICAST;

        sprintf(InterfaceName, "6over4 %hs", SrcAddrStr);
    } else {
        BindInfo.lip_type = IF_TYPE_TUNNEL_V6V4;
        BindInfo.lip_flags = IF_FLAG_P2P | IF_FLAG_MULTICAST;

        sprintf(InterfaceName, "v6v4 %hs %hs", SrcAddrStr, DstAddrStr);
    }
    BindInfo.lip_flags |= Flags;

    CreateGUIDFromName(InterfaceName, &Guid);

    //
    // We do not want IPv6 to reserve space for our link-layer header.
    //
    BindInfo.lip_hdrsize = 0;
    //
    // For point-to-point interfaces, the remote link-layer address
    // must follow the local link-layer address in memory.
    // So we rely on the TunnelContext layout of SrcAddr & DstAddr.
    //
    BindInfo.lip_addrlen = sizeof(IPAddr);
    BindInfo.lip_addr = (uchar *) &tc->SrcAddr;
    BindInfo.lip_dadxmit = 1; // Per RFC 2462.
    BindInfo.lip_pref = TUNNEL_DEFAULT_PREFERENCE;

    BindInfo.lip_token = TunnelCreateToken;
    BindInfo.lip_cvaddr = TunnelConvertAddress;
    BindInfo.lip_setrtrlladdr = NULL;
    BindInfo.lip_transmit = TunnelTransmitND;
    if (DstAddr == INADDR_ANY) {
        BindInfo.lip_mclist = TunnelSetMulticastAddressList;
        BindInfo.lip_rdllopt = TunnelReadLinkLayerAddressOption;
        BindInfo.lip_wrllopt = TunnelWriteLinkLayerAddressOption;
    }
    else {
        BindInfo.lip_mclist = NULL;
        BindInfo.lip_rdllopt = NULL;
        BindInfo.lip_wrllopt = NULL;
    }
    BindInfo.lip_close = TunnelClose;
    BindInfo.lip_cleanup = TunnelCleanup;

    KeWaitForSingleObject(&Tunnel.Mutex, Executive, KernelMode, FALSE, NULL);

    //
    // Open an IPv4 TDI Address Object that is bound
    // to this address. Packets sent with this AO
    // will use this address as the v4 source.
    // If the open fails, we create the interface disconnected.
    //
    TunnelOpenAddress(tc);
    if (tc->AOHandle == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TunnelOpenAddress(%s) failed\n",
                   FormatV4Address(SrcAddr)));
        BindInfo.lip_flags |= IF_FLAG_MEDIA_DISCONNECTED;
    }

    //
    // Check that an equivalent tunnel doesn't already exist.
    //
    for (tcTmp = Tunnel.List.Next;
         tcTmp != &Tunnel.List;
         tcTmp = tcTmp->Next) {

        if ((tcTmp->SrcAddr == SrcAddr) &&
            (tcTmp->DstAddr == DstAddr)) {

            Status = STATUS_ADDRESS_ALREADY_EXISTS;
            goto ErrorReturnUnlock;
        }
    }

    //
    // For 6over4 interfaces, start receiving multicasts.
    //
    if (DstAddr == INADDR_ANY) {
        //
        // Synchronize with TunnelOpenV4.
        //
        if (Tunnel.List.AOHandle != NULL)
            tc->SetMCListOK = TRUE;
    }

    //
    // Create the IPv6 interface.
    // We can hold the mutex across this call, but not a spinlock.
    //
    Status = CreateInterface(&Guid, &BindInfo, (void **)&tc->IF);
    if (! NT_SUCCESS(Status))
        goto ErrorReturnUnlock;

    //
    // Return a reference to the interface, if requested.
    //
    if (ReturnIF != NULL) {
        Interface *IF = tc->IF;
        AddRefIF(IF);
        *ReturnIF = IF;
    }

    //
    // Put this tunnel on our global list.
    // Note that once we unlock, it could be immediately deleted.
    //
    KeAcquireSpinLock(&Tunnel.Lock, &OldIrql);
    TunnelInsertTunnel(tc, &Tunnel.List);
    KeReleaseSpinLock(&Tunnel.Lock, OldIrql);
    KeReleaseMutex(&Tunnel.Mutex, FALSE);

    return STATUS_SUCCESS;

  ErrorReturnUnlock:
    KeReleaseMutex(&Tunnel.Mutex, FALSE);
    if (tc->AOFile != NULL)
        ObDereferenceObject(tc->AOFile);
    if (tc->AOHandle != NULL)
        TunnelCloseAddressObject(tc->AOHandle);
    ExFreePool(tc);
  ErrorReturn:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\tunnel.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Definitions for using IPv4 as a link-layer for IPv6.
//


#ifndef TUNNEL_INCLUDED
#define TUNNEL_INCLUDED 1

//
// A few IPv4 definitions that we need.
// Including the v4 header files causes errors.
// REVIEW: can we fix this?
//

#define INADDR_LOOPBACK 0x0100007f


//
// IP Header format.
//
typedef struct IPHeader {
    uchar iph_verlen;    // Version and length.
    uchar iph_tos;       // Type of service.
    ushort iph_length;   // Total length of datagram.
    ushort iph_id;       // Identification.
    ushort iph_offset;   // Flags and fragment offset.
    uchar iph_ttl;       // Time to live.
    uchar iph_protocol;  // Protocol.
    ushort iph_xsum;     // Header checksum.
    IPAddr iph_src;      // Source address.
    IPAddr iph_dest;     // Destination address.
} IPHeader;

//
// ICMP Header format.
//
typedef struct ICMPHeader {
    uchar ich_type;      // Type of ICMP packet.
    uchar ich_code;      // Subcode of type.
    ushort ich_xsum;     // Checksum of packet.
    ulong ich_param;     // Type-specific parameter field.
} ICMPHeader;

#define ICMP_DEST_UNREACH               3
#define ICMP_SOURCE_QUENCH              4
#define ICMP_TIME_EXCEED                11
#define ICMP_PARAM_PROBLEM              12

#define ICMP_TTL_IN_TRANSIT             0
#define ICMP_TTL_IN_REASSEM             1

#define ICMP_NET_UNREACH                0
#define ICMP_HOST_UNREACH               1
#define ICMP_PROT_UNREACH               2
#define ICMP_PORT_UNREACH               3
#define ICMP_FRAG_NEEDED                4
#define ICMP_SR_FAILED                  5
#define ICMP_DEST_NET_UNKNOWN           6
#define ICMP_DEST_HOST_UNKNOWN          7
#define ICMP_SRC_ISOLATED               8
#define ICMP_DEST_NET_ADMIN             9
#define ICMP_DEST_HOST_ADMIN            10
#define ICMP_NET_UNREACH_TOS            11
#define ICMP_HOST_UNREACH_TOS           12

//
// Tunnel protocol constants.
//
#define WideStr(x) L#x
#define TUNNEL_DEVICE_NAME(proto) (DD_RAW_IP_DEVICE_NAME L"\\" WideStr(proto))
#define TUNNEL_6OVER4_TTL  16

//
// We don't yet support Path MTU Discovery inside a tunnel,
// so we use a single MTU for the tunnel.
// Our buffer size for receiving IPv4 packets must be larger
// than that MTU, because other implementations might use
// a different value for their tunnel MTU.
//
#define TUNNEL_DEFAULT_MTU      IPv6_MINIMUM_MTU
#define TUNNEL_MAX_MTU          (64 * 1024 - sizeof(IPHeader) - 1)
#define TUNNEL_RECEIVE_BUFFER   (64 * 1024)
#define TUNNEL_DEFAULT_PREFERENCE       1

//
// Each tunnel interface (including the pseudo-interface)
// provides a TunnelContext to the IPv6 code as its link-level context.
//
// Each tunnel interface uses a separate v4 TDI address object
// for sending packets. This allows v4 attributes of the packets
// (like source address and TTL) to be controlled individually
// for each tunnel interface.
//
// The pseudo-tunnel interface does not control the v4 source address
// of the packets that it sends; the v4 stack is free to chose
// any v4 address. Note that this means a packet with a v4-compatible
// v6 source address might be sent using a v4 source address
// that is not derived from the v6 source address.
//
// The 6-over-4 and point-to-point virtual interfaces, however,
// do strictly control the v4 source addresses of their packets.
// As "real" interfaces, they participate in Neighbor Discovery
// and their link-level (v4) address is important.
//
// In contrast to sending, the receive path uses a single address object
// for all tunnel interfaces. We use the TDI address object
// associated with the pseudo-interface; because it's bound to INADDR_ANY
// it receives all encapsulated v6 packets sent to the machine.
//

typedef struct TunnelContext {
    struct TunnelContext *Prev, *Next;

    //
    // This DstAddr must follow SrcAddr in memory;
    // see BindInfo.lip_addr initialization.
    //
    IPAddr SrcAddr;     // Our v4 address.
    IPAddr DstAddr;     // Address of the other tunnel endpoint.
                        // (Zero for 6-over-4 tunnels.)
    IPAddr TokenAddr;   // The link-layer address.  Same as
                        // SrcAddr on interfaces except the ISATAP one.

    Interface *IF;      // Holds a reference.

    //
    // This field is effectively locked by IF->WorkerLock.
    //
    int SetMCListOK;    // Can TunnelSetMulticastAddressList proceed?

    //
    // Although we only use AOFile (the pointer version of AOHandle),
    // we must keep AOHandle open so AOFile will work. AOHandle
    // is in the kernel process context, so any open/close operations
    // must be done in the kernel process context.
    //
    PFILE_OBJECT AOFile;
    HANDLE AOHandle;
} TunnelContext;

//
// Information we keep globally.
//
// The spinlock and the mutex are used together to protect
// the chains of tunnel contexts rooted at Tunnel.List and Tunnel.AOList.
// Both must be held to modify a list; either is sufficient for read.
// If both are acquired, the order is mutex first then spinlock.
//
typedef struct TunnelGlobals {
    KSPIN_LOCK Lock;
    KMUTEX Mutex;

    PDEVICE_OBJECT V4Device;            // Does not hold a reference.

    //
    // List.IF is NULL; it is not a context for an interface.
    // But the other fields (particularly AOFile and AOHandle)
    // do store global values.
    //
    TunnelContext List;                 // List of tunnel contexts.

    // Used by TunnelReceive/TunnelReceiveComplete.
    PIRP ReceiveIrp;                    // Protected by Tunnel.Lock.
    TDI_CONNECTION_INFORMATION ReceiveInputInfo;
    TDI_CONNECTION_INFORMATION ReceiveOutputInfo;

    PEPROCESS KernelProcess;            // For later comparisons.
    HANDLE TdiHandle;                   // For unregistering.

    //
    // This is not actually a list of tunnels.
    // We use a list of TunnelContext structures
    // to track mappings from IPv4 address to TDI address object.
    // See TunnelTransmit for more information.
    //
    TunnelContext AOList;               // List of address objects.

    //
    // For receiving ICMPv4 packets.
    //
    PFILE_OBJECT IcmpFile;
    HANDLE IcmpHandle;
} TunnelGlobals;

extern TunnelGlobals Tunnel;

#endif  // TUNNEL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\ip6\subr.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Various subroutines for Internet Protocol Version 6 
//


#include "oscfg.h"
#include "ndis.h"
#include "tdi.h"
#include "tdistat.h"
#include "tdikrnl.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "fragment.h"
#include "icmp.h"
#include "neighbor.h"
#include "route.h"
#include "mld.h"
#include "md5.h"
#include "ntddksec.h"

uint IPv6TickCount = 0;

uint RandomValue = 0;


//* GetSystemRandomBits - Ask the KSecDD driver for a block of 'random' bits.
//
// This routine requests a block of random bits from the KSecDD driver.
// Doing so is not cheap - we only use this routine to provide seed values
// for our other random number generators.
//
int                         // Returns TRUE if successful, FALSE otherwise.
GetSystemRandomBits(
    unsigned char *Buffer,  // Buffer to fill with random data.
    uint Length)            // Length of Buffer in bytes.
{
    UNICODE_STRING DeviceName;
    NTSTATUS NtStatus;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    PIRP pIrp;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT kEvent;

    RtlInitUnicodeString(&DeviceName, DD_KSEC_DEVICE_NAME_U);

    KeInitializeEvent(&kEvent, SynchronizationEvent, FALSE);

    //
    // Get the file and device objects for KDSECDD,
    // acquire a reference to the device-object,
    // release the unneeded reference to the file-object,
    // and build the I/O control request to issue to KSecDD.
    //

    NtStatus = IoGetDeviceObjectPointer(&DeviceName, FILE_ALL_ACCESS,
                                        &FileObject, &DeviceObject);

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "Tcpip6: IoGetDeviceObjectPointer(KSecDD)=%08x\n",
                   NtStatus));
        return FALSE;
    }
    ObReferenceObject(DeviceObject);
    ObDereferenceObject(FileObject);

    pIrp = IoBuildDeviceIoControlRequest(IOCTL_KSEC_RNG,
                                         DeviceObject,
                                         NULL,    // No input buffer.
                                         0,
                                         Buffer,
                                         Length,
                                         FALSE,
                                         &kEvent,
                                         &ioStatusBlock);

    if (pIrp == NULL) {
        ObDereferenceObject(DeviceObject);
        return FALSE;
    }

    //
    // Issue the I/O control request, wait for it to complete
    // if necessary, and release the reference to KSecDD's device-object.
    //
    NtStatus = IoCallDriver(DeviceObject, pIrp);

    if (NtStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&kEvent,
                              Executive,
                              KernelMode,
                              FALSE,       // Not alertable.
                              NULL);       // No timeout.

        NtStatus = ioStatusBlock.Status;
    }
    ObDereferenceObject(DeviceObject);

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "Tcpip6: IoCallDriver IOCTL_KSEC_RNG failed %#x\n", 
                   NtStatus));
        return FALSE;
    }

    return TRUE;
}


//* SeedRandom - Provide a seed value.
//
//  Called to provide a seed value for the random number generator.
//
void
SeedRandom(const uchar *Seed, uint Length)
{
    uint OldValue;
    MD5_CTX Context;
    union {
        uint NewValue;
        uchar Buffer[16];
    } Hash;

    do {
        OldValue = RandomValue;
        MD5Init(&Context);
        MD5Update(&Context, (uchar *)Seed, Length);
        MD5Update(&Context, (uchar *)&OldValue, sizeof OldValue);
        MD5Final(&Context);
        memcpy(Hash.Buffer, Context.digest, MD5DIGESTLEN);
    } while (InterlockedCompareExchange((PLONG)&RandomValue,
                                        (LONG)Hash.NewValue,
                                        (LONG)OldValue) != (LONG)OldValue);
}


//* Random - Generate a pseudo random value between 0 and 2^32 - 1.
//
//  This routine is a quick and dirty psuedo random number generator.
//  It has the advantages of being fast and consuming very little
//  memory (for either code or data).  The random numbers it produces are
//  not of the best quality, however.  A much better generator could be
//  had if we were willing to use an extra 256 bytes of memory for data.
//
//  This routine uses the linear congruential method (see Knuth, Vol II),
//  with specific values for the multiplier and constant taken from
//  Numerical Recipes in C Second Edition by Press, et. al.
//
uint
Random(void)
{
    uint NewValue, OldValue;

    //
    // The algorithm is R = (aR + c) mod m, where R is the random number,
    // a is a magic multiplier, c is a constant, and the modulus m is the
    // maximum number of elements in the period.  We chose our m to be 2^32
    // in order to get the mod operation for free.
    //
    do {
        OldValue = RandomValue;
        NewValue = (1664525 * OldValue) + 1013904223;
    } while (InterlockedCompareExchange((PLONG)&RandomValue,
                                        (LONG)NewValue,
                                        (LONG)OldValue) != (LONG)OldValue);

    return NewValue;
}


//* RandomNumber
//
//  Returns a number randomly selected from a range.
//
uint
RandomNumber(uint Min, uint Max)
{
    uint Number;

    //
    // Note that the high bits of Random() are much more random
    // than the low bits.
    //
    Number = Max - Min; // Spread.
    Number = (uint)(((ULONGLONG)Random() * Number) >> 32); // Randomize spread.
    Number += Min;

    return Number;
}


//* CopyToBufferChain - Copy received packet to NDIS buffer chain.
//
//  Copies from a received packet to an NDIS buffer chain.
//  The received packet data comes in two flavors: if SrcPacket is
//  NULL, then SrcData is used. SrcOffset specifies an offset
//  into SrcPacket or SrcData.
//
//  Length limits the number of bytes copied. The number of bytes
//  copied may also be limited by the destination & source.
//
uint  // Returns: number of bytes copied.
CopyToBufferChain(
    PNDIS_BUFFER DstBuffer,
    uint DstOffset,
    PNDIS_PACKET SrcPacket,
    uint SrcOffset,
    uchar *SrcData,
    uint Length)
{
    PNDIS_BUFFER SrcBuffer = NULL;
    uchar *DstData;
    uint DstSize, SrcSize;
    uint BytesCopied, BytesToCopy;

    //
    // Skip DstOffset bytes in the destination buffer chain.
    // NB: DstBuffer might be NULL to begin with; that's legitimate.
    //
    for (;;) {
        if (DstBuffer == NULL)
            return 0;

        NdisQueryBufferSafe(DstBuffer, &DstData, &DstSize, LowPagePriority);
        if (DstData == NULL) {
            //
            // Couldn't map destination buffer into kernel address space.
            //
            return 0;
        }

        if (DstOffset < DstSize) {
            DstData += DstOffset;
            DstSize -= DstOffset;
            break;
        }

        DstOffset -= DstSize;
        NdisGetNextBuffer(DstBuffer, &DstBuffer);
    }

    if (SrcPacket != NULL) {
        //
        // Skip SrcOffset bytes into SrcPacket.
        // NB: SrcBuffer might be NULL to begin with; that's legitimate.
        //
        NdisQueryPacket(SrcPacket, NULL, NULL, &SrcBuffer, NULL);

        for (;;) {
            if (SrcBuffer == NULL)
                return 0;

            NdisQueryBuffer(SrcBuffer, &SrcData, &SrcSize);

            if (SrcOffset < SrcSize) {
                SrcData += SrcOffset;
                SrcSize -= SrcOffset;
                break;
            }

            SrcOffset -= SrcSize;
            NdisGetNextBuffer(SrcBuffer, &SrcBuffer);
        }
    } else {
        //
        // Using SrcData/SrcOffset instead of SrcPacket/SrcOffset.
        // In this case, we need not initialize SrcBuffer
        // because the copy loop below will never attempt
        // to advance to another SrcBuffer.
        //
        SrcSize = Length;
        SrcData += SrcOffset;
    }

    //
    // Perform the copy, advancing DstBuffer and SrcBuffer as needed.
    // Normally Length is initially non-zero, so no reason
    // to check Length first.
    //
    for (BytesCopied = 0;;) {

        BytesToCopy = MIN(MIN(Length, SrcSize), DstSize);
        RtlCopyMemory(DstData, SrcData, BytesToCopy);
        BytesCopied += BytesToCopy;

        Length -= BytesToCopy;
        if (Length == 0)
            break;  // All done.

        DstData += BytesToCopy;
        DstSize -= BytesToCopy;
        if (DstSize == 0) {
            //
            // We ran out of room in our current destination buffer.
            // Proceed to next buffer on the chain.
            //
            NdisGetNextBuffer(DstBuffer, &DstBuffer);
            if (DstBuffer == NULL)
                break;

            NdisQueryBuffer(DstBuffer, &DstData, &DstSize);
        }

        SrcData += BytesToCopy;
        SrcSize -= BytesToCopy;
        if (SrcSize == 0) {
            //
            // We ran out of data in our current source buffer.
            // Proceed to the next buffer on the chain.
            //
            NdisGetNextBuffer(SrcBuffer, &SrcBuffer);
            if (SrcBuffer == NULL)
                break;

            NdisQueryBuffer(SrcBuffer, &SrcData, &SrcSize);
        }
    }

    return BytesCopied;
}


//* CopyPacketToNdis - Copy from an IPv6Packet chain to an NDIS buffer.
//
//  This is the function we use to copy from a chain of IPv6Packets
//  to ONE NDIS buffer.  The caller specifies the source and
//  destination, a maximum size to copy, and an offset into the first
//  packet to start copying from.  We copy as much as possible up to the
//  size, and return the size copied.
//
//  Note that SrcOffset is relative to the beginning of the first packet in
//  the chain, and NOT the current 'Position' in that packet.
//
//  The source packet chain is not modified in any way by this routine.
//
uint  // Returns: Bytes copied.
CopyPacketToNdis(
    PNDIS_BUFFER DestBuf,  // Destination NDIS buffer chain.
    IPv6Packet *SrcPkt,    // Source packet chain.
    uint Size,             // Size in bytes to copy.
    uint DestOffset,       // Offset into dest buffer to start copying to.
    uint SrcOffset)        // Offset into packet chain to copy from.
{
    uint TotalBytesCopied = 0;  // Bytes we've copied so far.
    uint BytesCopied;           // Bytes copied out of each buffer.
    uint DestSize;              // Space left in destination.
    void *SrcData;              // Current source data pointer.
    uint SrcContig;             // Amount of Contiguous data from SrcData on.
    PNDIS_BUFFER SrcBuf;        // Current buffer in current packet.
    PNDIS_BUFFER TempBuf;       // Used to count through destination chain.
    uint PacketSize;            // Total size of current packet.
    NTSTATUS Status;


    ASSERT(SrcPkt != NULL);

    //
    // The destination buffer can be NULL - this is valid, if odd.
    //
    if (DestBuf == NULL)
        return 0;

    //
    // Limit our copy to the smaller of the requested amount and the
    // available space in the destination buffer chain.
    //
    TempBuf = DestBuf;
    DestSize = 0;

    do {
        DestSize += NdisBufferLength(TempBuf);
        TempBuf = NDIS_BUFFER_LINKAGE(TempBuf);
    } while (TempBuf);

    ASSERT(DestSize >= DestOffset);
    DestSize -= DestOffset;
    DestSize = MIN(DestSize, Size);

    //
    // First, skip SrcOffset bytes into the source packet chain.
    //
    if ((SrcOffset == SrcPkt->Position) && (Size <= SrcPkt->ContigSize)) {
        //
        // One common case is that we want to start from the current Position.
        // REVIEW: This case common enough to be worth this check?
        //
        SrcContig = SrcPkt->ContigSize;
        SrcData = SrcPkt->Data;
        SrcBuf = NULL;
        PacketSize = SrcPkt->TotalSize;
    } else {
        //
        // Otherwise step through packets and buffer regions until
        // we find the desired spot.
        //
        PacketSize = SrcPkt->Position + SrcPkt->TotalSize;
        while (SrcOffset >= PacketSize) {
            // Skip a whole packet.
            SrcOffset -= PacketSize;
            SrcPkt = SrcPkt->Next;
            ASSERT(SrcPkt != NULL);
            PacketSize = SrcPkt->Position + SrcPkt->TotalSize;
        }
        //
        // Found the right packet in the chain, now find desired buffer.
        //
        PacketSize -= SrcOffset;
        if (SrcPkt->NdisPacket == NULL) {
            //
            // This packet must be just a single contiguous region.
            // Finding the right spot is a simple matter of arithmetic.
            //
            SrcContig = PacketSize;
            SrcData = (uchar *)SrcPkt->FlatData + SrcOffset;
            SrcBuf = NULL;
        } else {
            uchar *BufAddr;
            uint BufLen;

            //
            // There may be multiple buffers comprising this packet.
            // Step through them until we arrive at the right spot.
            //
            SrcBuf = NdisFirstBuffer(SrcPkt->NdisPacket);
            NdisQueryBuffer(SrcBuf, &BufAddr, &BufLen);
            while (SrcOffset >= BufLen) {
                // Skip to the next buffer.
                SrcOffset -= BufLen;
                NdisGetNextBuffer(SrcBuf, &SrcBuf);
                ASSERT(SrcBuf != NULL);
                NdisQueryBuffer(SrcBuf, &BufAddr, &BufLen);
            }
            SrcContig = BufLen - SrcOffset;
            SrcData = BufAddr + BufLen - SrcContig;
        }
    }

    //
    // We're now at the point where we wish to start copying.
    //
    while (DestSize != 0) {
        uint BytesToCopy;

        BytesToCopy = MIN(DestSize, SrcContig);
        Status = TdiCopyBufferToMdl(SrcData, 0, BytesToCopy,
                                    DestBuf, DestOffset, (PULONG)&BytesCopied);
        if (!NT_SUCCESS(Status)) {
            break;
        }
        ASSERT(BytesCopied == BytesToCopy);
        TotalBytesCopied += BytesToCopy;

        if (BytesToCopy < DestSize) {
            //
            // Not done yet, we ran out of either source packet or buffer.
            // Get next one and fix up pointers/sizes for the next copy.
            //
            DestOffset += BytesToCopy;
            PacketSize -= BytesToCopy;
            if (PacketSize == 0) {
                // Get next packet on chain.
                SrcPkt = SrcPkt->Next;
                ASSERT(SrcPkt != NULL);
                PacketSize = SrcPkt->Position + SrcPkt->TotalSize;
                if (SrcPkt->NdisPacket == NULL) {
                    // Single contiguous region.
                    SrcData = (uchar *)SrcPkt->FlatData + SrcPkt->Position;
                    SrcContig = SrcPkt->TotalSize;
                } else {
                    // Potentially multiple buffers.
                    SrcBuf = NdisFirstBuffer(SrcPkt->NdisPacket);
                    NdisQueryBuffer(SrcBuf, &SrcData, &SrcContig);
                }
            } else {
                // Get next buffer in packet.
                ASSERT(SrcBuf != NULL);
                NdisGetNextBuffer(SrcBuf, &SrcBuf);
                ASSERT(SrcBuf != NULL);
                NdisQueryBuffer(SrcBuf, &SrcData, &SrcContig);
            }
        }
        DestSize -= BytesToCopy;
    }

    return TotalBytesCopied;
}


//* CopyPacketToFlatOrNdis - Copy from an IPv6Packet chain to a buffer or MDL.
//
//  Called during receive processing to copy from an IPv6Packet chain to a
//  flat buffer or an NDIS_BUFFER.  We skip SrcOffset bytes into the source
//  chain, and then copy Size bytes. If DestPtr is specified, the transfer
//  occurs directly into the virtual address that it specifies. Otherwise,
//  the transfer occurs into the pages described by DestBuf. Either way,
//  DestOffset specifies the offset at which to begin transferring bytes.
//
//  Note that SrcOffset is relative to the beginning of the packet, NOT
//  the current 'Position'.
//
//  The source packet chain is not modified in any way by this routine.
//
void  // Returns: Nothing.
CopyPacketToFlatOrNdis(
    PNDIS_BUFFER DestBuf,  // Destination MDL entry.
    uchar *DestPtr,        // Destination buffer (unstructured memory).
    uint DestOffset,       // Offset in DestBuf to start copying to.
    IPv6Packet *SrcPkt,    // Source packet chain.
    uint Size,             // Size in bytes to copy.
    uint SrcOffset)        // Offset in SrcPkt to start copying from.
{
    uint SrcContig;
    void *SrcData;
    PNDIS_BUFFER SrcBuf;
    uint PacketSize;

#if DBG
    IPv6Packet *TempPkt;
    uint TempSize;
#endif

    ASSERT(DestBuf != NULL || DestPtr != NULL);
    ASSERT(SrcPkt != NULL);

#if DBG
    //
    // In debug versions check to make sure we're copying a reasonable size
    // and from a reasonable offset.
    //
    TempPkt = SrcPkt;
    TempSize = TempPkt->Position + TempPkt->TotalSize;
    TempPkt = TempPkt->Next;
    while (TempPkt != NULL) {
        TempSize += TempPkt->TotalSize;
        TempPkt = TempPkt->Next;
    }

    ASSERT(SrcOffset <= TempSize);
    ASSERT((SrcOffset + Size) <= TempSize);
#endif

    //
    // First, skip SrcOffset bytes into the source packet chain.
    //
    if ((SrcOffset == SrcPkt->Position) && (Size <= SrcPkt->ContigSize)) {
        //
        // One common case is that we want to start from the current Position.
        // REVIEW: This case common enough to be worth this check?
        //
        SrcContig = SrcPkt->ContigSize;
        SrcData = SrcPkt->Data;
        SrcBuf = NULL;
        PacketSize = SrcPkt->TotalSize;
    } else {
        //
        // Otherwise step through packets and buffer regions until
        // we find the desired spot.
        //
        PacketSize = SrcPkt->Position + SrcPkt->TotalSize;
        while (SrcOffset >= PacketSize) {
            // Skip a whole packet.
            SrcOffset -= PacketSize;
            SrcPkt = SrcPkt->Next;
            ASSERT(SrcPkt != NULL);
            PacketSize = SrcPkt->Position + SrcPkt->TotalSize;
        }
        //
        // Found the right packet in the chain, now find desired buffer.
        //
        PacketSize -= SrcOffset;
        if (SrcPkt->NdisPacket == NULL) {
            //
            // This packet must be just a single contiguous region.
            // Finding the right spot is a simple matter of arithmetic.
            //
            SrcContig = PacketSize;
            SrcData = (uchar *)SrcPkt->FlatData + SrcOffset;
            SrcBuf = NULL;
        } else {
            uchar *BufAddr;
            uint BufLen;

            //
            // There may be multiple buffers comprising this packet.
            // Step through them until we arrive at the right spot.
            //
            SrcBuf = NdisFirstBuffer(SrcPkt->NdisPacket);
            NdisQueryBuffer(SrcBuf, &BufAddr, &BufLen);
            while (SrcOffset >= BufLen) {
                // Skip to the next buffer.
                SrcOffset -= BufLen;
                NdisGetNextBuffer(SrcBuf, &SrcBuf);
                ASSERT(SrcBuf != NULL);
                NdisQueryBuffer(SrcBuf, &BufAddr, &BufLen);
            }
            SrcContig = BufLen - SrcOffset;
            SrcData = BufAddr + BufLen - SrcContig;
        }
    }

    //
    // We're now at the point where we wish to start copying.
    //
    while (Size != 0) {
        uint BytesToCopy;

        BytesToCopy = MIN(Size, SrcContig);
        if (DestPtr != NULL) {
            RtlCopyMemory(DestPtr + DestOffset, (uchar *)SrcData, BytesToCopy);
        } else {
            TdiCopyBufferToMdlWithReservedMapping(SrcData, DestBuf, DestOffset,
                                                  BytesToCopy);
        }

        if (BytesToCopy < Size) {
            //
            // Not done yet, we ran out of either source packet or buffer.
            // Get next one and fix up pointers/sizes for the next copy.
            //
            DestOffset += BytesToCopy;
            PacketSize -= BytesToCopy;
            if (PacketSize == 0) {
                // Get next packet on chain.
                SrcPkt = SrcPkt->Next;
                ASSERT(SrcPkt != NULL);
                PacketSize = SrcPkt->Position + SrcPkt->TotalSize;
                if (SrcPkt->NdisPacket == NULL) {
                    // Single contiguous region.
                    SrcData = (uchar *)SrcPkt->FlatData + SrcPkt->Position;
                    SrcContig = SrcPkt->TotalSize;
                } else {
                    // Potentially multiple buffers.
                    SrcBuf = NdisFirstBuffer(SrcPkt->NdisPacket);
                    NdisQueryBuffer(SrcBuf, &SrcData, &SrcContig);
                }
            } else {
                // Get next buffer in packet.
                ASSERT(SrcBuf != NULL);
                NdisGetNextBuffer(SrcBuf, &SrcBuf);
                ASSERT(SrcBuf != NULL);
                NdisQueryBuffer(SrcBuf, &SrcData, &SrcContig);
            }
        }
        Size -= BytesToCopy;
    }
}

//* CopyToNdisSafe - Copy a flat buffer to an NDIS_BUFFER chain.
//
//  A utility function to copy a flat buffer to an NDIS buffer chain. We
//  assume that the NDIS_BUFFER chain is big enough to hold the copy amount;
//  in a debug build we'll assert if this isn't true. We return a pointer
//  to the buffer where we stopped copying, and an offset into that buffer.
//  This is useful for copying in pieces into the chain.
//
//  Input:  DestBuf     - Destination NDIS_BUFFER chain.
//          pNextBuf    - Pointer to next buffer in chain to copy into.
//          SrcBuf      - Src flat buffer.
//          Size        - Size in bytes to copy.
//          StartOffset - Pointer to start of offset into first buffer in
//                          chain. Filled in on return with the offset to
//                          copy into next.
//
//  Returns: TRUE  - Successfully copied flat buffer into NDIS_BUFFER chain.
//           FALSE - Failed to copy entire flat buffer.
//
int
CopyToNdisSafe(PNDIS_BUFFER DestBuf, PNDIS_BUFFER * ppNextBuf,
               uchar * SrcBuf, uint Size, uint * StartOffset)
{
    uint CopySize;
    uchar *DestPtr;
    uint DestSize;
    uint Offset = *StartOffset;
    uchar *VirtualAddress;
    uint Length;

    ASSERT(DestBuf != NULL);
    ASSERT(SrcBuf != NULL);

    NdisQueryBufferSafe(DestBuf, &VirtualAddress, &Length,
                        LowPagePriority);
    if (VirtualAddress == NULL)
        return FALSE;

    ASSERT(Length >= Offset);
    DestPtr = VirtualAddress + Offset;
    DestSize = Length - Offset;

    for (;;) {
        CopySize = MIN(Size, DestSize);
        RtlCopyMemory(DestPtr, SrcBuf, CopySize);

        DestPtr += CopySize;
        SrcBuf += CopySize;

        if ((Size -= CopySize) == 0)
            break;

        if ((DestSize -= CopySize) == 0) {
            DestBuf = NDIS_BUFFER_LINKAGE(DestBuf);
            ASSERT(DestBuf != NULL);

            NdisQueryBufferSafe(DestBuf, &VirtualAddress, &Length,
                                LowPagePriority);
            if (VirtualAddress == NULL)
                return FALSE;

            DestPtr = VirtualAddress;
            DestSize = Length;
        }
    }

    *StartOffset = (uint) (DestPtr - VirtualAddress);

    if (ppNextBuf)
        *ppNextBuf = DestBuf;
    return TRUE;
}


//* CopyFlatToNdis - Copy a flat buffer to an NDIS_BUFFER chain.
//
//  A utility function to copy a flat buffer to an NDIS buffer chain.  We
//  assume that the NDIS_BUFFER chain is big enough to hold the copy amount;
//  in a debug build we'll debugcheck if this isn't true.  We return a pointer
//  to the buffer where we stopped copying, and an offset into that buffer.
//  This is useful for copying in pieces into the chain.
//
PNDIS_BUFFER  // Returns: Pointer to next buffer in chain to copy into.
CopyFlatToNdis(
    PNDIS_BUFFER DestBuf,  // Destination NDIS buffer chain.
    uchar *SrcBuf,         // Source buffer (unstructured memory).
    uint Size,             // Size in bytes to copy.
    uint *StartOffset,     // Pointer to Offset info first buffer in chain.
                           // Filled on return with offset to copy into next.
    uint *BytesCopied)     // Location into which to return # of bytes copied.
{
    NTSTATUS Status = 0;

    *BytesCopied = 0;

    Status = TdiCopyBufferToMdl(SrcBuf, 0, Size, DestBuf, *StartOffset,
                                (PULONG)BytesCopied);

    *StartOffset += *BytesCopied;

    //
    // Always return the first buffer, since the TdiCopy function handles
    // finding the appropriate buffer based on offset.
    //
    return(DestBuf);
}


//* CopyNdisToFlat - Copy an NDIS_BUFFER chain to a flat buffer.
//
//  Copy (a portion of) an NDIS buffer chain to a flat buffer.
//
//  Returns TRUE if the copy succeeded and FALSE if it failed
//  because an NDIS buffer could not be mapped. If the copy succeeded,
//  returns the Next buffer/offset, for subsequent calls.
//
int
CopyNdisToFlat(
    void *DstData,
    PNDIS_BUFFER SrcBuffer,
    uint SrcOffset,
    uint Length,
    PNDIS_BUFFER *NextBuffer,
    uint *NextOffset)
{
    void *SrcData;
    uint SrcSize;
    uint Bytes;

    for (;;) {
        NdisQueryBufferSafe(SrcBuffer, &SrcData, &SrcSize, LowPagePriority);
        if (SrcSize < SrcOffset) {
            SrcOffset -= SrcSize;
            NdisGetNextBuffer(SrcBuffer, &SrcBuffer);
            continue;
        }

        if (SrcData == NULL)
            return FALSE;

        Bytes = SrcSize - SrcOffset;
        if (Bytes > Length)
            Bytes = Length;

        RtlCopyMemory(DstData, (uchar *)SrcData + SrcOffset, Bytes);

        (uchar *)DstData += Bytes;
        SrcOffset += Bytes;
        Length -= Bytes;

        if (Length == 0)
            break;

        NdisGetNextBuffer(SrcBuffer, &SrcBuffer);
        SrcOffset = 0;
    }

    *NextBuffer = SrcBuffer;
    *NextOffset = SrcOffset;
    return TRUE;
}


//
// Checksum support.
// On NT, there are architecture-specific assembly routines for the core
// calculation.
//

//* ChecksumPacket - Calculate the Internet checksum of a packet.
//
//  Calculates the checksum of packet data. The data may be supplied
//  either with the Packet/Offset arguments, or (if Packet is NULL)
//  the Data/Offset arguments. In either case, Length specifies how much
//  data to checksum.
//
//  The Packet is assumed to contain (at least) Offset + Length bytes.
//
//  Also calculates and adds-in the pseudo-header checksum,
//  using Source, Dest, Length, and NextHeader.
//
//  Returns 0 for failure, when an NDIS buffer can not be mapped
//  into kernel address space due to resource shortages.
//
ushort
ChecksumPacket(
    PNDIS_PACKET Packet,    // Packet with data to checksum.
    uint Offset,            // Offset into packet where data starts.
    uchar *Data,            // If Packet is NULL, data to checksum.
    uint Length,            // Length of packet data.
    const IPv6Addr *Source, // Source address.
    const IPv6Addr *Dest,   // Destination address.
    uchar NextHeader)       // Protocol type for pseudo-header.
{
    PNDIS_BUFFER Buffer = NULL;
    uint Checksum;
    uint PayloadLength;
    uint Size;
    uint TotalSummed;

    //
    // Start with the pseudo-header.
    //
    Checksum = Cksum(Source, sizeof *Source) + Cksum(Dest, sizeof *Dest);
    PayloadLength = net_long(Length);
    Checksum += (PayloadLength >> 16) + (PayloadLength & 0xffff);
    Checksum += (NextHeader << 8);

    if (Packet == NULL) {
        //
        // We do not have to initialize Buffer.
        // The checksum loop below will exit before trying to use it.
        //
        Size = Length;
        Data += Offset;
    } else {
        //
        // Skip over Offset bytes in the packet.
        //

        Buffer = NdisFirstBuffer(Packet);
        for (;;) {
            Size = NdisBufferLength(Buffer);

            //
            // There is a boundary case here: the Packet contains
            // exactly Offset bytes total, and Length is zero.
            // Checking Offset <= Size instead of Offset < Size
            // makes this work.
            //
            if (Offset <= Size) {
                Data = NdisBufferVirtualAddressSafe(Buffer, LowPagePriority);
                if (Data == NULL)
                    return 0;

                Data += Offset;
                Size -= Offset;
                break;
            }

            Offset -= Size;
            NdisGetNextBuffer(Buffer, &Buffer);
            ASSERT(Buffer != NULL); // Caller ensures this.
        }
    }
    for (TotalSummed = 0;;) {
        ushort Temp;

        //
        // Size might be bigger than we need,
        // if there is "extra" data in the packet.
        //
        if (Size > Length)
            Size = Length;

        Temp = Cksum(Data, Size);
        if (TotalSummed & 1) {
            // We're at an odd offset into the logical buffer,
            // so we need to swap the bytes that Cksum returns.
            Checksum += (Temp >> 8) + ((Temp & 0xff) << 8);
        } else {
            Checksum += Temp;
        }
        TotalSummed += Size;

        Length -= Size;
        if (Length == 0)
            break;
        // Buffer is always initialized if we reach here.
        NdisGetNextBuffer(Buffer, &Buffer);
        NdisQueryBufferSafe(Buffer, &Data, &Size, LowPagePriority);
        if (Data == NULL)
            return 0;
    }

    //
    // Wrap in the carries to reduce Checksum to 16 bits.
    // (Twice is sufficient because it can only overflow once.)
    //
    Checksum = (Checksum >> 16) + (Checksum & 0xffff);
    Checksum += (Checksum >> 16);

    //
    // Take ones-complement and replace 0 with 0xffff.
    //
    Checksum = (ushort) ~Checksum;
    if (Checksum == 0)
        Checksum = 0xffff;

    return (ushort) Checksum;
}

//* ConvertSecondsToTicks
//
//  Convert seconds to timer ticks.
//  A value of INFINITE_LIFETIME (0xffffffff) indicates infinity,
//  for both ticks and seconds.
//
uint
ConvertSecondsToTicks(uint Seconds)
{
    uint Ticks;

    Ticks = Seconds * IPv6_TICKS_SECOND;
    if (Ticks / IPv6_TICKS_SECOND != Seconds)
        Ticks = INFINITE_LIFETIME; // Overflow.

    return Ticks;
}

//* ConvertTicksToSeconds
//
//  Convert timer ticks to seconds.
//  A value of INFINITE_LIFETIME (0xffffffff) indicates infinity,
//  for both ticks and seconds.
//
uint
ConvertTicksToSeconds(uint Ticks)
{
    uint Seconds;

    if (Ticks == INFINITE_LIFETIME)
        Seconds = INFINITE_LIFETIME;
    else
        Seconds = Ticks / IPv6_TICKS_SECOND;

    return Seconds;
}

//* ConvertMillisToTicks
//
//  Convert milliseconds to timer ticks.
//
uint
ConvertMillisToTicks(uint Millis)
{
    uint Ticks;

    //
    // Use 64-bit arithmetic to guard against intermediate overlow.
    //
    Ticks = (uint) (((unsigned __int64) Millis * IPv6_TICKS_SECOND) / 1000);

    //
    // If the number of millis is non-zero,
    // then have at least one tick.
    //
    if (Ticks == 0 && Millis != 0)
        Ticks = 1;

    return Ticks;
}

//* IPv6Timeout - Perform various housekeeping duties periodically.
//
//  Neighbor discovery, fragment reassembly, ICMP ping, etc. all have
//  time-dependent parts.  Check for timer expiration here.
//
void
IPv6Timeout(
    PKDPC MyDpcObject,  // The DPC object describing this routine.
    void *Context,      // The argument we asked to be called with.
    void *Unused1,
    void *Unused2)
{
    UNREFERENCED_PARAMETER(MyDpcObject);
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Unused1);
    UNREFERENCED_PARAMETER(Unused2);

    //
    // Atomically increment our tick count.
    //
    InterlockedIncrement((LONG *)&IPv6TickCount);

    // 
    // Process all multicast groups with timers running.  Timers are used to
    // response to membership queries sent to us by the first-hop router.
    //
    // We call MLDTimeout *before* InterfaceTimeout and NetTableTimeout.
    // so that when an interface is first created and a link-local address
    // is assigned, the initial MLD Report for the solicited-node multicast
    // address gets sent *before* the Neighbor Solicit for DAD.
    // Similarly, we join the all-routers link-local multicast group
    // before sending our first RA from an advertising interface.
    //
    if (QueryList != NULL)
        MLDTimeout();

    //
    // Handle per-interface timeouts.
    //
    InterfaceTimeout();

    //
    // Handle per-NTE timeouts.
    //
    NetTableTimeout();

    //
    // Handle routing table timeouts.
    //
    RouteTableTimeout();

    //
    // If there's a possibility we have one or more outstanding echo requests,
    // call out to ICMPv6 to handle them.  Note that since we don't grab the
    // lock here, there may be none by the time we get there.  This just saves
    // us from always having to call out.
    //
    if (ICMPv6OutstandingEchos != NULL) {
        //
        // Echo requests outstanding.
        //
        ICMPv6EchoTimeout();
    }

    //
    // If we might have active reassembly records,
    // call out to handle timeout processing for them.
    //
    if (ReassemblyList.First != SentinelReassembly) {
        ReassemblyTimeout();
    }

    //
    // Check for expired binding cache entries.
    //
    if (BindingCache.First != SentinelBCE)
        BindingCacheTimeout();

    //
    // Check for expired site prefixes.
    //
    if (SitePrefixTable != NULL)
        SitePrefixTimeout();
}

//* AdjustPacketBuffer
//
//  Takes an NDIS Packet that has some spare bytes available
//  at the beginning and adjusts the size of that available space.
//
//  When we allocate packets, we often do not know a priori on which
//  link the packets will go out.  However it is much more efficient
//  to allocate space for the link-level header along with the rest
//  of the packet.  Hence we leave space for the maximum link-level header,
//  and each individual link layer uses AdjustPacketBuffer to shrink
//  that space to the size that it really needs.
//
//  AdjustPacketBuffer is needed because the sending calls (in both
//  the NDIS and TDI interfaces) do not allow the caller to specify
//  an offset of data to skip over.
//
//  Note that this code is NT-specific, because it knows about the
//  internal fields of NDIS_BUFFER structures.
//
void *
AdjustPacketBuffer(
    PNDIS_PACKET Packet,  // Packet to adjust.
    uint SpaceAvailable,  // Extra space available at start of first buffer.
    uint SpaceNeeded)     // Amount of space we need for the header.
{
    PMDL Buffer;
    uint Adjust;

    // Get first buffer on packet chain.
    NdisQueryPacket(Packet, NULL, NULL, &Buffer, NULL);

    //
    // The remaining space in the packet should all be in the first buffer.
    //
    ASSERT(SpaceAvailable <= Buffer->ByteCount);

    Adjust = SpaceAvailable - SpaceNeeded;
    if (Adjust == 0) {
        //
        // There is exactly the right amount of space left.
        // This is the common case.
        //
    } else if ((int)Adjust > 0) {
        //
        // There is too much space left.
        // Because NdisSend doesn't have an Offset argument,
        // we need to temporarily "shrink" the buffer.
        //
        (uchar *)Buffer->MappedSystemVa += Adjust;
        Buffer->ByteCount -= Adjust;
        Buffer->ByteOffset += Adjust;

        if (Buffer->ByteOffset >= PAGE_SIZE) {
            PFN_NUMBER FirstPage;

            //
            // Need to "remove" the first physical page
            // by shifting the array up one page.
            // Save it at the end of the array.
            //
            FirstPage = ((PPFN_NUMBER)(Buffer + 1))[0];
            RtlMoveMemory(&((PPFN_NUMBER)(Buffer + 1))[0],
                          &((PPFN_NUMBER)(Buffer + 1))[1],
                          Buffer->Size - sizeof *Buffer - sizeof(PFN_NUMBER));
            ((PPFN_NUMBER)((uchar *)Buffer + Buffer->Size))[-1] = FirstPage;

            (uchar *)Buffer->StartVa += PAGE_SIZE;
            Buffer->ByteOffset -= PAGE_SIZE;
        }
    } else { // Adjust < 0
        //
        // Not enough space.
        // Shouldn't happen in the normal send path.
        // REVIEW: This is a potential problem when forwarding packets
        // from an interface with a short link-level header
        // to an interface with a longer link-level header.
        // Should the forwarding code take care of this?
        //
        ABORTMSG("AdjustPacketBuffer: Adjust < 0");
    }

    //
    // Save away the adjustment for the completion callback,
    // which needs to undo our work with UndoAdjustPacketBuffer.
    //
    PC(Packet)->pc_adjust = Adjust;

    //
    // Return a pointer to the buffer.
    //
    return Buffer->MappedSystemVa;
}

//* UndoAdjustPacketBuffer
//
//  Undo the effects of AdjustPacketBuffer.
//
//  Note that this code is NT-specific, because it knows about the
//  internal fields of NDIS_BUFFER structures.
//
void
UndoAdjustPacketBuffer(
    PNDIS_PACKET Packet)  // Packet we may or may not have previously adjusted.
{
    uint Adjust;

    Adjust = PC(Packet)->pc_adjust;
    if (Adjust != 0) {
        PMDL Buffer;

        //
        // We need to undo the adjustment made in AdjustPacketBuffer.
        // This may including shifting the array of page info.
        //

        // Get first buffer on packet chain.
        NdisQueryPacket(Packet, NULL, NULL, &Buffer, NULL);

        if (Buffer->ByteOffset < Adjust) {
            PFN_NUMBER FirstPage;

            (uchar *)Buffer->StartVa -= PAGE_SIZE;
            Buffer->ByteOffset += PAGE_SIZE;

            FirstPage = ((PPFN_NUMBER)((uchar *)Buffer + Buffer->Size))[-1];
            RtlMoveMemory(&((PPFN_NUMBER)(Buffer + 1))[1],
                          &((PPFN_NUMBER)(Buffer + 1))[0],
                          Buffer->Size - sizeof *Buffer - sizeof(PFN_NUMBER));
            ((PPFN_NUMBER)(Buffer + 1))[0] = FirstPage;
        }

        (uchar *)Buffer->MappedSystemVa -= Adjust;
        Buffer->ByteCount += Adjust;
        Buffer->ByteOffset -= Adjust;
    }
}

//* CreateSolicitedNodeMulticastAddress
//
//  Given a unicast or anycast address, creates the corresponding
//  solicited-node multicast address.
//
void
CreateSolicitedNodeMulticastAddress(
    const IPv6Addr *Addr,
    IPv6Addr *MCastAddr)
{
    RtlZeroMemory(MCastAddr, sizeof *MCastAddr);
    MCastAddr->s6_bytes[0] = 0xff;
    MCastAddr->s6_bytes[1] = ADE_LINK_LOCAL;
    MCastAddr->s6_bytes[11] = 0x01;
    MCastAddr->s6_bytes[12] = 0xff;
    MCastAddr->s6_bytes[13] = Addr->s6_bytes[13];
    MCastAddr->s6_bytes[14] = Addr->s6_bytes[14];
    MCastAddr->s6_bytes[15] = Addr->s6_bytes[15];
}

//* IP6_ADDR_LTEQ
//
//  Is the first address <= the second address,
//  in a lexicographic ordering?
//
int
IP6_ADDR_LTEQ(const IPv6Addr *A, const IPv6Addr *B)
{
    uint i;

    for (i = 0; i < 16; i++) {
        if (A->s6_bytes[i] < B->s6_bytes[i])
            return TRUE;
        else if (A->s6_bytes[i] > B->s6_bytes[i])
            return FALSE;
    }

    return TRUE; // They are equal.
}

//* IsV4Compatible
//
//  Is this a v4-compatible address?
//
//  Note that the upper 8 bits of an IPv4 address are not allowed
//  to be zero.  If all 104 upper bits of an IPv6 address are zero,
//  it's potentially a valid native IPv6 address (e.g. loopback),
//  NOT a v4-compatible address.
//
int
IsV4Compatible(const IPv6Addr *Addr)
{
    return ((Addr->s6_words[0] == 0) &&
            (Addr->s6_words[1] == 0) &&
            (Addr->s6_words[2] == 0) &&
            (Addr->s6_words[3] == 0) &&
            (Addr->s6_words[4] == 0) &&
            (Addr->s6_words[5] == 0) &&
            (Addr->s6_bytes[12] != 0));
}

//* CreateV4Compatible
//
//  Create a v4-compatible address.
//
void
CreateV4Compatible(IPv6Addr *Addr, IPAddr V4Addr)
{
    Addr->s6_words[0] = 0;
    Addr->s6_words[1] = 0;
    Addr->s6_words[2] = 0;
    Addr->s6_words[3] = 0;
    Addr->s6_words[4] = 0;
    Addr->s6_words[5] = 0;
    * (IPAddr UNALIGNED *) &Addr->s6_words[6] = V4Addr;
}

//* IsV4Mapped
//
//  Is this a v4-mapped address?
//
int
IsV4Mapped(const IPv6Addr *Addr)
{
    return ((Addr->s6_words[0] == 0) &&
            (Addr->s6_words[1] == 0) &&
            (Addr->s6_words[2] == 0) &&
            (Addr->s6_words[3] == 0) &&
            (Addr->s6_words[4] == 0) &&
            (Addr->s6_words[5] == 0xffff));
}

//* CreateV4Mapped
//
//  Create a v4-mapped address.
//
void
CreateV4Mapped(IPv6Addr *Addr, IPAddr V4Addr)
{
    Addr->s6_words[0] = 0;
    Addr->s6_words[1] = 0;
    Addr->s6_words[2] = 0;
    Addr->s6_words[3] = 0;
    Addr->s6_words[4] = 0;
    Addr->s6_words[5] = 0xffff;
    * (IPAddr UNALIGNED *) &Addr->s6_words[6] = V4Addr;
}

//* IsSolicitedNodeMulticast
//
//  Is this a solicited-node multicast address?
//  Checks very strictly for the proper format.
//  For example scope values smaller than 2 are not allowed.
//
int
IsSolicitedNodeMulticast(const IPv6Addr *Addr)
{
    return ((Addr->s6_bytes[0] == 0xff) &&
            (Addr->s6_bytes[1] == ADE_LINK_LOCAL) &&
            (Addr->s6_words[1] == 0) &&
            (Addr->s6_words[2] == 0) &&
            (Addr->s6_words[3] == 0) &&
            (Addr->s6_words[4] == 0) &&
            (Addr->s6_bytes[10] == 0) &&
            (Addr->s6_bytes[11] == 0x01) &&
            (Addr->s6_bytes[12] == 0xff));
}

//* IsEUI64Address
//
//  Does the address have a format prefix
//  that indicates it uses EUI-64 interface identifiers?
//
int
IsEUI64Address(const IPv6Addr *Addr)
{
    //
    // Format prefixes 001 through 111, except for multicast.
    //
    return (((Addr->s6_bytes[0] & 0xe0) != 0) &&
            !IsMulticast(Addr));
}

//* IsSubnetRouterAnycast
//
//  Is this the subnet router anycast address?
//  See RFC 2373.
//
int
IsSubnetRouterAnycast(const IPv6Addr *Addr)
{
    return (IsEUI64Address(Addr) &&
            (Addr->s6_words[4] == 0) &&
            (Addr->s6_words[5] == 0) &&
            (Addr->s6_words[6] == 0) &&
            (Addr->s6_words[7] == 0));
}

//* IsSubnetReservedAnycast
//
//  Is this a subnet reserved anycast address?
//  See RFC 2526. It talks about non-EUI-64
//  addresses as well, but IMHO that part
//  of the RFC doesn't make sense. For example,
//  it shouldn't apply to multicast or v4-compatible
//  addresses.
//
int
IsSubnetReservedAnycast(const IPv6Addr *Addr)
{
    return (IsEUI64Address(Addr) &&
            (Addr->s6_words[4] == 0xfffd) &&
            (Addr->s6_words[5] == 0xffff) &&
            (Addr->s6_words[6] == 0xffff) &&
            ((Addr->s6_words[7] & 0x80ff) == 0x80ff));
}

//* IsKnownAnycast
//
//  As best we can tell from simple inspection,
//  is this an anycast address?
//
int
IsKnownAnycast(const IPv6Addr *Addr)
{
    return IsSubnetRouterAnycast(Addr) || IsSubnetReservedAnycast(Addr);
}

//* IsInvalidSourceAddress
//
//  Is this address illegal to use as a source address?
//  We currently flag IPv6 multicast, and embedded IPv4 multicast,
//  broadcast, loopback and unspecified as invalid.
//
//  Note that this function doesn't attempt to identify anycast addresses
//  in order to flag them as invalid.  Whether or not to allow them to
//  be valid source addresses has been a matter of some debate in the
//  working group.  We let them pass since we can't tell them all by
//  inspection and we don't see any real problems with accepting them.
//
int
IsInvalidSourceAddress(const IPv6Addr *Addr)
{
    IPAddr V4Addr;

    if (IsMulticast(Addr))
        return TRUE;

    if (IsISATAP(Addr) ||                          // ISATAP
        (((Addr->s6_words[0] == 0) && (Addr->s6_words[1] == 0) &&
          (Addr->s6_words[2] == 0) && (Addr->s6_words[3] == 0)) &&
         ((Addr->s6_words[4] == 0) && (Addr->s6_words[5] == 0) &&
          ((Addr->s6_words[6] & 0x00ff) != 0)) ||  // v4-compatible
         ((Addr->s6_words[4] == 0) &&
          (Addr->s6_words[5] == 0xffff)) ||        // v4-mapped
         ((Addr->s6_words[4] == 0xffff) &&
          (Addr->s6_words[5] == 0)))) {            // v4-translated

        V4Addr = ExtractV4Address(Addr);

    } else if (Is6to4(Addr)) {

        V4Addr = Extract6to4Address(Addr);

    } else {        
        //
        // It's not an IPv6 multicast address, nor does it contain
        // an embedded IPv4 address of some sort, so don't consider
        // it invalid.
        //
        return FALSE;
    }

    //
    // Check embedded IPv4 address for invalid types.
    //
    return (IsV4Multicast(V4Addr) || IsV4Broadcast(V4Addr) ||
            IsV4Loopback(V4Addr) || IsV4Unspecified(V4Addr));
}

//* IsNotManualAddress
//
//  Should this address NOT be manually assigned as an address?
//
int
IsNotManualAddress(const IPv6Addr *Addr)
{
    return (IsMulticast(Addr) ||
            IsUnspecified(Addr) ||
            IsLoopback(Addr) ||
            (IsV4Compatible(Addr) &&
             (V4AddressScope(ExtractV4Address(Addr)) != ADE_GLOBAL)) ||
            (Is6to4(Addr) &&
             (V4AddressScope(Extract6to4Address(Addr)) != ADE_GLOBAL)));
}

//* V4AddressScope
//
//  Determines the scope of an IPv4 address.
//  See RFC 1918.
//
ushort
V4AddressScope(IPAddr Addr)
{
    if ((Addr & 0x0000FFFF) == 0x0000FEA9) // 169.254/16 - auto-configured
        return ADE_LINK_LOCAL;
    else if ((Addr & 0x000000FF) == 0x0000000A) // 10/8 - private
        return ADE_SITE_LOCAL;
    else if ((Addr & 0x0000F0FF) == 0x000010AC) // 172.16/12 - private
        return ADE_SITE_LOCAL;
    else if ((Addr & 0x0000FFFF) == 0x0000A8C0) // 192.168/16 - private
        return ADE_SITE_LOCAL;
    else if ((Addr & 0x000000FF) == 0x0000007F) // 127/8 - loopback
        return ADE_LINK_LOCAL;
    else
        return ADE_GLOBAL;
}

//* UnicastAddressScope
//
//  Examines a unicast address and determines its scope.
//
//  Note that v4-compatible and 6to4 addresses
//  are deemed to have global scope. They should
//  not be derived from RFC 1918 IPv4 addresses.
//  But even if they are, we will treat the IPv6
//  addresses as global.
//
ushort
UnicastAddressScope(const IPv6Addr *Addr)
{
    if (IsLinkLocal(Addr))
        return ADE_LINK_LOCAL;
    else if (IsSiteLocal(Addr))
        return ADE_SITE_LOCAL;
    else if (IsLoopback(Addr))
        return ADE_LINK_LOCAL;
    else
        return ADE_GLOBAL;
}

//* AddressScope
//
//  Examines an address and determines its scope.
//
ushort
AddressScope(const IPv6Addr *Addr)
{
    if (IsMulticast(Addr))
        return MulticastAddressScope(Addr);
    else
        return UnicastAddressScope(Addr);
}

//* DetermineScopeId
//
//  Given an address and an associated interface, determine
//  the appropriate value for the scope identifier.
//
//  DetermineScopeId calculates a "user-level" ScopeId,
//  meaning that loopback and global addresses
//  get special treatment. Therefore, DetermineScopeId
//  is not appropriate for general network-layer use.
//  See also RouteToDestination and FindNetworkWithAddress.
//
//  Returns the ScopeId.
//
uint
DetermineScopeId(const IPv6Addr *Addr, Interface *IF)
{
    ushort Scope;

    if (IsLoopback(Addr) && (IF == LoopInterface))
        return 0;

    Scope = AddressScope(Addr);
    if (Scope == ADE_GLOBAL)
        return 0;

    return IF->ZoneIndices[Scope];
}

//* HasPrefix - Does an address have the given prefix?
//
int
HasPrefix(const IPv6Addr *Addr, const IPv6Addr *Prefix, uint PrefixLength)
{
    const uchar *AddrBytes = Addr->s6_bytes;
    const uchar *PrefixBytes = Prefix->s6_bytes;

    //
    // Check that initial integral bytes match.
    //
    while (PrefixLength > 8) {
        if (*AddrBytes++ != *PrefixBytes++)
            return FALSE;
        PrefixLength -= 8;
    }

    //
    // Check any remaining bits.
    // Note that if PrefixLength is zero now, we should not
    // dereference AddrBytes/PrefixBytes.
    //
    if ((PrefixLength > 0) &&
        ((*AddrBytes >> (8 - PrefixLength)) !=
         (*PrefixBytes >> (8 - PrefixLength))))
        return FALSE;

    return TRUE;
}

//* CopyPrefix
//
//  Copy an address prefix, zeroing the remaining bits
//  in the destination address.
//
void
CopyPrefix(IPv6Addr *Addr, const IPv6Addr *Prefix, uint PrefixLength)
{
    uint PLBytes, PLRemainderBits, Loop;

    PLBytes = PrefixLength / 8;
    PLRemainderBits = PrefixLength % 8;
    for (Loop = 0; Loop < sizeof(IPv6Addr); Loop++) {
        if (Loop < PLBytes)
            Addr->s6_bytes[Loop] = Prefix->s6_bytes[Loop];
        else
            Addr->s6_bytes[Loop] = 0;
    }
    if (PLRemainderBits) {
        Addr->s6_bytes[PLBytes] = (UCHAR)(Prefix->s6_bytes[PLBytes] &
            (0xff << (8 - PLRemainderBits)));
    }
}

//* CommonPrefixLength
//
//  Calculate the length of the longest prefix common
//  to the two addresses.
//
uint
CommonPrefixLength(const IPv6Addr *Addr, const IPv6Addr *Addr2)
{
    int i, j;

    //
    // Find first non-matching byte.
    //
    for (i = 0; ; i++) {
        if (i == sizeof(IPv6Addr))
            return 8 * i;

        if (Addr->s6_bytes[i] != Addr2->s6_bytes[i])
            break;
    }

    //
    // Find first non-matching bit (there must be one).
    //
    for (j = 0; ; j++) {
        uint Mask = 1 << (7 - j);

        if ((Addr->s6_bytes[i] & Mask) != (Addr2->s6_bytes[i] & Mask))
            break;
    }

    return 8 * i + j;
}

//* IntersectPrefix
//
//  Do the two prefixes overlap?
//
int
IntersectPrefix(const IPv6Addr *Prefix1, uint Prefix1Length,
                const IPv6Addr *Prefix2, uint Prefix2Length)
{
    return HasPrefix(Prefix1, Prefix2, MIN(Prefix1Length, Prefix2Length));
}

//* MapNdisBuffers
//
//  Maps the NDIS buffer chain into the kernel address space.
//  Returns FALSE upon failure.
//
int
MapNdisBuffers(NDIS_BUFFER *Buffer)
{
    uchar *Data;

    while (Buffer != NULL) {
        Data = NdisBufferVirtualAddressSafe(Buffer, LowPagePriority);
        if (Data == NULL)
            return FALSE;

        NdisGetNextBuffer(Buffer, &Buffer);
    }

    return TRUE;
}

//* GetDataFromNdis
//
//  Retrieves data from an NDIS buffer chain.
//  If the desired data is contiguous, then just returns
//  a pointer directly to the data in the buffer chain.
//  Otherwise the data is copied to the supplied buffer
//  and returns a pointer to the supplied buffer.
//
//  Returns NULL only if the desired data (offset/size)
//  does not exist in the NDIS buffer chain of
//  if DataBuffer is NULL and the data is not contiguous.
//
uchar *
GetDataFromNdis(
    NDIS_BUFFER *SrcBuffer,
    uint SrcOffset,
    uint Length,
    uchar *DataBuffer)
{
    void *DstData;
    void *SrcData;
    uint SrcSize;
    uint Bytes;

    //
    // Look through the buffer chain
    // for the beginning of the desired data.
    //
    for (;;) {
        if (SrcBuffer == NULL)
            return NULL;

        NdisQueryBuffer(SrcBuffer, &SrcData, &SrcSize);
        if (SrcOffset < SrcSize)
            break;

        SrcOffset -= SrcSize;
        NdisGetNextBuffer(SrcBuffer, &SrcBuffer);
    }

    //
    // If the desired data is contiguous,
    // then just return a pointer to it.
    //
    if (SrcOffset + Length <= SrcSize)
        return (uchar *)SrcData + SrcOffset;

    //
    // If our caller did not specify a buffer,
    // then we must fail.
    //
    if (DataBuffer == NULL)
        return NULL;

    //
    // Copy the desired data to the caller's buffer,
    // and return a pointer to the caller's buffer.
    //
    DstData = DataBuffer;
    for (;;) {
        Bytes = SrcSize - SrcOffset;
        if (Bytes > Length)
            Bytes = Length;

        RtlCopyMemory(DstData, (uchar *)SrcData + SrcOffset, Bytes);

        (uchar *)DstData += Bytes;
        Length -= Bytes;

        if (Length == 0)
            break;

        NdisGetNextBuffer(SrcBuffer, &SrcBuffer);
        if (SrcBuffer == NULL)
            return NULL;
        NdisQueryBuffer(SrcBuffer, &SrcData, &SrcSize);
        SrcOffset = 0;
    }

    return DataBuffer;
}

//* GetIPv6Header
//
//  Returns a pointer to the IPv6 header in an NDIS Packet.
//  If the header is contiguous, then just returns
//  a pointer to the data directly in the packet.
//  Otherwise the IPv6 header is copied to the supplied buffer,
//  and a pointer to the buffer is returned.
//
//  Returns NULL only if the NDIS packet is not big enough
//  to contain a header, or if HdrBuffer is NULL and the header
//  is not contiguous.
//
IPv6Header UNALIGNED *
GetIPv6Header(PNDIS_PACKET Packet, uint Offset, IPv6Header *HdrBuffer)
{
    PNDIS_BUFFER NdisBuffer;

    NdisQueryPacket(Packet, NULL, NULL, &NdisBuffer, NULL);

    return (IPv6Header UNALIGNED *)
        GetDataFromNdis(NdisBuffer, Offset, sizeof(IPv6Header),
                        (uchar *) HdrBuffer);
}


//* PacketPullupEx - extend contiguous, aligned data region.
//
//  Pulls up more data from secondary packet buffers to create a contiguous
//  buffer of at least the requested size with the requested alignment.
//
//  The alignment requirement is expressed as a power-of-2 multiple
//  plus an offset. For example, 4n+3 means the data address should
//  be a multiple of 4 plus 3.
//  NB: These two arguments are uint not UINT_PTR because we don't
//  need to express very large multiples.
//
//  For the moment, the alignment multiple should be one or two.
//  This is because Ethernet headers are 14 bytes so in practice
//  requesting 4-byte alignment would cause copying. In the future,
//  NDIS should be fixed so the network-layer header is 8-byte aligned.
//
//  So if the natural alignment (__builtin_alignof) of the needed type
//  is one or two, then supply the natural alignment and do not
//  use the UNALIGNED keyword. Otherwise, if the needed type
//  contains an IPv6 address, then supply __builtin_alignof(IPv6Addr)
//  (so you can use AddrAlign to access the addresses without copying)
//  and use UNALIGNED. Otherwise, supply 1 and use UNALIGNED.
//
//  NB: A caller can request a zero size contiguous region
//  with no alignment restriction, to move to the next buffer
//  after processing the current buffer. In this usage,
//  PacketPullupSubr will never fail.
//
uint  // Returns: new contiguous amount, or 0 if unable to satisfy request.
PacketPullupSubr(
    IPv6Packet *Packet,  // Packet to pullup.
    uint Needed,         // Minimum amount of contiguous data to return.
    uint AlignMultiple,  // Alignment multiple.
    uint AlignOffset)    // Offset from the alignment multiple.
{
    PNDIS_BUFFER Buffer;
    void *BufAddr;
    IPv6PacketAuxiliary *Aux;
    uint BufLen = 0, Offset, LeftToGo = 0;

    ASSERT(AlignMultiple <= 2);
    ASSERT((AlignMultiple & (AlignMultiple - 1)) == 0);
    ASSERT(AlignOffset < AlignMultiple);

    //
    // Check if our caller requested too much data.
    //
    if (Needed > Packet->TotalSize)
        return 0;

    //
    // Find our current position in the raw packet data.
    // REVIEW: This is exactly PositionPacketAt except
    // we want the Buffer for later use with CopyNdisToFlat.
    //
    if (Packet->NdisPacket == NULL) {
        //
        // Reset our data pointer and contiguous region counter.
        //
        Packet->Data = (uchar *)Packet->FlatData + Packet->Position;
        Packet->ContigSize = Packet->TotalSize;
    }
    else {
        //
        // Scan the NDIS buffer chain until we have reached the buffer
        // containing the current position.  Note that if we entered with
        // the position field pointing one off the end of a buffer (a common
        // case), we'll stop at the beginning of the following buffer. 
        //
        Buffer = NdisFirstBuffer(Packet->NdisPacket);
        Offset = 0;
        for (;;) {
            NdisQueryBuffer(Buffer, &BufAddr, &BufLen);
            Offset += BufLen;
            if (Packet->Position < Offset)
                break;
            NdisGetNextBuffer(Buffer, &Buffer);
        }

        //
        // Reset our data pointer and contiguous region counter to insure
        // they reflect the current position in the NDIS buffer chain.
        // 
        LeftToGo = Offset - Packet->Position;
        Packet->Data = (uchar *)BufAddr + (BufLen - LeftToGo);
        Packet->ContigSize = MIN(LeftToGo, Packet->TotalSize);
    }

    //
    // The above repositioning may result in a contiguous region
    // that will satisfy the request.
    //
    if (Needed <= Packet->ContigSize) {
        if ((PtrToUint(Packet->Data) & (AlignMultiple - 1)) == AlignOffset)
            return Packet->ContigSize;
    }

    //
    // In an attempt to prevent future pullup operations,
    // we actually pull up *more* than the requested amount.
    // But not too much more.
    //
    Needed = MAX(MIN(Packet->ContigSize, MAX_EXCESS_PULLUP), Needed);

    //
    // Allocate and initialize an auxiliary data region.
    // The data buffer follows the structure in memory,
    // with AlignOffset bytes of padding between.
    //
    Aux = ExAllocatePool(NonPagedPool, sizeof *Aux + AlignOffset + Needed);
    if (Aux == NULL)
        return 0;
    Aux->Next = Packet->AuxList;
    Aux->Data = (uchar *)(Aux + 1) + AlignOffset;
    Aux->Length = Needed;
    Aux->Position = Packet->Position;
    Packet->AuxList = Aux;

    //
    // We assume that ExAllocatePool returns aligned memory.
    //
    ASSERT((PtrToUint(Aux->Data) & (AlignMultiple - 1)) == AlignOffset);

    //
    // Copy the packet data to the auxiliary buffer.
    //
    if (Packet->NdisPacket == NULL) {
        RtlCopyMemory(Aux->Data, Packet->Data, Needed);
    }
    else {
        int Ok;

        Offset = BufLen - LeftToGo;
        Ok = CopyNdisToFlat(Aux->Data, Buffer, Offset, Needed,
                            &Buffer, &Offset);
        ASSERT(Ok);
    }

    //
    // Point our packet's data pointer at the auxiliary buffer.
    //
    Packet->Data = Aux->Data;
    return Packet->ContigSize = Needed;
}


//* PacketPullupCleanup
//
//  Cleanup auxiliary data regions that were created by PacketPullup.
//
void
PacketPullupCleanup(IPv6Packet *Packet)
{
    while (Packet->AuxList != NULL) {
        IPv6PacketAuxiliary *Aux = Packet->AuxList;
        Packet->AuxList = Aux->Next;
        ExFreePool(Aux);
    }
}


//* AdjustPacketParams
//
//  Adjust the pointers/value in the packet,
//  to move past some bytes in the packet.
//
void
AdjustPacketParams(
    IPv6Packet *Packet,
    uint BytesToSkip)
{
    ASSERT((BytesToSkip <= Packet->ContigSize) &&
           (Packet->ContigSize <= Packet->TotalSize));

    (uchar *)Packet->Data += BytesToSkip;
    Packet->ContigSize -= BytesToSkip;
    Packet->TotalSize -= BytesToSkip;
    Packet->Position += BytesToSkip;
}


//* PositionPacketAt
//
//  Adjust the pointers/values in the packet to reflect being at
//  a specific absolute position in the packet.
//
void
PositionPacketAt(
    IPv6Packet *Packet,
    uint NewPosition)
{
    if (Packet->NdisPacket == NULL) {
        //
        // This packet must be just a single contiguous region.
        // Finding the right spot is a simple matter of arithmetic.
        // We reset to the beginning and then adjust forward.
        //
        Packet->Data = Packet->FlatData;
        Packet->TotalSize += Packet->Position;
        Packet->ContigSize = Packet->TotalSize;
        Packet->Position = 0;
        AdjustPacketParams(Packet, NewPosition);
    } else {
        PNDIS_BUFFER Buffer;
        void *BufAddr;
        uint BufLen, Offset, LeftToGo;

        //
        // There may be multiple buffers comprising this packet.
        // Step through them until we arrive at the right spot.
        //
        Buffer = NdisFirstBuffer(Packet->NdisPacket);
        Offset = 0;
        for (;;) {
            NdisQueryBuffer(Buffer, &BufAddr, &BufLen);
            Offset += BufLen;
            if (NewPosition < Offset)
                break;
            NdisGetNextBuffer(Buffer, &Buffer);
        }
        LeftToGo = Offset - NewPosition;
        Packet->Data = (uchar *)BufAddr + (BufLen - LeftToGo);
        Packet->TotalSize += Packet->Position - NewPosition;
        Packet->ContigSize = MIN(LeftToGo, Packet->TotalSize);
        Packet->Position = NewPosition;
    }
}


//* GetPacketPositionFromPointer
//
//  Determines the Packet 'Position' (offset from start of packet)
//  corresponding to a given data pointer.
//
//  This isn't very efficient in some cases, so use sparingly.
//
uint
GetPacketPositionFromPointer(
    IPv6Packet *Packet,  // Packet containing pointer we're converting.
    uchar *Pointer)      // Pointer to convert to a position.
{
    PNDIS_BUFFER Buffer;
    uchar *BufAddr;
    uint BufLen, Position;
    IPv6PacketAuxiliary *Aux;

    //
    // If the IPv6Packet has no associated NDIS_PACKET, then we check
    // the flat data region. The packet may still have auxiliary buffers
    // from PacketPullup.
    //
    if (Packet->NdisPacket == NULL) {
        if (((uchar *)Packet->FlatData <= Pointer) &&
            (Pointer < ((uchar *)Packet->FlatData +
                        Packet->Position + Packet->TotalSize))) {
            //
            // Our pointer's position is just the difference between it
            // and the start of the flat data region.
            //
            return (uint)(Pointer - (uchar *)Packet->FlatData);
        }
    }

    //
    // The next place to look is the chain of auxiliary buffers
    // allocated by PacketPullup. This must succeed if there
    // is no associated NDIS_PACKET.
    //
    for (Aux = Packet->AuxList; Aux != NULL; Aux = Aux->Next) {
        if ((Aux->Data <= Pointer) && (Pointer < Aux->Data + Aux->Length))
            return Aux->Position + (uint)(Pointer - Aux->Data);
    }

    //
    // The last thing we do is search the NDIS buffer chain.
    // This must succeed.
    //
    Buffer = NdisFirstBuffer(Packet->NdisPacket);
    Position = 0;
    for (;;) {
        NdisQueryBuffer(Buffer, &BufAddr, &BufLen);
        if ((BufAddr <= Pointer) && (Pointer < BufAddr + BufLen))
            break;
        Position += BufLen;
        NdisGetNextBuffer(Buffer, &Buffer);
        ASSERT(Buffer != NULL);
    }

    return Position + (uint)(Pointer - BufAddr);
}


//* InitializePacketFromNdis
//
//  Initialize an IPv6Packet from an NDIS_PACKET.
//
void
InitializePacketFromNdis(
    IPv6Packet *Packet,
    PNDIS_PACKET NdisPacket,
    uint Offset)
{
    PNDIS_BUFFER NdisBuffer;

    RtlZeroMemory(Packet, sizeof *Packet);

    NdisGetFirstBufferFromPacket(NdisPacket, &NdisBuffer,
                                 &Packet->Data,
                                 &Packet->ContigSize,
                                 &Packet->TotalSize);

    Packet->NdisPacket = NdisPacket;
    PositionPacketAt(Packet, Offset);
}


#if DBG
//* FormatV6Address - Print an IPv6 address to a buffer.
//
//  Returns a static buffer containing the address.
//  Because the static buffer is not locked,
//  this function is only useful for debug prints.
//
//  Returns char * instead of WCHAR * because %ws
//  is not usable at DPC level in DbgPrint.
//
char *
FormatV6Address(const IPv6Addr *Addr)
{
    static char Buffer[INET6_ADDRSTRLEN];

    FormatV6AddressWorker(Buffer, Addr);
    return Buffer;
}


//* FormatV4Address - Print an IPv4 address to a buffer.
//
//  Returns a static buffer containing the address.
//  Because the static buffer is not locked,
//  this function is only useful for debug prints.
//
//  Returns char * instead of WCHAR * because %ws
//  is not usable at DPC level in DbgPrint.
//
char *
FormatV4Address(IPAddr Addr)
{
    static char Buffer[INET_ADDRSTRLEN];

    FormatV4AddressWorker(Buffer, Addr);
    return Buffer;
}
#endif // DBG


#if DBG
long DebugLogSlot = 0;
struct DebugLogEntry DebugLog[DEBUG_LOG_SIZE];

//* LogDebugEvent - Make an entry in our debug log that some event happened.
//
// The debug event log allows for "real time" logging of events
// in a circular queue kept in non-pageable memory.  Each event consists
// of an id number and a arbitrary 32 bit value.
//
void
LogDebugEvent(uint Event,  // The event that took place.
              int Arg)     // Any interesting 32 bits associated with event.
{
    uint Slot;

    //
    // Get the next slot in the log in a muliprocessor safe manner.
    //
    Slot = InterlockedIncrement(&DebugLogSlot) & (DEBUG_LOG_SIZE - 1);

    //
    // Add this event to the log along with a timestamp.
    //
    KeQueryTickCount(&DebugLog[Slot].Time);
    DebugLog[Slot].Event = Event;
    DebugLog[Slot].Arg = Arg;
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\addr.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Common transport layer address object handling code.
//
// This file contains the TDI address object related procedures,
// including TDI open address, TDI close address, etc.
//
// The local address objects are stored in a hash table, protected
// by the AddrObjTableLock.  In order to insert or delete from the
// hash table this lock must be held, as well as the address object
// lock.  The table lock must always be taken before the object lock.
//


#include "oscfg.h"
#include "ndis.h"
#include "tdi.h"
#include "tdistat.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "route.h"
#include "mld.h"
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "udp.h"
#include "raw.h"
#ifndef UDP_ONLY
#include "tcp.h"
#include "tcpconn.h"
#include "tcpdeliv.h"
#else
#include "tcpdeb.h"
#endif
#include "info.h"
#include "tcpcfg.h"
#include "ntddip6.h"  // included only to get the common socket -> kernel interface structures.

extern KSPIN_LOCK DGSendReqLock;


// Addess object hash table.
uint AddrObjTableSize;
AddrObj **AddrObjTable;
AddrObj *LastAO;     // one element lookup cache.
KSPIN_LOCK AddrObjTableLock;
KMUTEX AddrSDMutex;
#define AO_HASH(a, p) (((a).u.Word[7] + (uint)(p)) % AddrObjTableSize)

ushort NextUserPort = MIN_USER_PORT;

RTL_BITMAP PortBitmapTcp;
RTL_BITMAP PortBitmapUdp;
ulong PortBitmapBufferTcp[(1 << 16) / (sizeof(ulong) * 8)];
ulong PortBitmapBufferUdp[(1 << 16) / (sizeof(ulong) * 8)];

//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA

int InitAddr();

#pragma alloc_text(INIT, InitAddr)

#endif // ALLOC_PRAGMA


//* ReadNextAO - Read the next AddrObj in the table.
//
//  Called to read the next AddrObj in the table.  The needed information
//  is derived from the incoming context, which is assumed to be valid.
//  We'll copy the information, and then update the context value with
//  the next AddrObj to be read.
//
uint  // Returns: TRUE if more data is available to be read, FALSE is not.
ReadNextAO(
    void *Context,  // Pointer to a UDPContext.
    void *Buffer)   // Pointer to a UDP6ListenerEntry structure.
{
    UDPContext *UContext = (UDPContext *)Context;
    UDP6ListenerEntry *UEntry = (UDP6ListenerEntry *)Buffer;
    AddrObj *CurrentAO;
    uint i;

    CurrentAO = UContext->uc_ao;
    CHECK_STRUCT(CurrentAO, ao);

    UEntry->ule_localaddr = CurrentAO->ao_addr;
    UEntry->ule_localscopeid = CurrentAO->ao_scope_id;
    UEntry->ule_localport = CurrentAO->ao_port;
    UEntry->ule_owningpid = CurrentAO->ao_owningpid;

    // We've filled it in. Now update the context.
    CurrentAO = CurrentAO->ao_next;
    if (CurrentAO != NULL && CurrentAO->ao_prot == IP_PROTOCOL_UDP) {
        UContext->uc_ao = CurrentAO;
        return TRUE;
    } else {
        // The next AO is NULL, or not a UDP AO.  Loop through the AddrObjTable
        // looking for a new one.
        i = UContext->uc_index;

        for (;;) {
            while (CurrentAO != NULL) {
                if (CurrentAO->ao_prot == IP_PROTOCOL_UDP)
                    break;
                else
                    CurrentAO = CurrentAO->ao_next;
            }

            if (CurrentAO != NULL)
                break;  // Get out of for (;;) loop.

            ASSERT(CurrentAO == NULL);

            // Didn't find one on this chain.  Walk down the table, looking
            // for the next one.
            while (++i < AddrObjTableSize) {
                if (AddrObjTable[i] != NULL) {
                    CurrentAO = AddrObjTable[i];
                    break;  // Out of while loop.
                }
            }

            if (i == AddrObjTableSize)
                break;  // Out of for (;;) loop.
        }

        // If we found one, return it.
        if (CurrentAO != NULL) {
            UContext->uc_ao = CurrentAO;
            UContext->uc_index = i;
            return TRUE;
        } else {
            UContext->uc_index = 0;
            UContext->uc_ao = NULL;
            return FALSE;
        }
    }
}

//* ValidateAOContext - Validate the context for reading the AddrObj table.
//
//  Called to start reading the AddrObj table sequentially.  We take in
//  a context, and if the values are 0 we return information about the
//  first AddrObj in the table.  Otherwise we make sure that the context value
//  is valid, and if it is we return TRUE.
//  We assume the caller holds the AddrObjTable lock.
//
uint                // Returns: TRUE if data in table, FALSE if not.
ValidateAOContext(
    void *Context,  // Pointer to a UDPContext.
    uint *Valid)    // Pointer to value to set to true if context is valid.
{
    UDPContext *UContext = (UDPContext *)Context;
    uint i;
    AddrObj *TargetAO;
    AddrObj *CurrentAO;

    i = UContext->uc_index;
    TargetAO = UContext->uc_ao;

    // If the context values are 0 and NULL, we're starting from the beginning.
    if (i == 0 && TargetAO == NULL) {
        *Valid = TRUE;
        do {
            if ((CurrentAO = AddrObjTable[i]) != NULL) {
                CHECK_STRUCT(CurrentAO, ao);
                while (CurrentAO != NULL &&
                       CurrentAO->ao_prot != IP_PROTOCOL_UDP)
                    CurrentAO = CurrentAO->ao_next;

                if (CurrentAO != NULL)
                    break;
            }
            i++;
        } while (i < AddrObjTableSize);

        if (CurrentAO != NULL) {
            UContext->uc_index = i;
            UContext->uc_ao = CurrentAO;
            return TRUE;
        } else
            return FALSE;

    } else {

        // We've been given a context. We just need to make sure that it's
        // valid.

        if (i < AddrObjTableSize) {
            CurrentAO = AddrObjTable[i];
            while (CurrentAO != NULL) {
                if (CurrentAO == TargetAO) {
                    if (CurrentAO->ao_prot == IP_PROTOCOL_UDP) {
                        *Valid = TRUE;
                        return TRUE;
                    }
                    break;
                } else {
                    CurrentAO = CurrentAO->ao_next;
                }
            }
        }

        // If we get here, we didn't find the matching AddrObj.
        *Valid = FALSE;
        return FALSE;
    }
}


//* FindIfIndexOnAO - Find an interface index in an address-object's list.
//
//  This routine is called to determine whether a given interface index
//  appears in the list of interfaces with which the given address-object
//  is associated.
//
//  The routine is called from 'GetAddrObj' with the table lock held
//  but with the object lock not held. We take the object lock to look at
//  its interface list, and release the lock before returning control.
//
uint    // Returns: The index if found, or 0 if none.
FindIfIndexOnAO(
    AddrObj *AO,    // Address object to be searched.
    Interface *IF)  // The interface to be found.
{
    uint *IfList;
    KIRQL Irql;

    KeAcquireSpinLock(&AO->ao_lock, &Irql);
    if ((IfList = AO->ao_iflist) != NULL) {
        while (*IfList) {
            if (*IfList == IF->Index) {
                KeReleaseSpinLock(&AO->ao_lock, Irql);
                return IF->Index;
            }
            IfList++;
        }
    }
    KeReleaseSpinLock(&AO->ao_lock, Irql);

    //
    // If an interface list was present and the interface was not found,
    // return zero. Otherwise, if no interface list was present there is no
    // restriction on the object, so return the interface index as though the
    // interface appeared in the list.
    //
    return IfList ? 0 : IF->Index;
}


//* GetAddrObj - Find a local address object.
//
//  This is the local address object lookup routine.  We take as input the
//  local address and port and a pointer to a 'previous' address object.
//  The hash table entries in each bucket are sorted in order of increasing
//  address, and we skip over any object that has an address lower than the
//  'previous' address.  To get the first address object, pass in a previous
//  value of NULL.
//
//  We assume that the table lock is held while we're in this routine.  We
//  don't take each object lock, since the local address and port can't change
//  while the entry is in the table and the table lock is held so nothing can
//  be inserted or deleted.
//
AddrObj *  // Returns: A pointer to the Address object, or NULL if none.
GetAddrObj(
    IPv6Addr *LocalAddr,  // Local IP address of object to find (may be NULL).
    IPv6Addr *RemoteAddr, // Remote IP address to check against (may be NULL
                          // if IF is also NULL).
    uint LocalScopeId,    // Scope identifier for local IP address.
    ushort LocalPort,     // Local port of object to find.
    uchar Protocol,       // Protocol to find address.
    AddrObj *PreviousAO,  // Pointer to last address object found.
    Interface *IF)        // Interface to find in interface list (may be NULL).
{
    AddrObj *CurrentAO;  // Current address object we're examining.

#if DBG
    if (PreviousAO != NULL)
        CHECK_STRUCT(PreviousAO, ao);
#endif

#if 0
    //
    // Check our 1-element cache for a match.
    //
    if ((PreviousAO == NULL) && (LastAO != NULL)) {
        CHECK_STRUCT(LastAO, ao);
        if ((LastAO->ao_prot == Protocol) &&
            IP6_ADDR_EQUAL(LastAO->ao_addr, LocalAddr) &&
            (LastAO->ao_port == LocalPort))
        {
            return LastAO;
        }
    }
#endif

    // Find the appropriate bucket in the hash table, and search for a match.
    // If we don't find one the first time through, we'll try again with a
    // wildcard local address.

    for (;;) {

        CurrentAO = AddrObjTable[AO_HASH(*LocalAddr, LocalPort)];

        // While we haven't hit the end of the list, examine each element.
        while (CurrentAO != NULL) {

            CHECK_STRUCT(CurrentAO, ao);

            // If the current one is greater than one we were given, check it.
            if (CurrentAO > PreviousAO) {
                if (!(CurrentAO->ao_flags & AO_RAW_FLAG)) {
                    //
                    // This is an ordinary (non-raw) socket.
                    // Only match if we meet all the criteria.
                    //
                    if (IP6_ADDR_EQUAL(&CurrentAO->ao_addr, LocalAddr) &&
                        (CurrentAO->ao_scope_id == LocalScopeId) &&
                        (CurrentAO->ao_port == LocalPort) &&
                        (CurrentAO->ao_prot == Protocol)) {

                        if ((IF == NULL) ||
                            DoesAOAllowPacket(CurrentAO, IF, RemoteAddr)) {
                            // Found a match.  Update cache and return.
                            LastAO = CurrentAO;
                            return CurrentAO;
                        }
                    }
                } else {
                    //
                    // This is a raw socket.
                    //
                    if ((Protocol != IP_PROTOCOL_UDP)
#ifndef UDP_ONLY
                        && (Protocol != IP_PROTOCOL_TCP)
#endif
                        )
                    {
                        IF_TCPDBG(TCP_DEBUG_RAW) {
                            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                                "matching <p, a> <%u, %lx> ao %lx <%u, %lx>\n",
                                Protocol, LocalAddr, CurrentAO,
                                CurrentAO->ao_prot, CurrentAO->ao_addr));
                        }

                        if (IP6_ADDR_EQUAL(&CurrentAO->ao_addr, LocalAddr) &&
                            (CurrentAO->ao_scope_id == LocalScopeId) &&
                            ((CurrentAO->ao_prot == Protocol) ||
                             (CurrentAO->ao_prot == 0))) {

                            if ((IF == NULL) ||
                                DoesAOAllowPacket(CurrentAO, IF, RemoteAddr)) {
                                // Found a match.  Update cache and return.
                                LastAO = CurrentAO;
                                return CurrentAO;
                            }
                        }
                    }
                }
            }

            // Either it was less than the previous one, or they didn't match.
            // Keep searching in this bucket.
            CurrentAO = CurrentAO->ao_next;
        }

        //
        // When we get here, we've hit the end of the list we were examining.
        // If we weren't examining a wildcard address, look for a wild card
        // address.
        //
        if (!IP6_ADDR_EQUAL(LocalAddr, &UnspecifiedAddr)) {
            LocalAddr = &UnspecifiedAddr;
            LocalScopeId = 0;
            PreviousAO = NULL;
        } else
            return NULL;        // We looked for a wildcard and couldn't find
                                // one, so fail.
    }
}


//* GetNextAddrObj - Get the next address object in a sequential search.
//
//  This is the 'get next' routine, called when we are reading the address
//  object table sequentially.  We pull the appropriate parameters from the
//  search context, call GetAddrObj, and update the search context with what
//  we find.  This routine assumes the AddrObjTableLock is held by the caller.
//
AddrObj *  // Returns: Pointer to AddrObj, or NULL if search failed.
GetNextAddrObj(
    AOSearchContext *SearchContext)  // Context for search taking place.
{
    AddrObj *FoundAO;  // Pointer to the address object we found.

    ASSERT(SearchContext != NULL);

    // Try and find a match.
    FoundAO = GetAddrObj(&SearchContext->asc_local_addr, 
                         &SearchContext->asc_remote_addr, 
                         SearchContext->asc_scope_id,
                         SearchContext->asc_port, SearchContext->asc_prot,
                         SearchContext->asc_previous, 
                         SearchContext->asc_interface);

    // Found a match. Update the search context for next time.
    if (FoundAO != NULL) {
        SearchContext->asc_previous = FoundAO;
        SearchContext->asc_local_addr = FoundAO->ao_addr;
        SearchContext->asc_scope_id = FoundAO->ao_scope_id;
        // Don't bother to update port or protocol, they don't change.
    }
    return FoundAO;
}

//* GetFirstAddrObj - Get the first matching address object.
//
//  The routine called to start a sequential read of the AddrObj table.  We
//  initialize the provided search context and then call GetNextAddrObj to do
//  the actual read.  We assume the AddrObjTableLock is held by the caller.
//
AddrObj *  // Returns: Pointer to AO found, or NULL if we couldn't find any.
GetFirstAddrObj(
    IPv6Addr *LocalAddr,             // Local IP address of object to be found.
    IPv6Addr *RemoteAddr,            // Remote IP address to check against.
    uint LocalScopeId,               // Scope identifier for local IP address.
    ushort LocalPort,                // Local port of object to be found.
    uchar Protocol,                  // Protocol of object to be found.
    Interface *IF,                   // Interface to check against.
    AOSearchContext *SearchContext)  // Context to be used during search.
{
    ASSERT(SearchContext != NULL);

    // Fill in the search context.
    SearchContext->asc_previous = NULL;     // Haven't found one yet.
    SearchContext->asc_local_addr = *LocalAddr;
    SearchContext->asc_remote_addr = *RemoteAddr;
    SearchContext->asc_scope_id = LocalScopeId;
    SearchContext->asc_port = LocalPort;
    SearchContext->asc_prot = Protocol;
    SearchContext->asc_interface = IF;
    return GetNextAddrObj(SearchContext);
}

//* InsertAddrObj - Insert an address object into the AddrObj table.
//
//  Called to insert an AO into the table, assuming the table lock is held.
//  We hash on the addr and port, and then insert in into the correct place
//  (sorted by address of the objects).
//
void                 //  Returns: Nothing.
InsertAddrObj(
    AddrObj *NewAO)  // Pointer to AddrObj to be inserted.
{
    AddrObj *PrevAO;     // Pointer to previous address object in hash chain.
    AddrObj *CurrentAO;  // Pointer to current AO in table.

    CHECK_STRUCT(NewAO, ao);

    PrevAO = CONTAINING_RECORD(&AddrObjTable[AO_HASH(NewAO->ao_addr,
                                                     NewAO->ao_port)],
                               AddrObj, ao_next);
    CurrentAO = PrevAO->ao_next;

    // Loop through the chain until we hit the end or until we find an entry
    // whose address is greater than ours.

    while (CurrentAO != NULL) {

        CHECK_STRUCT(CurrentAO, ao);
        ASSERT(CurrentAO != NewAO);  // Debug check to make sure we aren't
                                     // inserting the same entry.
        if (NewAO < CurrentAO)
            break;
        PrevAO = CurrentAO;
        CurrentAO = CurrentAO->ao_next;
    }

    // At this point, PrevAO points to the AO before the new one. Insert it
    // there.
    ASSERT(PrevAO != NULL);
    ASSERT(PrevAO->ao_next == CurrentAO);

    NewAO->ao_next = CurrentAO;
    PrevAO->ao_next = NewAO;
    if (NewAO->ao_prot == IP_PROTOCOL_UDP)
        UStats.us_numaddrs++;
}

//* RemoveAddrObj - Remove an address object from the table.
//
//  Called when we need to remove an address object from the table.  We hash on
//  the addr and port, then walk the table looking for the object.  We assume
//  that the table lock is held.
//
//  The AddrObj may have already been removed from the table if it was
//  invalidated for some reason, so we need to check for the case of not
//  finding it.
//
void                     // Returns: Nothing.
RemoveAddrObj(
    AddrObj *RemovedAO)  // AddrObj to delete.
{
    AddrObj *PrevAO;     // Pointer to previous address object in hash chain.
    AddrObj *CurrentAO;  // Pointer to current AO in table.

    CHECK_STRUCT(RemovedAO, ao);

    PrevAO = CONTAINING_RECORD(&AddrObjTable[AO_HASH(RemovedAO->ao_addr,
                                                     RemovedAO->ao_port)],
                               AddrObj, ao_next);
    CurrentAO = PrevAO->ao_next;

    // Walk the table, looking for a match.
    while (CurrentAO != NULL) {
        CHECK_STRUCT(CurrentAO, ao);

        if (CurrentAO == RemovedAO) {
            PrevAO->ao_next = CurrentAO->ao_next;
            if (CurrentAO->ao_prot == IP_PROTOCOL_UDP) {
                UStats.us_numaddrs--;
            }
            if (CurrentAO == LastAO) {
                LastAO = NULL;
            }
            return;
        } else {
            PrevAO = CurrentAO;
            CurrentAO = CurrentAO->ao_next;
        }
    }

    //
    // If we get here, we didn't find him.  This is OK, but we should say
    // something about it.
    //
    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
               "RemoveAddrObj: Object not found.\n"));
}

//* FindAnyAddrObj - Find an AO with matching port on any local address.
//
//  Called for wildcard address opens.  We go through the entire addrobj table,
//  and see if anyone has the specified port.  We assume that the lock is
//  already held on the table.
//
AddrObj *  //  Returns: Pointer to AO found, or NULL is noone has it.
FindAnyAddrObj(
    ushort Port,     // Port to be looked for.
    uchar Protocol)  // Protocol on which to look.
{
    uint i;               // Index variable.
    AddrObj *CurrentAO;  // Current AddrObj being examined.

    for (i = 0; i < AddrObjTableSize; i++) {
        CurrentAO = AddrObjTable[i];
        while (CurrentAO != NULL) {
            CHECK_STRUCT(CurrentAO, ao);

            if (CurrentAO->ao_port == Port && CurrentAO->ao_prot == Protocol)
                return CurrentAO;
            else
                CurrentAO = CurrentAO->ao_next;
        }
    }

    return NULL;
}

//* RebuildAddrObjBitmap - reconstruct the address-object bitmap from scratch.
//
// Called when we need to reconcile the contents of our lookaside bitmap
// with the actual contents of the address-object table. We clear the bitmap,
// then scan the address-object table and mark each entry's bit as 'in-use'.
// Assumes the caller holds the AddrObjTableLock.
//
// Input:   nothing.
//
// Return:  nothing.
//
void
RebuildAddrObjBitmap(void)
{
    uint i;
    AddrObj* CurrentAO;

    RtlClearAllBits(&PortBitmapTcp);
    RtlClearAllBits(&PortBitmapUdp);

    for (i = 0; i < AddrObjTableSize; i++) {
        CurrentAO = AddrObjTable[i];
        while (CurrentAO != NULL) {
            CHECK_STRUCT(CurrentAO, ao);

            if (CurrentAO->ao_prot == IP_PROTOCOL_TCP) {
                RtlSetBit(&PortBitmapTcp, net_short(CurrentAO->ao_port));
            } else if (CurrentAO->ao_prot == IP_PROTOCOL_UDP) {
                RtlSetBit(&PortBitmapUdp, net_short(CurrentAO->ao_port));
            }
            CurrentAO = CurrentAO->ao_next;
        }
    }
}

//* GetAddress - Get an IP address and port from a TDI address structure.
//
//  Called when we need to get our addressing information from a TDI
//  address structure.  We go through the structure, and return what we
//  find.
//
uchar  //  Return: TRUE if we find an address, FALSE if we don't.
GetAddress(
    TRANSPORT_ADDRESS UNALIGNED *AddrList,  // Pointer to structure to search.
    IPv6Addr *Addr,                         // Where to return IP address.
    ulong *ScopeId,                         // Where to return address scope.
    ushort *Port)                           // Where to return Port.
{
    int i;  // Index variable.
    TA_ADDRESS *CurrentAddr;  // Address we're examining and may use.

    // First, verify that someplace in Address is an address we can use.
    CurrentAddr = (TA_ADDRESS *) AddrList->Address;

    for (i = 0; i < AddrList->TAAddressCount; i++) {
        if (CurrentAddr->AddressType == TDI_ADDRESS_TYPE_IP6) {
            if (CurrentAddr->AddressLength >= TDI_ADDRESS_LENGTH_IP6) {
                //
                // It's an IPv6 address.  Pull out the values.
                //
                TDI_ADDRESS_IP6 UNALIGNED *ValidAddr =
                    (TDI_ADDRESS_IP6 UNALIGNED *)CurrentAddr->Address;

                *Port = ValidAddr->sin6_port;
                RtlCopyMemory(Addr, ValidAddr->sin6_addr, sizeof(IPv6Addr));
                *ScopeId = ValidAddr->sin6_scope_id;
                return TRUE;
            } else
                return FALSE;  // Wrong length for address.
        } else {
            //
            // Wrong address type.  Skip over it to next one in list.
            //
            CurrentAddr = (TA_ADDRESS *)(CurrentAddr->Address +
                CurrentAddr->AddressLength);
        }
    }

    return FALSE;  // Didn't find a match.
}

//* InvalidateAddrs - Invalidate all AOs for a specific address.
//
//  Called when we need to invalidate all AOs for a specific address.  Walk
//  down the table with the lock held, and take the lock on each AddrObj.
//  If the address matches, mark it as invalid, pull off all requests,
//  and continue.  At the end we'll complete all requests with an error.
//
void                 // Returns: Nothing.
InvalidateAddrs(
    IPv6Addr *Addr,  // Addr to be invalidated.
    uint ScopeId)    // Scope id for Addr.
{
    Queue SendQ, RcvQ;
    AORequest *ReqList;
    KIRQL Irql0, Irql1;  // One per lock nesting level.
    uint i;
    AddrObj *AO;
    DGSendReq *SendReq;
    DGRcvReq *RcvReq;
    AOMCastAddr *MA;

    INITQ(&SendQ);
    INITQ(&RcvQ);
    ReqList = NULL;

    KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
    for (i = 0; i < AddrObjTableSize; i++) {
        // Walk down each hash bucket, looking for a match.
        AO = AddrObjTable[i];
        while (AO != NULL) {
            CHECK_STRUCT(AO, ao);

            KeAcquireSpinLock(&AO->ao_lock, &Irql1);
            if (IP6_ADDR_EQUAL(&AO->ao_addr, Addr) &&
                (AO->ao_scope_id == ScopeId) && AO_VALID(AO)) {
                // This one matches. Mark as invalid, then pull his requests.
                SET_AO_INVALID(AO);

                // If he has a request on him, pull him off.
                if (AO->ao_request != NULL) {
                    AORequest *Temp;

                    Temp = CONTAINING_RECORD(&AO->ao_request, AORequest,
                                             aor_next);
                    do {
                        Temp = Temp->aor_next;
                    } while (Temp->aor_next != NULL);

                    Temp->aor_next = ReqList;
                    ReqList = AO->ao_request;
                    AO->ao_request = NULL;
                }

                // Go down his send list, pulling things off the send q and
                // putting them on our local queue.
                while (!EMPTYQ(&AO->ao_sendq)) {
                    DEQUEUE(&AO->ao_sendq, SendReq, DGSendReq, dsr_q);
                    CHECK_STRUCT(SendReq, dsr);
                    ENQUEUE(&SendQ, &SendReq->dsr_q);
                }

                // Do the same for the receive queue.
                while (!EMPTYQ(&AO->ao_rcvq)) {
                    DEQUEUE(&AO->ao_rcvq, RcvReq, DGRcvReq, drr_q);
                    CHECK_STRUCT(RcvReq, drr);
                    ENQUEUE(&RcvQ, &RcvReq->drr_q);
                }

                // Free any multicast addresses he may have.  IP will have
                // deleted them at that level before we get here, so all we
                // need to do if free the memory.
                MA = AO->ao_mcastlist;
                while (MA != NULL) {
                    AOMCastAddr *Temp;

                    Temp = MA;
                    MA = MA->ama_next;
                    ExFreePool(Temp);
                }
                AO->ao_mcastlist = NULL;

            }
            KeReleaseSpinLock(&AO->ao_lock, Irql1);
            AO = AO->ao_next;  // Go to the next one.
        }
    }
    KeReleaseSpinLock(&AddrObjTableLock, Irql0);

    // OK, now walk what we've collected, complete it, and free it.
    while (ReqList != NULL) {
        AORequest *Req;

        Req = ReqList;
        ReqList = Req->aor_next;
        (*Req->aor_rtn)(Req->aor_context, (uint) TDI_ADDR_INVALID, 0);
        FreeAORequest(Req);
    }

    // Walk down the rcv. q, completing and freeing requests.
    while (!EMPTYQ(&RcvQ)) {

        DEQUEUE(&RcvQ, RcvReq, DGRcvReq, drr_q);
        CHECK_STRUCT(RcvReq, drr);

        (*RcvReq->drr_rtn)(RcvReq->drr_context, (uint) TDI_ADDR_INVALID, 0);

        FreeDGRcvReq(RcvReq);

    }

    // Now do the same for sends.
    while (!EMPTYQ(&SendQ)) {

        DEQUEUE(&SendQ, SendReq, DGSendReq, dsr_q);
        CHECK_STRUCT(SendReq, dsr);

        (*SendReq->dsr_rtn)(SendReq->dsr_context, (uint) TDI_ADDR_INVALID, 0);

        KeAcquireSpinLock(&DGSendReqLock, &Irql0);
        FreeDGSendReq(SendReq);
        KeReleaseSpinLock(&DGSendReqLock, Irql0);
    }
}

//* RequestWorker - Handle a deferred request.
//
//  This is the work item callback routine, called by a system worker
//  thread when the work item queued by DelayDerefAO is handled.
//  We just call ProcessAORequest on the AO.
//
void                  //  Returns: Nothing.
RequestWorker(
    void *Context)    // Pointer to AddrObj.
{
    AddrObj *AO = (AddrObj *)Context;

    CHECK_STRUCT(AO, ao);
    ASSERT(AO_BUSY(AO));

    ProcessAORequests(AO);
}

//* GetAddrOptions - Get the address options.
//
//  Called when we're opening an address.  We take in a pointer, and walk
//  down it looking for address options we know about.
//
void                  // Returns: Nothing.
GetAddrOptions(
    void *Ptr,        // Pointer to search.
    uchar *Reuse,     // Pointer to reuse flag.
    uchar *DHCPAddr,  // Pointer to DHCP flag.
    uchar *RawSock)   // Pointer to raw socket flag.
{
    uchar *OptPtr;

    *Reuse = 0;
    *DHCPAddr = 0;
    *RawSock = 0;

    if (Ptr == NULL)
        return;

    OptPtr = (uchar *)Ptr;

    while (*OptPtr != TDI_OPTION_EOL) {
        if (*OptPtr == TDI_ADDRESS_OPTION_REUSE)
            *Reuse = 1;
        else if (*OptPtr == TDI_ADDRESS_OPTION_DHCP)
            *DHCPAddr = 1;
        else if (*OptPtr == TDI_ADDRESS_OPTION_RAW)
            *RawSock = 1;

        OptPtr++;
    }
}


//* CheckAddrReuse - enforce port-sharing rules for a new TDI address object.
//
//  Called when opening an address, to determine whether the open should
//  succeed in the presence of previous binds to the same port.
//
//  N.B. Assumes the caller holds both AddrSDMutex and AddrObjTableLock.
//  The latter is freed and reacquired in this routine.
//
TDI_STATUS // Returns: TDI_STATUS code of attempt.
CheckAddrReuse(
    PTDI_REQUEST Request,       // Pointer to a TDI request for this open.
    uint Protocol,              // Protocol on which to open the address.
    IPv6Addr* Addr,             // Local IP address to open.
    ulong ScopeId,              // Scope identifier for local IP address.
    ushort Port,                // Local port number to open.
    BOOLEAN NewReuse,           // Indicates if reuse requested for the open.
    PSECURITY_DESCRIPTOR NewSD, // Captured security-descriptor for the open.
    KIRQL* TableIrql)           // IRQL at which AddrObjTableLock was taken.
{
    PACCESS_STATE AccessState;
    BOOLEAN AllowReuse;
    AddrObj* ExistingAO;
    BOOLEAN ExistingReuse;
    PSECURITY_DESCRIPTOR ExistingSD;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK GrantedAccess;
    NTSTATUS status;

    // Look for an existing valid AO and succeed if none.
    // Otherwise, capture its reuse flag and security-descriptor.

    ExistingAO = GetBestAddrObj(Addr, NULL, ScopeId, Port, (uchar)Protocol,
                                NULL);
    if (ExistingAO == NULL && IP6_ADDR_EQUAL(Addr, &UnspecifiedAddr) &&
        NewSD == NULL) {
        ExistingAO = FindAnyAddrObj(Port, (uchar)Protocol);
    }

    if (ExistingAO == NULL) {
        return TDI_SUCCESS;
    }

    do {
        // We've got at least one AO, so see if it allows reuse.
        // Note that we may need to repeat this for every AO on this port
        // in the case where we have multiple AOs sharing the port already,
        // since each AO has its own security descriptor. In that event,
        // we look at the AOs until one denies access or we've seen them all.

        ExistingReuse = !!AO_SHARE(ExistingAO);
        ExistingSD = ExistingAO->ao_sd;
    
        // Succeed immediately if reuse enabled on both instances.
        // Otherwise, fail if the two instances have the exact same address
        // (whether it's unspecified or specific).
    
        if (ExistingReuse && NewReuse) {
            return TDI_SUCCESS;
        }
    
        if (IP6_ADDR_EQUAL(&ExistingAO->ao_addr, Addr)) {
            return TDI_ADDR_IN_USE;
        }
    
        // The two instances have different addresses, and at least one of them
        // doesn't have reuse enabled. If the new instance is on the unspecified
        // address, the old instance must be on a specific address.
        // Allow the bind unless the new instance wants exclusive access
        // (i.e. NewSD == NULL).
    
        if (IP6_ADDR_EQUAL(Addr, &UnspecifiedAddr)) {
            if (NewSD == NULL) {
                return TDI_ADDR_IN_USE;
            }
            return TDI_SUCCESS;
        }
    
        // The two instances have different addresses, and the new instance is 
        // on a specific address. If the old instance is on a specific address
        // too, the two are disjoint and can peacefully coexist.
    
        if (!IP6_ADDR_EQUAL(&ExistingAO->ao_addr, &UnspecifiedAddr)) {
            return TDI_SUCCESS;
        }
    
        // The new instance is on a specific address and the old instance is on
        // the wildcard address. If the old instance wanted exclusive access
        // (i.e. ExistingSD == NULL) fail the new instance right away.
        // Otherwise, drop the AO table lock and perform an access check
        // to see if it's OK for the new instance to steal some traffic from
        // the old instance.
        //
        // N.B. Even though we've dropped the AO table lock, ExistingSD is safe
        // since we still have the AO SD mutex.
    
        if (ExistingSD == NULL) {
            return STATUS_ACCESS_DENIED;
        }
    
        ASSERT(*TableIrql <= PASSIVE_LEVEL);
        KeReleaseSpinLock(&AddrObjTableLock, *TableIrql);
    
        Irp = (PIRP)Request->RequestContext;
        IrpSp = IoGetCurrentIrpStackLocation(Irp);
        AccessState = IrpSp->Parameters.Create.SecurityContext->AccessState;
    
        SeLockSubjectContext(&AccessState->SubjectSecurityContext);
        AllowReuse = SeAccessCheck(ExistingSD, &AccessState->SubjectSecurityContext,
                                   TRUE, FILE_READ_DATA|FILE_WRITE_DATA, 0,
                                   NULL, IoGetFileObjectGenericMapping(),
                                   (IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                                        ? UserMode : Irp->RequestorMode,
                                   &GrantedAccess, &status);
        SeUnlockSubjectContext(&AccessState->SubjectSecurityContext);
    
        KeAcquireSpinLock(&AddrObjTableLock, TableIrql);
        if (!AllowReuse) {
            return status;
        }

        // The existing wildcard AO doesn't mind if the new instance takes
        // some of its traffic. If the existing AO has reuse enabled, there
        // might be others too on the port, so we'll look for them and do an
        // access check against their security-descriptors too.

    } while(ExistingReuse &&
            (ExistingAO = GetAddrObj(&UnspecifiedAddr, NULL, ScopeId, Port,
                                     (uchar)Protocol, ExistingAO, NULL))
                != NULL);

    return TDI_SUCCESS;
}

//* TdiOpenAddress - Open a TDI address object.
//
//  This is the external interface to open an address.  The caller provides a
//  TDI_REQUEST structure and a TRANSPORT_ADDRESS structure, as well a pointer
//  to a variable identifying whether or not we are to allow reuse of an
//  address while it's still open.
//
TDI_STATUS  // Returns: TDI_STATUS code of attempt.
TdiOpenAddress(
    PTDI_REQUEST Request,  // TDI request structure for this request.
    TRANSPORT_ADDRESS UNALIGNED *AddrList,  // Address to be opened.
    uint Protocol,  // Protocol on which to open the address (LSB only).
    void *Ptr,      // Pointer to option buffer.
    PSECURITY_DESCRIPTOR AddrSD) // SD for port-reuse access checks.
{
    uint i;               // Index variable.
    ushort Port;          // Local Port we'll use.
    IPv6Addr LocalAddr;   // Actual address we'll use.
    ulong ScopeId;        // Address scope.
    AddrObj *NewAO;       // New AO we'll use.
    AddrObj *ExistingAO;  // Pointer to existing AO, if any.
    KIRQL OldIrql;
    uchar Reuse, DHCPAddr, RawSock;
    PRTL_BITMAP PortBitmap;

    if (!GetAddress(AddrList, &LocalAddr, &ScopeId, &Port))
        return TDI_BAD_ADDR;

    // Find the address options we might need.
    GetAddrOptions(Ptr, &Reuse, &DHCPAddr, &RawSock);

    //
    // Allocate the new addr obj now, assuming that we need it,
    // so we don't have to do it with locks held later.
    //
    NewAO = ExAllocatePool(NonPagedPool, sizeof(AddrObj));
    if (NewAO == NULL) {
        // Couldn't allocate an address object.
        return TDI_NO_RESOURCES;
    }
    RtlZeroMemory(NewAO, sizeof(AddrObj));

    //
    // Check to make sure IP address is one of our local addresses.  This
    // is protected with the address table lock, so we can interlock an IP
    // address going away through DHCP.
    //
    KeWaitForSingleObject(&AddrSDMutex, Executive, KernelMode, FALSE, NULL);
    KeAcquireSpinLock(&AddrObjTableLock, &OldIrql);

    if (!IP6_ADDR_EQUAL(&LocalAddr, &UnspecifiedAddr)) {
        NetTableEntry *NTE;

        //
        // The user specified a local address (i.e. not wildcarded).
        // Call IP to check that this is a valid local address.
        // We do this by looking up an NTE for the address; note
        // that this will fail if the scope id is specified
        // improperly or doesn't match exactly.
        //
        NTE = FindNetworkWithAddress(&LocalAddr, ScopeId);
        if (NTE == NULL) {
            // Not a local address.  Fail the request.
          BadAddr:
            KeReleaseSpinLock(&AddrObjTableLock, OldIrql);
            KeReleaseMutex(&AddrSDMutex, FALSE);
            ExFreePool(NewAO);
            return TDI_BAD_ADDR;
        }

        //
        // We don't actually want the NTE, we were just checking that
        // it exists.  So release our reference.
        //
        ReleaseNTE(NTE);

    } else {
        //
        // The user specified the wildcard address.
        // Insist that the scope id is zero.
        //
        if (ScopeId != 0)
            goto BadAddr;
    }

    //
    // The specified IP address is a valid local address.  Now we do
    // protocol-specific processing.  An exception is raw sockets: we
    // don't allocate port space for them, regardless of their protocol.
    //

    if (Protocol == IP_PROTOCOL_TCP) {
        PortBitmap = &PortBitmapTcp;
    } else if (Protocol == IP_PROTOCOL_UDP) {
        PortBitmap = &PortBitmapUdp;
    } else {
        PortBitmap = NULL;
    }

    if (!RawSock && PortBitmap) {
        //
        // If no port is specified we have to assign one.  If there is a
        // port specified, we need to make sure that the IPAddress/Port
        // combo isn't already open (unless Reuse is specified).  If the
        // input address is a wildcard, we need to make sure the address
        // isn't open on any local ip address.
        //
        if (Port == WILDCARD_PORT) {
            // Have a wildcard port, need to assign an address.
            Port = NextUserPort;

            for (i = 0; i < NUM_USER_PORTS; i++, Port++) {
                ushort NetPort;  // Port in net byte order.

                if (Port > MaxUserPort) {
                    Port = MIN_USER_PORT;
                    RebuildAddrObjBitmap();
                }

                NetPort = net_short(Port);

                if (IP6_ADDR_EQUAL(&LocalAddr, &UnspecifiedAddr)) {
                    // Wildcard IP address.
                    if (PortBitmap) {
                        if (!RtlCheckBit(PortBitmap, Port))
                            break;
                        else
                            continue;
                    } else {
                        ExistingAO = FindAnyAddrObj(NetPort, (uchar)Protocol);
                    }
                } else {
                    ExistingAO = GetBestAddrObj(&LocalAddr, NULL, ScopeId, 
                                                NetPort, (uchar)Protocol, NULL);
                }

                if (ExistingAO == NULL)
                    break;  // Found an unused port.
            }

            if (i == NUM_USER_PORTS) {
                // Couldn't find a free port.
                KeReleaseSpinLock(&AddrObjTableLock, OldIrql);
                KeReleaseMutex(&AddrSDMutex, FALSE);
                ExFreePool(NewAO);
                return TDI_NO_FREE_ADDR;
            }
            NextUserPort = Port + 1;
            Port = net_short(Port);

        } else {
            //
            // A particular port was specified.
            //

            // Don't check if a DHCP address is specified.
            if (!DHCPAddr) {
                TDI_STATUS Status;

                //
                // See if we already have this address open and, if so,
                // decide whether this request should succeed.
                //
                Status = CheckAddrReuse(Request, Protocol, &LocalAddr, ScopeId,
                                        Port, Reuse, AddrSD, &OldIrql);
                if (Status != TDI_SUCCESS) {
                    KeReleaseSpinLock(&AddrObjTableLock, OldIrql);
                    KeReleaseMutex(&AddrSDMutex, FALSE);
                    ExFreePool(NewAO);
                    return Status;
                }
            }
        }

        //
        // We have a new AO.  Set up the protocol specific portions.
        //
        if (Protocol == IP_PROTOCOL_UDP) {
            NewAO->ao_dgsend = UDPSend;
            NewAO->ao_maxdgsize = 0xFFFF - sizeof(UDPHeader);
        }

    } else {
        //
        // Either we have a raw socket or this is a protocol for which
        // we don't allocate a port.  Open over Raw IP.
        //

        ASSERT(!DHCPAddr);

        //
        // We must set the port to zero.  This puts all the raw sockets
        // in one hash bucket, which is necessary for GetAddrObj to
        // work correctly.  It wouldn't be a bad idea to come up with
        // a better scheme...
        //
        Port = 0;
        NewAO->ao_dgsend = RawSend;
        NewAO->ao_maxdgsize = 0xFFFF;
        NewAO->ao_flags |= AO_RAW_FLAG;

        IF_TCPDBG(TCP_DEBUG_RAW) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "raw open protocol %u AO %lx\n", Protocol, NewAO));
        }
    }

    // When we get here, we know we're creating a brand new address object.
    // Port contains the port in question, and NewAO points to the newly
    // created AO.

    KeInitializeSpinLock(&NewAO->ao_lock);
    ExInitializeWorkItem(&NewAO->ao_workitem, RequestWorker, NewAO);
    INITQ(&NewAO->ao_sendq);
    INITQ(&NewAO->ao_rcvq);
    INITQ(&NewAO->ao_activeq);
    INITQ(&NewAO->ao_idleq);
    INITQ(&NewAO->ao_listenq);
    NewAO->ao_port = Port;
    NewAO->ao_addr = LocalAddr;
    NewAO->ao_scope_id = ScopeId;
    NewAO->ao_prot = (uchar)Protocol;
    NewAO->ao_ucast_hops = -1;  // This causes system default to be used.
    NewAO->ao_mcast_hops = -1;  // This causes system default to be used.
    NewAO->ao_mcast_loop = TRUE;// Multicast loopback is on by default.
#if DBG
    NewAO->ao_sig = ao_signature;
#endif
    NewAO->ao_sd = AddrSD;
    NewAO->ao_flags |= AO_VALID_FLAG;  // AO is valid.
    NewAO->ao_protect = PROTECTION_LEVEL_DEFAULT;

    if (DHCPAddr)
        NewAO->ao_flags |= AO_DHCP_FLAG;

    if (Reuse) {
        SET_AO_SHARE(NewAO);
    }

    NewAO->ao_owningpid = HandleToUlong(PsGetCurrentProcessId());

    //
    // Note the following fields are left zero - which has this effect:
    //
    // ao_mcast_if - use the routing table by default.
    // ao_udp_cksum_cover - checksum everything.
    //

    InsertAddrObj(NewAO);
    if (PortBitmap) {
        RtlSetBit(PortBitmap, net_short(Port));
    }
    KeReleaseSpinLock(&AddrObjTableLock, OldIrql);
    KeReleaseMutex(&AddrSDMutex, FALSE);
    Request->Handle.AddressHandle = NewAO;
    return TDI_SUCCESS;
}


//* DeleteAO - Delete an address object.
//
//  The internal routine to delete an address object.  We complete any pending
//  requests with errors, and remove and free the address object.
//
void                     //  Returns: Nothing.
DeleteAO(
    AddrObj *DeletedAO)  // AddrObj to be deleted.
{
    KIRQL Irql0;  // One per lock nesting level.
#ifndef UDP_ONLY
    TCB *TCBHead = NULL, *CurrentTCB;
    TCPConn *Conn;
    Queue *Temp;
    Queue *CurrentQ;
    RequestCompleteRoutine Rtn;  // Completion routine.
    PVOID Context;  // User context for completion routine.
#endif
    AOMCastAddr *AMA;
    PSECURITY_DESCRIPTOR AddrSD;

    CHECK_STRUCT(DeletedAO, ao);
    ASSERT(!AO_VALID(DeletedAO));
    ASSERT(DeletedAO->ao_usecnt == 0);

    KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
    KeAcquireSpinLockAtDpcLevel(&DGSendReqLock);
    KeAcquireSpinLockAtDpcLevel(&DeletedAO->ao_lock);

    // If he's on an oor queue, remove him.
    if (AO_OOR(DeletedAO))
        REMOVEQ(&DeletedAO->ao_pendq);
    KeReleaseSpinLockFromDpcLevel(&DGSendReqLock);

    RemoveAddrObj(DeletedAO);

#ifndef UDP_ONLY
    // Walk down the list of associated connections and zap their AO pointers.
    // For each connection, we need to shut down the connection if it's active.
    // If the connection isn't already closing, we'll put a reference on it
    // so that it can't go away while we're dealing with the AO, and put it
    // on a list.  On our way out we'll walk down that list and zap each
    // connection.
    CurrentQ = &DeletedAO->ao_activeq;

    for (;;) {
        Temp = QHEAD(CurrentQ);
        while (Temp != QEND(CurrentQ)) {
            Conn = QSTRUCT(TCPConn, Temp, tc_q);

            //
            // Move our temp pointer to the next connection now,
            // since we may free this connection below.
            //
            Temp = QNEXT(Temp);

            //
            // We'll need to unlock the AO in order to look at the Conn.
            // While the AO is unlocked, we need to worry about the following
            // requests being issued on the Conn:
            //
            // TdiDisAssociateAddress, TdiConnect: we hold AddrObjTableLock
            //      so the requests are blocked.
            // TdiListen, FindListenConn: the AO is marked invalid already,
            //      so the requests will fail.
            // TdiAccept: this request doesn't update the AO<->Conn link
            //      (just Conn<->TCB) so we don't care about it.
            //
            KeReleaseSpinLockFromDpcLevel(&DeletedAO->ao_lock);
            KeAcquireSpinLockAtDpcLevel(&Conn->tc_ConnBlock->cb_lock);

            CHECK_STRUCT(Conn, tc);
            CurrentTCB = Conn->tc_tcb;
            if (CurrentTCB != NULL) {

                // We have a TCB.
                CHECK_STRUCT(CurrentTCB, tcb);
                KeAcquireSpinLockAtDpcLevel(&CurrentTCB->tcb_lock);
                if (CurrentTCB->tcb_state != TCB_CLOSED &&
                    !CLOSING(CurrentTCB)) {
                    // It's not closing.  Put a reference on it and save it
                    // on the list.
                    CurrentTCB->tcb_refcnt++;
                    CurrentTCB->tcb_aonext = TCBHead;
                    TCBHead = CurrentTCB;
                }
                CurrentTCB->tcb_conn = NULL;
                CurrentTCB->tcb_rcvind = NULL;
                if (CurrentTCB->tcb_rcvhndlr == IndicateData &&
                    CurrentTCB->tcb_indicated == 0) {
                    if (CurrentTCB->tcb_currcv != NULL) {
                        CurrentTCB->tcb_rcvhndlr = BufferData;
                    } else {
                        CurrentTCB->tcb_rcvhndlr = PendData;
                    }
                }
                KeReleaseSpinLockFromDpcLevel(&CurrentTCB->tcb_lock);

                //
                //  Subtract one from the connection's ref count, since we
                //  are about to remove this TCB from the connection.
                //
                if (--(Conn->tc_refcnt) == 0) {

                    //
                    // We need to execute the code for the done
                    // routine.  There are only three done routines that can
                    // be called.  CloseDone(), DisassocDone(), and DummyDone().
                    // We execute the respective code here to avoid freeing locks.
                    // Note:  DummyDone() does nothing.
                    //

                    if (Conn->tc_flags & CONN_CLOSING) {

                        //
                        // This is the relevant CloseDone() code.
                        //

                        Rtn = Conn->tc_rtn;
                        Context = Conn->tc_rtncontext;
                        KeReleaseSpinLockFromDpcLevel(
                            &Conn->tc_ConnBlock->cb_lock);

                        ExFreePool(Conn);
                        (*Rtn) (Context, TDI_SUCCESS, 0);

                    } else if (Conn->tc_flags & CONN_DISACC) {

                        //
                        // This is the relevant DisassocDone() code.
                        //

                        Rtn = Conn->tc_rtn;
                        Context = Conn->tc_rtncontext;
                        Conn->tc_flags &= ~CONN_DISACC;
                        Conn->tc_ao = NULL;
                        Conn->tc_tcb = NULL;
                        KeReleaseSpinLockFromDpcLevel(
                            &Conn->tc_ConnBlock->cb_lock);

                        (*Rtn) (Context, TDI_SUCCESS, 0);
                    } else {
                        Conn->tc_ao = NULL;
                        Conn->tc_tcb = NULL;
                        KeReleaseSpinLockFromDpcLevel(
                            &Conn->tc_ConnBlock->cb_lock);

                    }
                } else {
                    Conn->tc_ao = NULL;
                    Conn->tc_tcb = NULL;
                    KeReleaseSpinLockFromDpcLevel(&Conn->tc_ConnBlock->cb_lock);
                }
            } else {
                Conn->tc_ao = NULL;
                KeReleaseSpinLockFromDpcLevel(&Conn->tc_ConnBlock->cb_lock);
            }

            KeAcquireSpinLockAtDpcLevel(&DeletedAO->ao_lock);
        }

        if (CurrentQ == &DeletedAO->ao_activeq) {
            CurrentQ = &DeletedAO->ao_idleq;
        } else if (CurrentQ == &DeletedAO->ao_idleq) {
            CurrentQ = &DeletedAO->ao_listenq;
        } else {
            ASSERT(CurrentQ == &DeletedAO->ao_listenq);
            break;
        }
    }
#endif

    //
    // Release excess locks.  Note we release the locks in a different order
    // from which we acquired them, but must return to IRQ levels in the order
    // we left them.
    //
    KeReleaseSpinLockFromDpcLevel(&AddrObjTableLock);

    // We've removed him from the queues, and he's marked as invalid.  Return
    // pending requests with errors.

    // We still hold the lock on the AddrObj, although this may not be
    // neccessary.

    while (!EMPTYQ(&DeletedAO->ao_rcvq)) {
        DGRcvReq *Rcv;

        DEQUEUE(&DeletedAO->ao_rcvq, Rcv, DGRcvReq, drr_q);
        CHECK_STRUCT(Rcv, drr);

        KeReleaseSpinLock(&DeletedAO->ao_lock, Irql0);
        (*Rcv->drr_rtn)(Rcv->drr_context, (uint) TDI_ADDR_DELETED, 0);

        FreeDGRcvReq(Rcv);

        KeAcquireSpinLock(&DeletedAO->ao_lock, &Irql0);
    }

    // Now destroy any sends.
    while (!EMPTYQ(&DeletedAO->ao_sendq)) {
        DGSendReq *Send;

        DEQUEUE(&DeletedAO->ao_sendq, Send, DGSendReq, dsr_q);
        CHECK_STRUCT(Send, dsr);

        KeReleaseSpinLock(&DeletedAO->ao_lock, Irql0);
        (*Send->dsr_rtn)(Send->dsr_context, (uint) TDI_ADDR_DELETED, 0);

        KeAcquireSpinLock(&DGSendReqLock, &Irql0);
        FreeDGSendReq(Send);
        KeReleaseSpinLock(&DGSendReqLock, Irql0);

        KeAcquireSpinLock(&DeletedAO->ao_lock, &Irql0);
    }

    AddrSD = DeletedAO->ao_sd;

    KeReleaseSpinLock(&DeletedAO->ao_lock, Irql0);

    // Free any associated multicast addresses.
    AMA = DeletedAO->ao_mcastlist;
    while (AMA != NULL) {
        AOMCastAddr *CurrentAMA;

        // Remove the group address from the IP layer.
        MLDDropMCastAddr(AMA->ama_if, &AMA->ama_addr);

        CurrentAMA = AMA;
        AMA = AMA->ama_next;
        ExFreePool(CurrentAMA);
    }

    if (DeletedAO->ao_iflist != NULL) {
        ExFreePool(DeletedAO->ao_iflist);
    }

    if (AddrSD != NULL) {
        KeWaitForSingleObject(&AddrSDMutex, Executive, KernelMode, FALSE, NULL);
        ObDereferenceSecurityDescriptor(AddrSD, 1);
        KeReleaseMutex(&AddrSDMutex, FALSE);
    }

    ExFreePool(DeletedAO);

#ifndef UDP_ONLY
    // Now go down the TCB list, and destroy any we need to.
    CurrentTCB = TCBHead;
    while (CurrentTCB != NULL) {
        TCB *NextTCB;

        KeAcquireSpinLock(&CurrentTCB->tcb_lock, &Irql0);
        CurrentTCB->tcb_flags |= NEED_RST;  // Make sure we send a RST.
        NextTCB = CurrentTCB->tcb_aonext;
        TryToCloseTCB(CurrentTCB, TCB_CLOSE_ABORTED, Irql0);
        KeAcquireSpinLock(&CurrentTCB->tcb_lock, &Irql0);
        DerefTCB(CurrentTCB, Irql0);
        CurrentTCB = NextTCB;
    }
#endif
}

//* GetAORequest - Get an AO request structure.
//
//  A routine to allocate a request structure from our free list.
//
AORequest *  // Returns: Ptr to request struct, or NULL if we couldn't get one.
GetAORequest()
{
    AORequest *NewRequest;

    NewRequest = ExAllocatePool(NonPagedPool, sizeof(AORequest));
    if (NewRequest != NULL) {
#if DBG
        NewRequest->aor_sig = aor_signature;
#endif
    }

    return NewRequest;
}

//* FreeAORequest - Free an AO request structure.
//
//  Called to free an AORequest structure.
//
void  //  Returns: Nothing.
FreeAORequest(
    AORequest *Request)  // AORequest structure to be freed.
{
    CHECK_STRUCT(Request, aor);

    ExFreePool(Request);
}


//* TDICloseAddress - Close an address.
//
//  The user API to delete an address.  Basically, we destroy the local address
//  object if we can.
//
//  This routine is interlocked with the AO busy bit - if the busy bit is set,
//  we'll  just flag the AO for later deletion.
//
TDI_STATUS  // Returns: Status of attempt to delete the address -
            // (either pending or success).
TdiCloseAddress(
    PTDI_REQUEST Request)  // TDI_REQUEST structure for this request.
{
    AddrObj *DeletingAO;
    KIRQL OldIrql;

    DeletingAO = Request->Handle.AddressHandle;

    CHECK_STRUCT(DeletingAO, ao);

    KeAcquireSpinLock(&DeletingAO->ao_lock, &OldIrql);

    if (!AO_BUSY(DeletingAO) && !(DeletingAO->ao_usecnt)) {
        SET_AO_BUSY(DeletingAO);
        SET_AO_INVALID(DeletingAO);  // This address object is deleting.

        KeReleaseSpinLock(&DeletingAO->ao_lock, OldIrql);
        DeleteAO(DeletingAO);
        return TDI_SUCCESS;

    } else {

        AORequest *NewRequest, *OldRequest;
        RequestCompleteRoutine CmpltRtn;
        PVOID ReqContext;
        TDI_STATUS Status;

        // Check and see if we already have a delete in progress. If we don't
        // allocate and link up a delete request structure.
        if (!AO_REQUEST(DeletingAO, AO_DELETE)) {

            OldRequest = DeletingAO->ao_request;

            NewRequest = GetAORequest();

            if (NewRequest != NULL) {
                // Got a request.
                NewRequest->aor_rtn = Request->RequestNotifyObject;
                NewRequest->aor_context = Request->RequestContext;
                // Clear the option request, if there is one.
                CLEAR_AO_REQUEST(DeletingAO, AO_OPTIONS);

                SET_AO_REQUEST(DeletingAO, AO_DELETE);
                SET_AO_INVALID(DeletingAO);  // Address object is deleting.

                DeletingAO->ao_request = NewRequest;
                NewRequest->aor_next = NULL;
                KeReleaseSpinLock(&DeletingAO->ao_lock, OldIrql);

                while (OldRequest != NULL) {
                    AORequest *Temp;

                    CmpltRtn = OldRequest->aor_rtn;
                    ReqContext = OldRequest->aor_context;

                    (*CmpltRtn)(ReqContext, (uint) TDI_ADDR_DELETED, 0);
                    Temp = OldRequest;
                    OldRequest = OldRequest->aor_next;
                    FreeAORequest(Temp);
                }

                return TDI_PENDING;
            } else
                Status = TDI_NO_RESOURCES;
        } else
            Status = TDI_ADDR_INVALID;  // Delete already in progress.

        KeReleaseSpinLock(&DeletingAO->ao_lock, OldIrql);
        return Status;
    }
}

//* FindAOMCastAddr - Find a multicast address on an AddrObj.
//
//  A utility routine to find a multicast address on an AddrObj.  We also
//  return a pointer to it's predecessor, for use in deleting.
//
//  A loose comparison treats the unspecified interface (IFNo is 0)
//  specially, selecting the first matching multicast address.
//
AOMCastAddr *  // Returns: matching AMA structure, or NULL if there is none.
FindAOMCastAddr(
    AddrObj *AO,            // AddrObj to search.
    IPv6Addr *Addr,         // MCast address to search for.
    uint IFNo,              // The interface number.
    AOMCastAddr **PrevAMA,  // Pointer to where to return predecessor.
    BOOLEAN Loose)          // Special case the unspecified interface.
{
    AOMCastAddr *FoundAMA, *Temp;

    Temp = CONTAINING_RECORD(&AO->ao_mcastlist, AOMCastAddr, ama_next);
    FoundAMA = AO->ao_mcastlist;

    while (FoundAMA != NULL) {
        if (IP6_ADDR_EQUAL(Addr, &FoundAMA->ama_addr) &&
            ((IFNo == FoundAMA->ama_if) || ((IFNo == 0) && Loose)))
            break;
        Temp = FoundAMA;
        FoundAMA = FoundAMA->ama_next;
    }

    *PrevAMA = Temp;
    return FoundAMA;
}

//* MCastAddrOnAO - Test to see if a multicast address on an AddrObj.
//
//  A utility routine to test to see if a multicast address is on an AddrObj.
//
uint  // Returns: TRUE if Addr is on AO.
MCastAddrOnAO(
    AddrObj *AO,    // AddrObj to search.
    IPv6Addr *Addr)  // MCast address to search for.
{
    AOMCastAddr *FoundAMA;

    FoundAMA = AO->ao_mcastlist;

    while (FoundAMA != NULL) {
        if (IP6_ADDR_EQUAL(Addr, &FoundAMA->ama_addr))
            return(TRUE);
        FoundAMA = FoundAMA->ama_next;
    }
    return(FALSE);
}

//* DoesAOAllowPacket - Test to see if an AO is allowed to receive a packet.
//
// A utility routine to test whether the interface list and protection level 
// of an AddrObj will accept a packet that arrives on a given interface, 
// from a given remote address.
//
int // Returns: TRUE if AO can accept packet.
DoesAOAllowPacket(
    AddrObj *AO,          // AddrObj to test.
    Interface *IF,        // Interface on which the packet arrived.
    IPv6Addr *RemoteAddr) // Remote address from which the packet arrived.
{
    //
    // See if an interface list was specified.
    //
    if ((AO->ao_iflist != NULL) &&
        IP6_ADDR_EQUAL(&AO->ao_addr, &UnspecifiedAddr) &&
        (FindIfIndexOnAO(AO, IF) == 0))
        return FALSE;

    //
    // Only accept Teredo if the protection level is unrestricted.
    //
    if ((IF->Type == IF_TYPE_TUNNEL_TEREDO) &&
        (AO->ao_protect != PROTECTION_LEVEL_UNRESTRICTED))
        return FALSE;

    //
    // If the level is restricted, disallow global addresses which
    // are not known to be within one of our sites.  Note that we
    // cannot use the IsGlobal() macro here, since we want v4-compatible
    // addresses, etc., to be treated as global.
    //
    if ((AO->ao_protect == PROTECTION_LEVEL_RESTRICTED) &&
        !IsSiteLocal(RemoteAddr) && 
        !IsLinkLocal(RemoteAddr) &&
        !IsLoopback(RemoteAddr) &&
        (SitePrefixMatch(RemoteAddr) == 0))
        return FALSE;

    //
    // TODO: Should eventually replace the simple firewall check here 
    // with hooks for ICF.
    //
    if ((IF->Flags & IF_FLAG_FIREWALL_ENABLED) && 
        (AO->ao_dgsend != NULL) &&
        !AO_SENTDATA(AO))
        return FALSE;
        
    return TRUE;
}

//* SetAOOptions - Set AddrObj options.
//
//  The set options worker routine, called when we've validated the buffer
//  and know that the AddrObj isn't busy.
//
TDI_STATUS  // Returns: TDI_STATUS of attempt.
SetAOOptions(
    AddrObj *OptionAO,  // AddrObj for which options are being set.
    uint ID,
    uint Length,
    uchar *Options)     // AOOption buffer of options.
{
    IP_STATUS IPStatus;  // Status of IP option set request.
    KIRQL OldIrql;
    TDI_STATUS Status;
    AOMCastAddr *AMA, *PrevAMA;

    ASSERT(AO_BUSY(OptionAO));

    if (Length == 0)
        return TDI_BAD_OPTION;

    if (ID == AO_OPTION_UNBIND) {
        KeAcquireSpinLock(&AddrObjTableLock, &OldIrql);
        RemoveAddrObj(OptionAO);
        KeReleaseSpinLock(&AddrObjTableLock, OldIrql);
        return TDI_SUCCESS;
    }

    Status = TDI_SUCCESS;
    KeAcquireSpinLock(&OptionAO->ao_lock, &OldIrql);

    switch (ID) {

    case AO_OPTION_TTL:
        if (Length >= sizeof(int)) {
            int Hops = (int) *Options;
            if ((Hops >= -1) && (Hops <= 255)) {
                OptionAO->ao_ucast_hops = Hops;
                break;
            }
        }
        Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_MCASTLOOP:
        if (Length >= sizeof(int)) {
            uint Loop = (uint) *Options;
            if (Loop <= TRUE) {
                OptionAO->ao_mcast_loop = Loop;
                break;
            }
        }
        Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_MCASTTTL:
        if (Length >= sizeof(int)) {
            int Hops = (int) *Options;
            if ((Hops >= -1) && (Hops <= 255)) {
                OptionAO->ao_mcast_hops = Hops;
                break;
            }
        }
        Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_MCASTIF:
        if (Length >= sizeof(uint)) {
            OptionAO->ao_mcast_if = (uint) *Options;
        } else
            Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_ADD_MCAST:
    case AO_OPTION_DEL_MCAST:
        if (Length >= sizeof(IPV6_MREQ)) {
            IPV6_MREQ *Req = (IPV6_MREQ *)Options;
            BOOLEAN IsInterfaceUnspecified = (Req->ipv6mr_interface == 0);

            //
            // Look for this multicast address on this Address Object.
            //
            // NOTE: A loose comparison of the interface index provides
            // the following behavior (when ipv6mr_interface is 0):
            // IPV6_ADD_MEMBERSHIP fails if the specified multicast
            // group has already been added to any interface.
            // IPV6_DROP_MEMBERSHIP drops the first matching multicast
            // group.
            //
            AMA = FindAOMCastAddr(OptionAO, &Req->ipv6mr_multiaddr,
                                  Req->ipv6mr_interface, &PrevAMA, TRUE);

            if (ID == AO_OPTION_ADD_MCAST) {
                // This is an add request.  Fail it if it's already there.
                if (AMA != NULL) {
                    // Address is already present on AO.
                    Status = TDI_BAD_OPTION;
                    break;
                }
                AMA = ExAllocatePool(NonPagedPool, sizeof(AOMCastAddr));
                if (AMA == NULL) {
                    // Couldn't get the resource we need.
                    Status = TDI_NO_RESOURCES;
                    break;
                }

                // Add it to the list.
                AMA->ama_next = OptionAO->ao_mcastlist;
                OptionAO->ao_mcastlist = AMA;

                // Fill in the address and interface information.
                AMA->ama_addr = Req->ipv6mr_multiaddr;
                AMA->ama_if = Req->ipv6mr_interface;

            } else {
                // This is a delete request.  Fail it if it's not there.
                if (AMA == NULL) {
                    // Address is not present on AO.
                    Status = TDI_BAD_OPTION;
                    break;
                }

                // Remove it from the list.
                PrevAMA->ama_next = AMA->ama_next;
                ExFreePool(AMA);
            }

            // Drop the AO lock since MLDAddMCastAddr/MLDDropMCastAddr
            // assume that they are called with no locks held.
            KeReleaseSpinLock(&OptionAO->ao_lock, OldIrql);
            if (ID == AO_OPTION_ADD_MCAST) {
                // If the interface is unspecified, MLDAddMCastAddr will
                // try to pick a reasonable interface and then return
                // the interface number that it picked.
                IPStatus = MLDAddMCastAddr(&Req->ipv6mr_interface,
                                           &Req->ipv6mr_multiaddr);
            } else
                IPStatus = MLDDropMCastAddr(Req->ipv6mr_interface,
                                            &Req->ipv6mr_multiaddr);
            KeAcquireSpinLock(&OptionAO->ao_lock, &OldIrql);

            // Since we dropped the AO lock, we have to search for our
            // AMA again if we need it.  In fact, it might even have
            // been deleted!
            if ((ID == AO_OPTION_ADD_MCAST) &&
                ((IPStatus != TDI_SUCCESS) || IsInterfaceUnspecified)) {
                AMA = FindAOMCastAddr(
                    OptionAO, &Req->ipv6mr_multiaddr,
                    IsInterfaceUnspecified ? 0 : Req->ipv6mr_interface,
                    &PrevAMA, FALSE);
                if (AMA != NULL) {
                    if (IPStatus != TDI_SUCCESS) {
                        // Some problem adding or deleting.  If we were
                        // adding, we remove and free the one we just added.
                        PrevAMA->ama_next = AMA->ama_next;
                        ExFreePool(AMA);
                    } else {
                        // Interface 0 was specified, assign AMA->ama_if
                        // to the interface selected by MLDAddMCastAddr.
                        // Hence, incoming multicast packets will only
                        // be accepted on this AMA if they arrive on the
                        // chosen interface.
                        AMA->ama_if = Req->ipv6mr_interface;
                    }
                }
            }

            if (IPStatus != TDI_SUCCESS)
                Status = (IPStatus == IP_NO_RESOURCES) ? TDI_NO_RESOURCES :
                          TDI_ADDR_INVALID;

        } else
            Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_UDP_CKSUM_COVER:
        if (Length >= sizeof(ushort)) {
            ushort Value = *(ushort *)Options;
            if ((0 < Value) && (Value < sizeof(UDPHeader)))
                Status = TDI_BAD_OPTION;
            else
                OptionAO->ao_udp_cksum_cover = Value;
        } else
            Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_IP_HDRINCL:
        if (Length >= sizeof(int)) {
            uint HdrIncl = (uint) *Options;
            if (HdrIncl <= TRUE) {
                if (HdrIncl)
                    SET_AO_HDRINCL(OptionAO);
                else
                    CLEAR_AO_HDRINCL(OptionAO);
                break;
            }
        }
        Status = TDI_BAD_OPTION;
        break;

    case AO_OPTION_IFLIST:

        //
        // Determine whether the interface-list is being enabled or cleared.
        // When enabled, an empty zero-terminated interface-list is set.
        // When disabled, any existing interface-list is freed.
        //
        // In both cases, the 'ao_iflist' pointer in the object is replaced
        // using an interlocked operation to allow us to check the field
        // in the receive-path without first locking the address-object.
        //
        if (Options[0]) {
            if (OptionAO->ao_iflist) {
                Status = TDI_SUCCESS;
            } else if (!IP6_ADDR_EQUAL(&OptionAO->ao_addr, &UnspecifiedAddr)) {
                Status = TDI_INVALID_PARAMETER;
            } else {
                uint *IfList = ExAllocatePool(NonPagedPool, sizeof(uint));
                if (IfList == NULL) {
                    Status = TDI_NO_RESOURCES;
                } else {
                    *IfList = 0;
                    OptionAO->ao_iflist = IfList;
                    Status = TDI_SUCCESS;
                }
            }
        } else {
            if (OptionAO->ao_iflist) {
                ExFreePool(OptionAO->ao_iflist);
                OptionAO->ao_iflist = NULL;
            }
            Status = TDI_SUCCESS;
        }
        break;

    case AO_OPTION_ADD_IFLIST:

        //
        // An interface-index is being added to the object's interface-list
        // so verify that an interface-list exists and, if not, fail.
        // Otherwise, verify that the index specified is valid and, if so,
        // verify that the index is not already in the interface list.
        //

        if (OptionAO->ao_iflist == NULL) {
            Status = TDI_INVALID_PARAMETER;
        } else {
            uint IfIndex = *(uint *)Options;
            Interface *IF = FindInterfaceFromIndex(IfIndex);
            if (IF == NULL) {
                Status = TDI_ADDR_INVALID;
            } else {
                uint i = 0;
                ReleaseIF(IF);
                while (OptionAO->ao_iflist[i] != 0 &&
                       OptionAO->ao_iflist[i] != IfIndex) {
                    i++;
                }
                if (OptionAO->ao_iflist[i] == IfIndex) {
                    Status = TDI_SUCCESS;
                } else {

                    //
                    // The index to be added is not already present.
                    // Allocate space for an expanded interface-list,
                    // copy the old interface-list, append the new index,
                    // and replace the old interface-list using an
                    // interlocked operation.
                    //
                    uint *IfList = ExAllocatePool(NonPagedPool,
                                                  (i + 2) * sizeof(uint));
                    if (IfList == NULL) {
                        Status = TDI_NO_RESOURCES;
                    } else {
                        RtlCopyMemory(IfList, OptionAO->ao_iflist,
                                      i * sizeof(uint));
                        IfList[i] = IfIndex;
                        IfList[i + 1] = 0;
                        ExFreePool(OptionAO->ao_iflist);
                        OptionAO->ao_iflist = IfList;
                        Status = TDI_SUCCESS;
                    }
                }
            }
        }
        break;

    case AO_OPTION_DEL_IFLIST:

        //
        // An index is being removed from the object's interface-list,
        // so verify that an interface-list exists and, if not, fail.
        // Otherwise, search the list for the index and, if not found, fail.
        //
        // N.B. We do not validate the index first in this case, to allow
        // an index to be removed even after the corresponding interface
        // is no longer present.
        //
        if (OptionAO->ao_iflist == NULL) {
            Status = TDI_INVALID_PARAMETER;
        } else {
            uint IfIndex = *(uint *) Options;
            if (IfIndex == 0) {
                Status = TDI_ADDR_INVALID;
            } else {
                uint j = (uint)-1;
                uint i = 0;
                while (OptionAO->ao_iflist[i] != 0) {
                    if (OptionAO->ao_iflist[i] == IfIndex) {
                        j = i;
                    }
                    i++;
                }
                if (j == (uint)-1) {
                    Status = TDI_ADDR_INVALID;
                } else {

                    //
                    // We've found the index to be removed.
                    // Allocate a truncated interface-list, copy the old
                    // interface-list excluding the removed index, and
                    // replace the old interface-list using an interlocked
                    // operation.
                    //
                    uint *IfList = ExAllocatePool(NonPagedPool,
                                                  i * sizeof(uint));
                    if (IfList == NULL) {
                        Status = TDI_NO_RESOURCES;
                    } else {
                        i = 0;
                        j = 0;
                        while (OptionAO->ao_iflist[i] != 0) {
                            if (OptionAO->ao_iflist[i] != IfIndex) {
                                IfList[j++] = OptionAO->ao_iflist[i];
                            }
                            i++;
                        }
                        IfList[j] = 0;
                        ExFreePool(OptionAO->ao_iflist);
                        OptionAO->ao_iflist = IfList;
                        Status = TDI_SUCCESS;
                    }
                }
            }
        }
        break;

    case AO_OPTION_IP_PKTINFO:
        if (Options[0])
            SET_AO_PKTINFO(OptionAO);
        else
            CLEAR_AO_PKTINFO(OptionAO);
        break;

    case AO_OPTION_RCV_HOPLIMIT:
        if (Options[0])
            SET_AO_RCV_HOPLIMIT(OptionAO);
        else
            CLEAR_AO_RCV_HOPLIMIT(OptionAO);
        break;

    case AO_OPTION_PROTECT:
        if (Length >= sizeof(int)) {
            int Level = (int) *Options;
            if ((Level == PROTECTION_LEVEL_RESTRICTED) ||
                (Level == PROTECTION_LEVEL_DEFAULT) ||
                (Level == PROTECTION_LEVEL_UNRESTRICTED)) {
                OptionAO->ao_protect = Level;
                break;
            }
        }
        Status = TDI_BAD_OPTION;
        break;

    default:
        Status = TDI_BAD_OPTION;
        break;
    }

    KeReleaseSpinLock(&OptionAO->ao_lock, OldIrql);

    return Status;
}

//* SetAddrOptions - Set options on an address object.
//
//  Called to set options on an address object.  We validate the buffer,
//  and if everything is OK we'll check the status of the AddrObj.  If
//  it's OK then we'll set them, otherwise we'll mark it for later use.
//
TDI_STATUS  // Returns: TDI_STATUS of attempt.
SetAddrOptions(
    PTDI_REQUEST Request,  // Request describing AddrObj for option set.
    uint ID,               // ID for option to be set.
    uint OptLength,        // Length of options.
    void *Options)         // Pointer to options.
{
    AddrObj *OptionAO;
    TDI_STATUS Status;
    KIRQL OldIrql;

    OptionAO = Request->Handle.AddressHandle;

    CHECK_STRUCT(OptionAO, ao);

    KeAcquireSpinLock(&OptionAO->ao_lock, &OldIrql);

    if (AO_VALID(OptionAO)) {
        if (!AO_BUSY(OptionAO) && OptionAO->ao_usecnt == 0) {
            SET_AO_BUSY(OptionAO);
            KeReleaseSpinLock(&OptionAO->ao_lock, OldIrql);

            Status = SetAOOptions(OptionAO, ID, OptLength, Options);

            KeAcquireSpinLock(&OptionAO->ao_lock, &OldIrql);
            if (!AO_PENDING(OptionAO)) {
                CLEAR_AO_BUSY(OptionAO);
                KeReleaseSpinLock(&OptionAO->ao_lock, OldIrql);
                return Status;
            } else {
                KeReleaseSpinLock(&OptionAO->ao_lock, OldIrql);
                ProcessAORequests(OptionAO);
                return Status;
            }
        } else {
            AORequest *NewRequest, *OldRequest;

            // The AddrObj is busy somehow.  We need to get a request, and link
            // him on the request list.

            NewRequest = GetAORequest();

            if (NewRequest != NULL) {
                // Got a request.
                NewRequest->aor_rtn = Request->RequestNotifyObject;
                NewRequest->aor_context = Request->RequestContext;
                NewRequest->aor_id = ID;
                NewRequest->aor_length = OptLength;
                NewRequest->aor_buffer = Options;
                NewRequest->aor_next = NULL;
                // Set the option request.
                SET_AO_REQUEST(OptionAO, AO_OPTIONS);

                OldRequest = CONTAINING_RECORD(&OptionAO->ao_request,
                                               AORequest, aor_next);

                while (OldRequest->aor_next != NULL)
                    OldRequest = OldRequest->aor_next;

                OldRequest->aor_next = NewRequest;
                KeReleaseSpinLock(&OptionAO->ao_lock, OldIrql);

                return TDI_PENDING;
            } else
                Status = TDI_NO_RESOURCES;
        }
    } else
        Status = TDI_ADDR_INVALID;

    KeReleaseSpinLock(&OptionAO->ao_lock, OldIrql);
    return Status;
}

//* TDISetEvent - Set a handler for a particular event.
//
//  This is the user API to set an event.  It's pretty simple, we just
//  grab the lock on the AddrObj and fill in the event.
//
//  This routine never pends.
//
TDI_STATUS  //  Returns: TDI_SUCCESS if it works, an error if it doesn't.
TdiSetEvent(
    PVOID Handle,   // Pointer to address object.
    int Type,       // Event being set.
    PVOID Handler,  // Handler to call for event.
    PVOID Context)  // Context to pass to event.
{
    AddrObj *EventAO;
    KIRQL OldIrql;
    TDI_STATUS Status;

    EventAO = (AddrObj *)Handle;

    CHECK_STRUCT(EventAO, ao);
    if (!AO_VALID(EventAO))
        return TDI_ADDR_INVALID;

    KeAcquireSpinLock(&EventAO->ao_lock, &OldIrql);

    Status = TDI_SUCCESS;
    switch (Type) {

        case TDI_EVENT_CONNECT:
            EventAO->ao_connect = Handler;
            EventAO->ao_conncontext = Context;
            break;
        case TDI_EVENT_DISCONNECT:
            EventAO->ao_disconnect = Handler;
            EventAO->ao_disconncontext = Context;
            break;
        case TDI_EVENT_ERROR:
            EventAO->ao_error = Handler;
            EventAO->ao_errcontext = Context;
            break;
        case TDI_EVENT_RECEIVE:
            EventAO->ao_rcv = Handler;
            EventAO->ao_rcvcontext = Context;
            break;
        case TDI_EVENT_RECEIVE_DATAGRAM:
            EventAO->ao_rcvdg = Handler;
            EventAO->ao_rcvdgcontext = Context;
            break;
        case TDI_EVENT_RECEIVE_EXPEDITED:
            EventAO->ao_exprcv = Handler;
            EventAO->ao_exprcvcontext = Context;
            break;

        case TDI_EVENT_ERROR_EX:
            EventAO->ao_errorex = Handler;
            EventAO->ao_errorexcontext = Context;
            break;

        default:
            Status = TDI_BAD_EVENT_TYPE;
            break;
    }

    KeReleaseSpinLock(&EventAO->ao_lock, OldIrql);
    return Status;
}

//* ProcessAORequests - Process pending requests on an AddrObj.
//
//  This is the delayed request processing routine, called when we've
//  done something that used the busy bit.  We examine the pending
//  requests flags, and dispatch the requests appropriately.
//
void                     // Returns: Nothing.
ProcessAORequests(
    AddrObj *RequestAO)  // AddrObj to be processed.
{
    KIRQL OldIrql;
    AORequest *Request;

    CHECK_STRUCT(RequestAO, ao);
    ASSERT(AO_BUSY(RequestAO));
    ASSERT(RequestAO->ao_usecnt == 0);

    KeAcquireSpinLock(&RequestAO->ao_lock, &OldIrql);

    while (AO_PENDING(RequestAO))  {
        Request = RequestAO->ao_request;

        if (AO_REQUEST(RequestAO, AO_DELETE)) {
            ASSERT(Request != NULL);
            ASSERT(!AO_REQUEST(RequestAO, AO_OPTIONS));
            KeReleaseSpinLock(&RequestAO->ao_lock, OldIrql);
            DeleteAO(RequestAO);
            (*Request->aor_rtn)(Request->aor_context, TDI_SUCCESS, 0);
            FreeAORequest(Request);
            return;                 // Deleted him, so get out.
        }

        // Now handle options request.
        while (AO_REQUEST(RequestAO, AO_OPTIONS)) {
            TDI_STATUS Status;

            // Have an option request.
            Request = RequestAO->ao_request;
            RequestAO->ao_request = Request->aor_next;
            if (RequestAO->ao_request == NULL)
                CLEAR_AO_REQUEST(RequestAO, AO_OPTIONS);

            ASSERT(Request != NULL);
            KeReleaseSpinLock(&RequestAO->ao_lock, OldIrql);

            Status = SetAOOptions(RequestAO, Request->aor_id,
                                  Request->aor_length, Request->aor_buffer);
            (*Request->aor_rtn)(Request->aor_context, Status, 0);
            FreeAORequest(Request);

            KeAcquireSpinLock(&RequestAO->ao_lock, &OldIrql);
        }

        // We've done options, now try sends.
        if (AO_REQUEST(RequestAO, AO_SEND)) {
            DGSendProc SendProc;
            DGSendReq *SendReq;

            // Need to send. Clear the busy flag, bump the send count, and
            // get the send request.
            if (!EMPTYQ(&RequestAO->ao_sendq)) {
                DEQUEUE(&RequestAO->ao_sendq, SendReq, DGSendReq, dsr_q);
                CLEAR_AO_BUSY(RequestAO);
                RequestAO->ao_usecnt++;
                SendProc = RequestAO->ao_dgsend;
                KeReleaseSpinLock(&RequestAO->ao_lock, OldIrql);
                (*SendProc)(RequestAO, SendReq);
                KeAcquireSpinLock(&RequestAO->ao_lock, &OldIrql);
                // If there aren't any other pending sends, set the busy bit.
                if (!(--RequestAO->ao_usecnt))
                    SET_AO_BUSY(RequestAO);
                else
                    break;  // Still sending, so get out.
            } else {
                // Had the send request set, but no send! Odd....
                KdBreakPoint();
                CLEAR_AO_REQUEST(RequestAO, AO_SEND);
            }
        }
    }

    // We're done here.
    CLEAR_AO_BUSY(RequestAO);
    KeReleaseSpinLock(&RequestAO->ao_lock, OldIrql);
}


//* DelayDerefAO - Dereference an AddrObj, and schedule an event.
//
//  Called when we are done with an address object, and need to
//  derefrence it.  We dec the usecount, and if it goes to 0 and
//  if there are pending actions we'll schedule an event to deal
//  with them.
//
void  // Returns: Nothing.
DelayDerefAO(
    AddrObj *RequestAO)  // AddrObj to be processed.
{
    KIRQL OldIrql;

    KeAcquireSpinLock(&RequestAO->ao_lock, &OldIrql);

    RequestAO->ao_usecnt--;

    if (!RequestAO->ao_usecnt && !AO_BUSY(RequestAO)) {
        if (AO_PENDING(RequestAO)) {
            SET_AO_BUSY(RequestAO);
            KeReleaseSpinLock(&RequestAO->ao_lock, OldIrql);
            ExQueueWorkItem(&RequestAO->ao_workitem, CriticalWorkQueue);
            return;
        }
    }
    KeReleaseSpinLock(&RequestAO->ao_lock, OldIrql);
}

//* DerefAO - Derefrence an AddrObj.
//
//  Called when we are done with an address object, and need to
//  derefrence it.  We dec the usecount, and if it goes to 0 and
//  if there are pending actions we'll call the process AO handler.
//
void                     // Returns: Nothing.
DerefAO(
    AddrObj *RequestAO)  // AddrObj to be processed.
{
    KIRQL OldIrql;

    KeAcquireSpinLock(&RequestAO->ao_lock, &OldIrql);

    RequestAO->ao_usecnt--;

    if (!RequestAO->ao_usecnt && !AO_BUSY(RequestAO)) {
        if (AO_PENDING(RequestAO)) {
            SET_AO_BUSY(RequestAO);
            KeReleaseSpinLock(&RequestAO->ao_lock, OldIrql);
            ProcessAORequests(RequestAO);
            return;
        }
    }

    KeReleaseSpinLock(&RequestAO->ao_lock, OldIrql);
}

#pragma BEGIN_INIT

//* InitAddr - Initialize the address object stuff.
//
//  Called during init time to initalize the address object stuff.
//
int  // Returns: True if we succeed, False if we fail.
InitAddr()
{
    uint i;

    KeInitializeSpinLock(&AddrObjTableLock);
    KeInitializeMutex(&AddrSDMutex, FALSE);
    if (MmIsThisAnNtAsSystem()) {
#if defined(_WIN64)
        AddrObjTableSize = DEFAULT_AO_TABLE_SIZE_AS64;
#else
        AddrObjTableSize = DEFAULT_AO_TABLE_SIZE_AS;
#endif
    } else {
        AddrObjTableSize = DEFAULT_AO_TABLE_SIZE_WS;
    }

    AddrObjTable = ExAllocatePool(NonPagedPool,
                                  AddrObjTableSize * sizeof(AddrObj*));
    if (AddrObjTable == NULL) {
        return FALSE;
    }

    for (i = 0; i < AddrObjTableSize; i++)
        AddrObjTable[i] = NULL;

    LastAO = NULL;

    RtlInitializeBitMap(&PortBitmapTcp, PortBitmapBufferTcp, 1 << 16);
    RtlInitializeBitMap(&PortBitmapUdp, PortBitmapBufferUdp, 1 << 16);
    RtlClearAllBits(&PortBitmapTcp);
    RtlClearAllBits(&PortBitmapUdp);

    return TRUE;
}
#pragma END_INIT

//* AddrUnload
//
//  Cleanup and prepare the address management code for stack unload.
//
void
AddrUnload(void)
{
    ExFreePool(AddrObjTable);
    AddrObjTable = NULL;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\info.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This file contains the code for dealing with TDI Query/Set
// information calls.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tdiinfo.h"
#include "ndis.h"
#include "info.h"
#include "tdiinfo.h"
#include "tcpcfg.h"
#include "udp.h"
#include "tcpsend.h"

extern long
IPv6QueryInfo(TDIObjectID * ID, PNDIS_BUFFER Buffer, uint * Size,
              void *Context, uint ContextSize);

#ifndef UDP_ONLY
#define MY_SERVICE_FLAGS (TDI_SERVICE_CONNECTION_MODE     | \
                          TDI_SERVICE_ORDERLY_RELEASE     | \
                          TDI_SERVICE_CONNECTIONLESS_MODE | \
                          TDI_SERVICE_ERROR_FREE_DELIVERY | \
                          TDI_SERVICE_BROADCAST_SUPPORTED | \
                          TDI_SERVICE_DELAYED_ACCEPTANCE  | \
                          TDI_SERVICE_EXPEDITED_DATA      | \
                          TDI_SERVICE_FORCE_ACCESS_CHECK  | \
                          TDI_SERVICE_ACCEPT_LOCAL_ADDR   | \
                          TDI_SERVICE_NO_ZERO_LENGTH      | \
                          TDI_SERVICE_ADDRESS_SECURITY)
#else
#define MY_SERVICE_FLAGS (TDI_SERVICE_CONNECTIONLESS_MODE | \
                          TDI_SERVICE_BROADCAST_SUPPORTED)
#endif

extern LARGE_INTEGER StartTime;
extern KSPIN_LOCK AddrObjTableLock;

#ifndef UDP_ONLY
TCPStats TStats;
#endif

UDPStats UStats;

struct ReadTableStruct {
    uint (*rts_validate)(void *Context, uint *Valid);
    uint (*rts_readnext)(void *Context, void *OutBuf);
};

struct ReadTableStruct ReadAOTable = {ValidateAOContext, ReadNextAO};

#ifndef UDP_ONLY

struct ReadTableStruct ReadTCBTable = {ValidateTCBContext, ReadNextTCB};

extern KSPIN_LOCK TCBTableLock;
#endif

extern KSPIN_LOCK AddrObjTableLock;

struct TDIEntityID *EntityList;
uint EntityCount;

//* TdiQueryInformation - Query Information handler.
//
//  The TDI QueryInformation routine.  Called when the client wants to
//  query information on a connection, the provider as a whole, or to
//  get statistics.
//
TDI_STATUS  // Returns: Status of attempt to query information.
TdiQueryInformation(
    PTDI_REQUEST Request,  // Request structure for this command.
    uint QueryType,        // Type of query to be performed.
    PNDIS_BUFFER Buffer,   // Buffer to place data info.
    uint *BufferSize,      // Pointer to size in bytes of buffer.
                           // On return, filled in with number of bytes copied.
    uint IsConn)           // Valid only for TDI_QUERY_ADDRESS_INFO.  TRUE if
                           // we are querying the address info on a connection.
{
    union {
        TDI_CONNECTION_INFO ConnInfo;
        TDI_ADDRESS_INFO AddrInfo;
        TDI_PROVIDER_INFO ProviderInfo;
        TDI_PROVIDER_STATISTICS ProviderStats;
    } InfoBuf;

    uint InfoSize;
    KIRQL Irql0, Irql1, Irql2;  // One per lock nesting level.
#ifndef UDP_ONLY
    TCPConn *Conn;
    TCB *InfoTCB;
#endif
    AddrObj *InfoAO;
    void *InfoPtr = NULL;
    uint Offset;
    uint Size;
    uint BytesCopied;

    switch (QueryType) {

    case TDI_QUERY_BROADCAST_ADDRESS:
        return TDI_INVALID_QUERY;
        break;

    case TDI_QUERY_PROVIDER_INFO:
        InfoBuf.ProviderInfo.Version = 0x100;
#ifndef UDP_ONLY
        InfoBuf.ProviderInfo.MaxSendSize = 0xffffffff;
#else
        InfoBuf.ProviderInfo.MaxSendSize = 0;
#endif
        InfoBuf.ProviderInfo.MaxConnectionUserData = 0;
        InfoBuf.ProviderInfo.MaxDatagramSize = 0xffff - sizeof(UDPHeader);
        InfoBuf.ProviderInfo.ServiceFlags = MY_SERVICE_FLAGS;
        InfoBuf.ProviderInfo.MinimumLookaheadData = 1;
        InfoBuf.ProviderInfo.MaximumLookaheadData = 0xffff;
        InfoBuf.ProviderInfo.NumberOfResources = 0;
        InfoBuf.ProviderInfo.StartTime = StartTime;
        InfoSize = sizeof(TDI_PROVIDER_INFO);
        InfoPtr = &InfoBuf.ProviderInfo;
        break;

    case TDI_QUERY_ADDRESS_INFO:
        InfoSize = sizeof(TDI_ADDRESS_INFO) - sizeof(TRANSPORT_ADDRESS) +
            TCP_TA_SIZE;
        RtlZeroMemory(&InfoBuf.AddrInfo, TCP_TA_SIZE);
        //
        // Since noone knows what this means, we'll set it to one.
        //
        InfoBuf.AddrInfo.ActivityCount = 1;

        if (IsConn) {
#ifdef UDP_ONLY
            return TDI_INVALID_QUERY;
#else

            KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
            Conn = GetConnFromConnID(
                        PtrToUlong(Request->Handle.ConnectionContext), &Irql1);

            if (Conn != NULL) {
                CHECK_STRUCT(Conn, tc);

                InfoTCB = Conn->tc_tcb;
                // If we have a TCB we'll return information about that TCB.
                // Otherwise we'll return info about the address object.
                if (InfoTCB != NULL) {
                    CHECK_STRUCT(InfoTCB, tcb);
                    KeAcquireSpinLock(&InfoTCB->tcb_lock, &Irql2);
                    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql2);
                    KeReleaseSpinLock(&AddrObjTableLock, Irql1);
                    BuildTDIAddress((uchar *)&InfoBuf.AddrInfo.Address,
                                    &InfoTCB->tcb_saddr,
                                    InfoTCB->tcb_sscope_id,
                                    InfoTCB->tcb_sport);
                    KeReleaseSpinLock(&InfoTCB->tcb_lock, Irql0);
                    InfoPtr = &InfoBuf.AddrInfo;
                    break;
                } else {
                    // No TCB, return info on the AddrObj.
                    InfoAO = Conn->tc_ao;
                    if (InfoAO != NULL) {
                        // We have an AddrObj.
                        CHECK_STRUCT(InfoAO, ao);
                        KeAcquireSpinLock(&InfoAO->ao_lock, &Irql2);
                        BuildTDIAddress((uchar *)&InfoBuf.AddrInfo.Address,
                                        &InfoAO->ao_addr,
                                        InfoAO->ao_scope_id,
                                        InfoAO->ao_port);
                        KeReleaseSpinLock(&InfoAO->ao_lock, Irql2);
                        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);
                        KeReleaseSpinLock(&AddrObjTableLock, Irql0);
                        InfoPtr = &InfoBuf.AddrInfo;
                        break;
                    } else
                        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);
                }
            }

            //
            // Fall through to here when we can't find the connection, or
            // the connection isn't associated.
            //
            KeReleaseSpinLock(&AddrObjTableLock, Irql0);
            return TDI_INVALID_CONNECTION;
            break;

#endif
        } else {
            // Asking for information on an addr. object.
            InfoAO = Request->Handle.AddressHandle;
            if (InfoAO == NULL)
                return TDI_ADDR_INVALID;

            CHECK_STRUCT(InfoAO, ao);

            KeAcquireSpinLock(&InfoAO->ao_lock, &Irql0);

            if (!AO_VALID(InfoAO)) {
                KeReleaseSpinLock(&InfoAO->ao_lock, Irql0);
                return TDI_ADDR_INVALID;
            }

            BuildTDIAddress((uchar *)&InfoBuf.AddrInfo.Address,
                            &InfoAO->ao_addr, InfoAO->ao_scope_id,
                            InfoAO->ao_port);
            KeReleaseSpinLock(&InfoAO->ao_lock, Irql0);
            InfoPtr = &InfoBuf.AddrInfo;
            break;
        }

        break;

    case TDI_QUERY_CONNECTION_INFO:
#ifndef UDP_ONLY
        InfoSize = sizeof(TDI_CONNECTION_INFO);
        Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext),
                                 &Irql0);

        if (Conn != NULL) {
            CHECK_STRUCT(Conn, tc);

            InfoTCB = Conn->tc_tcb;
            // If we have a TCB we'll return the information.
            // Otherwise we'll error out.
            if (InfoTCB != NULL) {
                CHECK_STRUCT(InfoTCB, tcb);
                KeAcquireSpinLock(&InfoTCB->tcb_lock, &Irql1);
                KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);
                RtlZeroMemory(&InfoBuf.ConnInfo, sizeof(TDI_CONNECTION_INFO));
                InfoBuf.ConnInfo.State = (ulong)InfoTCB->tcb_state;

                // IPv4 code called down into IP here to get PathBPS
                // for InfoTCB's saddr, daddr pair.
                InfoBuf.ConnInfo.Throughput.LowPart = 0xFFFFFFFF;
                InfoBuf.ConnInfo.Throughput.HighPart = 0xFFFFFFFF;

                // To figure the delay we use the rexmit timeout.  Our
                // rexmit timeout is roughly the round trip time plus
                // some slop, so we use half of that as the one way delay.
                InfoBuf.ConnInfo.Delay.LowPart =
                    (REXMIT_TO(InfoTCB) * MS_PER_TICK) / 2;
                InfoBuf.ConnInfo.Delay.HighPart = 0;
                //
                // Convert milliseconds to 100ns and negate for relative
                // time.
                //
                InfoBuf.ConnInfo.Delay = RtlExtendedIntegerMultiply(
                    InfoBuf.ConnInfo.Delay, 10000);

                ASSERT(InfoBuf.ConnInfo.Delay.HighPart == 0);

                InfoBuf.ConnInfo.Delay.QuadPart =
                    -InfoBuf.ConnInfo.Delay.QuadPart;

                KeReleaseSpinLock(&InfoTCB->tcb_lock, Irql0);
                InfoPtr = &InfoBuf.ConnInfo;
                break;
            } else
                KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
        }

        //
        // Come through here if we can't find the connection
        // or it has no TCB.
        //
        return TDI_INVALID_CONNECTION;
        break;

#else // UDP_ONLY
        return TDI_INVALID_QUERY;
        break;
#endif // UDP_ONLY
    case TDI_QUERY_PROVIDER_STATISTICS:
        RtlZeroMemory(&InfoBuf.ProviderStats, sizeof(TDI_PROVIDER_STATISTICS));
        InfoBuf.ProviderStats.Version = 0x100;
        InfoSize = sizeof(TDI_PROVIDER_STATISTICS);
        InfoPtr = &InfoBuf.ProviderStats;
        break;
    default:
        return TDI_INVALID_QUERY;
        break;
    }

    // When we get here, we've got the pointers set up and the information
    // filled in.

    ASSERT(InfoPtr != NULL);
    Offset = 0;
    Size = *BufferSize;
    (void)CopyFlatToNdis(Buffer, InfoPtr, MIN(InfoSize, Size), &Offset,
                         &BytesCopied);
    if (Size < InfoSize)
        return TDI_BUFFER_OVERFLOW;
    else {
        *BufferSize = InfoSize;
        return TDI_SUCCESS;
    }
}

//* TdiSetInformation - Set Information handler.
//
//  The TDI SetInformation routine.  Currently we don't allow anything to be
//  set.
//
TDI_STATUS  // Returns: Status of attempt to set information.
TdiSetInformation(
    PTDI_REQUEST Request,  // Request structure for this command.
    uint SetType,          // Type of set to be performed.
    PNDIS_BUFFER Buffer,   // Buffer to set from.
    uint BufferSize,       // Size in bytes of buffer.
    uint IsConn)           // Valid only for TDI_QUERY_ADDRESS_INFO. TRUE if
                           // we are setting the address info on a connection.
{
    UNREFERENCED_PARAMETER(Request);
    UNREFERENCED_PARAMETER(SetType);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferSize);
    UNREFERENCED_PARAMETER(IsConn);

    return TDI_INVALID_REQUEST;
}

//* TdiAction - Action handler.
//
//  The TDI Action routine.  Currently we don't support any actions.
//
TDI_STATUS  // Returns: Status of attempt to perform action.
TdiAction(
    PTDI_REQUEST Request,  // Request structure for this command.
    uint ActionType,       // Type of action to be performed.
    PNDIS_BUFFER Buffer,   // Buffer of action info.
    uint BufferSize)       // Size in bytes of buffer.
{
    UNREFERENCED_PARAMETER(Request);
    UNREFERENCED_PARAMETER(ActionType);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferSize);

    return TDI_INVALID_REQUEST;
}

//* CopyAO_TCPConn - Copy listening endpoints into connection table.
//
int
CopyAO_TCPConn(
    const AddrObj *AO,          // Address object to possibly copy.
    TCP6ConnTableEntry *Buffer) // Output buffer to fill in.
{
    if (AO == NULL)
        return 0;

    if ((!AO->ao_listencnt) && (AO->ao_prot == IP_PROTOCOL_TCP)) {
        Buffer->tct_state = TCP_CONN_LISTEN;

        // else if .. other cases can be added here ...

    } else {
        return 0;
    }

    Buffer->tct_localaddr = AO->ao_addr;
    Buffer->tct_localscopeid = AO->ao_scope_id;
    Buffer->tct_localport = AO->ao_port;
    RtlZeroMemory(&Buffer->tct_remoteaddr, sizeof(Buffer->tct_remoteaddr));
    Buffer->tct_remoteport = (ULONG) ((ULONG_PTR) AO & 0x0000ffff);
    Buffer->tct_remotescopeid = 0;
    Buffer->tct_owningpid = AO->ao_owningpid;

    return 1;
}

//* TdiQueryInformationEx - Extended TDI query information.
//
//  This is the new TDI query information handler.  We take in a TDIObjectID
//  structure, a buffer and length, and some context information, and return
//  the requested information if possible.
//
TDI_STATUS  // Returns: Status of attempt to get information.
TdiQueryInformationEx(
    PTDI_REQUEST Request,  // Request structure for this command.
    TDIObjectID *ID,       // Object ID.
    PNDIS_BUFFER Buffer,   // Buffer to be filled in.
    uint *Size,            // Pointer to size in bytes of Buffer.
                           // On return, filled with number of bytes written.
    void *Context,         // Context buffer.
    uint ContextSize)      // Size of context buffer.
{
    uint BufferSize = *Size;
    uint InfoSize;
    void *InfoPtr;
    uint Fixed;
    KIRQL Irql0 = 0, Irql1;
    KSPIN_LOCK *AOLockPtr = NULL;
    uint Offset = 0;
    uchar InfoBuffer[sizeof(TCP6ConnTableEntry)];
    uint BytesRead;
    uint Valid;
    uint Entity;
    uint BytesCopied;
    TCPStats TCPStatsListen;

    BOOLEAN TABLELOCK = FALSE;

    int lcount;
    AddrObj *pAO;
    TCP6ConnTableEntry tcp_ce;
    uint Index;
    int InfoTcpConn = 0;        // true if tcp conn info needed.

    // First check to see if he's querying for list of entities.
    Entity = ID->toi_entity.tei_entity;
    if (Entity == GENERIC_ENTITY) {
        *Size = 0;

        if (ID->toi_class  != INFO_CLASS_GENERIC ||
            ID->toi_type != INFO_TYPE_PROVIDER ||
            ID->toi_id != ENTITY_LIST_ID) {
            return TDI_INVALID_PARAMETER;
        }

        // Make sure we have room for it the list in the buffer.
        InfoSize = EntityCount * sizeof(TDIEntityID);

        if (BufferSize < InfoSize) {
            // Not enough room.
            return TDI_BUFFER_TOO_SMALL;
        }

        *Size = InfoSize;

        // Copy it in, free our temp. buffer, and return success.
        (void)CopyFlatToNdis(Buffer, (uchar *)EntityList, InfoSize, &Offset,
                             &BytesCopied);
        return TDI_SUCCESS;
    }

    //* Check the level.  If it can't be for us, pass it down.
#ifndef UDP_ONLY
    if (Entity != CO_TL_ENTITY &&  Entity != CL_TL_ENTITY) {
#else
    if (Entity != CL_TL_ENTITY) {
#endif
        // When we support multiple lower entities at this layer we'll have
        // to figure out which one to dispatch to. For now, just pass it
        // straight down.

        return IPv6QueryInfo(ID, Buffer, Size, Context, ContextSize);
    }

    if (ID->toi_entity.tei_instance != TL_INSTANCE) {
        // We only support a single instance.
        return TDI_INVALID_REQUEST;
    }

    // Zero returned parameters in case of an error below.
    *Size = 0;

    if (ID->toi_class == INFO_CLASS_GENERIC) {
        // This is a generic request.
        if (ID->toi_type == INFO_TYPE_PROVIDER &&
            ID->toi_id == ENTITY_TYPE_ID) {
            if (BufferSize >= sizeof(uint)) {
                *(uint *)&InfoBuffer[0] = (Entity == CO_TL_ENTITY) ? CO_TL_TCP
                    : CL_TL_UDP;
                (void)CopyFlatToNdis(Buffer, InfoBuffer, sizeof(uint), &Offset,
                                     &BytesCopied);
                return TDI_SUCCESS;
            } else
                return TDI_BUFFER_TOO_SMALL;
        }
        return TDI_INVALID_PARAMETER;
    }

    if (ID->toi_class == INFO_CLASS_PROTOCOL) {
        // Handle protocol specific class of information. For us, this is
        // the MIB-2 stuff or the minimal stuff we do for oob_inline support.

#ifndef UDP_ONLY
        if (ID->toi_type == INFO_TYPE_CONNECTION) {
            TCPConn *Conn;
            TCB *QueryTCB;
            TCPSocketAMInfo *AMInfo;

            if (BufferSize < sizeof(TCPSocketAMInfo) ||
                ID->toi_id != TCP_SOCKET_ATMARK)
                return TDI_INVALID_PARAMETER;

            AMInfo = (TCPSocketAMInfo *)InfoBuffer;

            Conn = GetConnFromConnID(
                        PtrToUlong(Request->Handle.ConnectionContext), &Irql0);

            if (Conn != NULL) {
                CHECK_STRUCT(Conn, tc);

                QueryTCB = Conn->tc_tcb;
                if (QueryTCB != NULL) {
                    CHECK_STRUCT(QueryTCB, tcb);
                    KeAcquireSpinLock(&QueryTCB->tcb_lock, &Irql1);
                    if ((QueryTCB->tcb_flags & (URG_INLINE | URG_VALID)) ==
                        (URG_INLINE | URG_VALID)) {
                        // We're in inline mode, and the urgent data fields are
                        // valid.
                        AMInfo->tsa_size = QueryTCB->tcb_urgend -
                            QueryTCB->tcb_urgstart + 1;
                        // Rcvnext - pendingcnt is the sequence number of the
                        // next byte of data that will be delivered to the
                        // client. Urgend - that value is the offset in the
                        // data stream of the end of urgent data.
                        AMInfo->tsa_offset = QueryTCB->tcb_urgend -
                            (QueryTCB->tcb_rcvnext - QueryTCB->tcb_pendingcnt);
                    } else {
                        AMInfo->tsa_size = 0;
                        AMInfo->tsa_offset = 0;
                    }
                    KeReleaseSpinLock(&QueryTCB->tcb_lock, Irql1);
                    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
                    *Size = sizeof(TCPSocketAMInfo);
                    CopyFlatToNdis(Buffer, InfoBuffer, sizeof(TCPSocketAMInfo),
                                   &Offset, &BytesCopied);
                    return TDI_SUCCESS;
                } else
                    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
            }
            return TDI_INVALID_PARAMETER;
        }

#endif
        if (ID->toi_type != INFO_TYPE_PROVIDER)
            return TDI_INVALID_PARAMETER;

        switch (ID->toi_id) {

        case UDP_MIB_STAT_ID:
#if UDP_MIB_STAT_ID != TCP_MIB_STAT_ID
        case TCP_MIB_STAT_ID:
#endif
            Fixed = TRUE;
            if (Entity == CL_TL_ENTITY) {
                InfoSize = sizeof(UDPStats);
                InfoPtr = &UStats;
            } else {
#ifndef UDP_ONLY
                TCPStatsListen = TStats;

                InfoSize = sizeof(TCPStatsListen);
                InfoPtr = &TCPStatsListen;
                lcount = 0;

                KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
                for (Index = 0; Index < AddrObjTableSize; Index++) {
                    pAO = AddrObjTable[Index];
                    while (pAO) {
                        lcount += CopyAO_TCPConn(pAO,
                                    &tcp_ce);
                        pAO = pAO->ao_next;
                    }
                }
                KeReleaseSpinLock(&AddrObjTableLock, Irql0);

                TCPStatsListen.ts_numconns += lcount;
#else
                return TDI_INVALID_PARAMETER;
#endif
            }
            break;
        case UDP_EX_TABLE_ID:
#if UDP_EX_TABLE_ID != TCP_EX_TABLE_ID
        case TCP_EX_TABLE_ID:
#endif
            Fixed = FALSE;
            if (Entity == CL_TL_ENTITY) {
                InfoSize = sizeof(UDP6ListenerEntry);
                InfoPtr = &ReadAOTable;
                KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
                AOLockPtr = &AddrObjTableLock;
            } else {
#ifndef UDP_ONLY
                InfoSize = sizeof(TCP6ConnTableEntry);
                InfoTcpConn = 1;
                InfoPtr = &ReadTCBTable;
                TABLELOCK = TRUE;
                KeAcquireSpinLock(&TCBTableLock, &Irql0);
#else
                return TDI_INVALID_PARAMETER;
#endif
            }
            break;
        default:
            return TDI_INVALID_PARAMETER;
            break;
        }

        if (Fixed) {
            if (BufferSize < InfoSize)
                return TDI_BUFFER_TOO_SMALL;

            *Size = InfoSize;

            (void)CopyFlatToNdis(Buffer, InfoPtr, InfoSize, &Offset,
                                 &BytesCopied);
            return TDI_SUCCESS;
        } else {
            struct ReadTableStruct *RTSPtr;
            uint ReadStatus;

            // Have a variable length (or mult-instance) structure to copy.
            // InfoPtr points to the structure describing the routines to
            // call to read the table.
            // Loop through up to CountWanted times, calling the routine
            // each time.
            BytesRead = 0;

            RTSPtr = InfoPtr;

            ReadStatus = (*(RTSPtr->rts_validate))(Context, &Valid);

            // If we successfully read something we'll continue. Otherwise
            // we'll bail out.
            if (!Valid) {
                if (TABLELOCK)
                    KeReleaseSpinLock(&TCBTableLock, Irql0);
                if (AOLockPtr) 
                    KeReleaseSpinLock(AOLockPtr, Irql0);
                return TDI_INVALID_PARAMETER;
            }

            while (ReadStatus)  {
                // The invariant here is that there is data in the table to
                // read. We may or may not have room for it. So ReadStatus
                // is TRUE, and BufferSize - BytesRead is the room left
                // in the buffer.
                if ((int)(BufferSize - BytesRead) >= (int)InfoSize) {
                    ReadStatus = (*(RTSPtr->rts_readnext))(Context,
                                                           InfoBuffer);
                    BytesRead += InfoSize;
                    Buffer = CopyFlatToNdis(Buffer, InfoBuffer, InfoSize,
                                            &Offset, &BytesCopied);
                } else
                    break;
            }

            if (TABLELOCK)
                KeReleaseSpinLock(&TCBTableLock, Irql0);

            if ((!ReadStatus) && InfoTcpConn) {
                if (!AOLockPtr) {
                    KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
                    AOLockPtr = &AddrObjTableLock;
                }
                for (Index = 0; Index < AddrObjTableSize; Index++) {
                    pAO = AddrObjTable[Index];
                    while (pAO) {
                        if (BufferSize < (BytesRead + InfoSize)) {
                            goto no_more_ao;
                        }
                        if (CopyAO_TCPConn(pAO, &tcp_ce)) {
                            ASSERT(BufferSize >= BytesRead);
                            Buffer = CopyFlatToNdis(Buffer, (void *)&tcp_ce,
                                                    InfoSize,
                                                    &Offset, &BytesCopied);
                            BytesRead += InfoSize;
                            ASSERT(BufferSize >= BytesRead);
                        }
                        pAO = pAO->ao_next;
                    }
                }
              no_more_ao:;
            }
            if (AOLockPtr)
                KeReleaseSpinLock(AOLockPtr, Irql0);
            *Size = BytesRead;
            return (!ReadStatus ? TDI_SUCCESS : TDI_BUFFER_OVERFLOW);
        }
    }

    if (ID->toi_class == INFO_CLASS_IMPLEMENTATION) {
        // We want to return implementation specific info.  For now, error out.
        return TDI_INVALID_PARAMETER;
    }

    return TDI_INVALID_PARAMETER;
}

//* TdiSetInfoEx - Extended TDI set information.
//
//  This is the new TDI set information handler.  We take in a TDIObjectID
//  structure, a buffer and length.  We set the object specifed by the ID
//  (and possibly by the Request) to the value specified in the buffer.
//
TDI_STATUS  // Returns: Status of attempt to get information.
TdiSetInformationEx(
    PTDI_REQUEST Request,  // Request structure for this command.
    TDIObjectID *ID,       // Object ID.
    void *Buffer,          // Buffer containing value to set.
    uint Size)             // Size in bytes of Buffer.
{
    TCP6ConnTableEntry *TCPEntry;
    KIRQL Irql0, Irql1;  // One per lock nesting level.
#ifndef UDP_ONLY
    TCB *SetTCB;
    TCPConn *Conn;
#endif
    uint Entity;
    TDI_STATUS Status;

    // Check the level.  If it can't be for us, pass it down.
    Entity = ID->toi_entity.tei_entity;

    if (Entity != CO_TL_ENTITY && Entity != CL_TL_ENTITY) {
        // Someday we'll have to figure out how to dispatch.
        // For now, just pass it down.

        // IPv4 code passed the set info request down to IP here.
        // Our IPv6 code is not configured this way.
        return TDI_INVALID_REQUEST;
    }

    if (ID->toi_entity.tei_instance != TL_INSTANCE)
        return TDI_INVALID_REQUEST;

    if (ID->toi_class == INFO_CLASS_GENERIC) {
        // Fill this in when we have generic class defines.
        return TDI_INVALID_PARAMETER;
    }

    // Now look at the rest of it.
    if (ID->toi_class == INFO_CLASS_PROTOCOL) {
        // Handle protocol specific class of information.  For us, this is
        // the MIB-2 stuff, as well as common sockets options,
        // and in particular the setting of the state of a TCP connection.

        if (ID->toi_type == INFO_TYPE_CONNECTION) {
            TCPSocketOption *Option;
            uint Flag;
            uint Value;

#ifndef UDP_ONLY
            // A connection type.  Get the connection, and then figure out
            // what to do with it.
            Status = TDI_INVALID_PARAMETER;

            if (Size < sizeof(TCPSocketOption))
                return Status;

            Conn = GetConnFromConnID(
                        PtrToUlong(Request->Handle.ConnectionContext), &Irql0);

            if (Conn != NULL) {
                CHECK_STRUCT(Conn, tc);

                Status = TDI_SUCCESS;

                if (ID->toi_id == TCP_SOCKET_WINDOW) {
                    // This is a funny option, because it doesn't involve
                    // flags.  Handle this specially.
                    Option = (TCPSocketOption *)Buffer;

                    // We don't allow anyone to shrink the window, as this
                    // gets too weird from a protocol point of view.  Also,
                    // make sure they don't try and set anything too big.
                    if (Option->tso_value > 0xffff)
                        Status = TDI_INVALID_PARAMETER;
                    else if (Option->tso_value > Conn->tc_window ||
                             Conn->tc_tcb == NULL) {
                        Conn->tc_flags |= CONN_WINSET;
                        Conn->tc_window = Option->tso_value;
                        SetTCB = Conn->tc_tcb;

                        if (SetTCB != NULL) {
                            CHECK_STRUCT(SetTCB, tcb);
                            KeAcquireSpinLock(&SetTCB->tcb_lock, &Irql1);
                            ASSERT(Option->tso_value > SetTCB->tcb_defaultwin);
                            if (DATA_RCV_STATE(SetTCB->tcb_state) &&
                                !CLOSING(SetTCB)) {
                                SetTCB->tcb_flags |= WINDOW_SET;
                                SetTCB->tcb_defaultwin = Option->tso_value;
                                SetTCB->tcb_refcnt++;
                                KeReleaseSpinLock(&SetTCB->tcb_lock, Irql1);
                                KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock,
                                                  Irql0);
                                SendACK(SetTCB);
                                KeAcquireSpinLock(&SetTCB->tcb_lock, &Irql1);
                                DerefTCB(SetTCB, Irql1);
                                return Status;
                            } else {
                                KeReleaseSpinLock(&SetTCB->tcb_lock, Irql1);
                            }
                        }
                    }
                    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
                    return Status;
                }

                Flag = 0;
                if (ID->toi_id == TCP_SOCKET_KEEPALIVE_VALS) {
                    TCPKeepalive *KAOption;
                    // treat it as separate as it takes a structure instead of integer
                    if (Size < sizeof(TCPKeepalive)) {
                        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
                        // The IPv4 code returns success here.
                        return TDI_INVALID_PARAMETER;
                    }
                    KAOption = (TCPKeepalive *) Buffer;
                    Value = KAOption->onoff;
                    if (Value) {
                        Conn->tc_tcbkatime = MS_TO_TICKS(KAOption->keepalivetime);
                        Conn->tc_tcbkainterval = MS_TO_TICKS(KAOption->keepaliveinterval);
                    }
                    Flag = KEEPALIVE;
                } else {
                    Option = (TCPSocketOption *)Buffer;
                    Value = Option->tso_value;
                    // We have the connection, so figure out which flag to set.
                    switch (ID->toi_id) {

                    case TCP_SOCKET_NODELAY:
                        Value = !Value;
                        Flag = NAGLING;
                        break;
                    case TCP_SOCKET_KEEPALIVE:
                        Flag = KEEPALIVE;
                        Conn->tc_tcbkatime = KeepAliveTime;
                        Conn->tc_tcbkainterval = KAInterval;
                        break;
                    case TCP_SOCKET_BSDURGENT:
                        Flag = BSD_URGENT;
                        break;
                    case TCP_SOCKET_OOBINLINE:
                        Flag = URG_INLINE;
                        break;
                    default:
                        Status = TDI_INVALID_PARAMETER;
                        break;
                    }
                }

                if (Status == TDI_SUCCESS) {
                    if (Value)
                        Conn->tc_tcbflags |= Flag;
                    else
                        Conn->tc_tcbflags &= ~Flag;

                    SetTCB = Conn->tc_tcb;
                    if (SetTCB != NULL) {
                        CHECK_STRUCT(SetTCB, tcb);
                        KeAcquireSpinLock(&SetTCB->tcb_lock, &Irql1);
                        if ((ID->toi_id == TCP_SOCKET_OOBINLINE ||
                             ID->toi_id == TCP_SOCKET_BSDURGENT) &&
                            ((SetTCB->tcb_flags & URG_VALID) ||
                             (SetTCB->tcb_fastchk & TCP_FLAG_IN_RCV))) {
                            // Don't allow switching to and from inline mode
                            // while we have urgent data outstanding or
                            // while we're processing receives.
                            Status = TDI_INVALID_STATE;
                        } else if (Value)
                            SetTCB->tcb_flags |= Flag;
                        else
                            SetTCB->tcb_flags &= ~Flag;

                        if ((ID->toi_id == TCP_SOCKET_KEEPALIVE) ||
                            (ID->toi_id == TCP_SOCKET_KEEPALIVE_VALS)) {
                            SetTCB->tcb_alive = TCPTime;
                            SetTCB->tcb_kacount = 0;
                        }

                        KeReleaseSpinLock(&SetTCB->tcb_lock, Irql1);
                    }
                }

                KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
            }
            return Status;
#else
            return TDI_INVALID_PARAMETER;
#endif
        }

        if (ID->toi_type == INFO_TYPE_ADDRESS_OBJECT) {
            // We're setting information on an address object.  This is
            // pretty simple.

            return SetAddrOptions(Request, ID->toi_id, Size, Buffer);
        }

        if (ID->toi_type != INFO_TYPE_PROVIDER)
            return TDI_INVALID_PARAMETER;

#ifndef UDP_ONLY
        if (ID->toi_id == TCP_MIB_TABLE_ID) {
            if (Size != sizeof(TCP6ConnTableEntry))
                return TDI_INVALID_PARAMETER;

            TCPEntry = (TCP6ConnTableEntry *)Buffer;

            if (TCPEntry->tct_state != TCP_DELETE_TCB)
                return TDI_INVALID_PARAMETER;

            // We have an apparently valid request.  Look up the TCB.
            KeAcquireSpinLock(&TCBTableLock, &Irql0);
            SetTCB = FindTCB(&TCPEntry->tct_localaddr,
                             &TCPEntry->tct_remoteaddr,
                             TCPEntry->tct_localscopeid,
                             TCPEntry->tct_remotescopeid,
                             (ushort)TCPEntry->tct_localport,
                             (ushort)TCPEntry->tct_remoteport);

            // We found him.  If he's not closing or closed, close him.
            if (SetTCB != NULL) {
                KeAcquireSpinLock(&SetTCB->tcb_lock, &Irql1);
                KeReleaseSpinLock(&TCBTableLock, Irql1);

                // We've got him.  Bump his ref. count, and call TryToCloseTCB
                // to mark him as closing. Then notify the upper layer client
                // of the disconnect.
                SetTCB->tcb_refcnt++;
                if (SetTCB->tcb_state != TCB_CLOSED && !CLOSING(SetTCB)) {
                    SetTCB->tcb_flags |= NEED_RST;
                    TryToCloseTCB(SetTCB, TCB_CLOSE_ABORTED, Irql0);
                    KeAcquireSpinLock(&SetTCB->tcb_lock, &Irql0);

                    if (SetTCB->tcb_state != TCB_TIME_WAIT) {
                        // Remove him from the TCB, and notify the client.
                        KeReleaseSpinLock(&SetTCB->tcb_lock, Irql0);
                        RemoveTCBFromConn(SetTCB);
                        NotifyOfDisc(SetTCB, TDI_CONNECTION_RESET, NULL);
                        KeAcquireSpinLock(&SetTCB->tcb_lock, &Irql0);
                    }
                }

                DerefTCB(SetTCB, Irql0);
                return TDI_SUCCESS;
            } else {
                KeReleaseSpinLock(&TCBTableLock, Irql0);
                return TDI_INVALID_PARAMETER;
            }
        } else
            return TDI_INVALID_PARAMETER;
#else
        return TDI_INVALID_PARAMETER;
#endif

    }

    if (ID->toi_class == INFO_CLASS_IMPLEMENTATION) {
        // We want to return implementation specific info.  For now, error out.
        return TDI_INVALID_REQUEST;
    }

    return TDI_INVALID_REQUEST;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\init.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This file contain init code for the TCP/UDP driver.
// Some things here are ifdef'ed for building a UDP only version.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include <tdikrnl.h>
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "udp.h"
#include "raw.h"
#include "info.h"

#ifndef UDP_ONLY
#include "tcp.h"
#include "tcpsend.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tcpdeliv.h"

extern int TCPInit(void);
extern void TCPUnload(void);
#endif // UDP_ONLY

#include "tdiinfo.h"
#include "tcpcfg.h"

extern int UDPInit(void);
extern void UDPUnload(void);

//
// Definitions of global variables.
//
uint MaxUserPort;
HANDLE AddressChangeHandle;
LARGE_INTEGER StartTime;

extern void *UDPProtInfo;
extern void *RawProtInfo;

//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA

int TransportLayerInit();

#pragma alloc_text(INIT, TransportLayerInit)

#endif // ALLOC_PRAGMA

#ifdef UDP_ONLY
//
// Dummy routines for UDP only version.
// All of these routines return 'Invalid Request'.
//
TDI_STATUS
TdiOpenConnection(PTDI_REQUEST Request, PVOID Context)
{
    return TDI_INVALID_REQUEST;
}

TDI_STATUS
TdiCloseConnection(PTDI_REQUEST Request)
{
    return TDI_INVALID_REQUEST;
}

TDI_STATUS
TdiAssociateAddress(PTDI_REQUEST Request, HANDLE AddrHandle)
{
    return TDI_INVALID_REQUEST;
}

TDI_STATUS
TdiDisAssociateAddress(PTDI_REQUEST Request)
{
    return TDI_INVALID_REQUEST;
}

TDI_STATUS
TdiConnect(PTDI_REQUEST Request, void *Timeout,
           PTDI_CONNECTION_INFORMATION RequestAddr,
           PTDI_CONNECTION_INFORMATION ReturnAddr)
{
    return TDI_INVALID_REQUEST;
}

TDI_STATUS
TdiListen(PTDI_REQUEST Request, ushort Flags,
          PTDI_CONNECTION_INFORMATION AcceptableAddr,
          PTDI_CONNECTION_INFORMATION ConnectedAddr)
{
    return TDI_INVALID_REQUEST;
}

TDI_STATUS
TdiAccept(PTDI_REQUEST Request, PTDI_CONNECTION_INFORMATION AcceptInfo,
          PTDI_CONNECTION_INFORMATION ConnectedInfo)
{
    return TDI_INVALID_REQUEST;
}

TDI_STATUS
TdiReceive(PTDI_REQUEST Request, ushort *Flags, uint *RcvLength,
           PNDIS_BUFFER Buffer)
{
    return TDI_INVALID_REQUEST;
}

TDI_STATUS
TdiSend(PTDI_REQUEST Request, ushort Flags, uint SendLength,
        PNDIS_BUFFER Buffer)
{
    return TDI_INVALID_REQUEST;
}

TDI_STATUS
TdiDisconnect(PTDI_REQUEST Request, PVOID Timeout, ushort Flags,
              PTDI_CONNECTION_INFORMATION DisconnectInfo,
              PTDI_CONNECTION_INFORMATION ReturnInfo)
{
    return TDI_INVALID_REQUEST;
}

#endif  // UDP_ONLY


#pragma BEGIN_INIT

//* TransportLayerInit - Initialize the transport layer.
//
//  The main transport layer initialize routine.  We get whatever config
//  info we need, initialize some data structures, get information
//  from IP, do some more initialization, and finally register our
//  protocol values with IP.
//
int        //  Returns: True is we succeeded, False if we fail to initialize.
TransportLayerInit(
    void)  // No arguments.
{
    //
    // Remember when we started for TdiQueryInformation.
    //
    KeQuerySystemTime(&StartTime);

    //
    // Initialize common address object management code.
    //
    if (!InitAddr())
        return FALSE;

    //
    // Initialize the individual protocols.
    //
    if (!UDPInit())
        return FALSE;

#ifndef UDP_ONLY
    if (!TCPInit())
        return FALSE;
#endif

    return TRUE;
}

#pragma END_INIT

//* TransportLayerUnload
//
//  Cleanup and prepare the transport layer for stack unload.
//
void
TransportLayerUnload(void)
{
#ifndef UDP_ONLY
    TCPUnload();
#endif

    UDPUnload();

    AddrUnload();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\ntdisp.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// NT specific routines for dispatching and handling IRPs.
//


#include <oscfg.h>
#include <ndis.h>
#include <tdikrnl.h>
#include <tdint.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <ip6imp.h>
#include <ip6def.h>
#include <ntddip6.h>
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "tcp.h"
#include "udp.h"
#include "raw.h"
#include <ntddtcp.h>
#include "tcpcfg.h"
#include "tcpconn.h"
#include "tdilocal.h"

//
// Macros
//

//* Convert100nsToMillisconds
//
//  Converts time expressed in hundreds of nanoseconds to milliseconds.
//
//  REVIEW: replace RtlExtendedMagicDivide with 64 bit compiler support?
//
//  LARGE_INTEGER  // Returns: Time in milliseconds.
//  Convert100nsToMilliseconds(
//      IN LARGE_INTEGER HnsTime);  // Time in hundreds of nanoseconds.
//
#define SHIFT10000 13
static LARGE_INTEGER Magic10000 = {0xe219652c, 0xd1b71758};

#define Convert100nsToMilliseconds(HnsTime) \
        RtlExtendedMagicDivide((HnsTime), Magic10000, SHIFT10000)


//
// Global variables
//
extern PSECURITY_DESCRIPTOR TcpAdminSecurityDescriptor;
extern PDEVICE_OBJECT TCPDeviceObject, UDPDeviceObject;
extern PDEVICE_OBJECT IPDeviceObject;
extern PDEVICE_OBJECT RawIPDeviceObject;


//
// Local types
//
typedef struct {
    PIRP Irp;
    PMDL InputMdl;
    PMDL OutputMdl;
    TCP_REQUEST_QUERY_INFORMATION_EX QueryInformation;
} TCP_QUERY_CONTEXT, *PTCP_QUERY_CONTEXT;


//
// General external function prototypes
//
extern
NTSTATUS
IPDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );


//
// Other external functions
//
void
TCPAbortAndIndicateDisconnect(
    CONNECTION_CONTEXT ConnnectionContext
    );

//
// Local pageable function prototypes
//
NTSTATUS
TCPDispatchDeviceControl(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
TCPCreate(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
TCPAssociateAddress(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
TCPSetEventHandler(
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
TCPQueryInformation(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

FILE_FULL_EA_INFORMATION UNALIGNED *
FindEA(
    PFILE_FULL_EA_INFORMATION  StartEA,
    CHAR                      *TargetName,
    USHORT                     TargetNameLength
    );

BOOLEAN
IsAdminIoRequest(
    PIRP Irp,
    PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
IsDHCPZeroAddress(
    TRANSPORT_ADDRESS UNALIGNED *AddrList
    );

ULONG
RawExtractProtocolNumber(
    IN  PUNICODE_STRING FileName
    );

NTSTATUS
CaptureCreatorSD(
    PIRP Irp,
    PIO_STACK_LOCATION IrpSp,
    OUT PSECURITY_DESCRIPTOR* CreatorSD
    );

NTSTATUS
TCPEnumerateConnectionList(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

//
// Local helper routine prototypes.
//
ULONG
TCPGetMdlChainByteCount(
    PMDL   Mdl
    );


//
// All of this code is pageable.
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, TCPDispatchDeviceControl)
#pragma alloc_text(PAGE, TCPCreate)
#pragma alloc_text(PAGE, TCPAssociateAddress)
#pragma alloc_text(PAGE, TCPSetEventHandler)
#pragma alloc_text(PAGE, FindEA)
#pragma alloc_text(PAGE, IsDHCPZeroAddress)
#pragma alloc_text(PAGE, RawExtractProtocolNumber)
#pragma alloc_text(PAGE, IsAdminIoRequest)
#pragma alloc_text(PAGE, CaptureCreatorSD)

#endif // ALLOC_PRAGMA


//
// Generic Irp completion and cancellation routines.
//

//* TCPDataRequestComplete - Completes a UDP/TCP send/receive request.
//
NTSTATUS                     // Returns: Nothing.
TCPDataRequestComplete(
    void *Context,           // A pointer to the IRP for this request.
    unsigned int Status,     // The final TDI status of the request.
    unsigned int ByteCount)  // Bytes sent/received information.
{
    KIRQL oldIrql;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTCP_CONTEXT tcpContext;

    irp = (PIRP) Context;
    irpSp = IoGetCurrentIrpStackLocation(irp);
    tcpContext = (PTCP_CONTEXT) irpSp->FileObject->FsContext;

    if (IoSetCancelRoutine(irp, NULL) == NULL) {
        //
        // In case an old cancel routine is still running,
        // synchronize with it.
        //
        IoAcquireCancelSpinLock(&oldIrql);
        IoReleaseCancelSpinLock(oldIrql);
    }

    KeAcquireSpinLock(&tcpContext->EndpointLock, &oldIrql);

#if DBG

    IF_TCPDBG(TCP_DEBUG_CANCEL) {

        PLIST_ENTRY entry, listHead;
        PIRP item = NULL;

        if (irp->Cancel) {
            ASSERT(irp->CancelRoutine == NULL);
            listHead = &(tcpContext->CancelledIrpList);
        } else {
            listHead = &(tcpContext->PendingIrpList);
        }

        //
        // Verify that the Irp is on the appropriate list.
        //
        for (entry = listHead->Flink; entry != listHead;
             entry = entry->Flink) {

            item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

            if (item == irp) {
                RemoveEntryList(&(irp->Tail.Overlay.ListEntry));
                break;
            }
        }

        ASSERT(item == irp);
    }

#endif

    if ((Status == TDI_CANCELLED) && ByteCount) {
        Status = STATUS_SUCCESS;
    } else {
        if (irp->Cancel || tcpContext->CancelIrps) {

            IF_TCPDBG(TCP_DEBUG_IRP) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TCPDataRequestComplete: Irp %lx was cancelled\n",
                           irp));
            }

            Status = (unsigned int) STATUS_CANCELLED;
            ByteCount = 0;
        }
    }

    ASSERT(tcpContext->ReferenceCount > 0);

    IF_TCPDBG(TCP_DEBUG_IRP) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPDataRequestComplete: "
                   "Irp %lx fileobj %lx refcnt dec to %u\n",
                   irp, irpSp->FileObject, tcpContext->ReferenceCount - 1));
    }

    if (--(tcpContext->ReferenceCount) == 0) {

        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            ASSERT(IsListEmpty(&(tcpContext->CancelledIrpList)));
            ASSERT(IsListEmpty(&(tcpContext->PendingIrpList)));
        }

        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

        //
        // Since the reference count on the tcpContext is now zero,
        // setting this event must be the last place we touch it.
        //
        KeSetEvent(&(tcpContext->CleanupEvent), 0, FALSE);

    } else {
        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);
    }

    IF_TCPDBG(TCP_DEBUG_IRP) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPDataRequestComplete: completing irp %lx, status %lx,"
                   " byte count %lx\n", irp, Status, ByteCount));
    }

    irp->IoStatus.Status = (NTSTATUS) Status;
    irp->IoStatus.Information = ByteCount;

    IoCompleteRequest(irp, IO_NETWORK_INCREMENT);

    return Status;

}  // TCPDataRequestComplete


//* TCPRequestComplete - Completes a TDI request.
//
//  Completes a cancellable TDI request which returns no data by
//  calling TCPDataRequestComplete with a ByteCount of zero.
//
void                      // Returns: Nothing.
TCPRequestComplete(
    void *Context,        // A pointer to the IRP for this request.
    unsigned int Status,  // The final TDI status of the request.
    unsigned int UnUsed)  // An unused parameter.
{
    UNREFERENCED_PARAMETER(UnUsed);

    TCPDataRequestComplete(Context, Status, 0);

}  // TCPRequestComplete


//* TCPNonCancellableRequestComplete - Complete uncancellable TDI request.
//
//  Completes a TDI request which cannot be cancelled.
//
void  // Returns: Nothing.
TCPNonCancellableRequestComplete(
    void *Context,        // A pointer to the IRP for this request.
    unsigned int Status,  // The final TDI status of the request.
    unsigned int UnUsed)  // An unused parameter.
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    UNREFERENCED_PARAMETER(UnUsed);

    irp = (PIRP) Context;
    irpSp = IoGetCurrentIrpStackLocation(irp);

    IF_TCPDBG(TCP_DEBUG_CLOSE) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPNonCancellableRequestComplete: irp %lx status %lx\n",
                   irp, Status));
    }

    //
    // Complete the IRP.
    //
    irp->IoStatus.Status = (NTSTATUS) Status;
    irp->IoStatus.Information = 0;
    IoCompleteRequest(irp, IO_NETWORK_INCREMENT);

    return;

}  // TCPNonCancellableRequestComplete


//* TCPCancelComplete
//
void
TCPCancelComplete(
    void *Context,
    unsigned int Unused1,
    unsigned int Unused2)
{
    PFILE_OBJECT fileObject = (PFILE_OBJECT) Context;
    PTCP_CONTEXT tcpContext = (PTCP_CONTEXT) fileObject->FsContext;
    KIRQL oldIrql;

    UNREFERENCED_PARAMETER(Unused1);
    UNREFERENCED_PARAMETER(Unused2);

    KeAcquireSpinLock(&tcpContext->EndpointLock, &oldIrql);

    //
    // Remove the reference placed on the endpoint by the cancel routine.
    // The cancelled Irp will be completed by the completion routine for the
    // request.
    //
    if (--(tcpContext->ReferenceCount) == 0) {

        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            ASSERT(IsListEmpty(&(tcpContext->CancelledIrpList)));
            ASSERT(IsListEmpty(&(tcpContext->PendingIrpList)));
        }

        //
        // Set the cleanup event.
        //
        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);
        KeSetEvent(&(tcpContext->CleanupEvent), 0, FALSE);
        return;
    }

    IF_TCPDBG(TCP_DEBUG_IRP) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPCancelComplete: fileobj %lx refcnt dec to %u\n",
                   fileObject, tcpContext->ReferenceCount));
    }

    KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

    return;

}  // TCPCancelComplete


//* TCPCancelRequest - Cancels an outstanding Irp.
//
//  Cancel an outstanding Irp.
//
VOID                        // Returns: Nothing.
TCPCancelRequest(
    PDEVICE_OBJECT Device,  // Pointer to the device object for this request.
    PIRP Irp)               // Pointer to I/O request packet.
{
    PIO_STACK_LOCATION irpSp;
    PTCP_CONTEXT tcpContext;
    NTSTATUS status = STATUS_SUCCESS;
    PFILE_OBJECT fileObject;
    UCHAR minorFunction;
    TDI_REQUEST request;
    KIRQL CancelIrql;

    UNREFERENCED_PARAMETER(Device);

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpSp->FileObject;
    tcpContext = (PTCP_CONTEXT) fileObject->FsContext;
    minorFunction = irpSp->MinorFunction;
    CancelIrql = Irp->CancelIrql;

    KeAcquireSpinLockAtDpcLevel(&tcpContext->EndpointLock);

    ASSERT(Irp->Cancel);
    IoReleaseCancelSpinLock(DISPATCH_LEVEL);

    IF_TCPDBG(TCP_DEBUG_IRP) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPCancelRequest: cancelling irp %lx, file object %lx\n",
                   Irp, fileObject));
    }

#if DBG

    IF_TCPDBG(TCP_DEBUG_CANCEL) {
        //
        // Verify that the Irp is on the pending list.
        //
        PLIST_ENTRY entry;
        PIRP item = NULL;

        for (entry = tcpContext->PendingIrpList.Flink;
             entry != &(tcpContext->PendingIrpList); entry = entry->Flink) {

            item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

            if (item == Irp) {
                RemoveEntryList( &(Irp->Tail.Overlay.ListEntry));
                break;
            }
        }

        ASSERT(item == Irp);

        InsertTailList(&(tcpContext->CancelledIrpList),
                       &(Irp->Tail.Overlay.ListEntry));
    }

#endif // DBG

    //
    // Add a reference so the object can't be closed while the cancel routine
    // is executing.
    //
    ASSERT(tcpContext->ReferenceCount > 0);
    tcpContext->ReferenceCount++;

    IF_TCPDBG(TCP_DEBUG_IRP) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPCancelRequest: Irp %lx fileobj %lx refcnt inc to %u\n",
                   Irp, fileObject, tcpContext->ReferenceCount));
    }

    //
    // Try to cancel the request.
    //
    switch(minorFunction) {

    case TDI_SEND:
    case TDI_RECEIVE:
        KeReleaseSpinLock(&tcpContext->EndpointLock, CancelIrql);

        ASSERT((PtrToUlong(fileObject->FsContext2)) == TDI_CONNECTION_FILE);
#ifndef UDP_ONLY
        TCPAbortAndIndicateDisconnect(tcpContext->Handle.ConnectionContext);
#endif
        break;

    case TDI_SEND_DATAGRAM:

        ASSERT(PtrToUlong(fileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE);

        TdiCancelSendDatagram(tcpContext->Handle.AddressHandle, Irp,
                              &tcpContext->EndpointLock, CancelIrql);
        break;

    case TDI_RECEIVE_DATAGRAM:

        ASSERT(PtrToUlong(fileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE);

        TdiCancelReceiveDatagram(tcpContext->Handle.AddressHandle, Irp,
                                 &tcpContext->EndpointLock, CancelIrql);
        break;

    case TDI_DISASSOCIATE_ADDRESS:

        ASSERT(PtrToUlong(fileObject->FsContext2) == TDI_CONNECTION_FILE);
        //
        // This pends but is not cancellable.  We put it thru the cancel code
        // anyway so a reference is made for it and so it can be tracked in
        // a debug build.
        //
        KeReleaseSpinLock(&tcpContext->EndpointLock, CancelIrql);
        break;

    default:

        //
        // Initiate a disconnect to cancel the request.
        //
        KeReleaseSpinLock(&tcpContext->EndpointLock, CancelIrql);
        request.Handle.ConnectionContext =
            tcpContext->Handle.ConnectionContext;
        request.RequestNotifyObject = TCPCancelComplete;
        request.RequestContext = fileObject;

        status = TdiDisconnect(&request, NULL, TDI_DISCONNECT_ABORT, NULL,
                               NULL, NULL);
        break;
    }

    if (status != TDI_PENDING) {
        TCPCancelComplete(fileObject, 0, 0);
    }

    return;

}  // TCPCancelRequest


//* TCPPrepareIrpForCancel
//
NTSTATUS
TCPPrepareIrpForCancel(
    PTCP_CONTEXT TcpContext,
    PIRP Irp,
    PDRIVER_CANCEL CancelRoutine)
{
    KIRQL oldIrql;

    //
    // Set up for cancellation.
    //
    KeAcquireSpinLock(&TcpContext->EndpointLock, &oldIrql);

    ASSERT(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {

        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, CancelRoutine);
        TcpContext->ReferenceCount++;

        IF_TCPDBG(TCP_DEBUG_IRP) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPPrepareIrpForCancel: irp %lx fileobj %lx refcnt inc"
                       " to %u\n", Irp,
                       (IoGetCurrentIrpStackLocation(Irp))->FileObject,
                       TcpContext->ReferenceCount));
        }

#if DBG
        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            PLIST_ENTRY entry;
            PIRP item = NULL;

            //
            // Verify that the Irp has not already been submitted.
            //
            for (entry = TcpContext->PendingIrpList.Flink;
                 entry != &(TcpContext->PendingIrpList);
                 entry = entry->Flink) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            for (entry = TcpContext->CancelledIrpList.Flink;
                 entry != &(TcpContext->CancelledIrpList);
                 entry = entry->Flink) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            InsertTailList(&(TcpContext->PendingIrpList),
                           &(Irp->Tail.Overlay.ListEntry));
        }
#endif // DBG

        KeReleaseSpinLock(&TcpContext->EndpointLock, oldIrql);

        return(STATUS_SUCCESS);
    }

    //
    // The IRP has already been cancelled.  Complete it now.
    //

    IF_TCPDBG(TCP_DEBUG_IRP) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCP: irp %lx already cancelled, completing.\n", Irp));
    }

    KeReleaseSpinLock(&TcpContext->EndpointLock, oldIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return(STATUS_CANCELLED);

}  // TCPPrepareIrpForCancel


//
// TDI functions.
//


//* TCPAssociateAddress - Handle TDI Associate Address IRP.
//
//  Converts a TDI Associate Address IRP into a call to TdiAssociateAddress.
//
//  This routine does not pend.
//
NTSTATUS  // Returns: indication of whether the request was successful.
TCPAssociateAddress(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.

{
    NTSTATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_ASSOCIATE associateInformation;
    PFILE_OBJECT fileObject;

    PAGED_CODE();

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    associateInformation =
        (PTDI_REQUEST_KERNEL_ASSOCIATE) &(IrpSp->Parameters);

    //
    // Get the file object for the address.  Then extract the Address Handle
    // from the TCP_CONTEXT associated with it.
    //
    status = ObReferenceObjectByHandle(associateInformation->AddressHandle,
                                       0, *IoFileObjectType, Irp->RequestorMode,
                                       &fileObject, NULL);

    if (NT_SUCCESS(status)) {

        if ((fileObject->DeviceObject == TCPDeviceObject) &&
            (PtrToUlong(fileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE)) {

            tcpContext = (PTCP_CONTEXT) fileObject->FsContext;

            status = TdiAssociateAddress(&request,
                                         tcpContext->Handle.AddressHandle);

            ASSERT(status != STATUS_PENDING);

            ObDereferenceObject(fileObject);

            IF_TCPDBG(TCP_DEBUG_ASSOCIATE) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TCPAssociateAddress complete on file object %lx\n",
                           IrpSp->FileObject));
            }
        } else {
            ObDereferenceObject(fileObject);
            status = STATUS_INVALID_HANDLE;

            IF_TCPDBG(TCP_DEBUG_ASSOCIATE) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TCPAssociateAddress: ObReference failed on object"
                           " %lx, status %lx\n",
                           associateInformation->AddressHandle, status));
            }
        }
    } else {
        IF_TCPDBG(TCP_DEBUG_ASSOCIATE) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPAssociateAddress: ObReference failed on object %lx,"
                       " status %lx\n", associateInformation->AddressHandle,
                       status));
        }
    }

    return(status);
}


//* TCPDisassociateAddress - Handle TDI Disassociate Address IRP.
//
//  Converts a TDI Disassociate Address IRP into a call to
//  TdiDisassociateAddress.
NTSTATUS  // Returns: Indication of whether the request was successful.
TCPDisassociateAddress(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    NTSTATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;

    IF_TCPDBG(TCP_DEBUG_ASSOCIATE) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCP disassociating address\n"));
    }

    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPRequestComplete;
    request.RequestContext = Irp;

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = TdiDisAssociateAddress(&request);

        if (status != TDI_PENDING)  {
            TCPRequestComplete(Irp, status, 0);
        }
        //
        // Return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING.
        //
        return(TDI_PENDING);
    }

    return(status);

}  // TCPDisassociateAddress


//* TCPConnect - Handle TDI Connect IRP.
//
//  Converts a TDI Connect IRP into a call to TdiConnect.
//
NTSTATUS  // Returns: Whether the request was successfully queued.
TCPConnect(
    IN PIRP Irp,                  // Pointer to I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    NTSTATUS status;
    PTCP_CONTEXT tcpContext;
    TDI_REQUEST request;
    PTDI_CONNECTION_INFORMATION requestInformation, returnInformation;
    PTDI_REQUEST_KERNEL_CONNECT connectRequest;
    LARGE_INTEGER millisecondTimeout;
    PLARGE_INTEGER requestTimeout;

    IF_TCPDBG(TCP_DEBUG_CONNECT) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPConnect irp %lx, file object %lx\n", Irp,
                   IrpSp->FileObject));
    }

    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);

    connectRequest = (PTDI_REQUEST_KERNEL_CONNECT) &(IrpSp->Parameters);
    requestInformation = connectRequest->RequestConnectionInformation;
    returnInformation = connectRequest->ReturnConnectionInformation;
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPRequestComplete;
    request.RequestContext = Irp;

    requestTimeout = (PLARGE_INTEGER) connectRequest->RequestSpecific;

    if (requestTimeout != NULL) {
        //
        // NT relative timeouts are negative.  Negate first to get a positive
        // value to pass to the transport.
        //
        millisecondTimeout.QuadPart = -((*requestTimeout).QuadPart);
        millisecondTimeout = Convert100nsToMilliseconds(millisecondTimeout);
    } else {
        millisecondTimeout.LowPart = 0;
        millisecondTimeout.HighPart = 0;
    }


    ASSERT(millisecondTimeout.HighPart == 0);

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = TdiConnect(&request, ((millisecondTimeout.LowPart != 0) ?
                                       &(millisecondTimeout.LowPart) : NULL),
                            requestInformation, returnInformation);

        if (status != STATUS_PENDING) {
            TCPRequestComplete(Irp, status, 0);
        }
        //
        // Return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING.
        //
        return(STATUS_PENDING);
    }

    return(status);

}  // TCPConnect


//* TCPDisconnect - Handler for TDI Disconnect IRP
//
//  Converts a TDI Disconnect IRP into a call to TdiDisconnect.
//
NTSTATUS  // Returns: whether the request was successfully queued.
TCPDisconnect(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    NTSTATUS status;
    PTCP_CONTEXT tcpContext;
    TDI_REQUEST request;
    PTDI_CONNECTION_INFORMATION requestInformation, returnInformation;
    PTDI_REQUEST_KERNEL_DISCONNECT disconnectRequest;
    LARGE_INTEGER millisecondTimeout;
    PLARGE_INTEGER requestTimeout;
    BOOLEAN abortive = FALSE;

    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);

    disconnectRequest = (PTDI_REQUEST_KERNEL_CONNECT) &(IrpSp->Parameters);
    requestInformation = disconnectRequest->RequestConnectionInformation;
    returnInformation = disconnectRequest->ReturnConnectionInformation;
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestContext = Irp;

    //
    // Set up the timeout value.
    //
    if (disconnectRequest->RequestSpecific != NULL) {
        requestTimeout = (PLARGE_INTEGER) disconnectRequest->RequestSpecific;

        if ((requestTimeout->LowPart == -1) &&
            (requestTimeout->HighPart == -1)) {

            millisecondTimeout.LowPart = requestTimeout->LowPart;
            millisecondTimeout.HighPart = 0;
        } else {
            //
            // NT relative timeouts are negative.  Negate first to get a
            // positive value to pass to the transport.
            //
            millisecondTimeout.QuadPart = -((*requestTimeout).QuadPart);
            millisecondTimeout = Convert100nsToMilliseconds(
                millisecondTimeout);
        }
    } else {
        millisecondTimeout.LowPart = 0;
        millisecondTimeout.HighPart = 0;
    }

    ASSERT(millisecondTimeout.HighPart == 0);

    if (disconnectRequest->RequestFlags & TDI_DISCONNECT_ABORT) {
        //
        // Abortive disconnects cannot be cancelled and must use
        // a specific completion routine.
        //
        abortive = TRUE;
        IoMarkIrpPending(Irp);
        request.RequestNotifyObject = TCPNonCancellableRequestComplete;
        status = STATUS_SUCCESS;
    } else {
        //
        // Non-abortive disconnects can use the generic cancellation and
        // completion routines.
        //
        status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);
        request.RequestNotifyObject = TCPRequestComplete;
    }

    IF_TCPDBG(TCP_DEBUG_CLOSE) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPDisconnect "
                   "irp %lx, flags %lx, fileobj %lx, abortive = %d\n",
                   Irp, disconnectRequest->RequestFlags, IrpSp->FileObject,
                   abortive));
    }

    if (NT_SUCCESS(status)) {
        status = TdiDisconnect(&request,((millisecondTimeout.LowPart != 0) ?
                                         &(millisecondTimeout.LowPart) : NULL),
                               (ushort) disconnectRequest->RequestFlags,
                               requestInformation, returnInformation,
                               (TCPAbortReq*)&Irp->Tail.Overlay.DriverContext[0]);

        if (status != STATUS_PENDING) {
            if (abortive) {
                TCPNonCancellableRequestComplete(Irp, status, 0);
            } else {
                TCPRequestComplete(Irp, status, 0);
            }
        } else {
            IF_TCPDBG(TCP_DEBUG_CLOSE) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TCPDisconnect pending irp %lx\n", Irp));
            }
        }
        //
        // return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING
        //
        return(STATUS_PENDING);
    }

    return(status);

}  // TCPDisconnect


//* TCPListen - Handler for TDI Listen IRP.
//
//  Converts a TDI Listen IRP into a call to TdiListen.
//
NTSTATUS  // Returns: whether or not the request was successful.
TCPListen(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.

{
    NTSTATUS status;
    PTCP_CONTEXT tcpContext;
    TDI_REQUEST request;
    PTDI_CONNECTION_INFORMATION requestInformation, returnInformation;
    PTDI_REQUEST_KERNEL_LISTEN listenRequest;

    IF_TCPDBG(TCP_DEBUG_CONNECT) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPListen irp %lx on file object %lx\n",
                   Irp, IrpSp->FileObject));
    }

    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);

    listenRequest = (PTDI_REQUEST_KERNEL_CONNECT) &(IrpSp->Parameters);
    requestInformation = listenRequest->RequestConnectionInformation;
    returnInformation = listenRequest->ReturnConnectionInformation;
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPRequestComplete;
    request.RequestContext = Irp;

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = TdiListen(&request, (ushort) listenRequest->RequestFlags,
                           requestInformation, returnInformation);

        if (status != TDI_PENDING) {
            TCPRequestComplete(Irp, status, 0);
        }
        //
        // return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING
        //
        return(TDI_PENDING);
    }

    return(status);

}  // TCPListen


//* TCPAccept - Handle a TDI Accept IRP.
//
//  Converts a TDI Accept IRP into a call to TdiAccept.
//
NTSTATUS  // Returns: whether the request was successfully queued.
TCPAccept(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    NTSTATUS status;
    PTCP_CONTEXT tcpContext;
    TDI_REQUEST request;
    PTDI_CONNECTION_INFORMATION requestInformation, returnInformation;
    PTDI_REQUEST_KERNEL_ACCEPT acceptRequest;

    IF_TCPDBG(TCP_DEBUG_CONNECT) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPAccept irp %lx on file object %lx\n", Irp,
                   IrpSp->FileObject));
    }

    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);

    acceptRequest = (PTDI_REQUEST_KERNEL_ACCEPT) &(IrpSp->Parameters);
    requestInformation = acceptRequest->RequestConnectionInformation;
    returnInformation = acceptRequest->ReturnConnectionInformation;
    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPRequestComplete;
    request.RequestContext = Irp;

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = TdiAccept(&request, requestInformation, returnInformation);

        if (status != TDI_PENDING) {
            TCPRequestComplete(Irp, status, 0);
        }
        //
        // Return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING.
        //
        return(TDI_PENDING);
    }

    return(status);

}  // TCPAccept


//* TCPSendData - Handle TDI Send IRP.
//
//  Converts a TDI Send IRP into a call to TdiSend.
//
NTSTATUS
TCPSendData(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    TDI_STATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_SEND requestInformation;
    KIRQL oldIrql;

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);
    requestInformation = (PTDI_REQUEST_KERNEL_SEND) &(IrpSp->Parameters);

    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;

    KeAcquireSpinLock(&tcpContext->EndpointLock, &oldIrql);
    IoSetCancelRoutine(Irp, TCPCancelRequest);

    if (!Irp->Cancel) {
        //
        // Set up for cancellation.
        //

        IoMarkIrpPending(Irp);

        tcpContext->ReferenceCount++;

        IF_TCPDBG(TCP_DEBUG_IRP) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPSendData: irp %lx fileobj %lx refcnt inc to %u\n",
                       Irp, IrpSp, tcpContext->ReferenceCount));
        }

#if DBG
        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            PLIST_ENTRY entry;
            PIRP item = NULL;

            //
            // Verify that the Irp has not already been submitted.
            //
            for (entry = tcpContext->PendingIrpList.Flink;
                 entry != &(tcpContext->PendingIrpList);
                 entry = entry->Flink) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            for (entry = tcpContext->CancelledIrpList.Flink;
                 entry != &(tcpContext->CancelledIrpList);
                 entry = entry->Flink) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            InsertTailList(&(tcpContext->PendingIrpList),
                           &(Irp->Tail.Overlay.ListEntry));
        }
#endif // DBG

        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

        IF_TCPDBG(TCP_DEBUG_SEND) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPSendData irp %lx sending %d bytes, flags %lx,"
                       " fileobj %lx\n", Irp, requestInformation->SendLength,
                       requestInformation->SendFlags, IrpSp->FileObject));
        }

        status = TdiSend(&request, (ushort) requestInformation->SendFlags,
                         requestInformation->SendLength,
                         (PNDIS_BUFFER) Irp->MdlAddress);

        if (status == TDI_PENDING) {
            IF_TCPDBG(TCP_DEBUG_SEND) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TCPSendData pending irp %lx\n", Irp));
            }

            return(status);
        }
        //
        // The status is not pending.  We reset the pending bit
        //
        IrpSp->Control &= ~SL_PENDING_RETURNED;

        if (status == TDI_SUCCESS) {
            ASSERT(requestInformation->SendLength == 0);

            status = TCPDataRequestComplete(Irp, status,
                                            requestInformation->SendLength);
        } else {

            IF_TCPDBG(TCP_DEBUG_SEND) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TCPSendData - irp %lx send failed, status %lx\n",
                           Irp, status));
            }

            status = TCPDataRequestComplete(Irp, status, 0);
        }
    } else {
        //
        // Irp was cancelled previously.
        //
        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

        //
        // Ensure that the cancel-routine has executed.
        //

        IoAcquireCancelSpinLock(&oldIrql);
        IoReleaseCancelSpinLock(oldIrql);

        KeAcquireSpinLock(&tcpContext->EndpointLock, &oldIrql);
        IoSetCancelRoutine(Irp, NULL);
        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

        IF_TCPDBG(TCP_DEBUG_SEND) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPSendData: Irp %lx on fileobj %lx was cancelled\n",
                       Irp, IrpSp->FileObject));
        }

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        status = STATUS_CANCELLED;
    }

    return(status);

}  // TCPSendData


//* TCPReceiveData - Handler for TDI Receive IRP.
//
//  Converts a TDI Receive IRP into a call to TdiReceive.
//
NTSTATUS  // Returns: whether the request was successful.
TCPReceiveData(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    TDI_STATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_RECEIVE requestInformation;
    KIRQL oldIrql;

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE);
    requestInformation = (PTDI_REQUEST_KERNEL_RECEIVE) &(IrpSp->Parameters);

    request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;

    KeAcquireSpinLock(&tcpContext->EndpointLock, &oldIrql);
    IoSetCancelRoutine(Irp, TCPCancelRequest);

    if (!Irp->Cancel) {
        //
        // Set up for cancellation.
        //

        IoMarkIrpPending(Irp);

        tcpContext->ReferenceCount++;

        IF_TCPDBG(TCP_DEBUG_IRP) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPReceiveData: irp %lx fileobj %lx refcnt inc to %u\n",
                       Irp, IrpSp->FileObject, tcpContext->ReferenceCount));
        }

#if DBG
        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            PLIST_ENTRY entry;
            PIRP item = NULL;

            //
            // Verify that the Irp has not already been submitted.
            //
            for (entry = tcpContext->PendingIrpList.Flink;
                 entry != &(tcpContext->PendingIrpList);
                 entry = entry->Flink) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            for (entry = tcpContext->CancelledIrpList.Flink;
                 entry != &(tcpContext->CancelledIrpList);
                 entry = entry->Flink) {

                item = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);

                ASSERT(item != Irp);
            }

            InsertTailList(&(tcpContext->PendingIrpList),
                           &(Irp->Tail.Overlay.ListEntry));
        }
#endif // DBG

        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

        IF_TCPDBG(TCP_DEBUG_RECEIVE) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPReceiveData irp %lx receiving %d bytes flags %lx"
                       " filobj %lx\n", Irp, requestInformation->ReceiveLength,
                       requestInformation->ReceiveFlags, IrpSp->FileObject));
        }

        status = TdiReceive(&request,
                            (ushort *) &(requestInformation->ReceiveFlags),
                            &(requestInformation->ReceiveLength),
                            (PNDIS_BUFFER) Irp->MdlAddress);

        if (status == TDI_PENDING) {
            IF_TCPDBG(TCP_DEBUG_RECEIVE) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TCPReceiveData: pending irp %lx\n", Irp));
            }

            return(status);
        }
        //
        // The status is not pending.  We reset the pending bit
        //
        IrpSp->Control &= ~SL_PENDING_RETURNED;

        IF_TCPDBG(TCP_DEBUG_RECEIVE) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPReceiveData - irp %lx failed, status %lx\n",
                       Irp, status));
        }

        status = TCPDataRequestComplete(Irp, status, 0);
    } else {
        //
        // Irp was cancelled previously.
        //
        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

        //
        // Ensure that the cancel-routine has executed.
        //

        IoAcquireCancelSpinLock(&oldIrql);
        IoReleaseCancelSpinLock(oldIrql);

        KeAcquireSpinLock(&tcpContext->EndpointLock, &oldIrql);
        IoSetCancelRoutine(Irp, NULL);
        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

        IF_TCPDBG(TCP_DEBUG_SEND) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPReceiveData: Irp %lx on fileobj %lx was cancelled\n",
                       Irp, IrpSp->FileObject));
        }

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        status = STATUS_CANCELLED;
    }

    return status;

}  // TCPReceiveData


//* UDPSendDatagram -
//
NTSTATUS  // Returns: whether the request was successfully queued.
UDPSendDatagram(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    TDI_STATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_SENDDG datagramInformation;
    ULONG bytesSent = 0;

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    datagramInformation = (PTDI_REQUEST_KERNEL_SENDDG) &(IrpSp->Parameters);
    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) ==
              TDI_TRANSPORT_ADDRESS_FILE);

    request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;

    IF_TCPDBG(TCP_DEBUG_SEND_DGRAM) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "UDPSendDatagram irp %lx sending %d bytes\n", Irp,
                   datagramInformation->SendLength));
    }

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = TdiSendDatagram(&request,
                                 datagramInformation->SendDatagramInformation,
                                 datagramInformation->SendLength, &bytesSent,
                                 (PNDIS_BUFFER) Irp->MdlAddress);

        if (status == TDI_PENDING) {
            return(status);
        }

        ASSERT(status != TDI_SUCCESS);
        ASSERT(bytesSent == 0);

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "UDPSendDatagram - irp %lx send failed, status %lx\n",
                   Irp, status));

        TCPDataRequestComplete(Irp, status, bytesSent);
        //
        // Return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING.
        //
        return(TDI_PENDING);
    }

    return status;

}  // UDPSendDatagram


//* UDPReceiveDatagram - Handle TDI ReceiveDatagram IRP.
//
//  Converts a TDI ReceiveDatagram IRP into a call to TdiReceiveDatagram.
//
NTSTATUS  // Returns: whether the request was successful.
UDPReceiveDatagram(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    TDI_STATUS status;
    TDI_REQUEST request;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_RECEIVEDG datagramInformation;
    uint bytesReceived = 0;

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    datagramInformation = (PTDI_REQUEST_KERNEL_RECEIVEDG) &(IrpSp->Parameters);
    ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) ==
              TDI_TRANSPORT_ADDRESS_FILE);

    request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;

    IF_TCPDBG(TCP_DEBUG_RECEIVE_DGRAM) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "UDPReceiveDatagram: irp %lx receiveing %d bytes\n", Irp,
                   datagramInformation->ReceiveLength));
    }

    status = TCPPrepareIrpForCancel(tcpContext, Irp, TCPCancelRequest);

    if (NT_SUCCESS(status)) {

        status = TdiReceiveDatagram(&request,
                     datagramInformation->ReceiveDatagramInformation,
                     datagramInformation->ReturnDatagramInformation,
                     datagramInformation->ReceiveLength, &bytesReceived,
                     Irp->MdlAddress);

        if (status == TDI_PENDING) {
            return(status);
        }

        ASSERT(status != TDI_SUCCESS);
        ASSERT(bytesReceived == 0);

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "UDPReceiveDatagram: irp %lx send failed, status %lx\n",
                   Irp, status));

        TCPDataRequestComplete(Irp, status, bytesReceived);
        //
        // Return PENDING because TCPPrepareIrpForCancel marks Irp as PENDING.
        //
        return(TDI_PENDING);
    }

    return status;

}  // UDPReceiveDatagram


//* TCPSetEventHandler - Handle TDI SetEventHandler IRP.
//
//  Converts a TDI SetEventHandler IRP into a call to TdiSetEventHandler.
//
NTSTATUS  // Returns: whether the request was successful.
TCPSetEventHandler(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    NTSTATUS status;
    PTDI_REQUEST_KERNEL_SET_EVENT  event;
    PTCP_CONTEXT tcpContext;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(Irp);

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    event = (PTDI_REQUEST_KERNEL_SET_EVENT) &(IrpSp->Parameters);

    IF_TCPDBG(TCP_DEBUG_EVENT_HANDLER) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPSetEventHandler: "
                   "irp %lx event %lx handler %lx context %lx\n", Irp,
                   event->EventType, event->EventHandler, event->EventContext));
    }

    status = TdiSetEvent(tcpContext->Handle.AddressHandle, event->EventType,
                         event->EventHandler, event->EventContext);

    ASSERT(status != TDI_PENDING);

    return(status);

}  // TCPSetEventHandler


//* TCPQueryInformation - Handle a TDI QueryInformation IRP.
//
//  Converts a TDI QueryInformation IRP into a call to TdiQueryInformation.
//
NTSTATUS  // Returns: whether request was successful.
TCPQueryInformation(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    TDI_REQUEST request;
    TDI_STATUS status = STATUS_SUCCESS;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION queryInformation;
    uint isConn = FALSE;
    uint dataSize = 0;

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    queryInformation = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)
                           &(IrpSp->Parameters);

    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;

    switch(queryInformation->QueryType) {

    case TDI_QUERY_BROADCAST_ADDRESS:
        ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) ==
                  TDI_CONTROL_CHANNEL_FILE);
        request.Handle.ControlChannel = tcpContext->Handle.ControlChannel;
        break;

    case TDI_QUERY_PROVIDER_INFO:
//
// NetBT does this.  Reinstate the ASSERT when it is fixed.
//
//      ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) ==
//                TDI_CONTROL_CHANNEL_FILE);
        request.Handle.ControlChannel = tcpContext->Handle.ControlChannel;
        break;

    case TDI_QUERY_ADDRESS_INFO:
        if (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) {
            //
            // This is a TCP connection object.
            //
            isConn = TRUE;
            request.Handle.ConnectionContext =
                tcpContext->Handle.ConnectionContext;
        } else {
            //
            // This is an address object.
            //
            request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
        }
        break;

    case TDI_QUERY_CONNECTION_INFO:

        if (PtrToUlong(IrpSp->FileObject->FsContext2) != TDI_CONNECTION_FILE){

            status = STATUS_INVALID_PARAMETER;

        } else {

            isConn = TRUE;
            request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
        }
        break;

    case TDI_QUERY_PROVIDER_STATISTICS:
        request.Handle.ControlChannel = tcpContext->Handle.ControlChannel;
        break;

    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if (NT_SUCCESS(status)) {
        //
        // This request isn't cancellable, but we put it through
        // the cancel path because it handles some checks for us
        // and tracks the irp.
        //
        status = TCPPrepareIrpForCancel(tcpContext, Irp, NULL);

        if (NT_SUCCESS(status)) {
            dataSize = TCPGetMdlChainByteCount(Irp->MdlAddress);

            status = TdiQueryInformation(&request, queryInformation->QueryType,
                                         Irp->MdlAddress, &dataSize, isConn);

            if (status != TDI_PENDING) {
                IrpSp->Control &= ~SL_PENDING_RETURNED;
                status = TCPDataRequestComplete(Irp, status, dataSize);
                return(status);
            }

            return(STATUS_PENDING);
        }

        return(status);
    }

    Irp->IoStatus.Status = (NTSTATUS) status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return(status);

}  // TCPQueryInformation


//* TCPQueryInformationExComplete - Complete a TdiQueryInformationEx request.
//
NTSTATUS
TCPQueryInformationExComplete(
    void *Context,           // A pointer to the IRP for this request.
    TDI_STATUS Status,       // Final TDI status of the request.
    unsigned int ByteCount)  // Bytes returned in output buffer.
{
    PTCP_QUERY_CONTEXT queryContext = (PTCP_QUERY_CONTEXT) Context;
    ULONG bytesCopied;

    if (NT_SUCCESS(Status)) {
        //
        // Copy the returned context to the input buffer.
        //
        TdiCopyBufferToMdl(&(queryContext->QueryInformation.Context), 0,
                           CONTEXT_SIZE, queryContext->InputMdl,
                           FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX,
                                        Context),
                           &bytesCopied);

        if (bytesCopied != CONTEXT_SIZE) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            ByteCount = 0;
        }
    }

    //
    // Unlock the user's buffers and free the MDLs describing them.
    //
    MmUnlockPages(queryContext->InputMdl);
    IoFreeMdl(queryContext->InputMdl);
    MmUnlockPages(queryContext->OutputMdl);
    IoFreeMdl(queryContext->OutputMdl);

    //
    // Complete the request.
    //
    Status = TCPDataRequestComplete(queryContext->Irp, Status, ByteCount);

    ExFreePool(queryContext);

    return Status;
}


//* TCPQueryInformationEx - Handle a TDI QueryInformationEx IRP.
//
//  Converts a TDI QueryInformationEx IRP into a call to TdiQueryInformationEx.
//
NTSTATUS  // Returns: whether the request was successful.
TCPQueryInformationEx(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    TDI_REQUEST request;
    TDI_STATUS status = STATUS_SUCCESS;
    PTCP_CONTEXT tcpContext;
    uint size;
    PTCP_REQUEST_QUERY_INFORMATION_EX InputBuffer;
    PVOID OutputBuffer;
    PMDL inputMdl = NULL;
    PMDL outputMdl = NULL;
    ULONG InputBufferLength, OutputBufferLength;
    PTCP_QUERY_CONTEXT queryContext;
    BOOLEAN inputLocked = FALSE;
    BOOLEAN outputLocked = FALSE;
    BOOLEAN inputBufferValid = FALSE;

    PAGED_CODE();

    IF_TCPDBG(TCP_DEBUG_INFO) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "QueryInformationEx starting - irp %lx fileobj %lx\n",
                   Irp, IrpSp->FileObject));
    }

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;

    switch (PtrToUlong(IrpSp->FileObject->FsContext2)) {

    case TDI_TRANSPORT_ADDRESS_FILE:
        request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
        break;

    case TDI_CONNECTION_FILE:
        request.Handle.ConnectionContext =
            tcpContext->Handle.ConnectionContext;
        break;

    case TDI_CONTROL_CHANNEL_FILE:
        request.Handle.ControlChannel = tcpContext->Handle.ControlChannel;
        break;

    default:
        ABORT();

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return(STATUS_INVALID_PARAMETER);
    }

    InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Validate the input parameters.
    //
    if (InputBufferLength >= sizeof(TCP_REQUEST_QUERY_INFORMATION_EX) &&
        InputBufferLength < MAXLONG) {
        inputBufferValid = TRUE;
    } else {
        inputBufferValid = FALSE;
    }
    if (inputBufferValid && (OutputBufferLength != 0)) {

        OutputBuffer = Irp->UserBuffer;
        InputBuffer = (PTCP_REQUEST_QUERY_INFORMATION_EX)
            IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        queryContext = ExAllocatePool(NonPagedPool, InputBufferLength
            + FIELD_OFFSET(TCP_QUERY_CONTEXT, QueryInformation));

        if (queryContext != NULL) {
            status = TCPPrepareIrpForCancel(tcpContext, Irp, NULL);

            if (!NT_SUCCESS(status)) {
                ExFreePool(queryContext);
                return(status);
            }

            //
            // Allocate Mdls to describe the input and output buffers.
            // Probe and lock the buffers.
            //
            try {
                inputMdl = IoAllocateMdl(InputBuffer, InputBufferLength,
                                         FALSE, TRUE, NULL);

                outputMdl = IoAllocateMdl(OutputBuffer, OutputBufferLength,
                                          FALSE, TRUE, NULL);

                if ((inputMdl != NULL) && (outputMdl != NULL)) {

                    MmProbeAndLockPages(inputMdl, Irp->RequestorMode,
                                        IoModifyAccess);

                    inputLocked = TRUE;

                    MmProbeAndLockPages(outputMdl, Irp->RequestorMode,
                                        IoWriteAccess);

                    outputLocked = TRUE;

                    //
                    // Copy the input parameter to our pool block so
                    // TdiQueryInformationEx can manipulate it directly.
                    //
                    RtlCopyMemory(&(queryContext->QueryInformation),
                                  InputBuffer,
                                  InputBufferLength);
                } else {

                    IF_TCPDBG(TCP_DEBUG_INFO) {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                                   "QueryInfoEx: Couldn't allocate MDL\n"));
                    }

                    IrpSp->Control &= ~SL_PENDING_RETURNED;

                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {

                IF_TCPDBG(TCP_DEBUG_INFO) {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                                   "QueryInfoEx: "
                                   "exception copying input param %lx\n",
                                   GetExceptionCode()));
                    }

                status = GetExceptionCode();
            }

            if (NT_SUCCESS(status)) {
                //
                // It's finally time to do this thing.
                //
                size = TCPGetMdlChainByteCount(outputMdl);

                queryContext->Irp = Irp;
                queryContext->InputMdl = inputMdl;
                queryContext->OutputMdl = outputMdl;

                request.RequestNotifyObject = TCPQueryInformationExComplete;
                request.RequestContext = queryContext;

                status = TdiQueryInformationEx(&request,
                                   &(queryContext->QueryInformation.ID),
                                   outputMdl, &size,
                                   &(queryContext->QueryInformation.Context),
                                   InputBufferLength - FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX, Context));

                if (status != TDI_PENDING) {

                    //
                    // Since status is not pending, clear the
                    // control flag to keep IO verifier happy.
                    //
                    IrpSp->Control &= ~SL_PENDING_RETURNED;

                    status = TCPQueryInformationExComplete(queryContext,
                                                           status, size);
                    return(status);
                }

                IF_TCPDBG(TCP_DEBUG_INFO) {
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                               "QueryInformationEx - "
                               "pending irp %lx fileobj %lx\n",
                               Irp, IrpSp->FileObject));
                }

                return(STATUS_PENDING);
            }

            //
            // If we get here, something failed.  Clean up.
            //
            if (inputMdl != NULL) {
                if (inputLocked) {
                    MmUnlockPages(inputMdl);
                }

                IoFreeMdl(inputMdl);
            }

            if (outputMdl != NULL) {
                if (outputLocked) {
                    MmUnlockPages(outputMdl);
                }

                IoFreeMdl(outputMdl);
            }

            ExFreePool(queryContext);

            // Since status is not pending, clear the
            // control flag to keep IO verifier happy.

            IrpSp->Control &= ~SL_PENDING_RETURNED;

            status = TCPDataRequestComplete(Irp, status, 0);

            return(status);

        } else {
            IrpSp->Control &= ~SL_PENDING_RETURNED;
            status = STATUS_INSUFFICIENT_RESOURCES;

            IF_TCPDBG(TCP_DEBUG_INFO) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "QueryInfoEx: Unable to allocate query context\n"));
            }
        }
    } else {
        status = STATUS_INVALID_PARAMETER;

        IF_TCPDBG(TCP_DEBUG_INFO) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "QueryInfoEx: Bad buffer len, OBufLen %d, InBufLen %d\n",
                       OutputBufferLength, InputBufferLength));
        }
    }

    IF_TCPDBG(TCP_DEBUG_INFO) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "QueryInformationEx complete - irp %lx, status %lx\n",
                   Irp, status));
    }

    Irp->IoStatus.Status = (NTSTATUS) status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return(status);
}


//* TCPSetInformationEx - Handle TDI SetInformationEx IRP.
//
//  Converts a TDI SetInformationEx IRP into a call to TdiSetInformationEx.
//
//  This routine does not pend.
//
NTSTATUS  // Returns: whether the request was successful.
TCPSetInformationEx(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    TDI_REQUEST request;
    TDI_STATUS status;
    PTCP_CONTEXT tcpContext;
    PTCP_REQUEST_SET_INFORMATION_EX setInformation;

    PAGED_CODE();

    IF_TCPDBG(TCP_DEBUG_INFO) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "SetInformationEx - irp %lx fileobj %lx\n", Irp,
                   IrpSp->FileObject));
    }

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    setInformation = (PTCP_REQUEST_SET_INFORMATION_EX)
                           Irp->AssociatedIrp.SystemBuffer;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) ||
        IrpSp->Parameters.DeviceIoControl.InputBufferLength -
        FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) < setInformation->BufferSize) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return (STATUS_INVALID_PARAMETER);
    }

    switch (PtrToUlong(IrpSp->FileObject->FsContext2)) {

    case TDI_TRANSPORT_ADDRESS_FILE:
        request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
        break;

    case TDI_CONNECTION_FILE:
        request.Handle.ConnectionContext =
            tcpContext->Handle.ConnectionContext;
        break;

    case TDI_CONTROL_CHANNEL_FILE:
        request.Handle.ControlChannel = tcpContext->Handle.ControlChannel;
        break;

    default:
        ABORT();
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Prevent non-privleged access (i.e. IOCTL_TCP_WSH_SET_INFORMATION_EX
    // calls) from making changes outside of the transport layer.
    // Privleged calls should be using IOCTL_TCP_SET_INFORMATION_EX instead.
    //
    if (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_TCP_WSH_SET_INFORMATION_EX) {
        uint Entity;

        Entity = setInformation->ID.toi_entity.tei_entity;

        if ((Entity != CO_TL_ENTITY) && (Entity != CL_TL_ENTITY) ) {
            Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
            return (STATUS_ACCESS_DENIED);
        }
    }

    status = TCPPrepareIrpForCancel(tcpContext, Irp, NULL);

    if (NT_SUCCESS(status)) {
        request.RequestNotifyObject = TCPDataRequestComplete;
        request.RequestContext = Irp;

        status = TdiSetInformationEx(&request, &(setInformation->ID),
                                     &(setInformation->Buffer[0]),
                                     setInformation->BufferSize);

        if (status != TDI_PENDING) {
            IrpSp->Control &= ~SL_PENDING_RETURNED;

            status = TCPDataRequestComplete(Irp, status, 0);

            return(status);
        }

        IF_TCPDBG(TCP_DEBUG_INFO) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "SetInformationEx - pending irp %lx fileobj %lx\n",
                       Irp, IrpSp->FileObject));
        }

        return(STATUS_PENDING);
    }

    IF_TCPDBG(TCP_DEBUG_INFO) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "SetInformationEx complete - irp %lx\n", Irp));
    }

    //
    // The irp has already been completed.
    //
    return(status);
}


#if 0
//* TCPEnumerateConnectionList -
//
//  Processes a request to enumerate the workstation connection list.
//
//  This routine does not pend.
//
NTSTATUS  // Return: whether the request was successful.
TCPEnumerateConnectionList(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{

    TCPConnectionListEntry *request;
    TCPConnectionListEnum *response;
    ULONG requestLength, responseLength;
    NTSTATUS status;

    PAGED_CODE();

    request = (TCPConnectionListEntry *) Irp->AssociatedIrp.SystemBuffer;
    response = (TCPConnectionListEnum *) request;
    requestLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    responseLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (responseLength < sizeof(TCPConnectionListEnum)) {
        status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = 0;
    } else {
        EnumerateConnectionList((uchar *) (response + 1),
                                responseLength - sizeof(TCPConnectionListEnum),
                                &(response->tce_entries_returned),
                                &(response->tce_entries_available));

        status = TDI_SUCCESS;
        Irp->IoStatus.Information = sizeof(TCPConnectionListEnum) +
            (response->tce_entries_returned * sizeof(TCPConnectionListEntry));
    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return(status);
}
#endif


//* TCPCreate -
//
NTSTATUS  // Returns: whether the request was successfully queued.
TCPCreate(
    IN PDEVICE_OBJECT DeviceObject,  // Device object for this request.
    IN PIRP Irp,                     // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)     // Current stack location in the Irp.
{
    TDI_REQUEST Request;
    NTSTATUS status;
    FILE_FULL_EA_INFORMATION *ea;
    FILE_FULL_EA_INFORMATION UNALIGNED *targetEA;
    PTCP_CONTEXT tcpContext;
    uint protocol;

    PAGED_CODE();

    tcpContext = ExAllocatePool(NonPagedPool, sizeof(TCP_CONTEXT));

    if (tcpContext == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

#if DBG
    InitializeListHead(&(tcpContext->PendingIrpList));
    InitializeListHead(&(tcpContext->CancelledIrpList));
#endif

    tcpContext->ReferenceCount = 1;  // Put initial reference on open object.
    tcpContext->CancelIrps = FALSE;
    KeInitializeEvent(&(tcpContext->CleanupEvent), SynchronizationEvent,
                      FALSE);
    KeInitializeSpinLock(&tcpContext->EndpointLock);

    ea = (PFILE_FULL_EA_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    //
    // See if this is a Control Channel open.
    //
    if (!ea) {
        IF_TCPDBG(TCP_DEBUG_OPEN) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPCreate: "
                       "Opening control channel for file object %lx\n",
                       IrpSp->FileObject));
        }

        tcpContext->Handle.ControlChannel = NULL;
        IrpSp->FileObject->FsContext = tcpContext;
        IrpSp->FileObject->FsContext2 = (PVOID) TDI_CONTROL_CHANNEL_FILE;

        return(STATUS_SUCCESS);
    }

    //
    // See if this is an Address Object open.
    //
    targetEA = FindEA(ea, TdiTransportAddress, TDI_TRANSPORT_ADDRESS_LENGTH);

    if (targetEA != NULL) {
        UCHAR optionsBuffer[3];
        PUCHAR optionsPointer = optionsBuffer;
        PSECURITY_DESCRIPTOR addrSD = NULL;

        if (DeviceObject == TCPDeviceObject) {
            protocol = IP_PROTOCOL_TCP;
        }
        else if (DeviceObject == UDPDeviceObject) {
            protocol = IP_PROTOCOL_UDP;

            ASSERT(optionsPointer - optionsBuffer <= 3);

            if (IsDHCPZeroAddress((TRANSPORT_ADDRESS UNALIGNED *)
                &(targetEA->EaName[targetEA->EaNameLength + 1]))) {

                if (!IsAdminIoRequest(Irp, IrpSp)) {
                    ExFreePool(tcpContext);
                    return(STATUS_ACCESS_DENIED);
                }

                *optionsPointer = TDI_ADDRESS_OPTION_DHCP;
                optionsPointer++;
            }

            ASSERT(optionsPointer - optionsBuffer <= 3);
        } else {
            //
            // This is a raw ip open.
            //

            //
            // Only administrators can create raw addresses
            // unless this is allowed through registry.
            //
            if (!AllowUserRawAccess && !IsAdminIoRequest(Irp, IrpSp)) {
                ExFreePool(tcpContext);
                return(STATUS_ACCESS_DENIED);
            }

            protocol = RawExtractProtocolNumber(
                &(IrpSp->FileObject->FileName));

            //
            // We need to protect the IPv6Send routine's packet rewriting
            // code (for fragmentation, header inclusion, etc) from getting
            // confused by malformed extension headers coming from user-land.
            // So we disallow these types.
            //
            if ((protocol == 0xFFFFFFFF) ||
                IsExtensionHeader((uchar)protocol)) {
                ExFreePool(tcpContext);
                return(STATUS_INVALID_PARAMETER);
            }

            *optionsPointer = TDI_ADDRESS_OPTION_RAW;
            optionsPointer++;
        }

        if ((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
            (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)) {

            *optionsPointer = TDI_ADDRESS_OPTION_REUSE;
            optionsPointer++;
        }

        *optionsPointer = TDI_OPTION_EOL;

        Request.Handle.AddressHandle = NULL;
        Request.RequestContext = Irp;
        if (protocol == IP_PROTOCOL_TCP || protocol == IP_PROTOCOL_UDP) {
            status = CaptureCreatorSD(Irp, IrpSp, &addrSD);
        } else {
            status = STATUS_SUCCESS;
        }

        IF_TCPDBG(TCP_DEBUG_OPEN) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPCreate: Opening address for file object %lx\n",
                       IrpSp->FileObject));
        }

        if (NT_SUCCESS(status)) {
            status = TdiOpenAddress(&Request, (TRANSPORT_ADDRESS UNALIGNED *)
                                &(targetEA->EaName[targetEA->EaNameLength + 1]),
                                protocol, optionsBuffer, addrSD);
        }

        if (NT_SUCCESS(status)) {
            //
            // Save off the handle to the AO passed back.
            //
            tcpContext->Handle.AddressHandle = Request.Handle.AddressHandle;
            IrpSp->FileObject->FsContext = tcpContext;
            IrpSp->FileObject->FsContext2 = (PVOID) TDI_TRANSPORT_ADDRESS_FILE;
        } else {
            if (addrSD != NULL) {
                ObDereferenceSecurityDescriptor(addrSD, 1);
            }
            ExFreePool(tcpContext);
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "TdiOpenAddress failed, status %lx\n", status));
            if (status == STATUS_ADDRESS_ALREADY_EXISTS) {
                status = STATUS_SHARING_VIOLATION;
            }
        }

        ASSERT(status != TDI_PENDING);

        return(status);
    }

    //
    // See if this is a Connection Object open.
    //
    targetEA = FindEA(ea, TdiConnectionContext, TDI_CONNECTION_CONTEXT_LENGTH);

    if (targetEA != NULL) {
        //
        // This is an open of a Connection Object.
        //

        if (DeviceObject == TCPDeviceObject) {
            //
            // Keep W4 happy.
            //
            Request.Handle.ConnectionContext = NULL;

            IF_TCPDBG(TCP_DEBUG_OPEN) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TCPCreate: Opening connection for file object %lx\n",
                           IrpSp->FileObject));
            }

            if (targetEA->EaValueLength < sizeof(CONNECTION_CONTEXT)) {
                status = STATUS_EA_LIST_INCONSISTENT;
            } else {
                status = TdiOpenConnection(&Request,
                             *((CONNECTION_CONTEXT UNALIGNED *)
                             &(targetEA->EaName[targetEA->EaNameLength + 1])));
            }

            if (NT_SUCCESS(status)) {
                //
                // Save off the Connection Context passed back.
                //
                tcpContext->Handle.ConnectionContext =
                    Request.Handle.ConnectionContext;
                IrpSp->FileObject->FsContext = tcpContext;
                IrpSp->FileObject->FsContext2 = (PVOID) TDI_CONNECTION_FILE;
            } else {
                ExFreePool(tcpContext);
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                           "TdiOpenConnection failed, status %lx\n", status));
            }
        } else {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                       "TCP: TdiOpenConnection issued on UDP device!\n"));
            status = STATUS_INVALID_DEVICE_REQUEST;
            ExFreePool(tcpContext);
        }

        ASSERT(status != TDI_PENDING);

        return(status);
    }

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
               "TCPCreate: didn't find any useful ea's\n"));
    status = STATUS_INVALID_EA_NAME;
    ExFreePool(tcpContext);

    ASSERT(status != TDI_PENDING);

    return(status);

}  // TCPCreate


//* IsAdminIoRequest -
//
//  (Lifted from AFD - AfdPerformSecurityCheck)
//  Compares security context of the endpoint creator to that
//  of the administrator and local system.
//
BOOLEAN // return TRUE if socket creator has admin or local system privilege
IsAdminIoRequest(
    PIRP Irp,                   // Pointer to I/O request packet.
    PIO_STACK_LOCATION IrpSp)   // Pointer to the I/O stack location to use for this request.
{
    BOOLEAN accessGranted;
    PACCESS_STATE accessState;
    PIO_SECURITY_CONTEXT securityContext;
    PPRIVILEGE_SET privileges = NULL;
    ACCESS_MASK grantedAccess;
    PGENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    NTSTATUS Status;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&AccessMask, GenericMapping);

    securityContext = IrpSp->Parameters.Create.SecurityContext;
    accessState = securityContext->AccessState;

    SeLockSubjectContext(&accessState->SubjectSecurityContext);

    accessGranted = SeAccessCheck(TcpAdminSecurityDescriptor,
                                  &accessState->SubjectSecurityContext,
                                  TRUE,
                                  AccessMask,
                                  0,
                                  &privileges,
                                  IoGetFileObjectGenericMapping(),
                                  (KPROCESSOR_MODE) ((IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                                                     ? UserMode
                                                     : Irp->RequestorMode),
                                  &grantedAccess,
                                  &Status);

    if (privileges) {
        (VOID) SeAppendPrivileges(accessState,
                                  privileges);
        SeFreePrivileges(privileges);
    }
    if (accessGranted) {
        accessState->PreviouslyGrantedAccess |= grantedAccess;
        accessState->RemainingDesiredAccess &= ~(grantedAccess | MAXIMUM_ALLOWED);
        ASSERT(NT_SUCCESS(Status));
    } else {
        ASSERT(!NT_SUCCESS(Status));
    }
    SeUnlockSubjectContext(&accessState->SubjectSecurityContext);

    return accessGranted;
} // IsAdminIoRequest


//* TCPCloseObjectComplete -
//
//  Completes a TdiCloseConnectoin or TdiCloseAddress request.
//
void                      // Returns: Nothing.
TCPCloseObjectComplete(
    void *Context,        // Pointer to the IRP for this request.
    unsigned int Status,  // Final status of the operation.
    unsigned int UnUsed)  // Unused parameter.
{
    KIRQL oldIrql;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTCP_CONTEXT tcpContext;

    UNREFERENCED_PARAMETER(UnUsed);

    irp = (PIRP) Context;
    irpSp = IoGetCurrentIrpStackLocation(irp);
    tcpContext = (PTCP_CONTEXT) irpSp->FileObject->FsContext;
    irp->IoStatus.Status = Status;

    IF_TCPDBG(TCP_DEBUG_CLEANUP) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPCloseObjectComplete on file object %lx\n",
                 irpSp->FileObject));
    }

    KeAcquireSpinLock(&tcpContext->EndpointLock, &oldIrql);

    ASSERT(tcpContext->ReferenceCount > 0);
    ASSERT(tcpContext->CancelIrps);

    //
    // Remove the initial reference that was put on by TCPCreate.
    //
    ASSERT(tcpContext->ReferenceCount > 0);

    IF_TCPDBG(TCP_DEBUG_IRP) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPCloseObjectComplete: "
                   "irp %lx fileobj %lx refcnt dec to %u\n",
                   irp, irpSp, tcpContext->ReferenceCount - 1));
    }

    if (--(tcpContext->ReferenceCount) == 0) {

        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            ASSERT(IsListEmpty(&(tcpContext->CancelledIrpList)));
            ASSERT(IsListEmpty(&(tcpContext->PendingIrpList)));
        }

        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);
        KeSetEvent(&(tcpContext->CleanupEvent), 0, FALSE);
        return;
    }

    KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

    return;

}  // TCPCloseObjectComplete



//* TCPCleanup -
//
//  Cancels all outstanding Irps on a TDI object by calling the close
//  routine for the object. It then waits for them to be completed
//  before returning.
//
//  This routine blocks, but does not pend.
//
NTSTATUS  // Returns: whether the request was successfully queued.
TCPCleanup(
    IN PDEVICE_OBJECT DeviceObject,  // Device object for this request.
    IN PIRP Irp,                     // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)     // Current stack location in the Irp.
{
    KIRQL oldIrql;
    PTCP_CONTEXT tcpContext;
    NTSTATUS status;
    TDI_REQUEST request;

    UNREFERENCED_PARAMETER(DeviceObject);

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;

    KeAcquireSpinLock(&tcpContext->EndpointLock, &oldIrql);

    tcpContext->CancelIrps = TRUE;
    KeResetEvent(&(tcpContext->CleanupEvent));

    KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

    //
    // Now call the TDI close routine for this object to force all of its Irps
    // to complete.
    //
    request.RequestNotifyObject = TCPCloseObjectComplete;
    request.RequestContext = Irp;

    switch (PtrToUlong(IrpSp->FileObject->FsContext2)) {

    case TDI_TRANSPORT_ADDRESS_FILE:
        IF_TCPDBG(TCP_DEBUG_CLOSE) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPCleanup: Closing address object on file object %lx\n",
                       IrpSp->FileObject));
        }
        request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
        status = TdiCloseAddress(&request);
        break;

    case TDI_CONNECTION_FILE:
        IF_TCPDBG(TCP_DEBUG_CLOSE) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPCleanup: "
                       "Closing Connection object on file object %lx\n",
                       IrpSp->FileObject));
        }
        request.Handle.ConnectionContext =
            tcpContext->Handle.ConnectionContext;
        status = TdiCloseConnection(&request);
        break;

    case TDI_CONTROL_CHANNEL_FILE:
        IF_TCPDBG(TCP_DEBUG_CLOSE) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "TCPCleanup: Closing Control Channel object on"
                       " file object %lx\n", IrpSp->FileObject));
        }
        status = STATUS_SUCCESS;
        break;

    default:
        //
        // This should never happen.
        //
        ABORT();

        KeAcquireSpinLock(&tcpContext->EndpointLock, &oldIrql);
        tcpContext->CancelIrps = FALSE;
        KeReleaseSpinLock(&tcpContext->EndpointLock, oldIrql);

        return(STATUS_INVALID_PARAMETER);
    }

    if (status != TDI_PENDING) {
        TCPCloseObjectComplete(Irp, status, 0);
    }

    IF_TCPDBG(TCP_DEBUG_CLEANUP) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPCleanup: waiting for completion of Irps on"
                   " file object %lx\n", IrpSp->FileObject));
    }

    status = KeWaitForSingleObject(&(tcpContext->CleanupEvent), UserRequest,
                                   KernelMode, FALSE, NULL);

    ASSERT(NT_SUCCESS(status));

    IF_TCPDBG(TCP_DEBUG_CLEANUP) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPCleanup: Wait on file object %lx finished\n",
                   IrpSp->FileObject));
    }

    //
    // The cleanup Irp will be completed by the dispatch routine.
    //

    return(Irp->IoStatus.Status);

}  // TCPCleanup


//* TCPClose -
//
//  Dispatch routine for MJ_CLOSE IRPs.  Performs final cleanup of the
//  open endpoint.
//
//  This request does not pend.
//
NTSTATUS  // Returns: whether the request was successfully queued.
TCPClose(
    IN PIRP Irp,                     // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)     // Current stack location in the Irp.
{
    PTCP_CONTEXT tcpContext;

    UNREFERENCED_PARAMETER(Irp);

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;

#if DBG

    IF_TCPDBG(TCP_DEBUG_CANCEL) {

        KIRQL oldIrql;

        IoAcquireCancelSpinLock(&oldIrql);

        ASSERT(tcpContext->ReferenceCount == 0);
        ASSERT(IsListEmpty(&(tcpContext->PendingIrpList)));
        ASSERT(IsListEmpty(&(tcpContext->CancelledIrpList)));

        IoReleaseCancelSpinLock(oldIrql);
    }
#endif // DBG

    IF_TCPDBG(TCP_DEBUG_CLOSE) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCPClose on file object %lx\n", IrpSp->FileObject));
    }

    ExFreePool(tcpContext);

    return(STATUS_SUCCESS);

}  // TCPClose


//* TCPDispatchDeviceControl -
//
NTSTATUS  // Returns: whether the request was successfully queued.
TCPDispatchDeviceControl(
    IN PIRP Irp,                  // I/O request packet.
    IN PIO_STACK_LOCATION IrpSp)  // Current stack location in the Irp.
{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Set this in advance.  Any IOCTL dispatch routine that cares about it
    // will modify it itself.
    //
    Irp->IoStatus.Information = 0;

    switch(IrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_TCP_QUERY_INFORMATION_EX:
        return(TCPQueryInformationEx(Irp, IrpSp));
        break;

    case IOCTL_TCP_SET_INFORMATION_EX:
    case IOCTL_TCP_WSH_SET_INFORMATION_EX:
        return(TCPSetInformationEx(Irp, IrpSp));
        break;

    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return status;

}  // TCPDispatchDeviceControl


//* TCPDispatchInternalDeviceControl -
//
//  This is the dispatch routine for Internal Device Control IRPs.
//  This is the hot path for kernel-mode clients.
//
NTSTATUS  // Returns: whether the request was successfully queued.
TCPDispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,  // Device object for target device.
    IN PIRP Irp)                     // I/O request packet.
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    if (DeviceObject != IPDeviceObject) {

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        if (PtrToUlong(irpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) {
            //
            // Send and receive are the performance path, so check for them
            // right away.
            //
            if (irpSp->MinorFunction == TDI_SEND) {
                return(TCPSendData(Irp, irpSp));
            }

            if (irpSp->MinorFunction == TDI_RECEIVE) {
                return(TCPReceiveData(Irp, irpSp));
            }

            switch(irpSp->MinorFunction) {

            case TDI_ASSOCIATE_ADDRESS:
                status = TCPAssociateAddress(Irp, irpSp);
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

                return(status);

            case TDI_DISASSOCIATE_ADDRESS:
                return(TCPDisassociateAddress(Irp, irpSp));

            case TDI_CONNECT:
                return(TCPConnect(Irp, irpSp));

            case TDI_DISCONNECT:
                return(TCPDisconnect(Irp, irpSp));

            case TDI_LISTEN:
                return(TCPListen(Irp, irpSp));

            case TDI_ACCEPT:
                return(TCPAccept(Irp, irpSp));

            default:
                break;
            }

            //
            // Fall through.
            //
        }
        else if (PtrToUlong(irpSp->FileObject->FsContext2) ==
                 TDI_TRANSPORT_ADDRESS_FILE) {

            if (irpSp->MinorFunction == TDI_SEND_DATAGRAM) {
                return(UDPSendDatagram(Irp, irpSp));
            }

            if (irpSp->MinorFunction == TDI_RECEIVE_DATAGRAM) {
                return(UDPReceiveDatagram(Irp, irpSp));
            }

            if (irpSp->MinorFunction ==  TDI_SET_EVENT_HANDLER) {
                status = TCPSetEventHandler(Irp, irpSp);

                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

                return(status);
            }

            //
            // Fall through.
            //
        }

        ASSERT(
           (PtrToUlong(irpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE)
           ||
           (PtrToUlong(irpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE)
           ||
           (PtrToUlong(irpSp->FileObject->FsContext2) == TDI_CONTROL_CHANNEL_FILE));

        //
        // These functions are common to all endpoint types.
        //
        switch(irpSp->MinorFunction) {

        case TDI_QUERY_INFORMATION:
            return(TCPQueryInformation(Irp, irpSp));

        case TDI_SET_INFORMATION:
        case TDI_ACTION:
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                       "TCP: Call to unimplemented TDI function 0x%p\n",
                       irpSp->MinorFunction));
            status = STATUS_NOT_IMPLEMENTED;
            break;

        default:
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                       "TCP: call to invalid TDI function 0x%p\n",
                       irpSp->MinorFunction));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        ASSERT(status != TDI_PENDING);

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return status;
    }

    return(IPDispatch(DeviceObject, Irp));
}


//* TCPDispatch -
//
//  This is the generic dispatch routine for TCP/UDP/RawIP.
//
NTSTATUS  // Returns: whether the request was successfully queued.
TCPDispatch(
    IN PDEVICE_OBJECT DeviceObject,  // Device object for target device.
    IN PIRP Irp)                     // I/O request packet.
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    if (DeviceObject != IPDeviceObject) {

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        ASSERT(irpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL);

        switch (irpSp->MajorFunction) {

        case IRP_MJ_CREATE:
            status = TCPCreate(DeviceObject, Irp, irpSp);
            break;

        case IRP_MJ_CLEANUP:
            status = TCPCleanup(DeviceObject, Irp, irpSp);
            break;

        case IRP_MJ_CLOSE:
            status = TCPClose(Irp, irpSp);
            break;

        case IRP_MJ_DEVICE_CONTROL:
            status = TdiMapUserRequest(DeviceObject, Irp, irpSp);

            if (status == STATUS_SUCCESS) {
                return(TCPDispatchInternalDeviceControl(DeviceObject, Irp));
            }

            if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                    IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER) {
                if (Irp->RequestorMode == KernelMode) {
                    *(PULONG_PTR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer = (ULONG_PTR)TCPSendData;
                    status = STATUS_SUCCESS;
                } else {
                    status = STATUS_ACCESS_DENIED;
                }
                break;
            }

            return(TCPDispatchDeviceControl(Irp,
                                        IoGetCurrentIrpStackLocation(Irp)));
            break;

        case IRP_MJ_QUERY_SECURITY:
            //
            // This is generated on Raw endpoints.  We don't do anything
            // for it.
            //
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case IRP_MJ_WRITE:
        case IRP_MJ_READ:

        default:
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                       "TCPDispatch: Irp %lx unsupported major function 0x%lx\n",
                       irpSp, irpSp->MajorFunction));
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        ASSERT(status != TDI_PENDING);

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return status;
    }

    return(IPDispatch(DeviceObject, Irp));

}  // TCPDispatch


//
// Private utility functions
//

//* FindEA -
//
//  Parses and extended attribute list for a given target attribute.
//
FILE_FULL_EA_INFORMATION UNALIGNED * // Returns: requested attribute or NULL.
FindEA(
    PFILE_FULL_EA_INFORMATION StartEA,  // First extended attribute in list.
    CHAR *TargetName,                   // Name of target attribute.
    USHORT TargetNameLength)            // Length of above.
{
    USHORT i;
    BOOLEAN found;
    FILE_FULL_EA_INFORMATION UNALIGNED *CurrentEA;

    PAGED_CODE();

    do {
        found = TRUE;

        CurrentEA = StartEA;
        StartEA += CurrentEA->NextEntryOffset;

        if (CurrentEA->EaNameLength != TargetNameLength) {
            continue;
        }

        for (i=0; i < CurrentEA->EaNameLength; i++) {
            if (CurrentEA->EaName[i] == TargetName[i]) {
                continue;
            }
            found = FALSE;
            break;
        }

        if (found) {
            return(CurrentEA);
        }

    } while(CurrentEA->NextEntryOffset != 0);

    return(NULL);
}

//* IsDHCPZeroAddress -
//
//  Checks a TDI IP address list for an address from DHCP binding
//  to the IP address zero.  Normally, binding to zero means wildcard.
//  For DHCP, it really means bind to an interface with an address of
//  zero.  This semantic is flagged by a special value in an unused
//  portion of the address structure (ie. this is a kludge).
//
BOOLEAN  // Returns: TRUE iff first IP address found had the flag set.
IsDHCPZeroAddress(
    TRANSPORT_ADDRESS UNALIGNED *AddrList)  // TDI transport address list
                                            // passed in the create IRP.
{
    int i;                              // Index variable.
    TA_ADDRESS *CurrentAddr;  // Address we're examining and may use.

    // First, verify that someplace in Address is an address we can use.
    CurrentAddr = (TA_ADDRESS *)AddrList->Address;

    for (i = 0; i < AddrList->TAAddressCount; i++) {
        if (CurrentAddr->AddressType == TDI_ADDRESS_TYPE_IP) {
            if (CurrentAddr->AddressLength == TDI_ADDRESS_LENGTH_IP) {
                TDI_ADDRESS_IP UNALIGNED *ValidAddr;

                ValidAddr = (TDI_ADDRESS_IP UNALIGNED *)CurrentAddr->Address;

                if (*((ULONG UNALIGNED *) ValidAddr->sin_zero) == 0x12345678) {
                    return TRUE;
                }

            } else {
                return FALSE;  // Wrong length for address.
            }
        } else {
            CurrentAddr = (TA_ADDRESS *)
                          (CurrentAddr->Address + CurrentAddr->AddressLength);
        }
    }

    return FALSE;  // Didn't find a match.
}


//* TCPGetMdlChainByteCount -
//
//  Sums the byte counts of each MDL in a chain.
//
ULONG  // Returns: byte count of the MDL chain.
TCPGetMdlChainByteCount(
    PMDL Mdl)  // MDL chain to sum.
{
    ULONG count = 0;

    while (Mdl != NULL) {
        count += MmGetMdlByteCount(Mdl);
        Mdl = Mdl->Next;
    }

    return(count);
}


//* RawExtractProtocolNumber -
//
//  Extracts the protocol number from the file object name.
//
ULONG  // Returns: the protocol number or 0xFFFFFFFF on error.
RawExtractProtocolNumber(
    IN PUNICODE_STRING FileName)  // File name (Unicode).
{
    PWSTR name;
    UNICODE_STRING unicodeString;
    ULONG protocol;
    NTSTATUS status;

    PAGED_CODE();

    name = FileName->Buffer;

    if (FileName->Length < (sizeof(OBJ_NAME_PATH_SEPARATOR) + sizeof(WCHAR))) {
        return(0xFFFFFFFF);
    }

    //
    // Step over separator.
    //
    if (*name++ != OBJ_NAME_PATH_SEPARATOR) {
        return(0xFFFFFFFF);
    }

    if (*name == UNICODE_NULL) {
        return(0xFFFFFFFF);
    }

    //
    // Convert the remaining name into a number.
    //
    RtlInitUnicodeString(&unicodeString, name);

    status = RtlUnicodeStringToInteger(&unicodeString, 10, &protocol);

    if (!NT_SUCCESS(status)) {
        return(0xFFFFFFFF);
    }

    if (protocol > 255) {
        return(0xFFFFFFFF);
    }

    return(protocol);
}

//* CaptureCreatorSD -
//
//  Captures the security-descriptor associated with an IRP_MJ_CREATE request.
//
NTSTATUS // Returns: status of the capture attempt.
CaptureCreatorSD(
    PIRP Irp, // IRP_MJ_CREATE request packet.
    PIO_STACK_LOCATION IrpSp, // Stack-location containing create parameters.
    OUT PSECURITY_DESCRIPTOR* CreatorSD) // Receives the captured SD.
{
    NTSTATUS status;
    PSECURITY_DESCRIPTOR mergedSD;
    PACCESS_STATE accessState =
        IrpSp->Parameters.Create.SecurityContext->AccessState;

    PAGED_CODE();

    if (Irp->RequestorMode == KernelMode &&
        IrpSp->Parameters.Create.ShareAccess == 0 &&
        accessState->SecurityDescriptor == NULL) {
        *CreatorSD = NULL;
        status = STATUS_SUCCESS;
    } else {
        //
        // Take a read-lock on the subject security context for the request,
        // and merge the request's SD into a new SD.
        //
        SeLockSubjectContext(&accessState->SubjectSecurityContext);
        status = SeAssignSecurity(NULL, accessState->SecurityDescriptor,
                                  &mergedSD, FALSE,
                                  &accessState->SubjectSecurityContext,
                                  IoGetFileObjectGenericMapping(), PagedPool);
        SeUnlockSubjectContext(&accessState->SubjectSecurityContext);
        if (NT_SUCCESS(status)) {
            // Request a tracked and referenced copy of the merged SD.

            status = ObLogSecurityDescriptor(mergedSD, CreatorSD, 1);
            ExFreePool(mergedSD);
        }
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\tdilocal.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Locally definied TDI function prototypes.
//


#ifndef TDILOCAL_INCLUDED
#define TDILOCAL_INCLUDED 1

extern TDI_STATUS
TdiOpenAddress(PTDI_REQUEST Request, TRANSPORT_ADDRESS UNALIGNED *AddrList,
               uint protocol, void *Reuse, PSECURITY_DESCRIPTOR AddrSD);

extern TDI_STATUS
TdiCloseAddress(PTDI_REQUEST Request);

extern TDI_STATUS
TdiOpenConnection(PTDI_REQUEST Request, PVOID Context);

extern TDI_STATUS
TdiCloseConnection(PTDI_REQUEST Request);

extern TDI_STATUS
TdiAssociateAddress(PTDI_REQUEST Request, HANDLE AddrHandle);

extern TDI_STATUS
TdiCancelDisAssociateAddress(PTDI_REQUEST Request);

extern TDI_STATUS
TdiDisAssociateAddress(PTDI_REQUEST Request);

extern TDI_STATUS
TdiConnect(PTDI_REQUEST Request, void *Timeout,
           PTDI_CONNECTION_INFORMATION RequestAddr,
           PTDI_CONNECTION_INFORMATION ReturnAddr);

extern TDI_STATUS
TdiListen(PTDI_REQUEST Request, ushort Flags,
          PTDI_CONNECTION_INFORMATION AcceptableAddr,
          PTDI_CONNECTION_INFORMATION ConnectedAddr);

extern TDI_STATUS
TdiAccept(PTDI_REQUEST Request, PTDI_CONNECTION_INFORMATION AcceptInfo,
          PTDI_CONNECTION_INFORMATION ConnectedInfo);

extern TDI_STATUS
TdiDisconnect(PTDI_REQUEST Request, void *TO, ushort Flags,
              PTDI_CONNECTION_INFORMATION DiscConnInfo,
              PTDI_CONNECTION_INFORMATION ReturnInfo,
              TCPAbortReq *AbortReq);

extern TDI_STATUS
TdiSend(PTDI_REQUEST Request, ushort Flags, uint SendLength,
        PNDIS_BUFFER SendBuffer);

extern TDI_STATUS
TdiReceive(PTDI_REQUEST Request, ushort *Flags, ULONG *RcvLength,
           PNDIS_BUFFER Buffer);

extern TDI_STATUS
TdiSendDatagram(PTDI_REQUEST Request, PTDI_CONNECTION_INFORMATION ConnInfo,
                uint DataSize, ULONG *BytesSent, PNDIS_BUFFER Buffer);

VOID
TdiCancelSendDatagram(AddrObj *SrcAO, PVOID Context, PKSPIN_LOCK EndpointLock,
                      KIRQL CancelIrql);

extern TDI_STATUS
TdiReceiveDatagram(PTDI_REQUEST Request, PTDI_CONNECTION_INFORMATION ConnInfo,
                   PTDI_CONNECTION_INFORMATION ReturnInfo, uint RcvSize,
                   uint *BytesRcvd, PNDIS_BUFFER Buffer);

VOID
TdiCancelReceiveDatagram(AddrObj *SrcAO, PVOID Context,
                         PKSPIN_LOCK EndpointLock, KIRQL CancelIrql);

extern TDI_STATUS
TdiSetEvent(PVOID Handle, int Type, PVOID Handler, PVOID Context);

extern TDI_STATUS
TdiQueryInformation(PTDI_REQUEST Request, uint QueryType, PNDIS_BUFFER Buffer,
                    uint *BytesReturned, uint IsConn);

extern TDI_STATUS
TdiSetInformation(PTDI_REQUEST Request, uint SetType, PNDIS_BUFFER Buffer,
                  uint BufferSize, uint IsConn);

extern TDI_STATUS
TdiQueryInformationEx(PTDI_REQUEST Request, struct TDIObjectID *ID,
                      PNDIS_BUFFER Buffer, uint *Size, void *Context,
                      uint ContextSize);

extern TDI_STATUS
TdiSetInformationEx(PTDI_REQUEST Request, struct TDIObjectID *ID,
                    void *Buffer, uint Size);

extern TDI_STATUS
TdiAction(PTDI_REQUEST Request, uint ActionType, PNDIS_BUFFER Buffer,
          uint BufferSize);

#endif  // TDILOCAL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\transprt.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Common transport layer code.  This file contains code for routines
// that are common to both TCP and UDP.
//


#include "oscfg.h"
#include "ndis.h"
#include "tdi.h"
#include "tdistat.h"
#include "tdikrnl.h"
#include "ip6imp.h"
#include "transprt.h"

#define NO_TCP_DEFS 1
#include "tcpdeb.h"

//* BuildTDIAddress - Build a TDI address structure.
//
//  Called when we need to build a TDI address structure. We fill in
//  the specifed buffer with the correct information in the correct
//  format.
//
void  // Returns: Nothing.
BuildTDIAddress(
    uchar *Buffer,   // Buffer to fill in as TDI address structure.
    IPv6Addr *Addr,  // IP address to fill in.
    ulong ScopeId,   // Scope id to fill in.
    ushort Port)     // Port to fill in.
{
    PTRANSPORT_ADDRESS XportAddr;
    PTA_ADDRESS TAAddr;

    XportAddr = (PTRANSPORT_ADDRESS)Buffer;
    XportAddr->TAAddressCount = 1;
    TAAddr = XportAddr->Address;
    TAAddr->AddressType = TDI_ADDRESS_TYPE_IP6;
    TAAddr->AddressLength = sizeof(TDI_ADDRESS_IP6);
    ((PTDI_ADDRESS_IP6)TAAddr->Address)->sin6_port = Port;
    ((PTDI_ADDRESS_IP6)TAAddr->Address)->sin6_scope_id = ScopeId;
    RtlCopyMemory(((PTDI_ADDRESS_IP6)TAAddr->Address)->sin6_addr, Addr,
                  sizeof(IPv6Addr));
}

//* UpdateConnInfo - Update a connection information structure.
//
//  Called when we need to update a connection information structure. We
//  copy any options, and create a transport address. If any buffer is
//  too small we return an error.
//
TDI_STATUS  //  Returns: TDI_SUCCESS if ok, TDI_BUFFER_OVERFLOW for an error.
UpdateConnInfo(
    PTDI_CONNECTION_INFORMATION ConnInfo,  // Structure to fill in.
    IPv6Addr *SrcAddress,                  // Source IP address.
    ulong SrcScopeId,                      // Scope id for address.
    ushort SrcPort)                        // Source port.
{
    TDI_STATUS Status = TDI_SUCCESS;   // Default status to return.
    uint AddrLength;

    if (ConnInfo != NULL) {
        ConnInfo->UserDataLength = 0;   // No user data.

#if 0
        // Fill in the options. If the provided buffer is too small,
        // we'll truncate the options and return an error. Otherwise
        // we'll copy the whole IP option buffer.
        if (ConnInfo->OptionsLength) {
            if (ConnInfo->OptionsLength < OptInfo->ioi_optlength) {
                Status = TDI_BUFFER_OVERFLOW;
                OptLength = ConnInfo->OptionsLength;
            } else
                OptLength = OptInfo->ioi_optlength;

            RtlCopyMemory(ConnInfo->Options, OptInfo->ioi_options, OptLength);

            ConnInfo->OptionsLength = OptLength;
        }
#endif

        // Options are copied. Build a TRANSPORT_ADDRESS structure in
        // the buffer.
        if ((AddrLength = ConnInfo->RemoteAddressLength) != 0) {

            // Make sure we have at least enough to fill in the count and type.
            if (AddrLength >= TCP_TA_SIZE) {

                // The address fits. Fill it in.
                ConnInfo->RemoteAddressLength = TCP_TA_SIZE;
                BuildTDIAddress(ConnInfo->RemoteAddress, SrcAddress,
                                SrcScopeId, SrcPort);

            } else {
                ConnInfo->RemoteAddressLength = 0;
                Status = TDI_INVALID_PARAMETER;
            }
        }
    }

    return Status;
}

//* SystemUpTime - get time since system boot in milliseconds.
//
//  Get our system uptime in ticks and then convert it into milliseconds.
//  This resolution is small enough for most purposes and big enough for
//  a reasonable length of time (48 days) to fit into a 32-bit word.
//  For fast timestamps, however, it is best to use tick counts directly.
//
//  REVIEW: rework transports to use a more directly available time unit?
//
unsigned long  // Returns: Low order 32-bits worth of time since boot in ms.
SystemUpTime(
    void)
{
    LARGE_INTEGER TickCount;

    KeQueryTickCount(&TickCount);  // In ticks.
    TickCount.QuadPart *= KeQueryTimeIncrement();  // In 100-ns units.
    TickCount.QuadPart /= 10000;  // In milliseconds.

    return(TickCount.LowPart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\amd64\xsum.asm ===
include xsum.amd64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\ntinit.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// NT specific routines for loading and configuring the TCP/IPv6 driver.
//


#include <oscfg.h>
#include <ndis.h>
#include <tdi.h>
#include <tdikrnl.h>
#include <tdint.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <ip6imp.h>
#include <ip6def.h>
#include <ntddip6.h>
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tcpcfg.h"
#include <ntddtcp.h>

//
// Global variables.
//
PSECURITY_DESCRIPTOR TcpAdminSecurityDescriptor = NULL;
PDEVICE_OBJECT TCPDeviceObject = NULL;
PDEVICE_OBJECT UDPDeviceObject = NULL;
PDEVICE_OBJECT RawIPDeviceObject = NULL;
extern PDEVICE_OBJECT IPDeviceObject;

HANDLE TCPRegistrationHandle;
HANDLE UDPRegistrationHandle;
HANDLE IPRegistrationHandle;

//
// Set to TRUE when the stack is unloading.
//
int Unloading = FALSE;

//
// External function prototypes.
// REVIEW: These prototypes should be imported via include files.
//

int
TransportLayerInit(void);

void
TransportLayerUnload(void);

NTSTATUS
TCPDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
TCPDispatchInternalDeviceControl(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
IPDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);

NTSTATUS
IPDriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);

NTSTATUS
GetRegMultiSZValue(HANDLE KeyHandle, PWCHAR ValueName,
                   PUNICODE_STRING ValueData);

PWCHAR
EnumRegMultiSz(IN PWCHAR MszString, IN ULONG MszStringLength,
               IN ULONG StringIndex);

//
// Local funcion prototypes.
//
NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);

VOID
DriverUnload(IN PDRIVER_OBJECT DriverObject);

void
TLRegisterProtocol(uchar Protocol, void *RcvHandler, void  *XmitHandler,
                   void *StatusHandler, void *RcvCmpltHandler);

uchar
TCPGetConfigInfo(void);

NTSTATUS
TCPInitializeParameter(HANDLE KeyHandle, PWCHAR ValueName, PULONG Value);

BOOLEAN
IsRunningOnPersonal(VOID);

BOOLEAN
IsRunningOnWorkstation(VOID);

NTSTATUS
TcpBuildDeviceAcl(OUT PACL *DeviceAcl);

NTSTATUS
TcpCreateAdminSecurityDescriptor(VOID);

NTSTATUS
AddNetAcesToDeviceObject(IN OUT PDEVICE_OBJECT DeviceObject);

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, TLRegisterProtocol)
#pragma alloc_text(INIT, TCPGetConfigInfo)
#pragma alloc_text(INIT, TCPInitializeParameter)

#pragma alloc_text(INIT, IsRunningOnPersonal)
#pragma alloc_text(PAGE, IsRunningOnWorkstation)
#pragma alloc_text(INIT, TcpBuildDeviceAcl)
#pragma alloc_text(INIT, TcpCreateAdminSecurityDescriptor)
#pragma alloc_text(INIT, AddNetAcesToDeviceObject)

#endif // ALLOC_PRAGMA


//
//  Main initialization routine for the TCP/IPv6 driver.
//
//  This is the driver entry point, called by NT upon loading us.
//
//
NTSTATUS  //  Returns: final status from the initialization operation.
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,   // TCP/IPv6 driver object.
    IN PUNICODE_STRING RegistryPath)  // Path to our info in the registry.
{
    NTSTATUS Status;
    UNICODE_STRING deviceName;
    USHORT i;
    int initStatus;
    PIO_ERROR_LOG_PACKET entry;

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "Tcpip6: In DriverEntry routine\n"));

    //
    // Write a log entry, so that PSS will know
    // if this driver has been loaded on the machine.
    //
    entry = IoAllocateErrorLogEntry(DriverObject, sizeof *entry);
    if (entry != NULL) {
        RtlZeroMemory(entry, sizeof *entry);
        entry->ErrorCode = EVENT_TCPIP6_STARTED;
        IoWriteErrorLogEntry(entry);
    }

#if COUNTING_MALLOC
    InitCountingMalloc();
#endif

    TdiInitialize();


    //
    // Initialize network level protocol: IPv6.
    //
    Status = IPDriverEntry(DriverObject, RegistryPath);

    if (!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "Tcpip6: IPv6 init failed, status %lx\n", Status));
        return(Status);
    }

    //
    // Initialize transport level protocols: TCP, UDP, and RawIP.
    //

    //
    // Create the device objects.  IoCreateDevice zeroes the memory
    // occupied by the object.
    //

    RtlInitUnicodeString(&deviceName, DD_TCPV6_DEVICE_NAME);

    Status = IoCreateDevice(DriverObject, 0, &deviceName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE, &TCPDeviceObject);

    if (!NT_SUCCESS(Status)) {
        //
        // REVIEW: Write an error log entry here?
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "Tcpip6: Failed to create TCP device object, status %lx\n",
                   Status));
        goto init_failed;
    }

    RtlInitUnicodeString(&deviceName, DD_UDPV6_DEVICE_NAME);

    Status = IoCreateDevice(DriverObject, 0, &deviceName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE, &UDPDeviceObject);

    if (!NT_SUCCESS(Status)) {
        //
        // REVIEW: Write an error log entry here?
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "Tcpip6: Failed to create UDP device object, status %lx\n",
                   Status));
        goto init_failed;
    }

    RtlInitUnicodeString(&deviceName, DD_RAW_IPV6_DEVICE_NAME);

    Status = IoCreateDevice(DriverObject, 0, &deviceName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE, &RawIPDeviceObject);

    if (!NT_SUCCESS(Status)) {
        //
        // REVIEW: Write an error log entry here?
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "Tcpip6: Failed to create Raw IP device object, status %lx\n",
                   Status));
        goto init_failed;
    }

    //
    // Initialize the driver object.
    //
    DriverObject->DriverUnload = DriverUnload;
    DriverObject->FastIoDispatch = NULL;
    for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = TCPDispatch;
    }

    //
    // We special case Internal Device Controls because they are the
    // hot path for kernel-mode clients.
    //
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
        TCPDispatchInternalDeviceControl;

    //
    // Intialize the device objects.
    //
    TCPDeviceObject->Flags |= DO_DIRECT_IO;
    UDPDeviceObject->Flags |= DO_DIRECT_IO;
    RawIPDeviceObject->Flags |= DO_DIRECT_IO;

    //
    // Change the devices and objects to allow access by
    // Network Configuration Operators
    //
    if (!IsRunningOnPersonal()) {

        Status = AddNetAcesToDeviceObject(IPDeviceObject);
        if (!NT_SUCCESS(Status)) {
            goto init_failed;
        }

        Status = AddNetAcesToDeviceObject(TCPDeviceObject);
        if (!NT_SUCCESS(Status)) {
            goto init_failed;
        }
    }

    //
    // Create the security descriptor used for raw socket access checks.
    //
    Status = TcpCreateAdminSecurityDescriptor();
    if (!NT_SUCCESS(Status)) {
        goto init_failed;
    }

    //
    // Finally, initialize the stack.
    //
    initStatus = TransportLayerInit();

    if (initStatus == TRUE) {

        RtlInitUnicodeString(&deviceName, DD_TCPV6_DEVICE_NAME);
        (void)TdiRegisterDeviceObject(&deviceName, &TCPRegistrationHandle);

        RtlInitUnicodeString(&deviceName, DD_UDPV6_DEVICE_NAME);
        (void)TdiRegisterDeviceObject(&deviceName, &UDPRegistrationHandle);

        RtlInitUnicodeString(&deviceName, DD_RAW_IPV6_DEVICE_NAME);
        (void)TdiRegisterDeviceObject(&deviceName, &IPRegistrationHandle);

        return(STATUS_SUCCESS);
    }

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
               "Tcpip6: "
               "TCP/UDP initialization failed, but IP will be available.\n"));

    //
    // REVIEW: Write an error log entry here?
    //
    Status = STATUS_UNSUCCESSFUL;


  init_failed:

    //
    // IP has successfully started, but TCP & UDP failed.  Set the
    // Dispatch routine to point to IP only, since the TCP and UDP
    // devices don't exist.
    //

    if (TCPDeviceObject != NULL) {
        IoDeleteDevice(TCPDeviceObject);
    }

    if (UDPDeviceObject != NULL) {
        IoDeleteDevice(UDPDeviceObject);
    }

    if (RawIPDeviceObject != NULL) {
        IoDeleteDevice(RawIPDeviceObject);
    }

    for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = IPDispatch;
    }

    return(STATUS_SUCCESS);
}

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject)
{
    UNICODE_STRING WinDeviceName;

    UNREFERENCED_PARAMETER(DriverObject);

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
               "IPv6: DriverUnload\n"));

    //
    // Start the shutdown process by noting our change of state.
    // This will inhibit our starting new activities.
    // REVIEW - Is this actually needed? Possibly other factors
    // prevent new entries into the stack.
    //
    Unloading = TRUE;

    //
    // Cleanup our modules.
    // This will break connections with NDIS and the v4 stack.
    //
    TransportLayerUnload();
    IPUnload();
    LanUnload();

    //
    // Deregister with TDI.
    //
    (void) TdiDeregisterDeviceObject(TCPRegistrationHandle);
    (void) TdiDeregisterDeviceObject(UDPRegistrationHandle);
    (void) TdiDeregisterDeviceObject(IPRegistrationHandle);

    //
    // Delete Win32 symbolic links.
    //
    RtlInitUnicodeString(&WinDeviceName, L"\\??\\" WIN_IPV6_BASE_DEVICE_NAME);
    (void) IoDeleteSymbolicLink(&WinDeviceName);

    //
    // Delete our device objects.
    //
    IoDeleteDevice(TCPDeviceObject);
    IoDeleteDevice(UDPDeviceObject);
    IoDeleteDevice(RawIPDeviceObject);
    IoDeleteDevice(IPDeviceObject);

#if COUNTING_MALLOC
    DumpCountingMallocStats();
    UnloadCountingMalloc();
#endif
}


//
// Interval in milliseconds between keepalive transmissions until a
// response is received.
//
#define DEFAULT_KEEPALIVE_INTERVAL 1000

//
// Time to first keepalive transmission.  2 hours == 7,200,000 milliseconds
//
#define DEFAULT_KEEPALIVE_TIME 7200000

#if 1

//* TCPGetConfigInfo -
//
// Initializes TCP global configuration parameters.
//
uchar  // Returns: Zero on failure, nonzero on success.
TCPGetConfigInfo(void)
{
    HANDLE keyHandle;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING UKeyName;
    ULONG maxConnectRexmits = 0;
    ULONG maxDataRexmits = 0;
    ULONG pptpmaxDataRexmits = 0;
    ULONG useRFC1122UrgentPointer = 0;
    MM_SYSTEMSIZE systemSize;

    //
    // Initialize to the defaults in case an error occurs somewhere.
    //
    AllowUserRawAccess = FALSE;
    KAInterval = DEFAULT_KEEPALIVE_INTERVAL;
    KeepAliveTime = DEFAULT_KEEPALIVE_TIME;
    PMTUDiscovery = TRUE;
    PMTUBHDetect = FALSE;
    DefaultRcvWin = 0;  // Automagically pick a reasonable one.
    MaxConnections = DEFAULT_MAX_CONNECTIONS;
    maxConnectRexmits = MAX_CONNECT_REXMIT_CNT;
    pptpmaxDataRexmits = maxDataRexmits = MAX_REXMIT_CNT;
    BSDUrgent = TRUE;
    FinWait2TO = FIN_WAIT2_TO;
    NTWMaxConnectCount = NTW_MAX_CONNECT_COUNT;
    NTWMaxConnectTime = NTW_MAX_CONNECT_TIME;
    MaxUserPort = MAX_USER_PORT;
    TcbTableSize = ComputeLargerOrEqualPowerOfTwo(DEFAULT_TCB_TABLE_SIZE);
    systemSize = MmQuerySystemSize();
    if (MmIsThisAnNtAsSystem()) {
        switch (systemSize) {
        case MmSmallSystem:
            MaxConnBlocks = DEFAULT_MAX_CONN_BLOCKS_AS_SMALL;
            break;
        case MmMediumSystem:
            MaxConnBlocks = DEFAULT_MAX_CONN_BLOCKS_AS_MEDIUM;
            break;
        case MmLargeSystem:
        default:
#if defined(_WIN64)
            MaxConnBlocks = DEFAULT_MAX_CONN_BLOCKS_AS_LARGE64;
#else
            MaxConnBlocks = DEFAULT_MAX_CONN_BLOCKS_AS_LARGE;
#endif
            break;
        }
    } else {
        switch (systemSize) {
        case MmSmallSystem:
            MaxConnBlocks = DEFAULT_MAX_CONN_BLOCKS_WS_SMALL;
            break;
        case MmMediumSystem:
            MaxConnBlocks = DEFAULT_MAX_CONN_BLOCKS_WS_MEDIUM;
            break;
        case MmLargeSystem:
        default:
            MaxConnBlocks = DEFAULT_MAX_CONN_BLOCKS_WS_LARGE;
            break;
        }
    }

    //
    // Read the TCP optional (hidden) registry parameters.
    //
    RtlInitUnicodeString(&UKeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" TCPIPV6_NAME L"\\Parameters"
        );

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));

    InitializeObjectAttributes(&objectAttributes, &UKeyName,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = ZwOpenKey(&keyHandle, KEY_READ, &objectAttributes);

    if (NT_SUCCESS(status)) {

        TCPInitializeParameter(keyHandle, L"AllowUserRawAccess", 
                               (PULONG)&AllowUserRawAccess);

        TCPInitializeParameter(keyHandle, L"IsnStoreSize", 
                               (PULONG)&ISNStoreSize);

        TCPInitializeParameter(keyHandle, L"KeepAliveInterval", 
                               (PULONG)&KAInterval);

        TCPInitializeParameter(keyHandle, L"KeepAliveTime", 
                               (PULONG)&KeepAliveTime);

        TCPInitializeParameter(keyHandle, L"EnablePMTUBHDetect",
                               (PULONG)&PMTUBHDetect);

        TCPInitializeParameter(keyHandle, L"TcpWindowSize", 
                               (PULONG)&DefaultRcvWin);

        TCPInitializeParameter(keyHandle, L"TcpNumConnections",
                               (PULONG)&MaxConnections);
        if (MaxConnections != DEFAULT_MAX_CONNECTIONS) {
            uint ConnBlocks =
                (MaxConnections + MAX_CONN_PER_BLOCK - 1) / MAX_CONN_PER_BLOCK;
            if (ConnBlocks > MaxConnBlocks) {
                MaxConnBlocks = ConnBlocks;
            }
        }

        TCPInitializeParameter(keyHandle, L"MaxHashTableSize", 
                               (PULONG)&TcbTableSize);
        if (TcbTableSize < MIN_TCB_TABLE_SIZE) {
            TcbTableSize = MIN_TCB_TABLE_SIZE;
        } else if (TcbTableSize > MAX_TCB_TABLE_SIZE) {
            TcbTableSize = MAX_TCB_TABLE_SIZE;
        } else {
            TcbTableSize = ComputeLargerOrEqualPowerOfTwo(TcbTableSize);
        }

        TCPInitializeParameter(keyHandle, L"TcpMaxConnectRetransmissions",
                               &maxConnectRexmits);

        if (maxConnectRexmits > 255) {
            maxConnectRexmits = 255;
        }

        TCPInitializeParameter(keyHandle, L"TcpMaxDataRetransmissions",
                               &maxDataRexmits);

        if (maxDataRexmits > 255) {
            maxDataRexmits = 255;
        }

        //
        // If we fail, then set to same value as maxDataRexmit so that the
        // max(pptpmaxDataRexmit,maxDataRexmit) is a decent value
        // Need this since TCPInitializeParameter no longer "initializes"
        // to a default value.
        //

        if(TCPInitializeParameter(keyHandle, L"PPTPTcpMaxDataRetransmissions",
                                  &pptpmaxDataRexmits) != STATUS_SUCCESS) {
            pptpmaxDataRexmits = maxDataRexmits;
        }

        if (pptpmaxDataRexmits > 255) {
            pptpmaxDataRexmits = 255;
        }

        TCPInitializeParameter(keyHandle, L"TcpUseRFC1122UrgentPointer",
                               &useRFC1122UrgentPointer);

        if (useRFC1122UrgentPointer) {
            BSDUrgent = FALSE;
        }

        TCPInitializeParameter(keyHandle, L"TcpTimedWaitDelay", 
                               (PULONG)&FinWait2TO);

        if (FinWait2TO < 30) {
            FinWait2TO = 30;
        }
        if (FinWait2TO > 300) {
            FinWait2TO = 300;
        }
        FinWait2TO = MS_TO_TICKS(FinWait2TO*1000);

        NTWMaxConnectTime = MS_TO_TICKS(NTWMaxConnectTime*1000);

        TCPInitializeParameter(keyHandle, L"MaxUserPort", (PULONG)&MaxUserPort);

        if (MaxUserPort < 5000) {
            MaxUserPort = 5000;
        }
        if (MaxUserPort > 65534) {
            MaxUserPort = 65534;
        }

        //
        // Read a few IP optional (hidden) registry parameters that TCP
        // cares about.
        //
        TCPInitializeParameter(keyHandle, L"EnablePMTUDiscovery",
                               (PULONG)&PMTUDiscovery);

        TCPInitializeParameter(keyHandle, L"SynAttackProtect",
                               (PULONG)&SynAttackProtect);

        ZwClose(keyHandle);
    }

    MaxConnectRexmitCount = maxConnectRexmits;

    //
    // Use the greater of the two, hence both values should be valid
    //

    MaxDataRexmitCount = (maxDataRexmits > pptpmaxDataRexmits ?
                          maxDataRexmits : pptpmaxDataRexmits);

    return(1);
}
#endif

#define WORK_BUFFER_SIZE 256

//* TCPInitializeParameter - Read a value from the registry.
//
//  Initializes a ULONG parameter from the registry.
//
NTSTATUS
TCPInitializeParameter(
    HANDLE KeyHandle,  // An open handle to the registry key for the parameter.
    PWCHAR ValueName,  // The UNICODE name of the registry value to read.
    PULONG Value)      // The ULONG into which to put the data.
{
    NTSTATUS status;
    ULONG resultLength;
    PKEY_VALUE_FULL_INFORMATION keyValueFullInformation;
    UCHAR keybuf[WORK_BUFFER_SIZE];
    UNICODE_STRING UValueName;

    RtlInitUnicodeString(&UValueName, ValueName);

    keyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)keybuf;

    status = ZwQueryValueKey(KeyHandle, &UValueName, KeyValueFullInformation,
                             keyValueFullInformation, WORK_BUFFER_SIZE,
                             &resultLength);

    if (status == STATUS_SUCCESS) {
        if (keyValueFullInformation->Type == REG_DWORD) {
            *Value = *((ULONG UNALIGNED *) ((PCHAR)keyValueFullInformation +
                                  keyValueFullInformation->DataOffset));
        }
    }

    return(status);
}


//* IsRunningOnPersonal - Are we running on the Personal SKU.
//
BOOLEAN
IsRunningOnPersonal(
    VOID)
{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;
    BOOLEAN IsPersonal = TRUE;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = VER_SUITE_PERSONAL;
    OsVer.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

    if (RtlVerifyVersionInfo(&OsVer, VER_PRODUCT_TYPE | VER_SUITENAME,
        ConditionMask) == STATUS_REVISION_MISMATCH) {
        IsPersonal = FALSE;
    }

    return(IsPersonal);
} // IsRunningOnPersonal


//* IsRunningOnWorkstation - Are we running on any Workstation SKU.
//
BOOLEAN
IsRunningOnWorkstation(
    VOID)
{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;
    BOOLEAN IsWorkstation = TRUE;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);

    if (RtlVerifyVersionInfo(&OsVer, VER_PRODUCT_TYPE, ConditionMask) == 
        STATUS_REVISION_MISMATCH) {
        IsWorkstation = FALSE;
    }

    return(IsWorkstation);
} // IsRunningOnWorkstation


//* TcpBuildDeviceAcl -
//
//  (Lifted from AFD - AfdBuildDeviceAcl)
//  This routine builds an ACL which gives Administrators and LocalSystem
//  principals full access. All other principals have no access.
//
NTSTATUS
TcpBuildDeviceAcl(
    OUT PACL *DeviceAcl) // Output pointer to the new ACL.
{
    PGENERIC_MAPPING GenericMapping;
    PSID AdminsSid;
    PSID SystemSid;
    PSID NetworkSid;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();
    RtlMapGenericMask(&AccessMask, GenericMapping);

    AdminsSid = SeExports->SeAliasAdminsSid;
    SystemSid = SeExports->SeLocalSystemSid;
    NetworkSid = SeExports->SeNetworkServiceSid;

    AclLength = sizeof(ACL) +
        3 * FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart) +
        RtlLengthSid(AdminsSid) +
        RtlLengthSid(SystemSid) +
        RtlLengthSid(NetworkSid);

    NewAcl = ExAllocatePool(NonPagedPool, AclLength);
    if (NewAcl == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION);
    if (!NT_SUCCESS(Status)) {
        ExFreePool(NewAcl);
        return(Status);
    }

    Status = RtlAddAccessAllowedAce(NewAcl,
                                    ACL_REVISION,
                                    AccessMask,
                                    AdminsSid);
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAddAccessAllowedAce(NewAcl,
                                    ACL_REVISION,
                                    AccessMask,
                                    SystemSid);
    ASSERT(NT_SUCCESS(Status));


    // Add acl for NetworkSid!

    Status = RtlAddAccessAllowedAce(NewAcl,
                                    ACL_REVISION,
                                    AccessMask,
                                    NetworkSid);
    ASSERT(NT_SUCCESS(Status));

    *DeviceAcl = NewAcl;

    return(STATUS_SUCCESS);

} // TcpBuildDeviceAcl


//* TcpCreateAdminSecurityDescriptor -
//
//  (Lifted from AFD - AfdCreateAdminSecurityDescriptor)
//  This routine creates a security descriptor which gives access
//  only to Administrtors and LocalSystem. This descriptor is used
//  to access check raw endpoint opens and exclisive access to transport
//  addresses.
//
NTSTATUS
TcpCreateAdminSecurityDescriptor(VOID)
{
    PACL rawAcl = NULL;
    NTSTATUS status;
    BOOLEAN memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR tcpSecurityDescriptor;
    ULONG tcpSecurityDescriptorLength;
    CHAR buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR localSecurityDescriptor =
    (PSECURITY_DESCRIPTOR) buffer;
    PSECURITY_DESCRIPTOR localTcpAdminSecurityDescriptor;
    SECURITY_INFORMATION securityInformation = DACL_SECURITY_INFORMATION;

    //
    // Get a pointer to the security descriptor from the TCP device object.
    //
    status = ObGetObjectSecurity(TCPDeviceObject,
                                 &tcpSecurityDescriptor,
                                 &memoryAllocated);

    if (!NT_SUCCESS(status)) {
        ASSERT(memoryAllocated == FALSE);
        return(status);
    }
    //
    // Build a local security descriptor with an ACL giving only
    // administrators and system access.
    //
    status = TcpBuildDeviceAcl(&rawAcl);
    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    (VOID) RtlCreateSecurityDescriptor(
                                       localSecurityDescriptor,
                                       SECURITY_DESCRIPTOR_REVISION
                                       );

    (VOID) RtlSetDaclSecurityDescriptor(
                                        localSecurityDescriptor,
                                        TRUE,
                                        rawAcl,
                                        FALSE
                                        );

    //
    // Make a copy of the TCP descriptor. This copy will be the raw descriptor.
    //
    tcpSecurityDescriptorLength = RtlLengthSecurityDescriptor(tcpSecurityDescriptor);

    localTcpAdminSecurityDescriptor = ExAllocatePool(PagedPool,
                                                     tcpSecurityDescriptorLength);
    if (localTcpAdminSecurityDescriptor == NULL) {
        goto error_exit;
    }
    RtlMoveMemory(localTcpAdminSecurityDescriptor,
                  tcpSecurityDescriptor,
                  tcpSecurityDescriptorLength);

    TcpAdminSecurityDescriptor = localTcpAdminSecurityDescriptor;

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(NULL,
                                         &securityInformation,
                                         localSecurityDescriptor,
                                         &TcpAdminSecurityDescriptor,
                                         PagedPool,
                                         IoGetFileObjectGenericMapping());

    if (!NT_SUCCESS(status)) {
        ASSERT(TcpAdminSecurityDescriptor == localTcpAdminSecurityDescriptor);
        ExFreePool(TcpAdminSecurityDescriptor);
        TcpAdminSecurityDescriptor = NULL;
        goto error_exit;
    }

    if (TcpAdminSecurityDescriptor != localTcpAdminSecurityDescriptor) {
        ExFreePool(localTcpAdminSecurityDescriptor);
    }
    status = STATUS_SUCCESS;

error_exit:
    ObReleaseObjectSecurity(tcpSecurityDescriptor,
                            memoryAllocated);

    if (rawAcl != NULL) {
        ExFreePool(rawAcl);
    }
    return(status);
}


//* AddNetAcesToDeviceObject -
//
//  This routine adds ACEs that give full access to NetworkService and
//  NetConfigOps to the IO manager device object.
//  
//  Note that if existing ACE's in the DACL deny access to the same
//  user/group as ACE's being added, the new ACEs will not take
//  affect by the virtue of being placed in the back of the DACL.
//
//  This routine statically allocates kernel security structures (on 
//  the stack).  Thus it must be in sync with current kernel headers 
//  (e.g. once compiled this code may not be binary compatible with 
//  previous or future OS versions).
//
NTSTATUS
AddNetAcesToDeviceObject(
    IN OUT PDEVICE_OBJECT DeviceObject) // Device object to add ACEs to.
{
    NTSTATUS status;
    BOOLEAN present, defaulted, memoryAllocated;
    PSECURITY_DESCRIPTOR sd;
    PACL newAcl = NULL, dacl;
    ULONG newAclSize;
    ULONG aclRevision;
    ACCESS_MASK accessMask = GENERIC_ALL;
    
    SECURITY_DESCRIPTOR localSd;
    // Provision enough space for IO manager FILE_DEVICE_NETWORK ACL
    // which includes ACEs for:
    //      World (EXECUTE),
    //      LocalSystem (ALL),
    //      Administrators(ALL),
    //      RestrictedUser (EXECUTE)
    // plus two ACEs that we need to add:
    //      NetworkService (ALL)
    //      NetworkConfigOps (ALL)
    union {
        CHAR buffer[sizeof (ACL) + 
                    6 * (FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                    SECURITY_MAX_SID_SIZE)];
        ACL acl;
    } acl;
    union {
        CHAR buffer[SECURITY_MAX_SID_SIZE];
        SID sid;
    } netOps;

    {
        //
        // Create SID for NetworkConfigOps.
        // Should we export this from NDIS as global (e.g. NdisSeExports)?
        //
        SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
        //
        // Initialize SID for network operators.
        //
        status = RtlInitializeSid  (&netOps.sid, &sidAuth, 2);
        // Nothing to fail - local storage init (see above for
        // possible binary incompatibility).
        ASSERT (NT_SUCCESS (status));
        netOps.sid.SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
        netOps.sid.SubAuthority[1] = DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS;
    }

    //
    // Compute the size of ACEs that we want to add.
    //
    newAclSize = FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                    RtlLengthSid( SeExports->SeNetworkServiceSid ) +
                 FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                    RtlLengthSid( &netOps.sid );

    //
    // Get the original ACL.
    //
    status = ObGetObjectSecurity(DeviceObject,
                                 &sd,
                                 &memoryAllocated
                                 );
    if (!NT_SUCCESS(status)) {
        //
        // Object doesn't have security descriptor in the first place
        // This shouldn't be possible (unless we are running under some really 
        // bad memory conditions).
        //
        return status;
    }

    status = RtlGetDaclSecurityDescriptor (sd, &present, &dacl, &defaulted);
    if (!NT_SUCCESS (status)) {
        //
        // Malformed SD? Should this be an assert since SD comes from kernel?
        //
        goto cleanup;
    }

    if (present && dacl!=NULL) {
        USHORT i;
        aclRevision = max(dacl->AclRevision, ACL_REVISION);
        //
        // DeviceObject already had an ACL, copy ACEs from it.
        //
        newAclSize += dacl->AclSize;

        //
        // See if it fits into the stack buffer or allocate
        // one if it doesn't.
        //
        if (newAclSize<=sizeof (acl)) {
            newAcl = &acl.acl;
        } else {
            newAcl = ExAllocatePool(PagedPool, newAclSize);
            if (newAcl==NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto cleanup;
            }
        }

        status = RtlCreateAcl(newAcl, newAclSize, aclRevision);
        ASSERT (NT_SUCCESS (status)); // Nothing to fail - local storage init

        //
        // Copy ACEs from the original ACL if there are any in there.
        //
        for (i=0; i<dacl->AceCount; i++) {
            PACE_HEADER ace;
            status = RtlGetAce (dacl, i, (PVOID)&ace);
            ASSERT (NT_SUCCESS (status));   // Nothing to fail - we know
                                            // ACEs are there.

            status = RtlAddAce (newAcl,             // ACL
                                aclRevision,        // AceRevision
                                i,                  // StartingAceIndex
                                ace,                // AceList
                                ace->AceSize);      // AceListLength
            ASSERT (NT_SUCCESS (status));   // Nothing to fail - local storage init.
        }
    } else {
        //
        // We allocate enough space on stack for ACL
        // with two ACEs.
        //
        C_ASSERT ( sizeof (acl) >= 
                        sizeof (ACL) + 
                        2 * (FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) + 
                                SECURITY_MAX_SID_SIZE) );
        aclRevision = ACL_REVISION;
        newAcl = &acl.acl;
        newAclSize += sizeof (ACL);

        status = RtlCreateAcl(newAcl, newAclSize, aclRevision);
        ASSERT (NT_SUCCESS (status)); // Nothing to fail - local storage init.
    }

    //
    // Generic mapping is the same for device and file objects.
    //
    RtlMapGenericMask(&accessMask, IoGetFileObjectGenericMapping());

    status = RtlAddAccessAllowedAce(
                            newAcl, 
                            aclRevision,
                            accessMask,
                            SeExports->SeNetworkServiceSid
                            );
    ASSERT (NT_SUCCESS (status)); // Nothing to fail - local storage init.

    status = RtlAddAccessAllowedAce(
                            newAcl, 
                            aclRevision,
                            accessMask,
                            &netOps.sid
                            );
    ASSERT (NT_SUCCESS (status)); // Nothing to fail - local storage init.

    status = RtlCreateSecurityDescriptor(
                &localSd,
                SECURITY_DESCRIPTOR_REVISION
                );
    ASSERT (NT_SUCCESS (status)); // Nothing to fail - local storage init.

    status = RtlSetDaclSecurityDescriptor(
                &localSd,                   // Sd
                TRUE,                       // DaclPresent
                newAcl,                     // Dacl
                FALSE                       // DaclDefaulted
                );
    ASSERT (NT_SUCCESS (status)); // Nothing to fail - local storage init.


    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = ObSetSecurityObjectByPointer(
                    DeviceObject,
                    DACL_SECURITY_INFORMATION,
                    &localSd);

cleanup:
    if (newAcl!=NULL && newAcl!=&acl.acl) {
        ExFreePool (newAcl);
    }

    ObReleaseObjectSecurity(sd, memoryAllocated);
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\ia64\xsum.s ===
#include <xsum.ia64>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\sidebug.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Debugging code.
//

#pragma warning(disable:4115) // named type definition in parentheses
#pragma warning(disable:4127) // conditional expression is constant

#include <ntosp.h>

#undef ExAllocatePoolWithTag
#undef ExFreePool

//
// This is copied from ntos\inc\ex.h
//
#if !defined(POOL_TAGGING)
#define ExAllocatePoolWithTag(a,b,c) ExAllocatePool(a,b)
#endif  // !POOL_TAGGING

#ifndef COUNTING_MALLOC
#define COUNTING_MALLOC DBG
#endif

#if COUNTING_MALLOC

//
// This enumerated type is used as the function return
// value of the function that is used to search the tree
// for a key.  SisFoundNode indicates that the function found
// the key.  SisInsertAsLeft indicates that the key was not found
// and the node should be inserted as the left child of the
// parent.  SisInsertAsRight indicates that the key was not found
// and the node should be inserted as the right child of the
// parent.
//

typedef enum _SIS_SEARCH_RESULT{
    SisEmptyTree,
    SisFoundNode,
    SisInsertAsLeft,
    SisInsertAsRight
} SIS_SEARCH_RESULT;

typedef
LONG
(NTAPI *PSIS_TREE_COMPARE_ROUTINE) (
    PVOID Key,
    PVOID Node
    );

typedef struct _SIS_TREE {
    PRTL_SPLAY_LINKS TreeRoot;
    PSIS_TREE_COMPARE_ROUTINE CompareRoutine;
} SIS_TREE, *PSIS_TREE;

static
SIS_SEARCH_RESULT
FindNodeOrParent(
    IN PSIS_TREE Tree,
    IN PVOID Key,
    OUT PRTL_SPLAY_LINKS *NodeOrParent
    )

/*++

Routine Description:

    This routine is private to the tree package and will
    find and return (via the NodeOrParent parameter) the node
    with the given key, or if that node is not in the tree it
    will return (via the NodeOrParent parameter) a pointer to
    the parent.

Arguments:

    Tree         - The  tree to search for the key.

    Key          - Pointer to a buffer holding the key.  The tree
                   package doesn't examine the key itself.  It leaves
                   this up to the user supplied compare routine.

    NodeOrParent - Will be set to point to the node containing the
                   the key or what should be the parent of the node
                   if it were in the tree.  Note that this will *NOT*
                   be set if the search result is SisEmptyTree.

Return Value:

    SIS_SEARCH_RESULT - SisEmptyTree: The tree was empty.  NodeOrParent
                                      is *not* altered.

                    SisFoundNode: A node with the key is in the tree.
                                  NodeOrParent points to that node.

                    SisInsertAsLeft: Node with key was not found.
                                     NodeOrParent points to what would be
                                     parent.  The node would be the left
                                     child.

                    SisInsertAsRight: Node with key was not found.
                                      NodeOrParent points to what would be
                                      parent.  The node would be the right
                                      child.

--*/

{

    if (Tree->TreeRoot == NULL) {

        return SisEmptyTree;

    } else {

        //
        // Used as the iteration variable while stepping through
        // the  tree.
        //
        PRTL_SPLAY_LINKS NodeToExamine = Tree->TreeRoot;

        //
        // Just a temporary.  Hopefully a good compiler will get
        // rid of it.
        //
        PRTL_SPLAY_LINKS Child;

        //
        // Holds the value of the comparasion.
        //
        int Result;

        while (TRUE) {

            //
            // Compare the buffer with the key in the tree element.
            //

            Result = Tree->CompareRoutine(
                         Key,
                         NodeToExamine
                         );

            if (Result < 0) {

                if ((Child = RtlLeftChild(NodeToExamine)) != NULL) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return SisInsertAsLeft;

                }

            } else if (Result > 0) {

                if ((Child = RtlRightChild(NodeToExamine)) != NULL) {

                    NodeToExamine = Child;

                } else {

                    //
                    // Node is not in the tree.  Set the output
                    // parameter to point to what would be its
                    // parent and return which child it would be.
                    //

                    *NodeOrParent = NodeToExamine;
                    return SisInsertAsRight;

                }

            } else {

                //
                // Node is in the tree (or it better be because of the
                // assert).  Set the output parameter to point to
                // the node and tell the caller that we found the node.
                //

                ASSERT(Result == 0);
                *NodeOrParent = NodeToExamine;
                return SisFoundNode;

            }
        }
    }
}


VOID
SipInitializeTree (
    IN PSIS_TREE Tree,
    IN PSIS_TREE_COMPARE_ROUTINE CompareRoutine
    )

/*++

Routine Description:

    The procedure InitializeTree prepares a tree for use.
    This must be called for every individual tree variable before
    it can be used.

Arguments:

    Tree - Pointer to the  tree to be initialized.

    CompareRoutine - User routine to be used to compare to keys in the
                     tree.

Return Value:

    None.

--*/

{
    Tree->TreeRoot = NULL;
    Tree->CompareRoutine = CompareRoutine;
}


PVOID
SipInsertElementTree (
    IN PSIS_TREE Tree,
    IN PVOID Node,
    IN PVOID Key
    )

/*++

Routine Description:

    The function SipInsertElementTree will insert a new element in a tree.
    If an element with the same key already exists in the tree the return
    value is a pointer to the old element.  Otherwise, the return value is
    a pointer to the new element.  Note that this differs from the Rtl
    generic table package in that the actual node passed in is inserted in
    the tree, whereas the table package inserts a copy of the node.

Arguments:

    Tree - Pointer to the tree in which to (possibly) insert the
           node.

    Node - Pointer to the node to insert in the tree.  Will not be inserted
           if a node with a matching key is found.

    Key - Passed to the user comparasion routine.

Return Value:

    PVOID - Pointer to the new node or the existing node if one exists.

--*/

{

    //
    // Holds a pointer to the node in the tree or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the tree lookup.
    //
    SIS_SEARCH_RESULT Lookup;

    //
    // Node will point to the splay links of what
    // will be returned to the user.
    //
    PRTL_SPLAY_LINKS NodeToReturn = (PRTL_SPLAY_LINKS) Node;

    Lookup = FindNodeOrParent(
                 Tree,
                 Key,
                 &NodeOrParent
                 );

    if (Lookup != SisFoundNode) {

        RtlInitializeSplayLinks(NodeToReturn);

        //
        // Insert the new node in the tree.
        //

        if (Lookup == SisEmptyTree) {

            Tree->TreeRoot = NodeToReturn;

        } else {

            if (Lookup == SisInsertAsLeft) {

                RtlInsertAsLeftChild(
                    NodeOrParent,
                    NodeToReturn
                    );

            } else {

                RtlInsertAsRightChild(
                    NodeOrParent,
                    NodeToReturn
                    );

            }

        }

    } else {

        NodeToReturn = NodeOrParent;

    }

    //
    // Always splay the (possibly) new node.
    //

    Tree->TreeRoot = RtlSplay(NodeToReturn);

    return NodeToReturn;
}


VOID
SipDeleteElementTree (
    IN PSIS_TREE Tree,
    IN PVOID Node
    )

/*++

Routine Description:

    The function SipDeleteElementTree will remove an element
    from a tree.  Note that the memory associated with the node
    is not actually freed.

Arguments:

    Tree - Pointer to the tree in which to remove the specified node.

    Node - Node of tree to remove.

Return Value:

    None.

--*/

{

    PRTL_SPLAY_LINKS NodeToDelete = (PRTL_SPLAY_LINKS) Node;

    //
    // Delete the node from the tree.  Note that RtlDelete
    // will splay the tree.
    //

    Tree->TreeRoot = RtlDelete(NodeToDelete);
}


PVOID
SipLookupElementTree (
    IN PSIS_TREE Tree,
    IN PVOID Key
    )

/*++

Routine Description:

    The function SipLookupElementTree will find an element in a
    tree.  If the element is located the return value is a pointer to
    the element, otherwise if the element is not located the return
    value is NULL.

Arguments:

    Tree - Pointer to the users tree to search for the key.

    Key - Used for the comparasion.

Return Value:

    PVOID - returns a pointer to the user data.

--*/

{

    //
    // Holds a pointer to the node in the tree or what would be the
    // parent of the node.
    //
    PRTL_SPLAY_LINKS NodeOrParent;

    //
    // Holds the result of the tree lookup.
    //
    SIS_SEARCH_RESULT Lookup;

    Lookup = FindNodeOrParent(
                 Tree,
                 Key,
                 &NodeOrParent
                 );

    if (Lookup == SisEmptyTree) {

        return NULL;

    } else {

        //
        // Splay the tree with this node.  Note that we do this irregardless
        // of whether the node was found.
        //
        Tree->TreeRoot = RtlSplay(NodeOrParent);

        //
        // Return a pointer to the user data.
        //
        if (Lookup == SisFoundNode) {

            return NodeOrParent;

        } else {

            return NULL;
        }
    }
}


VOID
SipDeleteTree (
    IN PSIS_TREE Tree
    )

/*++

Routine Description:

    Deletes and frees all elements in a tree.
    Does not free the tree structure itself.

Arguments:

    Tree - Pointer to the tree to be deleted.

Return Value:

    None.

--*/

{
    PVOID Node;

    while ((Node = Tree->TreeRoot) != NULL) {
        SipDeleteElementTree(Tree, Node);
        ExFreePool(Node);
    }
}


typedef struct _SIS_COUNTING_MALLOC_CLASS_KEY {
    POOL_TYPE poolType;
    ULONG tag;
    PCHAR file;
    ULONG line;
} SIS_COUNTING_MALLOC_CLASS_KEY, *PSIS_COUNTING_MALLOC_CLASS_KEY;

typedef struct _SIS_COUNTING_MALLOC_CLASS_ENTRY {
    RTL_SPLAY_LINKS;
    SIS_COUNTING_MALLOC_CLASS_KEY;
    ULONG numberOutstanding;
    ULONG bytesOutstanding;
    ULONG numberEverAllocated;
    LONGLONG bytesEverAllocated;
    struct _SIS_COUNTING_MALLOC_CLASS_ENTRY *prev, *next;
} SIS_COUNTING_MALLOC_CLASS_ENTRY, *PSIS_COUNTING_MALLOC_CLASS_ENTRY;

typedef struct _SIS_COUNTING_MALLOC_KEY {
    PVOID p;
} SIS_COUNTING_MALLOC_KEY, *PSIS_COUNTING_MALLOC_KEY;

typedef struct _SIS_COUNTING_MALLOC_ENTRY {
    RTL_SPLAY_LINKS;
    SIS_COUNTING_MALLOC_KEY;
    PSIS_COUNTING_MALLOC_CLASS_ENTRY classEntry;
    ULONG byteCount;
} SIS_COUNTING_MALLOC_ENTRY, *PSIS_COUNTING_MALLOC_ENTRY;

KSPIN_LOCK CountingMallocLock[1];
BOOLEAN CountingMallocInternalFailure = FALSE;
SIS_COUNTING_MALLOC_CLASS_ENTRY CountingMallocClassListHead[1];
SIS_TREE CountingMallocClassTree[1];
SIS_TREE CountingMallocTree[1];


LONG NTAPI
CountingMallocClassCompareRoutine(
    PVOID Key,
    PVOID Node)
{
    PSIS_COUNTING_MALLOC_CLASS_KEY key = Key;
    PSIS_COUNTING_MALLOC_CLASS_ENTRY entry = Node;

    if (key->poolType > entry->poolType) return 1;
    if (key->poolType < entry->poolType) return -1;
    ASSERT(key->poolType == entry->poolType);

    if (key->tag > entry->tag) return 1;
    if (key->tag < entry->tag) return -1;
    ASSERT(key->tag == entry->tag);

    if (key->file > entry->file) return 1;
    if (key->file < entry->file) return -1;
    ASSERT(key->file == entry->file);

    if (key->line > entry->line) return 1;
    if (key->line < entry->line) return -1;
    ASSERT(key->line == entry->line);

    return 0;
}


LONG NTAPI
CountingMallocCompareRoutine(
    PVOID Key,
    PVOID Node)
{
    PSIS_COUNTING_MALLOC_KEY key = Key;
    PSIS_COUNTING_MALLOC_ENTRY entry = Node;

    if (key->p < entry->p) return 1;
    if (key->p > entry->p) return -1;
    ASSERT(key->p == entry->p);

    return 0;
}


VOID *
CountingExAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Tag,
    IN PCHAR File,
    IN ULONG Line)
{
    PVOID memoryFromExAllocate;
    KIRQL OldIrql;
    SIS_COUNTING_MALLOC_CLASS_KEY classKey[1];
    PSIS_COUNTING_MALLOC_CLASS_ENTRY classEntry;
    SIS_COUNTING_MALLOC_KEY key[1];
    PSIS_COUNTING_MALLOC_ENTRY entry;

    //
    // First do the actual malloc.
    //
    memoryFromExAllocate = ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
    if (NULL == memoryFromExAllocate) {
        //
        // We're out of memory.  Punt.
        //
        return NULL;
    }

    KeAcquireSpinLock(CountingMallocLock, &OldIrql);
    //
    // See if we already have a class entry for this tag/poolType pair.
    //
    classKey->tag = Tag;
    classKey->poolType = PoolType;
    classKey->file = File;
    classKey->line = Line;

    classEntry = SipLookupElementTree(CountingMallocClassTree, classKey);
    if (NULL == classEntry) {
        //
        // This is the first time we've seen a malloc of this class.
        //
        classEntry = ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(SIS_COUNTING_MALLOC_CLASS_ENTRY), ' siS');
        if (NULL == classEntry) {
            CountingMallocInternalFailure = TRUE;
            KeReleaseSpinLock(CountingMallocLock, OldIrql);
            return memoryFromExAllocate;
        }

        //
        // Fill in the new class entry.
        //
        classEntry->tag = Tag;
        classEntry->poolType = PoolType;
        classEntry->file = File;
        classEntry->line = Line;
        classEntry->numberOutstanding = 0;
        classEntry->bytesOutstanding = 0;
        classEntry->numberEverAllocated = 0;
        classEntry->bytesEverAllocated = 0;

        //
        // Put it in the tree of classes.
        //
        SipInsertElementTree(CountingMallocClassTree, classEntry, classKey);

        //
        // And put it in the list of classes.
        //
        classEntry->prev = CountingMallocClassListHead;
        classEntry->next = CountingMallocClassListHead->next;
        classEntry->prev->next = classEntry->next->prev = classEntry;
    }

    //
    // Roll up an entry for the pointer.
    //
    entry = ExAllocatePoolWithTag(NonPagedPool,
                                  sizeof(SIS_COUNTING_MALLOC_ENTRY), ' siS');
    if (NULL == entry) {
        CountingMallocInternalFailure = TRUE;
        KeReleaseSpinLock(CountingMallocLock, OldIrql);
        return memoryFromExAllocate;
    }

    //
    // Update the stats in the class.
    //
    classEntry->numberOutstanding++;
    classEntry->bytesOutstanding += NumberOfBytes;
    classEntry->numberEverAllocated++;
    classEntry->bytesEverAllocated += NumberOfBytes;

    //
    // Fill in the pointer entry.
    //
    entry->p = memoryFromExAllocate;
    entry->classEntry = classEntry;
    entry->byteCount = NumberOfBytes;

    //
    // Stick it in the tree.
    //
    key->p = memoryFromExAllocate;
    SipInsertElementTree(CountingMallocTree, entry, key);

    KeReleaseSpinLock(CountingMallocLock, OldIrql);

    return memoryFromExAllocate;
}


VOID
CountingExFreePool(
    PVOID p)
{
    SIS_COUNTING_MALLOC_KEY key[1];
    PSIS_COUNTING_MALLOC_ENTRY entry;
    KIRQL OldIrql;

    key->p = p;

    KeAcquireSpinLock(CountingMallocLock, &OldIrql);

    entry = SipLookupElementTree(CountingMallocTree, key);
    if (NULL == entry) {
        //
        // We may have failed to allocate the entry because of an
        // internal failure in the counting package, or else we're
        // freeing memory that was allocated by another system
        // component, like the SystemBuffer in an irp.
        //
    } else {
        //
        // Update the stats in the class.
        //
        ASSERT(entry->classEntry->numberOutstanding > 0);
        entry->classEntry->numberOutstanding--;

        ASSERT(entry->classEntry->bytesOutstanding >= entry->byteCount);
        entry->classEntry->bytesOutstanding -= entry->byteCount;

        //
        // Remove the entry from the tree.
        //
        SipDeleteElementTree(CountingMallocTree, entry);

        //
        // And free it.
        //
        ExFreePool(entry);
    }

    KeReleaseSpinLock(CountingMallocLock, OldIrql);

    //
    // Free the caller's memory.
    //
    ExFreePool(p);
}


VOID
InitCountingMalloc(void)
{
    KeInitializeSpinLock(CountingMallocLock);

    CountingMallocClassListHead->next =
        CountingMallocClassListHead->prev = CountingMallocClassListHead;

    SipInitializeTree(CountingMallocClassTree,
                      CountingMallocClassCompareRoutine);
    SipInitializeTree(CountingMallocTree, CountingMallocCompareRoutine);
}


VOID
UnloadCountingMalloc(void)
{
    SipDeleteTree(CountingMallocTree);
    SipDeleteTree(CountingMallocClassTree);
}


VOID
DumpCountingMallocStats(void)
{
    PSIS_COUNTING_MALLOC_CLASS_ENTRY classEntry;
    ULONG totalAllocated = 0;
    ULONG totalEverAllocated = 0;
    ULONG totalBytesAllocated = 0;
    ULONG totalBytesEverAllocated = 0;

    //
    // Note that this function does NOT acquire CountingMallocLock,
    // so there can be no concurrent allocations/frees happening.
    // CountingMallocLock would raise to DPC irql,
    // and the filename strings might be pageable.
    //

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_LEVEL,
               "Tag\tFile\tLine\tPoolType\tCountOutstanding\tBytesOutstanding"
               "\tTotalEverAllocated\tTotalBytesAllocated\n"));

    for (classEntry = CountingMallocClassListHead->next;
         classEntry != CountingMallocClassListHead;
         classEntry = classEntry->next) {

        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_LEVEL,
                   "%c%c%c%c\t%s\t%d\t%s\t%d\t%d\t%d\t%d\n",
                   (CHAR)(classEntry->tag >> 24),
                   (CHAR)(classEntry->tag >> 16),
                   (CHAR)(classEntry->tag >> 8),
                   (CHAR)(classEntry->tag),
                   classEntry->file,
                   classEntry->line,
                   (classEntry->poolType == NonPagedPool) ? "NonPagedPool"
                   : ((classEntry->poolType == PagedPool) ? "PagedPool"
                      : "Other"),
                   classEntry->numberOutstanding,
                   classEntry->bytesOutstanding,
                   classEntry->numberEverAllocated,
                   (ULONG)classEntry->bytesEverAllocated));

        totalAllocated += classEntry->numberOutstanding;
        totalEverAllocated += classEntry->numberEverAllocated;
        totalBytesAllocated += classEntry->bytesOutstanding;
        totalBytesEverAllocated += (ULONG)classEntry->bytesEverAllocated;
    }

    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_LEVEL,
               "%d objects, %d bytes currently allocated.  "
               "%d objects, %d bytes ever allocated.\n",
               totalAllocated, totalBytesAllocated, totalEverAllocated,
               totalBytesEverAllocated));
}

#endif  // COUNTING_MALLOC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\i386\xsum.asm ===
title  "Compute Checksum"
;
; Copyright (c) 1985-2000 Microsoft Corporation
; This file is part of the Microsoft Research IPv6 Network Protocol Stack.
; You should have received a copy of the Microsoft End-User License Agreement
; for this software along with this release; see the file "license.txt".
; If not, please see http://www.research.microsoft.com/msripv6/license.htm,
; or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
;
; Abstract:
;
; This module implements a function to compute the checksum of a buffer.
;
; Environment:
;
; Any mode.
;

LOOP_UNROLLING_BITS     equ     5
LOOP_UNROLLING          equ     (1 SHL LOOP_UNROLLING_BITS)

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        .list

        .code

;++
;
; ULONG
; tcpxsum(
;   IN ULONG cksum,
;   IN PUCHAR buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;
; Arguments:
;
;    cksum - Suppiles the initial checksum value, in 16-bit form,
;            with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

cksum   equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word:
        jmp     checksum_last_word

to_checksum_done:
        jmp     checksum_done

to_checksum_dword_loop_done:
        jmp     checksum_dword_loop_done

cPublicProc tcpxsum,3

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done
                                        ; skip the loop if that was the only
                                        ;  dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS ; convert from word count to unrolled
                                        ;  loop count
        and     ebx,LOOP_UNROLLING-1    ; # of partial dwords to do in first
                                        ;  loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     loop_entry[ebx*4]       ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 64-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING
        deflab  loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word label proc           ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done     ; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done label proc                ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine label proc             ; "proc" so not scoped to function
        add     ax,word ptr [esp + cksum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING*4
        REPT    LOOP_UNROLLING-1
TEMP=TEMP-4
        reflab  loop_entry_,%TEMP
        ENDM

stdENDP tcpxsum

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\sys\i386\alloca.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This module implements support for the alloca compiler intrinsic.
//


//* _alloca_probe
//
// Routine Description:
//
// The compiler uses this function to implement alloca.
// It adjusts the stack frame for new stack-allocated storage.
// This implementation is only intended to handle small allocations
// (big allocations should be heap-allocated), so it does no
// stack probing.
//
// Arguments:
//
// eax - Number of bytes to allocate
//
__declspec(naked) void __cdecl
_alloca_probe(void)
{
    __asm {
        push    ecx                     ; save ecx
        mov     ecx,esp                 ; compute new stack pointer in ecx
        add     ecx,8                   ; correct for return address and
                                        ; saved ecx value

        sub     ecx,eax                 ; move stack down by eax

        mov     eax,esp                 ; save pointer to current tos
        mov     esp,ecx                 ; set the new stack pointer
        mov     ecx,dword ptr [eax]     ; recover ecx
        mov     eax,dword ptr [eax + 4] ; recover return address
        jmp     eax                     ; return
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\tcp\tcpconn.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Code for TCP connection management.
//
// This file contains the code handling TCP connection related requests,
// such as connecting and disconnecting.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tcpsend.h"
#include "tcprcv.h"
#include "tcpdeliv.h"
#include "info.h"
#include "tcpcfg.h"
#include "route.h"
#include "security.h"
#include "tcpmd5.h"
#include "md5.h"
#include "crypto\rc4.h"

SLIST_HEADER ConnReqFree;               // Connection request free list.

//
// ISN globals.
//
#define ISN_KEY_SIZE            256     // 2048 bits.
#define ISN_DEF_RAND_STORE_SIZE 256
#define ISN_MIN_RAND_STORE_SIZE 1
#define ISN_MAX_RAND_STORE_SIZE 16384


typedef struct _ISN_RAND_STORE {
    MD5_CONTEXT Md5Context;
    ulong iBuf;
    ushort* pBuf;
} ISN_RAND_STORE, *PISN_RAND_STORE;

RC4_KEYSTRUCT ISNRC4Key; 
PISN_RAND_STORE ISNStore;
uint ISNStoreSize = ISN_DEF_RAND_STORE_SIZE;
uint ISNStoreMask;
SeqNum ISNMonotonicPortion = 0;
int ISNCredits;
int ISNLastIsnUpdateTime;
int ISNMaxCredits;

extern PDRIVER_OBJECT TCPDriverObject;

KSPIN_LOCK ConnReqFreeLock;             // Lock to protect conn req free list.
uint NumConnReq;                        // Current number of ConnReqs.
uint MaxConnReq = 0xffffffff;           // Maximum allowed number of ConnReqs.
uint ConnPerBlock = MAX_CONN_PER_BLOCK;
uint NextConnBlock = 0;                 // Cached index of next unfilled block.
uint MaxAllocatedConnBlocks = 0;        // Current number of blocks in the
                                        // ConnTable.
TCPConnBlock **ConnTable = NULL;        // The current connection table.

KSPIN_LOCK ConnTableLock;
extern KSPIN_LOCK AddrObjTableLock;
extern KSPIN_LOCK TCBTableLock;

extern void RemoveConnFromAO(AddrObj *AO, TCPConn *Conn);


//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA

int InitTCPConn(void);
int InitISNGenerator(void);
void UnloadISNGenerator(void);
int GetRandBits();
uint GetDeltaTime();

#pragma alloc_text(INIT, InitTCPConn)
#pragma alloc_text(INIT, InitISNGenerator)
#pragma alloc_text(PAGE, UnloadISNGenerator)

#endif // ALLOC_PRAGMA

void CompleteConnReq(TCB *CmpltTCB, TDI_STATUS Status);


//* UnloadISNGenerator - Unload the support for the ISN generator.
//
//  Called when we are unloading the driver.
//
void  // Returns: Nothing.
UnloadISNGenerator(void)
{
    CCHAR i;
    
    ASSERT(ISNStore);

    for (i = 0; i < KeNumberProcessors; i++) {
        if (ISNStore[i].pBuf != NULL) {
            ExFreePool(ISNStore[i].pBuf);
            ISNStore[i].pBuf = NULL;
        }
    }
    ExFreePool(ISNStore);
    ISNStore = NULL;   
}


//* InitISNGenerator - Initialize the support for the ISN generator.
//
//  Called when the driver is loaded.  Get 2048 bits of randomness and
//  use them to create an RC4 key.
//
int //Returns: TRUE if successful.
InitISNGenerator(void)
{
    ULONG cBits = 0;
    ULONG i;
    ULONG cProcs = KeNumberProcessors;
    ULONG ISNRandomValue;
    unsigned char pBuf[ISN_KEY_SIZE];

    //
    // Start with the credits that would last for 1 tick.
    //
    ISNMaxCredits = ISNCredits = MAX_ISN_INCREMENTABLE_CONNECTIONS_PER_100MS;
    ISNLastIsnUpdateTime = (int)X100NSTOMS(KeQueryInterruptTime());

    if (!GetSystemRandomBits(pBuf, ISN_KEY_SIZE)) {
        return FALSE;
    }

    //
    // Generate the key control structure.
    //
    rc4_key(&ISNRC4Key, ISN_KEY_SIZE, pBuf);

    //
    // Initalialize the current sequence number to a random value.
    //
    rc4(&ISNRC4Key, sizeof(SeqNum), (uchar*)&ISNMonotonicPortion);

    //
    // Obtain a random value to be used along with the invariants to compute
    // the MD5 hash.
    //
    rc4(&ISNRC4Key, sizeof(ISNRandomValue), (uchar*)&ISNRandomValue);

    //
    // Round down the store size to power of 2. Verify in range.
    //

    while ((ISNStoreSize = ISNStoreSize >> 1) != 0) {
        cBits++;
    }

    ISNStoreSize = 1 << cBits;

    if (ISNStoreSize < ISN_MIN_RAND_STORE_SIZE ||
        ISNStoreSize > ISN_MAX_RAND_STORE_SIZE) {
        ISNStoreSize = ISN_DEF_RAND_STORE_SIZE;
    }

    //
    // The mask is store size - 1.
    //
    ISNStoreMask = ISNStoreSize - 1;

    //
    // Initialize the random ISN store. One array/index per processor.
    //

    ISNStore = ExAllocatePool(NonPagedPool, cProcs * sizeof(ISN_RAND_STORE));

    if (ISNStore == NULL) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "Tcpip: failed to allocate ISN rand store\n"));
        return FALSE;
    }
    RtlZeroMemory(ISNStore, sizeof(ISN_RAND_STORE) * cProcs);

    for (i = 0; i < cProcs; i++) {
        ISNStore[i].pBuf = ExAllocatePool(NonPagedPool,
                                          sizeof(ushort) * ISNStoreSize);

        if (ISNStore[i].pBuf == NULL) {
            goto error1;
        }
        rc4(&ISNRC4Key,
            sizeof(ushort) * ISNStoreSize, 
            (uchar*)ISNStore[i].pBuf);

        //
        // Initialize structures required to call the MD5 transform.
        //
        MD5InitializeData(&ISNStore[i].Md5Context, ISNRandomValue);
    }

    return TRUE;

  error1:

    UnloadISNGenerator();
    return FALSE;
}


//* GetRandomISN - Gets a random Initial Sequence Number.
//
//  Called when an Initial Sequence Number (ISN) is needed. Calls crypto
//  functions for random number generation.
//
void  // Returns: Nothing.
GetRandomISN(
    SeqNum *Seq, // Returned sequence number
    uchar *TcbInvariants) // Connection invariants
{
    ulong randbits;
    ulong iProc;
    PMD5_CONTEXT Md5Context;

    //
    // Raise IRQL to DISPATCH so that we don't get swapped out while accessing
    // the processor specific array. Check to see if already at DISPATCH
    // before doing the work.
    //

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    iProc = KeGetCurrentProcessorNumber();

    //
    // Add the random number only if the number of connections that can 
    // increment the sequence number within this time period is non zero.
    // [Note: This could make the ISNCredits less than 0, but it is not a 
    // problem].
    //
    if ((ISNCredits > 0) && (InterlockedDecrement((PLONG)&ISNCredits) > 0)) {
        randbits = GetRandBits();

        // 
        // We want to add between 16K and 32K of random, so adjust. There are
        // 15 bits of randomness, just ensure that the high order bit is set 
        // and we have >= 16K and <= (32K-1)::14bits of randomness.
        //
        randbits &= 0x7FFF;
        randbits |= 0x4000;

    } else {
        int Delta = GetDeltaTime();

        if (Delta > 0) {
            randbits = GetRandBits();

            // 
            // We can add anywhere from 256 to 512 per ms.
            //
            randbits &= 0x1FF;
            randbits |= 0x100;

            randbits *= Delta;
        } else {
            randbits = 0;
        }
    }

    // 
    // Update global CurISN. InterlockedExchangeAdd returns initial value
    // (not the added value).
    //
    *Seq = InterlockedExchangeAdd((PLONG)&ISNMonotonicPortion, randbits);

    //
    // Move the invariants from the connection.
    //
    Md5Context = &ISNStore[iProc].Md5Context;
    MD5InitializeScratch(Md5Context);
    RtlCopyMemory(Md5Context->Data, TcbInvariants, TCP_MD5_DATA_LENGTH);
    TransformMD5(Md5Context->Scratch, Md5Context->Data);

    //
    // Add the Invariant hash to the sequence number.
    //
    *Seq += (ULONG)(Md5Context->Scratch[0]);
    
    return;
}


//* GetRandBits
//
//  Returns 16 random bits from the random number array generated using RC4.
//  When the store is exhausted, it will be replenished.
//
int  // Returns: 16 bits of random data.
GetRandBits()
{
    ulong iStore;
    int randbits;
    ulong iProc = KeGetCurrentProcessorNumber();

    //
    // Get index into the random store. Mask performs mod operation.
    //
    iStore = ++ISNStore[iProc].iBuf & ISNStoreMask;
    
    ASSERT(iStore < ISNStoreSize);

    randbits = ISNStore[iProc].pBuf[iStore];

    if (iStore == 0) {
        rc4(&ISNRC4Key, 
            sizeof(ushort) * ISNStoreSize, 
            (uchar*) ISNStore[iProc].pBuf);
    }

    return randbits;
}

//* GetRandBits
//
//  Tracks the time-based updates of ISN. It will return the time elapsed since 
//  the last time this function was called. This would be used by the caller to
//  increment the ISN by an appropriate amount. Note that the maximum value
//  is function returns is 200 MS.
//
uint  // Returns: Delta time in milli-seconds.
GetDeltaTime()
{
    // 
    // If the time has changed since the ISN was updated last time, it
    // can be incremented now.
    //
    int PreviousUpdateTime, Delta;
    int CurrentUpdateTime = (int)X100NSTOMS(KeQueryInterruptTime());

    PreviousUpdateTime = InterlockedExchange((PLONG)&ISNLastIsnUpdateTime,
                                             CurrentUpdateTime);

    Delta = CurrentUpdateTime - PreviousUpdateTime;

    if (Delta > 0) {
        return MIN(Delta, 200);
    } else {
        return 0;
    }    
}


//
// Routines for handling conn refcount going to 0.
//

//* DummyDone - Called when nothing to do.
//
//  Called with TCPConnBlock.cb_lock held.
//
void  // Returns: Nothing.
DummyDone(TCPConn *Conn,      // Connection going to 0.
          KIRQL PreLockIrql)  // IRQL prior to TCPConnBlock.cb_lock acquisition.
{
    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, PreLockIrql);
}

//* DummyCmplt - Dummy close completion routine.
void
DummyCmplt(PVOID Dummy1, uint Dummy2, uint Dummy3)
{
    UNREFERENCED_PARAMETER(Dummy1);
    UNREFERENCED_PARAMETER(Dummy2);
    UNREFERENCED_PARAMETER(Dummy3);
}

//* CloseDone - Called when we need to complete a close.
//
//  Called with TCPConnBlock.cb_lock held.
//
void  // Returns: Nothing.
CloseDone(TCPConn *Conn,  // Connection going to 0.
          KIRQL Irql0)    // IRQL prior to TCPConnBlock.cb_lock acquisition.
{
    RequestCompleteRoutine Rtn;  // Completion routine.
    PVOID Context;  // User context for completion routine.
    AddrObj *AO;
    KIRQL Irql1, Irql2;

    ASSERT(Conn->tc_flags & CONN_CLOSING);

    Rtn = Conn->tc_rtn;
    Context = Conn->tc_rtncontext;
    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);

    KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
    KeAcquireSpinLock(&Conn->tc_ConnBlock->cb_lock, &Irql1);

    if ((AO = Conn->tc_ao) != NULL) {

        CHECK_STRUCT(AO, ao);

        // It's associated.
        KeAcquireSpinLock(&AO->ao_lock, &Irql2);
        RemoveConnFromAO(AO, Conn);
        // We've pulled him from the AO, we can free the lock now.
        KeReleaseSpinLock(&AO->ao_lock, Irql2);
    }

    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);
    KeReleaseSpinLock(&AddrObjTableLock, Irql0);

    ExFreePool(Conn);

    (*Rtn)(Context, TDI_SUCCESS, 0);
}

//* DisassocDone - Called when we need to complete a disassociate.
//
//  Called with TCPConnBlock.cb_lock held.
//
void  // Returns: Nothing.
DisassocDone(TCPConn *Conn,  // Connection going to 0.
             KIRQL Irql0)    // IRQL prior to TCPConnBlock.cb_lock acquisition.
{
    RequestCompleteRoutine Rtn;  // Completion routine.
    PVOID Context;  // User context for completion routine.
    AddrObj *AO;
    uint NeedClose = FALSE;
    KIRQL Irql1, Irql2;

    ASSERT(Conn->tc_flags & CONN_DISACC);
    ASSERT(!(Conn->tc_flags & CONN_CLOSING));
    ASSERT(Conn->tc_refcnt == 0);

    Rtn = Conn->tc_rtn;
    Context = Conn->tc_rtncontext;
    Conn->tc_refcnt = 1;
    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);

    KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
    KeAcquireSpinLock(&Conn->tc_ConnBlock->cb_lock, &Irql1);
    if (!(Conn->tc_flags & CONN_CLOSING)) {

        AO = Conn->tc_ao;
        if (AO != NULL) {
            KeAcquireSpinLock(&AO->ao_lock, &Irql2);
            RemoveConnFromAO(AO, Conn);
            KeReleaseSpinLock(&AO->ao_lock, Irql2);
        }

        ASSERT(Conn->tc_refcnt == 1);
        Conn->tc_flags &= ~CONN_DISACC;
    } else
        NeedClose = TRUE;

    Conn->tc_refcnt = 0;
    KeReleaseSpinLock(&AddrObjTableLock, Irql1);

    if (NeedClose) {
        CloseDone(Conn, Irql0);
    } else {
        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
        (*Rtn)(Context, TDI_SUCCESS, 0);
    }
}


//* FreeConnReq - Free a connection request structure.
//
//  Called to free a connection request structure.
//
void                       // Returns: Nothing.
FreeConnReq(
    TCPConnReq *FreedReq)  // Connection request structure to be freed.
{
    PSLIST_ENTRY BufferLink;

    CHECK_STRUCT(FreedReq, tcr);

    BufferLink = CONTAINING_RECORD(&(FreedReq->tcr_req.tr_q.q_next),
                                   SLIST_ENTRY, Next);

    ExInterlockedPushEntrySList(&ConnReqFree, BufferLink, &ConnReqFreeLock);
}


//* GetConnReq - Get a connection request structure.
//
//  Called to get a connection request structure.
//
TCPConnReq *      // Returns: Pointer to ConnReq structure, or NULL if none.
GetConnReq(void)  // Nothing.
{
    TCPConnReq *Temp;
    PSLIST_ENTRY BufferLink;
    Queue *QueuePtr;
    TCPReq *ReqPtr;

    BufferLink = ExInterlockedPopEntrySList(&ConnReqFree, &ConnReqFreeLock);

    if (BufferLink != NULL) {
        QueuePtr = CONTAINING_RECORD(BufferLink, Queue, q_next);
        ReqPtr = CONTAINING_RECORD(QueuePtr, TCPReq, tr_q);
        Temp = CONTAINING_RECORD(ReqPtr, TCPConnReq, tcr_req);
        CHECK_STRUCT(Temp, tcr);
    } else {
        if (NumConnReq < MaxConnReq)
            Temp = ExAllocatePool(NonPagedPool, sizeof(TCPConnReq));
        else
            Temp = NULL;

        if (Temp != NULL) {
            ExInterlockedAddUlong((PULONG)&NumConnReq, 1, &ConnReqFreeLock);
#if DBG
            Temp->tcr_req.tr_sig = tr_signature;
            Temp->tcr_sig = tcr_signature;
#endif
        }
    }

    return Temp;
}


//* GetConnFromConnID - Get a Connection from a connection ID.
//
//  Called to obtain a Connection pointer from a ConnID.  We don't actually
//  check the connection pointer here, but we do bounds check the input ConnID
//  and make sure the instance fields match.
//  If successful, returns with TCPConnBlock.cb_lock held.
//
TCPConn *         // Returns: Pointer to the TCPConn, or NULL.
GetConnFromConnID(
    uint ConnID,  // Connection ID to find a pointer for.
    KIRQL* Irql)  // Receives IRQL prior to TCPConnBlock.cb_lock acquisition.
{
    uint ConnIndex = CONN_INDEX(ConnID);
    uint ConnBlockId = CONN_BLOCKID(ConnID);
    TCPConn *MatchingConn = NULL;
    TCPConnBlock *ConnBlock;

    if (ConnIndex < MAX_CONN_PER_BLOCK && ConnBlockId < MaxAllocatedConnBlocks) {

        ConnBlock = ConnTable[ConnBlockId];
        if (ConnBlock) {
            MatchingConn = ConnBlock->cb_conn[ConnIndex];
        }
        if (MatchingConn != NULL) {
            KeAcquireSpinLock(&ConnBlock->cb_lock, Irql);
            //
            // Revalidate under lock that the conn is still in conn table.
            //
            MatchingConn = ConnBlock->cb_conn[ConnIndex];
            if (MatchingConn != NULL) {
                CHECK_STRUCT(MatchingConn, tc);
                if (MatchingConn->tc_inst != CONN_INST(ConnID)) {
                    MatchingConn = NULL;
                    KeReleaseSpinLock(&ConnBlock->cb_lock, *Irql);
                }
            } else {
                KeReleaseSpinLock(&ConnBlock->cb_lock, *Irql);
            }
        }
    } else
        MatchingConn = NULL;

    return MatchingConn;
}


//* GetConnID - Get a ConnTable slot.
//
//  Called during OpenConnection to find a free slot in the ConnTable and
//  set it up with a connection.
//  If successful, returns with TCPConnBlock.cb_lock held.
//
uint                   // Returns: A ConnId to use.
GetConnID(
    TCPConn *NewConn,  // Connection to enter into slot.
    KIRQL *Irql0)      // Receives IRQL prior to TCPConnBlock.cb_lock
                       // acquisition.
{
    uint CurrConnID = NewConn->tc_connid;
    uint i, j, BlockID, ConnIndex;

    //
    // If NewConn contains a valid ConnID and that location is unoccupied,
    // reuse it.
    //
    if (CurrConnID != INVALID_CONN_ID &&
        !NewConn->tc_ConnBlock->cb_conn[CONN_INDEX(CurrConnID)]) {
        KeAcquireSpinLock(&NewConn->tc_ConnBlock->cb_lock, Irql0);
        //
        // Reconfirm under lock that the location is unoccupied and, if so,
        // claim it.
        //
        if (!NewConn->tc_ConnBlock->cb_conn[CONN_INDEX(CurrConnID)]) {
            NewConn->tc_ConnBlock->cb_conn[CONN_INDEX(CurrConnID)] = NewConn;
            NewConn->tc_ConnBlock->cb_freecons--;
            NewConn->tc_inst = NewConn->tc_ConnBlock->cb_conninst++;
            NewConn->tc_connid = MAKE_CONN_ID(CONN_INDEX(CurrConnID),
                                              NewConn->tc_ConnBlock->cb_blockid,
                                              NewConn->tc_inst);
            return NewConn->tc_connid;
        }
        KeReleaseSpinLock(&NewConn->tc_ConnBlock->cb_lock, *Irql0);
    }

    //
    // NewConn's last spot is taken; search from the block from which
    // a ConnID was claimed most recently.
    //
    if (MaxAllocatedConnBlocks) {
        //
        // Capture the global counters without acquiring the lock.
        //
        uint TempMaxAllocatedConnBlocks = MaxAllocatedConnBlocks;
        uint TempNextConnBlock = NextConnBlock;

        for (i = 0; i < TempMaxAllocatedConnBlocks; i++) {
            BlockID = (TempNextConnBlock + i) % TempMaxAllocatedConnBlocks;

            if (!ConnTable[BlockID] || !ConnTable[BlockID]->cb_freecons) {
                continue;
            }

            //
            // Reconfirm under lock that the TCPConnBlock has free slots.
            //
            KeAcquireSpinLock(&ConnTable[BlockID]->cb_lock, Irql0);
            if (!ConnTable[BlockID]->cb_freecons) {
                KeReleaseSpinLock(&ConnTable[BlockID]->cb_lock, *Irql0);
                continue;
            }
            for (j = 0; j < MAX_CONN_PER_BLOCK; j++) {
                ConnIndex = (ConnTable[BlockID]->cb_nextfree + j) %
                            MAX_CONN_PER_BLOCK;
                if (ConnTable[BlockID]->cb_conn[ConnIndex]) {
                    continue;
                }

                //
                // Found the free slot; fill it in.
                //
                ConnTable[BlockID]->cb_conn[ConnIndex] = NewConn;
                ConnTable[BlockID]->cb_nextfree = ConnIndex + 1;
                ConnTable[BlockID]->cb_freecons--;
                if (!ConnTable[BlockID]->cb_freecons) {
                    InterlockedCompareExchange((PLONG)&NextConnBlock,
                                               TempNextConnBlock,
                                               TempNextConnBlock + 1);
                }
                NewConn->tc_ConnBlock = ConnTable[BlockID];
                NewConn->tc_inst = ConnTable[BlockID]->cb_conninst++;
                NewConn->tc_connid = MAKE_CONN_ID(ConnIndex, BlockID,
                                                  NewConn->tc_inst);
                return NewConn->tc_connid;
            }
            KeReleaseSpinLock(&ConnTable[BlockID]->cb_lock, *Irql0);
        }
    }

    //
    // The entire table is occupied; if we have room to grow,
    // allocate a new block.
    //

    KeAcquireSpinLock(&ConnTableLock, Irql0);
    if (MaxAllocatedConnBlocks < MaxConnBlocks) {
        TCPConnBlock* ConnBlock;
        BlockID = MaxAllocatedConnBlocks;
        ConnBlock = ExAllocatePool(NonPagedPool, sizeof(TCPConnBlock));
        if (ConnBlock) {
            RtlZeroMemory(ConnBlock, sizeof(TCPConnBlock));
            KeInitializeSpinLock(&ConnBlock->cb_lock);

            KeAcquireSpinLockAtDpcLevel(&ConnBlock->cb_lock);

            ConnBlock->cb_blockid = BlockID;
            ConnBlock->cb_freecons = MAX_CONN_PER_BLOCK - 1;
            ConnBlock->cb_nextfree = 1;
            ConnBlock->cb_conninst = 2;
            ConnBlock->cb_conn[0] = NewConn;

            NewConn->tc_ConnBlock = ConnBlock;
            NewConn->tc_inst = 1;
            NewConn->tc_connid = MAKE_CONN_ID(0, BlockID, NewConn->tc_inst);

            ConnTable[BlockID] = ConnBlock;
            InterlockedIncrement((PLONG)&MaxAllocatedConnBlocks);

            KeReleaseSpinLockFromDpcLevel(&ConnTableLock);

            return NewConn->tc_connid;
        }
    }

    KeReleaseSpinLock(&ConnTableLock, *Irql0);
    return INVALID_CONN_ID;
}


//* FreeConnID - Free a ConnTable slot.
//
//  Called when we're done with a ConnID. We assume the caller holds the lock
//  on the TCPConnBlock when we are called.
//
void               // Returns: Nothing.
FreeConnID(
    TCPConn *Conn)  // Conn to be freed.
{
    uint ConnIndex = CONN_INDEX(Conn->tc_connid);  // Index into conn table.
    uint BlockID = CONN_BLOCKID(Conn->tc_connid);
    TCPConnBlock* ConnBlock = Conn->tc_ConnBlock;

    ASSERT(ConnIndex < MAX_CONN_PER_BLOCK);
    ASSERT(BlockID < MaxAllocatedConnBlocks);
    ASSERT(ConnBlock->cb_conn[ConnIndex] != NULL);

    if (ConnBlock->cb_conn[ConnIndex]) {
        ConnBlock->cb_conn[ConnIndex] = NULL;
        ConnBlock->cb_freecons++;
        ConnBlock->cb_nextfree = ConnIndex;
        ASSERT(ConnBlock->cb_freecons <= MAX_CONN_PER_BLOCK);
    } else {
        ABORT();
    }
}


//* MapIPError - Map an IP error to a TDI error.
//
//  Called to map an input IP error code to a TDI error code. If we can't,
//  we return the provided default.
//
TDI_STATUS  // Returns: Mapped TDI error.
MapIPError(
    IP_STATUS IPError,   // Error code to be mapped.
    TDI_STATUS Default)  // Default error code to return.
{
    switch (IPError) {

        case IP_DEST_NO_ROUTE:
            return TDI_DEST_NET_UNREACH;
        case IP_DEST_ADDR_UNREACHABLE:
            return TDI_DEST_HOST_UNREACH;
        case IP_UNRECOGNIZED_NEXT_HEADER:
            return TDI_DEST_PROT_UNREACH;
        case IP_DEST_PORT_UNREACHABLE:
            return TDI_DEST_PORT_UNREACH;
        default:
            return Default;
    }
}


//* FinishRemoveTCBFromConn - Finish removing a TCB from a conn structure.
//
//  Called when we have the locks we need and we just want to pull the
//  TCB off the connection.
//
void  // Returns: Nothing.
FinishRemoveTCBFromConn(
    TCB *RemovedTCB)  // TCB to be removed.
{
    TCPConn *Conn;
    AddrObj *AO;
    KIRQL Irql;
    TCPConnBlock *ConnBlock = NULL;

    if (((Conn = RemovedTCB->tcb_conn) != NULL)  &&
        (Conn->tc_tcb == RemovedTCB)) {
        CHECK_STRUCT(Conn, tc);
        ConnBlock = Conn->tc_ConnBlock;

        KeAcquireSpinLock(&ConnBlock->cb_lock, &Irql);

        AO = Conn->tc_ao;

        if (AO != NULL) {
            KeAcquireSpinLockAtDpcLevel(&AO->ao_lock);
            if (AO_VALID(AO)) {
                KeAcquireSpinLockAtDpcLevel(&RemovedTCB->tcb_lock);

                // Need to double check this is still correct.

                if (Conn == RemovedTCB->tcb_conn) {
                    // Everything still looks good.
                    REMOVEQ(&Conn->tc_q);
                    PUSHQ(&AO->ao_idleq, &Conn->tc_q);
                } else
                    Conn = RemovedTCB->tcb_conn;
            } else {
                KeAcquireSpinLockAtDpcLevel(&RemovedTCB->tcb_lock);
                Conn = RemovedTCB->tcb_conn;
            }

            KeReleaseSpinLockFromDpcLevel(&AO->ao_lock);
        } else {
            KeAcquireSpinLockAtDpcLevel(&RemovedTCB->tcb_lock);
            Conn = RemovedTCB->tcb_conn;
        }

        if (Conn != NULL) {
            if (Conn->tc_tcb == RemovedTCB)
                Conn->tc_tcb = NULL;
            else
                ASSERT(Conn->tc_tcb == NULL);
        }

        KeReleaseSpinLockFromDpcLevel(&RemovedTCB->tcb_lock);
        KeReleaseSpinLock(&ConnBlock->cb_lock, Irql);
    }
}


//* RemoveTCBFromConn - Remove a TCB from a Conn structure.
//
//  Called when we need to disassociate a TCB from a connection structure.
//  All we do is get the appropriate locks and call FinishRemoveTCBFromConn.
//
void                  // Returns: Nothing.
RemoveTCBFromConn(
    TCB *RemovedTCB)  // TCB to be removed.
{
    CHECK_STRUCT(RemovedTCB, tcb);

    FinishRemoveTCBFromConn(RemovedTCB);
}


//* RemoveConnFromTCB - Remove a conn from a TCB.
//
//  Called when we want to break the final association between a connection
//  and a TCB.
//
void                 // Returns: Nothing.
RemoveConnFromTCB(
    TCB *RemoveTCB)  // TCB to be removed.
{
    ConnDoneRtn DoneRtn = NULL;
    KIRQL Irql = 0;
    TCPConn *Conn;

    if ((Conn = RemoveTCB->tcb_conn) != NULL) {
        KeAcquireSpinLock(&Conn->tc_ConnBlock->cb_lock, &Irql);
        KeAcquireSpinLockAtDpcLevel(&RemoveTCB->tcb_lock);

        CHECK_STRUCT(Conn, tc);

        if (--(Conn->tc_refcnt) == 0)
            DoneRtn = Conn->tc_donertn;

        RemoveTCB->tcb_conn = NULL;
        KeReleaseSpinLockFromDpcLevel(&RemoveTCB->tcb_lock);
    }

    if (DoneRtn != NULL)
        (*DoneRtn)(Conn, Irql);
    else if (Conn) {
        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql);
    }
}


//* CloseTCB - Close a TCB.
//
//  Called when we are done with a TCB, and want to free it. We'll remove
//  him from any tables that he's in, and destroy any outstanding requests.
//
void  // Returns: Nothing.
CloseTCB(
    TCB *ClosedTCB,  // TCB to be closed.
    KIRQL OldIrql)   // IRQL prior to acquiring TCB lock.
{
    uchar OrigState = ClosedTCB->tcb_state;
    TDI_STATUS Status;
    uint OKToFree;

    CHECK_STRUCT(ClosedTCB, tcb);
    ASSERT(ClosedTCB->tcb_refcnt == 0);
    ASSERT(ClosedTCB->tcb_state != TCB_CLOSED);
    ASSERT(ClosedTCB->tcb_pending & DEL_PENDING);

    //
    // We'll check to make sure that our state isn't CLOSED.  This should never
    // happen, since nobody should call TryToCloseTCB when the state is
    // closed, or take the reference count if we're closing.  Nevertheless,
    // we'll double check as a safety measure.
    //
    if (ClosedTCB->tcb_state == TCB_CLOSED) {
        KeReleaseSpinLock(&ClosedTCB->tcb_lock, OldIrql);
        return;
    }

    //
    // Update SNMP counters.  If we're in SYN-SENT or SYN-RCVD, this is a
    // failed connection attempt.  If we're in ESTABLISED or CLOSE-WAIT,
    // treat this as an 'Established Reset' event.
    //
    if (ClosedTCB->tcb_state == TCB_SYN_SENT ||
        ClosedTCB->tcb_state == TCB_SYN_RCVD)
        TStats.ts_attemptfails++;
    else
        if (ClosedTCB->tcb_state == TCB_ESTAB ||
            ClosedTCB->tcb_state == TCB_CLOSE_WAIT) {
            TStats.ts_estabresets++;
            InterlockedDecrement((PLONG)&TStats.ts_currestab);
            ASSERT(*(int *)&TStats.ts_currestab >= 0);
        }

    ClosedTCB->tcb_state = TCB_CLOSED;
    KeReleaseSpinLockFromDpcLevel(&ClosedTCB->tcb_lock);

    //
    // Remove the TCB from it's associated TCPConn structure, if it has one.
    //
    FinishRemoveTCBFromConn(ClosedTCB);

    KeAcquireSpinLockAtDpcLevel(&TCBTableLock);
    KeAcquireSpinLockAtDpcLevel(&ClosedTCB->tcb_lock);

    OKToFree = RemoveTCB(ClosedTCB);

    //
    // He's been pulled from the appropriate places so nobody can find him.
    // Free the locks, and proceed to destroy any requests, etc.
    //
    KeReleaseSpinLockFromDpcLevel(&ClosedTCB->tcb_lock);
    KeReleaseSpinLock(&TCBTableLock, OldIrql);

    if ((SYNC_STATE(OrigState) || OrigState == TCB_SYN_RCVD) && 
        !GRACEFUL_CLOSED_STATE(OrigState)) {
        if (ClosedTCB->tcb_flags & NEED_RST)
            SendRSTFromTCB(ClosedTCB);
    }

    //
    // Release our references on our NTE and RCE.
    // We won't be sending anymore on this TCB.
    //
    if (ClosedTCB->tcb_nte != NULL)
        ReleaseNTE(ClosedTCB->tcb_nte);
    if (ClosedTCB->tcb_rce != NULL)
        ReleaseRCE(ClosedTCB->tcb_rce);

    if (ClosedTCB->tcb_closereason & TCB_CLOSE_RST)
        Status = TDI_CONNECTION_RESET;
    else if (ClosedTCB->tcb_closereason & TCB_CLOSE_ABORTED)
        Status = TDI_CONNECTION_ABORTED;
    else if (ClosedTCB->tcb_closereason & TCB_CLOSE_TIMEOUT)
        Status = MapIPError(ClosedTCB->tcb_error, TDI_TIMED_OUT);
    else if (ClosedTCB->tcb_closereason & TCB_CLOSE_REFUSED)
        Status = TDI_CONN_REFUSED;
    else if (ClosedTCB->tcb_closereason & TCB_CLOSE_UNREACH)
        Status = MapIPError(ClosedTCB->tcb_error, TDI_DEST_UNREACHABLE);
    else
        Status = TDI_SUCCESS;

    //
    // Now complete any outstanding requests on the TCB.
    //
    if (ClosedTCB->tcb_abortreq != NULL) {
        TCPAbortReq* AbortReq = ClosedTCB->tcb_abortreq;

        (*AbortReq->tar_rtn)(AbortReq->tar_context, TDI_SUCCESS, 0);
    }

    if (ClosedTCB->tcb_connreq != NULL) {
        TCPConnReq *ConnReq = ClosedTCB->tcb_connreq;

        CHECK_STRUCT(ConnReq, tcr);

        (*ConnReq->tcr_req.tr_rtn)(ConnReq->tcr_req.tr_context, Status, 0);
        FreeConnReq(ConnReq);
    }

    if (ClosedTCB->tcb_discwait != NULL) {
        TCPConnReq *ConnReq = ClosedTCB->tcb_discwait;

        CHECK_STRUCT(ConnReq, tcr);

        (*ConnReq->tcr_req.tr_rtn)(ConnReq->tcr_req.tr_context, Status, 0);
        FreeConnReq(ConnReq);
    }

    while (!EMPTYQ(&ClosedTCB->tcb_sendq)) {
        TCPReq *Req;
        TCPSendReq *SendReq;
        long Result;

        DEQUEUE(&ClosedTCB->tcb_sendq, Req, TCPReq, tr_q);

        CHECK_STRUCT(Req, tr);
        SendReq = (TCPSendReq *)Req;
        CHECK_STRUCT(SendReq, tsr);

        //
        // Set the status before dropping the ref count. 
        //
        SendReq->tsr_req.tr_status = Status;

        //
        // Decrement the initial reference put on the buffer when it was
        // allocated.  This reference would have been decremented if the
        // send had been acknowledged, but then the send would not still
        // be on the tcb_sendq.
        //
        Result = InterlockedDecrement(&(SendReq->tsr_refcnt));

        ASSERT(Result >= 0);

        if (Result <= 0) {
            // If we've sent directly from this send, NULL out the next
            // pointer for the last buffer in the chain.
            if (SendReq->tsr_lastbuf != NULL) {
                NDIS_BUFFER_LINKAGE(SendReq->tsr_lastbuf) = NULL;
                SendReq->tsr_lastbuf = NULL;
            }

            (*Req->tr_rtn)(Req->tr_context, Status, 0);
            FreeSendReq(SendReq);
        }
    }

    while (ClosedTCB->tcb_rcvhead != NULL) {
        TCPRcvReq *RcvReq;

        RcvReq = ClosedTCB->tcb_rcvhead;
        CHECK_STRUCT(RcvReq, trr);
        ClosedTCB->tcb_rcvhead = RcvReq->trr_next;
        (*RcvReq->trr_rtn)(RcvReq->trr_context, Status, 0);
        FreeRcvReq(RcvReq);
    }

    while (ClosedTCB->tcb_exprcv != NULL) {
        TCPRcvReq *RcvReq;

        RcvReq = ClosedTCB->tcb_exprcv;
        CHECK_STRUCT(RcvReq, trr);
        ClosedTCB->tcb_exprcv = RcvReq->trr_next;
        (*RcvReq->trr_rtn)(RcvReq->trr_context, Status, 0);
        FreeRcvReq(RcvReq);
    }

    if (ClosedTCB->tcb_pendhead != NULL)
        FreePacketChain(ClosedTCB->tcb_pendhead);

    if (ClosedTCB->tcb_urgpending != NULL)
        FreePacketChain(ClosedTCB->tcb_urgpending);

    while (ClosedTCB->tcb_raq != NULL) {
        TCPRAHdr *Hdr;

        Hdr = ClosedTCB->tcb_raq;
        CHECK_STRUCT(Hdr, trh);
        ClosedTCB->tcb_raq = Hdr->trh_next;
        if (Hdr->trh_buffer != NULL)
            FreePacketChain(Hdr->trh_buffer);

        ExFreePool(Hdr);
    }

    RemoveConnFromTCB(ClosedTCB);

    if (OKToFree) {
        FreeTCB(ClosedTCB);
    } else {
        KeAcquireSpinLock(&TCBTableLock, &OldIrql);
        ClosedTCB->tcb_walkcount--;
        if (ClosedTCB->tcb_walkcount == 0) {
            FreeTCB(ClosedTCB);
        }
        KeReleaseSpinLock(&TCBTableLock, OldIrql);
    }
}


//* TryToCloseTCB - Try to close a TCB.
//
//  Called when we need to close a TCB, but don't know if we can.
//  If the reference count is 0, we'll call CloseTCB to deal with it.
//  Otherwise we'll set the DELETE_PENDING bit and deal with it when the
//  ref. count goes to 0.  We assume the TCB is locked when we are called.
//
void                    // Returns: Nothing.
TryToCloseTCB   (
    TCB *ClosedTCB,     // TCB to be closed.
    uchar Reason,       // Reason we're closing.
    KIRQL PreLockIrql)  // IRQL prior to acquiring the TCB lock.
{
    CHECK_STRUCT(ClosedTCB, tcb);
    ASSERT(ClosedTCB->tcb_state != TCB_CLOSED);

    ClosedTCB->tcb_closereason |= Reason;

    if (ClosedTCB->tcb_pending & DEL_PENDING) {
        KeReleaseSpinLock(&ClosedTCB->tcb_lock, PreLockIrql);
        return;
    }

    ClosedTCB->tcb_pending |= DEL_PENDING;
    ClosedTCB->tcb_slowcount++;
    ClosedTCB->tcb_fastchk |= TCP_FLAG_SLOW;

    if (ClosedTCB->tcb_refcnt == 0)
        CloseTCB(ClosedTCB, PreLockIrql);
    else {
        KeReleaseSpinLock(&ClosedTCB->tcb_lock, PreLockIrql);
    }
}


//* DerefTCB - Dereference a TCB.
//
//  Called when we're done with a TCB, and want to let exclusive user
//  have a shot.  We dec. the refcount, and if it goes to zero and there
//  are pending actions, we'll perform one of the pending actions.
//
void                    // Returns: Nothing.
DerefTCB(
    TCB *DoneTCB,       // TCB to be dereffed.
    KIRQL PreLockIrql)  // IRQL prior to acquiring the TCB lock.
{

    ASSERT(DoneTCB->tcb_refcnt != 0);
    if (--DoneTCB->tcb_refcnt == 0) {
        if (DoneTCB->tcb_pending == 0) {
            KeReleaseSpinLock(&DoneTCB->tcb_lock, PreLockIrql);
            return;
        } else {
            if (DoneTCB->tcb_pending & RST_PENDING) {
                DoneTCB->tcb_refcnt++;
                NotifyOfDisc(DoneTCB, TDI_CONNECTION_RESET, &PreLockIrql);
                KeAcquireSpinLock(&DoneTCB->tcb_lock, &PreLockIrql);
                DerefTCB(DoneTCB, PreLockIrql);
                return;
            }
            if (DoneTCB->tcb_pending & DEL_PENDING)
                CloseTCB(DoneTCB, PreLockIrql);
            else
                DbgBreakPoint();  // Fatal condition.
            return;
        }
    }

    KeReleaseSpinLock(&DoneTCB->tcb_lock, PreLockIrql);
    return;
}


//* CalculateMSSForTCB - Update MSS, etc. after PMTU changes.
//
//  Calculate our connection's MSS based on our PMTU, the sizes
//  of various headers, and the remote side's advertised MSS.
//  It's expected that this routine will be called whenever
//  our cached copy of the PMTU has been updated to a new value.
//
void
CalculateMSSForTCB(
    TCB *ThisTCB)  // The TCB we're running our calculations on.
{
    uint PMTU;
    IPSecProc *IPSecToDo;
    uint TrailerLength = 0;
    uint IPSecBytes = 0;
    uint Dummy;

    ASSERT(ThisTCB->tcb_pmtu != 0);  // Should be set before entering.
    ASSERT(ThisTCB->tcb_rce != NULL);

    //
    // First check that the PMTU size is reasonable.  IP won't
    // let it get below minimum, but we have our own maximum since
    // currently TCP can only handle an MSS that fits in 16 bits.
    // TBD: If we add IPv6 Jumbogram support, we should also add LFN
    // TBD: support to TCP and change this to handle a larger MSS.
    //
    PMTU = ThisTCB->tcb_pmtu;
    if (PMTU > 65535) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "TCPSend: PMTU update value too large %u\n", PMTU));
        PMTU = 65535;
    }

    //
    // Determine size of IPSec headers, if any.
    //
    IPSecToDo = OutboundSPLookup(&ThisTCB->tcb_saddr, &ThisTCB->tcb_daddr,
                                 IP_PROTOCOL_TCP,
                                 net_short(ThisTCB->tcb_sport),
                                 net_short(ThisTCB->tcb_dport),
                                 ThisTCB->tcb_rce->NTE->IF, &Dummy);
    if (IPSecToDo != NULL) {
        //
        // Calculate the space needed for the IPSec headers.
        //
        IPSecBytes = IPSecBytesToInsert(IPSecToDo, &Dummy, &TrailerLength);
        FreeIPSecToDo(IPSecToDo, IPSecToDo->BundleSize);
        IPSecBytes += TrailerLength;
    }
    IF_TCPDBG(TCP_DEBUG_MSS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "CalculateMSSForTCB: IPSecBytes is %u\n", IPSecBytes));
    }

    //
    // Subtract out the header sizes to yield the TCP MSS.
    // If there is an ESP trailer on this connection, round down
    // the MSS to allow the trailer to end on a 4-byte boundary.
    //
    PMTU -= sizeof(IPv6Header) + sizeof(TCPHeader) + IPSecBytes;
    if (TrailerLength)
        PMTU -= (PMTU & 3);

    //
    // Don't let MSS exceed what our peer advertised, regardless of how
    // large the Path MTU is.
    //
    IF_TCPDBG(TCP_DEBUG_MSS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "CalculateMSSForTCB: Old MSS is %u ", ThisTCB->tcb_mss));
    }
    ThisTCB->tcb_mss = (ushort)MIN(PMTU, ThisTCB->tcb_remmss);
    IF_TCPDBG(TCP_DEBUG_MSS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "New MSS is %u\n", ThisTCB->tcb_mss));
    }

    ASSERT(ThisTCB->tcb_mss != 0);

    //
    // We don't want our Congestion Window to be smaller than one maximum
    // segment, so we may need to increase it when our MSS grows.
    //
    if (ThisTCB->tcb_cwin < ThisTCB->tcb_mss) {
        ThisTCB->tcb_cwin = ThisTCB->tcb_mss;

        //
        // Make sure the slow start threshold is at
        // least 2 segments.
        //
        if (ThisTCB->tcb_ssthresh < ((uint) ThisTCB->tcb_mss * 2)) {
            ThisTCB->tcb_ssthresh = ThisTCB->tcb_mss * 2;
        }
    }
}


//** TdiOpenConnection - Open a connection.
//
//  This is the TDI Open Connection entry point. We open a connection,
//  and save the caller's connection context. A TCPConn structure is allocated
//  here, but a TCB isn't allocated until the Connect or Listen is done.
//
TDI_STATUS                 // Returns: Status of attempt to open connection.
TdiOpenConnection(
    PTDI_REQUEST Request,  // This TDI request.
    PVOID Context)         // Connection context to be save for connection.
{
    TCPConn *NewConn;      // The newly opened connection.
    KIRQL OldIrql;         // Irql prior to acquiring TCPConnBlock lock.
    uint ConnID;           // New ConnID.
    TDI_STATUS Status;     // Status of this request.

    NewConn = ExAllocatePool(NonPagedPool, sizeof(TCPConn));

    if (NewConn != NULL) {
        //
        // We allocated a connection.
        //
        RtlZeroMemory(NewConn, sizeof(TCPConn));
#if DBG
        NewConn->tc_sig = tc_signature;
#endif
        NewConn->tc_tcb = NULL;
        NewConn->tc_ao = NULL;
        NewConn->tc_context = Context;
        NewConn->tc_connid = INVALID_CONN_ID;

        ConnID = GetConnID(NewConn, &OldIrql);
        if (ConnID != INVALID_CONN_ID) {
            //
            // We successfully got a ConnID.
            //
            Request->Handle.ConnectionContext = (CONNECTION_CONTEXT)UIntToPtr(ConnID);
            NewConn->tc_refcnt = 0;
            NewConn->tc_flags = 0;
            NewConn->tc_tcbflags =  NAGLING | (BSDUrgent ? BSD_URGENT : 0);
            if (DefaultRcvWin != 0) {
                NewConn->tc_window = DefaultRcvWin;
                NewConn->tc_flags |= CONN_WINSET;
            } else
                NewConn->tc_window = DEFAULT_RCV_WIN;

            NewConn->tc_donertn = DummyDone;
            NewConn->tc_owningpid = HandleToUlong(PsGetCurrentProcessId());
            Status = TDI_SUCCESS;
            KeReleaseSpinLock(&NewConn->tc_ConnBlock->cb_lock, OldIrql);
        } else {
            ExFreePool(NewConn);
            Status = TDI_NO_RESOURCES;
        }

        return Status;
    }

    //
    // Couldn't get a connection.
    //
    return TDI_NO_RESOURCES;
}


//* RemoveConnFromAO - Remove a connection from an AddrObj.
//
//  A little utility routine to remove a connection from an AddrObj.
//  We run down the connections on the AO, and when we find him we splice
//  him out. We assume the caller holds the locks on the AddrObj and the
//  TCPConnBlock lock.
//
void                // Returns: Nothing.
RemoveConnFromAO(
    AddrObj *AO,    // AddrObj to remove from.
    TCPConn *Conn)  // Conn to remove.
{
    CHECK_STRUCT(AO, ao);
    CHECK_STRUCT(Conn, tc);

    REMOVEQ(&Conn->tc_q);
    Conn->tc_ao = NULL;
}


//* TdiCloseConnection - Close a connection.
//
//  Called when the user is done with a connection, and wants to close it.
//  We look the connection up in our table, and if we find it we'll remove
//  the connection from the AddrObj it's associate with (if any).  If there's
//  a TCB associated with the connection we'll close it also.
//
//  There are some interesting wrinkles related to closing while a TCB
//  is still referencing the connection (i.e. tc_refcnt != 0) or while a
//  disassociate address is in progress.  See below for more details.
//
TDI_STATUS                 // Returns: Status of attempt to close.
TdiCloseConnection(
    PTDI_REQUEST Request)  // Request identifying connection to be closed.
{
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    KIRQL Irql0;
    TCPConn *Conn;
    TDI_STATUS Status;

    //
    // We have the locks we need.  Try to find a connection.
    //
    Conn = GetConnFromConnID(ConnID, &Irql0);

    if (Conn != NULL)  {
        KIRQL Irql1;
        TCB *ConnTCB;

        //
        // We found the connection.  Free the ConnID and mark the connection
        // as closing.
        //
        CHECK_STRUCT(Conn, tc);

        FreeConnID(Conn);

        Conn->tc_flags |= CONN_CLOSING;

        //
        // See if there's a TCB referencing this connection.
        // If there is, we'll need to wait until he's done before closing him.
        // We'll hurry the process along if we still have a pointer to him.
        //
        if (Conn->tc_refcnt != 0) {
            RequestCompleteRoutine Rtn;
            PVOID Context;

            //
            // A connection still references him.  Save the current rtn stuff
            // in case we are in the middle of disassociating him from an
            // address, and store the caller's callback routine and our done
            // routine.
            //
            Rtn = Conn->tc_rtn;
            Context = Conn->tc_rtncontext;

            Conn->tc_rtn = Request->RequestNotifyObject;
            Conn->tc_rtncontext = Request->RequestContext;
            Conn->tc_donertn = CloseDone;

            //
            // See if we're in the middle of disassociating him.
            //
            if (Conn->tc_flags & CONN_DISACC) {

                //
                // We are disassociating him.  We'll free the conn table lock
                // now and fail the disassociate request.  Note that when
                // we free the lock the refcount could go to zero.  This is
                // OK, because we've already stored the neccessary info. in
                // the connection so the caller will get called back if it
                // does.  From this point out we return PENDING, so a callback
                // is OK.  We've marked him as closing, so the disassoc done
                // routine will bail out if we've interrupted him.  If the ref.
                // count does go to zero, Conn->tc_tcb would have to be NULL,
                // so in that case we'll just fall out of this routine.
                //
                KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
                (*Rtn)(Context, (uint) TDI_REQ_ABORTED, 0);
                KeAcquireSpinLock(&Conn->tc_ConnBlock->cb_lock, &Irql0);
            }

            ConnTCB = Conn->tc_tcb;
            if (ConnTCB != NULL) {
                CHECK_STRUCT(ConnTCB, tcb);
                //
                // We have a TCB.  Take the lock on him and get ready to
                // close him.
                //
                KeAcquireSpinLock(&ConnTCB->tcb_lock, &Irql1);
                if (ConnTCB->tcb_state != TCB_CLOSED) {
                    ConnTCB->tcb_flags |= NEED_RST;
                    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);
                    if (!CLOSING(ConnTCB))
                        TryToCloseTCB(ConnTCB, TCB_CLOSE_ABORTED, Irql0);
                    else
                        KeReleaseSpinLock(&ConnTCB->tcb_lock, Irql0);
                    return TDI_PENDING;
                } else {
                    //
                    // He's already closing.  This should be harmless, but
                    // check this case.
                    //
                    KeReleaseSpinLock(&ConnTCB->tcb_lock, Irql1);
                }
            }
            Status = TDI_PENDING;

        }  else {
            //
            // We have a connection that we can close.  Finish the close.
            //
            Conn->tc_rtn = DummyCmplt;
            CloseDone(Conn, Irql0);
            return TDI_SUCCESS;
        }

        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);

    } else
        Status = TDI_INVALID_CONNECTION;

    //
    // We're done with the connection. Go ahead and free him.
    //

    return Status;
}


//* TdiAssociateAddress - Associate an address with a connection.
//
//  Called to associate an address with a connection. We do a minimal
//  amount of sanity checking, and then put the connection on the AddrObj's
//  list.
//
TDI_STATUS                 // Returns: Status of attempt to associate.
TdiAssociateAddress(
    PTDI_REQUEST Request,  // Structure for this request.
    HANDLE AddrHandle)     // Address handle to associate connection with.
{
    KIRQL Irql0, Irql1;  // One per lock nesting level.
    AddrObj *AO;
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    TCPConn *Conn;
    TDI_STATUS Status;

    AO = (AddrObj *)AddrHandle;
    CHECK_STRUCT(AO, ao);

    Conn = GetConnFromConnID(ConnID, &Irql0);
    KeAcquireSpinLock(&AO->ao_lock, &Irql1);
    if (!AO_VALID(AO)) {
        KeReleaseSpinLock(&AO->ao_lock, Irql1);
        if (Conn != NULL) {
            KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
        }
        return TDI_INVALID_PARAMETER;
    }

    if (Conn != NULL) {
        CHECK_STRUCT(Conn, tc);

        if (Conn->tc_ao != NULL) {
            //
            // It's already associated.  Error out.
            //
            KdBreakPoint();
            Status = TDI_ALREADY_ASSOCIATED;
        } else {
            Conn->tc_ao = AO;
            ASSERT(Conn->tc_tcb == NULL);
            PUSHQ(&AO->ao_idleq, &Conn->tc_q);
            Status = TDI_SUCCESS;
        }
        KeReleaseSpinLock(&AO->ao_lock, Irql1);
        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
        return Status;
    } else
        Status = TDI_INVALID_CONNECTION;

    KeReleaseSpinLock(&AO->ao_lock, Irql1);
    return Status;
}


//* TdiDisAssociateAddress - Disassociate a connection from an address.
//
//  The TDI entry point to disassociate a connection from an address. The
//  connection must actually be associated and not connected to anything.
//
TDI_STATUS                 // Returns: Status of request.
TdiDisAssociateAddress(
    PTDI_REQUEST Request)  // Structure for this request.
{
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    KIRQL Irql0, Irql1, Irql2;  // One per lock nesting level.
    TCPConn *Conn;
    AddrObj *AO;
    TDI_STATUS Status;

    KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
    Conn = GetConnFromConnID(ConnID, &Irql1);

    if (Conn != NULL) {
        //
        // The connection actually exists!
        //
        CHECK_STRUCT(Conn, tc);
        AO = Conn->tc_ao;
        if (AO != NULL) {
            CHECK_STRUCT(AO, ao);
            //
            // And it's associated.
            //
            KeAcquireSpinLock(&AO->ao_lock, &Irql2);
            //
            // If there's no connection currently active, go ahead and remove
            // him from the AddrObj.  If a connection is active error the
            // request out.
            //
            if (Conn->tc_tcb == NULL) {
                if (Conn->tc_refcnt == 0) {
                    RemoveConnFromAO(AO, Conn);
                    Status = TDI_SUCCESS;
                } else {
                    //
                    // He shouldn't be closing, or we couldn't have found him.
                    //
                    ASSERT(!(Conn->tc_flags & CONN_CLOSING));

                    Conn->tc_rtn = Request->RequestNotifyObject;
                    Conn->tc_rtncontext = Request->RequestContext;
                    Conn->tc_donertn = DisassocDone;
                    Conn->tc_flags |= CONN_DISACC;
                    Status = TDI_PENDING;
                }

            } else
                Status = TDI_CONNECTION_ACTIVE;
            KeReleaseSpinLock(&AO->ao_lock, Irql2);
        } else
            Status = TDI_NOT_ASSOCIATED;
        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);
    } else
        Status = TDI_INVALID_CONNECTION;

    KeReleaseSpinLock(&AddrObjTableLock, Irql0);

    return Status;
}

//* InitTCBFromConn - Initialize a TCB from information in a Connection.
//
//  Called from Connect and Listen processing to initialize a new TCB from
//  information in the connection.  We assume the AddrObjTableLock and
//  TCPConnBlock locks are held when we are called, or that the caller has some
//  other way of making sure that the referenced AO doesn't go away in the
//  middle of operation.
//
//  Input:  Conn            - Connection to initialize from.
//          NewTCB          - TCB to be initialized.
//          Addr            - Remote addressing and option info for NewTCB.
//          AOLocked        - True if the called has the address object locked.
//
//
TDI_STATUS  // Returns: TDI_STATUS of init attempt.
InitTCBFromConn(
    TCPConn *Conn,                     // Connection to initialize from.
    TCB *NewTCB,                       // TCB to be initialized.
    PTDI_CONNECTION_INFORMATION Addr,  // Remove addr info, etc. for NewTCB.
    uint AOLocked)                     // True if caller has addr object lock.
{
    KIRQL OldIrql;

    CHECK_STRUCT(Conn, tc);

    //
    // We have a connection.  Make sure it's associated with an address and
    // doesn't already have a TCB attached.
    //
    if (Conn->tc_flags & CONN_INVALID)
        return TDI_INVALID_CONNECTION;

    if (Conn->tc_tcb == NULL) {
        AddrObj *ConnAO;

        ConnAO = Conn->tc_ao;
        if (ConnAO != NULL) {
            CHECK_STRUCT(ConnAO, ao);

            if (!AOLocked) {
                KeAcquireSpinLock(&ConnAO->ao_lock, &OldIrql);
            }
            if (!(NewTCB->tcb_flags & ACCEPT_PENDING)) {
                //
                // These fields are already initialized
                // when ACCEPT_PENDING is on.
                //
                NewTCB->tcb_saddr = ConnAO->ao_addr;
                NewTCB->tcb_sscope_id = ConnAO->ao_scope_id;
                NewTCB->tcb_sport = ConnAO->ao_port;
                NewTCB->tcb_defaultwin = Conn->tc_window;
                NewTCB->tcb_rcvwin = Conn->tc_window;
            }

            NewTCB->tcb_rcvind = ConnAO->ao_rcv;
            NewTCB->tcb_ricontext = ConnAO->ao_rcvcontext;
            if (NewTCB->tcb_rcvind == NULL)
                NewTCB->tcb_rcvhndlr = PendData;
            else
                NewTCB->tcb_rcvhndlr = IndicateData;

            NewTCB->tcb_conncontext = Conn->tc_context;
            NewTCB->tcb_flags |= Conn->tc_tcbflags;

            if (Conn->tc_flags & CONN_WINSET)
                NewTCB->tcb_flags |= WINDOW_SET;

            if (NewTCB->tcb_flags & KEEPALIVE) {
                NewTCB->tcb_alive = TCPTime;
                NewTCB->tcb_kacount = 0;
            }

            NewTCB->tcb_hops = ConnAO->ao_ucast_hops;

            if (!AOLocked) {
                KeReleaseSpinLock(&ConnAO->ao_lock, OldIrql);
            }

            return TDI_SUCCESS;
        } else
            return TDI_NOT_ASSOCIATED;
    } else
        return TDI_CONNECTION_ACTIVE;
}


//* TdiConnect - Establish a connection.
//
//  The TDI connection establishment routine. Called when the client wants to
//  establish a connection, we validate his incoming parameters and kick
//  things off by sending a SYN.
//
//  Note: The format of the timeout (TO) parameter is system specific -
//        we use a macro to convert to ticks.
//
TDI_STATUS  // Returns: Status of attempt to connect.
TdiConnect(
    PTDI_REQUEST Request,                     // This command request.
    void *TO,                                 // How long to wait for request.
    PTDI_CONNECTION_INFORMATION RequestAddr,  // Describes the destination.
    PTDI_CONNECTION_INFORMATION ReturnAddr)   // Where to return information.
{
    TCPConnReq *ConnReq; // Connection request to use.
    IPv6Addr DestAddr;
    ulong DestScopeId;
    ushort DestPort;
    TCPConn *Conn;
    TCB *NewTCB;
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    KIRQL Irql0, Irql1, Irql2;  // One per lock nesting level.
    AddrObj *AO;
    TDI_STATUS Status;
    IP_STATUS IPStatus;
    TCP_TIME *Timeout;
    NetTableEntry *NTE;
    NetTableEntryOrInterface *NTEorIF;

    //
    // First, get and validate the remote address.
    //
    if (RequestAddr == NULL || RequestAddr->RemoteAddress == NULL ||
        !GetAddress((PTRANSPORT_ADDRESS)RequestAddr->RemoteAddress, &DestAddr,
                    &DestScopeId, &DestPort))
        return TDI_BAD_ADDR;

    //
    // REVIEW: IPv4 performed other remote address sanity checks here.
    // REVIEW: E.g., should we check that remote addr isn't multicast?
    //

    //
    // REVIEW: I can't find an RFC which states 0 is not a valid port number.
    //
    if (DestPort == 0)
        return TDI_BAD_ADDR;

    //
    // Get a connection request.  If we can't, bail out now.
    //
    ConnReq = GetConnReq();
    if (ConnReq == NULL)
        return TDI_NO_RESOURCES;

    //
    // Get a TCB, assuming we'll need one.
    //
    NewTCB = AllocTCB();
    if (NewTCB == NULL) {
        // Couldn't get a TCB.
        FreeConnReq(ConnReq);
        return TDI_NO_RESOURCES;
    }

    Timeout = (TCP_TIME *)TO;

    if (Timeout != NULL && !INFINITE_CONN_TO(*Timeout)) {
        ulong Ticks = TCP_TIME_TO_TICKS(*Timeout);

        if (Ticks > MAX_CONN_TO_TICKS)
            Ticks = MAX_CONN_TO_TICKS;
        else
            Ticks++;
        ConnReq->tcr_timeout = (ushort)Ticks;
    } else
        ConnReq->tcr_timeout = 0;

    ConnReq->tcr_flags = 0;
    ConnReq->tcr_conninfo = ReturnAddr;
    ConnReq->tcr_addrinfo = NULL;
    ConnReq->tcr_req.tr_rtn = Request->RequestNotifyObject;
    ConnReq->tcr_req.tr_context = Request->RequestContext;
    NewTCB->tcb_daddr = DestAddr;
    NewTCB->tcb_dscope_id = DestScopeId;
    NewTCB->tcb_dport = DestPort;

    //
    // Now find the real connection.
    //
    KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
    Conn = GetConnFromConnID(ConnID, &Irql1);
    if (Conn != NULL) {
        uint Inserted;

        CHECK_STRUCT(Conn, tc);

        //
        // We found the connection.  Check for an associated address object.
        //
        AO = Conn->tc_ao;
        if (AO != NULL) {
            KeAcquireSpinLock(&AO->ao_lock, &Irql2);

            CHECK_STRUCT(AO, ao);

            Status = InitTCBFromConn(Conn, NewTCB, RequestAddr, TRUE);
            if (Status == TDI_SUCCESS) {
                //
                // We've initialized our TCB.  Mark it that we initiated this
                // connection (i.e. active open).  Also, we're done with the
                // AddrObjTable, so we can free it's lock.
                //
                NewTCB->tcb_flags |= ACTIVE_OPEN;
                KeReleaseSpinLock(&AddrObjTableLock, Irql2);

                //
                // Initialize our routing state validation counter.
                // We need to do this before acquiring an NTE or an RCE
                // (to avoid missing any changes which may occur while
                // we're in the process of acquiring them).
                //
                NewTCB->tcb_routing = RouteCacheValidationCounter;

                //
                // Determine NTE to send on (if user cares).
                //
                if (IsUnspecified(&NewTCB->tcb_saddr)) {
                    //
                    // Caller didn't specify a source address.
                    // Let the routing code pick one.
                    //
                    NTE = NULL;
                    NTEorIF = NULL;

                } else {
                    //
                    // Our TCB has a specific source address.  Determine
                    // which NTE corresponds to it and the scope id.
                    //
                    NTE = FindNetworkWithAddress(&NewTCB->tcb_saddr,
                                                 NewTCB->tcb_sscope_id);
                    if (NTE == NULL) {
                        //
                        // Bad source address.  We don't have a network with
                        // the requested address.  Error out.
                        //
                        // REVIEW: Will the AddrObj code even let this happen?
                        //
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                                   "TdiConnect: Bad source address\n"));
                        KeReleaseSpinLock(&AO->ao_lock, Irql1);
                        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
                        Status = TDI_BAD_ADDR;
                        goto error;
                    }

                    NTEorIF = CastFromNTE(NTE);
                }

                //
                // Get the route.
                //
                ASSERT(NewTCB->tcb_rce == NULL);
                IPStatus = RouteToDestination(&DestAddr, DestScopeId,
                                              NTEorIF, RTD_FLAG_NORMAL,
                                              &NewTCB->tcb_rce);
                if (IPStatus != IP_SUCCESS) {
                    //
                    // Failed to get a route to the destination.  Error out.
                    //
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                               "TdiConnect: Failed to get route to dest.\n"));
                    KeReleaseSpinLock(&AO->ao_lock, Irql1);
                    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
                    if ((IPStatus == IP_PARAMETER_PROBLEM) ||
                        (IPStatus == IP_BAD_ROUTE))
                        Status = TDI_BAD_ADDR;
                    else if (IPStatus == IP_NO_RESOURCES)
                        Status = TDI_NO_RESOURCES;
                    else
                        Status = TDI_DEST_UNREACHABLE;
                    goto error;
                }

                ASSERT(NewTCB->tcb_rce != NULL);
                if (IsDisconnectedAndNotLoopbackRCE(NewTCB->tcb_rce)) {
                    //
                    // Fail new connection requests for TCBs with a
                    // disconnected outgoing interface, except when a
                    // loopback route is used.
                    //
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                               "TdiConnect: Interface disconnected.\n"));
                    KeReleaseSpinLock(&AO->ao_lock, Irql1);
                    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);

                    //
                    // Drop the reference on the route we obtained.
                    //
                    ReleaseRCE(NewTCB->tcb_rce);

                    Status = TDI_DEST_NET_UNREACH;
                    goto error;
                }

                //
                // OK, we got a route.  Enter the TCB into the connection
                // and send a SYN.
                //
                KeAcquireSpinLock(&NewTCB->tcb_lock, &Irql2);
                Conn->tc_tcb = NewTCB;
                Conn->tc_refcnt++;
                NewTCB->tcb_conn = Conn;
                NewTCB->tcb_connid = Conn->tc_connid;
                REMOVEQ(&Conn->tc_q);
                ENQUEUE(&AO->ao_activeq, &Conn->tc_q);
                KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql2);
                KeReleaseSpinLock(&AO->ao_lock, Irql1);

                //
                // Initialize path-specific TCB settings, based on the RCE:
                //
                // If packets on the path will be looped back in software,
                // don't use the Nagle algorithm for this TCB.
                //
                if (IsLoopbackRCE(NewTCB->tcb_rce)) {
                    NewTCB->tcb_flags &= ~NAGLING;
                }

                //
                // Keep a reference for the NTE we're using.
                // This prevents the NTE from going away should we release
                // our RCE, and also makes for easy comparisons.
                //
                if (NTE == NULL) {
                    //
                    // We let the routing code pick the source NTE above.
                    // Remember this NTE and address for later use.
                    //
                    NewTCB->tcb_nte = NewTCB->tcb_rce->NTE;
                    AddRefNTE(NewTCB->tcb_nte);
                    NewTCB->tcb_saddr = NewTCB->tcb_nte->Address;
                    NewTCB->tcb_sscope_id =
                        DetermineScopeId(&NewTCB->tcb_saddr,
                                         NewTCB->tcb_nte->IF);
                } else {
                    //
                    // Remember the NTE we found above.
                    // We already hold a reference on it.
                    //
                    NewTCB->tcb_nte = NTE;
                }

                //
                // Similarly, the routing code may have picked
                // the destination scope id if it was left unspecified.
                // REVIEW - getpeername will not return the new DestScopeId.
                //
                DestScopeId = DetermineScopeId(&NewTCB->tcb_daddr,
                                               NewTCB->tcb_rce->NTE->IF);
                ASSERT((NewTCB->tcb_dscope_id == DestScopeId) ||
                       (NewTCB->tcb_dscope_id == 0));
                NewTCB->tcb_dscope_id = DestScopeId;

                //
                // Initialize our Maximum Segment Size (MSS).
                // Cache our current Path Maximum Transmission Unit (PMTU)
                // so that we'll know if it changes.
                //
                NewTCB->tcb_pmtu = GetEffectivePathMTUFromRCE(NewTCB->tcb_rce);
                IF_TCPDBG(TCP_DEBUG_MSS) {
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                               "TCP TdiConnect: PMTU from RCE is %d\n",
                               NewTCB->tcb_pmtu));
                }
                NewTCB->tcb_remmss = MAXUSHORT;
                NewTCB->tcb_security = SecurityStateValidationCounter;
                CalculateMSSForTCB(NewTCB);

                // Now initialize our send state.
                InitSendState(NewTCB);
                NewTCB->tcb_refcnt = 1;
                NewTCB->tcb_state = TCB_SYN_SENT;
                TStats.ts_activeopens++;

                // Need to put the ConnReq on the TCB now, in case the timer
                // fires after we've inserted.
                NewTCB->tcb_connreq = ConnReq;
                KeReleaseSpinLock(&NewTCB->tcb_lock, Irql0);

                Inserted = InsertTCB(NewTCB);
                KeAcquireSpinLock(&NewTCB->tcb_lock, &Irql0);

                if (!Inserted) {
                    // Insert failed.  We must already have a connection. Pull
                    // the connreq from the TCB first, so we can return the
                    // correct error code for it.
                    NewTCB->tcb_connreq = NULL;
                    TryToCloseTCB(NewTCB, TCB_CLOSE_ABORTED, Irql0);
                    KeAcquireSpinLock(&NewTCB->tcb_lock, &Irql0);
                    DerefTCB(NewTCB, Irql0);
                    FreeConnReq(ConnReq);
                    return TDI_ADDR_IN_USE;
                }

                // If it's closing somehow, stop now. It can't have gone to
                // closed, as we hold a reference on it. It could have gone
                // to some other state (for example SYN-RCVD) so we need to
                // check that now too.
                if (!CLOSING(NewTCB) && NewTCB->tcb_state == TCB_SYN_SENT) {
                    SendSYN(NewTCB, Irql0);
                    KeAcquireSpinLock(&NewTCB->tcb_lock, &Irql0);
                }
                DerefTCB(NewTCB, Irql0);

                return TDI_PENDING;
            } else
                KeReleaseSpinLock(&AO->ao_lock, Irql2);
        } else
            Status = TDI_NOT_ASSOCIATED;
        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);
    } else
        Status = TDI_INVALID_CONNECTION;

    KeReleaseSpinLock(&AddrObjTableLock, Irql0);
error:
    if (NTE != NULL)
        ReleaseNTE(NTE);
    FreeTCB(NewTCB);
    FreeConnReq(ConnReq);
    return Status;
}


//* TdiListen - Listen for a connection.
//
//  The TDI listen handling routine. Called when the client wants to
//  post a listen, we validate his incoming parameters, allocate a TCB
//  and return.
//
TDI_STATUS  // Returns: Status of attempt to connect.
TdiListen(
    PTDI_REQUEST Request,                        // Structure for this request.
    ushort Flags,                                // Listen flags for listen.
    PTDI_CONNECTION_INFORMATION AcceptableAddr,  // Acceptable remote addrs.
    PTDI_CONNECTION_INFORMATION ConnectedAddr)   // Where to return conn addr.
{
    TCPConnReq *ConnReq;  // Connection request to use.
    IPv6Addr RemoteAddr;  // Remote address to take conn. from.
    ulong RemoteScopeId;  // Scope identifier for remote addr (0 is none).
    ushort RemotePort;    // Acceptable remote port.
    TCPConn *Conn;        // Pointer to the Connection being listened upon.
    TCB *NewTCB;          // Pointer to the new TCB we'll use.
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    KIRQL OldIrql;        // Save IRQL value prior to taking lock.
    TDI_STATUS Status;

    //
    // If we've been given remote addressing criteria, check it out.
    //
    if (AcceptableAddr != NULL && AcceptableAddr->RemoteAddress != NULL) {
        if (!GetAddress((PTRANSPORT_ADDRESS)AcceptableAddr->RemoteAddress,
                        &RemoteAddr, &RemoteScopeId, &RemotePort))
            return TDI_BAD_ADDR;

        //
        // REVIEW: IPv4 version did some other address sanity checks here.
        // REVIEW: E.g., should we check that remote addr isn't multicast?
        //

    } else {
        RemoteAddr = UnspecifiedAddr;
        RemoteScopeId = 0;
        RemotePort = 0;
    }

    //
    // The remote address is valid.  Get a ConnReq, and maybe a TCB.
    //
    ConnReq = GetConnReq();
    if (ConnReq == NULL)
        return TDI_NO_RESOURCES;  // Couldn't get one.

    //
    // Now try to get a TCB.
    //
    NewTCB = AllocTCB();
    if (NewTCB == NULL) {
        //
        // Couldn't get a TCB.  Return an error.
        //
        FreeConnReq(ConnReq);
        return TDI_NO_RESOURCES;
    }

    //
    // We have the resources we need.  Initialize them, and then check the
    // state of the connection.
    //
    ConnReq->tcr_flags = Flags;
    ConnReq->tcr_conninfo = ConnectedAddr;
    ConnReq->tcr_addrinfo = NULL;
    ConnReq->tcr_req.tr_rtn = Request->RequestNotifyObject;
    ConnReq->tcr_req.tr_context = Request->RequestContext;
    NewTCB->tcb_connreq = ConnReq;
    NewTCB->tcb_daddr = RemoteAddr;
    NewTCB->tcb_dscope_id = RemoteScopeId;
    NewTCB->tcb_dport = RemotePort;
    NewTCB->tcb_state = TCB_LISTEN;

    //
    // Now find the real connection.  If we find it, we'll make sure it's
    // associated.
    //
    Conn = GetConnFromConnID(ConnID, &OldIrql);
    if (Conn != NULL) {
        AddrObj *ConnAO;

        CHECK_STRUCT(Conn, tc);
        //
        // We have a connection.  Make sure it's associated with an address and
        // doesn't already have a TCB attached.
        //
        ConnAO = Conn->tc_ao;

        if (ConnAO != NULL) {
            CHECK_STRUCT(ConnAO, ao);
            KeAcquireSpinLockAtDpcLevel(&ConnAO->ao_lock);

            if (AO_VALID(ConnAO)) {
                Status = InitTCBFromConn(Conn, NewTCB, AcceptableAddr, TRUE);
            } else {
                Status = TDI_ADDR_INVALID;
            }

            if (Status == TDI_SUCCESS) {
                //
                // The initialization worked.  Assign the new TCB to the
                // connection, and return.
                //
                REMOVEQ(&Conn->tc_q);
                PUSHQ(&ConnAO->ao_listenq, &Conn->tc_q);

                Conn->tc_tcb = NewTCB;
                NewTCB->tcb_conn = Conn;
                NewTCB->tcb_connid = Conn->tc_connid;
                Conn->tc_refcnt++;

                ConnAO->ao_listencnt++;
                KeReleaseSpinLockFromDpcLevel(&ConnAO->ao_lock);

                Status = TDI_PENDING;
            } else {
                FreeTCB(NewTCB);
                KeReleaseSpinLockFromDpcLevel(&ConnAO->ao_lock);
            }
        } else {
            FreeTCB(NewTCB);
            Status = TDI_NOT_ASSOCIATED;
        }
        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, OldIrql);
    } else {
        FreeTCB(NewTCB);
        Status = TDI_INVALID_CONNECTION;
    }

    //
    // We're all done.
    //
    if (Status != TDI_PENDING) {
        FreeConnReq(ConnReq);
    }
    return Status;
}


//* InitRCE - Initialize an RCE.
//
//  A utility routine to open an RCE and determine the maximum segment size
//  for a connection.  This function is called with the TCB lock held
//  when transitioning out of the SYN_SENT or LISTEN states.
//
void              // Returns: Nothing.
InitRCE(
    TCB *NewTCB)  // TCB for which an RCE is to be opened.
{
    IP_STATUS Status;

    //
    // We are called when receiving an incoming connection attempt,
    // so tcb_saddr will always be initialized.
    //
    ASSERT(! IsUnspecified(&NewTCB->tcb_saddr));

    //
    // If we don't already have an NTE for this connection, get one now.
    //
    if (NewTCB->tcb_nte == NULL) {
        //
        // Initialize our routing state validation counter.
        // We need to do this before acquiring an NTE or an RCE
        // (to avoid missing any changes which may occur while
        // we're in the process of acquiring them).
        //
        NewTCB->tcb_routing = RouteCacheValidationCounter;

        NewTCB->tcb_nte = FindNetworkWithAddress(&NewTCB->tcb_saddr,
                                                 NewTCB->tcb_sscope_id);
        if (NewTCB->tcb_nte == NULL) {
            //
            // Failed to get an NTE corresponding to this source address.
            //
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                       "TCP InitRCE: Can't find the NTE for address?!?\n"));
            goto ErrorReturn;
        }
    }

    //
    // Get the route.
    //
    ASSERT(NewTCB->tcb_rce == NULL);
    Status = RouteToDestination(&NewTCB->tcb_daddr, NewTCB->tcb_dscope_id,
                                CastFromNTE(NewTCB->tcb_nte), RTD_FLAG_NORMAL,
                                &NewTCB->tcb_rce);
    if (Status != IP_SUCCESS) {
        //
        // Failed to get a route to the destination.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "TCP InitRCE: Can't get a route?!?\n"));
      ErrorReturn:
        //
        // Until we have a real route, use conservative values.
        //
        NewTCB->tcb_pmtu = IPv6_MINIMUM_MTU;
        NewTCB->tcb_mss = (ushort)MIN(DEFAULT_MSS, NewTCB->tcb_remmss);
        return;
    }

    //
    // Initialize path-specific TCB settings, based on the RCE:
    //
    // If packets on the path will be looped back in software,
    // don't use the Nagle algorithm for this TCB.
    //
    if (IsLoopbackRCE(NewTCB->tcb_rce)) {
        NewTCB->tcb_flags &= ~NAGLING;
    }

    //
    // Initialize the maximum segement size (MSS) for this connection.
    // Cache our current Path Maximum Transmission Unit (PMTU)
    // so that we'll know if it changes.
    //
    NewTCB->tcb_pmtu = GetEffectivePathMTUFromRCE(NewTCB->tcb_rce);
    IF_TCPDBG(TCP_DEBUG_MSS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "TCP InitRCE: PMTU from RCE is %d\n", NewTCB->tcb_pmtu));
    }
    NewTCB->tcb_security = SecurityStateValidationCounter;
    CalculateMSSForTCB(NewTCB);
}


//* AcceptConn - Accept a connection on a TCB.
//
//  Called to accept a connection on a TCB, either from an incoming
//  receive segment or via a user's accept.  We initialize the RCE
//  and the send state, and send out a SYN.  We assume the TCB is locked
//  and referenced when we get it.
//
void                       // Returns: Nothing.
AcceptConn(
    TCB *AcceptTCB,        // TCB to accept on.
    KIRQL PreLockIrql)     // IRQL prior to acquiring TCB lock.
{
    CHECK_STRUCT(AcceptTCB, tcb);
    ASSERT(AcceptTCB->tcb_refcnt != 0);

    InitRCE(AcceptTCB);
    InitSendState(AcceptTCB);

    AdjustRcvWin(AcceptTCB);
    SendSYN(AcceptTCB, PreLockIrql);

    KeAcquireSpinLock(&AcceptTCB->tcb_lock, &PreLockIrql);
    DerefTCB(AcceptTCB, PreLockIrql);
}


//* TdiAccept - Accept a connection.
//
//  The TDI accept routine. Called when the client wants to
//  accept a connection for which a listen had previously completed. We
//  examine the state of the connection - it has to be in SYN-RCVD, with
//  a TCB, with no pending connreq, etc.
//
TDI_STATUS  // Returns: Status of attempt to connect.
TdiAccept(
    PTDI_REQUEST Request,                       // Structure for this request.
    PTDI_CONNECTION_INFORMATION AcceptInfo,     // Info for this accept.
    PTDI_CONNECTION_INFORMATION ConnectedInfo)  // Where to return conn addr.
{
    TCPConnReq *ConnReq;  // ConnReq we'll use for this connection.
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    TCPConn *Conn;        // Connection being accepted upon.
    TCB *AcceptTCB;       // TCB for Conn.
    KIRQL Irql0, Irql1;   // One per lock nesting level.
    TDI_STATUS Status;

    //
    // First, get the ConnReq we'll need.
    //
    ConnReq = GetConnReq();
    if (ConnReq == NULL)
        return TDI_NO_RESOURCES;

    ConnReq->tcr_conninfo = ConnectedInfo;
    ConnReq->tcr_addrinfo = NULL;
    ConnReq->tcr_req.tr_rtn = Request->RequestNotifyObject;
    ConnReq->tcr_req.tr_context = Request->RequestContext;

    //
    // Now look up the connection.
    //
    Conn = GetConnFromConnID(ConnID, &Irql0);
    if (Conn != NULL) {
        CHECK_STRUCT(Conn, tc);

        //
        // We have the connection.  Make sure is has a TCB, and that the
        // TCB is in the SYN-RCVD state, etc.
        //
        AcceptTCB = Conn->tc_tcb;

        if (AcceptTCB != NULL) {
            CHECK_STRUCT(AcceptTCB, tcb);

            KeAcquireSpinLock(&AcceptTCB->tcb_lock, &Irql1);
            KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);

            if (!CLOSING(AcceptTCB) && AcceptTCB->tcb_state == TCB_SYN_RCVD) {
                //
                // State is valid.  Make sure this TCB had a delayed accept on
                // it, and that there is currently no connect request pending.
                //
                if (!(AcceptTCB->tcb_flags & CONN_ACCEPTED) &&
                    AcceptTCB->tcb_connreq == NULL) {

                    AcceptTCB->tcb_connreq = ConnReq;
                    AcceptTCB->tcb_flags |= CONN_ACCEPTED;
                    AcceptTCB->tcb_refcnt++;
                    //
                    // Everything's set.  Accept the connection now.
                    //
                    AcceptConn(AcceptTCB, Irql0);
                    return TDI_PENDING;
                }
            }

            KeReleaseSpinLock(&AcceptTCB->tcb_lock, Irql0);
            Status = TDI_INVALID_CONNECTION;
            goto error;
        }
        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
    }
    Status = TDI_INVALID_CONNECTION;

error:
    FreeConnReq(ConnReq);
    return Status;
}


//* TdiDisConnect - Disconnect a connection.
//
//  The TDI disconnection routine. Called when the client wants to disconnect
//  a connection. There are two types of disconnection we support, graceful
//  and abortive. A graceful close will cause us to send a FIN and not complete
//  the request until we get the ACK back. An abortive close causes us to send
//  a RST. In that case we'll just get things going and return immediately.
//
//  Note: The format of the Timeout (TO) is system specific - we use
//        a macro to convert to ticks.
//
TDI_STATUS  // Returns: Status of attempt to disconnect.
TdiDisconnect(
    PTDI_REQUEST Request,                      // Structure for this request.
    void *TO,                                  // How long to wait.
    ushort Flags,                              // Type of disconnect.
    PTDI_CONNECTION_INFORMATION DiscConnInfo,  // Ignored.
    PTDI_CONNECTION_INFORMATION ReturnInfo,    // Ignored.
    TCPAbortReq *AbortReq)                     // Space for pending abort.
{
    TCPConnReq *ConnReq;  // Connection request to use.
    TCPConn *Conn;
    TCB *DiscTCB;
    KIRQL Irql0, Irql1;  // One per lock nesting level.
    TDI_STATUS Status;
    TCP_TIME *Timeout;

    UNREFERENCED_PARAMETER(DiscConnInfo);
    UNREFERENCED_PARAMETER(ReturnInfo);

    Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext),
                             &Irql0);

    if (Conn != NULL) {
        CHECK_STRUCT(Conn, tc);

        DiscTCB = Conn->tc_tcb;
        if (DiscTCB != NULL) {
            CHECK_STRUCT(DiscTCB, tcb);
            KeAcquireSpinLock(&DiscTCB->tcb_lock, &Irql1);

            //
            // We have the TCB.  See what kind of disconnect this is.
            //
            if (Flags & TDI_DISCONNECT_ABORT) {
                //
                // This is an abortive disconnect.  If we're not already
                // closed or closing, blow the connection away.
                //
                if (DiscTCB->tcb_state != TCB_CLOSED) {
                    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);

                    if (AbortReq != NULL) {
                        if (DiscTCB->tcb_abortreq == NULL) {
                            AbortReq->tar_rtn = Request->RequestNotifyObject;
                            AbortReq->tar_context = Request->RequestContext;
                            DiscTCB->tcb_abortreq = AbortReq;
                            Status = TDI_PENDING;
                        } else {
                            Status = TDI_SUCCESS;
                        }
                    } else {
                        Status = TDI_SUCCESS;
                    }

                    if (!CLOSING(DiscTCB)) {
                        DiscTCB->tcb_flags |= NEED_RST;
                        TryToCloseTCB(DiscTCB, TCB_CLOSE_ABORTED,
                            Irql0);
                    } else
                        KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);

                    return Status;
                } else {
                    //
                    // The TCB isn't connected.
                    //
                    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);
                    KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);
                    return TDI_INVALID_STATE;
                }
            } else {
                //
                // This is not an abortive close.  For graceful close we'll
                // need a ConnReq.
                //
                KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);

                //
                // Make sure we aren't in the middle of an abortive close.
                //
                if (CLOSING(DiscTCB)) {
                    KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);
                    return TDI_INVALID_CONNECTION;
                }

                ConnReq = GetConnReq();
                if (ConnReq != NULL) {
                    //
                    // Got the ConnReq.  See if this is a DISCONNECT_WAIT
                    // primitive or not.
                    //
                    ConnReq->tcr_flags = 0;
                    ConnReq->tcr_conninfo = NULL;
                    ConnReq->tcr_addrinfo = NULL;
                    ConnReq->tcr_req.tr_rtn = Request->RequestNotifyObject;
                    ConnReq->tcr_req.tr_context = Request->RequestContext;

                    if (!(Flags & TDI_DISCONNECT_WAIT)) {
                        Timeout = (TCP_TIME *)TO;

                        if (Timeout != NULL && !INFINITE_CONN_TO(*Timeout)) {
                            ulong   Ticks = TCP_TIME_TO_TICKS(*Timeout);
                            if (Ticks > MAX_CONN_TO_TICKS)
                                Ticks = MAX_CONN_TO_TICKS;
                            else
                                Ticks++;
                            ConnReq->tcr_timeout = (ushort)Ticks;
                        } else
                            ConnReq->tcr_timeout = 0;

                        //
                        // OK, we're just about set.  We need to update
                        // the TCB state, and send the FIN.
                        //
                        if (DiscTCB->tcb_state == TCB_ESTAB) {
                            DiscTCB->tcb_state = TCB_FIN_WAIT1;
                            //
                            // Since we left established, we're off the fast
                            // receive path.
                            //
                            DiscTCB->tcb_slowcount++;
                            DiscTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                        } else
                            if (DiscTCB->tcb_state == TCB_CLOSE_WAIT)
                                DiscTCB->tcb_state = TCB_LAST_ACK;
                            else {
                                KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);
                                FreeConnReq(ConnReq);
                                return TDI_INVALID_STATE;
                            }

                        // Update SNMP info.
                        InterlockedDecrement((PLONG)&TStats.ts_currestab);
                        ASSERT(*(int *)&TStats.ts_currestab >= 0);

                        ASSERT(DiscTCB->tcb_connreq == NULL);
                        DiscTCB->tcb_connreq = ConnReq;
                        DiscTCB->tcb_flags |= FIN_NEEDED;
                        DiscTCB->tcb_refcnt++;
                        TCPSend(DiscTCB, Irql0);

                        return TDI_PENDING;
                    } else {
                        //
                        // This is a DISC_WAIT request.
                        //
                        ConnReq->tcr_timeout = 0;
                        if (DiscTCB->tcb_discwait == NULL) {
                            DiscTCB->tcb_discwait = ConnReq;
                            Status = TDI_PENDING;
                        } else {
                            FreeConnReq(ConnReq);
                            Status = TDI_INVALID_STATE;
                        }

                        KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);
                        return Status;
                    }
                } else {
                    //
                    // Couldn't get a ConnReq.
                    //
                    KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);
                    return TDI_NO_RESOURCES;
                }
            }
        } else
            KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
    }

    //
    // No Conn, or no TCB on conn.  Return an error.
    //
    return TDI_INVALID_CONNECTION;
}


//* OKToNotify - See if it's OK to notify about a DISC.
//
//  A little utility function, called to see it it's OK to notify the client
//  of an incoming FIN.
//
uint                 // Returns: TRUE if it's OK, False otherwise.
OKToNotify(
    TCB *NotifyTCB)  // TCB to check.
{
    CHECK_STRUCT(NotifyTCB, tcb);
    if (NotifyTCB->tcb_pendingcnt == 0 && NotifyTCB->tcb_urgcnt == 0 &&
        NotifyTCB->tcb_rcvhead == NULL && NotifyTCB->tcb_exprcv == NULL)
        return TRUE;
    else
        return FALSE;
}


//* NotifyOfDisc - Notify a client that a TCB is being disconnected.
//
//  Called when we're disconnecting a TCB because we've received a FIN or
//  RST from the remote peer, or because we're aborting for some reason.
//  We'll complete a DISCONNECT_WAIT request if we have one, or try and
//  issue an indication otherwise.  This is only done if we're in a
//  synchronized state and not in TIMED-WAIT.
//
//  May be called with TCB lock held.  Or not.
//
void  // Returns: Nothing.
NotifyOfDisc(
    TCB *DiscTCB,         // TCB we're notifying.
    TDI_STATUS Status,    // Status code for notification.
    PKIRQL IrqlPtr)       // Indicates TCB is locked with given IRQL.
{
    KIRQL Irql0, Irql1;
    TCPConnReq *DiscReq;
    TCPConn *Conn;
    AddrObj *DiscAO;
    PVOID ConnContext;

    CHECK_STRUCT(DiscTCB, tcb);
    ASSERT(DiscTCB->tcb_refcnt != 0);

    //
    // See if we already hold the TCB lock, grab it if not.
    //
    if (IrqlPtr != NULL) {
        Irql0 = *IrqlPtr;
    } else {
        KeAcquireSpinLock(&DiscTCB->tcb_lock, &Irql0);
    }

    if (SYNC_STATE(DiscTCB->tcb_state) &&
        !(DiscTCB->tcb_flags & DISC_NOTIFIED)) {

        //
        // We can't notify him if there's still data to be taken.
        //
        if (Status == TDI_GRACEFUL_DISC) {
            if (!OKToNotify(DiscTCB)) {
                DiscTCB->tcb_flags |= DISC_PENDING;
                KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);
                return;
            }
            if (DiscTCB->tcb_pending & RST_PENDING) {
                KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);
                return;
            }
        } else {
            if (DiscTCB->tcb_flags & (IN_RCV_IND | IN_DELIV_URG)) {
                DiscTCB->tcb_pending |= RST_PENDING;
                KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);
                return;
            }
            DiscTCB->tcb_pending &= ~RST_PENDING;
        }

        DiscTCB->tcb_flags |= DISC_NOTIFIED;
        DiscTCB->tcb_flags &= ~DISC_PENDING;

        //
        // We're in a state where a disconnect is meaningful, and we haven't
        // already notified the client.
        // See if we have a DISC-WAIT request pending.
        //
        if ((DiscReq = DiscTCB->tcb_discwait) != NULL) {
            //
            // We have a disconnect wait request.  Complete it and we're done.
            //
            DiscTCB->tcb_discwait = NULL;
            KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);
            (*DiscReq->tcr_req.tr_rtn)(DiscReq->tcr_req.tr_context, Status, 0);
            FreeConnReq(DiscReq);
            return;
        }

        //
        // No DISC-WAIT.  Find the AddrObj for the connection, and see if
        // there is a disconnect handler registered.
        //
        ConnContext = DiscTCB->tcb_conncontext;
        KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);

        KeAcquireSpinLock(&AddrObjTableLock, &Irql0);
        if ((Conn = DiscTCB->tcb_conn) != NULL) {
            CHECK_STRUCT(Conn, tc);
            KeAcquireSpinLock(&Conn->tc_ConnBlock->cb_lock, &Irql1);

            DiscAO = Conn->tc_ao;
            if (DiscAO != NULL) {
                KIRQL Irql2;
                PDisconnectEvent DiscEvent;
                PVOID DiscContext;

                CHECK_STRUCT(DiscAO, ao);
                KeAcquireSpinLock(&DiscAO->ao_lock, &Irql2);
                KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql2);
                KeReleaseSpinLock(&AddrObjTableLock, Irql1);

                DiscEvent = DiscAO->ao_disconnect;
                DiscContext = DiscAO->ao_disconncontext;

                if (DiscEvent != NULL) {

                    REF_AO(DiscAO);
                    KeReleaseSpinLock(&DiscAO->ao_lock, Irql0);

                    IF_TCPDBG(TCP_DEBUG_CLOSE) {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                                   "TCP: indicating %s disconnect\n",
                                   (Status == TDI_GRACEFUL_DISC) ?
                                   "graceful" : "abortive"));
                    }

                    (*DiscEvent)(DiscContext, ConnContext, 0, NULL, 0,
                                 NULL, (Status == TDI_GRACEFUL_DISC) ?
                                 TDI_DISCONNECT_RELEASE :
                                 TDI_DISCONNECT_ABORT);

                    DELAY_DEREF_AO(DiscAO);
                    return;
                } else {
                    KeReleaseSpinLock(&DiscAO->ao_lock, Irql0);
                    return;
                }
            }
            KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);
        }

        KeReleaseSpinLock(&AddrObjTableLock, Irql0);
        return;

    }
    KeReleaseSpinLock(&DiscTCB->tcb_lock, Irql0);
}


//* GracefulClose - Complete the transition to a gracefully closed state.
//
//  Called when we need to complete the transition to a gracefully closed
//  state, either TIME_WAIT or CLOSED.  This completion involves removing
//  the TCB from it's associated connection (if it has one), notifying the
//  upper layer client either via completing a request or calling a disc.
//  notification handler, and actually doing the transition.
//
//  The tricky part here is if we need to notify him (instead of completing
//  a graceful disconnect request).  We can't notify him if there is pending
//  data on the connection, so in that case we have to pend the disconnect
//  notification until we deliver the data.
//
void                       // Returns: Nothing.
GracefulClose(
    TCB *CloseTCB,         // TCB to transition.
    uint ToTimeWait,       // TRUE if we're going to TIME_WAIT, FALSE if
                           // we're going to close the TCB.
    uint Notify,           // TRUE if via notification, FALSE if via completing
                           // a disconnect request.
    KIRQL PreLockIrql)     // IRQL prior to acquiring TCB lock.
{

    CHECK_STRUCT(CloseTCB, tcb);
    ASSERT(CloseTCB->tcb_refcnt != 0);

    //
    // First, see if we need to notify the client of a FIN.
    //
    if (Notify) {
        //
        // We do need to notify him.  See if it's OK to do so.
        //
        if (OKToNotify(CloseTCB)) {
            //
            // We can notify him.  Change his state, pull him from the conn.,
            // and notify him.
            //
            if (ToTimeWait) {
                //
                // Save the time we went into time wait, in case we need to
                // scavenge.
                //
                CloseTCB->tcb_alive = SystemUpTime();
                CloseTCB->tcb_state = TCB_TIME_WAIT;
                KeReleaseSpinLock(&CloseTCB->tcb_lock, PreLockIrql);
            } else {
                //
                // He's going to close.  Mark him as closing with TryToCloseTCB
                // (he won't actually close since we have a ref. on him).  We
                // do this so that anyone touching him after we free the
                // lock will fail.
                //
                TryToCloseTCB(CloseTCB, TDI_SUCCESS, PreLockIrql);
            }

            RemoveTCBFromConn(CloseTCB);
            NotifyOfDisc(CloseTCB, TDI_GRACEFUL_DISC, NULL);

        } else {
            //
            // Can't notify him now.  Set the appropriate flags, and return.
            //
            CloseTCB->tcb_flags |= (GC_PENDING |
                                    (ToTimeWait ? TW_PENDING : 0));
            DerefTCB(CloseTCB, PreLockIrql);
            return;
        }
    } else {
        //
        // We're not notifying this guy, we just need to complete a conn. req.
        // We need to check and see if he's been notified, and if not
        // we'll complete the request and notify him later.
        //
        if (CloseTCB->tcb_flags & DISC_NOTIFIED) {
            //
            // He's been notified.
            //
            if (ToTimeWait) {
                //
                // Save the time we went into time wait, in case we need to
                // scavenge.
                //
                CloseTCB->tcb_alive = SystemUpTime();
                CloseTCB->tcb_state = TCB_TIME_WAIT;
                KeReleaseSpinLock(&CloseTCB->tcb_lock, PreLockIrql);
            } else {
                //
                // Mark him as closed.  See comments above.
                //
                TryToCloseTCB(CloseTCB, TDI_SUCCESS, PreLockIrql);
            }

            RemoveTCBFromConn(CloseTCB);

            KeAcquireSpinLock(&CloseTCB->tcb_lock, &PreLockIrql);
            CompleteConnReq(CloseTCB, TDI_SUCCESS);
            KeReleaseSpinLock(&CloseTCB->tcb_lock, PreLockIrql);
        } else {
            //
            // He hasn't been notified. He should be pending already.
            //
            ASSERT(CloseTCB->tcb_flags & DISC_PENDING);
            CloseTCB->tcb_flags |= (GC_PENDING |
                                    (ToTimeWait ? TW_PENDING : 0));

            CompleteConnReq(CloseTCB, TDI_SUCCESS);

            DerefTCB(CloseTCB, PreLockIrql);
            return;
        }
    }

    //
    // If we're going to TIME_WAIT, start the TIME_WAIT timer now.
    // Otherwise close the TCB.
    //
    KeAcquireSpinLock(&CloseTCB->tcb_lock, &PreLockIrql);
    if (!CLOSING(CloseTCB) && ToTimeWait) {
        START_TCB_TIMER(CloseTCB->tcb_rexmittimer, MAX_REXMIT_TO);
        KeReleaseSpinLock(&CloseTCB->tcb_lock, PreLockIrql);
        RemoveConnFromTCB(CloseTCB);
        KeAcquireSpinLock(&CloseTCB->tcb_lock, &PreLockIrql);
    }

    DerefTCB(CloseTCB, PreLockIrql);
}

#if 0  // REVIEW: Unused function?
//* ConnCheckPassed - Check to see if we have exceeded the connect limit.
//
//  Called when a SYN is received to determine whether we will accept
//  the incoming connection.  If there is an empty slot or if the IP address
//  is already in the table, we accept it.
//
int                // Returns: TRUE is connect is accepted, FALSE if rejected.
ConnCheckPassed(
    IPv6Addr *Src,  // Source address of incoming connection.
    ulong Prt)      // Destination port of incoming connection.
{
    UNREFERENCED_PARAMETER(Src);
    UNREFERENCED_PARAMETER(Prt);

    return TRUE;
}
#endif

void InitAddrChecks()
{
    return;
}


//* EnumerateConnectionList - Enumerate Connection List database.
//
//  This routine enumerates the contents of the connection limit database.
//
//  Note: The comments found with this routine upon IPv6 port imply that
//        there may have been code here once that actually did something.
//        What's here now is a no-op.
//
void                          // Returns: Nothing.
EnumerateConnectionList(
    uchar *Buffer,            // Buffer to fill with connection list entries.
    ulong BufferSize,         // Size of Buffer in bytes.
    ulong *EntriesReturned,   // Where to put the number of entries returned.
    ulong *EntriesAvailable)  // Where to return number of avail conn. entries.
{

    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferSize);

    *EntriesAvailable = 0;
    *EntriesReturned = 0;

    return;
}


#pragma BEGIN_INIT

//* InitTCPConn - Initialize TCP connection management code.
//
//  Called during init time to initialize our TCP connection management.
//
int  // Returns: TRUE.
InitTCPConn(
    void)  // Input: Nothing.
{
    ExInitializeSListHead(&ConnReqFree);
    KeInitializeSpinLock(&ConnReqFreeLock);
    KeInitializeSpinLock(&ConnTableLock);
    MaxAllocatedConnBlocks = 0;
    ConnTable = ExAllocatePool(NonPagedPool,
                               MaxConnBlocks * sizeof(TCPConnBlock *));
    if (ConnTable == NULL) {
        return FALSE;
    }

    return TRUE;
}

#pragma END_INIT

//* UnloadTCPConn
//
//  Cleanup and prepare for stack unload.
//
void
UnloadTCPConn(void)
{
    PSLIST_ENTRY BufferLink;
    KIRQL OldIrql;
    TCPConnBlock **OldTable;

    while ((BufferLink = ExInterlockedPopEntrySList(&ConnReqFree,
                                                    &ConnReqFreeLock))
                                                        != NULL) {
        Queue *QueuePtr = CONTAINING_RECORD(BufferLink, Queue, q_next);
        TCPReq *Req = CONTAINING_RECORD(QueuePtr, TCPReq, tr_q);
        TCPConnReq *ConnReq = CONTAINING_RECORD(Req, TCPConnReq, tcr_req);

        CHECK_STRUCT(ConnReq, tcr);
        ExFreePool(ConnReq);
    }

    KeAcquireSpinLock(&ConnTableLock, &OldIrql);
    OldTable = ConnTable;
    ConnTable = NULL;
    KeReleaseSpinLock(&ConnTableLock, OldIrql);

    if (OldTable != NULL) {
        uint i;
        for (i = 0; i < MaxAllocatedConnBlocks; i++) {
            ExFreePool(OldTable[i]);
        }
        ExFreePool(OldTable);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\tcp\tcpdeliv.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// TCP deliver data code.
//
// This file contains the code for delivering data to the user, including
// putting data into recv. buffers and calling indication handlers.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcprcv.h"
#include "tcpsend.h"
#include "tcpconn.h"
#include "tcpdeliv.h"
#include "route.h"

extern KSPIN_LOCK AddrObjTableLock;

extern uint
PutOnRAQ(TCB *RcvTCB, TCPRcvInfo *RcvInfo, IPv6Packet *Packet, uint Size);

extern IPv6Packet *
TrimPacket(IPv6Packet *Packet, uint AmountToTrim);

SLIST_HEADER TCPRcvReqFree;       // Rcv req. free list.

KSPIN_LOCK TCPRcvReqFreeLock;  // Protects rcv req free list.

uint NumTCPRcvReq = 0;        // Current number of RcvReqs in system.
uint MaxRcvReq = 0xffffffff;  // Maximum allowed number of SendReqs.

NTSTATUS TCPPrepareIrpForCancel(PTCP_CONTEXT TcpContext, PIRP Irp,
                                PDRIVER_CANCEL CancelRoutine);
ULONG TCPGetMdlChainByteCount(PMDL Mdl);
void TCPDataRequestComplete(void *Context, unsigned int Status,
                            unsigned int ByteCount);
VOID TCPCancelRequest(PDEVICE_OBJECT Device, PIRP Irp);
VOID CompleteRcvs(TCB *CmpltTCB);


//* FreeRcvReq - Free a rcv request structure.
//
//  Called to free a rcv request structure.
//
void                      // Returns: Nothing.
FreeRcvReq(
    TCPRcvReq *FreedReq)  // Rcv request structure to be freed.
{
    PSLIST_ENTRY BufferLink;

    CHECK_STRUCT(FreedReq, trr);
    BufferLink = CONTAINING_RECORD(&(FreedReq->trr_next), SLIST_ENTRY,
                                   Next);
    ExInterlockedPushEntrySList(&TCPRcvReqFree, BufferLink,
                                &TCPRcvReqFreeLock);
}

//* GetRcvReq - Get a recv. request structure.
//
//  Called to get a rcv. request structure.
//
TCPRcvReq *  // Returns: Pointer to RcvReq structure, or NULL if none.
GetRcvReq(
    void)    // Nothing.
{
    TCPRcvReq *Temp;

    PSLIST_ENTRY BufferLink;

    BufferLink = ExInterlockedPopEntrySList(&TCPRcvReqFree,
                                            &TCPRcvReqFreeLock);

    if (BufferLink != NULL) {
        Temp = CONTAINING_RECORD(BufferLink, TCPRcvReq, trr_next);
        CHECK_STRUCT(Temp, trr);
    } else {
        if (NumTCPRcvReq < MaxRcvReq)
            Temp = ExAllocatePool(NonPagedPool, sizeof(TCPRcvReq));
        else
            Temp = NULL;

        if (Temp != NULL) {
            ExInterlockedAddUlong((PULONG)&NumTCPRcvReq, 1, &TCPRcvReqFreeLock);
#if DBG
            Temp->trr_sig = trr_signature;
#endif
        }
    }

    return Temp;
}


//* FindLastPacket - Find the last packet in a chain.
//
//  A utility routine to find the last packet in a packet chain.
//
IPv6Packet *             // Returns: Pointer to last packet in chain.
FindLastPacket(
    IPv6Packet *Packet)  // Pointer to packet chain.
{
    ASSERT(Packet != NULL);

    while (Packet->Next != NULL)
        Packet = Packet->Next;

    return Packet;
}


//* CovetPacketChain - Take owership of a chain of IP packets.
//
//  Called to seize ownership of a chain of IP packets.  We copy any
//  packets that are not already owned by us.  We assume that all packets
//  not belonging to us start before those that do, so we quit copying
//  when we reach a packet we own.
//
IPv6Packet *               // Returns: Pointer to new packet chain.
CovetPacketChain(
    IPv6Packet *OrigPkt,   // Packet chain to copy from.
    IPv6Packet **LastPkt,  // Where to return pointer to last packet in chain.
    uint Size)             // Maximum size in bytes to seize.
{
    IPv6Packet *FirstPkt, *EndPkt;
    uint BytesToCopy;

    ASSERT(OrigPkt != NULL);
    ASSERT(Size > 0);

    if (!(OrigPkt->Flags & PACKET_OURS)) {

        BytesToCopy = MIN(Size, OrigPkt->TotalSize);
        FirstPkt = ExAllocatePoolWithTagPriority(NonPagedPool,
                                                 sizeof(IPv6Packet) +
                                                 BytesToCopy, TCP6_TAG,
                                                 LowPoolPriority);
        if (FirstPkt != NULL) {
            EndPkt = FirstPkt;
            FirstPkt->Next = NULL;
            FirstPkt->Position = 0;
            FirstPkt->FlatData = (uchar *)(FirstPkt + 1);
            FirstPkt->Data = FirstPkt->FlatData;
            FirstPkt->ContigSize = BytesToCopy;
            FirstPkt->TotalSize = BytesToCopy;
            FirstPkt->NdisPacket = NULL;
            FirstPkt->AuxList = NULL;
            FirstPkt->Flags = PACKET_OURS;
            CopyPacketToBuffer(FirstPkt->Data, OrigPkt, BytesToCopy,
                               OrigPkt->Position);
            Size -= BytesToCopy;
            OrigPkt = OrigPkt->Next;
            while (OrigPkt != NULL && !(OrigPkt->Flags & PACKET_OURS)
                   && Size != 0) {
                IPv6Packet *NewPkt;

                BytesToCopy = MIN(Size, OrigPkt->TotalSize);
                NewPkt = ExAllocatePoolWithTagPriority(NonPagedPool,
                                                       sizeof(IPv6Packet) +
                                                       BytesToCopy, TCP6_TAG,
                                                       LowPoolPriority);
                if (NewPkt != NULL) {
                    NewPkt->Next = NULL;
                    NewPkt->Position = 0;
                    NewPkt->FlatData = (uchar *)(NewPkt + 1);
                    NewPkt->Data = NewPkt->FlatData;
                    NewPkt->ContigSize = BytesToCopy;
                    NewPkt->TotalSize = BytesToCopy;
                    NewPkt->Flags = PACKET_OURS;
                    NewPkt->NdisPacket = NULL;
                    NewPkt->AuxList = NULL;
                    CopyPacketToBuffer(NewPkt->Data, OrigPkt, BytesToCopy,
                                       OrigPkt->Position);
                    EndPkt->Next = NewPkt;
                    EndPkt = NewPkt;
                    Size -= BytesToCopy;
                    OrigPkt = OrigPkt->Next;
                } else {
                    FreePacketChain(FirstPkt);
                    return NULL;
                }
            }
            EndPkt->Next = OrigPkt;
        } else
            return NULL;
    } else {
        FirstPkt = OrigPkt;
        EndPkt = OrigPkt;
        if (Size < OrigPkt->TotalSize) {
            OrigPkt->TotalSize = Size;
            OrigPkt->ContigSize = Size;
        }
        Size -= OrigPkt->TotalSize;
    }

    //
    // Now walk down the chain, until we  run out of Size.
    // At this point, Size is the bytes left to 'seize' (it may be 0),
    // and the sizes in packets FirstPkt...EndPkt are correct.
    //
    while (Size != 0) {

        EndPkt = EndPkt->Next;
        ASSERT(EndPkt != NULL);

        if (Size < EndPkt->TotalSize) {
            EndPkt->TotalSize = Size;
            EndPkt->ContigSize = Size;
        }

        Size -= EndPkt->TotalSize;
    }

    // If there's anything left in the chain, free it now.
    if (EndPkt->Next != NULL) {
        FreePacketChain(EndPkt->Next);
        EndPkt->Next = NULL;
    }

    *LastPkt = EndPkt;
    return FirstPkt;
}


//* PendData - Pend incoming data to a client.
//
//  Called when we need to buffer data for a client because there's no receive
//  down and we can't indicate.
//
//  The TCB lock is held throughout this procedure. If this is to be changed,
//  make sure consistency of tcb_pendingcnt is preserved. This routine is
//  always called at DPC level.
//
uint                       // Returns: Number of bytes of data taken.
PendData(
    TCB *RcvTCB,           // TCB on which to receive the data.
    uint RcvFlags,         // TCP flags for the incoming packet.
    IPv6Packet *InPacket,  // Input buffer of packet.
    uint Size)             // Size in bytes of data in InPacket.
{
    IPv6Packet *NewPkt, *LastPkt;

    UNREFERENCED_PARAMETER(RcvFlags);

    CHECK_STRUCT(RcvTCB, tcb);
    ASSERT(Size > 0);
    ASSERT(InPacket != NULL);
    ASSERT(RcvTCB->tcb_refcnt != 0);
    ASSERT(RcvTCB->tcb_fastchk & TCP_FLAG_IN_RCV);
    ASSERT(RcvTCB->tcb_currcv == NULL);
    ASSERT(RcvTCB->tcb_rcvhndlr == PendData);

    CheckPacketList(RcvTCB->tcb_pendhead, RcvTCB->tcb_pendingcnt);

    NewPkt = CovetPacketChain(InPacket, &LastPkt, Size);
    if (NewPkt != NULL) {
        //
        // We have a duplicate chain.  Put it on the end of the pending q.
        //
        if (RcvTCB->tcb_pendhead == NULL) {
            RcvTCB->tcb_pendhead = NewPkt;
            RcvTCB->tcb_pendtail = LastPkt;
        } else {
            RcvTCB->tcb_pendtail->Next = NewPkt;
            RcvTCB->tcb_pendtail = LastPkt;
        }
        RcvTCB->tcb_pendingcnt += Size;
    } else {
        FreePacketChain(InPacket);
        Size = 0;
    }

    CheckPacketList(RcvTCB->tcb_pendhead, RcvTCB->tcb_pendingcnt);

    return Size;
}


//* BufferData - Put incoming data into client's buffer.
//
//  Called when we believe we have a buffer into which we can put data. We put
//  it in there, and if we've filled the buffer or the incoming data has the
//  push flag set we'll mark the TCB to return the buffer. Otherwise we'll
//  get out and return the data later.
//
//  In NT, this routine is called with the TCB lock held, and holds it for
//  the duration of the call.  This is important to ensure consistency of
//  the tcb_pendingcnt field.  If we need to change this to free the lock
//  partway through, make sure to take this into account.  In particular,
//  TdiReceive zeros pendingcnt before calling this routine, and this routine
//  may update it.  If the lock is freed in here there would be a window where
//  we really do have pending data, but it's not on the list or reflected in
//  pendingcnt.  This could mess up our windowing computations, and we'd have
//  to be careful not to end up with more data pending than our window allows.
//
uint                       // Returns: Number of bytes of data taken.
BufferData(
    TCB *RcvTCB,           // TCB on which to receive the data.
    uint RcvFlags,         // TCP rcv flags for the incoming packet.
    IPv6Packet *InPacket,  // Input buffer of packet.
    uint Size)             // Size in bytes of data in InPacket.
{
    uchar *DestBase;       // Destination pointer.
    uint DestOffset;       // Destination offset.
    uint SrcSize;          // Size of current source buffer.
    uint DestSize;         // Size of current destination buffer.
    uint Copied;           // Total bytes to copy.
    uint BytesToCopy;      // Bytes of data to copy this time.
    TCPRcvReq *DestReq;    // Current receive request.
    IPv6Packet *SrcPkt;    // Current source packet.
    PNDIS_BUFFER DestBuf;  // Current receive buffer.
    uint RcvCmpltd;
    uint Flags;

    CHECK_STRUCT(RcvTCB, tcb);
    ASSERT(Size > 0);
    ASSERT(InPacket != NULL);
    ASSERT(RcvTCB->tcb_refcnt != 0);
    ASSERT(RcvTCB->tcb_rcvhndlr == BufferData);

    Copied = 0;
    RcvCmpltd = 0;

    DestReq = RcvTCB->tcb_currcv;

    ASSERT(DestReq != NULL);
    CHECK_STRUCT(DestReq, trr);

    DestBuf = DestReq->trr_buffer;

    DestSize = MIN(NdisBufferLength(DestBuf) - DestReq->trr_offset,
                   DestReq->trr_size - DestReq->trr_amt);
    DestBase = (uchar *)NdisBufferVirtualAddressSafe(DestBuf,
                                                     NormalPagePriority);
    DestOffset = DestReq->trr_offset;

    SrcPkt = InPacket;
    SrcSize = SrcPkt->TotalSize;

    Flags = (RcvFlags & TCP_FLAG_PUSH) ? TRR_PUSHED : 0;
    RcvCmpltd = Flags;
    DestReq->trr_flags |= Flags;

    do {

        BytesToCopy = MIN(Size - Copied, MIN(SrcSize, DestSize));
        CopyPacketToFlatOrNdis(DestBuf, DestBase, DestOffset, SrcPkt,
                               BytesToCopy, SrcPkt->Position);
        Copied += BytesToCopy;
        DestReq->trr_amt += BytesToCopy;

        // Update our source pointers.
        if ((SrcSize -= BytesToCopy) == 0) {
            IPv6Packet *TempPkt;

            // We've copied everything in this packet.
            TempPkt = SrcPkt;
            SrcPkt = SrcPkt->Next;
            if (Size != Copied) {
                ASSERT(SrcPkt != NULL);
                SrcSize = SrcPkt->TotalSize;
            }
            TempPkt->Next = NULL;
            FreePacketChain(TempPkt);
        } else {
            if (BytesToCopy < SrcPkt->ContigSize) {
                //
                // We have a contiguous region, easy to skip forward.
                //
                AdjustPacketParams(SrcPkt, BytesToCopy);
            } else {
                //
                // REVIEW: This method isn't very efficient.
                //
                PositionPacketAt(SrcPkt, SrcPkt->Position + BytesToCopy);
            }
        }

        // Now check the destination pointer, and update it if we need to.
        if ((DestSize -= BytesToCopy) == 0) {
            uint DestAvail;

            // Exhausted this buffer. See if there's another one.
            DestAvail = DestReq->trr_size - DestReq->trr_amt;
            DestBuf = NDIS_BUFFER_LINKAGE(DestBuf);

            if (DestBuf != NULL && (DestAvail != 0)) {
                // Have another buffer in the chain. Update things.
                DestSize = MIN(NdisBufferLength(DestBuf), DestAvail);
                DestBase = NdisBufferVirtualAddressSafe(DestBuf,
                                                        NormalPagePriority);
                DestOffset = 0;
            } else {
                // No more buffers in the chain. See if we have another buffer
                // on the list.
                DestReq->trr_flags |= TRR_PUSHED;

                // If we've been told there's to be no back traffic, get an ACK
                // going right away.
                if (DestReq->trr_flags & TDI_RECEIVE_NO_RESPONSE_EXP)
                    DelayAction(RcvTCB, NEED_ACK);

                RcvCmpltd = TRUE;
                DestReq = DestReq->trr_next;
                if (DestReq != NULL) {
                    DestBuf = DestReq->trr_buffer;
                    DestSize = MIN(NdisBufferLength(DestBuf),
                                   DestReq->trr_size);
                    DestBase = NdisBufferVirtualAddressSafe(DestBuf,
                                                            NormalPagePriority);
                    DestOffset = 0;

                    // If we have more to put into here, set the flags.
                    if (Copied != Size)
                        DestReq->trr_flags |= Flags;

                } else {
                    // All out of buffer space. Reset the data handler pointer.
                    break;
                }
            }
        } else {
            // Current buffer not empty yet.
            DestOffset += BytesToCopy;
        }

        // If we've copied all that we need to, we're done.
    } while (Copied != Size);

    //
    // We've finished copying, and have a few more things to do.  We need to
    // update the current rcv. pointer and possibly the offset in the
    // recv. request.  If we need to complete any receives we have to schedule
    // that.  If there's any data we couldn't copy we'll need to dispose of it.
    //
    RcvTCB->tcb_currcv = DestReq;
    if (DestReq != NULL) {
        DestReq->trr_buffer = DestBuf;
        DestReq->trr_offset = DestOffset;
        RcvTCB->tcb_rcvhndlr = BufferData;
    } else
        RcvTCB->tcb_rcvhndlr = PendData;

    RcvTCB->tcb_indicated -= MIN(Copied, RcvTCB->tcb_indicated);

    if (Size != Copied) {
        IPv6Packet *NewPkt, *LastPkt;

        ASSERT(DestReq == NULL);

        // We have data to dispose of.  Update the first buffer of the chain
        // with the current src pointer and size, and copy it.
        ASSERT(SrcSize <= SrcPkt->TotalSize);

        NewPkt = CovetPacketChain(SrcPkt, &LastPkt, Size - Copied);
        if (NewPkt != NULL) {
            // We managed to copy the chain. Push it on the pending queue.
            if (RcvTCB->tcb_pendhead == NULL) {
                RcvTCB->tcb_pendhead = NewPkt;
                RcvTCB->tcb_pendtail = LastPkt;
            } else {
                LastPkt->Next = RcvTCB->tcb_pendhead;
                RcvTCB->tcb_pendhead = NewPkt;
            }
            RcvTCB->tcb_pendingcnt += Size - Copied;
            Copied = Size;

            CheckPacketList(RcvTCB->tcb_pendhead, RcvTCB->tcb_pendingcnt);

        } else
            FreePacketChain(SrcPkt);
    } else {
        // We copied Size bytes, but the chain could be longer than that. Free
        // it if we need to.
        if (SrcPkt != NULL)
            FreePacketChain(SrcPkt);
    }

    if (RcvCmpltd != 0) {
        DelayAction(RcvTCB, NEED_RCV_CMPLT);
    } else {
        START_TCB_TIMER(RcvTCB->tcb_pushtimer, PUSH_TO);
    }

    return Copied;
}


//* IndicateData - Indicate incoming data to a client.
//
//  Called when we need to indicate data to an upper layer client. We'll pass
//  up a pointer to whatever we have available, and the client may take some
//  or all of it.
//
uint                       // Returns: Number of bytes of data taken.
IndicateData(
    TCB *RcvTCB,           // TCB on which to receive the data.
    uint RcvFlags,         // TCP receive flags for the incoming packet.
    IPv6Packet *InPacket,  // Input buffer of packet.
    uint Size)             // Size in bytes of data in InPacket.
{
    TDI_STATUS Status;
    PRcvEvent Event;
    PVOID EventContext, ConnContext;
    uint BytesTaken = 0;
    EventRcvBuffer *ERB = NULL;
    PTDI_REQUEST_KERNEL_RECEIVE RequestInformation;
    PIO_STACK_LOCATION IrpSp;
    TCPRcvReq *RcvReq;
    ulong IndFlags;

    CHECK_STRUCT(RcvTCB, tcb);
    ASSERT(Size > 0);
    ASSERT(InPacket != NULL);
    ASSERT(RcvTCB->tcb_refcnt != 0);
    ASSERT(RcvTCB->tcb_fastchk & TCP_FLAG_IN_RCV);
    ASSERT(RcvTCB->tcb_rcvind != NULL);
    ASSERT(RcvTCB->tcb_rcvhead == NULL);
    ASSERT(RcvTCB->tcb_rcvhndlr == IndicateData);

    RcvReq = GetRcvReq();
    if (RcvReq != NULL) {
        //
        // The indicate handler is saved in the TCB.  Just call up into it.
        //
        Event = RcvTCB->tcb_rcvind;
        EventContext = RcvTCB->tcb_ricontext;
        ConnContext = RcvTCB->tcb_conncontext;

        RcvTCB->tcb_indicated = Size;
        RcvTCB->tcb_flags |= IN_RCV_IND;

        //
        // If we're at the end of a contigous data region,
        // move forward to the next one.  This prevents us
        // from making nonsensical zero byte indications.
        //
        if (InPacket->ContigSize == 0) {
            PacketPullupSubr(InPacket, 0, 1, 0);
        }

        IF_TCPDBG(TCP_DEBUG_RECEIVE) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "Indicating %lu bytes, %lu available\n",
                       MIN(InPacket->ContigSize, Size), Size));
        }

#if TCP_FLAG_PUSH >= TDI_RECEIVE_ENTIRE_MESSAGE
        IndFlags = TDI_RECEIVE_COPY_LOOKAHEAD | TDI_RECEIVE_NORMAL |
            TDI_RECEIVE_AT_DISPATCH_LEVEL |
            ((RcvFlags & TCP_FLAG_PUSH) >>
             ((TCP_FLAG_PUSH / TDI_RECEIVE_ENTIRE_MESSAGE) - 1));
#else
        IndFlags = TDI_RECEIVE_COPY_LOOKAHEAD | TDI_RECEIVE_NORMAL |
            TDI_RECEIVE_AT_DISPATCH_LEVEL |
            ((RcvFlags & TCP_FLAG_PUSH) <<
             ((TDI_RECEIVE_ENTIRE_MESSAGE / TCP_FLAG_PUSH) - 1));
#endif
        if ((RcvTCB->tcb_flags & DISC_NOTIFIED) ||
            (RcvTCB->tcb_pending & RST_PENDING)) {
            KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
            Status = TDI_NOT_ACCEPTED;
        } else {
            KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
            Status = (*Event)(EventContext, ConnContext, IndFlags,
                              MIN(InPacket->ContigSize, Size), Size,
                              (PULONG)&BytesTaken, InPacket->Data, &ERB);
        }

        IF_TCPDBG(TCP_DEBUG_RECEIVE) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "%lu bytes taken, status %lx\n", BytesTaken, Status));
        }

        //
        // See what the client did.  If the return status is MORE_PROCESSING,
        // we've been given a buffer.  In that case put it on the front of the
        // buffer queue, and if all the data wasn't taken go ahead and copy
        // it into the new buffer chain.
        //
        // Note that the size and buffer chain we're concerned with here is
        // the one that we passed to the client.  Since we're in a recieve
        // handler, any data that has come in would have been put on the
        // reassembly queue.
        //
        if (Status == TDI_MORE_PROCESSING) {

            ASSERT(ERB != NULL);

            IrpSp = IoGetCurrentIrpStackLocation(ERB);

            Status = TCPPrepareIrpForCancel(
                (PTCP_CONTEXT) IrpSp->FileObject->FsContext, ERB,
                TCPCancelRequest);

            if (NT_SUCCESS(Status)) {

                RequestInformation = (PTDI_REQUEST_KERNEL_RECEIVE)
                                     &(IrpSp->Parameters);

                RcvReq->trr_rtn = TCPDataRequestComplete;
                RcvReq->trr_context = ERB;
                RcvReq->trr_buffer = ERB->MdlAddress;
                RcvReq->trr_size = RequestInformation->ReceiveLength;
                RcvReq->trr_uflags = (ushort *)
                    &(RequestInformation->ReceiveFlags);
                RcvReq->trr_flags = (uint)(RequestInformation->ReceiveFlags);
                RcvReq->trr_offset = 0;
                RcvReq->trr_amt = 0;

                KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);

                RcvTCB->tcb_flags &= ~IN_RCV_IND;

                ASSERT(RcvTCB->tcb_rcvhndlr == IndicateData);

                // Push him on the front of the rcv. queue.
                ASSERT((RcvTCB->tcb_currcv == NULL) ||
                       (RcvTCB->tcb_currcv->trr_amt == 0));

                if (RcvTCB->tcb_rcvhead == NULL) {
                    RcvTCB->tcb_rcvhead = RcvReq;
                    RcvTCB->tcb_rcvtail = RcvReq;
                    RcvReq->trr_next = NULL;
                } else {
                    RcvReq->trr_next = RcvTCB->tcb_rcvhead;
                    RcvTCB->tcb_rcvhead = RcvReq;
                }

                RcvTCB->tcb_currcv = RcvReq;
                RcvTCB->tcb_rcvhndlr = BufferData;

                ASSERT(BytesTaken <= Size);

                RcvTCB->tcb_indicated -= BytesTaken;
                if ((Size -= BytesTaken) != 0) {
                    //
                    // Not everything was taken.
                    // Adjust the buffer chain to point beyond what was taken.
                    //
                    InPacket = TrimPacket(InPacket, BytesTaken);

                    ASSERT(InPacket != NULL);

                    //
                    // We've adjusted the buffer chain.
                    // Call the BufferData handler.
                    //
                    BytesTaken += BufferData(RcvTCB, RcvFlags, InPacket, Size);

                } else  {
                    // All of the data was taken.  Free the buffer chain.
                    FreePacketChain(InPacket);
                }

                return BytesTaken;
            } else {
                //
                // The IRP was cancelled before it was handed back to us.
                // We'll pretend we never saw it.  TCPPrepareIrpForCancel
                // already completed it.  The client may have taken data,
                // so we will act as if success was returned.
                //
                ERB = NULL;
                Status = TDI_SUCCESS;
            }
        }

        KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);

        RcvTCB->tcb_flags &= ~IN_RCV_IND;

        //
        // Status is not more processing. If it's not SUCCESS, the client
        // didn't take any of the data. In either case we now need to
        // see if all of the data was taken. If it wasn't, we'll try and
        // push it onto the front of the pending queue.
        //
        FreeRcvReq(RcvReq);  // This won't be needed.
        if (Status == TDI_NOT_ACCEPTED)
            BytesTaken = 0;

        ASSERT(BytesTaken <= Size);

        RcvTCB->tcb_indicated -= BytesTaken;

        ASSERT(RcvTCB->tcb_rcvhndlr == IndicateData);

        // Check to see if a rcv. buffer got posted during the indication.
        // If it did, reset the receive handler now.
        if (RcvTCB->tcb_rcvhead != NULL) {
            RcvTCB->tcb_rcvhndlr = BufferData;
        } else if (RcvTCB->tcb_rcvind == NULL) {
            RcvTCB->tcb_rcvhndlr = PendData;
        }

        // See if all of the data was taken.
        if (BytesTaken == Size) {
            ASSERT(RcvTCB->tcb_indicated == 0);

            FreePacketChain(InPacket);
            return BytesTaken;  // It was all taken.
        }

        //
        // It wasn't all taken.  Adjust for what was taken, and push
        // on the front of the pending queue.  We also need to check to
        // see if a receive buffer got posted during the indication.  This
        // would be weird, but not impossible.
        //
        InPacket = TrimPacket(InPacket, BytesTaken);
        if (RcvTCB->tcb_rcvhead == NULL) {
            IPv6Packet *LastPkt, *NewPkt;

            RcvTCB->tcb_rcvhndlr = PendData;
            NewPkt = CovetPacketChain(InPacket, &LastPkt, Size - BytesTaken);
            if (NewPkt != NULL) {
                // We have a duplicate chain.  Push it on the front of the
                // pending q.
                if (RcvTCB->tcb_pendhead == NULL) {
                    RcvTCB->tcb_pendhead = NewPkt;
                    RcvTCB->tcb_pendtail = LastPkt;
                } else {
                    LastPkt->Next = RcvTCB->tcb_pendhead;
                    RcvTCB->tcb_pendhead = NewPkt;
                }
                RcvTCB->tcb_pendingcnt += Size - BytesTaken;
                BytesTaken = Size;
            } else {
                FreePacketChain(InPacket);
            }
            return BytesTaken;
        } else {
            //
            // Just great.  There's now a receive buffer on the TCB.
            // Call the BufferData handler now.
            //
            ASSERT(RcvTCB->tcb_rcvhndlr == BufferData);

            BytesTaken += BufferData(RcvTCB, RcvFlags, InPacket,
                                     Size - BytesTaken);
            return BytesTaken;
        }

    } else {
        //
        // Couldn't get a receive request.  We must be really low on resources,
        // so just bail out now.
        //
        FreePacketChain(InPacket);
        return 0;
    }
}


//* IndicatePendingData - Indicate pending data to a client.
//
//  Called when we need to indicate pending data to an upper layer client,
//  usually because data arrived when we were in a state that it couldn't
//  be indicated.
//
//  Many of the comments in the BufferData header about the consistency of
//  tcb_pendingcnt apply here also.
//
void                    //  Returns: Nothing.
IndicatePendingData(
    TCB *RcvTCB,        // TCB on which to indicate the data.
    TCPRcvReq *RcvReq,  // Receive request to use to indicate it.
    KIRQL PreLockIrql)  // IRQL prior to acquiring TCB lock.
{
    TDI_STATUS Status;
    PRcvEvent Event;
    PVOID EventContext, ConnContext;
    uint BytesTaken = 0;
    EventRcvBuffer *ERB = NULL;
    PTDI_REQUEST_KERNEL_RECEIVE RequestInformation;
    PIO_STACK_LOCATION IrpSp;
    IPv6Packet *NewPkt;
    uint Size;
    uint BytesIndicated;
    uint BytesAvailable;
    uchar* DataBuffer;

    CHECK_STRUCT(RcvTCB, tcb);

    ASSERT(RcvTCB->tcb_refcnt != 0);
    ASSERT(RcvTCB->tcb_rcvind != NULL);
    ASSERT(RcvTCB->tcb_rcvhead == NULL);
    ASSERT(RcvTCB->tcb_pendingcnt != 0);
    ASSERT(RcvReq != NULL);

    for (;;) {
        ASSERT(RcvTCB->tcb_rcvhndlr == PendData);

        // The indicate handler is saved in the TCB.  Just call up into it.
        Event = RcvTCB->tcb_rcvind;
        EventContext = RcvTCB->tcb_ricontext;
        ConnContext = RcvTCB->tcb_conncontext;
        BytesIndicated = RcvTCB->tcb_pendhead->ContigSize;
        BytesAvailable = RcvTCB->tcb_pendingcnt;
        DataBuffer = RcvTCB->tcb_pendhead->Data;
        RcvTCB->tcb_indicated = RcvTCB->tcb_pendingcnt;
        RcvTCB->tcb_flags |= IN_RCV_IND;

        if ((RcvTCB->tcb_flags & DISC_NOTIFIED) ||
            (RcvTCB->tcb_pending & RST_PENDING)) {
            KeReleaseSpinLock(&RcvTCB->tcb_lock, PreLockIrql);
            Status = TDI_NOT_ACCEPTED;
            BytesTaken = 0;
        } else {
            KeReleaseSpinLock(&RcvTCB->tcb_lock, PreLockIrql);

            IF_TCPDBG(TCPDebug & TCP_DEBUG_RECEIVE) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "Indicating pending %d bytes, %d available\n",
                           BytesIndicated,
                           BytesAvailable));
            }

            Status = (*Event)(EventContext, ConnContext,
                              TDI_RECEIVE_COPY_LOOKAHEAD | TDI_RECEIVE_NORMAL |
                              TDI_RECEIVE_ENTIRE_MESSAGE,
                              BytesIndicated, BytesAvailable,
                              (PULONG)&BytesTaken, DataBuffer, &ERB);

            IF_TCPDBG(TCPDebug & TCP_DEBUG_RECEIVE) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "%d bytes taken\n", BytesTaken));
            }
        }

        //
        // See what the client did.  If the return status is MORE_PROCESSING,
        // we've been given a buffer.  In that case put it on the front of the
        // buffer queue, and if all the data wasn't taken go ahead and copy
        // it into the new buffer chain.
        //
        if (Status == TDI_MORE_PROCESSING) {

            IF_TCPDBG(TCP_DEBUG_RECEIVE) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "more processing on receive\n"));
            }

            ASSERT(ERB != NULL);

            IrpSp = IoGetCurrentIrpStackLocation(ERB);

            Status = TCPPrepareIrpForCancel(
                (PTCP_CONTEXT) IrpSp->FileObject->FsContext, ERB,
                TCPCancelRequest);

            if (NT_SUCCESS(Status)) {

                RequestInformation = (PTDI_REQUEST_KERNEL_RECEIVE)
                    &(IrpSp->Parameters);

                RcvReq->trr_rtn = TCPDataRequestComplete;
                RcvReq->trr_context = ERB;
                RcvReq->trr_buffer = ERB->MdlAddress;
                RcvReq->trr_size = RequestInformation->ReceiveLength;
                RcvReq->trr_uflags = (ushort *)
                    &(RequestInformation->ReceiveFlags);
                RcvReq->trr_flags = (uint)(RequestInformation->ReceiveFlags);
                RcvReq->trr_offset = 0;
                RcvReq->trr_amt = 0;

                KeAcquireSpinLock(&RcvTCB->tcb_lock, &PreLockIrql);
                RcvTCB->tcb_flags &= ~IN_RCV_IND;

                // Push him on the front of the receive queue.
                ASSERT((RcvTCB->tcb_currcv == NULL) ||
                       (RcvTCB->tcb_currcv->trr_amt == 0));

                if (RcvTCB->tcb_rcvhead == NULL) {
                    RcvTCB->tcb_rcvhead = RcvReq;
                    RcvTCB->tcb_rcvtail = RcvReq;
                    RcvReq->trr_next = NULL;
                } else {
                    RcvReq->trr_next = RcvTCB->tcb_rcvhead;
                    RcvTCB->tcb_rcvhead = RcvReq;
                }

                RcvTCB->tcb_currcv = RcvReq;
                RcvTCB->tcb_rcvhndlr = BufferData;

                //
                // Have to pick up the new size and pointers now, since things
                // could have changed during the upcall.
                //
                Size = RcvTCB->tcb_pendingcnt;
                NewPkt = RcvTCB->tcb_pendhead;
                RcvTCB->tcb_pendingcnt = 0;
                RcvTCB->tcb_pendhead = NULL;

                ASSERT(BytesTaken <= Size);

                RcvTCB->tcb_indicated -= BytesTaken;
                if ((Size -= BytesTaken) != 0) {
                    //
                    // Not everything was taken.  Adjust the buffer chain to
                    // point beyond what was taken.
                    //
                    NewPkt = TrimPacket(NewPkt, BytesTaken);

                    ASSERT(NewPkt != NULL);

                    //
                    // We've adjusted the buffer chain.
                    // Call the BufferData handler.
                    //
                    (void)BufferData(RcvTCB, TCP_FLAG_PUSH, NewPkt, Size);
                    KeReleaseSpinLock(&RcvTCB->tcb_lock, PreLockIrql);

                } else  {
                    //
                    // All of the data was taken.  Free the buffer chain.
                    // Since we were passed a buffer chain which we put on the
                    // head of the list, leave the rcvhandler pointing at
                    // BufferData.
                    //
                    ASSERT(RcvTCB->tcb_rcvhndlr == BufferData);
                    ASSERT(RcvTCB->tcb_indicated == 0);
                    ASSERT(RcvTCB->tcb_rcvhead != NULL);

                    KeReleaseSpinLock(&RcvTCB->tcb_lock, PreLockIrql);
                    FreePacketChain(NewPkt);
                }

                return;
            } else {
                //
                // The IRP was cancelled before it was handed back to us.
                // We'll pretend we never saw it.  TCPPrepareIrpForCancel
                // already completed it.  The client may have taken data,
                // so we will act as if success was returned.
                //
                ERB = NULL;
                Status = TDI_SUCCESS;
            }
        }

        KeAcquireSpinLock(&RcvTCB->tcb_lock, &PreLockIrql);

        RcvTCB->tcb_flags &= ~IN_RCV_IND;

        //
        // Status is not more processing.  If it's not SUCCESS, the client
        // didn't take any of the data.  In either case we now need to
        // see if all of the data was taken.  If it wasn't, we're done.
        //
        if (Status == TDI_NOT_ACCEPTED)
            BytesTaken = 0;

        ASSERT(RcvTCB->tcb_rcvhndlr == PendData);

        RcvTCB->tcb_indicated -= BytesTaken;
        Size = RcvTCB->tcb_pendingcnt;
        NewPkt = RcvTCB->tcb_pendhead;

        ASSERT(BytesTaken <= Size);

        // See if all of the data was taken.
        if (BytesTaken == Size) {
            // It was all taken.  Zap the pending data information.
            RcvTCB->tcb_pendingcnt = 0;
            RcvTCB->tcb_pendhead = NULL;

            ASSERT(RcvTCB->tcb_indicated == 0);
            if (RcvTCB->tcb_rcvhead == NULL) {
                if (RcvTCB->tcb_rcvind != NULL)
                    RcvTCB->tcb_rcvhndlr = IndicateData;
            } else
                RcvTCB->tcb_rcvhndlr = BufferData;

            KeReleaseSpinLock(&RcvTCB->tcb_lock, PreLockIrql);
            FreePacketChain(NewPkt);
            break;
        }

        //
        // It wasn't all taken.  Adjust for what was taken; we also need to
        // check to see if a receive buffer got posted during the indication.
        // This would be weird, but not impossible.
        //
        NewPkt = TrimPacket(NewPkt, BytesTaken);

        ASSERT(RcvTCB->tcb_rcvhndlr == PendData);

        if (RcvTCB->tcb_rcvhead == NULL) {
            RcvTCB->tcb_pendhead = NewPkt;
            RcvTCB->tcb_pendingcnt -= BytesTaken;
            if (RcvTCB->tcb_indicated != 0 || RcvTCB->tcb_rcvind == NULL) {
                KeReleaseSpinLock(&RcvTCB->tcb_lock, PreLockIrql);
                break;
            }

            // From here, we'll loop around and indicate the new data that
            // presumably came in during the previous indication.
        } else {
            //
            // Just great.  There's now a receive buffer on the TCB.
            // Call the BufferData handler now.
            //
            RcvTCB->tcb_rcvhndlr = BufferData;
            RcvTCB->tcb_pendingcnt = 0;
            RcvTCB->tcb_pendhead = NULL;
            BytesTaken += BufferData(RcvTCB, TCP_FLAG_PUSH, NewPkt,
                                     Size - BytesTaken);
            KeReleaseSpinLock(&RcvTCB->tcb_lock, PreLockIrql);
            break;
        }

    } // for (;;)

    FreeRcvReq(RcvReq);  // This isn't needed anymore.
}

//* DeliverUrgent - Deliver urgent data to a client.
//
//  Called to deliver urgent data to a client. We assume the input
//  urgent data is in a buffer we can keep. The buffer can be NULL, in
//  which case we'll just look on the urgent pending queue for data.
//
void                     // Returns: Nothing.
DeliverUrgent(
    TCB *RcvTCB,         // TCB to deliver on.
    IPv6Packet *RcvPkt,  // Packet for urgent data.
    uint Size,           // Number of bytes of urgent data to deliver.
    KIRQL *pTCBIrql)     // Location of KIRQL prior to acquiring TCB lock.
{
    KIRQL Irql1, Irql2, Irql3;  // One per lock nesting level.
    TCPRcvReq *RcvReq, *PrevReq;
    uint BytesTaken = 0;
    IPv6Packet *LastPkt;
    EventRcvBuffer *ERB;
    PRcvEvent ExpRcv;
    PVOID ExpRcvContext;
    PVOID ConnContext;
    TDI_STATUS Status;

    CHECK_STRUCT(RcvTCB, tcb);
    ASSERT(RcvTCB->tcb_refcnt != 0);

    CheckPacketList(RcvTCB->tcb_urgpending, RcvTCB->tcb_urgcnt);

    //
    // See if we have new data, or are processing old data.
    //
    if (RcvPkt != NULL) {
        //
        // We have new data.  If the pending queue is not NULL, or we're
        // already in this routine, just put the buffer on the end of the
        // queue.
        //
        if (RcvTCB->tcb_urgpending != NULL ||
            (RcvTCB->tcb_flags & IN_DELIV_URG)) {
            IPv6Packet *PrevRcvPkt;

            // Put him on the end of the queue.
            PrevRcvPkt = CONTAINING_RECORD(&RcvTCB->tcb_urgpending, IPv6Packet,
                                           Next);
            while (PrevRcvPkt->Next != NULL)
                PrevRcvPkt = PrevRcvPkt->Next;

            PrevRcvPkt->Next = RcvPkt;
            RcvTCB->tcb_urgcnt += Size;
            return;
        }
    } else {
        //
        // The input buffer is NULL.  See if we have existing data, or are in
        // this routine.  If we have no existing data or are in this routine
        // just return.
        //
        if (RcvTCB->tcb_urgpending == NULL ||
            (RcvTCB->tcb_flags & IN_DELIV_URG)) {
            return;
        } else {
            RcvPkt = RcvTCB->tcb_urgpending;
            Size = RcvTCB->tcb_urgcnt;
            RcvTCB->tcb_urgpending = NULL;
            RcvTCB->tcb_urgcnt = 0;
        }
    }

    ASSERT(RcvPkt != NULL);
    ASSERT(!(RcvTCB->tcb_flags & IN_DELIV_URG));

    //
    // We know we have data to deliver, and we have a pointer and a size.
    // Go into a loop, trying to deliver the data.  On each iteration, we'll
    // try to find a buffer for the data.  If we find one, we'll copy and
    // complete it right away.  Otherwise we'll try and indicate it.  If we
    // can't indicate it, we'll put it on the pending queue and leave.
    //
    RcvTCB->tcb_flags |= IN_DELIV_URG;
    RcvTCB->tcb_slowcount++;
    RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
    CheckTCBRcv(RcvTCB);

    do {
        CheckPacketList(RcvTCB->tcb_urgpending, RcvTCB->tcb_urgcnt);

        BytesTaken = 0;

        // First check the expedited queue.
        if ((RcvReq = RcvTCB->tcb_exprcv) != NULL)
            RcvTCB->tcb_exprcv = RcvReq->trr_next;
        else {
            //
            // Nothing in the expedited receive queue.  Walk down the ordinary
            // receive queue, looking for a buffer that we can steal.
            //
            PrevReq = CONTAINING_RECORD(&RcvTCB->tcb_rcvhead, TCPRcvReq,
                                        trr_next);
            RcvReq = PrevReq->trr_next;
            while (RcvReq != NULL) {
                CHECK_STRUCT(RcvReq, trr);
                if (RcvReq->trr_flags & TDI_RECEIVE_EXPEDITED) {
                    // This is a candidate.
                    if (RcvReq->trr_amt == 0) {

                        ASSERT(RcvTCB->tcb_rcvhndlr == BufferData);

                        //
                        // And he has nothing currently in him.
                        // Pull him out of the queue.
                        //
                        if (RcvTCB->tcb_rcvtail == RcvReq) {
                            if (RcvTCB->tcb_rcvhead == RcvReq)
                                RcvTCB->tcb_rcvtail = NULL;
                            else
                                RcvTCB->tcb_rcvtail = PrevReq;
                        }

                        PrevReq->trr_next = RcvReq->trr_next;
                        if (RcvTCB->tcb_currcv == RcvReq) {
                            RcvTCB->tcb_currcv = RcvReq->trr_next;
                            if (RcvTCB->tcb_currcv == NULL) {
                                //
                                // We've taken the last receive from the list.
                                // Reset the rcvhndlr.
                                //
                                if (RcvTCB->tcb_rcvind != NULL &&
                                    RcvTCB->tcb_indicated == 0)
                                    RcvTCB->tcb_rcvhndlr = IndicateData;
                                else
                                    RcvTCB->tcb_rcvhndlr = PendData;
                            }
                        }

                        break;
                    }
                }
                PrevReq = RcvReq;
                RcvReq = PrevReq->trr_next;
            }
        }

        //
        // We've done our best to get a buffer.  If we got one, copy into it
        // now, and complete the request.
        //
        if (RcvReq != NULL) {
            // Got a buffer.
            KeReleaseSpinLock(&RcvTCB->tcb_lock, *pTCBIrql);
            BytesTaken = CopyPacketToNdis(RcvReq->trr_buffer, RcvPkt,
                                          Size, 0, RcvPkt->Position);
            (*RcvReq->trr_rtn)(RcvReq->trr_context, TDI_SUCCESS, BytesTaken);
            FreeRcvReq(RcvReq);
            KeAcquireSpinLock(&RcvTCB->tcb_lock, pTCBIrql);
            RcvTCB->tcb_urgind -= MIN(RcvTCB->tcb_urgind, BytesTaken);
        } else {
            // No posted buffer. If we can indicate, do so.
            if (RcvTCB->tcb_urgind == 0) {
                TCPConn *Conn;

                // See if he has an expedited rcv handler.
                ConnContext = RcvTCB->tcb_conncontext;
                KeReleaseSpinLock(&RcvTCB->tcb_lock, *pTCBIrql);
                KeAcquireSpinLock(&AddrObjTableLock, &Irql1);
                KeAcquireSpinLock(
                    &ConnTable[CONN_BLOCKID(RcvTCB->tcb_connid)]->cb_lock,
                    &Irql2);
                KeAcquireSpinLock(&RcvTCB->tcb_lock, pTCBIrql);
                if ((Conn = RcvTCB->tcb_conn) != NULL) {
                    CHECK_STRUCT(Conn, tc);
                    ASSERT(Conn->tc_tcb == RcvTCB);
                    if ((RcvTCB->tcb_flags & DISC_NOTIFIED) ||
                        (RcvTCB->tcb_pending & RST_PENDING)) {
                        Status = TDI_NOT_ACCEPTED;
                    } else {
                        Status = TDI_SUCCESS;
                    }
                    KeReleaseSpinLock(&RcvTCB->tcb_lock, *pTCBIrql);
                    if (Conn->tc_ao != NULL) {
                        AddrObj *AO;

                        AO = Conn->tc_ao;
                        KeAcquireSpinLock(&AO->ao_lock, &Irql3);
                        if (AO_VALID(AO) && (ExpRcv = AO->ao_exprcv) != NULL) {
                            ExpRcvContext = AO->ao_exprcvcontext;
                            KeReleaseSpinLock(&AO->ao_lock, Irql3);

                            // We're going to indicate.
                            RcvTCB->tcb_urgind = Size;
                            KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock,
                                              Irql2);
                            KeReleaseSpinLock(&AddrObjTableLock, Irql1);

                            if (Status != TDI_NOT_ACCEPTED) {
                                Status = (*ExpRcv)(ExpRcvContext, ConnContext,
                                                   TDI_RECEIVE_COPY_LOOKAHEAD |
                                                   TDI_RECEIVE_ENTIRE_MESSAGE |
                                                   TDI_RECEIVE_EXPEDITED,
                                                   MIN(RcvPkt->ContigSize,
                                                       Size),
                                                   Size, (PULONG)&BytesTaken,
                                                   RcvPkt->Data, &ERB);
                            }

                            KeAcquireSpinLock(&RcvTCB->tcb_lock, pTCBIrql);

                            // See what he did with it.
                            if (Status == TDI_MORE_PROCESSING) {
                                uint CopySize;

                                // He gave us a buffer.
                                if (BytesTaken == Size) {
                                    //
                                    // He gave us a buffer, but took all of
                                    // it.  We'll just return it to him.
                                    //
                                    CopySize = 0;
                                } else {
                                    // We have some data to copy in.
                                    RcvPkt = TrimPacket(RcvPkt, BytesTaken);
                                    ASSERT(RcvPkt->TotalSize != 0);
                                    CopySize = CopyPacketToNdis(
                                        ERB->MdlAddress, RcvPkt,
                                        MIN(Size - BytesTaken,
                                            TCPGetMdlChainByteCount(
                                                ERB->MdlAddress)), 0,
                                        RcvPkt->Position);
                                }
                                BytesTaken += CopySize;
                                RcvTCB->tcb_urgind -= MIN(RcvTCB->tcb_urgind,
                                                          BytesTaken);
                                KeReleaseSpinLock(&RcvTCB->tcb_lock,
                                                  *pTCBIrql);

                                ERB->IoStatus.Status = TDI_SUCCESS;
                                ERB->IoStatus.Information = CopySize;
                                IoCompleteRequest(ERB, 2);

                                KeAcquireSpinLock(&RcvTCB->tcb_lock, pTCBIrql);

                            } else {

                                // No buffer to deal with.
                                if (Status == TDI_NOT_ACCEPTED)
                                    BytesTaken = 0;

                                RcvTCB->tcb_urgind -= MIN(RcvTCB->tcb_urgind,
                                                          BytesTaken);
                            }
                            goto checksize;
                        } else {
                            // No receive handler.
                            KeReleaseSpinLock(&AO->ao_lock, Irql3);
                        }
                    }
                    // Conn->tc_ao == NULL.
                    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql2);
                    KeReleaseSpinLock(&AddrObjTableLock, Irql1);
                    KeAcquireSpinLock(&RcvTCB->tcb_lock, pTCBIrql);
                } else {
                    // RcvTCB has invalid index.
                    KeReleaseSpinLock(
                        &ConnTable[CONN_BLOCKID(RcvTCB->tcb_connid)]->cb_lock,
                        *pTCBIrql);
                    KeReleaseSpinLock(&AddrObjTableLock, Irql2);
                    *pTCBIrql = Irql1;
                }
            }

            //
            // For whatever reason we couldn't indicate the data.  At this
            // point we hold the lock on the TCB.  Push the buffer onto the
            // pending queue and return.
            //
            CheckPacketList(RcvTCB->tcb_urgpending, RcvTCB->tcb_urgcnt);

            LastPkt = FindLastPacket(RcvPkt);
            LastPkt->Next = RcvTCB->tcb_urgpending;
            RcvTCB->tcb_urgpending = RcvPkt;
            RcvTCB->tcb_urgcnt += Size;
            break;
        }

checksize:
        //
        // See how much we took.  If we took it all, check the pending queue.
        // At this point, we should hold the lock on the TCB.
        //
        if (Size == BytesTaken) {
            // Took it all.
            FreePacketChain(RcvPkt);
            RcvPkt = RcvTCB->tcb_urgpending;
            Size = RcvTCB->tcb_urgcnt;
        } else {
            //
            // We didn't manage to take it all.  Free what we did take,
            // and then merge with the pending queue.
            //
            RcvPkt = TrimPacket(RcvPkt, BytesTaken);
            Size = Size - BytesTaken + RcvTCB->tcb_urgcnt;
            if (RcvTCB->tcb_urgpending != NULL) {
                //
                // Find the end of the current Packet chain, so we can merge.
                //
                LastPkt = FindLastPacket(RcvPkt);
                LastPkt->Next = RcvTCB->tcb_urgpending;
            }
        }

        RcvTCB->tcb_urgpending = NULL;
        RcvTCB->tcb_urgcnt = 0;

    } while (RcvPkt != NULL);

    CheckPacketList(RcvTCB->tcb_urgpending, RcvTCB->tcb_urgcnt);

    RcvTCB->tcb_flags &= ~IN_DELIV_URG;
    if (--(RcvTCB->tcb_slowcount) == 0) {
        RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
        CheckTCBRcv(RcvTCB);
    }
}

//* PushData - Push all data back to the client.
//
//  Called when we've received a FIN and need to push data to the client.
//
void               // Returns: Nothing.
PushData(
    TCB *PushTCB)  // TCB to be pushed.
{
    TCPRcvReq *RcvReq;

    CHECK_STRUCT(PushTCB, tcb);

    RcvReq = PushTCB->tcb_rcvhead;
    while (RcvReq != NULL) {
        CHECK_STRUCT(RcvReq, trr);
        RcvReq->trr_flags |= TRR_PUSHED;
        RcvReq = RcvReq->trr_next;
    }

    RcvReq = PushTCB->tcb_exprcv;
    while (RcvReq != NULL) {
        CHECK_STRUCT(RcvReq, trr);
        RcvReq->trr_flags |= TRR_PUSHED;
        RcvReq = RcvReq->trr_next;
    }

    if (PushTCB->tcb_rcvhead != NULL || PushTCB->tcb_exprcv != NULL)
        DelayAction(PushTCB, NEED_RCV_CMPLT);
}

//* SplitPacket - Split an IPv6Packet into three pieces.
//
//  This function takes an input IPv6Packet and splits it into three pieces.
//  The first piece is the input buffer, which we just skip over.  The second
//  and third pieces are actually copied, even if we already own them, so
//  that they may go to different places.
//
//  Note: *SecondBuf and *ThirdBuf are set to NULL if we can't allocate
//        memory for them.
//
void                         // Returns: Nothing.
SplitPacket(
    IPv6Packet *Packet,      // Packet chain to be split.
    uint Size,               // Total size in bytes of packet chain.
    uint Offset,             // Offset to skip over.
    uint SecondSize,         // Size in bytes of second piece.
    IPv6Packet **SecondPkt,  // Where to return second packet pointer.
    IPv6Packet **ThirdPkt)   // Where to return third packet pointer.
{
    IPv6Packet *Temp;
    uint ThirdSize;

    ASSERT(Offset < Size);
    ASSERT(((Offset + SecondSize) < Size) ||
           (((Offset + SecondSize) == Size) && ThirdPkt == NULL));
    ASSERT(Packet != NULL);

    //
    // Packet points at the packet to copy from, and Offset is the offset into
    // this packet to copy from.
    //
    if (SecondPkt != NULL) {
        //
        // We need to allocate memory for a second packet.
        //
        Temp = ExAllocatePoolWithTagPriority(NonPagedPool,
                                             sizeof(IPv6Packet) + SecondSize,
                                             TCP6_TAG, LowPoolPriority);
        if (Temp != NULL) {
            Temp->Next = NULL;
            Temp->Position = 0;
            Temp->FlatData = (uchar *)(Temp + 1);
            Temp->Data = Temp->FlatData;
            Temp->ContigSize = SecondSize;
            Temp->TotalSize = SecondSize;
            Temp->NdisPacket = NULL;
            Temp->AuxList = NULL;
            Temp->Flags = PACKET_OURS;
            CopyPacketToBuffer(Temp->Data, Packet, SecondSize,
                               Packet->Position + Offset);
            *SecondPkt = Temp;
        } else {
            *SecondPkt = NULL;
            if (ThirdPkt != NULL)
                *ThirdPkt = NULL;
            return;
        }
    }

    if (ThirdPkt != NULL) {
        //
        // We need to allocate memory for a third buffer.
        //
        ThirdSize = Size - (Offset + SecondSize);
        Temp = ExAllocatePoolWithTagPriority(NonPagedPool,
                                             sizeof(IPv6Packet) + ThirdSize,
                                             TCP6_TAG, LowPoolPriority);

        if (Temp != NULL) {
            Temp->Next = NULL;
            Temp->Position = 0;
            Temp->FlatData = (uchar *)(Temp + 1);
            Temp->Data = Temp->FlatData;
            Temp->ContigSize = ThirdSize;
            Temp->TotalSize = ThirdSize;
            Temp->NdisPacket = NULL;
            Temp->AuxList = NULL;
            Temp->Flags = PACKET_OURS;
            CopyPacketToBuffer(Temp->Data, Packet, ThirdSize,
                               Packet->Position + Offset + SecondSize);
            *ThirdPkt = Temp;
        } else
            *ThirdPkt = NULL;
    }
}


//* HandleUrgent - Handle urgent data.
//
//  Called when an incoming segment has urgent data in it. We make sure there
//  really is urgent data in the segment, and if there is we try to dispose
//  of it either by putting it into a posted buffer or calling an exp. rcv.
//  indication handler.
//
//  This routine is called at DPC level, and with the TCP locked.
//
//  Urgent data handling is a little complicated.  Each TCB has the starting
//  and ending sequence numbers of the 'current' (last received) bit of urgent
//  data.  It is possible that the start of the current urgent data might be
//  greater than tcb_rcvnext, if urgent data came in, we handled it, and then
//  couldn't take the preceding normal data.  The urgent valid flag is cleared
//  when the next byte of data the user would read (rcvnext - pendingcnt) is
//  greater than the end of urgent data - we do this so that we can correctly
//  support SIOCATMARK.  We always seperate urgent data out of the data stream.
//  If the urgent valid field is set when we get into this routing we have
//  to play a couple of games.  If the incoming segment starts in front of the
//  current urgent data, we truncate it before the urgent data, and put any
//  data after the urgent data on the reassemble queue.  These gyrations are
//  done to avoid delivering the same urgent data twice.  If the urgent valid
//  field in the TCB is set and the segment starts after the current urgent
//  data the new urgent information will replace the current urgent
//  information.
//
void                      // Returns: Nothing.
HandleUrgent(
    TCB *RcvTCB,          // TCB to recv the data on.
    TCPRcvInfo *RcvInfo,  // RcvInfo structure for the incoming segment.
    IPv6Packet *RcvPkt,   // Packet chain containing the incoming segment.
    uint *Size)           // Size in bytes of data in the segment.
{
    uint BytesInFront;          // Bytes in front of the urgent data.
    uint BytesInBack;           // Bytes in back of the urgent data.
    uint UrgSize;               // Size in bytes of urgent data.
    SeqNum UrgStart, UrgEnd;
    IPv6Packet *EndPkt, *UrgPkt;
    TCPRcvInfo NewRcvInfo;
    KIRQL TCBIrql;

    CHECK_STRUCT(RcvTCB, tcb);
    ASSERT(RcvTCB->tcb_refcnt != 0);
    ASSERT(RcvInfo->tri_flags & TCP_FLAG_URG);
    ASSERT(SEQ_EQ(RcvInfo->tri_seq, RcvTCB->tcb_rcvnext));

    // First, validate the urgent pointer.
    if (RcvTCB->tcb_flags & BSD_URGENT) {
        //
        // We're using BSD style urgent data.  We assume that the urgent
        // data is one byte long, and that the urgent pointer points one
        // after the urgent data instead of at the last byte of urgent data.
        // See if the urgent data is in this segment.
        //
        if (RcvInfo->tri_urgent == 0 || RcvInfo->tri_urgent > *Size) {
            //
            // Not in this segment.  Clear the urgent flag and return.
            //
            RcvInfo->tri_flags &= ~TCP_FLAG_URG;
            return;
        }

        UrgSize = 1;
        BytesInFront = RcvInfo->tri_urgent - 1;

    } else {
        //
        // This is not BSD style urgent.  We assume that the urgent data
        // starts at the front of the segment and the last byte is pointed
        // to by the urgent data pointer.
        //
        BytesInFront = 0;
        UrgSize = MIN(RcvInfo->tri_urgent + 1, *Size);
    }

    BytesInBack = *Size - BytesInFront - UrgSize;

    //
    // UrgStart and UrgEnd are the first and last sequence numbers of the
    // urgent data in this segment.
    //
    UrgStart = RcvInfo->tri_seq + BytesInFront;
    UrgEnd = UrgStart + UrgSize - 1;

    if (!(RcvTCB->tcb_flags & URG_INLINE)) {
        EndPkt = NULL;

        // Now see if this overlaps with any urgent data we've already seen.
        if (RcvTCB->tcb_flags & URG_VALID) {
            //
            // We have some urgent data still around.  See if we've advanced
            // rcvnext beyond the urgent data.  If we have, this is new urgent
            // data, and we can go ahead and process it (although anyone doing
            // an SIOCATMARK socket command might get confused).  If we haven't
            // consumed the data in front of the existing urgent data yet,
            // we'll truncate this seg. to that amount and push the rest onto
            // the reassembly queue.  Note that rcvnext should never fall
            // between tcb_urgstart and tcb_urgend.
            //
            ASSERT(SEQ_LT(RcvTCB->tcb_rcvnext, RcvTCB->tcb_urgstart) ||
                   SEQ_GT(RcvTCB->tcb_rcvnext, RcvTCB->tcb_urgend));

            if (SEQ_LT(RcvTCB->tcb_rcvnext, RcvTCB->tcb_urgstart)) {
                //
                // There appears to be some overlap in the data stream.
                // Split the buffer up into pieces that come before the current
                // urgent data and after the current urgent data, putting the
                // latter on the reassembly queue.
                //
                UrgSize = RcvTCB->tcb_urgend - RcvTCB->tcb_urgstart + 1;

                BytesInFront = MIN(RcvTCB->tcb_urgstart - RcvTCB->tcb_rcvnext,
                                   (int) *Size);

                if (SEQ_GT(RcvTCB->tcb_rcvnext + *Size, RcvTCB->tcb_urgend)) {
                    // We have data after this piece of urgent data.
                    BytesInBack = RcvTCB->tcb_rcvnext + *Size -
                        RcvTCB->tcb_urgend;
                } else
                    BytesInBack = 0;

                SplitPacket(RcvPkt, *Size, BytesInFront, UrgSize, NULL,
                            (BytesInBack ? &EndPkt : NULL));

                if (EndPkt != NULL) {
                    NewRcvInfo.tri_seq = RcvTCB->tcb_urgend + 1;
                    if (SEQ_GT(UrgEnd, RcvTCB->tcb_urgend)) {
                        NewRcvInfo.tri_flags = RcvInfo->tri_flags;
                        NewRcvInfo.tri_urgent = UrgEnd - NewRcvInfo.tri_seq;
                        if (RcvTCB->tcb_flags & BSD_URGENT)
                            NewRcvInfo.tri_urgent++;
                    } else {
                        NewRcvInfo.tri_flags = RcvInfo->tri_flags &
                            ~TCP_FLAG_URG;
                    }
                    NewRcvInfo.tri_ack = RcvInfo->tri_ack;
                    NewRcvInfo.tri_window = RcvInfo->tri_window;
                    PutOnRAQ(RcvTCB, &NewRcvInfo, EndPkt, BytesInBack);
                    FreePacketChain(EndPkt);
                }

                *Size = BytesInFront;
                RcvInfo->tri_flags &= ~TCP_FLAG_URG;
                return;
            }
        }

        //
        // We have urgent data we can process now.  Split it into its component
        // parts, the first part, the urgent data, and the stuff after the
        // urgent data.
        //
        SplitPacket(RcvPkt, *Size, BytesInFront, UrgSize, &UrgPkt,
                    (BytesInBack ? &EndPkt : NULL));

        //
        // If we managed to split out the end stuff, put it on the queue now.
        //
        if (EndPkt != NULL) {
            NewRcvInfo.tri_seq = RcvInfo->tri_seq + BytesInFront + UrgSize;
            NewRcvInfo.tri_flags = RcvInfo->tri_flags & ~TCP_FLAG_URG;
            NewRcvInfo.tri_ack = RcvInfo->tri_ack;
            NewRcvInfo.tri_window = RcvInfo->tri_window;
            PutOnRAQ(RcvTCB, &NewRcvInfo, EndPkt, BytesInBack);
            FreePacketChain(EndPkt);
        }

        if (UrgPkt != NULL) {
            // We succesfully split the urgent data out.
            if (!(RcvTCB->tcb_flags & URG_VALID)) {
                RcvTCB->tcb_flags |= URG_VALID;
                RcvTCB->tcb_slowcount++;
                RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                CheckTCBRcv(RcvTCB);
            }
            RcvTCB->tcb_urgstart = UrgStart;
            RcvTCB->tcb_urgend = UrgEnd;
            TCBIrql = DISPATCH_LEVEL;
            DeliverUrgent(RcvTCB, UrgPkt, UrgSize, &TCBIrql);
        }

        *Size = BytesInFront;

    } else {
        //
        // Urgent data is to be processed inline.  We just need to remember
        // where it is and treat it as normal data.  If there's already urgent
        // data, we remember the latest urgent data.
        //
        RcvInfo->tri_flags &= ~TCP_FLAG_URG;

        if (RcvTCB->tcb_flags & URG_VALID) {
            //
            // There is urgent data.  See if this stuff comes after the
            // existing urgent data.
            //
            if (SEQ_LTE(UrgEnd, RcvTCB->tcb_urgend)) {
                //
                // The existing urgent data completely overlaps this stuff,
                // so ignore this.
                //
                return;
            }
        } else {
            RcvTCB->tcb_flags |= URG_VALID;
            RcvTCB->tcb_slowcount++;
            RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
            CheckTCBRcv(RcvTCB);
        }

        RcvTCB->tcb_urgstart = UrgStart;
        RcvTCB->tcb_urgend = UrgEnd;
    }

    return;
}

//* TdiReceive - Process a receive request.
//
//  This is the main TDI receive request handler.  We validate the connection
//  and make sure that we have a TCB in the proper state, then we try to
//  allocate a receive request structure.  If that succeeds, we'll look and
//  see what's happening on the TCB - if there's pending data, we'll put it
//  in the buffer.  Otherwise we'll just queue the receive for later.
//
TDI_STATUS  // Returns: TDI_STATUS of request.
TdiReceive(
    PTDI_REQUEST Request,  // TDI_REQUEST structure for this request.
    ushort *Flags,         // Pointer to flags word.
    uint *RcvLength,       // Pointer to length in bytes of receive buffer.
    PNDIS_BUFFER Buffer)   // Pointer to buffer to take data.
{
    TCPConn *Conn;
    TCB *RcvTCB;
    TCPRcvReq *RcvReq;
    KIRQL Irql0, Irql1;  // One per lock nesting level.
    ushort UFlags;
    TDI_STATUS Status;

    Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext),
                             &Irql0);
    if (Conn == NULL) {
        //
        // No connection.
        //
        return TDI_INVALID_CONNECTION;
    }

    CHECK_STRUCT(Conn, tc);

    RcvTCB = Conn->tc_tcb;
    if (RcvTCB == NULL) {
        //
        // No TCB for connection.
        //
        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
        return TDI_INVALID_STATE;
    }

    CHECK_STRUCT(RcvTCB, tcb);
    KeAcquireSpinLock(&RcvTCB->tcb_lock, &Irql1);
    KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);
    UFlags = *Flags;

    //
    // Fail new receive requests for TCBs in an invalid state.
    //
    if (CLOSING(RcvTCB)) {
        Status = TDI_INVALID_STATE;
        goto done;
    }
    //
    // Also fail for TCBs that don't have any data available to
    // be read and have route over a disconnected outgoing interface
    // (except when a loopback route is being used).
    //
    if ((RcvTCB->tcb_pendingcnt == 0 || !(UFlags & TDI_RECEIVE_NORMAL)) &&
        (RcvTCB->tcb_urgcnt == 0 || !(UFlags & TDI_RECEIVE_EXPEDITED))) {
        //
        // We have no data waiting to give this type of receive request.
        // Check to see if our TCB is likely to get any more data.
        //
        if (!DATA_RCV_STATE(RcvTCB->tcb_state)) {
            Status = TDI_INVALID_STATE;
            goto done;
        }
            
        //
        // In order to verify that our outgoing interface hasn't become
        // disconnected, we need to know what route we are using.
        // If we've released our RCE for some reason, reacquire one.
        //
        if (RcvTCB->tcb_rce == NULL) {
            InitRCE(RcvTCB);
            if (RcvTCB->tcb_rce == NULL) {
                Status = TDI_DEST_NET_UNREACH;
                goto done;
            }
        }

        //
        // Verify that the cached RCE is still valid.
        //
        RcvTCB->tcb_rce = ValidateRCE(RcvTCB->tcb_rce, RcvTCB->tcb_nte);
        ASSERT(RcvTCB->tcb_rce != NULL);

        if (IsDisconnectedAndNotLoopbackRCE(RcvTCB->tcb_rce)) {
            Status = TDI_DEST_NET_UNREACH;
            goto done;
        }
    }

    CheckPacketList(RcvTCB->tcb_pendhead, RcvTCB->tcb_pendingcnt);

    //
    // We have a TCB, and it's valid.  Get a receive request now.
    //
    RcvReq = GetRcvReq();
    if (RcvReq == NULL) {
        //
        // Couldn't get a receive request.
        //
        Status = TDI_NO_RESOURCES;
        goto done;
    }

    RcvReq->trr_rtn = Request->RequestNotifyObject;
    RcvReq->trr_context = Request->RequestContext;
    RcvReq->trr_buffer = Buffer;
    RcvReq->trr_size = *RcvLength;
    RcvReq->trr_uflags = Flags;
    RcvReq->trr_offset = 0;
    RcvReq->trr_amt = 0;
    RcvReq->trr_flags = (uint)UFlags;

    if ((UFlags & (TDI_RECEIVE_NORMAL | TDI_RECEIVE_EXPEDITED))
        != TDI_RECEIVE_EXPEDITED) {
        //
        // This is not an expedited only receive.
        // Put it on the normal receive queue.
        //
        RcvReq->trr_next = NULL;
        if (RcvTCB->tcb_rcvhead == NULL) {
            // The receive queue is empty.
            // Put it on the front.
            RcvTCB->tcb_rcvhead = RcvReq;
            RcvTCB->tcb_rcvtail = RcvReq;
        } else {
            RcvTCB->tcb_rcvtail->trr_next = RcvReq;
            RcvTCB->tcb_rcvtail = RcvReq;
        }

        //
        // If this receive is for zero length, complete this
        // and indicate pending data again, if any.
        //
        if (RcvReq->trr_size == 0) {
            RcvTCB->tcb_refcnt++;
            RcvReq->trr_flags |= TRR_PUSHED;
            KeReleaseSpinLock(&RcvTCB->tcb_lock, Irql0);
            CompleteRcvs(RcvTCB);
            KeAcquireSpinLock(&RcvTCB->tcb_lock, &Irql0);
            DerefTCB(RcvTCB, Irql0);
            return TDI_PENDING;
        }

        //
        // Check to see if this receive can hold urgent data and also
        // if there is some urgent data pending.
        //
        if ((UFlags & TDI_RECEIVE_EXPEDITED) &&
            RcvTCB->tcb_urgcnt != 0) {
            //
            // This buffer can hold urgent data and we have
            // some pending.  Deliver it now.
            //
            RcvTCB->tcb_refcnt++;
            DeliverUrgent(RcvTCB, NULL, 0, &Irql0);
            DerefTCB(RcvTCB, Irql0);
            return TDI_PENDING;
        }

        //
        // Check to see if there is a currently active receive.
        //
        if (RcvTCB->tcb_currcv == NULL) {
            RcvTCB->tcb_currcv = RcvReq;
            //
            // No currently active receive.  Check to see if there is
            // pending data and that we are not currently in a receive
            // indication handler.  If both of these are true then deal
            // with the pending data.
            //
            if (RcvTCB->tcb_flags & IN_RCV_IND) {
                //
                // In a receive indication. The receive request
                // is now on the queue, so just fall through
                // to the return.
                //
            } else {
                //
                // Not in a receive indication.
                // Check for pending data.
                //
                RcvTCB->tcb_rcvhndlr = BufferData;
                if (RcvTCB->tcb_pendhead == NULL) {
                    //
                    // No pending data.
                    //
                    Status = TDI_PENDING;
                    goto done;
                } else {
                    IPv6Packet *PendPacket;
                    uint PendSize;
                    uint OldRcvWin;

                    //
                    // We have pending data to deal with.
                    //
                    PendPacket = RcvTCB->tcb_pendhead;
                    PendSize = RcvTCB->tcb_pendingcnt;
                    RcvTCB->tcb_pendhead = NULL;
                    RcvTCB->tcb_pendingcnt = 0;
                    RcvTCB->tcb_refcnt++;

                    //
                    // We assume that BufferData holds the lock (does not
                    // yield) during this call.  If this changes for some
                    // reason, we'll have to fix the code below that does
                    // the window update check.  See the comments in the
                    // BufferData() routine for more info.
                    //
                    (void)BufferData(RcvTCB, TCP_FLAG_PUSH, PendPacket,
                                     PendSize);
                    CheckTCBRcv(RcvTCB);

                    //
                    // Now we need to see if the window has changed.
                    // If it has, send an ACK.
                    //
                    OldRcvWin = RcvTCB->tcb_rcvwin;
                    if (OldRcvWin != RcvWin(RcvTCB)) {
                        //
                        // The window has changed, so send an ACK.
                        //
                        DelayAction(RcvTCB, NEED_ACK);
                    }

                    DerefTCB(RcvTCB, Irql0);
                    ProcessTCBDelayQ();
                    return TDI_PENDING;
                }
            }
        }

        //
        // A receive is currently active.  No need to do
        // anything else.
        //
        Status = TDI_PENDING;

    } else {
        TCPRcvReq *Temp;

        //
        // This is an expedited only receive.  Just put it
        // on the end of the expedited receive queue.
        //
        Temp = CONTAINING_RECORD(&RcvTCB->tcb_exprcv, TCPRcvReq, trr_next);
        while (Temp->trr_next != NULL)
            Temp = Temp->trr_next;

        RcvReq->trr_next = NULL;
        Temp->trr_next = RcvReq;

        if (RcvTCB->tcb_urgpending != NULL) {
            RcvTCB->tcb_refcnt++;
            DeliverUrgent(RcvTCB, NULL, 0, &Irql0);
            DerefTCB(RcvTCB, Irql0);
            return TDI_PENDING;
        }

        Status = TDI_PENDING;
    }

  done:
    KeReleaseSpinLock(&RcvTCB->tcb_lock, Irql0);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\tcp\tcpdeb.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// TCP debug code.
//
// This file contains the code for various TCP specific debug routines.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include "queue.h"
#include "transprt.h"
#include "tcp.h"
#include "tcpsend.h"

#if DBG

ULONG TCPDebug = 0;


//* CheckPacketList - Check a list of packets for the correct size.
//
//  A routine to walk a chain of packets, making sure the size
//  is what we think it is.
//
void                    // Returns: Nothing.
CheckPacketList(
    IPv6Packet *Chain,  // List of packets to check.
    uint Size)          // Total size all packets should sum to.
{
    uint SoFar = 0;

    while (Chain != NULL) {
        SoFar += Chain->TotalSize;
        Chain = Chain->Next;
    }

    ASSERT(Size == SoFar);
}


//* CheckTCBRcv - Check receives on a TCB.
//
//  Check the receive state of a TCB.
//
void                // Returns: Nothing.
CheckTCBRcv(
    TCB *CheckTCB)  // TCB to check.
{
    CHECK_STRUCT(CheckTCB, tcb);

    ASSERT(!(CheckTCB->tcb_flags & FLOW_CNTLD) ||
           (CheckTCB->tcb_sendwin == 0));

    if ((CheckTCB->tcb_fastchk & ~TCP_FLAG_IN_RCV) == TCP_FLAG_ACK) {
        ASSERT(CheckTCB->tcb_slowcount == 0);
        ASSERT(CheckTCB->tcb_state == TCB_ESTAB);
        ASSERT(CheckTCB->tcb_raq == NULL);
        ASSERT(!(CheckTCB->tcb_flags & TCP_SLOW_FLAGS));
        ASSERT(!CLOSING(CheckTCB));
    } else {
        ASSERT(CheckTCB->tcb_slowcount != 0);
        ASSERT((CheckTCB->tcb_state != TCB_ESTAB) ||
               (CheckTCB->tcb_raq != NULL) ||
               (CheckTCB->tcb_flags & TCP_SLOW_FLAGS) || CLOSING(CheckTCB));
    }
}


//* CheckTCBSends - Check the send status of a TCB.
//
//  A routine to check the send status of a TCB. We make sure that all
//  of the SendReqs make sense, as well as making sure that the send seq.
//  variables in the TCB are consistent.
//
void                // Returns: Nothing.
CheckTCBSends(
    TCB *CheckTCB)  // TCB to check.
{
    Queue *End, *Current;        // End and current elements.
    TCPSendReq *CurrentTSR;      // Current send req we're examining.
    uint Unacked;                // Number of unacked bytes.
    PNDIS_BUFFER CurrentBuffer;
    TCPSendReq *TCBTsr;          // Current send on TCB.
    uint FoundSendReq;

    CHECK_STRUCT(CheckTCB, tcb);

    // Don't check on unsynchronized TCBs.
    if (!SYNC_STATE(CheckTCB->tcb_state))
        return;

    ASSERT(SEQ_LTE(CheckTCB->tcb_senduna, CheckTCB->tcb_sendnext));
    ASSERT(SEQ_LTE(CheckTCB->tcb_sendnext, CheckTCB->tcb_sendmax));
    ASSERT(!(CheckTCB->tcb_flags & FIN_OUTSTANDING) ||
           (CheckTCB->tcb_sendnext == CheckTCB->tcb_sendmax));

    if (CheckTCB->tcb_unacked == 0) {
        ASSERT(CheckTCB->tcb_cursend == NULL);
        ASSERT(CheckTCB->tcb_sendsize == 0);
    }

    if (CheckTCB->tcb_sendbuf != NULL)
        ASSERT(CheckTCB->tcb_sendofs <
               NdisBufferLength(CheckTCB->tcb_sendbuf));

    TCBTsr = CheckTCB->tcb_cursend;
    FoundSendReq = (TCBTsr == NULL) ? TRUE : FALSE;

    End = QEND(&CheckTCB->tcb_sendq);
    Current = QHEAD(&CheckTCB->tcb_sendq);

    Unacked = 0;
    while (Current != End) {
        CurrentTSR = CONTAINING_RECORD(QSTRUCT(TCPReq, Current, tr_q),
                                       TCPSendReq, tsr_req);
        CHECK_STRUCT(CurrentTSR, tsr);

        if (CurrentTSR == TCBTsr)
            FoundSendReq = TRUE;

        ASSERT(CurrentTSR->tsr_unasize <= CurrentTSR->tsr_size);

        CurrentBuffer = CurrentTSR->tsr_buffer;
        ASSERT(CurrentBuffer != NULL);

        ASSERT(CurrentTSR->tsr_offset < NdisBufferLength(CurrentBuffer));

        Unacked += CurrentTSR->tsr_unasize;
        Current = QNEXT(Current);
    }

    ASSERT(FoundSendReq);

    ASSERT(Unacked == CheckTCB->tcb_unacked);
    Unacked += ((CheckTCB->tcb_flags & FIN_SENT) ? 1 : 0);
    ASSERT((CheckTCB->tcb_sendmax - CheckTCB->tcb_senduna) <=
           (int) Unacked);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\tcp\tcb.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Code for TCP Control Block management.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tcpsend.h"
#include "tcprcv.h"
#include "info.h"
#include "tcpcfg.h"
#include "tcpdeliv.h"
#include "route.h"

KSPIN_LOCK TCBTableLock;

uint TCPTime;
uint TCBWalkCount;

TCB **TCBTable;

TCB *LastTCB;

TCB *PendingFreeList;

SLIST_HEADER FreeTCBList;

KSPIN_LOCK FreeTCBListLock;  // Lock to protect TCB free list.

extern KSPIN_LOCK AddrObjTableLock;

extern SeqNum ISNMonotonicPortion;
extern int ISNCredits;
extern int ISNMaxCredits;
extern uint GetDeltaTime();


uint CurrentTCBs = 0;
uint FreeTCBs = 0;

uint MaxTCBs = 0xffffffff;

#define MAX_FREE_TCBS 1000

#define NUM_DEADMAN_TICKS MS_TO_TICKS(1000)

uint MaxFreeTCBs = MAX_FREE_TCBS;
uint DeadmanTicks;

KTIMER TCBTimer;
KDPC TCBTimeoutDpc;


//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA

int InitTCB(void);

#pragma alloc_text(INIT, InitTCB)

#endif // ALLOC_PRAGMA


//* ReadNextTCB - Read the next TCB in the table.
//
//  Called to read the next TCB in the table.  The needed information
//  is derived from the incoming context, which is assumed to be valid.
//  We'll copy the information, and then update the context value with
//  the next TCB to be read.
//
uint  // Returns: TRUE if more data is available to be read, FALSE is not.
ReadNextTCB(
    void *Context,  // Pointer to a TCPConnContext.
    void *Buffer)   // Pointer to a TCPConnTableEntry structure.
{
    TCPConnContext *TCContext = (TCPConnContext *)Context;
    TCP6ConnTableEntry *TCEntry = (TCP6ConnTableEntry *)Buffer;
    KIRQL OldIrql;
    TCB *CurrentTCB;
    uint i;

    CurrentTCB = TCContext->tcc_tcb;
    CHECK_STRUCT(CurrentTCB, tcb);

    KeAcquireSpinLock(&CurrentTCB->tcb_lock, &OldIrql);
    if (CLOSING(CurrentTCB))
        TCEntry->tct_state = TCP_CONN_CLOSED;
    else
        TCEntry->tct_state = (uint)CurrentTCB->tcb_state + TCB_STATE_DELTA;
    TCEntry->tct_localaddr = CurrentTCB->tcb_saddr;
    TCEntry->tct_localscopeid = CurrentTCB->tcb_sscope_id;
    TCEntry->tct_localport = CurrentTCB->tcb_sport;
    TCEntry->tct_remoteaddr = CurrentTCB->tcb_daddr;
    TCEntry->tct_remotescopeid = CurrentTCB->tcb_dscope_id;
    TCEntry->tct_remoteport = CurrentTCB->tcb_dport;
    TCEntry->tct_owningpid = (CurrentTCB->tcb_conn) ?
            CurrentTCB->tcb_conn->tc_owningpid : 0;
    KeReleaseSpinLock(&CurrentTCB->tcb_lock, OldIrql);

    // We've filled it in. Now update the context.
    if (CurrentTCB->tcb_next != NULL) {
        TCContext->tcc_tcb = CurrentTCB->tcb_next;
        return TRUE;
    } else {
        // NextTCB is NULL. Loop through the TCBTable looking for a new one.
        i = TCContext->tcc_index + 1;
        while (i < TcbTableSize) {
            if (TCBTable[i] != NULL) {
                TCContext->tcc_tcb = TCBTable[i];
                TCContext->tcc_index = i;
                return TRUE;
                break;
            } else
                i++;
        }

        TCContext->tcc_index = 0;
        TCContext->tcc_tcb = NULL;
        return FALSE;
    }
}


//* ValidateTCBContext - Validate the context for reading a TCB table.
//
//  Called to start reading the TCB table sequentially.  We take in
//  a context, and if the values are 0 we return information about the
//  first TCB in the table.  Otherwise we make sure that the context value
//  is valid, and if it is we return TRUE.
//  We assume the caller holds the TCB table lock.
//
//  Upon return, *Valid is set to true if the context is valid.
//
uint                // Returns: TRUE if data in table, FALSE if not.
ValidateTCBContext(
    void *Context,  // Pointer to a TCPConnContext.
    uint *Valid)    // Where to return infoformation about context being valid.
{
    TCPConnContext *TCContext = (TCPConnContext *)Context;
    uint i;
    TCB *TargetTCB;
    TCB *CurrentTCB;

    i = TCContext->tcc_index;
    TargetTCB = TCContext->tcc_tcb;

    //
    // If the context values are 0 and NULL, we're starting from the beginning.
    //
    if (i == 0 && TargetTCB == NULL) {
        *Valid = TRUE;
        do {
            if ((CurrentTCB = TCBTable[i]) != NULL) {
                CHECK_STRUCT(CurrentTCB, tcb);
                break;
            }
            i++;
        } while (i < TcbTableSize);

        if (CurrentTCB != NULL) {
            TCContext->tcc_index = i;
            TCContext->tcc_tcb = CurrentTCB;
            return TRUE;
        } else
            return FALSE;

    } else {
        //
        // We've been given a context.  We just need to make sure that it's
        // valid.
        //
        if (i < TcbTableSize) {
            CurrentTCB = TCBTable[i];
            while (CurrentTCB != NULL) {
                if (CurrentTCB == TargetTCB) {
                    *Valid = TRUE;
                    return TRUE;
                    break;
                } else {
                    CurrentTCB = CurrentTCB->tcb_next;
                }
            }

        }

        // If we get here, we didn't find the matching TCB.
        *Valid = FALSE;
        return FALSE;
    }
}


//* FindNextTCB - Find the next TCB in a particular chain.
//
//  This routine is used to find the 'next' TCB in a chain.  Since we keep
//  the chain in ascending order, we look for a TCB which is greater than
//  the input TCB.  When we find one, we return it.
//
//  This routine is mostly used when someone is walking the table and needs
//  to free the various locks to perform some action.
//
TCB *              // Returns: Pointer to the next TCB, or NULL.
FindNextTCB(
    uint Index,    // Index into TCBTable.
    TCB *Current)  // Current TCB - we find the one after this one.
{
    TCB *Next;

    ASSERT(Index < TcbTableSize);

    Next = TCBTable[Index];

    while (Next != NULL && (Next <= Current))
        Next = Next->tcb_next;

    return Next;
}


//* ResetSendNext - Set the sendnext value of a TCB.
//
//  Called to set the send next value of a TCB.  We do that, and adjust all
//  pointers to the appropriate places.  We assume the caller holds the lock
//  on the TCB.
//
void  // Returns: Nothing.
ResetSendNext(
    TCB *SeqTCB,    // TCB to be updated.
    SeqNum NewSeq)  // Sequence number to set.
{
    TCPSendReq *SendReq;
    uint AmtForward;
    Queue *CurQ;
    PNDIS_BUFFER Buffer;
    uint Offset;

    CHECK_STRUCT(SeqTCB, tcb);
    ASSERT(SEQ_GTE(NewSeq, SeqTCB->tcb_senduna));

    //
    // The new seq must be less than send max, or NewSeq, senduna, sendnext,
    // and sendmax must all be equal (the latter case happens when we're
    // called exiting TIME_WAIT, or possibly when we're retransmitting
    // during a flow controlled situation).
    //
    ASSERT(SEQ_LT(NewSeq, SeqTCB->tcb_sendmax) ||
           (SEQ_EQ(SeqTCB->tcb_senduna, SeqTCB->tcb_sendnext) &&
            SEQ_EQ(SeqTCB->tcb_senduna, SeqTCB->tcb_sendmax) &&
            SEQ_EQ(SeqTCB->tcb_senduna, NewSeq)));

    AmtForward = NewSeq - SeqTCB->tcb_senduna;

    if ((AmtForward == 1) && (SeqTCB->tcb_flags & FIN_SENT) &&
        !((SeqTCB->tcb_sendnext - SeqTCB->tcb_senduna) > 1) &&
        (SEQ_EQ(SeqTCB->tcb_sendnext,SeqTCB->tcb_sendmax))) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_RARE,
                   "tcpip6: trying to set sendnext for FIN_SENT\n"));
        SeqTCB->tcb_sendnext = NewSeq;
        SeqTCB->tcb_flags &= ~FIN_OUTSTANDING;
        return;
    }
    if((SeqTCB->tcb_flags & FIN_SENT) &&
       (SEQ_EQ(SeqTCB->tcb_sendnext,SeqTCB->tcb_sendmax)) &&
       ((SeqTCB->tcb_sendnext - NewSeq) == 1) ){

        //
        // There is only FIN that is left beyond sendnext.
        //
        SeqTCB->tcb_sendnext = NewSeq;
        SeqTCB->tcb_flags &= ~FIN_OUTSTANDING;
        return;
    }


    SeqTCB->tcb_sendnext = NewSeq;

    //
    // If we're backing off send next, turn off the FIN_OUTSTANDING flag to
    // maintain a consistent state.
    //
    if (!SEQ_EQ(NewSeq, SeqTCB->tcb_sendmax))
        SeqTCB->tcb_flags &= ~FIN_OUTSTANDING;

    if (SYNC_STATE(SeqTCB->tcb_state) && SeqTCB->tcb_state != TCB_TIME_WAIT) {
        //
        // In these states we need to update the send queue.
        //

        if (!EMPTYQ(&SeqTCB->tcb_sendq)) {
            CurQ = QHEAD(&SeqTCB->tcb_sendq);

            SendReq = (TCPSendReq *)CONTAINING_RECORD(CurQ, TCPReq, tr_q);

            //
            // SendReq points to the first send request on the send queue.
            // Move forward AmtForward bytes on the send queue, and set the
            // TCB pointers to the resultant SendReq, buffer, offset, size.
            //
            while (AmtForward) {

                CHECK_STRUCT(SendReq, tsr);

                if (AmtForward >= SendReq->tsr_unasize) {
                    //
                    // We're going to move completely past this one.  Subtract
                    // his size from AmtForward and get the next one.
                    //
                    AmtForward -= SendReq->tsr_unasize;
                    CurQ = QNEXT(CurQ);
                    ASSERT(CurQ != QEND(&SeqTCB->tcb_sendq));
                    SendReq = (TCPSendReq *)CONTAINING_RECORD(CurQ, TCPReq,
                                                              tr_q);
                } else {
                    //
                    // We're pointing at the proper send req now.  Break out
                    // of this loop and save the information.  Further down
                    // we'll need to walk down the buffer chain to find
                    // the proper buffer and offset.
                    //
                    break;
                }
            }

            //
            // We're pointing at the proper send req now.  We need to go down
            // the buffer chain here to find the proper buffer and offset.
            //
            SeqTCB->tcb_cursend = SendReq;
            SeqTCB->tcb_sendsize = SendReq->tsr_unasize - AmtForward;
            Buffer = SendReq->tsr_buffer;
            Offset = SendReq->tsr_offset;

            while (AmtForward) {
                // Walk the buffer chain.
                uint Length;

                //
                // We'll need the length of this buffer.  Use the portable
                // macro to get it.  We have to adjust the length by the offset
                // into it, also.
                //
                ASSERT((Offset < NdisBufferLength(Buffer)) ||
                       ((Offset == 0) && (NdisBufferLength(Buffer) == 0)));

                Length = NdisBufferLength(Buffer) - Offset;

                if (AmtForward >= Length) {
                    //
                    // We're moving past this one.  Skip over him, and 0 the
                    // Offset we're keeping.
                    //
                    AmtForward -= Length;
                    Offset = 0;
                    Buffer = NDIS_BUFFER_LINKAGE(Buffer);
                    ASSERT(Buffer != NULL);
                } else
                    break;
            }

            //
            // Save the buffer we found, and the offset into that buffer.
            //
            SeqTCB->tcb_sendbuf = Buffer;
            SeqTCB->tcb_sendofs = Offset + AmtForward;

        } else {
            ASSERT(SeqTCB->tcb_cursend == NULL);
            ASSERT(AmtForward == 0);
        }
    }

    CheckTCBSends(SeqTCB);
}


//* TCPAbortAndIndicateDisconnect
//
//  Abortively closes a TCB and issues a disconnect indication up to the
//  transport user.  This function is used to support cancellation of
//  TDI send and receive requests.
//
void  // Returns: Nothing.
TCPAbortAndIndicateDisconnect(
    CONNECTION_CONTEXT ConnectionContext  // Connection ID to find a TCB for.
    )
{
    TCB *AbortTCB;
    KIRQL Irql0, Irql1;  // One per lock nesting level.
    TCPConn *Conn;

    Conn = GetConnFromConnID(PtrToUlong(ConnectionContext), &Irql0);

    if (Conn != NULL) {
        CHECK_STRUCT(Conn, tc);

        AbortTCB = Conn->tc_tcb;

        if (AbortTCB != NULL) {
            //
            // If it's CLOSING or CLOSED, skip it.
            //
            if ((AbortTCB->tcb_state != TCB_CLOSED) && !CLOSING(AbortTCB)) {
                CHECK_STRUCT(AbortTCB, tcb);
                KeAcquireSpinLock(&AbortTCB->tcb_lock, &Irql1);
                KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql1);

                if (AbortTCB->tcb_state == TCB_CLOSED || CLOSING(AbortTCB)) {
                    KeReleaseSpinLock(&AbortTCB->tcb_lock, Irql0);
                    return;
                }

                AbortTCB->tcb_refcnt++;
                AbortTCB->tcb_flags |= NEED_RST;  // send a reset if connected
                TryToCloseTCB(AbortTCB, TCB_CLOSE_ABORTED, Irql0);

                RemoveTCBFromConn(AbortTCB);

                IF_TCPDBG(TCP_DEBUG_IRP) {
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                        "TCPAbortAndIndicateDisconnect, indicating discon\n"));
                }

                NotifyOfDisc(AbortTCB, TDI_CONNECTION_ABORTED, NULL);

                KeAcquireSpinLock(&AbortTCB->tcb_lock, &Irql0);
                DerefTCB(AbortTCB, Irql0);

                // TCB lock freed by DerefTCB.

                return;
            } else
                KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
        } else
            KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, Irql0);
    }
}


//* TCBTimeout - Do timeout events on TCBs.
//
//  Called every MS_PER_TICKS milliseconds to do timeout processing on TCBs.
//  We run throught the TCB table, decrementing timers.  If one goes to zero
//  we look at its state to decide what to do.
//
void  // Returns: Nothing.
TCBTimeout(
    PKDPC MyDpcObject,  // The DPC object describing this routine.
    void *Context,      // The argument we asked to be called with.
    void *Unused1,
    void *Unused2)
{
    uint i;
    TCB *CurrentTCB;
    uint Delayed = FALSE;
    uint CallRcvComplete;
    int Delta;

    UNREFERENCED_PARAMETER(MyDpcObject);
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Unused1);
    UNREFERENCED_PARAMETER(Unused2);

    //
    // Update our free running counter.
    //
    TCPTime++;

    ExInterlockedAddUlong((PULONG)&TCBWalkCount, 1, &TCBTableLock);

    // 
    // Set credits so that some more connections can increment the 
    // Initial Sequence Number, during the next 100 ms.
    //
    InterlockedExchange((PLONG)&ISNCredits, ISNMaxCredits);

    Delta = GetDeltaTime();

    //
    // The increment made is (256)*(Time in milliseconds). This is really close
    // to 25000 increment made originally every 100 ms.
    //
    if (Delta > 0) {
        Delta *= 0x100;
        InterlockedExchangeAdd((PLONG)&ISNMonotonicPortion, Delta);
    }

    //
    // Loop through each bucket in the table, going down the chain of
    // TCBs on the bucket.
    //
    for (i = 0; i < TcbTableSize; i++) {
        TCB *TempTCB;
        uint maxRexmitCnt;

        CurrentTCB = TCBTable[i];

        while (CurrentTCB != NULL) {
            CHECK_STRUCT(CurrentTCB, tcb);
            KeAcquireSpinLockAtDpcLevel(&CurrentTCB->tcb_lock);

            //
            // If it's CLOSING or CLOSED, skip it.
            //
            if (CurrentTCB->tcb_state == TCB_CLOSED || CLOSING(CurrentTCB)) {
                TempTCB = CurrentTCB->tcb_next;
                KeReleaseSpinLockFromDpcLevel(&CurrentTCB->tcb_lock);
                CurrentTCB = TempTCB;
                continue;
            }

            CheckTCBSends(CurrentTCB);
            CheckTCBRcv(CurrentTCB);

            //
            // First check the rexmit timer.
            //
            if (TCB_TIMER_RUNNING(CurrentTCB->tcb_rexmittimer)) {
                //
                // The timer is running.
                //
                if (--(CurrentTCB->tcb_rexmittimer) == 0) {
                    //
                    // And it's fired. Figure out what to do now.
                    //

                    if ((CurrentTCB->tcb_state == TCB_SYN_SENT) || 
                        (CurrentTCB->tcb_state == TCB_SYN_RCVD)) {
                        maxRexmitCnt = MaxConnectRexmitCount;
                    } else {
                        maxRexmitCnt = MaxDataRexmitCount;
                    }

                    //
                    // If we've run out of retransmits or we're in FIN_WAIT2,
                    // time out.
                    //
                    CurrentTCB->tcb_rexmitcnt++;
                    if (CurrentTCB->tcb_rexmitcnt > maxRexmitCnt) {

                        ASSERT(CurrentTCB->tcb_state > TCB_LISTEN);

                        //
                        // This connection has timed out.  Abort it.  First
                        // reference him, then mark as closed, notify the
                        // user, and finally dereference and close him.
                        //
TimeoutTCB:
                        CurrentTCB->tcb_refcnt++;
                        TryToCloseTCB(CurrentTCB, TCB_CLOSE_TIMEOUT,
                                      DISPATCH_LEVEL);

                        RemoveTCBFromConn(CurrentTCB);
                        NotifyOfDisc(CurrentTCB, TDI_TIMED_OUT, NULL);

                        KeAcquireSpinLockAtDpcLevel(&CurrentTCB->tcb_lock);
                        DerefTCB(CurrentTCB, DISPATCH_LEVEL);

                        CurrentTCB = FindNextTCB(i, CurrentTCB);
                        continue;
                    }

                    //
                    // Stop round trip time measurement.
                    //
                    CurrentTCB->tcb_rtt = 0;

                    //
                    // Figure out what our new retransmit timeout should be.
                    // We double it each time we get a retransmit, and reset it
                    // back when we get an ack for new data.
                    //
                    CurrentTCB->tcb_rexmit = MIN(CurrentTCB->tcb_rexmit << 1,
                                                 MAX_REXMIT_TO);

                    //
                    // Reset the sequence number, and reset the congestion
                    // window.
                    //
                    ResetSendNext(CurrentTCB, CurrentTCB->tcb_senduna);

                    if (!(CurrentTCB->tcb_flags & FLOW_CNTLD)) {
                        //
                        // Don't let the slow start threshold go below 2
                        // segments.
                        //
                        CurrentTCB->tcb_ssthresh =
                            MAX(MIN(CurrentTCB->tcb_cwin,
                                    CurrentTCB->tcb_sendwin) / 2,
                                (uint) CurrentTCB->tcb_mss * 2);
                        CurrentTCB->tcb_cwin = CurrentTCB->tcb_mss;
                    } else {
                        //
                        // We're probing, and the probe timer has fired.  We
                        // need to set the FORCE_OUTPUT bit here.
                        //
                        CurrentTCB->tcb_flags |= FORCE_OUTPUT;
                    }

                    //
                    // See if we need to probe for a PMTU black hole.
                    //
                    if (PMTUBHDetect &&
                        CurrentTCB->tcb_rexmitcnt == ((maxRexmitCnt+1)/2)) {
                        //
                        // We may need to probe for a black hole.  If we're
                        // doing MTU discovery on this connection and we
                        // are retransmitting more than a minimum segment
                        // size, or we are probing for a PMTU BH already,
                        // bump the probe count.  If the probe count gets
                        // too big we'll assume it's not a PMTU black hole,
                        // and we'll try to switch the router.
                        //
                        if ((CurrentTCB->tcb_flags & PMTU_BH_PROBE) ||
                            (CurrentTCB->tcb_sendmax - CurrentTCB->tcb_senduna
                             > 8)) {
                            //
                            // May need to probe.  If we haven't exceeded our
                            // probe count, do so, otherwise restore those
                            // values.
                            //
                            if (CurrentTCB->tcb_bhprobecnt++ < 2) {
                                //
                                // We're going to probe.  Turn on the flag,
                                // drop the MSS, and turn off the don't
                                // fragment bit.
                                //
                                if (!(CurrentTCB->tcb_flags & PMTU_BH_PROBE)) {
                                    CurrentTCB->tcb_flags |= PMTU_BH_PROBE;
                                    CurrentTCB->tcb_slowcount++;
                                    CurrentTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                                    //
                                    // Drop the MSS to the minimum.
                                    //
                                    CurrentTCB->tcb_mss =
                                        MIN(DEFAULT_MSS,
                                            CurrentTCB->tcb_remmss);

                                    ASSERT(CurrentTCB->tcb_mss > 0);

                                    CurrentTCB->tcb_cwin = CurrentTCB->tcb_mss;
                                }

                                //
                                // Drop the rexmit count so we come here again.
                                //
                                CurrentTCB->tcb_rexmitcnt--;
                            } else {
                                //
                                // Too many probes.  Stop probing, and allow
                                // fallover to the next gateway.
                                //
                                // Currently this code won't do BH probing on
                                // the 2nd gateway.  The MSS will stay at the
                                // minimum size.  This might be a little
                                // suboptimal, but it's easy to implement for
                                // the Sept. 95 service pack and will keep
                                // connections alive if possible.
                                //
                                // In the future we should investigate doing
                                // dead g/w detect on a per-connection basis,
                                // and then doing PMTU probing for each
                                // connection.
                                //
                                if (CurrentTCB->tcb_flags & PMTU_BH_PROBE) {
                                    CurrentTCB->tcb_flags &= ~PMTU_BH_PROBE;
                                    if (--(CurrentTCB->tcb_slowcount) == 0)
                                        CurrentTCB->tcb_fastchk &=
                                            ~TCP_FLAG_SLOW;
                                }
                                CurrentTCB->tcb_bhprobecnt = 0;
                            }
                        }
                    }

                    //
                    // Now handle the various cases.
                    //
                    switch (CurrentTCB->tcb_state) {

                    case TCB_SYN_SENT:
                    case TCB_SYN_RCVD:
                        //
                        // In SYN-SENT or SYN-RCVD we'll need to retransmit
                        // the SYN.
                        //
                        SendSYN(CurrentTCB, DISPATCH_LEVEL);
                        CurrentTCB = FindNextTCB(i, CurrentTCB);
                        continue;

                    case TCB_FIN_WAIT1:
                    case TCB_CLOSING:
                    case TCB_LAST_ACK:
                        //
                        // The call to ResetSendNext (above) will have
                        // turned off the FIN_OUTSTANDING flag.
                        //
                        CurrentTCB->tcb_flags |= FIN_NEEDED;

                    case TCB_CLOSE_WAIT:
                    case TCB_ESTAB:
                        //
                        // In this state we have data to retransmit, unless
                        // the window is zero (in which case we need to
                        // probe), or we're just sending a FIN.
                        //
                        CheckTCBSends(CurrentTCB);

                        //
                        // Since we're retransmitting, our first-hop router
                        // may be down.  Tell IP we're suspicious if this
                        // is the first retransmit.
                        //
                        if (CurrentTCB->tcb_rexmitcnt == 1 &&
                            CurrentTCB->tcb_rce != NULL) {
                            ForwardReachabilityInDoubt(CurrentTCB->tcb_rce);
                        }

                        Delayed = TRUE;
                        DelayAction(CurrentTCB, NEED_OUTPUT);
                        break;

                    case TCB_TIME_WAIT:
                        //
                        // If it's fired in TIME-WAIT, we're all done and
                        // can clean up.  We'll call TryToCloseTCB even
                        // though he's already sort of closed.  TryToCloseTCB
                        // will figure this out and do the right thing.
                        //
                        TryToCloseTCB(CurrentTCB, TCB_CLOSE_SUCCESS,
                                      DISPATCH_LEVEL);
                        CurrentTCB = FindNextTCB(i, CurrentTCB);
                        continue;

                    default:
                        break;
                    }
                }
            }

            //
            // Now check the SWS deadlock timer..
            //
            if (TCB_TIMER_RUNNING(CurrentTCB->tcb_swstimer)) {
                //
                // The timer is running.
                //
                if (--(CurrentTCB->tcb_swstimer) == 0) {
                    //
                    // And it's fired. Force output now.
                    //
                    CurrentTCB->tcb_flags |= FORCE_OUTPUT;
                    Delayed = TRUE;
                    DelayAction(CurrentTCB, NEED_OUTPUT);
                }
            }

            //
            // Check the push data timer.
            //
            if (TCB_TIMER_RUNNING(CurrentTCB->tcb_pushtimer)) {
                //
                // The timer is running. Decrement it.
                //
                if (--(CurrentTCB->tcb_pushtimer) == 0) {
                    //
                    // It's fired.
                    //
                    PushData(CurrentTCB);
                    Delayed = TRUE;
                }
            }

            //
            // Check the delayed ack timer.
            //
            if (TCB_TIMER_RUNNING(CurrentTCB->tcb_delacktimer)) {
                //
                // The timer is running.
                //
                if (--(CurrentTCB->tcb_delacktimer) == 0) {
                    //
                    // And it's fired.  Set up to send an ACK.
                    //
                    Delayed = TRUE;
                    DelayAction(CurrentTCB, NEED_ACK);
                }
            }

            //
            // Finally check the keepalive timer.
            //
            if (CurrentTCB->tcb_state == TCB_ESTAB) {
                if ((CurrentTCB->tcb_flags & KEEPALIVE) &&
                    (CurrentTCB->tcb_conn != NULL)) {
                    uint Delta;

                    Delta = TCPTime - CurrentTCB->tcb_alive;
                    if (Delta > CurrentTCB->tcb_conn->tc_tcbkatime) {
                        Delta -= CurrentTCB->tcb_conn->tc_tcbkatime;
                        if (Delta > (CurrentTCB->tcb_kacount * CurrentTCB->tcb_conn->tc_tcbkainterval)) {
                            if (CurrentTCB->tcb_kacount < MaxDataRexmitCount) {
                                SendKA(CurrentTCB, DISPATCH_LEVEL);
                                CurrentTCB = FindNextTCB(i, CurrentTCB);
                                continue;
                            } else
                                goto TimeoutTCB;
                        }
                    } else
                        CurrentTCB->tcb_kacount = 0;
                }
            }

            //
            // If this is an active open connection in SYN-SENT or SYN-RCVD,
            // or we have a FIN pending, check the connect timer.
            //
            if (CurrentTCB->tcb_flags &
                (ACTIVE_OPEN | FIN_NEEDED | FIN_SENT)) {
                TCPConnReq *ConnReq = CurrentTCB->tcb_connreq;

                ASSERT(ConnReq != NULL);
                if (TCB_TIMER_RUNNING(ConnReq->tcr_timeout)) {
                    // Timer is running.
                    if (--(ConnReq->tcr_timeout) == 0) {
                        // The connection timer has timed out.
                        TryToCloseTCB(CurrentTCB, TCB_CLOSE_TIMEOUT,
                                      DISPATCH_LEVEL);
                        CurrentTCB = FindNextTCB(i, CurrentTCB);
                        continue;
                    }
                }
            }

            //
            // Timer isn't running, or didn't fire.
            //
            TempTCB = CurrentTCB->tcb_next;
            KeReleaseSpinLockFromDpcLevel(&CurrentTCB->tcb_lock);
            CurrentTCB = TempTCB;
        }
    }

    //
    // See if we need to call receive complete as part of deadman processing.
    // We do this now because we want to restart the timer before calling
    // receive complete, in case that takes a while.  If we make this check
    // while the timer is running we'd have to lock, so we'll check and save
    // the result now before we start the timer.
    //
    if (DeadmanTicks == TCPTime) {
        CallRcvComplete = TRUE;
        DeadmanTicks += NUM_DEADMAN_TICKS;
    } else
        CallRcvComplete = FALSE;

    //
    // Now check the pending free list.  If it's not null, walk down the
    // list and decrement the walk count.  If the count goes below 2, pull it
    // from the list.  If the count goes to 0, free the TCB.  If the count is
    // at 1 it'll be freed by whoever called RemoveTCB.
    //
    KeAcquireSpinLockAtDpcLevel(&TCBTableLock);
    if (PendingFreeList != NULL) {
        TCB *PrevTCB;

        PrevTCB = CONTAINING_RECORD(&PendingFreeList, TCB, tcb_delayq.q_next);

        do {
            CurrentTCB = (TCB *)PrevTCB->tcb_delayq.q_next;

            CHECK_STRUCT(CurrentTCB, tcb);

            CurrentTCB->tcb_walkcount--;
            if (CurrentTCB->tcb_walkcount <= 1) {
                *(TCB **)&PrevTCB->tcb_delayq.q_next =
                    (TCB *)CurrentTCB->tcb_delayq.q_next;

                if (CurrentTCB->tcb_walkcount == 0) {
                    FreeTCB(CurrentTCB);
                }
            } else {
                PrevTCB = CurrentTCB;
            }
        } while (PrevTCB->tcb_delayq.q_next != NULL);
    }

    TCBWalkCount--;
    KeReleaseSpinLockFromDpcLevel(&TCBTableLock);

    if (Delayed)
        ProcessTCBDelayQ();

    if (CallRcvComplete)
        TCPRcvComplete();
}


//* TCBWalk - Walk the TCBs in the table, and call a function for each of them.
//
//  Called when we need to repetively do something to each TCB in the table.
//  We call the specified function with a pointer to the TCB and the input
//  context for each TCB in the table.  If the function returns FALSE, we
//  delete the TCB.
//
void  // Returns: Nothing.
TCBWalk(
    uint (*CallRtn)(struct TCB *, void *, void *, void *),  // Routine to call.
    void *Context1,  // Context to pass to CallRtn.
    void *Context2,  // Second context to pass to call routine.
    void *Context3)  // Third context to pass to call routine.
{
    uint i;
    TCB *CurTCB;
    KIRQL Irql0, Irql1;

    //
    // Loop through each bucket in the table, going down the chain of
    // TCBs on the bucket.  For each one call CallRtn.
    //
    KeAcquireSpinLock(&TCBTableLock, &Irql0);

    for (i = 0; i < TcbTableSize; i++) {

        CurTCB = TCBTable[i];

        //
        // Walk down the chain on this bucket.
        //
        while (CurTCB != NULL) {
            if (!(*CallRtn)(CurTCB, Context1, Context2, Context3)) {
                //
                // Call failed on this one.
                // Notify the client and close the TCB.
                //
                KeAcquireSpinLock(&CurTCB->tcb_lock, &Irql1);
                if (!CLOSING(CurTCB)) {
                    CurTCB->tcb_refcnt++;
                    KeReleaseSpinLock(&TCBTableLock, Irql1);
                    TryToCloseTCB(CurTCB, TCB_CLOSE_ABORTED, Irql0);

                    RemoveTCBFromConn(CurTCB);
                    if (CurTCB->tcb_state != TCB_TIME_WAIT)
                        NotifyOfDisc(CurTCB, TDI_CONNECTION_ABORTED, NULL);

                    KeAcquireSpinLock(&CurTCB->tcb_lock, &Irql0);
                    DerefTCB(CurTCB, Irql0);
                    KeAcquireSpinLock(&TCBTableLock, &Irql0);
                } else
                    KeReleaseSpinLock(&CurTCB->tcb_lock, Irql1);

                CurTCB = FindNextTCB(i, CurTCB);
            } else {
                CurTCB = CurTCB->tcb_next;
            }
        }
    }

    KeReleaseSpinLock(&TCBTableLock, Irql0);
}

//* FindTCB - Find a TCB in the tcb table.
//
//  Called when we need to find a TCB in the TCB table.  We take a quick
//  look at the last TCB we found, and if it matches we return it.  Otherwise
//  we hash into the TCB table and look for it.  We assume the TCB table lock
//  is held when we are called.
//
TCB *  // Returns: Pointer to TCB found, or NULL if none.
FindTCB(
    IPv6Addr *Src,     // Source IP address of TCB to be found.
    IPv6Addr *Dest,    // Destination IP address of TCB to be found.
    uint SrcScopeId,   // Source address scope identifier.
    uint DestScopeId,  // Destination address scope identifier.
    ushort SrcPort,    // Source port of TCB to be found.
    ushort DestPort)   // Destination port of TCB to be found.
{
    TCB *FoundTCB;

    if (LastTCB != NULL) {
        CHECK_STRUCT(LastTCB, tcb);
        if (IP6_ADDR_EQUAL(&LastTCB->tcb_daddr, Dest) &&
            LastTCB->tcb_dscope_id == DestScopeId &&
            LastTCB->tcb_dport == DestPort &&
            IP6_ADDR_EQUAL(&LastTCB->tcb_saddr, Src) &&
            LastTCB->tcb_sscope_id == SrcScopeId &&
            LastTCB->tcb_sport == SrcPort)
            return LastTCB;
    }

    //
    // Didn't find it in our 1 element cache.
    //
    FoundTCB = TCBTable[TCB_HASH(*Dest, *Src, DestPort, SrcPort)];
    while (FoundTCB != NULL) {
        CHECK_STRUCT(FoundTCB, tcb);
        if (IP6_ADDR_EQUAL(&FoundTCB->tcb_daddr, Dest) &&
            FoundTCB->tcb_dscope_id == DestScopeId &&
            FoundTCB->tcb_dport == DestPort &&
            IP6_ADDR_EQUAL(&FoundTCB->tcb_saddr, Src) &&
            FoundTCB->tcb_sscope_id == SrcScopeId &&
            FoundTCB->tcb_sport == SrcPort) {

            //
            // Found it.  Update the cache for next time, and return.
            //
            LastTCB = FoundTCB;
            return FoundTCB;
        } else
            FoundTCB = FoundTCB->tcb_next;
    }

    return FoundTCB;
}


//* InsertTCB - Insert a TCB in the tcb table.
//
//  This routine inserts a TCB in the TCB table. No locks need to be held
//  when this routine is called. We insert TCBs in ascending address order.
//  Before inserting we make sure that the TCB isn't already in the table.
//
uint              // Returns: TRUE if we inserted, false if we didn't.
InsertTCB(
    TCB *NewTCB)  // TCB to be inserted.
{
    uint TCBIndex;
    KIRQL OldIrql;
    TCB *PrevTCB, *CurrentTCB;
    TCB *WhereToInsert;

    ASSERT(NewTCB != NULL);
    CHECK_STRUCT(NewTCB, tcb);
    TCBIndex = TCB_HASH(NewTCB->tcb_daddr, NewTCB->tcb_saddr,
                        NewTCB->tcb_dport, NewTCB->tcb_sport);

    KeAcquireSpinLock(&TCBTableLock, &OldIrql);
    KeAcquireSpinLockAtDpcLevel(&NewTCB->tcb_lock);

    //
    // Find the proper place in the table to insert him.  While
    // we're walking we'll check to see if a dupe already exists.
    // When we find the right place to insert, we'll remember it, and
    // keep walking looking for a duplicate.
    //
    PrevTCB = CONTAINING_RECORD(&TCBTable[TCBIndex], TCB, tcb_next);
    WhereToInsert = NULL;

    while (PrevTCB->tcb_next != NULL) {
        CurrentTCB = PrevTCB->tcb_next;

        if (IP6_ADDR_EQUAL(&CurrentTCB->tcb_daddr, &NewTCB->tcb_daddr) &&
            IP6_ADDR_EQUAL(&CurrentTCB->tcb_saddr, &NewTCB->tcb_saddr) &&
            (CurrentTCB->tcb_dscope_id == NewTCB->tcb_dscope_id) &&
            (CurrentTCB->tcb_sscope_id == NewTCB->tcb_sscope_id) &&
            (CurrentTCB->tcb_sport == NewTCB->tcb_sport) &&
            (CurrentTCB->tcb_dport == NewTCB->tcb_dport)) {

            KeReleaseSpinLockFromDpcLevel(&NewTCB->tcb_lock);
            KeReleaseSpinLock(&TCBTableLock, OldIrql);
            return FALSE;

        } else {

            if (WhereToInsert == NULL && CurrentTCB > NewTCB) {
                WhereToInsert = PrevTCB;
            }

            CHECK_STRUCT(PrevTCB->tcb_next, tcb);
            PrevTCB = PrevTCB->tcb_next;
        }
    }

    if (WhereToInsert == NULL) {
        WhereToInsert = PrevTCB;
    }

    NewTCB->tcb_next = WhereToInsert->tcb_next;
    WhereToInsert->tcb_next = NewTCB;
    NewTCB->tcb_flags |= IN_TCB_TABLE;
    TStats.ts_numconns++;

    KeReleaseSpinLockFromDpcLevel(&NewTCB->tcb_lock);
    KeReleaseSpinLock(&TCBTableLock, OldIrql);
    return TRUE;
}


//* RemoveTCB - Remove a TCB from the tcb table.
//
//  Called when we need to remove a TCB from the TCB table.  We assume the
//  TCB table lock and the TCB lock are held when we are called.  If the
//  TCB isn't in the table we won't try to remove him.
//
uint  // Returns: TRUE if it's OK to free it, FALSE otherwise.
RemoveTCB(
    TCB *RemovedTCB)  // TCB to be removed.
{
    uint TCBIndex;
    TCB *PrevTCB;
#if DBG
    uint Found = FALSE;
#endif

    CHECK_STRUCT(RemovedTCB, tcb);

    if (RemovedTCB->tcb_flags & IN_TCB_TABLE) {
        TCBIndex = TCB_HASH(RemovedTCB->tcb_daddr, RemovedTCB->tcb_saddr,
            RemovedTCB->tcb_dport, RemovedTCB->tcb_sport);

        PrevTCB = CONTAINING_RECORD(&TCBTable[TCBIndex], TCB, tcb_next);

        do {
            if (PrevTCB->tcb_next == RemovedTCB) {
                // Found him.
                PrevTCB->tcb_next = RemovedTCB->tcb_next;
                RemovedTCB->tcb_flags &= ~IN_TCB_TABLE;
                TStats.ts_numconns--;
#if DBG
                Found = TRUE;
#endif
                break;
            }
            PrevTCB = PrevTCB->tcb_next;
#if DBG
            if (PrevTCB != NULL)
                CHECK_STRUCT(PrevTCB, tcb);
#endif
        } while (PrevTCB != NULL);

        ASSERT(Found);
    }

    if (LastTCB == RemovedTCB)
        LastTCB = NULL;

    if (TCBWalkCount == 0) {
        return TRUE;
    } else {
        RemovedTCB->tcb_walkcount = TCBWalkCount + 1;
        *(TCB **)&RemovedTCB->tcb_delayq.q_next = PendingFreeList;
        PendingFreeList = RemovedTCB;
        return FALSE;
    }
}


//* ScavengeTCB - Scavenge a TCB that's in the TIME_WAIT state.
//
//  Called when we're running low on TCBs, and need to scavenge one from
//  TIME_WAIT state.  We'll walk through the TCB table, looking for the oldest
//  TCB in TIME_WAIT.  We'll remove and return a pointer to that TCB.  If we
//  don't find any TCBs in TIME_WAIT, we'll return NULL.
//
TCB *  // Returns: Pointer to a reusable TCB, or NULL.
ScavengeTCB(
    void)
{
    KIRQL Irql0, Irql1, IrqlSave = 0;
    uint Now = SystemUpTime();
    uint Delta = 0;
    uint i;
    TCB *FoundTCB = NULL, *PrevFound = NULL;
    TCB *CurrentTCB, *PrevTCB;

    KeAcquireSpinLock(&TCBTableLock, &Irql0);

    if (TCBWalkCount != 0) {
        KeReleaseSpinLock(&TCBTableLock, Irql0);
        return NULL;
    }

    for (i = 0; i < TcbTableSize; i++) {

        PrevTCB = CONTAINING_RECORD(&TCBTable[i], TCB, tcb_next);
        CurrentTCB = PrevTCB->tcb_next;

        while (CurrentTCB != NULL) {
            CHECK_STRUCT(CurrentTCB, tcb);

            KeAcquireSpinLock(&CurrentTCB->tcb_lock, &Irql1);
            if (CurrentTCB->tcb_state == TCB_TIME_WAIT &&
                (CurrentTCB->tcb_refcnt == 0) && !CLOSING(CurrentTCB)){
                if (FoundTCB == NULL ||
                    ((Now - CurrentTCB->tcb_alive) > Delta)) {
                    //
                    // Found a new 'older' TCB.  If we already have one, free
                    // the lock on him and get the lock on the new one.
                    //
                    if (FoundTCB != NULL)
                        KeReleaseSpinLock(&FoundTCB->tcb_lock, Irql1);
                    else
                        IrqlSave = Irql1;

                    PrevFound = PrevTCB;
                    FoundTCB = CurrentTCB;
                    Delta = Now - FoundTCB->tcb_alive;
                } else
                    KeReleaseSpinLock(&CurrentTCB->tcb_lock, Irql1);
            } else
                KeReleaseSpinLock(&CurrentTCB->tcb_lock, Irql1);

            //
            // Look at the next one.
            //
            PrevTCB = CurrentTCB;
            CurrentTCB = PrevTCB->tcb_next;
        }
    }

    //
    // If we have one, pull him from the list.
    //
    if (FoundTCB != NULL) {
        PrevFound->tcb_next = FoundTCB->tcb_next;
        FoundTCB->tcb_flags &= ~IN_TCB_TABLE;

        //
        // Release our references on the NTE and RCE.  We won't
        // be sending anymore using the old incarnation of this TCB.
        //
        if (FoundTCB->tcb_nte != NULL)
            ReleaseNTE(FoundTCB->tcb_nte);
        if (FoundTCB->tcb_rce != NULL)
            ReleaseRCE(FoundTCB->tcb_rce);

        TStats.ts_numconns--;
        if (LastTCB == FoundTCB) {
            LastTCB = NULL;
        }
        KeReleaseSpinLock(&FoundTCB->tcb_lock, IrqlSave);
    }

    KeReleaseSpinLock(&TCBTableLock, Irql0);
    return FoundTCB;
}


//* AllocTCB - Allocate a TCB.
//
//  Called whenever we need to allocate a TCB.  We try to pull one off the
//  free list, or allocate one if we need one.  We then initialize it, etc.
//
TCB *  // Returns: Pointer to the new TCB, or NULL if we couldn't get one.
AllocTCB(
    void)
{
    TCB *NewTCB;

    //
    // First, see if we have one on the free list.
    //
    PSLIST_ENTRY BufferLink;

    BufferLink = ExInterlockedPopEntrySList(&FreeTCBList, &FreeTCBListLock);

    if (BufferLink != NULL) {
        NewTCB = CONTAINING_RECORD(BufferLink, TCB, tcb_next);
        CHECK_STRUCT(NewTCB, tcb);
        ExInterlockedAddUlong((PULONG)&FreeTCBs, (ULONG)-1, &FreeTCBListLock);
    } else {
        //
        // We have none on the free list.  If the total number of TCBs
        // outstanding is more than we like to keep on the free list, try
        // to scavenge a TCB from time wait.
        //
        if (CurrentTCBs < MaxFreeTCBs || ((NewTCB = ScavengeTCB()) == NULL)) {
            if (CurrentTCBs < MaxTCBs) {
                NewTCB = ExAllocatePool(NonPagedPool, sizeof(TCB));
                if (NewTCB == NULL) {
                    return NewTCB;
                } else {
                    ExInterlockedAddUlong((PULONG)&CurrentTCBs, 1, 
                                          &FreeTCBListLock);
                }
            } else
                return NULL;
        }
    }

    ASSERT(NewTCB != NULL);

    RtlZeroMemory(NewTCB, sizeof(TCB));
#if DBG
    NewTCB->tcb_sig = tcb_signature;
#endif
    INITQ(&NewTCB->tcb_sendq);
    NewTCB->tcb_cursend = NULL;
    NewTCB->tcb_alive = TCPTime;
    NewTCB->tcb_hops = -1;

    //
    // Initially we're not on the fast path because we're not established.  Set
    // the slowcount to one and set up the fastchk fields so we don't take the
    // fast path.
    //
    NewTCB->tcb_slowcount = 1;
    NewTCB->tcb_fastchk = TCP_FLAG_ACK | TCP_FLAG_SLOW;
    KeInitializeSpinLock(&NewTCB->tcb_lock);

    return NewTCB;
}


//* FreeTCB - Free a TCB.
//
//  Called whenever we need to free a TCB.
//
//  Note: This routine may be called with the TCBTableLock held.
//
void  // Returns: Nothing.
FreeTCB(
    TCB *FreedTCB)  // TCB to be freed.
{
    PSLIST_ENTRY BufferLink;
    KIRQL OldIrql;

    CHECK_STRUCT(FreedTCB, tcb);

#if defined(_WIN64)
    if (CurrentTCBs > 2 * MaxFreeTCBs) {

#else
    //
    // Acquire FreeTCBListLock before accessing Depth field.
    //
    KeAcquireSpinLock(&FreeTCBListLock, &OldIrql);
    if ((CurrentTCBs > 2 * MaxFreeTCBs) || (FreeTCBList.Depth > 65000)) {
        KeReleaseSpinLock(&FreeTCBListLock, OldIrql);

#endif
        ExInterlockedAddUlong((PULONG)&CurrentTCBs, (ulong) - 1, &FreeTCBListLock);
        ExFreePool(FreedTCB);
        return;
    }
#if !defined(_WIN64)
    KeReleaseSpinLock(&FreeTCBListLock, OldIrql);
#endif

    BufferLink = CONTAINING_RECORD(&(FreedTCB->tcb_next),
                                   SLIST_ENTRY, Next);
    ExInterlockedPushEntrySList(&FreeTCBList, BufferLink, &FreeTCBListLock);
    ExInterlockedAddUlong((PULONG)&FreeTCBs, 1, &FreeTCBListLock);
}


#pragma BEGIN_INIT

//* InitTCB - Initialize our TCB code.
//
//  Called during init time to initialize our TCB code. We initialize
//  the TCB table, etc, then return.
//
int  // Returns: TRUE if we did initialize, false if we didn't.
InitTCB(
    void)
{
    LARGE_INTEGER InitialWakeUp;
    uint i;

    TCBTable = ExAllocatePool(NonPagedPool, TcbTableSize * sizeof(TCB*));
    if (TCBTable == NULL) {
        return FALSE;
    }

    for (i = 0; i < TcbTableSize; i++)
        TCBTable[i] = NULL;

    LastTCB = NULL;

    ExInitializeSListHead(&FreeTCBList);

    KeInitializeSpinLock(&TCBTableLock);
    KeInitializeSpinLock(&FreeTCBListLock);

    TCPTime = 0;
    TCBWalkCount = 0;
    DeadmanTicks = NUM_DEADMAN_TICKS;

    //
    // Set up our timer to call TCBTimeout once every MS_PER_TICK milliseconds.
    //
    // REVIEW: Switch this to be driven off the IPv6Timeout routine instead
    // REVIEW: of having two independent timers?
    //
    KeInitializeDpc(&TCBTimeoutDpc, TCBTimeout, NULL);
    KeInitializeTimer(&TCBTimer);
    InitialWakeUp.QuadPart = -(LONGLONG) MS_PER_TICK * 10000;
    KeSetTimerEx(&TCBTimer, InitialWakeUp, MS_PER_TICK, &TCBTimeoutDpc);

    return TRUE;
}

#pragma END_INIT


//* UnloadTCB
//
//  Called during shutdown to uninitialize
//  in preparation for unloading the stack.
//
//  There are no open sockets (or else we wouldn't be unloading).
//  Because UnloadTCPSend has already been called,
//  we are no longer receiving packets from the IPv6 layer.
//
void
UnloadTCB(void)
{
    PSLIST_ENTRY BufferLink;
    TCB *CurrentTCB;
    uint i;
    KIRQL OldIrql;

    //
    // First stop TCBTimeout from being called.
    //
    KeCancelTimer(&TCBTimer);

    //
    // Wait until all the DPC routines have finished.
    //
    KeFlushQueuedDpcs();

    //
    // Traverse the buckets looking for TCBs.
    // REVIEW - Can we have TCBs in states other than time-wait?
    //
    for (i = 0; i < TcbTableSize; i++) {

        while ((CurrentTCB = TCBTable[i]) != NULL) {

            KeAcquireSpinLock(&CurrentTCB->tcb_lock, &OldIrql);

            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_STATE,
                       "UnloadTCB(%p): state %x flags %x refs %x "
                       "reason %x pend %x walk %x\n",
                       CurrentTCB,
                       CurrentTCB->tcb_state,
                       CurrentTCB->tcb_flags,
                       CurrentTCB->tcb_refcnt,
                       CurrentTCB->tcb_closereason,
                       CurrentTCB->tcb_pending,
                       CurrentTCB->tcb_walkcount));

            CurrentTCB->tcb_flags |= NEED_RST;
            TryToCloseTCB(CurrentTCB, TCB_CLOSE_ABORTED, OldIrql);
        }
    }

    //
    // Now pull TCBs off the free list and really free them.
    //
    while ((BufferLink = ExInterlockedPopEntrySList(&FreeTCBList, &FreeTCBListLock)) != NULL) {
        CurrentTCB = CONTAINING_RECORD(BufferLink, TCB, tcb_next);
        CHECK_STRUCT(CurrentTCB, tcb);

        ExFreePool(CurrentTCB);
    }

    ExFreePool(TCBTable);
    TCBTable = NULL;
}

//* CleanupTCBWithIF
//
//  Helper function for TCBWalk, to remove
//  TCBs and RCEs that reference the specified interface.
//
//  Lock: Called in TCBWalk with TCB table lock held. 
//  Returns FALSE if CheckTCB should be deleted, TRUE otherwise.
//
uint
CleanupTCBWithIF(
    TCB *CheckTCB,
    void *Context1,
    void *Context2,
    void *Context3)
{
    Interface *IF = (Interface *) Context1;

    UNREFERENCED_PARAMETER(Context2);
    UNREFERENCED_PARAMETER(Context3);

    CHECK_STRUCT(CheckTCB, tcb);

    //
    // Take the lock of this TCB before accessing its NTE and RCE.
    //
    KeAcquireSpinLockAtDpcLevel(&CheckTCB->tcb_lock);

    if ((CheckTCB->tcb_nte != NULL) && (CheckTCB->tcb_nte->IF == IF)) {

        //
        // Any NTE on this IF is guaranteed to be invalid by the time
        // this routine gets called.  So we need to quit using it.
        //
        ReleaseNTE(CheckTCB->tcb_nte);

        //
        // See if this address lives on as a different NTE.
        //
        CheckTCB->tcb_nte = FindNetworkWithAddress(&CheckTCB->tcb_saddr,
                                                   CheckTCB->tcb_sscope_id);
        if (CheckTCB->tcb_nte == NULL) {
            //
            // Game over man, game over.
            //
            KeReleaseSpinLockFromDpcLevel(&CheckTCB->tcb_lock);
            return FALSE;  // Delete this TCB.
        }
    }

    if ((CheckTCB->tcb_rce != NULL) && (CheckTCB->tcb_rce->NTE->IF == IF)) {
        //
        // Free up this RCE.  TCP will attempt to get a new one
        // the next time it wants to send something.
        //
        ReleaseRCE(CheckTCB->tcb_rce);
        CheckTCB->tcb_rce = NULL;
    }

    KeReleaseSpinLockFromDpcLevel(&CheckTCB->tcb_lock);
    return TRUE;  // Do not delete this TCB.
}


//* TCPRemoveIF
//
//  Remove TCP's references to the specified interface.
//
void
TCPRemoveIF(Interface *IF)
{
    //
    // Currently, only TCBs hold onto references.
    // The TCBTable might have already been freed if we're being
    // unloaded at this point.
    //
    if (TCBTable != NULL) {
        TCBWalk(CleanupTCBWithIF, IF, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\tcp\tcpinit.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This file contains init code for TCP.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include <tdikrnl.h>
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "info.h"
#include "tcp.h"
#include "tcpsend.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tcpdeliv.h"
#include "tdiinfo.h"
#include "tcpcfg.h"

#pragma BEGIN_INIT

extern uchar TCPGetConfigInfo(void);
extern int InitTCPConn(void);
extern void UnloadTCPConn(void);
extern int InitTCPRcv(void);
extern void UnloadTCPRcv(void);
extern int InitISNGenerator(void);
extern void UnloadISNGenerator(void);

//
// Definitions of TCP specific global variables.
//
uint AllowUserRawAccess;
uint PMTUDiscovery;
uint PMTUBHDetect;
uint KeepAliveTime;
uint KAInterval;
uint DefaultRcvWin;
uint MaxConnections;
uint MaxConnBlocks;
uint TcbTableSize;
uint MaxConnectRexmitCount;
uint MaxDataRexmitCount;
uint BSDUrgent;
uint FinWait2TO;
uint NTWMaxConnectCount;
uint NTWMaxConnectTime;
uint SynAttackProtect = 0;


//* TCPInit - Initialize the Transport Control Protocol.
//
//  The main TCP initialize routine.  We get whatever config
//  info we need, initialize some data structures, etc.
//
int  // Returns: True is we succeeded, False if we fail to initialize.
TCPInit(void)
{
    if (!TCPGetConfigInfo())
        return FALSE;

    KeepAliveTime = MS_TO_TICKS(KeepAliveTime);
    KAInterval = MS_TO_TICKS(KAInterval);

    MaxConnections = MIN(MaxConnections, INVALID_CONN_INDEX - 1);

    if (!InitISNGenerator())
        return FALSE;

    if (!InitTCPConn())
        return FALSE;

    if (!InitTCB())
        return FALSE;

    if (!InitTCPRcv())
        return FALSE;

    if (!InitTCPSend())
        return FALSE;

    //
    // Initialize statistics.
    //
    RtlZeroMemory(&TStats, sizeof(TCPStats));
    TStats.ts_rtoalgorithm = TCP_RTO_VANJ;
    TStats.ts_rtomin = MIN_RETRAN_TICKS * MS_PER_TICK;
    TStats.ts_rtomax = MAX_REXMIT_TO * MS_PER_TICK;
    TStats.ts_maxconn = (ulong) TCP_MAXCONN_DYNAMIC;

    return TRUE;
}

#pragma END_INIT

//* TCPUnload
//
//  Called to cleanup TCP in preparation for unloading the stack.
//
void
TCPUnload(void)
{
    //
    // After UnloadTCPSend, we will stop receiving packets
    // from the IPv6 layer.
    //
    UnloadTCPSend();

    UnloadTCPRcv();

    UnloadTCB();

    UnloadTCPConn();

    UnloadISNGenerator();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\tcp\tcpmd5.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This file contains the support routines for computing MD5 on TCP invariants.
//

#define MD5_SCRATCH_LENGTH 4
#define MD5_DATA_LENGTH 16

//
// Data structure for MD5 (Message Digest) computation.
//
// MD5_CONTEXT
//
typedef struct _MD5_CONTEXT {
    ULONG Scratch[MD5_SCRATCH_LENGTH];
    ULONG Data[MD5_DATA_LENGTH];
} MD5_CONTEXT, *PMD5_CONTEXT;


//
// The Length of TCP connection invariants should be a multiple of 4.
//
C_ASSERT(TCP_MD5_DATA_LENGTH % 4 == 0);


FORCEINLINE
VOID
MD5InitializeScratch(
    PMD5_CONTEXT Md5Context
    )
{
    //
    // Load the constants as suggested by RFC 1321, Appendix A.3.
    //

    Md5Context->Scratch[0] = (UINT32)0x67452301;
    Md5Context->Scratch[1] = (UINT32)0xefcdab89;
    Md5Context->Scratch[2] = (UINT32)0x98badcfe;
    Md5Context->Scratch[3] = (UINT32)0x10325476;
}


FORCEINLINE
VOID
MD5InitializeData(
    PMD5_CONTEXT Md5Context,
    ULONG RandomValue
    )
{
    ULONG RandomValueIndex = (TCP_MD5_DATA_LENGTH / 4);

    //
    // The unused part of the Data buffer should be zero.
    //
    RtlZeroMemory(&Md5Context->Data, sizeof(ULONG) * MD5_DATA_LENGTH);

    Md5Context->Data[RandomValueIndex] = RandomValue;
    Md5Context->Data[RandomValueIndex + 1] = 0x80;

    ASSERT((RandomValueIndex + 1) < (MD5_DATA_LENGTH - 2));
    Md5Context->Data[MD5_DATA_LENGTH - 2] = 
                            (TCP_MD5_DATA_LENGTH + sizeof(ULONG)) * 8;

}


//
// This function will be exported as part of MD5.H; until then,
// we will define it as extern.
//
extern
VOID
TransformMD5(ULONG block[4], ULONG buffer[16]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ttcp\makefile.inc ===
$(O)\msg00001.bin: localmsg.mc
    $(MC) -v -h $(O) -r $(O) localmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\tcp\tcprcv.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Transmission Control Protocol receive module definitions.
//


#define CONN_REQUEST_COMPLETE 0x01
#define SEND_REQUEST_COMPLETE 0x02

#define IN_RCV_COMPLETE 0x10
#define ANY_REQUEST_COMPLETE (CONN_REQUEST_COMPLETE | SEND_REQUEST_COMPLETE)

#define trh_signature 0x20485254  // 'TRH '

typedef struct TCPRAHdr {
#if DBG
    ulong trh_sig; // Signature.
#endif
    struct TCPRAHdr *trh_next;  // Next pointer.
    SeqNum trh_start;           // First sequence number.
    uint trh_size;              // Size in bytes of data in this TRH.
    uint trh_flags;             // Flags for this segment.
    uint trh_urg;               // Urgent pointer from this seg.
    IPv6Packet *trh_buffer;       // Head of buffer list for this TRH.
    IPv6Packet *trh_end;       // Tail of buffer list for this TRH.
} TCPRAHdr;


//
// Structure of a TCP receive request.
//
#define trr_signature 0x20525254  // 'TRR '

typedef struct TCPRcvReq {
    struct TCPRcvReq *trr_next;       // Next in chain.
#if DBG
    ulong trr_sig;  // Signature.
#endif
    RequestCompleteRoutine trr_rtn;   // Completion routine.
    PVOID trr_context;                // User context.
    uint trr_amt;                     // Number of bytes currently in buffer.
    uint trr_offset;                  // Offset into first buffer on chain
                                      // at which to start copying.
    uint trr_flags;                   // Flags for this receive.
    ushort *trr_uflags;               // Pointer to user specifed flags.
    uint trr_size;                    // Total size of buffer chain.
    PNDIS_BUFFER trr_buffer;          // Pointer to useable NDIS buffer chain.
} TCPRcvReq;

#define TRR_PUSHED 0x80000000  // This buffer has been pushed.


extern uint RequestCompleteFlags;

extern Queue SendCompleteQ;
extern Queue TCBDelayQ;

extern KSPIN_LOCK RequestCompleteLock;
extern KSPIN_LOCK TCBDelayLock;

extern void TCPRcvComplete(void);
extern void FreePacketChain(IPv6Packet *Packet);
extern void DelayAction(struct TCB *DelayTCB, uint Action);
extern void ProcessTCBDelayQ(void);
extern void AdjustRcvWin(struct TCB *WinTCB);

extern ProtoRecvProc TCPReceive;
extern ProtoControlRecvProc TCPControlReceive;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\tcp\tcprcv.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// TCP receive code.
//
// This file contains the code for handling incoming TCP packets.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "icmp.h"
#include "tdi.h"
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tcpsend.h"
#include "tcprcv.h"
#include "tcpdeliv.h"
#include "info.h"
#include "tcpcfg.h"
#include "route.h"
#include "security.h"

uint RequestCompleteFlags;

Queue ConnRequestCompleteQ;
Queue SendCompleteQ;

Queue TCBDelayQ;

KSPIN_LOCK RequestCompleteLock;
KSPIN_LOCK TCBDelayLock;

ulong TCBDelayRtnCount;
ulong TCBDelayRtnLimit;
#define TCB_DELAY_RTN_LIMIT 4

uint MaxDupAcks = 2;

extern KSPIN_LOCK TCBTableLock;
extern KSPIN_LOCK AddrObjTableLock;


#define PERSIST_TIMEOUT MS_TO_TICKS(500)

void ResetSendNext(TCB *SeqTCB, SeqNum NewSeq);

NTSTATUS TCPPrepareIrpForCancel(PTCP_CONTEXT TcpContext, PIRP Irp,
                                PDRIVER_CANCEL CancelRoutine);

extern void TCPRequestComplete(void *Context, unsigned int Status,
                               unsigned int UnUsed);

VOID TCPCancelRequest(PDEVICE_OBJECT Device, PIRP Irp);

//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA

int InitTCPRcv(void);

#pragma alloc_text(INIT, InitTCPRcv)

#endif // ALLOC_PRAGMA


//* AdjustRcvWin - Adjust the receive window on a TCB.
//
//  A utility routine that adjusts the receive window to an even multiple of
//  the local segment size.  We round it up to the next closest multiple, or
//  leave it alone if it's already an event multiple.  We assume we have
//  exclusive access to the input TCB.
//
void              // Returns: Nothing.
AdjustRcvWin(
    TCB *WinTCB)  // TCB to be adjusted.
{
    ushort LocalMSS;
    uchar FoundMSS;
    ulong SegmentsInWindow;

    ASSERT(WinTCB->tcb_defaultwin != 0);
    ASSERT(WinTCB->tcb_rcvwin != 0);
    ASSERT(WinTCB->tcb_remmss != 0);

    if (WinTCB->tcb_flags & WINDOW_SET)
        return;

#if 0
    //
    // First, get the local MSS by calling IP.
    //

    // REVIEW: IPv4 had code here to call down to IP to get the local MTU
    // REVIEW: corresponding to this source address.  Result in "LocalMSS",
    // REVIEW: status of call in "FoundMSS".
    //
    // REVIEW: Why did they do this?  tcb_mss is already set by this point!
    //

    if (!FoundMSS) {
        //
        // Didn't find it, error out.
        //
        ASSERT(FALSE);
        return;
    }
    LocalMSS -= sizeof(TCPHeader);
    LocalMSS = MIN(LocalMSS, WinTCB->tcb_remmss);
#else
    LocalMSS = WinTCB->tcb_mss;
#endif

    SegmentsInWindow = WinTCB->tcb_defaultwin / (ulong)LocalMSS;

    //
    // Make sure we have at least 4 segments in window, if that wouldn't make
    // the window too big.
    //
    if (SegmentsInWindow < 4) {
        //
        // We have fewer than four segments in the window.  Round up to 4
        // if we can do so without exceeding the maximum window size; otherwise
        // use the maximum multiple that we can fit in 64K.  The exception is
        // if we can only fit one integral multiple in the window - in that
        // case we'll use a window of 0xffff.
        //
        if (LocalMSS <= (0xffff/4)) {
            WinTCB->tcb_defaultwin = (uint)(4 * LocalMSS);
        } else {
            ulong SegmentsInMaxWindow;

            //
            // Figure out the maximum number of segments we could possibly
            // fit in a window.  If this is > 1, use that as the basis for
            // our window size.  Otherwise use a maximum size window.
            //
            SegmentsInMaxWindow = 0xffff/(ulong)LocalMSS;
            if (SegmentsInMaxWindow != 1)
                WinTCB->tcb_defaultwin = SegmentsInMaxWindow * (ulong)LocalMSS;
            else
                WinTCB->tcb_defaultwin = 0xffff;
        }

        WinTCB->tcb_rcvwin = WinTCB->tcb_defaultwin;

    } else {
        //
        // If it's not already an even multiple, bump the default and current
        // windows to the nearest multiple.
        //
        if ((SegmentsInWindow * (ulong)LocalMSS) != WinTCB->tcb_defaultwin) {
            ulong NewWindow;

            NewWindow = (SegmentsInWindow + 1) * (ulong)LocalMSS;

            // Don't let the new window be > 64K.
            if (NewWindow <= 0xffff) {
                WinTCB->tcb_defaultwin = (uint)NewWindow;
                WinTCB->tcb_rcvwin = (uint)NewWindow;
            }
        }
    }
}


//* CompleteRcvs - Complete receives on a TCB.
//
//  Called when we need to complete receives on a TCB.  We'll pull things from
//  the TCB's receive queue, as long as there are receives that have the PUSH
//  bit set.
//
void                // Returns: Nothing.
CompleteRcvs(
    TCB *CmpltTCB)  // TCB to complete on.
{
    KIRQL OldIrql;
    TCPRcvReq *CurrReq, *NextReq, *IndReq;

    CHECK_STRUCT(CmpltTCB, tcb);
    ASSERT(CmpltTCB->tcb_refcnt != 0);

    KeAcquireSpinLock(&CmpltTCB->tcb_lock, &OldIrql);

    if (!CLOSING(CmpltTCB) && !(CmpltTCB->tcb_flags & RCV_CMPLTING)
        && (CmpltTCB->tcb_rcvhead != NULL)) {

        CmpltTCB->tcb_flags |= RCV_CMPLTING;

        for (;;) {

            CurrReq = CmpltTCB->tcb_rcvhead;
            IndReq = NULL;
            do {
                CHECK_STRUCT(CurrReq, trr);

                if (CurrReq->trr_flags & TRR_PUSHED) {
                    //
                    // Need to complete this one.  If this is the current
                    // receive then advance the current receive to the next
                    // one in the list.  Then set the list head to the next
                    // one in the list.
                    //
                    ASSERT(CurrReq->trr_amt != 0 ||
                           !DATA_RCV_STATE(CmpltTCB->tcb_state));

                    NextReq = CurrReq->trr_next;
                    if (CmpltTCB->tcb_currcv == CurrReq)
                        CmpltTCB->tcb_currcv = NextReq;

                    CmpltTCB->tcb_rcvhead = NextReq;

                    if (NextReq == NULL) {
                        //
                        // We've just removed the last buffer.  Set the
                        // rcvhandler to PendData, in case something
                        // comes in during the callback.
                        //
                        ASSERT(CmpltTCB->tcb_rcvhndlr != IndicateData);
                        CmpltTCB->tcb_rcvhndlr = PendData;
                    }

                    KeReleaseSpinLock(&CmpltTCB->tcb_lock, OldIrql);
                    if (CurrReq->trr_uflags != NULL)
                        *(CurrReq->trr_uflags) =
                            TDI_RECEIVE_NORMAL | TDI_RECEIVE_ENTIRE_MESSAGE;

                    (*CurrReq->trr_rtn)(CurrReq->trr_context, TDI_SUCCESS,
                                        CurrReq->trr_amt);
                    if (IndReq != NULL)
                        FreeRcvReq(CurrReq);
                    else
                        IndReq = CurrReq;
                    KeAcquireSpinLock(&CmpltTCB->tcb_lock, &OldIrql);
                    CurrReq = CmpltTCB->tcb_rcvhead;

                } else
                    // This one isn't to be completed, so bail out.
                    break;
            } while (CurrReq != NULL);

            //
            // Now see if we've completed all of the requests.  If we have,
            // we may need to deal with pending data and/or reset the receive
            // handler.
            //
            if (CurrReq == NULL) {
                //
                // We've completed everything that can be, so stop the push
                // timer.  We don't stop it if CurrReq isn't NULL because we
                // want to make sure later data is eventually pushed.
                //
                STOP_TCB_TIMER(CmpltTCB->tcb_pushtimer);

                ASSERT(IndReq != NULL);
                //
                // No more receive requests.
                //
                if (CmpltTCB->tcb_pendhead == NULL) {
                    FreeRcvReq(IndReq);
                    //
                    // No pending data. Set the receive handler to either
                    // PendData or IndicateData.
                    //
                    if (!(CmpltTCB->tcb_flags & (DISC_PENDING | GC_PENDING))) {
                        if (CmpltTCB->tcb_rcvind != NULL &&
                            CmpltTCB->tcb_indicated == 0)
                            CmpltTCB->tcb_rcvhndlr = IndicateData;
                        else
                            CmpltTCB->tcb_rcvhndlr = PendData;
                    } else {
                        goto Complete_Notify;
                    }

                } else {
                    //
                    // We have pending data to deal with.
                    //
                    if (CmpltTCB->tcb_rcvind != NULL &&
                        CmpltTCB->tcb_indicated == 0) {
                        //
                        // There's a receive indicate handler on this TCB.
                        // Call the indicate handler with the pending data.
                        //
                        IndicatePendingData(CmpltTCB, IndReq, OldIrql);
                        SendACK(CmpltTCB);
                        KeAcquireSpinLock(&CmpltTCB->tcb_lock, &OldIrql);

                        //
                        // See if a buffer has been posted.  If so, we'll need
                        // to check and see if it needs to be completed.
                        //
                        if (CmpltTCB->tcb_rcvhead != NULL)
                            continue;
                        else {
                            //
                            // If the pending head is now NULL, we've used up
                            // all the data.
                            //
                            if (CmpltTCB->tcb_pendhead == NULL &&
                                (CmpltTCB->tcb_flags &
                                 (DISC_PENDING | GC_PENDING)))
                                goto Complete_Notify;
                        }

                    } else {
                        //
                        // No indicate handler, so nothing to do.  The receive
                        // handler should already be set to PendData.
                        //
                        FreeRcvReq(IndReq);
                        ASSERT(CmpltTCB->tcb_rcvhndlr == PendData);
                    }
                }
            } else {
                if (IndReq != NULL)
                    FreeRcvReq(IndReq);
                ASSERT(CmpltTCB->tcb_rcvhndlr == BufferData);
            }

            break;
        }
        CmpltTCB->tcb_flags &= ~RCV_CMPLTING;
    }
    KeReleaseSpinLock(&CmpltTCB->tcb_lock, OldIrql);
    return;

Complete_Notify:
    //
    // Something is pending.  Figure out what it is, and do it.
    //
    if (CmpltTCB->tcb_flags & GC_PENDING) {
        CmpltTCB->tcb_flags &= ~RCV_CMPLTING;
        //
        // Bump the refcnt, because GracefulClose will deref the TCB
        // and we're not really done with it yet.
        //
        CmpltTCB->tcb_refcnt++;
        GracefulClose(CmpltTCB, CmpltTCB->tcb_flags & TW_PENDING, TRUE,
                      OldIrql);
    } else
        if (CmpltTCB->tcb_flags & DISC_PENDING) {
            NotifyOfDisc(CmpltTCB, TDI_GRACEFUL_DISC, &OldIrql);

            KeAcquireSpinLock(&CmpltTCB->tcb_lock, &OldIrql);
            CmpltTCB->tcb_flags &= ~RCV_CMPLTING;
            KeReleaseSpinLock(&CmpltTCB->tcb_lock, OldIrql);
        } else {
            ASSERT(FALSE);
            KeReleaseSpinLock(&CmpltTCB->tcb_lock, OldIrql);
        }

    return;
}

//* ProcessTCBDelayQ - Process TCBs on the delayed Q.
//
//  Called at various times to process TCBs on the delayed Q.
//
void               // Returns: Nothing.
ProcessTCBDelayQ(
    void)          // Nothing.
{
    KIRQL OldIrql;
    TCB *DelayTCB;

    KeAcquireSpinLock(&TCBDelayLock, &OldIrql);

    //
    // Check for recursion.  We do not stop recursion completely, only
    // limit it.  This is done to allow multiple threads to process the
    // TCBDelayQ simultaneously.
    //
    TCBDelayRtnCount++;
    if (TCBDelayRtnCount > TCBDelayRtnLimit) {
        TCBDelayRtnCount--;
        KeReleaseSpinLock(&TCBDelayLock, OldIrql);
        return;
    }

    while (!EMPTYQ(&TCBDelayQ)) {

        DEQUEUE(&TCBDelayQ, DelayTCB, TCB, tcb_delayq);
        CHECK_STRUCT(DelayTCB, tcb);
        ASSERT(DelayTCB->tcb_refcnt != 0);
        ASSERT(DelayTCB->tcb_flags & IN_DELAY_Q);
        KeReleaseSpinLock(&TCBDelayLock, OldIrql);

        KeAcquireSpinLock(&DelayTCB->tcb_lock, &OldIrql);

        while (!CLOSING(DelayTCB) && (DelayTCB->tcb_flags & DELAYED_FLAGS)) {

            if (DelayTCB->tcb_flags & NEED_RCV_CMPLT) {
                DelayTCB->tcb_flags &= ~NEED_RCV_CMPLT;
                KeReleaseSpinLock(&DelayTCB->tcb_lock, OldIrql);
                CompleteRcvs(DelayTCB);
                KeAcquireSpinLock(&DelayTCB->tcb_lock, &OldIrql);
            }

            if (DelayTCB->tcb_flags & NEED_OUTPUT) {
                DelayTCB->tcb_flags &= ~NEED_OUTPUT;
                DelayTCB->tcb_refcnt++;
                TCPSend(DelayTCB, OldIrql);
                KeAcquireSpinLock(&DelayTCB->tcb_lock, &OldIrql);
            }

            if (DelayTCB->tcb_flags & NEED_ACK) {
                DelayTCB->tcb_flags &= ~NEED_ACK;
                KeReleaseSpinLock(&DelayTCB->tcb_lock, OldIrql);
                SendACK(DelayTCB);
                KeAcquireSpinLock(&DelayTCB->tcb_lock, &OldIrql);
            }
        }

        DelayTCB->tcb_flags &= ~IN_DELAY_Q;
        DerefTCB(DelayTCB, OldIrql);
        KeAcquireSpinLock(&TCBDelayLock, &OldIrql);
    }

    TCBDelayRtnCount--;
    KeReleaseSpinLock(&TCBDelayLock, OldIrql);
}


//* DelayAction - Put a TCB on the queue for a delayed action.
//
//  Called when we want to put a TCB on the DelayQ for a delayed action at
//  receive complete or some other time.  The lock on the TCB must be held
//  when this is called.
//
void                // Returns: Nothing.
DelayAction(
    TCB *DelayTCB,  // TCP which we're going to schedule.
    uint Action)    // Action we're scheduling.
{
    //
    // Schedule the completion.
    //
    KeAcquireSpinLockAtDpcLevel(&TCBDelayLock);
    DelayTCB->tcb_flags |= Action;
    if (!(DelayTCB->tcb_flags & IN_DELAY_Q)) {
        DelayTCB->tcb_flags |= IN_DELAY_Q;
        DelayTCB->tcb_refcnt++;             // Reference this for later.
        ENQUEUE(&TCBDelayQ, &DelayTCB->tcb_delayq);
    }
    KeReleaseSpinLockFromDpcLevel(&TCBDelayLock);
}

//* TCPRcvComplete - Handle a receive complete.
//
//  Called by the lower layers when we're done receiving.  We look to see
//  if we have and pending requests to complete.  If we do, we complete them.
//  Then we look to see if we have any TCBs pending for output.  If we do,
//  we get them going.
//
void  // Returns: Nothing.
TCPRcvComplete(
    void)  // Nothing.
{
    KIRQL OldIrql;
    TCPReq *Req;

    if (RequestCompleteFlags & ANY_REQUEST_COMPLETE) {
        KeAcquireSpinLock(&RequestCompleteLock, &OldIrql);
        if (!(RequestCompleteFlags & IN_RCV_COMPLETE)) {
            RequestCompleteFlags |= IN_RCV_COMPLETE;
            do {
                if (RequestCompleteFlags & CONN_REQUEST_COMPLETE) {
                    if (!EMPTYQ(&ConnRequestCompleteQ)) {
                        DEQUEUE(&ConnRequestCompleteQ, Req, TCPReq, tr_q);
                        CHECK_STRUCT(Req, tr);
                        CHECK_STRUCT(*(TCPConnReq **)&Req, tcr);

                        KeReleaseSpinLock(&RequestCompleteLock, OldIrql);
                        (*Req->tr_rtn)(Req->tr_context, Req->tr_status, 0);
                        FreeConnReq((TCPConnReq *)Req);
                        KeAcquireSpinLock(&RequestCompleteLock, &OldIrql);

                    } else
                        RequestCompleteFlags &= ~CONN_REQUEST_COMPLETE;
                }

                if (RequestCompleteFlags & SEND_REQUEST_COMPLETE) {
                    if (!EMPTYQ(&SendCompleteQ)) {
                        TCPSendReq *SendReq;

                        DEQUEUE(&SendCompleteQ, Req, TCPReq, tr_q);
                        CHECK_STRUCT(Req, tr);
                        SendReq = (TCPSendReq *)Req;
                        CHECK_STRUCT(SendReq, tsr);

                        KeReleaseSpinLock(&RequestCompleteLock, OldIrql);
                        (*Req->tr_rtn)(Req->tr_context, Req->tr_status,
                            Req->tr_status == TDI_SUCCESS ? SendReq->tsr_size
                            : 0);
                        FreeSendReq((TCPSendReq *)Req);
                        KeAcquireSpinLock(&RequestCompleteLock, &OldIrql);

                    } else
                        RequestCompleteFlags &= ~SEND_REQUEST_COMPLETE;
                }

            } while (RequestCompleteFlags & ANY_REQUEST_COMPLETE);

            RequestCompleteFlags &= ~IN_RCV_COMPLETE;
        }
        KeReleaseSpinLock(&RequestCompleteLock, OldIrql);
    }

    ProcessTCBDelayQ();
}


//* ReleaseConnReq - Complete a connection request.
//
//  A utility function to release a connection request which may or may not
//  have come from a TCB. We assume the TCB is readable when we're called
//  (i.e. the caller holds a lock or a reference).
//
void                        // Returns: Nothing.
ReleaseConnReq(
    TCB *CmpltTCB,          // TCB from which to get addressing information.
    TCPConnReq *ConnReq,    // ConnReq to do away with.
    TDI_STATUS Status)      // Status with which to complete.
{
    //
    // Fill in the connection information, then enqueue the ConnReq
    // for completion.
    //
    UpdateConnInfo(ConnReq->tcr_conninfo, &CmpltTCB->tcb_daddr,
                   CmpltTCB->tcb_dscope_id, CmpltTCB->tcb_dport);
    if (ConnReq->tcr_addrinfo) {
        UpdateConnInfo(ConnReq->tcr_addrinfo, &CmpltTCB->tcb_saddr,
                       CmpltTCB->tcb_sscope_id, CmpltTCB->tcb_sport);
    }

    ConnReq->tcr_req.tr_status = Status;
    KeAcquireSpinLockAtDpcLevel(&RequestCompleteLock);
    RequestCompleteFlags |= CONN_REQUEST_COMPLETE;
    ENQUEUE(&ConnRequestCompleteQ, &ConnReq->tcr_req.tr_q);
    KeReleaseSpinLockFromDpcLevel(&RequestCompleteLock);
}

//* CompleteConnReq - Complete a connection request on a TCB.
//
//  A utility function to complete a connection request on a TCB.  We remove
//  the connreq, and put it on the ConnReqCmpltQ where it will be picked
//  off later during RcvCmplt processing.  We assume the TCB lock is held when
//  we're called.
//
void                    //  Returns: Nothing.
CompleteConnReq(
    TCB *CmpltTCB,      // TCB from which to complete.
    TDI_STATUS Status)  // Status to complete with.
{
    TCPConnReq *ConnReq;

    CHECK_STRUCT(CmpltTCB, tcb);

    ConnReq = CmpltTCB->tcb_connreq;
    if (ConnReq != NULL) {
        //
        // There's a connreq on this TCB.  Fill in the connection information
        // before returning it.
        //
        CmpltTCB->tcb_connreq = NULL;
        ReleaseConnReq(CmpltTCB, ConnReq, Status);

    } else if (!((CmpltTCB->tcb_state == TCB_SYN_RCVD) &&
               (CmpltTCB->tcb_flags & ACCEPT_PENDING))) {
        //
        // This should not happen except
        // in the case of SynAttackProtect.
        //

        ASSERT(FALSE);
    }
}

//* DelayedAcceptConn - Process delayed-connect request.
//
//  Called by TCPRcv when SynAttackProtection is turned on, when a final
//  ACK arrives in response to our SYN-ACK. Indicate the connect request to
//  ULP and if it is accepted init TCB and move con to appropriate queue on AO.
//  The caller must hold the AddrObjTableLock before calling this routine,
//  and that lock must have been taken at DPC level.  This routine will free
//  that lock back to DPC level.
//  Returns TRUE if the request is accepted.
//
BOOLEAN
DelayedAcceptConn(
    AddrObj *ListenAO,  // AddrObj for local address.
    IPv6Addr *Src,      // Source IP address of SYN.
    ulong SrcScopeId,   // Scope id of source address (0 for non-scope addr).
    ushort SrcPort,     // Source port of SYN.
    TCB *AcceptTCB)     // Pre-accepted TCB
{
    TCPConn *CurrentConn = NULL;
    Queue *Temp;
    TCPConnReq *ConnReq = NULL;
    BOOLEAN FoundConn = FALSE;
    uchar TAddress[TCP_TA_SIZE];
    PVOID ConnContext;
    PConnectEvent Event;
    PVOID EventContext;
    TDI_STATUS Status;
    PTCP_CONTEXT TcpContext = NULL;
    ConnectEventInfo *EventInfo;

    CHECK_STRUCT(ListenAO, ao);
    KeAcquireSpinLockAtDpcLevel(&ListenAO->ao_lock);
    KeReleaseSpinLockFromDpcLevel(&AddrObjTableLock);

    if (!AO_VALID(ListenAO) || ListenAO->ao_connect == NULL) {
        KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);
        return FALSE;
    }

    // He has a connect handler. Put the transport address together,
    // and call him. We also need to get the necessary resources
    // first.

    Event = ListenAO->ao_connect;
    EventContext = ListenAO->ao_conncontext;
    REF_AO(ListenAO);

    KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);

    ConnReq = GetConnReq();

    if (ConnReq != NULL) {
        BuildTDIAddress(TAddress, Src, SrcScopeId, SrcPort);

        IF_TCPDBG(TCP_DEBUG_CONNECT) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                "indicating connect request\n"));
        }

        Status = (*Event) (EventContext, TCP_TA_SIZE,
                           (PTRANSPORT_ADDRESS) TAddress, 0, NULL, 0, NULL,
                           &ConnContext, &EventInfo);

        if (Status == TDI_MORE_PROCESSING) {
            PIO_STACK_LOCATION IrpSp;
            PTDI_REQUEST_KERNEL_ACCEPT AcceptRequest;

            IrpSp = IoGetCurrentIrpStackLocation(EventInfo);

            Status = TCPPrepareIrpForCancel((PTCP_CONTEXT) IrpSp->FileObject->FsContext,
                                            EventInfo, TCPCancelRequest);

            if (!NT_SUCCESS(Status)) {
                Status = TDI_NOT_ACCEPTED;
                EventInfo = NULL;
                goto AcceptIrpCancelled;
            }

            //
            // He accepted it. Find the connection on the AddrObj.
            //

            IF_TCPDBG(TCP_DEBUG_CONNECT) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                    "connect indication accepted, queueing request\n"
                    ));
            }

            AcceptRequest = (PTDI_REQUEST_KERNEL_ACCEPT)
                    & (IrpSp->Parameters);
            ConnReq->tcr_conninfo =
                AcceptRequest->ReturnConnectionInformation;
            if (AcceptRequest->RequestConnectionInformation &&
                AcceptRequest->RequestConnectionInformation->
                    RemoteAddress) {
                ConnReq->tcr_addrinfo =
                    AcceptRequest->RequestConnectionInformation;
            } else {
                ConnReq->tcr_addrinfo = NULL;
            }

            ConnReq->tcr_req.tr_rtn = TCPRequestComplete;
            ConnReq->tcr_req.tr_context = EventInfo;
SearchAO:

            KeAcquireSpinLockAtDpcLevel(&ListenAO->ao_lock);

            Temp = QHEAD(&ListenAO->ao_idleq);;

            Status = TDI_INVALID_CONNECTION;

            while (Temp != QEND(&ListenAO->ao_idleq)) {

                CurrentConn = QSTRUCT(TCPConn, Temp, tc_q);
                CHECK_STRUCT(CurrentConn, tc);
                if ((CurrentConn->tc_context == ConnContext) &&
                    !(CurrentConn->tc_flags & CONN_INVALID)) {

                    //
                    // We need to lock its TCPConnBlock, with care.
                    // We'll ref the TCPConn so it can't go away,
                    // then unlock the AO (which is already ref'd),
                    // then relock. Note that tc_refcnt is updated
                    // under ao_lock for any associated TCPConn.
                    // If things have changed, go back and try again.
                    //
                    ++CurrentConn->tc_refcnt;
                    KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);

                    KeAcquireSpinLockAtDpcLevel(
                        &CurrentConn->tc_ConnBlock->cb_lock);

                    //
                    // Now that we've got the lock, we need to consider
                    // the following possibilities:
                    //
                    // * a disassociate was initiated
                    // * a close was initiated
                    // * accept completed
                    // * listen completed
                    // * connect completed
                    //
                    // The first two require that we clean up,
                    // by calling the tc_donertn. For the last three,
                    // we have nothing to do, but tc_donertn points at
                    // DummyDone, so go ahead and call it anyway;
                    // it'll release the TCPConnBlock lock for us.
                    //
                    if (--CurrentConn->tc_refcnt == 0 &&
                        ((CurrentConn->tc_flags & CONN_INVALID) ||
                         (CurrentConn->tc_tcb != NULL))) {
                        ConnDoneRtn DoneRtn = CurrentConn->tc_donertn;
                        DoneRtn(CurrentConn, DISPATCH_LEVEL);
                        goto SearchAO;
                    }

                    KeAcquireSpinLockAtDpcLevel(&ListenAO->ao_lock);
                    KeAcquireSpinLockAtDpcLevel(&AcceptTCB->tcb_lock);

                    // We think we have a match. The connection
                    // shouldn't have a TCB associated with it. If it
                    // does, it's an error. InitTCBFromConn will
                    // handle all this, but first confirm that
                    // ACCEPT_PENDING is still set. If it isn't,
                    // someone accepted this before we did.

                    if (AcceptTCB->tcb_flags & ACCEPT_PENDING) {
                        Status = InitTCBFromConn(CurrentConn, AcceptTCB,
                                                 AcceptRequest->RequestConnectionInformation,
                                                 TRUE);
                    } else {
                        Status = TDI_INVALID_STATE;
                    }

                    if (Status == TDI_SUCCESS) {
                        FoundConn = TRUE;
                        AcceptTCB->tcb_flags &= ~ACCEPT_PENDING;
                        AcceptTCB->tcb_connreq = ConnReq;
                        AcceptTCB->tcb_conn = CurrentConn;
                        AcceptTCB->tcb_connid = CurrentConn->tc_connid;
                        CurrentConn->tc_tcb = AcceptTCB;
                        CurrentConn->tc_refcnt++;
                        KeReleaseSpinLockFromDpcLevel(&AcceptTCB->tcb_lock);


                        // Move him from the idle q to the active
                        // queue.

                        REMOVEQ(&CurrentConn->tc_q);
                        ENQUEUE(&ListenAO->ao_activeq, &CurrentConn->tc_q);
                    } else {
                        KeReleaseSpinLockFromDpcLevel(&AcceptTCB->tcb_lock);
                        KeReleaseSpinLockFromDpcLevel(
                                &CurrentConn->tc_ConnBlock->cb_lock);
                    }

                    // In any case, we're done now.
                    break;
                }

                Temp = QNEXT(Temp);
            }

            LOCKED_DELAY_DEREF_AO(ListenAO);
            KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);
            if (FoundConn) {
                KeReleaseSpinLockFromDpcLevel(
                    &CurrentConn->tc_ConnBlock->cb_lock);
            } else {
                //
                // We have to complete the abandoned ConnReq,
                // then we're done.
                //
                ReleaseConnReq(AcceptTCB, ConnReq, Status);
            }

            return FoundConn;
        }

        //
        // The event handler didn't take it. Dereference it, free
        // the resources, and return NULL.
        //
    }

AcceptIrpCancelled:
    //
    // We couldn't get a new TCPConnReq, or the client didn't want it.
    //

    if (ConnReq != NULL) {
        FreeConnReq(ConnReq);
    }
    DELAY_DEREF_AO(ListenAO);
    return FALSE;
}




//* FindListenConn - Find (or fabricate) a listening connection.
//
//  Called by our Receive handler to decide what to do about an incoming
//  SYN.  We walk down the list of connections associated with the destination
//  address, and if we find any in the listening state that can be used for
//  the incoming request we'll take them, possibly returning a listen in the
//  process.  If we don't find any appropriate listening connections, we'll
//  call the Connect Event handler if one is registered.  If all else fails,
//  we'll return NULL and the SYN will be RST.
//
//  The caller must hold the AddrObjTableLock before calling this routine,
//  and that lock must have been taken at DPC level.  This routine will free
//  that lock back to DPC level.
//
TCB *  // Returns: Pointer to found TCB, or NULL if we can't find one.
FindListenConn(
    AddrObj *ListenAO,  // AddrObj for local address.
    IPv6Addr *Src,      // Source IP address of SYN.
    ulong SrcScopeId,   // Scope id of source address (0 for non-scope addr).
    ushort SrcPort)     // Source port of SYN.
{
    TCB *CurrentTCB = NULL;
    TCPConn *CurrentConn = NULL;
    TCPConnReq *ConnReq = NULL;
    Queue *Temp;
    uint FoundConn = FALSE;

    CHECK_STRUCT(ListenAO, ao);

    KeAcquireSpinLockAtDpcLevel(&ListenAO->ao_lock);

    KeReleaseSpinLockFromDpcLevel(&AddrObjTableLock);

    //
    // We have the lock on the AddrObj.  Walk down its list, looking
    // for connections in the listening state.
    //
    if (AO_VALID(ListenAO)) {
        if (ListenAO->ao_listencnt != 0) {

            Temp = QHEAD(&ListenAO->ao_listenq);
            while (Temp != QEND(&ListenAO->ao_listenq)) {

                CurrentConn = QSTRUCT(TCPConn, Temp, tc_q);
                CHECK_STRUCT(CurrentConn, tc);

                KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);
                KeAcquireSpinLockAtDpcLevel(&CurrentConn->tc_ConnBlock->cb_lock);
                KeAcquireSpinLockAtDpcLevel(&ListenAO->ao_lock);

                //
                // If this TCB is in the listening state, with no delete
                // pending, it's a candidate.  Look at the pending listen
                // information to see if we should take it.
                //
                if ((CurrentTCB = CurrentConn->tc_tcb) != NULL &&
                    CurrentTCB->tcb_state == TCB_LISTEN) {

                    CHECK_STRUCT(CurrentTCB, tcb);

                    KeAcquireSpinLockAtDpcLevel(&CurrentTCB->tcb_lock);

                    if (CurrentTCB->tcb_state == TCB_LISTEN &&
                        !PENDING_ACTION(CurrentTCB)) {

                        //
                        // Need to see if we can take it.
                        // See if the addresses specifed in the ConnReq match.
                        //
                        if ((IsUnspecified(&CurrentTCB->tcb_daddr) ||
                             (IP6_ADDR_EQUAL(&CurrentTCB->tcb_daddr, Src) &&
                              (CurrentTCB->tcb_dscope_id == SrcScopeId))) &&
                            (CurrentTCB->tcb_dport == 0 ||
                             CurrentTCB->tcb_dport == SrcPort)) {
                            FoundConn = TRUE;
                            break;
                        }

                        //
                        // Otherwise, this didn't match, so we'll check the
                        // next one.
                        //
                    }
                    KeReleaseSpinLockFromDpcLevel(&CurrentTCB->tcb_lock);
                }
                KeReleaseSpinLockFromDpcLevel(&CurrentConn->tc_ConnBlock->cb_lock);

                Temp = QNEXT(Temp);;
            }

            //
            // See why we've exited the loop.
            //
            if (FoundConn) {
                CHECK_STRUCT(CurrentTCB, tcb);

                //
                // We exited because we found a TCB.  If it's pre-accepted,
                // we're done.
                //
                CurrentTCB->tcb_refcnt++;

                ASSERT(CurrentTCB->tcb_connreq != NULL);

                ConnReq = CurrentTCB->tcb_connreq;
                //
                // If QUERY_ACCEPT isn't set, turn on the CONN_ACCEPTED bit.
                //
                if (!(ConnReq->tcr_flags & TDI_QUERY_ACCEPT))
                    CurrentTCB->tcb_flags |= CONN_ACCEPTED;

                CurrentTCB->tcb_state = TCB_SYN_RCVD;

                ListenAO->ao_listencnt--;

                //
                // Since he's no longer listening, remove him from the listen
                // queue and put him on the active queue.
                //
                REMOVEQ(&CurrentConn->tc_q);
                ENQUEUE(&ListenAO->ao_activeq, &CurrentConn->tc_q);

                KeReleaseSpinLockFromDpcLevel(&CurrentTCB->tcb_lock);
                KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);
                KeReleaseSpinLockFromDpcLevel(&CurrentConn->tc_ConnBlock->cb_lock);
                return CurrentTCB;
            }
        }


        //
        // We didn't find a matching TCB.
        //

        ASSERT(FoundConn == FALSE);

        //
        // If there's no connect indication handler, we're done.
        //

        if (ListenAO->ao_connect == NULL) {
            KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);
            return NULL;
        }

        if (SynAttackProtect) {
            TCB *AcceptTCB;

            //
            // SynAttack protection is on. Just initialize
            // this TCB and send SYN-ACK. When final
            // ACK is seen we will indicate about this
            // connection arrival to upper layer.
            //

            AcceptTCB = AllocTCB();

            if (AcceptTCB != NULL) {

                AcceptTCB->tcb_state = TCB_SYN_RCVD;
                AcceptTCB->tcb_connreq = NULL;
                AcceptTCB->tcb_flags |= (CONN_ACCEPTED | ACCEPT_PENDING);
                AcceptTCB->tcb_refcnt = 1;
                AcceptTCB->tcb_defaultwin = DEFAULT_RCV_WIN;
                AcceptTCB->tcb_rcvwin = DEFAULT_RCV_WIN;

                //
                // This TCB isn't going through the InitTCBFromConn logic (yet)
                // so perform minimal initialization on it now. In particular,
                // inherit any AddrObj settings that we care about during
                // connection-acceptance.
                //

                AcceptTCB->tcb_hops = ListenAO->ao_ucast_hops;

                IF_TCPDBG(TCP_DEBUG_CONNECT) {
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "Allocated SP TCB %x\n", (PCHAR)AcceptTCB));
                }
            }

            KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);

            return AcceptTCB;
        } else {
            uchar TAddress[TCP_TA_SIZE];
            PVOID ConnContext;
            PConnectEvent Event;
            PVOID EventContext;
            TDI_STATUS Status;
            TCB *AcceptTCB;
            ConnectEventInfo *EventInfo;

            //
            // He has a connect handler.  Put the transport address together,
            // and call him.  We also need to get the necessary resources
            // first.
            //

            Event = ListenAO->ao_connect;
            EventContext = ListenAO->ao_conncontext;
            REF_AO(ListenAO);
            KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);

            AcceptTCB = AllocTCB();
            ConnReq = GetConnReq();

            if (AcceptTCB != NULL && ConnReq != NULL) {
                BuildTDIAddress(TAddress, Src, SrcScopeId, SrcPort);

                AcceptTCB->tcb_state = TCB_LISTEN;
                AcceptTCB->tcb_connreq = ConnReq;
                AcceptTCB->tcb_flags |= CONN_ACCEPTED;

                IF_TCPDBG(TCP_DEBUG_CONNECT) {
                    KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                               "indicating connect request\n"));
                }

                Status = (*Event)(EventContext, TCP_TA_SIZE,
                                  (PTRANSPORT_ADDRESS)TAddress, 0, NULL,
                                  0, NULL,
                                  &ConnContext, &EventInfo);

                if (Status == TDI_MORE_PROCESSING) {
                    PIO_STACK_LOCATION IrpSp;
                    PTDI_REQUEST_KERNEL_ACCEPT AcceptRequest;

                    IrpSp = IoGetCurrentIrpStackLocation(EventInfo);

                    Status = TCPPrepareIrpForCancel(
                        (PTCP_CONTEXT) IrpSp->FileObject->FsContext,
                        EventInfo, TCPCancelRequest);

                    if (!NT_SUCCESS(Status)) {
                        Status = TDI_NOT_ACCEPTED;
                        EventInfo = NULL;
                        goto AcceptIrpCancelled;
                    }

                    //
                    // He accepted it.  Find the connection on the AddrObj.
                    //
                    {
                        IF_TCPDBG(TCP_DEBUG_CONNECT) {
                            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                                       "connect indication accepted,"
                                       " queueing request\n"));
                        }

                        AcceptRequest = (PTDI_REQUEST_KERNEL_ACCEPT)
                            &(IrpSp->Parameters);
                        ConnReq->tcr_conninfo =
                            AcceptRequest->ReturnConnectionInformation;
                        if (AcceptRequest->RequestConnectionInformation &&
                            AcceptRequest->RequestConnectionInformation->
                                RemoteAddress) {
                            ConnReq->tcr_addrinfo =
                                AcceptRequest->RequestConnectionInformation;
                        } else {
                            ConnReq->tcr_addrinfo = NULL;
                        }
                        ConnReq->tcr_req.tr_rtn = TCPRequestComplete;
                        ConnReq->tcr_req.tr_context = EventInfo;
                    }
SearchAO:
                    KeAcquireSpinLockAtDpcLevel(&ListenAO->ao_lock);
                    Temp = QHEAD(&ListenAO->ao_idleq);
                    CurrentTCB = NULL;
                    Status = TDI_INVALID_CONNECTION;

                    while (Temp != QEND(&ListenAO->ao_idleq)) {

                        CurrentConn = QSTRUCT(TCPConn, Temp, tc_q);

                        CHECK_STRUCT(CurrentConn, tc);
                        if ((CurrentConn->tc_context == ConnContext) &&
                            !(CurrentConn->tc_flags & CONN_INVALID)) {

                            //
                            // We need to lock its TCPConnBlock, with care.
                            // We'll ref the TCPConn so it can't go away,
                            // then unlock the AO (which is already ref'd),
                            // then relock. Note that tc_refcnt is updated
                            // under ao_lock for any associated TCPConn.
                            // If things have changed, go back and try again.
                            //
                            ++CurrentConn->tc_refcnt;
                            KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);

                            KeAcquireSpinLockAtDpcLevel(
                                &CurrentConn->tc_ConnBlock->cb_lock);

                            //
                            // Now that we've got the lock, we need to consider
                            // the following possibilities:
                            //
                            // * a disassociate was initiated
                            // * a close was initiated
                            // * accept completed
                            // * listen completed
                            // * connect completed
                            //
                            // The first two require that we clean up,
                            // by calling the tc_donertn. For the last three,
                            // we have nothing to do, but tc_donertn points at
                            // DummyDone, so go ahead and call it anyway;
                            // it'll release the TCPConnBlock lock for us.
                            //
                            if (--CurrentConn->tc_refcnt == 0 &&
                                ((CurrentConn->tc_flags & CONN_INVALID) ||
                                 (CurrentConn->tc_tcb != NULL))) {
                                ConnDoneRtn DoneRtn = CurrentConn->tc_donertn;
                                DoneRtn(CurrentConn, DISPATCH_LEVEL);
                                goto SearchAO;
                            }

                            KeAcquireSpinLockAtDpcLevel(&ListenAO->ao_lock);

                            //
                            // We think we have a match. The connection
                            // shouldn't have a TCB associated with it. If it
                            // does, it's an error. InitTCBFromConn will
                            // handle all this.
                            //
                            AcceptTCB->tcb_refcnt = 1;
                            Status = InitTCBFromConn(CurrentConn, AcceptTCB,
                                   AcceptRequest->RequestConnectionInformation,
                                                     TRUE);
                            if (Status == TDI_SUCCESS) {
                                FoundConn = TRUE;
                                AcceptTCB->tcb_state = TCB_SYN_RCVD;
                                AcceptTCB->tcb_conn = CurrentConn;
                                AcceptTCB->tcb_connid = CurrentConn->tc_connid;
                                CurrentConn->tc_tcb = AcceptTCB;
                                CurrentConn->tc_refcnt++;

                                //
                                // Move him from the idle queue to the
                                // active queue.
                                //
                                REMOVEQ(&CurrentConn->tc_q);
                                ENQUEUE(&ListenAO->ao_activeq,
                                        &CurrentConn->tc_q);
                            } else
                                KeReleaseSpinLockFromDpcLevel(
                                    &CurrentConn->tc_ConnBlock->cb_lock);

                            // In any case, we're done now.
                            break;
                        }
                        Temp = QNEXT(Temp);
                    }

                    if (!FoundConn) {
                        //
                        // Didn't find a match, or had an error.
                        // Status code is set.
                        // Complete the ConnReq and free the resources.
                        //
                        CompleteConnReq(AcceptTCB, Status);
                        FreeTCB(AcceptTCB);
                        AcceptTCB = NULL;
                    }

                    LOCKED_DELAY_DEREF_AO(ListenAO);
                    KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);
                    if (FoundConn) {
                        KeReleaseSpinLockFromDpcLevel(
                            &CurrentConn->tc_ConnBlock->cb_lock);
                    }

                    return AcceptTCB;
                }
            }
AcceptIrpCancelled:
            //
            // We couldn't get a needed resource or event handler
            // did not take this.  Free any that we
            // did get, and fall through to the 'return NULL' code.
            //
            if (ConnReq != NULL)
                FreeConnReq(ConnReq);
            if (AcceptTCB != NULL)
                FreeTCB(AcceptTCB);
            DELAY_DEREF_AO(ListenAO);

        }

        return NULL;
    }

    //
    // If we get here, the address object wasn't valid.
    //
    KeReleaseSpinLockFromDpcLevel(&ListenAO->ao_lock);
    return NULL;
}


//* FindMSS - Find the MSS option in a segment.
//
//  Called when a SYN is received to find the MSS option in a segment.
//  If we don't find one, we assume the worst and return one based on
//  the minimum MTU.
//
ushort                         //  Returns: MSS to be used.
FindMSS(
    TCPHeader UNALIGNED *TCP)  // TCP header to be searched.
{
    uint OptSize;
    uchar *OptPtr;

    OptSize = TCP_HDR_SIZE(TCP) - sizeof(TCPHeader);
    OptPtr = (uchar *)(TCP + 1);

    while (OptSize) {

        if (*OptPtr == TCP_OPT_EOL)
            break;

        if (*OptPtr == TCP_OPT_NOP) {
            OptPtr++;
            OptSize--;
            continue;
        }

        if (*OptPtr == TCP_OPT_MSS) {
            if (OptSize >= MSS_OPT_SIZE && OptPtr[1] == MSS_OPT_SIZE) {
                ushort TempMss = *(ushort UNALIGNED *)(OptPtr + 2);
                if (TempMss != 0)
                    return net_short(TempMss);
                else
                    break;  // MSS size of 0, use default.
            } else
                break;      // Bad option size, use default.
        } else {
            //
            // Unknown option.  Skip over it.
            //
            if (OptSize < 2 || OptPtr[1] == 0 || OptPtr[1] > OptSize)
                break;      // Bad option length, bail out.

            OptSize -= OptPtr[1];
            OptPtr += OptPtr[1];
        }
    }

    return DEFAULT_MSS;
}


//* ACKAndDrop - Acknowledge a segment, and drop it.
//
//  Called from within the receive code when we need to drop a segment that's
//  outside the receive window.
//
void                 // Returns: Nothing.
ACKAndDrop(
    TCPRcvInfo *RI,  // Receive info for incoming segment.
    TCB *RcvTCB)     // TCB for incoming segment.
{

    if (!(RI->tri_flags & TCP_FLAG_RST)) {

        if (RcvTCB->tcb_state == TCB_TIME_WAIT) {
            //
            // In TIME_WAIT, we only ACK duplicates/retransmissions
            // of our peer's FIN segment.
            //
            // REVIEW: We're currently fairly loose on the sequence
            // number check here.
            //
            if ((RI->tri_flags & TCP_FLAG_FIN) &&
                SEQ_LTE(RI->tri_seq, RcvTCB->tcb_rcvnext)) {
                // Restart 2MSL timer and proceed with sending the ACK.
                START_TCB_TIMER(RcvTCB->tcb_rexmittimer, MAX_REXMIT_TO);
            } else {
                // Drop this segment without an ACK.
                DerefTCB(RcvTCB, DISPATCH_LEVEL);
                return;
            }
        }

        KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);

        SendACK(RcvTCB);

        KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
    }
    DerefTCB(RcvTCB, DISPATCH_LEVEL);
}


//* ACKData - Acknowledge data.
//
//  Called from the receive handler to acknowledge data.  We're given the
//  TCB and the new value of senduna.  We walk down the send queue pulling
//  off sends and putting them on the complete queue until we hit the end
//  or we acknowledge the specified number of bytes of data.
//
//  NOTE: We manipulate the send refcnt and acked flag without taking a lock.
//  This is OK in the VxD version where locks don't mean anything anyway, but
//  in the port to NT we'll need to add locking.  The lock will have to be
//  taken in the transmit complete routine.  We can't use a lock in the TCB,
//  since the TCB could go away before the transmit complete happens, and a
//  lock in the TSR would be overkill, so it's probably best to use a global
//  lock for this.  If that causes too much contention, we could use a set of
//  locks and pass a pointer to the appropriate lock back as part of the
//  transmit confirm context.  This lock pointer would also need to be stored
//  in the TCB.
//
void                 // Returns: Nothing.
ACKData(
    TCB *ACKTcb,     // TCB from which to pull data.
    SeqNum SendUNA)  // New value of send una.
{
    Queue *End, *Current;        // End and current elements.
    Queue *TempQ, *EndQ;
    Queue *LastCmplt;            // Last one we completed.
    TCPSendReq *CurrentTSR;      // Current send req we're looking at.
    PNDIS_BUFFER CurrentBuffer;  // Current NDIS_BUFFER.
    uint Updated = FALSE;
    uint BufLength;
    int Amount, OrigAmount;
    long Result;
    KIRQL OldIrql;
    uint Temp;

    CHECK_STRUCT(ACKTcb, tcb);

    CheckTCBSends(ACKTcb);

    Amount = SendUNA - ACKTcb->tcb_senduna;
    ASSERT(Amount > 0);

    //
    // Since this is an acknowledgement of receipt by our peer for previously
    // unacknowledged data, it implies forward reachablility.
    //
    if (ACKTcb->tcb_rce != NULL)
        ConfirmForwardReachability(ACKTcb->tcb_rce);

    //
    // Do a quick check to see if this acks everything that we have.  If it
    // does, handle it right away.  We can only do this in the ESTABLISHED
    // state, because we blindly update sendnext, and that can only work if we
    // haven't sent a FIN.
    //
    if ((Amount == (int) ACKTcb->tcb_unacked) &&
        ACKTcb->tcb_state == TCB_ESTAB) {

        //
        // Everything is acked.
        //
        ASSERT(!EMPTYQ(&ACKTcb->tcb_sendq));

        TempQ = ACKTcb->tcb_sendq.q_next;

        INITQ(&ACKTcb->tcb_sendq);

        ACKTcb->tcb_sendnext = SendUNA;
        ACKTcb->tcb_senduna = SendUNA;

        ASSERT(ACKTcb->tcb_sendnext == ACKTcb->tcb_sendmax);
        ACKTcb->tcb_cursend = NULL;
        ACKTcb->tcb_sendbuf = NULL;
        ACKTcb->tcb_sendofs = 0;
        ACKTcb->tcb_sendsize = 0;
        ACKTcb->tcb_unacked = 0;

        //
        // Now walk down the list of send requests.  If the reference count
        // has gone to 0, put it on the send complete queue.
        //
        KeAcquireSpinLock(&RequestCompleteLock, &OldIrql);
        EndQ = &ACKTcb->tcb_sendq;
        do {
            CurrentTSR = CONTAINING_RECORD(QSTRUCT(TCPReq, TempQ, tr_q),
                                           TCPSendReq, tsr_req);

            CHECK_STRUCT(CurrentTSR, tsr);

            TempQ = CurrentTSR->tsr_req.tr_q.q_next;

            CurrentTSR->tsr_req.tr_status = TDI_SUCCESS;
            Result = InterlockedDecrement(&CurrentTSR->tsr_refcnt);

            ASSERT(Result >= 0);

            if (Result <= 0) {
                // No more references are outstanding, the send can be
                // completed.

                // If we've sent directly from this send, NULL out the next
                // pointer for the last buffer in the chain.
                if (CurrentTSR->tsr_lastbuf != NULL) {
                    NDIS_BUFFER_LINKAGE(CurrentTSR->tsr_lastbuf) = NULL;
                    CurrentTSR->tsr_lastbuf = NULL;
                }
                ACKTcb->tcb_totaltime += (TCPTime - CurrentTSR->tsr_time);
                Temp = ACKTcb->tcb_bcountlow;
                ACKTcb->tcb_bcountlow += CurrentTSR->tsr_size;
                ACKTcb->tcb_bcounthi += (Temp > ACKTcb->tcb_bcountlow ? 1 : 0);

                ENQUEUE(&SendCompleteQ, &CurrentTSR->tsr_req.tr_q);
            }

        } while (TempQ != EndQ);

        RequestCompleteFlags |= SEND_REQUEST_COMPLETE;
        KeReleaseSpinLock(&RequestCompleteLock, OldIrql);

        CheckTCBSends(ACKTcb);
        return;
    }

    OrigAmount = Amount;
    End = QEND(&ACKTcb->tcb_sendq);
    Current = QHEAD(&ACKTcb->tcb_sendq);

    LastCmplt = NULL;

    while (Amount > 0 && Current != End) {
        CurrentTSR = CONTAINING_RECORD(QSTRUCT(TCPReq, Current, tr_q),
                                       TCPSendReq, tsr_req);
        CHECK_STRUCT(CurrentTSR, tsr);

        if (Amount >= (int) CurrentTSR->tsr_unasize) {
            // This is completely acked.  Just advance to the next one.
            Amount -= CurrentTSR->tsr_unasize;

            LastCmplt = Current;

            Current = QNEXT(Current);
            continue;
        }

        //
        // This one is only partially acked.  Update his offset and NDIS buffer
        // pointer, and break out.  We know that Amount is < the unacked size
        // in this buffer, we we can walk the NDIS buffer chain without fear
        // of falling off the end.
        //
        CurrentBuffer = CurrentTSR->tsr_buffer;
        ASSERT(CurrentBuffer != NULL);
        ASSERT(Amount < (int) CurrentTSR->tsr_unasize);
        CurrentTSR->tsr_unasize -= Amount;

        BufLength = NdisBufferLength(CurrentBuffer) - CurrentTSR->tsr_offset;

        if (Amount >= (int) BufLength) {
            do {
                Amount -= BufLength;
                CurrentBuffer = NDIS_BUFFER_LINKAGE(CurrentBuffer);
                ASSERT(CurrentBuffer != NULL);
                BufLength = NdisBufferLength(CurrentBuffer);
            } while (Amount >= (int) BufLength);

            CurrentTSR->tsr_offset = Amount;
            CurrentTSR->tsr_buffer = CurrentBuffer;

        } else
            CurrentTSR->tsr_offset += Amount;

        Amount = 0;

        break;
    }

#if DBG
    //
    // We should always be able to remove at least Amount bytes, except in
    // the case where a FIN has been sent.  In that case we should be off
    // by exactly one.  In the debug builds we'll check this.
    //
    if (Amount != 0 && (!(ACKTcb->tcb_flags & FIN_SENT) || Amount != 1))
        DbgBreakPoint();
#endif

    if (SEQ_GT(SendUNA, ACKTcb->tcb_sendnext)) {

        if (Current != End) {
            //
            // Need to reevaluate CurrentTSR, in case we bailed out of the
            // above loop after updating Current but before updating
            // CurrentTSR.
            //
            CurrentTSR = CONTAINING_RECORD(QSTRUCT(TCPReq, Current, tr_q),
                                           TCPSendReq, tsr_req);
            CHECK_STRUCT(CurrentTSR, tsr);
            ACKTcb->tcb_cursend = CurrentTSR;
            ACKTcb->tcb_sendbuf = CurrentTSR->tsr_buffer;
            ACKTcb->tcb_sendofs = CurrentTSR->tsr_offset;
            ACKTcb->tcb_sendsize = CurrentTSR->tsr_unasize;
        } else {
            ACKTcb->tcb_cursend = NULL;
            ACKTcb->tcb_sendbuf = NULL;
            ACKTcb->tcb_sendofs = 0;
            ACKTcb->tcb_sendsize = 0;
        }

        ACKTcb->tcb_sendnext = SendUNA;
    }

    //
    // Now update tcb_unacked with the amount we tried to ack minus the
    // amount we didn't ack (Amount should be 0 or 1 here).
    //
    ASSERT(Amount == 0 || Amount == 1);

    ACKTcb->tcb_unacked -= OrigAmount - Amount;
    ASSERT(*(int *)&ACKTcb->tcb_unacked >= 0);

    ACKTcb->tcb_senduna = SendUNA;

    //
    // If we've acked any here, LastCmplt will be non-null, and Current will
    // point to the send that should be at the start of the queue.  Splice
    // out the completed ones and put them on the end of the send completed
    // queue, and update the TCB send queue.
    //
    if (LastCmplt != NULL) {
        Queue *FirstCmplt;
        TCPSendReq *FirstTSR, *EndTSR;

        ASSERT(!EMPTYQ(&ACKTcb->tcb_sendq));

        FirstCmplt = QHEAD(&ACKTcb->tcb_sendq);

        //
        // If we've acked everything, just reinit the queue.
        //
        if (Current == End) {
            INITQ(&ACKTcb->tcb_sendq);
        } else {
            //
            // There's still something on the queue.  Just update it.
            //
            ACKTcb->tcb_sendq.q_next = Current;
            Current->q_prev = &ACKTcb->tcb_sendq;
        }

        CheckTCBSends(ACKTcb);

        //
        // Now walk down the lists of things acked.  If the refcnt on the send
        // is 0, go ahead and put him on the send complete Q.  Otherwise set
        // the ACKed bit in the send, and he'll be completed when the count
        // goes to 0 in the transmit confirm.
        //
        // Note that we haven't done any locking here. This will probably
        // need to change in the port to NT.
        //
        // Set FirstTSR to the first TSR we'll complete, and EndTSR to be
        // the first TSR that isn't completed.
        //
        FirstTSR = CONTAINING_RECORD(QSTRUCT(TCPReq, FirstCmplt, tr_q),
                                     TCPSendReq, tsr_req);
        EndTSR = CONTAINING_RECORD(QSTRUCT(TCPReq, Current, tr_q),
                                   TCPSendReq, tsr_req);

        CHECK_STRUCT(FirstTSR, tsr);
        ASSERT(FirstTSR != EndTSR);

        //
        // Now walk the list of ACKed TSRs.  If we can complete one, put him
        // on the complete queue.
        //
        KeAcquireSpinLockAtDpcLevel(&RequestCompleteLock);
        while (FirstTSR != EndTSR) {

            TempQ = QNEXT(&FirstTSR->tsr_req.tr_q);

            CHECK_STRUCT(FirstTSR, tsr);
            FirstTSR->tsr_req.tr_status = TDI_SUCCESS;

            //
            // The tsr_lastbuf->Next field is zapped to 0 when the tsr_refcnt
            // goes to 0, so we don't need to do it here.
            //
            // Decrement the reference put on the send buffer when it was
            // initialized indicating the send has been acknowledged.
            //
            Result = InterlockedDecrement(&(FirstTSR->tsr_refcnt));

            ASSERT(Result >= 0);
            if (Result <= 0) {
                //
                // No more references are outstanding, the send can be
                // completed.
                //
                // If we've sent directly from this send, NULL out the next
                // pointer for the last buffer in the chain.
                //
                if (FirstTSR->tsr_lastbuf != NULL) {
                    NDIS_BUFFER_LINKAGE(FirstTSR->tsr_lastbuf) = NULL;
                    FirstTSR->tsr_lastbuf = NULL;
                }

                ACKTcb->tcb_totaltime += (TCPTime - CurrentTSR->tsr_time);
                Temp = ACKTcb->tcb_bcountlow;
                ACKTcb->tcb_bcountlow += CurrentTSR->tsr_size;
                ACKTcb->tcb_bcounthi += (Temp > ACKTcb->tcb_bcountlow ? 1 : 0);
                ENQUEUE(&SendCompleteQ, &FirstTSR->tsr_req.tr_q);
            }

            FirstTSR = CONTAINING_RECORD(QSTRUCT(TCPReq, TempQ, tr_q),
                                         TCPSendReq, tsr_req);
        }
        RequestCompleteFlags |= SEND_REQUEST_COMPLETE;
        KeReleaseSpinLockFromDpcLevel(&RequestCompleteLock);
    }
}


//* TrimPacket - Trim the leading edge of a Packet.
//
//  A utility routine to trim the front of a Packet.  We take in an amount
//  to trim off (which may be 0) and adjust the pointer in the first buffer
//  in the chain forward by that much.  If there isn't that much in the first
//  buffer, we move onto the next one.  If we run out of buffers we'll return
//  a pointer to the last buffer in the chain, with a size of 0.  It's the
//  caller's responsibility to catch this.
//  REVIEW - Move this to subr.c?
//
IPv6Packet *  // Returns: A pointer to the new start, or NULL.
TrimPacket(
    IPv6Packet *Packet,  // Packet to be trimmed.
    uint TrimAmount)     // Amount to be trimmed.
{
    uint TrimThisTime;

    ASSERT(Packet != NULL);

    while (TrimAmount) {
        ASSERT(Packet != NULL);

        TrimThisTime = MIN(TrimAmount, Packet->ContigSize);

        TrimAmount -= TrimThisTime;
        Packet->Position += TrimThisTime;
        (uchar *)Packet->Data += TrimThisTime;
        Packet->TotalSize -= TrimThisTime;
        if ((Packet->ContigSize -= TrimThisTime) == 0) {
            //
            // Ran out of space in current buffer.
            // Check for possibility of more data buffers in current packet.
            //
            if (Packet->TotalSize != 0) {
                //
                // Get more contiguous data.
                //
                PacketPullupSubr(Packet, 0, 1, 0);
                continue;
            }

            //
            // Couldn't do a pullup, so see if there's another packet
            // hanging on this chain.
            //
            if (Packet->Next != NULL) {
                IPv6Packet *Temp;

                //
                // There's another packet following.  Toss this one.
                //
                Temp = Packet;
                Packet = Packet->Next;
                Temp->Next = NULL;
                FreePacketChain(Temp);
            } else {
                //
                // Ran out of Packets.  Just return this one.
                //
                break;
            }
        }
    }

    return Packet;
}


//* FreePacketChain - Free a Packet chain.
//
//  Called to free a chain of IPv6Packets.  Only want to free that which
//  we (the TCP/IPv6 stack) have allocated.  Don't try to free anything
//  passed up to us from lower layers.
//
void                     // Returns: Nothing.
FreePacketChain(
    IPv6Packet *Packet)  // First Packet in chain to be freed.
{
    void *Aux;

    while (Packet != NULL) {

        PacketPullupCleanup(Packet);

        if (Packet->Flags & PACKET_OURS) {
            IPv6Packet *Temp;

            Temp = Packet;
            Packet = Packet->Next;
            ExFreePool(Temp);
        } else
            Packet = Packet->Next;
    }
}


IPv6Packet DummyPacket;

//* PullFromRAQ - Pull segments from the reassembly queue.
//
//  Called when we've received frames out of order, and have some segments
//  on the reassembly queue.  We'll walk down the reassembly list, segments
//  that are overlapped by the current receive next variable.  When we get
//  to one that doesn't completely overlap we'll trim it to fit the next
//  receive sequence number, and pull it from the queue.
//
IPv6Packet *
PullFromRAQ(
    TCB *RcvTCB,          // TCB to pull from.
    TCPRcvInfo *RcvInfo,  // TCPRcvInfo structure for current segment.
    uint *Size)           // Where to update the size of the current segment.
{
    TCPRAHdr *CurrentTRH;   // Current TCP RA Header being examined.
    TCPRAHdr *TempTRH;      // Temporary variable.
    SeqNum NextSeq;         // Next sequence number we want.
    IPv6Packet *NewPacket;  // Packet after trimming.
    SeqNum NextTRHSeq;      // Sequence number immediately after current TRH.
    int Overlap;            // Overlap between current TRH and NextSeq.

    CHECK_STRUCT(RcvTCB, tcb);

    CurrentTRH = RcvTCB->tcb_raq;
    NextSeq = RcvTCB->tcb_rcvnext;

    while (CurrentTRH != NULL) {
        CHECK_STRUCT(CurrentTRH, trh);
        ASSERT(!(CurrentTRH->trh_flags & TCP_FLAG_SYN));

        if (SEQ_LT(NextSeq, CurrentTRH->trh_start)) {
#if DBG
            *Size = 0;
#endif
            return NULL;  // The next TRH starts too far down.
        }

        NextTRHSeq = CurrentTRH->trh_start + CurrentTRH->trh_size +
            ((CurrentTRH->trh_flags & TCP_FLAG_FIN) ? 1 : 0);

        if (SEQ_GTE(NextSeq, NextTRHSeq)) {
            //
            // The current TRH is overlapped completely.  Free it and continue.
            //
            FreePacketChain(CurrentTRH->trh_buffer);
            TempTRH = CurrentTRH->trh_next;
            ExFreePool(CurrentTRH);
            CurrentTRH = TempTRH;
            RcvTCB->tcb_raq = TempTRH;
            if (TempTRH == NULL) {
                //
                // We've just cleaned off the RAQ. We can go back on the
                // fast path now.
                //
                if (--(RcvTCB->tcb_slowcount) == 0) {
                    RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                    CheckTCBRcv(RcvTCB);
                }
                break;
            }
        } else {
            Overlap = NextSeq - CurrentTRH->trh_start;
            RcvInfo->tri_seq = NextSeq;
            RcvInfo->tri_flags = CurrentTRH->trh_flags;
            RcvInfo->tri_urgent = CurrentTRH->trh_urg;

            if (Overlap != (int) CurrentTRH->trh_size) {
                NewPacket = TrimPacket(CurrentTRH->trh_buffer, Overlap);
                *Size = CurrentTRH->trh_size - Overlap;
            } else {
                //
                // This completely overlaps the data in this segment, but the
                // sequence number doesn't overlap completely.  There must
                // be a FIN in the TRH.  We'll just return some bogus value
                // that nobody will look at with a size of 0.
                //
                FreePacketChain(CurrentTRH->trh_buffer);
                ASSERT(CurrentTRH->trh_flags & TCP_FLAG_FIN);
                NewPacket =&DummyPacket;
                *Size = 0;
            }

            RcvTCB->tcb_raq = CurrentTRH->trh_next;
            if (RcvTCB->tcb_raq == NULL) {
                //
                // We've just cleaned off the RAQ.  We can go back on the
                // fast path now.
                //
                if (--(RcvTCB->tcb_slowcount) == 0) {
                    RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                    CheckTCBRcv(RcvTCB);
                }

            }
            ExFreePool(CurrentTRH);
            return NewPacket;
        }
    }

#if DBG
    *Size = 0;
#endif
    return NULL;
}


//* CreateTRH - Create a TCP reassembly header.
//
//  This function tries to create a TCP reassembly header.  We take as input
//  a pointer to the previous TRH in the chain, the IPv6Packet to put on,
//  etc. and try to create and link in a TRH.  The caller must hold the lock
//  on the TCB when this is called.
//
uint  // Returns: TRUE if we created it, FALSE otherwise.
CreateTRH(
    TCPRAHdr *PrevTRH,    // TRH to insert after.
    IPv6Packet *Packet,   // IP Packet chain.
    TCPRcvInfo *RcvInfo,  // RcvInfo for this TRH.
    int Size)             // Size in bytes of data.
{
    TCPRAHdr *NewTRH;
    IPv6Packet *NewPacket;

    ASSERT((Size > 0) || (RcvInfo->tri_flags & TCP_FLAG_FIN));

    NewTRH = ExAllocatePoolWithTagPriority(NonPagedPool, sizeof(TCPRAHdr),
                                           TCP6_TAG, LowPoolPriority);
    if (NewTRH == NULL)
        return FALSE;

    NewPacket = ExAllocatePoolWithTagPriority(NonPagedPool,
                                              sizeof(IPv6Packet) + Size,
                                              TCP6_TAG, LowPoolPriority);
    if (NewPacket == NULL) {
        ExFreePool(NewTRH);
        return FALSE;
    }

#if DBG
    NewTRH->trh_sig = trh_signature;
#endif
    NewPacket->Next = NULL;
    NewPacket->Position = 0;
    NewPacket->FlatData = (uchar *)(NewPacket + 1);
    NewPacket->Data = NewPacket->FlatData;
    NewPacket->ContigSize = (uint)Size;
    NewPacket->TotalSize = (uint)Size;
    NewPacket->NdisPacket = NULL;
    NewPacket->AuxList = NULL;
    NewPacket->Flags = PACKET_OURS;
    if (Size != 0)
        CopyPacketToBuffer(NewPacket->Data, Packet, Size, Packet->Position);

    NewTRH->trh_start = RcvInfo->tri_seq;
    NewTRH->trh_flags = RcvInfo->tri_flags;
    NewTRH->trh_size = Size;
    NewTRH->trh_urg = RcvInfo->tri_urgent;
    NewTRH->trh_buffer = NewPacket;
    NewTRH->trh_end = NewPacket;

    NewTRH->trh_next = PrevTRH->trh_next;
    PrevTRH->trh_next = NewTRH;
    return TRUE;
}


//* PutOnRAQ - Put a segment on the reassembly queue.
//
//  Called during segment reception to put a segment on the reassembly
//  queue.  We try to use as few reassembly headers as possible, so if this
//  segment has some overlap with an existing entry in the queue we'll just
//  update the existing entry.  If there is no overlap we'll create a new
//  reassembly header.  Combining URGENT data with non-URGENT data is tricky.
//  If we get a segment that has urgent data that overlaps the front of a
//  reassembly header we'll always mark the whole chunk as urgent - the value
//  of the urgent pointer will mark the end of urgent data, so this is OK.
//  If it only overlaps at the end, however, we won't combine, since we would
//  have to mark previously non-urgent data as urgent.  We'll trim the
//  front of the incoming segment and create a new reassembly header.  Also,
//  if we have non-urgent data that overlaps at the front of a reassembly
//  header containing urgent data we can't combine these two, since again we
//  would mark non-urgent data as urgent.
//  Our search will stop if we find an entry with a FIN.
//  We assume that the TCB lock is held by the caller.
//
uint                      // Returns: TRUE if successful, FALSE otherwise.
PutOnRAQ(
    TCB *RcvTCB,          // TCB on which to reassemble.
    TCPRcvInfo *RcvInfo,  // RcvInfo for new segment.
    IPv6Packet *Packet,   // Packet chain for this segment.
    uint Size)            // Size in bytes of data in this segment.
{
    TCPRAHdr *PrevTRH;     // Previous reassembly header.
    TCPRAHdr *CurrentTRH;  // Current reassembly header.
    SeqNum NextSeq;        // Seq num of 1st byte after seg being reassembled.
    SeqNum NextTRHSeq;     // Sequence number of 1st byte after current TRH.
    uint Created;

    CHECK_STRUCT(RcvTCB, tcb);
    ASSERT(RcvTCB->tcb_rcvnext != RcvInfo->tri_seq);
    ASSERT(!(RcvInfo->tri_flags & TCP_FLAG_SYN));

    NextSeq = RcvInfo->tri_seq + Size +
        ((RcvInfo->tri_flags & TCP_FLAG_FIN) ? 1 : 0);

    PrevTRH = CONTAINING_RECORD(&RcvTCB->tcb_raq, TCPRAHdr, trh_next);
    CurrentTRH = PrevTRH->trh_next;

    //
    // Walk down the reassembly queue, looking for the correct place to
    // insert this, until we hit the end.
    //
    while (CurrentTRH != NULL) {
        CHECK_STRUCT(CurrentTRH, trh);

        ASSERT(!(CurrentTRH->trh_flags & TCP_FLAG_SYN));
        NextTRHSeq = CurrentTRH->trh_start + CurrentTRH->trh_size +
            ((CurrentTRH->trh_flags & TCP_FLAG_FIN) ? 1 : 0);

        //
        // First, see if it starts beyond the end of the current TRH.
        //
        if (SEQ_LTE(RcvInfo->tri_seq, NextTRHSeq)) {
            //
            // We know the incoming segment doesn't start beyond the end
            // of this TRH, so we'll either create a new TRH in front of
            // this one or we'll merge the new segment onto this TRH.
            // If the end of the current segment is in front of the start
            // of the current TRH, we'll need to create a new TRH.  Otherwise
            // we'll merge these two.
            //
            if (SEQ_LT(NextSeq, CurrentTRH->trh_start))
                break;
            else {
                //
                // There's some overlap.  If there's actually data in the
                // incoming segment we'll merge it.
                //
                if (Size != 0) {
                    int FrontOverlap, BackOverlap;
                    IPv6Packet *NewPacket;

                    //
                    // We need to merge.  If there's a FIN on the incoming
                    // segment that would fall inside this current TRH, we
                    // have a protocol violation from the remote peer.  In
                    // this case just return, discarding the incoming segment.
                    //
                    if ((RcvInfo->tri_flags & TCP_FLAG_FIN) &&
                        SEQ_LTE(NextSeq, NextTRHSeq))
                        return TRUE;

                    //
                    // We have some overlap.  Figure out how much.
                    //
                    FrontOverlap = CurrentTRH->trh_start - RcvInfo->tri_seq;
                    if (FrontOverlap > 0) {
                        //
                        // Have overlap in front.  Allocate an IPv6Packet to
                        // to hold it, and copy it, unless we would have to
                        // combine non-urgent with urgent.
                        //
                        if (!(RcvInfo->tri_flags & TCP_FLAG_URG) &&
                            (CurrentTRH->trh_flags & TCP_FLAG_URG)) {
                            if (CreateTRH(PrevTRH, Packet, RcvInfo,
                                CurrentTRH->trh_start - RcvInfo->tri_seq)) {
                                PrevTRH = PrevTRH->trh_next;
                                CurrentTRH = PrevTRH->trh_next;
                            }
                            FrontOverlap = 0;
                        } else {
                            NewPacket = ExAllocatePoolWithTagPriority(
                                            NonPagedPool,
                                            sizeof(IPv6Packet) + FrontOverlap,
                                            TCP6_TAG, LowPoolPriority);
                            if (NewPacket == NULL) {
                                // Couldn't allocate memory.
                                return TRUE;
                            }
                            NewPacket->Position = 0;
                            NewPacket->FlatData = (uchar *)(NewPacket + 1);
                            NewPacket->Data = NewPacket->FlatData;
                            NewPacket->ContigSize = FrontOverlap;
                            NewPacket->TotalSize = FrontOverlap;
                            NewPacket->NdisPacket = NULL;
                            NewPacket->AuxList = NULL;
                            NewPacket->Flags = PACKET_OURS;
                            CopyPacketToBuffer(NewPacket->Data, Packet,
                                               FrontOverlap, Packet->Position);
                            CurrentTRH->trh_size += FrontOverlap;

                            //
                            // Put our new packet on the front of this
                            // reassembly header's packet list.
                            //
                            NewPacket->Next = CurrentTRH->trh_buffer;
                            CurrentTRH->trh_buffer = NewPacket;
                            CurrentTRH->trh_start = RcvInfo->tri_seq;
                        }
                    }

                    //
                    // We've updated the starting sequence number of this TRH
                    // if we needed to.  Now look for back overlap.  There
                    // can't be any back overlap if the current TRH has a FIN.
                    // Also we'll need to check for urgent data if there is
                    // back overlap.
                    //
                    if (!(CurrentTRH->trh_flags & TCP_FLAG_FIN)) {
                        BackOverlap = RcvInfo->tri_seq + Size - NextTRHSeq;
                        if ((BackOverlap > 0) &&
                            (RcvInfo->tri_flags & TCP_FLAG_URG) &&
                            !(CurrentTRH->trh_flags & TCP_FLAG_URG) &&
                            (FrontOverlap <= 0)) {
                            int AmountToTrim;
                            //
                            // The incoming segment has urgent data and
                            // overlaps on the back but not the front, and the
                            // current TRH has no urgent data.  We can't
                            // combine into this TRH, so trim the front of the
                            // incoming segment to NextTRHSeq and move to the
                            // next TRH.
                            AmountToTrim = NextTRHSeq - RcvInfo->tri_seq;
                            ASSERT(AmountToTrim >= 0);
                            ASSERT(AmountToTrim < (int) Size);
                            Packet = TrimPacket(Packet, (uint)AmountToTrim);
                            RcvInfo->tri_seq += AmountToTrim;
                            RcvInfo->tri_urgent -= AmountToTrim;
                            PrevTRH = CurrentTRH;
                            CurrentTRH = PrevTRH->trh_next;
                            Size -= AmountToTrim;
                            continue;
                        }
                    } else
                        BackOverlap = 0;

                    //
                    // Now if we have back overlap, copy it.
                    //
                    if (BackOverlap > 0) {
                        //
                        // We have back overlap.  Get a buffer to copy it into.
                        // If we can't get one, we won't just return, because
                        // we may have updated the front and may need to
                        // update the urgent info.
                        //
                        NewPacket = ExAllocatePoolWithTagPriority(
                                        NonPagedPool,
                                        sizeof(IPv6Packet) + BackOverlap,
                                        TCP6_TAG, LowPoolPriority);
                        if (NewPacket != NULL) {
                            // Allocation succeeded.
                            NewPacket->Position = 0;
                            NewPacket->FlatData = (uchar *)(NewPacket + 1);
                            NewPacket->Data = NewPacket->FlatData;
                            NewPacket->ContigSize = BackOverlap;
                            NewPacket->TotalSize = BackOverlap;
                            NewPacket->NdisPacket = NULL;
                            NewPacket->AuxList = NULL;
                            NewPacket->Flags = PACKET_OURS;
                            CopyPacketToBuffer(NewPacket->Data, Packet,
                                               BackOverlap, Packet->Position +
                                               NextTRHSeq - RcvInfo->tri_seq);
                            CurrentTRH->trh_size += BackOverlap;
                            NewPacket->Next = CurrentTRH->trh_end->Next;
                            CurrentTRH->trh_end->Next = NewPacket;
                            CurrentTRH->trh_end = NewPacket;

                            //
                            // This segment could also have FIN set.
                            // If it does, set the TRH flag.
                            //
                            // N.B. If there's another reassembly header after
                            // the current one, the data that we're about to
                            // put on the current header might already be
                            // on that subsequent header which, in that event,
                            // will already have the FIN flag set.
                            // Check for that case before recording the FIN.
                            //
                            if ((RcvInfo->tri_flags & TCP_FLAG_FIN) &&
                                !CurrentTRH->trh_next) {
                                CurrentTRH->trh_flags |= TCP_FLAG_FIN;
                            }
                        }
                    }

                    //
                    // Everything should be consistent now.  If there's an
                    // urgent data pointer in the incoming segment, update the
                    // one in the TRH now.
                    //
                    if (RcvInfo->tri_flags & TCP_FLAG_URG) {
                        SeqNum UrgSeq;
                        //
                        // Have an urgent pointer.  If the current TRH already
                        // has an urgent pointer, see which is bigger.
                        // Otherwise just use this one.
                        //
                        UrgSeq = RcvInfo->tri_seq + RcvInfo->tri_urgent;
                        if (CurrentTRH->trh_flags & TCP_FLAG_URG) {
                            SeqNum TRHUrgSeq;

                            TRHUrgSeq = CurrentTRH->trh_start +
                                CurrentTRH->trh_urg;
                            if (SEQ_LT(UrgSeq, TRHUrgSeq))
                                UrgSeq = TRHUrgSeq;
                        } else
                            CurrentTRH->trh_flags |= TCP_FLAG_URG;

                        CurrentTRH->trh_urg = UrgSeq - CurrentTRH->trh_start;
                    }

                } else {
                    //
                    // We have a 0 length segment.  The only interesting thing
                    // here is if there's a FIN on the segment.  If there is,
                    // and the seq. # of the incoming segment is exactly after
                    // the current TRH, OR matches the FIN in the current TRH,
                    // we note it.
                    if (RcvInfo->tri_flags & TCP_FLAG_FIN) {
                        if (!(CurrentTRH->trh_flags & TCP_FLAG_FIN)) {
                            if (SEQ_EQ(NextTRHSeq, RcvInfo->tri_seq))
                                CurrentTRH->trh_flags |= TCP_FLAG_FIN;
                            else
                                KdBreakPoint();
                        }
                        else {
                            if (!(SEQ_EQ((NextTRHSeq-1), RcvInfo->tri_seq))) {
                                KdBreakPoint();
                            }
                        }
                    }
                }
                return TRUE;
            }
        } else {
            //
            // Look at the next TRH, unless the current TRH has a FIN.  If he
            // has a FIN, we won't save any data beyond that anyway.
            //
            if (CurrentTRH->trh_flags & TCP_FLAG_FIN)
                return TRUE;

            PrevTRH = CurrentTRH;
            CurrentTRH = PrevTRH->trh_next;
        }
    }

    //
    // When we get here, we need to create a new TRH.  If we create one and
    // there was previously nothing on the reassembly queue, we'll have to
    // move off the fast receive path.
    //
    CurrentTRH = RcvTCB->tcb_raq;
    Created = CreateTRH(PrevTRH, Packet, RcvInfo, (int)Size);

    if (Created && CurrentTRH == NULL) {
        RcvTCB->tcb_slowcount++;
        RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
        CheckTCBRcv(RcvTCB);
    } else if (!Created) {
        return FALSE;
    }
    return TRUE;
}


//* HandleFastXmit - Handles fast retransmit algorithm.  See RFC 2581.
//
//  Called by TCPReceive to determine if we should retransmit a segment
//  without waiting for retransmit timeout to fire.
//
BOOLEAN  // Returns: TRUE if the segment got retransmitted, FALSE otherwise.
HandleFastXmit(
    TCB *RcvTCB,          // Connection context for this receive.
    TCPRcvInfo *RcvInfo)  // Pointer to rcvd TCP Header information.
{
    uint CWin;

    RcvTCB->tcb_dupacks++;

    if (RcvTCB->tcb_dupacks == MaxDupAcks) {
        //
        // We're going to do a fast retransmit.
        // Stop the retransmit timer and any round-trip time
        // calculations we might have been running.
        //
        STOP_TCB_TIMER(RcvTCB->tcb_rexmittimer);
        RcvTCB->tcb_rtt = 0;

        if (!(RcvTCB->tcb_flags & FLOW_CNTLD)) {
            //
            // Don't let the slow start threshold go
            // below 2 segments.
            //
            RcvTCB->tcb_ssthresh =
                MAX(MIN(RcvTCB->tcb_cwin, RcvTCB->tcb_sendwin) / 2,
                    (uint) RcvTCB->tcb_mss * 2);
        }

        //
        // Inflate the congestion window by the number of segments
        // which have presumably left the network.
        //
        CWin = RcvTCB->tcb_ssthresh + (MaxDupAcks * RcvTCB->tcb_mss);

        //
        // Recall the segment in question and send it out.
        // Note that tcb_lock will be dereferenced by the caller.
        //
        ResetAndFastSend(RcvTCB, RcvTCB->tcb_senduna, CWin);

        return TRUE;

    } else {

        int SendWin;
        uint AmtOutstanding;

        //
        // REVIEW: At least the first part of this check is redundant.
        //
        if (SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo->tri_ack) &&
            (SEQ_LT(RcvTCB->tcb_sendwl1, RcvInfo->tri_seq) ||
             (SEQ_EQ(RcvTCB->tcb_sendwl1, RcvInfo->tri_seq) &&
              SEQ_LTE(RcvTCB->tcb_sendwl2, RcvInfo->tri_ack)))) {

            RcvTCB->tcb_sendwin = RcvInfo->tri_window;
            RcvTCB->tcb_maxwin = MAX(RcvTCB->tcb_maxwin, RcvInfo->tri_window);
            RcvTCB->tcb_sendwl1 = RcvInfo->tri_seq;
            RcvTCB->tcb_sendwl2 = RcvInfo->tri_ack;
        }

        if (RcvTCB->tcb_dupacks > MaxDupAcks) {
            //
            // Update the congestion window to reflect the fact that the
            // duplicate ack presumably indicates that the previous frame
            // was received by our peer and has thus left the network.
            //
            RcvTCB->tcb_cwin += RcvTCB->tcb_mss;
        }

        //
        // Check if we need to set tcb_force.
        //
        if ((RcvTCB->tcb_cwin + RcvTCB->tcb_mss) < RcvTCB->tcb_sendwin) {
             AmtOutstanding = (uint)(RcvTCB->tcb_sendnext -
                                     RcvTCB->tcb_senduna);

             SendWin = (int)(MIN(RcvTCB->tcb_sendwin, RcvTCB->tcb_cwin) -
                             AmtOutstanding);

             if (SendWin < RcvTCB->tcb_mss) {
                 RcvTCB->tcb_force = 1;
             }
        }
    }

    return FALSE;
}


//* TCPReceive - Receive an incoming TCP segment.
//
//  This is the routine called by IPv6 when we need to receive a TCP segment.
//  In general, we follow the RFC 793 event processing section pretty closely,
//  but there is a 'fast path' where we make some quick checks on the incoming
//  segment, and if it matches we deliver it immediately.
//
uchar  // Returns: next header value (always IP_PROTOCOL_NONE for TCP).
TCPReceive(
    IPv6Packet *Packet)        // Packet IP handed up to us.
{
    NetTableEntry *NTE;
    TCPHeader UNALIGNED *TCP;  // The TCP header.
    uint DataOffset;           // Offset from start of TCP header to data.
    ushort Checksum;
    TCPRcvInfo RcvInfo;        // Local swapped copy of receive info.
    uint SrcScopeId;           // Scope id of remote address, if applicable.
    uint DestScopeId;          // Scope id of local address, if applicable.
    TCB *RcvTCB;               // TCB on which to receive the packet.
    uint Inserted;
    uint Actions;              // Flags for future actions to be performed.
    uint BytesTaken;
    uint NewSize;
    BOOLEAN UseIsn = FALSE;
    SeqNum Isn = 0;
    uint UpdateWindow;

    //
    // REVIEW: Expediency hacks to get something working.
    //
    uint Size;  // Probably safe to just change name to PayloadLength below.

    //
    // TCP only works with unicast addresses.  If this packet was
    // received on a unicast address, then Packet->NTEorIF will be an
    // NTE.  So drop packets if we don't have an NTE.
    // (IPv6HeaderReceive checks validity.) But the converse isn't
    // true, we could have an NTE here that is associated with the
    // anycast/multicast address we received the packet on.  So to
    // guard against that, we verify that our NTE's address is the
    // destination given in the packet.
    //
    if (!IsNTE(Packet->NTEorIF) ||
        !IP6_ADDR_EQUAL(AlignAddr(&Packet->IP->Dest),
                        &(NTE = CastToNTE(Packet->NTEorIF))->Address)) {
        // Packet's destination was not a valid unicast address of ours.
        return IP_PROTOCOL_NONE; // Drop packet.
    }

    TStats.ts_insegs++;

    //
    // Verify that we have enough contiguous data to overlay a TCPHeader
    // structure on the incoming packet.  Then do so.
    //
    if (! PacketPullup(Packet, sizeof(TCPHeader), 1, 0)) {
        // Pullup failed.
        TStats.ts_inerrs++;
        if (Packet->TotalSize < sizeof(TCPHeader)) {
        BadPayloadLength:
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "TCPv6: data buffer too small to contain TCP header\n"));
            ICMPv6SendError(Packet,
                            ICMPv6_PARAMETER_PROBLEM,
                            ICMPv6_ERRONEOUS_HEADER_FIELD,
                            FIELD_OFFSET(IPv6Header, PayloadLength),
                            IP_PROTOCOL_NONE, FALSE);
        }
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    TCP = (TCPHeader UNALIGNED *)Packet->Data;

    //
    // Verify checksum.
    //
    Checksum = ChecksumPacket(Packet->NdisPacket, Packet->Position,
                              Packet->FlatData, Packet->TotalSize,
                              Packet->SrcAddr, AlignAddr(&Packet->IP->Dest),
                              IP_PROTOCOL_TCP);
    if (Checksum != 0xffff) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "TCPv6: Checksum failed %0x\n", Checksum));
        TStats.ts_inerrs++;
        return IP_PROTOCOL_NONE;  // Drop packet.
    }

    //
    // Now that we can read the header, pull out the header length field.
    // Verify that we have enough contiguous data to hold any TCP options
    // that may be present in the header, and skip over the entire header.
    //
    DataOffset = TCP_HDR_SIZE(TCP);
    if (! PacketPullup(Packet, DataOffset, 1, 0)) {
        TStats.ts_inerrs++;
        if (Packet->TotalSize < DataOffset)
            goto BadPayloadLength;
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    TCP = (TCPHeader UNALIGNED *)Packet->Data;

    AdjustPacketParams(Packet, DataOffset);
    Size = Packet->TotalSize;

    //
    // Verify IPSec was performed.
    //
    if (InboundSecurityCheck(Packet, IP_PROTOCOL_TCP, net_short(TCP->tcp_src),
                             net_short(TCP->tcp_dest), NTE->IF) != TRUE) {
        //
        // No policy was found or the policy indicated to drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "TCPReceive: IPSec Policy caused packet to be dropped\n"));
        return IP_PROTOCOL_NONE;  // Drop packet.
    }

    //
    // The packet is valid.
    // Get the info we need and byte swap it.
    //
    RcvInfo.tri_seq = net_long(TCP->tcp_seq);
    RcvInfo.tri_ack = net_long(TCP->tcp_ack);
    RcvInfo.tri_window = (uint)net_short(TCP->tcp_window);
    RcvInfo.tri_urgent = (uint)net_short(TCP->tcp_urgent);
    RcvInfo.tri_flags = (uint)TCP->tcp_flags;

    //
    // Determine the appropriate scope id for our packet's addresses.
    // Note that multicast addresses were forbidden above.
    // We use DetermineScopeId instead of just indexing into ZoneIndices
    // because we need the "user-level" scope id here.
    //
    SrcScopeId = DetermineScopeId(Packet->SrcAddr, NTE->IF);
    DestScopeId = DetermineScopeId(&NTE->Address, NTE->IF);

    //
    // See if we have a TCP Control Block for this connection.
    //
    KeAcquireSpinLockAtDpcLevel(&TCBTableLock);
    RcvTCB = FindTCB(AlignAddr(&Packet->IP->Dest), Packet->SrcAddr,
                     DestScopeId, SrcScopeId, TCP->tcp_dest, TCP->tcp_src);

    if (RcvTCB == NULL) {

        //
        // Didn't find a matching TCB, which means incoming segment doesn't
        // belong to an existing connection.
        //
        KeReleaseSpinLockFromDpcLevel(&TCBTableLock);

        //
        // Make sure that the source address is reasonable
        // before proceeding.
        //
        ASSERT(!IsInvalidSourceAddress(Packet->SrcAddr));
        if (IsUnspecified(Packet->SrcAddr)) {
            return IP_PROTOCOL_NONE;
        }

        //
        // If this segment carries a SYN (and only a SYN), it's a
        // connection initiation request.
        //
        if ((RcvInfo.tri_flags & (TCP_FLAG_SYN | TCP_FLAG_ACK |
                                  TCP_FLAG_RST)) == TCP_FLAG_SYN) {
            AddrObj *AO;

ValidNewConnectionRequest:
            //
            // If the firewall is enabled on the arrival interface,
            // drop the SYN without sending a RST.
            //
            // TODO: This is a very simplistic heuristic that
            // should eventually be replaced with a port map to filter 
            // against.
            //
            if (NTE->IF->Flags & IF_FLAG_FIREWALL_ENABLED) {
                return IP_PROTOCOL_NONE;
            }

            //
            // We need to look for a matching address object.
            // Want match for local address (+ scope id for scoped addresses),
            // port and protocol.
            //
            KeAcquireSpinLockAtDpcLevel(&AddrObjTableLock);
            AO = GetBestAddrObj(AlignAddr(&Packet->IP->Dest), Packet->SrcAddr,
                                DestScopeId, TCP->tcp_dest,
                                IP_PROTOCOL_TCP, NTE->IF);
            if (AO == NULL) {
                //
                // No address object.  Free the lock, and send a RST.
                //
                KeReleaseSpinLockFromDpcLevel(&AddrObjTableLock);
                goto SendReset;
            }

            //
            // Found an AO.  See if it has a listen indication.
            // FindListenConn will free the lock on the AddrObjTable.
            //
            RcvTCB = FindListenConn(AO, Packet->SrcAddr, SrcScopeId,
                                    TCP->tcp_src);
            if (RcvTCB == NULL) {
                //
                // No listening connection.  AddrObjTableLock was
                // released by FindListenConn.  Just send a RST.
                //
                goto SendReset;
            }

            CHECK_STRUCT(RcvTCB, tcb);
            KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
            //
            // We found a listening connection. Initialize
            // it now, and if it is actually to be accepted
            // we'll send a SYN-ACK also.
            //
            ASSERT(RcvTCB->tcb_state == TCB_SYN_RCVD);

            RcvTCB->tcb_daddr = *Packet->SrcAddr;
            RcvTCB->tcb_saddr = Packet->IP->Dest;
            RcvTCB->tcb_dscope_id = SrcScopeId;
            RcvTCB->tcb_sscope_id = DestScopeId;
            RcvTCB->tcb_dport = TCP->tcp_src;
            RcvTCB->tcb_sport = TCP->tcp_dest;
            RcvTCB->tcb_rcvnext = ++RcvInfo.tri_seq;
            RcvTCB->tcb_rcvwinwatch = RcvTCB->tcb_rcvnext;
            if (UseIsn) {
                RcvTCB->tcb_sendnext = Isn;
            }  else {
                GetRandomISN(&RcvTCB->tcb_sendnext,
                             (uchar*)&RcvTCB->tcb_md5data);
            }
            RcvTCB->tcb_sendwin = RcvInfo.tri_window;
            RcvTCB->tcb_remmss = FindMSS(TCP);
            TStats.ts_passiveopens++;
            RcvTCB->tcb_fastchk |= TCP_FLAG_IN_RCV;
            KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);

            Inserted = InsertTCB(RcvTCB);

            //
            // Get the lock on it, and see if it's been accepted.
            //
            KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
            if (!Inserted) {
                // Couldn't insert it!.
                CompleteConnReq(RcvTCB, TDI_CONNECTION_ABORTED);
                TryToCloseTCB(RcvTCB, TCB_CLOSE_ABORTED, DISPATCH_LEVEL);
                KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
                DerefTCB(RcvTCB, DISPATCH_LEVEL);
                return IP_PROTOCOL_NONE;
            }

            RcvTCB->tcb_fastchk &= ~TCP_FLAG_IN_RCV;
            if (RcvTCB->tcb_flags & SEND_AFTER_RCV) {
                RcvTCB->tcb_flags &= ~SEND_AFTER_RCV;
                DelayAction(RcvTCB, NEED_OUTPUT);
            }

            if (RcvTCB->tcb_flags & CONN_ACCEPTED) {
                //
                // The connection was accepted.  Finish the
                // initialization, and send the SYN ack.
                //
                AcceptConn(RcvTCB, DISPATCH_LEVEL);
                return IP_PROTOCOL_NONE;
            } else {
                //
                // We don't know what to do about the
                // connection yet.  Return the pending listen,
                // dereference the connection, and return.
                //
                CompleteConnReq(RcvTCB, TDI_SUCCESS);
                DerefTCB(RcvTCB, DISPATCH_LEVEL);
                return IP_PROTOCOL_NONE;
            }
        }

      SendReset:
        //
        // Not a SYN, no AddrObj available, or port filtered.
        // Send a RST back to the sender.
        //
        SendRSTFromHeader(TCP, Packet->TotalSize, Packet->SrcAddr, SrcScopeId,
                          AlignAddr(&Packet->IP->Dest), DestScopeId);
        return IP_PROTOCOL_NONE;
    }

    //
    // We found a matching TCB.  Get the lock on it, and continue.
    //
    KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
    KeReleaseSpinLockFromDpcLevel(&TCBTableLock);

    //
    // Do the fast path check.  We can hit the fast path if the incoming
    // sequence number matches our receive next and the masked flags
    // match our 'predicted' flags.
    //
    CheckTCBRcv(RcvTCB);
    RcvTCB->tcb_alive = TCPTime;

    if (RcvTCB->tcb_rcvnext == RcvInfo.tri_seq &&
        (RcvInfo.tri_flags & TCP_FLAGS_ALL) == RcvTCB->tcb_fastchk) {

        Actions = 0;
        RcvTCB->tcb_refcnt++;

        //
        // The fast path.  We know all we have to do here is ack sends and
        // deliver data.  First try and ack data.
        //
        if (SEQ_LT(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
            SEQ_LTE(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
            uint CWin;
            uint MSS;

            //
            // The ack acknowledges something. Pull the
            // appropriate amount off the send q.
            //
            ACKData(RcvTCB, RcvInfo.tri_ack);

            //
            // If this acknowledges something we were running a RTT on,
            // update that stuff now.
            //
            if (RcvTCB->tcb_rtt != 0 && SEQ_GT(RcvInfo.tri_ack,
                                               RcvTCB->tcb_rttseq)) {
                short RTT;

                RTT = (short)(TCPTime - RcvTCB->tcb_rtt);
                RcvTCB->tcb_rtt = 0;
                RTT -= (RcvTCB->tcb_smrtt >> 3);
                RcvTCB->tcb_smrtt += RTT;
                RTT = (RTT >= 0 ? RTT : -RTT);
                RTT -= (RcvTCB->tcb_delta >> 3);
                RcvTCB->tcb_delta += RTT + RTT;
                RcvTCB->tcb_rexmit = MIN(MAX(REXMIT_TO(RcvTCB),
                                             MIN_RETRAN_TICKS),
                                         MAX_REXMIT_TO);
            }

            if ((RcvTCB->tcb_dupacks >= MaxDupAcks) &&
                ((int)RcvTCB->tcb_ssthresh > 0)) {
                //
                // We were in fast retransmit mode, so this ACK is for
                // our fast retransmitted frame.  Set cwin to ssthresh
                // so that cwin grows linearly from here.
                //
                RcvTCB->tcb_cwin = RcvTCB->tcb_ssthresh;

            } else {

                //
                // Update the congestion window now.
                //
                CWin = RcvTCB->tcb_cwin;
                MSS = RcvTCB->tcb_mss;
                if (CWin < RcvTCB->tcb_maxwin) {
                    if (CWin < RcvTCB->tcb_ssthresh)
                        CWin += MSS;
                    else
                        CWin += (MSS * MSS)/CWin;
                    
                    RcvTCB->tcb_cwin = CWin;
                }
            }
            ASSERT(*(int *)&RcvTCB->tcb_cwin > 0);

            //
            // Since this isn't a duplicate ACK, reset the counter.
            //
            RcvTCB->tcb_dupacks = 0;

            //
            // We've acknowledged something, so reset the rexmit count.
            // If there's still stuff outstanding, restart the rexmit
            // timer.
            //
            RcvTCB->tcb_rexmitcnt = 0;
            if (SEQ_EQ(RcvInfo.tri_ack, RcvTCB->tcb_sendmax))
                STOP_TCB_TIMER(RcvTCB->tcb_rexmittimer);
            else
                START_TCB_TIMER(RcvTCB->tcb_rexmittimer, RcvTCB->tcb_rexmit);

            //
            // Since we've acknowledged data, we need to update the window.
            //
            RcvTCB->tcb_sendwin = RcvInfo.tri_window;
            RcvTCB->tcb_maxwin = MAX(RcvTCB->tcb_maxwin, RcvInfo.tri_window);
            RcvTCB->tcb_sendwl1 = RcvInfo.tri_seq;
            RcvTCB->tcb_sendwl2 = RcvInfo.tri_ack;

            //
            // We've updated the window, remember to send some more.
            //
            Actions = (RcvTCB->tcb_unacked ? NEED_OUTPUT : 0);

        } else {
            //
            // It doesn't ack anything.  If it's an ack for something
            // larger than we've sent then ACKAndDrop it.
            //
            if (SEQ_GT(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
                ACKAndDrop(&RcvInfo, RcvTCB);
                return IP_PROTOCOL_NONE;
            }

            //
            // If it is a pure duplicate ack, check if we should
            // do a fast retransmit.
            //
            if ((Size == 0) && SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                SEQ_LT(RcvTCB->tcb_senduna, RcvTCB->tcb_sendmax) &&
                (RcvTCB->tcb_sendwin == RcvInfo.tri_window) &&
                RcvInfo.tri_window) {

                //
                // See if fast rexmit can be done.
                //
                if (HandleFastXmit(RcvTCB, &RcvInfo)) {
                    return IP_PROTOCOL_NONE;
                }

                Actions = (RcvTCB->tcb_unacked ? NEED_OUTPUT : 0);

            } else {

                //
                // Not a pure duplicate ack (Size != 0 or peer is
                // advertising a new windows).  Reset counter.
                //
                RcvTCB->tcb_dupacks = 0;

                //
                // If the ack matches our existing UNA, we need to see if
                // we can update the window.
                //
                if (SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                    (SEQ_LT(RcvTCB->tcb_sendwl1, RcvInfo.tri_seq) ||
                     (SEQ_EQ(RcvTCB->tcb_sendwl1, RcvInfo.tri_seq) &&
                      SEQ_LTE(RcvTCB->tcb_sendwl2, RcvInfo.tri_ack)))) {
                    RcvTCB->tcb_sendwin = RcvInfo.tri_window;
                    RcvTCB->tcb_maxwin = MAX(RcvTCB->tcb_maxwin,
                                             RcvInfo.tri_window);
                    RcvTCB->tcb_sendwl1 = RcvInfo.tri_seq;
                    RcvTCB->tcb_sendwl2 = RcvInfo.tri_ack;
                    //
                    // Since we've updated the window, remember to send
                    // some more.
                    //
                    Actions = (RcvTCB->tcb_unacked ? NEED_OUTPUT : 0);
                }
            }
        }

        //
        // Check to see if this packet contains any useable data.
        //
        NewSize = MIN((int) Size, RcvTCB->tcb_rcvwin);
        if (NewSize != 0) {
            RcvTCB->tcb_fastchk |= TCP_FLAG_IN_RCV;
            BytesTaken = (*RcvTCB->tcb_rcvhndlr)(RcvTCB, RcvInfo.tri_flags,
                                                 Packet, NewSize);
            RcvTCB->tcb_rcvnext += BytesTaken;
            RcvTCB->tcb_rcvwin -= BytesTaken;
            CheckTCBRcv(RcvTCB);

            RcvTCB->tcb_fastchk &= ~TCP_FLAG_IN_RCV;

            //
            // If our peer is sending into an expanded window, then our
            // peer must have received our ACK advertising said window.
            // Take this as proof of forward reachability.
            //
            if (SEQ_GTE(RcvInfo.tri_seq + (int)NewSize,
                        RcvTCB->tcb_rcvwinwatch)) {
                RcvTCB->tcb_rcvwinwatch = RcvTCB->tcb_rcvnext +
                    RcvTCB->tcb_rcvwin;
                if (RcvTCB->tcb_rce != NULL)
                    ConfirmForwardReachability(RcvTCB->tcb_rce);
            }

            Actions |= (RcvTCB->tcb_flags & SEND_AFTER_RCV ? NEED_OUTPUT : 0);

            RcvTCB->tcb_flags &= ~SEND_AFTER_RCV;
            if ((RcvTCB->tcb_flags & ACK_DELAYED) ||
                (BytesTaken != NewSize)) {
                Actions |= NEED_ACK;
            } else {
                RcvTCB->tcb_flags |= ACK_DELAYED;
                START_TCB_TIMER(RcvTCB->tcb_delacktimer, DEL_ACK_TICKS);
            }
        } else {
            //
            // The new size is 0.  If the original size was not 0, we must
            // have a 0 receive win and hence need to send an ACK to this
            // probe.
            //
            Actions |= (Size ? NEED_ACK : 0);
        }

        if (Actions)
            DelayAction(RcvTCB, Actions);

        DerefTCB(RcvTCB, DISPATCH_LEVEL);

        return IP_PROTOCOL_NONE;
    }

    //
    // This is the non-fast path.
    //

    //
    // If we found a matching TCB in TIME_WAIT, and the received segment
    // carries a SYN (and only a SYN), and the received segment has a sequence
    // greater than the last received, kill the TIME_WAIT TCB and use its
    // next sequence number to generate the initial sequence number of a
    // new incarnation.
    //
    if ((RcvTCB->tcb_state == TCB_TIME_WAIT) &&
        ((RcvInfo.tri_flags & (TCP_FLAG_SYN | TCP_FLAG_ACK | TCP_FLAG_RST))
            == TCP_FLAG_SYN) &&
        SEQ_GT(RcvInfo.tri_seq, RcvTCB->tcb_rcvnext)) {

        Isn = RcvTCB->tcb_sendnext + 128000;
        UseIsn = TRUE;
        STOP_TCB_TIMER(RcvTCB->tcb_rexmittimer);
        TryToCloseTCB(RcvTCB, TCB_CLOSE_SUCCESS, DISPATCH_LEVEL);
        RcvTCB = NULL;
        goto ValidNewConnectionRequest;
    }

    //
    // Make sure we can handle this frame.  We can't handle it if we're
    // in SYN_RCVD and the accept is still pending, or we're in a
    // non-established state and already in the receive handler.
    //
    if ((RcvTCB->tcb_state == TCB_SYN_RCVD &&
         !(RcvTCB->tcb_flags & CONN_ACCEPTED) &&
         !(RcvTCB->tcb_flags & ACTIVE_OPEN)) ||
        (RcvTCB->tcb_state != TCB_ESTAB && (RcvTCB->tcb_fastchk &
                                            TCP_FLAG_IN_RCV))) {
        KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
        return IP_PROTOCOL_NONE;
    }

    //
    // If it's closed, it's a temporary zombie TCB.  Reset the sender.
    //
    if (RcvTCB->tcb_state == TCB_CLOSED || CLOSING(RcvTCB) ||
        ((RcvTCB->tcb_flags & (GC_PENDING | TW_PENDING)) == GC_PENDING)) {
        KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
        SendRSTFromHeader(TCP, Packet->TotalSize, Packet->SrcAddr, SrcScopeId,
                          AlignAddr(&Packet->IP->Dest), DestScopeId);
        return IP_PROTOCOL_NONE;
    }

    //
    // At this point, we have a connection, and it's locked.  Following
    // the 'Segment Arrives' section of 793, the next thing to check is
    // if this connection is in SynSent state.
    //
    if (RcvTCB->tcb_state == TCB_SYN_SENT) {

        ASSERT(RcvTCB->tcb_flags & ACTIVE_OPEN);

        //
        // Check the ACK bit.  Since we don't send data with our SYNs, the
        // check we make is for the ack to exactly match our SND.NXT.
        //
        if (RcvInfo.tri_flags & TCP_FLAG_ACK) {
            // ACK is set.
            if (!SEQ_EQ(RcvInfo.tri_ack, RcvTCB->tcb_sendnext)) {
                // Bad ACK value.
                KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
                // Send a RST back at him.
                SendRSTFromHeader(TCP, Packet->TotalSize,
                                  Packet->SrcAddr, SrcScopeId,
                                  AlignAddr(&Packet->IP->Dest), DestScopeId);
                return IP_PROTOCOL_NONE;
            }
        }

        if (RcvInfo.tri_flags & TCP_FLAG_RST) {
            //
            // This might be an acceptable RST.  We'll persist here, sending
            // another SYN in PERSIST_TIMEOUT ms, until we fail from too
            // many retries.
            //
            if (!(RcvInfo.tri_flags & TCP_FLAG_ACK)) {
                //
                // The RST isn't acceptable, so ignore it.
                //
                KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
            } else if (RcvTCB->tcb_rexmitcnt == MaxConnectRexmitCount) {
                //
                // We've had a positive refusal, and one more rexmit
                // would time us out, so close the connection now.
                //
                CompleteConnReq(RcvTCB, TDI_CONN_REFUSED);

                TryToCloseTCB(RcvTCB, TCB_CLOSE_REFUSED, DISPATCH_LEVEL);
            } else {
                START_TCB_TIMER(RcvTCB->tcb_rexmittimer, PERSIST_TIMEOUT);
                KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
            }
            return IP_PROTOCOL_NONE;
        }

        //
        // See if we have a SYN.  If we do, we're going to change state
        // somehow (either to ESTABLISHED or SYN_RCVD).
        //
        if (RcvInfo.tri_flags & TCP_FLAG_SYN) {
            RcvTCB->tcb_refcnt++;
            //
            // We have a SYN.  Go ahead and record the sequence number and
            // window info.
            //
            RcvTCB->tcb_rcvnext = ++RcvInfo.tri_seq;
            RcvTCB->tcb_rcvwinwatch = RcvTCB->tcb_rcvnext;

            if (RcvInfo.tri_flags & TCP_FLAG_URG) {
                // Urgent data. Update the pointer.
                if (RcvInfo.tri_urgent != 0)
                    RcvInfo.tri_urgent--;
                else
                    RcvInfo.tri_flags &= ~TCP_FLAG_URG;
            }

            RcvTCB->tcb_remmss = FindMSS(TCP);
            RcvTCB->tcb_mss = MIN(RcvTCB->tcb_mss, RcvTCB->tcb_remmss);
            ASSERT(RcvTCB->tcb_mss > 0);

            RcvTCB->tcb_rexmitcnt = 0;
            STOP_TCB_TIMER(RcvTCB->tcb_rexmittimer);

            AdjustRcvWin(RcvTCB);

            if (RcvInfo.tri_flags & TCP_FLAG_ACK) {
                //
                // Our SYN has been acked.  Update SND.UNA and stop the
                // retrans timer.
                //
                RcvTCB->tcb_senduna = RcvInfo.tri_ack;
                RcvTCB->tcb_sendwin = RcvInfo.tri_window;
                RcvTCB->tcb_maxwin = RcvInfo.tri_window;
                RcvTCB->tcb_sendwl1 = RcvInfo.tri_seq;
                RcvTCB->tcb_sendwl2 = RcvInfo.tri_ack;
                GoToEstab(RcvTCB);

                //
                // We know our peer received our SYN.
                //
                if (RcvTCB->tcb_rce != NULL)
                    ConfirmForwardReachability(RcvTCB->tcb_rce);

                //
                // Remove whatever command exists on this connection.
                //
                CompleteConnReq(RcvTCB, TDI_SUCCESS);

                //
                // If data has been queued already, send the first data
                // segment with the ACK. Otherwise, send a pure ACK.
                //
                if (RcvTCB->tcb_unacked) {
                    RcvTCB->tcb_refcnt++;
                    TCPSend(RcvTCB, DISPATCH_LEVEL);
                } else {
                    KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
                    SendACK(RcvTCB);
                }

                //
                // Now handle other data and controls.  To do this we need
                // to reaquire the lock, and make sure we haven't started
                // closing it.
                //
                KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
                if (!CLOSING(RcvTCB)) {
                    //
                    // We haven't started closing it.  Turn off the
                    // SYN flag and continue processing.
                    //
                    RcvInfo.tri_flags &= ~TCP_FLAG_SYN;
                    if ((RcvInfo.tri_flags & TCP_FLAGS_ALL) !=
                        TCP_FLAG_ACK || Size != 0)
                        goto NotSYNSent;
                }
                DerefTCB(RcvTCB, DISPATCH_LEVEL);
                return IP_PROTOCOL_NONE;
            } else {
                //
                // A SYN, but not an ACK.  Go to SYN_RCVD.
                //
                RcvTCB->tcb_state = TCB_SYN_RCVD;
                RcvTCB->tcb_sendnext = RcvTCB->tcb_senduna;
                SendSYN(RcvTCB, DISPATCH_LEVEL);

                KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
                DerefTCB(RcvTCB, DISPATCH_LEVEL);
                return IP_PROTOCOL_NONE;
            }

        } else {
            //
            // No SYN, just toss the frame.
            //
            KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
            return IP_PROTOCOL_NONE;
        }
    }

    RcvTCB->tcb_refcnt++;

NotSYNSent:
    //
    // Not in the SYN-SENT state.  Check the sequence number.  If my window
    // is 0, I'll truncate all incoming frames but look at some of the
    // control fields.  Otherwise I'll try and make this segment fit into
    // the window.
    //
    if (RcvTCB->tcb_rcvwin != 0) {
        int StateSize;        // Size, including state info.
        SeqNum LastValidSeq;  // Sequence number of last valid byte at RWE.

        //
        // We are offering a window.  If this segment starts in front of my
        // receive window, clip off the front part.
        //
        if (SEQ_LT(RcvInfo.tri_seq, RcvTCB->tcb_rcvnext)) {
            int AmountToClip, FinByte;

            if (RcvInfo.tri_flags & TCP_FLAG_SYN) {
                //
                // Had a SYN.  Clip it off and update the sequence number.
                //
                RcvInfo.tri_flags &= ~TCP_FLAG_SYN;
                RcvInfo.tri_seq++;
                RcvInfo.tri_urgent--;
            }

            //
            // Advance the receive buffer to point at the new data.
            //
            AmountToClip = RcvTCB->tcb_rcvnext - RcvInfo.tri_seq;
            ASSERT(AmountToClip >= 0);

            //
            // If there's a FIN on this segment, account for it.
            //
            FinByte = ((RcvInfo.tri_flags & TCP_FLAG_FIN) ? 1: 0);

            if (AmountToClip >= (((int) Size) + FinByte)) {
                //
                // Falls entirely before the window.  We have more special
                // case code here - if the ack number acks something,
                // we'll go ahead and take it, faking the sequence number
                // to be rcvnext.  This prevents problems on full duplex
                // connections, where data has been received but not acked,
                // and retransmission timers reset the seq number to
                // below our rcvnext.
                //
                if ((RcvInfo.tri_flags & TCP_FLAG_ACK) &&
                    SEQ_LT(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                    SEQ_LTE(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
                    //
                    // This contains valid ACK info.  Fudge the information
                    // to get through the rest of this.
                    //
                    Size = 0;
                    AmountToClip = 0;
                    RcvInfo.tri_seq = RcvTCB->tcb_rcvnext;
                    RcvInfo.tri_flags &= ~(TCP_FLAG_SYN | TCP_FLAG_FIN |
                                           TCP_FLAG_RST | TCP_FLAG_URG);
#if DBG
                    FinByte = 1;  // Fake out assert below.
#endif
                } else {
                    ACKAndDrop(&RcvInfo, RcvTCB);
                    return IP_PROTOCOL_NONE;
                }
            }

            //
            // Trim what we have to.  If we can't trim enough, the frame
            // is too short.  This shouldn't happen, but it it does we'll
            // drop the frame.
            //
            Size -= AmountToClip;
            RcvInfo.tri_seq += AmountToClip;
            RcvInfo.tri_urgent -= AmountToClip;
            Packet = TrimPacket(Packet, AmountToClip);

            if (*(int *)&RcvInfo.tri_urgent < 0) {
                RcvInfo.tri_urgent = 0;
                RcvInfo.tri_flags &= ~TCP_FLAG_URG;
            }
        }

        //
        // We've made sure the front is OK.  Now make sure part of it
        // doesn't fall after the window.  If it does, we'll truncate the
        // frame (removing the FIN, if any).  If we truncate the whole
        // frame we'll ACKAndDrop it.
        //
        StateSize = Size + ((RcvInfo.tri_flags & TCP_FLAG_SYN) ? 1: 0) +
            ((RcvInfo.tri_flags & TCP_FLAG_FIN) ? 1: 0);

        if (StateSize)
            StateSize--;

        //
        // Now the incoming sequence number (RcvInfo.tri_seq) + StateSize
        // it the last sequence number in the segment.  If this is greater
        // than the last valid byte in the window, we have some overlap
        // to chop off.
        //
        ASSERT(StateSize >= 0);
        LastValidSeq = RcvTCB->tcb_rcvnext + RcvTCB->tcb_rcvwin - 1;
        if (SEQ_GT(RcvInfo.tri_seq + StateSize, LastValidSeq)) {
            int AmountToChop;

            //
            // At least some part of the frame is outside of our window.
            // See if it starts outside our window.
            //
            if (SEQ_GT(RcvInfo.tri_seq, LastValidSeq)) {
                //
                // Falls entirely outside the window.  We have special
                // case code to deal with a pure ack that falls exactly at
                // our right window edge.  Otherwise we ack and drop it.
                //
                if (!SEQ_EQ(RcvInfo.tri_seq, LastValidSeq+1) || Size != 0
                    || (RcvInfo.tri_flags & (TCP_FLAG_SYN | TCP_FLAG_FIN))) {
                    ACKAndDrop(&RcvInfo, RcvTCB);
                    return IP_PROTOCOL_NONE;
                }
            } else {
                //
                // At least some part of it is in the window.  If there's a
                // FIN, chop that off and see if that moves us inside.
                //
                if (RcvInfo.tri_flags & TCP_FLAG_FIN) {
                    RcvInfo.tri_flags &= ~TCP_FLAG_FIN;
                    StateSize--;
                }

                //
                // Now figure out how much to chop off.
                //
                AmountToChop = (RcvInfo.tri_seq + StateSize) - LastValidSeq;
                ASSERT(AmountToChop >= 0);
                Size -= AmountToChop;
            }
        }
    } else {
        if (!SEQ_EQ(RcvTCB->tcb_rcvnext, RcvInfo.tri_seq)) {
            //
            // If there's a RST on this segment, and he's only off by 1,
            // take it anyway.  This can happen if the remote peer is
            // probing and sends with the seq number after the probe.
            //
            if (!(RcvInfo.tri_flags & TCP_FLAG_RST) ||
                !(SEQ_EQ(RcvTCB->tcb_rcvnext, (RcvInfo.tri_seq - 1)))) {
                ACKAndDrop(&RcvInfo, RcvTCB);
                return IP_PROTOCOL_NONE;
            } else
                RcvInfo.tri_seq = RcvTCB->tcb_rcvnext;
        }

        //
        // He's in sequence, but we have a window of 0.  Truncate the
        // size, and clear any sequence consuming bits.
        //
        if (Size != 0 || (RcvInfo.tri_flags &
                          (TCP_FLAG_SYN | TCP_FLAG_FIN))) {
            RcvInfo.tri_flags &= ~(TCP_FLAG_SYN | TCP_FLAG_FIN);
            Size = 0;
            if (!(RcvInfo.tri_flags & TCP_FLAG_RST))
                DelayAction(RcvTCB, NEED_ACK);
        }
    }

    //
    // At this point, the segment is in our window and does not overlap
    // on either end.  If it's the next sequence number we expect, we can
    // handle the data now.  Otherwise we'll queue it for later.  In either
    // case we'll handle RST and ACK information right now.
    //
    ASSERT((*(int *)&Size) >= 0);

    //
    // Now, following 793, we check the RST bit.
    //
    if (RcvInfo.tri_flags & TCP_FLAG_RST) {
        uchar Reason;
        //
        // We can't go back into the LISTEN state from SYN-RCVD here,
        // because we may have notified the client via a listen completing
        // or a connect indication.  So, if came from an active open we'll
        // give back a 'connection refused' notice.  For all other cases
        // we'll just destroy the connection.
        //
        if (RcvTCB->tcb_state == TCB_SYN_RCVD) {
            if (RcvTCB->tcb_flags & ACTIVE_OPEN)
                Reason = TCB_CLOSE_REFUSED;
            else
                Reason = TCB_CLOSE_RST;
        } else
            Reason = TCB_CLOSE_RST;

        TryToCloseTCB(RcvTCB, Reason, DISPATCH_LEVEL);
        KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);

        if (RcvTCB->tcb_state != TCB_TIME_WAIT) {
            KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
            RemoveTCBFromConn(RcvTCB);
            NotifyOfDisc(RcvTCB, TDI_CONNECTION_RESET, NULL);
            KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
        }

        DerefTCB(RcvTCB, DISPATCH_LEVEL);
        return IP_PROTOCOL_NONE;
    }

    //
    // Next check the SYN bit.
    //
    if (RcvInfo.tri_flags & TCP_FLAG_SYN) {
        //
        // Again, we can't quietly go back into the LISTEN state here, even
        // if we came from a passive open.
        //
        TryToCloseTCB(RcvTCB, TCB_CLOSE_ABORTED, DISPATCH_LEVEL);
        SendRSTFromHeader(TCP, Size, Packet->SrcAddr, SrcScopeId,
                          AlignAddr(&Packet->IP->Dest), DestScopeId);

        KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);

        if (RcvTCB->tcb_state != TCB_TIME_WAIT) {
            KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
            RemoveTCBFromConn(RcvTCB);
            NotifyOfDisc(RcvTCB, TDI_CONNECTION_RESET, NULL);
            KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
        }

        DerefTCB(RcvTCB, DISPATCH_LEVEL);
        return IP_PROTOCOL_NONE;
    }

    //
    // Check the ACK field. If it's not on drop the segment.
    //
    if (!(RcvInfo.tri_flags & TCP_FLAG_ACK)) {
        //
        // No ACK.  Just drop the segment and return.
        //
        DerefTCB(RcvTCB, DISPATCH_LEVEL);
        return IP_PROTOCOL_NONE;
    }

    //
    // If we're in SYN-RCVD, go to ESTABLISHED.
    //
    if (RcvTCB->tcb_state == TCB_SYN_RCVD) {
        if (SEQ_LT(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
            SEQ_LTE(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
            //
            // The ack is valid.
            //
            if (RcvTCB->tcb_flags & ACCEPT_PENDING) {
                AddrObj *AO;
                BOOLEAN Accepted;

                //
                // We have not yet indicated this connection to the client,
                // so do it now.
                //

                KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);

                //
                // Check if we still have the listening endpoint.
                //
                KeAcquireSpinLockAtDpcLevel(&AddrObjTableLock);
                AO = GetBestAddrObj(AlignAddr(&Packet->IP->Dest),
                                    Packet->SrcAddr, DestScopeId,
                                    TCP->tcp_dest, IP_PROTOCOL_TCP,
                                    NTE->IF);

                if (AO != NULL) {
                    Accepted = DelayedAcceptConn(AO, Packet->SrcAddr,
                                                 SrcScopeId, TCP->tcp_src,
                                                 RcvTCB);
                } else {
                    KeReleaseSpinLockFromDpcLevel(&AddrObjTableLock);
                    Accepted = FALSE;
                }

                KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);

                if (!Accepted) {

                    //
                    // Delayed acceptance failed. Send RST.
                    //
                    TryToCloseTCB(RcvTCB, TCB_CLOSE_REFUSED, DISPATCH_LEVEL);
                    KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
                    DerefTCB(RcvTCB, DISPATCH_LEVEL);
                    SendRSTFromHeader(TCP, Packet->TotalSize,
                                      Packet->SrcAddr, SrcScopeId,
                                      AlignAddr(&Packet->IP->Dest),
                                      DestScopeId);
                    return IP_SUCCESS;
                }
            }

            RcvTCB->tcb_rexmitcnt = 0;
            STOP_TCB_TIMER(RcvTCB->tcb_rexmittimer);
            RcvTCB->tcb_senduna++;
            RcvTCB->tcb_sendwin = RcvInfo.tri_window;
            RcvTCB->tcb_maxwin = RcvInfo.tri_window;
            RcvTCB->tcb_sendwl1 = RcvInfo.tri_seq;
            RcvTCB->tcb_sendwl2 = RcvInfo.tri_ack;
            GoToEstab(RcvTCB);

            //
            // We know our peer received our SYN.
            //
            if (RcvTCB->tcb_rce != NULL)
                ConfirmForwardReachability(RcvTCB->tcb_rce);

            //
            // Now complete whatever we can here.
            //
            CompleteConnReq(RcvTCB, TDI_SUCCESS);
        } else {
            DerefTCB(RcvTCB, DISPATCH_LEVEL);
            SendRSTFromHeader(TCP, Size, Packet->SrcAddr, SrcScopeId,
                              AlignAddr(&Packet->IP->Dest), DestScopeId);
            return IP_PROTOCOL_NONE;
        }
    } else {
        //
        // We're not in SYN-RCVD.  See if this acknowledges anything.
        //
        if (SEQ_LT(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
            SEQ_LTE(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
            uint CWin;

            //
            // The ack acknowledes something.  Pull the
            // appropriate amount off the send q.
            //
            ACKData(RcvTCB, RcvInfo.tri_ack);

            //
            // If this acknowledges something we were running a RTT on,
            // update that stuff now.
            //
            if (RcvTCB->tcb_rtt != 0 && SEQ_GT(RcvInfo.tri_ack,
                                               RcvTCB->tcb_rttseq)) {
                short RTT;

                RTT = (short)(TCPTime - RcvTCB->tcb_rtt);
                RcvTCB->tcb_rtt = 0;
                RTT -= (RcvTCB->tcb_smrtt >> 3);
                RcvTCB->tcb_smrtt += RTT;
                RTT = (RTT >= 0 ? RTT : -RTT);
                RTT -= (RcvTCB->tcb_delta >> 3);
                RcvTCB->tcb_delta += RTT + RTT;
                RcvTCB->tcb_rexmit = MIN(MAX(REXMIT_TO(RcvTCB),
                                             MIN_RETRAN_TICKS),
                                         MAX_REXMIT_TO);
            }

            //
            // If we're probing for a PMTU black hole then we've found
            // one, so turn off the detection.  The size is already
            // down, so leave it there.
            //
            if (RcvTCB->tcb_flags & PMTU_BH_PROBE) {
                RcvTCB->tcb_flags &= ~PMTU_BH_PROBE;
                RcvTCB->tcb_bhprobecnt = 0;
                if (--(RcvTCB->tcb_slowcount) == 0) {
                    RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                    CheckTCBRcv(RcvTCB);
                }
            }

            if ((RcvTCB->tcb_dupacks >= MaxDupAcks) &&
                ((int)RcvTCB->tcb_ssthresh > 0)) {
                //
                // We were in fast retransmit mode, so this ACK is for
                // our fast retransmitted frame.  Set cwin to ssthresh
                // so that cwin grows linearly from here.
                //
                RcvTCB->tcb_cwin = RcvTCB->tcb_ssthresh;

            } else {
                //
                // Update the congestion window now.
                //
                CWin = RcvTCB->tcb_cwin;
                if (CWin < RcvTCB->tcb_maxwin) {
                    if (CWin < RcvTCB->tcb_ssthresh)
                        CWin += RcvTCB->tcb_mss;
                    else
                        CWin += (RcvTCB->tcb_mss * RcvTCB->tcb_mss) / CWin;

                    RcvTCB->tcb_cwin = MIN(CWin, RcvTCB->tcb_maxwin);
                }
            }
            ASSERT(*(int *)&RcvTCB->tcb_cwin > 0);

            //
            // Since this isn't a duplicate ACK, reset the counter.
            //
            RcvTCB->tcb_dupacks = 0;

            //
            // We've acknowledged something, so reset the rexmit count.
            // If there's still stuff outstanding, restart the rexmit
            // timer.
            //
            RcvTCB->tcb_rexmitcnt = 0;
            if (!SEQ_EQ(RcvInfo.tri_ack, RcvTCB->tcb_sendmax))
                START_TCB_TIMER(RcvTCB->tcb_rexmittimer,
                                RcvTCB->tcb_rexmit);
            else
                STOP_TCB_TIMER(RcvTCB->tcb_rexmittimer);

            //
            // If we've sent a FIN, and this acknowledges it, we
            // need to complete the client's close request and
            // possibly transition our state.
            //
            if (RcvTCB->tcb_flags & FIN_SENT) {
                //
                // We have sent a FIN.  See if it's been acknowledged.
                // Once we've sent a FIN, tcb_sendmax can't advance,
                // so our FIN must have sequence num tcb_sendmax - 1.
                // Thus our FIN is acknowledged if the incoming ack is
                // equal to tcb_sendmax.
                //
                if (SEQ_EQ(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
                    //
                    // He's acked our FIN.  Turn off the flags,
                    // and complete the request.  We'll leave the
                    // FIN_OUTSTANDING flag alone, to force early
                    // outs in the send code.
                    //
                    RcvTCB->tcb_flags &= ~(FIN_NEEDED | FIN_SENT);

                    ASSERT(RcvTCB->tcb_unacked == 0);
                    ASSERT(RcvTCB->tcb_sendnext == RcvTCB->tcb_sendmax);

                    //
                    // Now figure out what we need to do. In FIN_WAIT1
                    // or FIN_WAIT, just complete the disconnect
                    // request and continue.  Otherwise, it's a bit
                    // trickier, since we can't complete the connreq
                    // until we remove the TCB from it's connection.
                    //
                    switch (RcvTCB->tcb_state) {

                    case TCB_FIN_WAIT1:
                        RcvTCB->tcb_state = TCB_FIN_WAIT2;
                        CompleteConnReq(RcvTCB, TDI_SUCCESS);

                        //
                        // Start a timer in case we never get
                        // out of FIN_WAIT2.  Set the retransmit
                        // count high to force a timeout the
                        // first time the timer fires.
                        //
                        RcvTCB->tcb_rexmitcnt = (uchar)MaxDataRexmitCount;
                        START_TCB_TIMER(RcvTCB->tcb_rexmittimer,
                                        (ushort)FinWait2TO);

                        // Fall through to FIN-WAIT-2 processing.
                    case TCB_FIN_WAIT2:
                        break;
                    case TCB_CLOSING:
                        GracefulClose(RcvTCB, TRUE, FALSE, DISPATCH_LEVEL);
                        return IP_PROTOCOL_NONE;
                        break;
                    case TCB_LAST_ACK:
                        GracefulClose(RcvTCB, FALSE, FALSE, DISPATCH_LEVEL);
                        return IP_PROTOCOL_NONE;
                        break;
                    default:
                        KdBreakPoint();
                        break;
                    }
                }
            }
            UpdateWindow = TRUE;
        } else {
            //
            // It doesn't ack anything.  If we're in FIN_WAIT2,
            // we'll restart the timer.  We don't make this check
            // above because we know no data can be acked when we're
            // in FIN_WAIT2.
            //
            if (RcvTCB->tcb_state == TCB_FIN_WAIT2)
                START_TCB_TIMER(RcvTCB->tcb_rexmittimer, (ushort)FinWait2TO);

            //
            // If it's an ack for something larger than
            // we've sent then ACKAndDrop it.
            //
            if (SEQ_GT(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
                ACKAndDrop(&RcvInfo, RcvTCB);
                return IP_PROTOCOL_NONE;
            }

            //
            // If it is a pure duplicate ack, check if we should
            // do a fast retransmit.
            //
            if ((Size == 0) &&
                SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                SEQ_LT(RcvTCB->tcb_senduna, RcvTCB->tcb_sendmax) &&
                (RcvTCB->tcb_sendwin == RcvInfo.tri_window) &&
                RcvInfo.tri_window) {

                //
                // See if fast rexmit can be done.
                //
                if (HandleFastXmit(RcvTCB, &RcvInfo)) {
                    return IP_PROTOCOL_NONE;
                }

            } else {
                //
                // Not a pure duplicate ack (Size != 0 or peer is
                // advertising a new window).  Reset counter.
                //
                RcvTCB->tcb_dupacks = 0;

                //
                // See if we should update the window.
                //
                if (SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                    (SEQ_LT(RcvTCB->tcb_sendwl1, RcvInfo.tri_seq) ||
                     (SEQ_EQ(RcvTCB->tcb_sendwl1, RcvInfo.tri_seq) &&
                      SEQ_LTE(RcvTCB->tcb_sendwl2, RcvInfo.tri_ack)))){
                    UpdateWindow = TRUE;
                } else
                    UpdateWindow = FALSE;
            }
        }

        if (UpdateWindow) {
            RcvTCB->tcb_sendwin = RcvInfo.tri_window;
            RcvTCB->tcb_maxwin = MAX(RcvTCB->tcb_maxwin, RcvInfo.tri_window);
            RcvTCB->tcb_sendwl1 = RcvInfo.tri_seq;
            RcvTCB->tcb_sendwl2 = RcvInfo.tri_ack;
            if (RcvInfo.tri_window == 0) {
                //
                // We've got a zero window.
                //
                if (!EMPTYQ(&RcvTCB->tcb_sendq)) {
                    RcvTCB->tcb_flags &= ~NEED_OUTPUT;
                    RcvTCB->tcb_rexmitcnt = 0;
                    START_TCB_TIMER(RcvTCB->tcb_rexmittimer,
                                    RcvTCB->tcb_rexmit);
                    if (!(RcvTCB->tcb_flags & FLOW_CNTLD)) {
                        RcvTCB->tcb_flags |= FLOW_CNTLD;
                        RcvTCB->tcb_slowcount++;
                        RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                        CheckTCBRcv(RcvTCB);
                    }
                }
            } else {
                if (RcvTCB->tcb_flags & FLOW_CNTLD) {
                    RcvTCB->tcb_rexmitcnt = 0;
                    RcvTCB->tcb_flags &= ~(FLOW_CNTLD | FORCE_OUTPUT);
                    //
                    // Reset send next to the left edge of the window,
                    // because it might be at senduna+1 if we've been
                    // probing.
                    //
                    ResetSendNext(RcvTCB, RcvTCB->tcb_senduna);
                    if (--(RcvTCB->tcb_slowcount) == 0) {
                        RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                        CheckTCBRcv(RcvTCB);
                    }
                }

                //
                // Since we've updated the window, see if we can send
                // some more.
                //
                if (RcvTCB->tcb_unacked != 0 ||
                    (RcvTCB->tcb_flags & FIN_NEEDED))
                    DelayAction(RcvTCB, NEED_OUTPUT);
            }
        }
    }

    //
    // We've handled all the acknowledgment stuff.  If the size
    // is greater than 0 or important bits are set process it further,
    // otherwise it's a pure ack and we're done with it.
    //
    if (Size > 0 || (RcvInfo.tri_flags & TCP_FLAG_FIN)) {
        //
        // If we're not in a state where we can process incoming data
        // or FINs, there's no point in going further.  Just send an
        // ack and drop this segment.
        //
        if (!DATA_RCV_STATE(RcvTCB->tcb_state) ||
            (RcvTCB->tcb_flags & GC_PENDING)) {
            ACKAndDrop(&RcvInfo, RcvTCB);
            return IP_PROTOCOL_NONE;
        }

        //
        // If our peer is sending into an expanded window, then our
        // peer must have received our ACK advertising said window.
        // Take this as proof of forward reachability.
        // Note: we have no guarantee this is timely.
        //
        if (SEQ_GTE(RcvInfo.tri_seq + (int)Size,
                    RcvTCB->tcb_rcvwinwatch)) {
            RcvTCB->tcb_rcvwinwatch = RcvTCB->tcb_rcvnext +
                RcvTCB->tcb_rcvwin;
            if (RcvTCB->tcb_rce != NULL)
                ConfirmForwardReachability(RcvTCB->tcb_rce);
        }

        //
        // If it's in sequence process it now, otherwise reassemble it.
        //
        if (SEQ_EQ(RcvInfo.tri_seq, RcvTCB->tcb_rcvnext)) {
            //
            // If we're already in the receive handler, this is a
            // duplicate.  We'll just toss it.
            //
            if (RcvTCB->tcb_fastchk & TCP_FLAG_IN_RCV) {
                DerefTCB(RcvTCB, DISPATCH_LEVEL);
                return IP_PROTOCOL_NONE;
            }

            RcvTCB->tcb_fastchk |= TCP_FLAG_IN_RCV;

            //
            // Now loop, pulling things from the reassembly queue,
            // until the queue is empty, or we can't take all of the
            // data, or we hit a FIN.
            //
            do {
                //
                // Handle urgent data, if any.
                //
                if (RcvInfo.tri_flags & TCP_FLAG_URG) {
                    HandleUrgent(RcvTCB, &RcvInfo, Packet, &Size);

                    //
                    // Since we may have freed the lock, we need to
                    // recheck and see if we're closing here.
                    //
                    if (CLOSING(RcvTCB))
                        break;
                }

                //
                // OK, the data is in sequence, we've updated the
                // reassembly queue and handled any urgent data.  If we
                // have any data go ahead and process it now.
                //
                if (Size > 0) {
                    BytesTaken = (*RcvTCB->tcb_rcvhndlr)
                        (RcvTCB, RcvInfo.tri_flags, Packet, Size);
                    RcvTCB->tcb_rcvnext += BytesTaken;
                    RcvTCB->tcb_rcvwin -= BytesTaken;

                    CheckTCBRcv(RcvTCB);
                    if (RcvTCB->tcb_flags & ACK_DELAYED)
                        DelayAction(RcvTCB, NEED_ACK);
                    else {
                        RcvTCB->tcb_flags |= ACK_DELAYED;
                        START_TCB_TIMER(RcvTCB->tcb_delacktimer,
                                        DEL_ACK_TICKS);
                    }

                    if (BytesTaken != Size) {
                        //
                        // We didn't take everything we could.  No
                        // use in further processing, just bail
                        // out.
                        //
                        DelayAction(RcvTCB, NEED_ACK);
                        break;
                    }

                    //
                    // If we're closing now, we're done, so get out.
                    //
                    if (CLOSING(RcvTCB))
                        break;
                }

                //
                // See if we need to advance over some urgent data.
                //
                if (RcvTCB->tcb_flags & URG_VALID) {
                    uint AdvanceNeeded;

                    //
                    // We only need to advance if we're not doing
                    // urgent inline.  Urgent inline also has some
                    // implications for when we can clear the URG_VALID
                    // flag.  If we're not doing urgent inline, we can
                    // clear it when rcvnext advances beyond urgent
                    // end.  If we are doing urgent inline, we clear it
                    // when rcvnext advances one receive window beyond
                    // urgend.
                    //
                    if (!(RcvTCB->tcb_flags & URG_INLINE)) {
                        if (RcvTCB->tcb_rcvnext == RcvTCB->tcb_urgstart) {
                            RcvTCB->tcb_rcvnext = RcvTCB->tcb_urgend + 1;
                        } else {
                            ASSERT(SEQ_LT(RcvTCB->tcb_rcvnext,
                                          RcvTCB->tcb_urgstart) ||
                                   SEQ_GT(RcvTCB->tcb_rcvnext,
                                          RcvTCB->tcb_urgend));
                        }
                        AdvanceNeeded = 0;
                    } else
                        AdvanceNeeded = RcvTCB->tcb_defaultwin;

                    //
                    // See if we can clear the URG_VALID flag.
                    //
                    if (SEQ_GT(RcvTCB->tcb_rcvnext - AdvanceNeeded,
                               RcvTCB->tcb_urgend)) {
                        RcvTCB->tcb_flags &= ~URG_VALID;
                        if (--(RcvTCB->tcb_slowcount) == 0) {
                            RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                            CheckTCBRcv(RcvTCB);
                        }
                    }
                }

                //
                // We've handled the data.  If the FIN bit is set, we
                // have more processing.
                //
                if (RcvInfo.tri_flags & TCP_FLAG_FIN) {
                    uint Notify = FALSE;

                    RcvTCB->tcb_rcvnext++;
                    DelayAction(RcvTCB, NEED_ACK);

                    PushData(RcvTCB);

                    switch (RcvTCB->tcb_state) {

                    case TCB_SYN_RCVD:
                        //
                        // I don't think we can get here - we
                        // should have discarded the frame if it
                        // had no ACK, or gone to established if
                        // it did.
                        //
                        KdBreakPoint();
                    case TCB_ESTAB:
                        RcvTCB->tcb_state = TCB_CLOSE_WAIT;
                        //
                        // We left established, we're off the
                        // fast path.
                        //
                        RcvTCB->tcb_slowcount++;
                        RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                        CheckTCBRcv(RcvTCB);
                        Notify = TRUE;
                        break;
                    case TCB_FIN_WAIT1:
                        RcvTCB->tcb_state = TCB_CLOSING;
                        Notify = TRUE;
                        break;
                    case TCB_FIN_WAIT2:
                        //
                        // Stop the FIN_WAIT2 timer.
                        //
                        STOP_TCB_TIMER(RcvTCB->tcb_rexmittimer);
                        RcvTCB->tcb_refcnt++;
                        GracefulClose(RcvTCB, TRUE, TRUE, DISPATCH_LEVEL);
                        KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
                        break;
                    default:
                        KdBreakPoint();
                        break;
                    }

                    if (Notify) {
                        KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
                        NotifyOfDisc(RcvTCB, TDI_GRACEFUL_DISC, NULL);
                        KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
                    }

                    break;  // Exit out of WHILE loop.
                }

                //
                // If the reassembly queue isn't empty, get what we
                // can now.
                //
                Packet = PullFromRAQ(RcvTCB, &RcvInfo, &Size);
                CheckPacketList(Packet, Size);

            } while (Packet != NULL);

            RcvTCB->tcb_fastchk &= ~TCP_FLAG_IN_RCV;
            if (RcvTCB->tcb_flags & SEND_AFTER_RCV) {
                RcvTCB->tcb_flags &= ~SEND_AFTER_RCV;
                DelayAction(RcvTCB, NEED_OUTPUT);
            }

            DerefTCB(RcvTCB, DISPATCH_LEVEL);
            return IP_PROTOCOL_NONE;

        } else {

            //
            // It's not in sequence.  Since it needs further
            // processing, put in on the reassembly queue.
            //
            if (DATA_RCV_STATE(RcvTCB->tcb_state) &&
                !(RcvTCB->tcb_flags & GC_PENDING))  {
                PutOnRAQ(RcvTCB, &RcvInfo, Packet, Size);
                KeReleaseSpinLockFromDpcLevel(&RcvTCB->tcb_lock);
                SendACK(RcvTCB);
                KeAcquireSpinLockAtDpcLevel(&RcvTCB->tcb_lock);
                DerefTCB(RcvTCB, DISPATCH_LEVEL);
            } else
                ACKAndDrop(&RcvInfo, RcvTCB);

            return IP_PROTOCOL_NONE;
        }
    }

    DerefTCB(RcvTCB, DISPATCH_LEVEL);

    return IP_PROTOCOL_NONE;
}


//* TCPControlReceive - handler for TCP control messages.
//
//  This routine is called if we receive an ICMPv6 error message that
//  was generated by some remote site as a result of receiving a TCP
//  packet from us.
//
uchar
TCPControlReceive(
    IPv6Packet *Packet,  // Packet handed to us by ICMPv6ErrorReceive.
    StatusArg *StatArg)  // Error Code, Argument, and invoking IP header.
{
    KIRQL Irql0, Irql1;  // One per lock nesting level.
    TCB *StatusTCB;
    SeqNum DropSeq;
    TCPHeader UNALIGNED *InvokingTCP;
    Interface *IF = Packet->NTEorIF->IF;
    uint SrcScopeId, DestScopeId;

    //
    // The next thing in the packet should be the TCP header of the
    // original packet which invoked this error.
    //
    if (! PacketPullup(Packet, sizeof(TCPHeader), 1, 0)) {
        // Pullup failed.
        if (Packet->TotalSize < sizeof(TCPHeader))
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "TCPv6: Packet too small to contain TCP header "
                       "from invoking packet\n"));
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    InvokingTCP = (TCPHeader UNALIGNED *)Packet->Data;

    //
    // Determining the scope identifiers for the addresses in the
    // invoking packet is potentially problematic, since we have
    // no way to be certain which interface we sent the packet on.
    // Use the interface the icmp error arrived on to determine
    // the scope ids for both the local and remote addresses.
    //
    SrcScopeId = DetermineScopeId(AlignAddr(&StatArg->IP->Source), IF);
    DestScopeId = DetermineScopeId(AlignAddr(&StatArg->IP->Dest), IF);

    //
    // Find the TCB for the connection this packet was sent on.
    //
    KeAcquireSpinLock(&TCBTableLock, &Irql0);
    StatusTCB = FindTCB(AlignAddr(&StatArg->IP->Source),
                        AlignAddr(&StatArg->IP->Dest),
                        SrcScopeId, DestScopeId,
                        InvokingTCP->tcp_src, InvokingTCP->tcp_dest);
    if (StatusTCB != NULL) {
        //
        // Found one.  Get the lock on it, and continue.
        //
        CHECK_STRUCT(StatusTCB, tcb);

        KeAcquireSpinLock(&StatusTCB->tcb_lock, &Irql1);
        KeReleaseSpinLock(&TCBTableLock, Irql1);

        //
        // Make sure the TCB is in a state that is interesting.
        //
        if (StatusTCB->tcb_state == TCB_CLOSED ||
            StatusTCB->tcb_state == TCB_TIME_WAIT ||
            CLOSING(StatusTCB)) {
            //
            // Connection is already closing, or too new to have sent
            // anything yet.  Leave it be.
            //
            KeReleaseSpinLock(&StatusTCB->tcb_lock, Irql0);
            return IP_PROTOCOL_NONE;  // Discard error packet.
        }

        switch (StatArg->Status) {
        case IP_UNRECOGNIZED_NEXT_HEADER:
            //
            // Destination protocol unreachable.
            // We treat this as a fatal errors.  Close the connection.
            //
            StatusTCB->tcb_error = StatArg->Status;
            StatusTCB->tcb_refcnt++;
            TryToCloseTCB(StatusTCB, TCB_CLOSE_UNREACH, Irql0);

            RemoveTCBFromConn(StatusTCB);
            NotifyOfDisc(StatusTCB,
                         MapIPError(StatArg->Status, TDI_DEST_UNREACHABLE),
                         NULL);
            KeAcquireSpinLock(&StatusTCB->tcb_lock, &Irql1);
            DerefTCB(StatusTCB, Irql1);
            return IP_PROTOCOL_NONE;  // Done with packet.
            break;

        case IP_DEST_NO_ROUTE:
        case IP_DEST_ADDR_UNREACHABLE:
        case IP_DEST_PORT_UNREACHABLE:
        case IP_DEST_PROHIBITED:
        case IP_BAD_ROUTE:
        case IP_HOP_LIMIT_EXCEEDED:
        case IP_REASSEMBLY_TIME_EXCEEDED:
        case IP_PARAMETER_PROBLEM:
            //
            // Soft errors.  Save the error in case it times out.
            //
            StatusTCB->tcb_error = StatArg->Status;
            break;

        case IP_PACKET_TOO_BIG: {
            uint PMTU;

            IF_TCPDBG(TCP_DEBUG_MSS) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TCPControlReceive: Got Packet Too Big\n"));
            }

            //
            // We sent a TCP datagram which was too big for the path to
            // our destination.  That packet was dropped by the router
            // which sent us this error message.  The Arg value is TRUE
            // if this Packet Too Big reduced our PMTU, FALSE otherwise.
            //
            if (!StatArg->Arg)
                break;

            //
            // Our PMTU was reduced.  Find out what it is now.
            //
            if (StatusTCB->tcb_rce == NULL) {
                //
                // We've released our RCE due to SYN attack protection
                // or because our outgoing interface went away.  In
                // either case it is unlikely that we would be receiving
                // a legitimate and useful Packet Too Big for this TCB.
                // So we ignore it.
                //
                break;
            }
            PMTU = GetEffectivePathMTUFromRCE(StatusTCB->tcb_rce);

            //
            // Update fields based on new PMTU.
            //
            StatusTCB->tcb_pmtu = PMTU;
            StatusTCB->tcb_security = SecurityStateValidationCounter;
            CalculateMSSForTCB(StatusTCB);

            //
            // Since our PMTU was reduced, we know that this is the first
            // Packet Too Big we've received about this bottleneck.
            // We should retransmit so long as this is for a legitimate
            // outstanding packet (i.e. sequence number is is greater than
            // the last acked and less than our current send next).
            //
            DropSeq = net_long(InvokingTCP->tcp_seq);
            if ((SEQ_GTE(DropSeq, StatusTCB->tcb_senduna)  &&
                 SEQ_LT(DropSeq, StatusTCB->tcb_sendnext))) {
                //
                // Need to initiate a retransmit.
                //
                ResetSendNext(StatusTCB, DropSeq);

                //
                // WINBUG #242757 11-27-2000 richdr TCP resp. to Packet Too Big
                // RFC 1981 states that "a retransmission caused by a Packet
                // Too Big message should not change the congestion window.
                // It should, however, trigger the slow-start mechanism."
                // The code below would appear to be broken.  However, the
                // IPv4 stack works this way.
                //

                //
                // Set the congestion window to allow only one packet.
                // This may prevent us from sending anything if we
                // didn't just set sendnext to senduna.  This is OK,
                // we'll retransmit later, or send when we get an ack.
                //
                StatusTCB->tcb_cwin = StatusTCB->tcb_mss;

                DelayAction(StatusTCB, NEED_OUTPUT);
            }
        }
        break;

        default:
            // Should never happen.
            KdBreakPoint();
            break;
        }

        KeReleaseSpinLock(&StatusTCB->tcb_lock, Irql0);
    } else {
        //
        // Couldn't find a matching TCB.  Connection probably went away since
        // we sent the offending packet.  Just free the lock and return.
        //
        KeReleaseSpinLock(&TCBTableLock, Irql0);
    }

    return IP_PROTOCOL_NONE;  // Done with packet.
}

#pragma BEGIN_INIT

//* InitTCPRcv - Initialize TCP receive side.
//
//  Called during init time to initialize our TCP receive side.
//
int          // Returns: TRUE.
InitTCPRcv(
    void)    // Nothing.
{
    ExInitializeSListHead(&TCPRcvReqFree);

    KeInitializeSpinLock(&RequestCompleteLock);
    KeInitializeSpinLock(&TCBDelayLock);
    KeInitializeSpinLock(&TCPRcvReqFreeLock);
    INITQ(&ConnRequestCompleteQ);
    INITQ(&SendCompleteQ);
    INITQ(&TCBDelayQ);
    RequestCompleteFlags = 0;
    TCBDelayRtnCount = 0;

    TCBDelayRtnLimit = (uint) KeNumberProcessors;
    if (TCBDelayRtnLimit > TCB_DELAY_RTN_LIMIT)
        TCBDelayRtnLimit = TCB_DELAY_RTN_LIMIT;

    RtlZeroMemory(&DummyPacket, sizeof DummyPacket);
    DummyPacket.Flags = PACKET_OURS;

    return TRUE;
}

#pragma END_INIT

//* UnloadTCPRcv
//
//  Cleanup and prepare for stack unload.
//
void
UnloadTCPRcv(void)
{
    PSLIST_ENTRY BufferLink;

    while ((BufferLink = ExInterlockedPopEntrySList(&TCPRcvReqFree,
                                                    &TCPRcvReqFreeLock))
                                                        != NULL) {
        TCPRcvReq *RcvReq = CONTAINING_RECORD(BufferLink, TCPRcvReq, trr_next);

        CHECK_STRUCT(RcvReq, trr);
        ExFreePool(RcvReq);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\udp\datagram.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Common code for dealing with datagrams.  This code is common to
// both UDP and Raw IP.
//

#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include "tdistat.h"
#include "tdint.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "datagram.h"

#define NO_TCP_DEFS 1
#include "tcpdeb.h"

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )
#ifndef __cplusplus
#pragma warning(disable:4116)       // TYPE_ALIGNMENT generates this
#endif
#endif
#endif

//
// REVIEW: shouldn't this be in an include file someplace?  Isn't it already?
//
#ifdef POOL_TAGGING

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, '6RGD')

#endif // POOL_TAGGING

#if 0
#define DG_MAX_HDRS 0xffff
#else
#define DG_MAX_HDRS 100
#endif

extern KSPIN_LOCK AddrObjTableLock;

DGSendReq *DGSendReqFree;
KSPIN_LOCK DGSendReqLock;

SLIST_HEADER DGRcvReqFree;
KSPIN_LOCK DGRcvReqFreeLock;

#if DBG
uint NumSendReq = 0;
ULONG NumRcvReq = 0;
#endif

//
// Information for maintaining the datagram send request pending queue.
//
Queue DGPending;
Queue DGDelayed;
WORK_QUEUE_ITEM DGDelayedWorkItem;


//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA

int InitDG(void);

#pragma alloc_text(INIT, InitDG)

#endif // ALLOC_PRAGMA


//* PutPendingQ - Put an address object on the pending queue.
//
//  Called when we've experienced an out of resources condition, and want
//  to queue an AddrObj for later processing.  We put the specified address
//  object on the DGPending queue, set the OOR flag and clear the
//  'send request' flag.  It is invariant in the system that the send
//  request flag and the OOR flag are not set at the same time.
//
//  This routine assumes that the caller holds the DGSendReqLock and the
//  lock on the particular AddrObj.
//
void                      // Returns: Nothing.
PutPendingQ(
    AddrObj *QueueingAO)  // Address object to be queued.
{
    CHECK_STRUCT(QueueingAO, ao);

    if (!AO_OOR(QueueingAO)) {
        CLEAR_AO_REQUEST(QueueingAO, AO_SEND);
        SET_AO_OOR(QueueingAO);

        ENQUEUE(&DGPending, &QueueingAO->ao_pendq);
    }
}


//* GetDGSendReq - Get a datagram send request.
//
//  Called when someone wants to allocate a datagram send request.
//  We assume the send request lock is held when we are called.
//
//  REVIEW: This routine and the corresponding free routine might
//  REVIEW: be good candidates for inlining.
//
DGSendReq *  // Returns: Pointer to the SendReq, or NULL if none.
GetDGSendReq()
{
    DGSendReq *NewReq;

    NewReq = DGSendReqFree;
    if (NewReq != NULL) {
        CHECK_STRUCT(NewReq, dsr);
        DGSendReqFree = (DGSendReq *)NewReq->dsr_q.q_next;
    } else {
        //
        // Couldn't get a request, grow it.  This is one area where we'll try
        // to allocate memory with a lock held.  Because of this, we've
        // got to be careful about where we call this routine from.
        //
        NewReq = ExAllocatePool(NonPagedPool, sizeof(DGSendReq));
        if (NewReq != NULL) {
#if DBG
            NewReq->dsr_sig = dsr_signature;
            NumSendReq++;
#endif
        }
    }

    return NewReq;
}


//* FreeDGSendReq - Free a DG send request.
//
//  Called when someone wants to free a datagram send request.
//  It's assumed that the caller holds the SendRequest lock.
//
void                     // Returns: Nothing.
FreeDGSendReq(
    DGSendReq *SendReq)  // SendReq to be freed.
{
    CHECK_STRUCT(SendReq, dsr);

    *(DGSendReq **)&SendReq->dsr_q.q_next = DGSendReqFree;
    DGSendReqFree = SendReq;
}


//* GetDGRcvReq - Get a DG receive request.
//
//  Called when we need to get a datagram receive request.
//
DGRcvReq *  // Returns: Pointer to new request, or NULL if none.
GetDGRcvReq()
{
    DGRcvReq *NewReq;
    PSLIST_ENTRY BufferLink;
    Queue *QueuePtr;

    BufferLink = ExInterlockedPopEntrySList(&DGRcvReqFree, &DGRcvReqFreeLock);

    if (BufferLink != NULL) {
        QueuePtr = CONTAINING_RECORD(BufferLink, Queue, q_next);
        NewReq = CONTAINING_RECORD(QueuePtr, DGRcvReq, drr_q);
        CHECK_STRUCT(NewReq, drr);
    } else {
        // Couldn't get a request, grow it.
        NewReq = ExAllocatePool(NonPagedPool, sizeof(DGRcvReq));
        if (NewReq != NULL) {
#if DBG
            NewReq->drr_sig = drr_signature;
            ExInterlockedAddUlong(&NumRcvReq, 1, &DGRcvReqFreeLock);
#endif
        }
    }

    return NewReq;
}


//* FreeDGRcvReq - Free a datagram receive request.
//
//  Called when someone wants to free a datagram receive request.
//
void                   // Returns: Nothing.
FreeDGRcvReq(
    DGRcvReq *RcvReq)  // RcvReq to be freed.
{
    PSLIST_ENTRY BufferLink;

    CHECK_STRUCT(RcvReq, drr);

    BufferLink = CONTAINING_RECORD(&(RcvReq->drr_q.q_next), SLIST_ENTRY,
                                   Next);
    ExInterlockedPushEntrySList(&DGRcvReqFree, BufferLink, &DGRcvReqFreeLock);
}


//* DGDelayedWorker - Routine to handle a delayed work item.
//
//  This is the work item callback routine, used for out-of-resources
//  conditions on AddrObjs.  We pull from the delayed queue, and if the addr
//  obj is not already busy we'll send the datagram.
//
void                  // Returns: Nothing.
DGDelayedWorker(
    void *Context)    // Nothing.
{
    KIRQL Irql0, Irql1;  // One per lock nesting level.
    AddrObj *SendingAO;
    DGSendProc SendProc;

    UNREFERENCED_PARAMETER(Context);

    KeAcquireSpinLock(&DGSendReqLock, &Irql0);
    while (!EMPTYQ(&DGDelayed)) {
        DEQUEUE(&DGDelayed, SendingAO, AddrObj, ao_pendq);
        CHECK_STRUCT(SendingAO, ao);

        KeAcquireSpinLock(&SendingAO->ao_lock, &Irql1);

        CLEAR_AO_OOR(SendingAO);
        if (!AO_BUSY(SendingAO)) {
            DGSendReq *SendReq;

            if (!EMPTYQ(&SendingAO->ao_sendq)) {
                DEQUEUE(&SendingAO->ao_sendq, SendReq, DGSendReq, dsr_q);

                CHECK_STRUCT(SendReq, dsr);

                SendingAO->ao_usecnt++;
                SendProc = SendingAO->ao_dgsend;
                KeReleaseSpinLock(&SendingAO->ao_lock, Irql1);
                KeReleaseSpinLock(&DGSendReqLock, Irql0);

                (*SendProc)(SendingAO, SendReq);
                DEREF_AO(SendingAO);
                KeAcquireSpinLock(&DGSendReqLock, &Irql0);
            } else {
                ABORT();
                KeReleaseSpinLock(&SendingAO->ao_lock, Irql1);
            }

        } else {
            SET_AO_REQUEST(SendingAO, AO_SEND);
            KeReleaseSpinLock(&SendingAO->ao_lock, Irql1);
        }
    }

    KeReleaseSpinLock(&DGSendReqLock, Irql0);
}

//* DGSendComplete - DG send complete handler.
//
//  This is the routine called by IP when a send completes.  We
//  take the context passed back as a pointer to a SendRequest
//  structure, and complete the caller's send.
//
void                      // Returns: Nothing.
DGSendComplete(
    PNDIS_PACKET Packet,  // Packet that was sent.
    IP_STATUS Status)
{
    DGSendReq *FinishedSR;
    KIRQL Irql0, Irql1;  // One per lock nesting level.
    RequestCompleteRoutine Callback;  // Request's Completion routine.
    PVOID CallbackContext;  // User context.
    ushort SentSize;
    AddrObj *AO;
    PNDIS_BUFFER BufferChain;  // Chain of buffers sent.

    //
    // Pull values we care about out of the packet structure.
    //
    FinishedSR = (DGSendReq *) PC(Packet)->CompletionData;
    BufferChain = NdisFirstBuffer(Packet);
    CHECK_STRUCT(FinishedSR, dsr);
    Callback = FinishedSR->dsr_rtn;
    CallbackContext = FinishedSR->dsr_context;
    SentSize = FinishedSR->dsr_size;

    //
    // Free resources acquired for this send.
    // Note we only free the first buffer on the chain, as that is the
    // only buffer added by the datagram code prior to sending.  Our
    // TDI client is responsible for the rest.
    //
    if (BufferChain != FinishedSR->dsr_buffer) {
        PVOID Memory;
        UINT Unused;

        NdisQueryBuffer(BufferChain, &Memory, &Unused);
        NdisFreeBuffer(BufferChain);
        ExFreePool(Memory);
    }

    NdisFreePacket(Packet);

    KeAcquireSpinLock(&DGSendReqLock, &Irql0);
    FreeDGSendReq(FinishedSR);

    //
    // If there's something on the pending queue, schedule an event
    // to deal with it.  We may have just freed up the needed resources.
    //
    if (!EMPTYQ(&DGPending)) {
        DEQUEUE(&DGPending, AO, AddrObj, ao_pendq);
        CHECK_STRUCT(AO, ao);
        KeAcquireSpinLock(&AO->ao_lock, &Irql1);
        if (!EMPTYQ(&AO->ao_sendq)) {
            DGSendReq *SendReq;

            PEEKQ(&AO->ao_sendq, SendReq, DGSendReq, dsr_q);
            ENQUEUE(&DGDelayed, &AO->ao_pendq);
            KeReleaseSpinLock(&AO->ao_lock, Irql1);
            ExQueueWorkItem(&DGDelayedWorkItem, CriticalWorkQueue);
        } else {
            // On the pending queue, but no sends!
            KdBreakPoint();
            CLEAR_AO_OOR(AO);
            KeReleaseSpinLock(&AO->ao_lock, Irql1);
        }
    }

    KeReleaseSpinLock(&DGSendReqLock, Irql0);
    if (Callback != NULL) {
        TDI_STATUS TDIStatus;

        switch (Status) {
        case IP_SUCCESS:
            TDIStatus = TDI_SUCCESS;
            break;
        case IP_PACKET_TOO_BIG:
            TDIStatus = TDI_BUFFER_TOO_BIG;
            break;
        default:
            TDIStatus = TDI_REQ_ABORTED;
            break;
        }

        (*Callback)(CallbackContext, TDIStatus, (uint)SentSize);
    }
}


//
// NT supports cancellation of DG send/receive requests.
//

VOID
TdiCancelSendDatagram(
    AddrObj *SrcAO,
    PVOID Context,
    PKSPIN_LOCK EndpointLock,
    KIRQL CancelIrql)
{
    KIRQL OldIrql;
    DGSendReq *sendReq = NULL;
    Queue *qentry;
    BOOLEAN found = FALSE;

    CHECK_STRUCT(SrcAO, ao);

    KeAcquireSpinLock(&SrcAO->ao_lock, &OldIrql);

    // Search the send list for the specified request.
    for (qentry = QNEXT(&(SrcAO->ao_sendq)); qentry != &(SrcAO->ao_sendq);
         qentry = QNEXT(qentry)) {

        sendReq = CONTAINING_RECORD(qentry, DGSendReq, dsr_q);

        CHECK_STRUCT(sendReq, dsr);

        if (sendReq->dsr_context == Context) {
            //
            // Found it.  Dequeue.
            //
            REMOVEQ(qentry);
            found = TRUE;

            IF_TCPDBG(TCP_DEBUG_SEND_DGRAM) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TdiCancelSendDatagram: Dequeued item %lx\n",
                           Context));
            }

            break;
        }
    }

    KeReleaseSpinLock(&SrcAO->ao_lock, OldIrql);
    KeReleaseSpinLock(EndpointLock, CancelIrql);

    if (found) {
        //
        // Complete the request and free its resources.
        //
        (*sendReq->dsr_rtn)(sendReq->dsr_context, (uint) TDI_CANCELLED, 0);

        KeAcquireSpinLock(&DGSendReqLock, &OldIrql);
        FreeDGSendReq(sendReq);
        KeReleaseSpinLock(&DGSendReqLock, OldIrql);
    }

} // TdiCancelSendDatagram


VOID
TdiCancelReceiveDatagram(
    AddrObj *SrcAO,
    PVOID Context,
    PKSPIN_LOCK EndpointLock,
    KIRQL CancelIrql)
{
    KIRQL OldIrql;
    DGRcvReq *rcvReq = NULL;
    Queue *qentry;
    BOOLEAN found = FALSE;

    CHECK_STRUCT(SrcAO, ao);

    KeAcquireSpinLock(&SrcAO->ao_lock, &OldIrql);

    // Search the send list for the specified request.
    for (qentry = QNEXT(&(SrcAO->ao_rcvq)); qentry != &(SrcAO->ao_rcvq);
         qentry = QNEXT(qentry)) {

        rcvReq = CONTAINING_RECORD(qentry, DGRcvReq, drr_q);

        CHECK_STRUCT(rcvReq, drr);

        if (rcvReq->drr_context == Context) {
            //
            // Found it.  Dequeue.
            //
            REMOVEQ(qentry);
            found = TRUE;

            IF_TCPDBG(TCP_DEBUG_SEND_DGRAM) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                           "TdiCancelReceiveDatagram: Dequeued item %lx\n",
                           Context));
            }

            break;
        }
    }

    KeReleaseSpinLock(&SrcAO->ao_lock, OldIrql);
    KeReleaseSpinLock(EndpointLock, CancelIrql);

    if (found) {
        //
        // Complete the request and free its resources.
        //
        (*rcvReq->drr_rtn)(rcvReq->drr_context, (uint) TDI_CANCELLED, 0);

        FreeDGRcvReq(rcvReq);
    }

} // TdiCancelReceiveDatagram


//* TdiSendDatagram - TDI send datagram function.
//
//  This is the user interface to the send datagram function.  The caller
//  specified a request structure, a connection info structure containing
//  the address, and data to be sent.  This routine gets a DG Send request
//  structure to manage the send, fills the structure in, and calls DGSend
//  to deal with it.
//
TDI_STATUS  // Returns: Status of attempt to send.
TdiSendDatagram(
    PTDI_REQUEST Request,                  // Request structure.
    PTDI_CONNECTION_INFORMATION ConnInfo,  // ConnInfo for remote address.
    uint DataSize,                         // Size in bytes of data to be sent.
    ULONG *BytesSent,                      // Return location for bytes sent.
    PNDIS_BUFFER Buffer)                   // Buffer chain to send.
{
    AddrObj *SrcAO;          // Pointer to AddrObj for src.
    DGSendReq *SendReq;      // Pointer to send req for this request.
    KIRQL Irql0, Irql1;      // One per lock nesting level.
    TDI_STATUS ReturnValue;
    DGSendProc SendProc;

    UNREFERENCED_PARAMETER(BytesSent);

    //
    // First, get a send request.  We do this first because of MP issues.
    // We need to take the SendRequest lock before we take the AddrObj lock,
    // to prevent deadlock and also because GetDGSendReq might yield, and
    // the state of the AddrObj might change on us, so we don't want to
    // yield after we've validated it.
    //
    KeAcquireSpinLock(&DGSendReqLock, &Irql0);
    SendReq = GetDGSendReq();

    //
    // Now get the lock on the AO, and make sure it's valid.  We do this
    // to make sure we return the correct error code.
    //
    SrcAO = Request->Handle.AddressHandle;
    CHECK_STRUCT(SrcAO, ao);
    KeAcquireSpinLock(&SrcAO->ao_lock, &Irql1);
    if (!AO_VALID(SrcAO)) {
        // The addr object is invalid, possibly because it's deleting.
        ReturnValue = TDI_ADDR_INVALID;
        goto Failure;
    }

    //
    // Make sure the requested amount of data to send is reasonable.
    //
    if (DataSize > SrcAO->ao_maxdgsize) {
        // Buffer is too big, return an error.
        ReturnValue = TDI_BUFFER_TOO_BIG;
        goto Failure;
    }

    //
    // Verify that we got a SendReq struct above.  We store the send
    // request in one of these so that we can queue it for later processing
    // in the event that something keeps us from sending it immediately.
    //
    if (SendReq == NULL) {
        // Send request was null, return no resources.
        ReturnValue = TDI_NO_RESOURCES;
        goto Failure;
    }

    //
    // Fill in our send request with the adddress, scope id, and port
    // number corresponding to the requested destination.
    //
    // REVIEW: TdiReceiveDatagram checks ConnInfo for validity,
    // REVIEW: while this code does not.  One of them is wrong.
    //
    if (!GetAddress(ConnInfo->RemoteAddress, &SendReq->dsr_addr,
                    &SendReq->dsr_scope_id, &SendReq->dsr_port)) {
        // The remote address was invalid.
        ReturnValue = TDI_BAD_ADDR;
        goto Failure;
    }

    //
    // Fill in the rest of our send request.
    //
    SendReq->dsr_rtn = Request->RequestNotifyObject;
    SendReq->dsr_context = Request->RequestContext;
    SendReq->dsr_buffer = Buffer;
    SendReq->dsr_size = (ushort)DataSize;

    //
    // We've filled in the send request.
    // We're either going to send it now, or queue it for later.
    // Check that the AO isn't out of resources or already busy.
    //
    if (AO_OOR(SrcAO)) {
        //
        // AO is currently out of resources.
        // Queue the send request for later.
        //
      QueueIt:
        ENQUEUE(&SrcAO->ao_sendq, &SendReq->dsr_q);
        SendReq = NULL;  // Don't let failure code below delete it.
        ReturnValue = TDI_PENDING;
        goto Failure;
    }
    if (AO_BUSY(SrcAO)) {
        // AO is busy, set request for later.
        SET_AO_REQUEST(SrcAO, AO_SEND);
        goto QueueIt;
    }

    //
    // All systems go for sending!
    //
    REF_AO(SrcAO);  // Lock out exclusive activities.
    SendProc = SrcAO->ao_dgsend;

    KeReleaseSpinLock(&SrcAO->ao_lock, Irql1);
    KeReleaseSpinLock(&DGSendReqLock, Irql0);

    // Allright, just send it.
    (*SendProc)(SrcAO, SendReq);

    //
    // Release our address object to process anything that might
    // have queued up in the meantime.
    //
    DEREF_AO(SrcAO);

    //
    // Done for now.
    // The send completion handler will finish the job.
    //
    return TDI_PENDING;

  Failure:
    KeReleaseSpinLock(&SrcAO->ao_lock, Irql1);

    if (SendReq != NULL)
        FreeDGSendReq(SendReq);

    KeReleaseSpinLock(&DGSendReqLock, Irql0);
    return ReturnValue;
}


//* TdiReceiveDatagram - TDI receive datagram function.
//
//  This is the user interface to the receive datagram function.  The
//  caller specifies a request structure, a connection info structure
//  that acts as a filter on acceptable datagrams, a connection info
//  structure to be filled in, and other parameters.  We get a DGRcvReq
//  structure, fill it in, and hang it on the AddrObj, where it will be
//  removed later by the incoming datagram handler.
//
TDI_STATUS  // Returns: Status of attempt to receive.
TdiReceiveDatagram(
    PTDI_REQUEST Request,
    PTDI_CONNECTION_INFORMATION ConnInfo,    // ConnInfo for remote address.
    PTDI_CONNECTION_INFORMATION ReturnInfo,  // ConnInfo to be filled in.
    uint RcvSize,                            // Total size in bytes of Buffer.
    uint *BytesRcvd,                         // Where to return bytes recv'd.
    PNDIS_BUFFER Buffer)                     // Buffer chain to fill in.
{
    AddrObj *RcvAO;          // AddrObj that is receiving.
    DGRcvReq *RcvReq;        // Receive request structure.
    KIRQL OldIrql;
    uchar AddrValid;

    UNREFERENCED_PARAMETER(BytesRcvd);

    RcvReq = GetDGRcvReq();
    RcvAO = Request->Handle.AddressHandle;
    CHECK_STRUCT(RcvAO, ao);

    KeAcquireSpinLock(&RcvAO->ao_lock, &OldIrql);
    if (AO_VALID(RcvAO)) {

        IF_TCPDBG(TCP_DEBUG_RAW) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                       "posting receive on AO %lx\n", RcvAO));
        }

        if (RcvReq != NULL) {
            if (ConnInfo != NULL && ConnInfo->RemoteAddressLength != 0) {
                AddrValid = GetAddress(ConnInfo->RemoteAddress,
                                       &RcvReq->drr_addr,
                                       &RcvReq->drr_scope_id,
                                       &RcvReq->drr_port);
            } else {
                AddrValid = TRUE;
                RcvReq->drr_addr = UnspecifiedAddr;
                RcvReq->drr_scope_id = 0;
                RcvReq->drr_port = 0;
            }

            if (AddrValid) {
                //
                // Everything is valid.
                // Fill in the receive request and queue it.
                //
                RcvReq->drr_conninfo = ReturnInfo;
                RcvReq->drr_rtn = Request->RequestNotifyObject;
                RcvReq->drr_context = Request->RequestContext;
                RcvReq->drr_buffer = Buffer;
                RcvReq->drr_size = (ushort)RcvSize;
                ENQUEUE(&RcvAO->ao_rcvq, &RcvReq->drr_q);
                KeReleaseSpinLock(&RcvAO->ao_lock, OldIrql);

                return TDI_PENDING;
            } else {
                // Have an invalid filter address.
                KeReleaseSpinLock(&RcvAO->ao_lock, OldIrql);
                FreeDGRcvReq(RcvReq);
                return TDI_BAD_ADDR;
            }
        } else {
            // Couldn't get a receive request.
            KeReleaseSpinLock(&RcvAO->ao_lock, OldIrql);
            return TDI_NO_RESOURCES;
        }
    } else {
        // The AddrObj isn't valid.
        KeReleaseSpinLock(&RcvAO->ao_lock, OldIrql);
    }

    // The AddrObj is invalid or non-existent.
    if (RcvReq != NULL)
        FreeDGRcvReq(RcvReq);

    return TDI_ADDR_INVALID;
}

//* DGFillIpv6PktInfo - Create an ancillary data object and fill in
//                      IPV6_PKTINFO information.
//
//  This is a helper function for the IPV6_PKTINFO socket option supported for
//  datagram sockets only. The caller provides the destination address as
//  specified in the IP header of the packet and the interface index of the
//  local interface the packet was delivered on. This routine will create the
//  proper ancillary data object and fill in the destination IP address
//  and the interface number of the local interface.
//
//  Input:  DestAddr        - Destination address from IP header of packet.
//          LocalInterface  - Index of local interface on which packet
//                               arrived.
//          CurrPosition    - Buffer that will be filled in with 
//                               the ancillary data object.
//
VOID
DGFillIpv6PktInfo(IPv6Addr UNALIGNED *DestAddr, uint LocalInterface, uchar **CurrPosition)
{
    PTDI_CMSGHDR CmsgHdr = (PTDI_CMSGHDR)*CurrPosition;
    IN6_PKTINFO *pktinfo = (IN6_PKTINFO*)TDI_CMSG_DATA(CmsgHdr);

    // Fill in the ancillary data object header information.
    TDI_INIT_CMSGHDR(CmsgHdr, IP_PROTOCOL_V6, IPV6_PKTINFO,
                     sizeof(IN6_PKTINFO));

    pktinfo->ipi6_addr = *DestAddr;
    pktinfo->ipi6_ifindex = LocalInterface;

    *CurrPosition += TDI_CMSG_SPACE(sizeof(IN6_PKTINFO));
}

//* DGFillIpv6HopLimit - Create an ancillary data object and fill in
//                       IPV6_HOPLIMIT information.
//
//  This is a helper function for the IPV6_HOPLIMIT socket option supported for
//  datagram sockets only. The caller provides the hop limit as
//  specified in the IP header of the packet. This routine will create the
//  proper ancillary data object and fill in the hop limit.
//
//  Input:  DestAddr        - Destination address from IP header of packet.
//          LocalInterface  - Index of local interface on which packet
//                               arrived.
//          CurrPosition    - Buffer that will be filled in with
//                               the ancillary data object.
//
VOID
DGFillIpv6HopLimit(int HopLimit, uchar **CurrPosition)
{
    PTDI_CMSGHDR CmsgHdr = (PTDI_CMSGHDR)*CurrPosition;
    int *hoplimit = (int*)TDI_CMSG_DATA(CmsgHdr);

    // Fill in the ancillary data object header information.
    TDI_INIT_CMSGHDR(CmsgHdr, IP_PROTOCOL_V6, IPV6_HOPLIMIT, sizeof(int));

    *hoplimit = HopLimit;

    *CurrPosition += TDI_CMSG_SPACE(sizeof(int));
}

#pragma BEGIN_INIT


//* InitDG - Initialize the DG stuff.
//
//  Called during init time to initalize the DG code.  We initialize
//  our locks and request lists.
//
int                      // Returns: True if we succeed, False if we fail.
InitDG(void)
{
    KeInitializeSpinLock(&DGSendReqLock);
    KeInitializeSpinLock(&DGRcvReqFreeLock);

    DGSendReqFree = NULL;
    ExInitializeSListHead(&DGRcvReqFree);

    INITQ(&DGPending);
    INITQ(&DGDelayed);

    //
    // Prepare a work-queue item which we may later enqueue for a system
    // worker thread to handle.  Here we associate our callback routine
    // (DGDelayedWorker) with the work item.
    //
    ExInitializeWorkItem(&DGDelayedWorkItem, DGDelayedWorker, NULL);

    return TRUE;
}

#pragma END_INIT

//* DGUnload
//
//  Cleanup and prepare the datagram module for stack unload.
//
void
DGUnload(void)
{
    DGSendReq *SendReq, *SendReqFree;
    PSLIST_ENTRY BufferLink;
    KIRQL OldIrql;

    KeAcquireSpinLock(&DGSendReqLock, &OldIrql);
    SendReqFree = DGSendReqFree;
    DGSendReqFree = NULL;
    KeReleaseSpinLock(&DGSendReqLock, OldIrql);

    while ((SendReq = SendReqFree) != NULL) {
        CHECK_STRUCT(SendReq, dsr);
        SendReqFree = (DGSendReq *)SendReq->dsr_q.q_next;
        ExFreePool(SendReq);
    }

    while ((BufferLink = ExInterlockedPopEntrySList(&DGRcvReqFree,
                                                    &DGRcvReqFreeLock))
                                                        != NULL) {
        Queue *QueuePtr = CONTAINING_RECORD(BufferLink, Queue, q_next);
        DGRcvReq *RcvReq = CONTAINING_RECORD(QueuePtr, DGRcvReq, drr_q);

        CHECK_STRUCT(RcvReq, drr);
        ExFreePool(RcvReq);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\udp\udp.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// User Datagram Protocol code.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "icmp.h"
#include "tdi.h"
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "udp.h"
#include "info.h"
#include "route.h"
#include "security.h"

//
// TDI_CMSG_SPACE generates the following warning.
//
#pragma warning(disable:4116) // unnamed type definition in parentheses

#define NO_TCP_DEFS 1
#include "tcpdeb.h"

//
// REVIEW: Shouldn't this be in an include file somewhere?
//
#ifdef POOL_TAGGING

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, '6PDU')

#endif // POOL_TAGGING


extern KSPIN_LOCK AddrObjTableLock;
extern TDI_STATUS MapIPError(IP_STATUS IPError,TDI_STATUS Default);


//* UDPSend - Send a user datagram.
//
//  The real send datagram routine.  We assume that the busy bit is
//  set on the input AddrObj, and that the address of the SendReq
//  has been verified.
//
//  We start by sending the input datagram, and we loop until there's
//  nothing left on the send queue.
//
void                     // Returns: Nothing.
UDPSend(
    AddrObj *SrcAO,      // Address Object of endpoint doing the send.
    DGSendReq *SendReq)  // Datagram send request describing the send.
{
    KIRQL Irql0;
    RouteCacheEntry *RCE;
    NetTableEntryOrInterface *NTEorIF;
    NetTableEntry *NTE;
    Interface *IF;
    IPv6Header UNALIGNED *IP;
    UDPHeader UNALIGNED *UDP;
    uint PayloadLength;
    PNDIS_PACKET Packet;
    PNDIS_BUFFER UDPBuffer;
    void *Memory;
    IP_STATUS Status;
    NDIS_STATUS NdisStatus;
    TDI_STATUS ErrorValue;
    uint Offset;
    uint HeaderLength;
    uint ChecksumLength = 0;
    int Hops;

    CHECK_STRUCT(SrcAO, ao);
    ASSERT(SrcAO->ao_usecnt != 0);

    //
    // Loop while we have something to send, and can get
    // the resources to send it.
    //
    for (;;) {

        CHECK_STRUCT(SendReq, dsr);

        //
        // Determine NTE to send on (if user cares).
        // We do this prior to allocating packet header buffers so
        // we know how much room to leave for the link-level header.
        //
        // REVIEW: We may need to add a DHCP case later that checks for
        // REVIEW: the AO_DHCP_FLAG and allows src addr to be unspecified.
        //
        if (!IsUnspecified(&SrcAO->ao_addr)) {
            //
            // Convert the bound address to a NTE.
            //
            NTE = FindNetworkWithAddress(&SrcAO->ao_addr, SrcAO->ao_scope_id);
            if (NTE == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                           "UDPSend: Bad source address\n"));
                ErrorValue = TDI_INVALID_REQUEST;
            ReturnError:
                //
                // If possible, complete the request with an error.
                // Free the request structure.
                //
                if (SendReq->dsr_rtn != NULL)
                    (*SendReq->dsr_rtn)(SendReq->dsr_context,
                                        ErrorValue, 0);
                KeAcquireSpinLock(&DGSendReqLock, &Irql0);
                FreeDGSendReq(SendReq);
                KeReleaseSpinLock(&DGSendReqLock, Irql0);
                goto SendComplete;
            }
        } else {
            //
            // We are not binding to any address.
            //
            NTE = NULL;
        }
        NTEorIF = CastFromNTE(NTE);
        //
        // If this is a multicast packet, check if the application
        // has specified an interface. Note that ao_mcast_if
        // overrides ao_addr if both are specified and they conflict.
        //
        if (IsMulticast(&SendReq->dsr_addr) && (SrcAO->ao_mcast_if != 0) &&
            ((NTE == NULL) || (NTE->IF->Index != SrcAO->ao_mcast_if))) {
            if (NTE != NULL) {
                ReleaseNTE(NTE);
                NTE = NULL;
            }
            IF = FindInterfaceFromIndex(SrcAO->ao_mcast_if);
            if (IF == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                        "UDPSend: Bad mcast interface number\n"));
                ErrorValue = TDI_INVALID_REQUEST;
                goto ReturnError;
            }
            NTEorIF = CastFromIF(IF);
        } else {
            IF = NULL;
        } 
        //
        // Get the route.
        //
        Status = RouteToDestination(&SendReq->dsr_addr, SendReq->dsr_scope_id,
                                    NTEorIF, RTD_FLAG_NORMAL, &RCE);
        if (IF != NULL)
            ReleaseIF(IF);
        if (Status != IP_SUCCESS) {
            //
            // Failed to get a route to the destination.  Error out.
            //
            if ((Status == IP_PARAMETER_PROBLEM) ||
                (Status == IP_BAD_ROUTE))
                ErrorValue = TDI_BAD_ADDR;
            else if (Status == IP_NO_RESOURCES)
                ErrorValue = TDI_NO_RESOURCES;
            else
                ErrorValue = TDI_DEST_UNREACHABLE;
            if (NTE != NULL)
                ReleaseNTE(NTE);
            goto ReturnError;
        }

        //
        // If our address object didn't have a source address,
        // take the one of the sending net from the RCE.
        // Otherwise, use address from AO.
        //
        if (NTE == NULL) {
            NTE = RCE->NTE;
            AddRefNTE(NTE);
        }

        //
        // Allocate a packet header to anchor the buffer list.
        //
        NdisAllocatePacket(&NdisStatus, &Packet, IPv6PacketPool);
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "UDPSend: Couldn't allocate packet header!?!\n"));
            //
            // If we can't get a packet header from the pool, we push
            // the send request back on the queue and queue the address
            // object for when we get resources.
            //
          OutOfResources:
            ReleaseRCE(RCE);
            ReleaseNTE(NTE);
            KeAcquireSpinLock(&SrcAO->ao_lock, &Irql0);
            PUSHQ(&SrcAO->ao_sendq, &SendReq->dsr_q);
            PutPendingQ(SrcAO);
            KeReleaseSpinLock(&SrcAO->ao_lock, Irql0);
            return;
        }

        InitializeNdisPacket(Packet);
        PC(Packet)->CompletionHandler = DGSendComplete;
        PC(Packet)->CompletionData = SendReq;

        //
        // Our header buffer has extra space at the beginning for other
        // headers to be prepended to ours without requiring further
        // allocation calls.
        //
        Offset = RCE->NCE->IF->LinkHeaderSize;
        HeaderLength = Offset + sizeof(*IP) + sizeof(*UDP);
        Memory = ExAllocatePool(NonPagedPool, HeaderLength);
        if (Memory == NULL) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "UDPSend: couldn't allocate header memory!?!\n"));
            NdisFreePacket(Packet);
            goto OutOfResources;
        }

        NdisAllocateBuffer(&NdisStatus, &UDPBuffer, IPv6BufferPool,
                           Memory, HeaderLength);
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "UDPSend: couldn't allocate buffer!?!\n"));
            ExFreePool(Memory);
            NdisFreePacket(Packet);
            goto OutOfResources;
        }

        //
        // Link the data buffers from the send request onto the buffer
        // chain headed by our header buffer.  Then attach this chain
        // to the packet.
        //
        NDIS_BUFFER_LINKAGE(UDPBuffer) = SendReq->dsr_buffer;
        NdisChainBufferAtFront(Packet, UDPBuffer);

        //
        // We now have all the resources we need to send.
        // Prepare the actual packet.
        //

        PayloadLength = SendReq->dsr_size + sizeof(UDPHeader);

        //
        // Our UDP Header buffer has extra space for other buffers to be
        // prepended to ours without requiring further allocation calls.
        // Put the actual UDP/IP header at the end of the buffer.
        //
        IP = (IPv6Header UNALIGNED *)((uchar *)Memory + Offset);
        IP->VersClassFlow = IP_VERSION;
        IP->NextHeader = IP_PROTOCOL_UDP;
        IP->Source = NTE->Address;
        IP->Dest = SendReq->dsr_addr;

        //
        // Apply the multicast or unicast hop limit, as appropriate.
        //
        if (IsMulticast(AlignAddr(&IP->Dest))) {
            //
            // Also disable multicast loopback, if requested.
            //
            if (! SrcAO->ao_mcast_loop)
                PC(Packet)->Flags |= NDIS_FLAGS_DONT_LOOPBACK;
            Hops = SrcAO->ao_mcast_hops;
        }
        else
            Hops = SrcAO->ao_ucast_hops;
        if (Hops != -1)
            IP->HopLimit = (uchar) Hops;
        else
            IP->HopLimit = (uchar) RCE->NCE->IF->CurHopLimit;

        //
        // Fill in UDP Header fields.
        //
        UDP = (UDPHeader UNALIGNED *)(IP + 1);
        UDP->Source = SrcAO->ao_port;
        UDP->Dest = SendReq->dsr_port;

        //
        // Check if the user specified a partial UDP checksum.
        // The possible values are 0, 8, or greater.
        //
        if ((SrcAO->ao_udp_cksum_cover > PayloadLength) ||
            (SrcAO->ao_udp_cksum_cover == 0) ||
            (SrcAO->ao_udp_cksum_cover == (ushort)-1)) {

            //
            // The checksum coverage is the default so just use the
            // payload length.  Or, the checksum coverage is bigger
            // than the actual payload so include the payload length.
            //
            if ((PayloadLength > MAX_IPv6_PAYLOAD) ||
                (SrcAO->ao_udp_cksum_cover == (ushort)-1)) {
                //
                // If the PayloadLength is too large for the UDP Length field,
                // set the field to zero. Or for testing:
                // if the ao_udp_cksum_cover is -1.
                //
                UDP->Length = 0;
            } else {
                //
                // For backwards-compatibility, set the UDP Length field
                // to the payload length.
                //
                UDP->Length = net_short((ushort)PayloadLength);
            }
            ChecksumLength = PayloadLength;
        } else {
            //
            // The checksum coverage is less than the actual payload
            // so use it in the length field.
            //
            UDP->Length = net_short(SrcAO->ao_udp_cksum_cover);
            ChecksumLength = SrcAO->ao_udp_cksum_cover;
        }

        //
        // Compute the UDP checksum.  It covers the entire UDP datagram
        // starting with the UDP header, plus the IPv6 pseudo-header.
        //
        UDP->Checksum = 0;
        UDP->Checksum = ChecksumPacket(
            Packet, Offset + sizeof *IP, NULL, ChecksumLength,
            AlignAddr(&IP->Source), AlignAddr(&IP->Dest), IP_PROTOCOL_UDP);

        if (UDP->Checksum == 0) {
            //
            // ChecksumPacket failed, so abort the transmission.
            //
            IPv6SendComplete(NULL, Packet, IP_NO_RESOURCES);
        }
        else {
            //
            // Allow the AO to receive data when in firewall mode.
            //
            SET_AO_SENTDATA(SrcAO);

            //
            // Everything's ready.  Now send the packet.
            //
            // Note that IPv6Send does not return a status code.
            // Instead it *always* completes the packet
            // with an appropriate status code.
            //
            UStats.us_outdatagrams++;

            IPv6Send(Packet, Offset, IP, PayloadLength, RCE, 0,
                     IP_PROTOCOL_UDP,
                     net_short(UDP->Source),
                     net_short(UDP->Dest));
        }

        //
        // Release the route and NTE.
        //
        ReleaseRCE(RCE);
        ReleaseNTE(NTE);


      SendComplete:

        //
        // Check the send queue for more to send.
        //
        KeAcquireSpinLock(&SrcAO->ao_lock, &Irql0);
        if (!EMPTYQ(&SrcAO->ao_sendq)) {
            //
            // More to go.  Dequeue next request and loop back to top.
            //
            DEQUEUE(&SrcAO->ao_sendq, SendReq, DGSendReq, dsr_q);
            KeReleaseSpinLock(&SrcAO->ao_lock, Irql0);
        } else {
            //
            // Nothing more to send.
            //
            CLEAR_AO_REQUEST(SrcAO, AO_SEND);
            KeReleaseSpinLock(&SrcAO->ao_lock, Irql0);
            return;
        }
    }
}


//* UDPDeliver - Deliver a datagram to a user.
//
//  This routine delivers a datagram to a UDP user.  We're called with
//  the AddrObj to deliver on, and with the lock for that AddrObj held.
//  We try to find a receive on the specified AddrObj, and if we do
//  we remove it and copy the data into the buffer.  Otherwise we'll
//  call the receive datagram event handler, if there is one.  If that
//  fails we'll discard the datagram.
//
void  // Returns: Nothing.
UDPDeliver(
    AddrObj *RcvAO,             // AddrObj to receive datagram.
    IPv6Packet *Packet,         // Packet handed up by IP.
    uint SrcScopeId,            // Scope id for source address.
    ushort SrcPort,             // Source port of datagram.
    uint Length,                // Size of UDP payload data.
    KIRQL Irql0)                // IRQL prior to acquiring AddrObj table lock.
{
    Queue *CurrentQ;
    DGRcvReq *RcvReq;
    ULONG BytesTaken = 0;
    uchar AddressBuffer[TCP_TA_SIZE];
    uint RcvdSize;
    EventRcvBuffer *ERB = NULL;
    uint Position = Packet->Position;

    CHECK_STRUCT(RcvAO, ao);

    if (AO_VALID(RcvAO)) {
        CurrentQ = QHEAD(&RcvAO->ao_rcvq);

        // Walk the list, looking for a receive buffer that matches.
        while (CurrentQ != QEND(&RcvAO->ao_rcvq)) {
            RcvReq = QSTRUCT(DGRcvReq, CurrentQ, drr_q);

            CHECK_STRUCT(RcvReq, drr);

            //
            // If this request is a wildcard request, or matches the source IP
            // address and scope id, check the port.
            //
            if (IsUnspecified(&RcvReq->drr_addr) ||
                (IP6_ADDR_EQUAL(&RcvReq->drr_addr, Packet->SrcAddr) &&
                 (RcvReq->drr_scope_id == SrcScopeId))) {

                //
                // The remote address matches, check the port.
                // We'll match either 0 or the actual port.
                //
                if (RcvReq->drr_port == 0 || RcvReq->drr_port == SrcPort) {
                    TDI_STATUS Status;

                    // The ports matched. Remove this from the queue.
                    REMOVEQ(&RcvReq->drr_q);

                    // We're done. We can free the AddrObj lock now.
                    KeReleaseSpinLock(&RcvAO->ao_lock, Irql0);

                    // Copy the data, and then complete the request.
                    RcvdSize = CopyToBufferChain(RcvReq->drr_buffer, 0,
                                                 Packet->NdisPacket,
                                                 Position,
                                                 Packet->FlatData,
                                                 MIN(Length,
                                                     RcvReq->drr_size));

                    ASSERT(RcvdSize <= RcvReq->drr_size);

                    Status = UpdateConnInfo(RcvReq->drr_conninfo,
                                            Packet->SrcAddr, SrcScopeId,
                                            SrcPort);

                    UStats.us_indatagrams++;

                    (*RcvReq->drr_rtn)(RcvReq->drr_context, Status, RcvdSize);

                    FreeDGRcvReq(RcvReq);

                    return;  // All done.
                }
            }

            //
            // Either the IP address or the port didn't match.
            // Get the next one.
            //
            CurrentQ = QNEXT(CurrentQ);
        }

        //
        // We've walked the list, and not found a buffer.
        // Call the receive handler now, if we have one.
        //
        if (RcvAO->ao_rcvdg != NULL) {
            PRcvDGEvent RcvEvent = RcvAO->ao_rcvdg;
            PVOID RcvContext = RcvAO->ao_rcvdgcontext;
            TDI_STATUS RcvStatus;
            ULONG Flags = TDI_RECEIVE_COPY_LOOKAHEAD;
            int BufferSize = 0;
            PVOID BufferToSend = NULL;
            uchar *CurrPosition;

            REF_AO(RcvAO);
            KeReleaseSpinLock(&RcvAO->ao_lock, Irql0);

            BuildTDIAddress(AddressBuffer, Packet->SrcAddr, SrcScopeId,
                            SrcPort);

            UStats.us_indatagrams++;

            if (IsMulticast(AlignAddr(&Packet->IP->Dest))) {
                Flags |= TDI_RECEIVE_MULTICAST;
            }

            // If the IPV6_PKTINFO or IPV6_HOPLIMIT options were set, then 
            // create the control information to be passed to the handler.  
            // Currently this is the only place such options are filled in,
            // so we just have one buffer. If other places are added in the 
            // future, we may want to support a list or array of buffers to 
            // copy into the user's buffer.
            //
            if (AO_PKTINFO(RcvAO)) {
                BufferSize += TDI_CMSG_SPACE(sizeof(IN6_PKTINFO));
            }
            if (AO_RCV_HOPLIMIT(RcvAO)) {
                BufferSize += TDI_CMSG_SPACE(sizeof(int));
            }
            if (BufferSize > 0) {
                CurrPosition = BufferToSend = ExAllocatePool(NonPagedPool, 
                                                             BufferSize);
                if (BufferToSend == NULL) {
                    BufferSize = 0;
                } else {
                    if (AO_PKTINFO(RcvAO)) {
                        DGFillIpv6PktInfo(&Packet->IP->Dest,
                                          Packet->NTEorIF->IF->Index,
                                          &CurrPosition);
    
                        // Set the receive flag so the receive handler knows
                        // we are passing up control info.
                        //
                        Flags |= TDI_RECEIVE_CONTROL_INFO;
                    }
    
                    if (AO_RCV_HOPLIMIT(RcvAO)) {
                        DGFillIpv6HopLimit(Packet->IP->HopLimit, &CurrPosition);
    
                        Flags |= TDI_RECEIVE_CONTROL_INFO;
                    }
                }
            }

            RcvStatus  = (*RcvEvent)(RcvContext, TCP_TA_SIZE,
                                     (PTRANSPORT_ADDRESS)AddressBuffer,
                                     BufferSize, BufferToSend, Flags,
                                     Packet->ContigSize, Length, &BytesTaken,
                                     Packet->Data, &ERB);

            if (BufferToSend) {
                ExFreePool(BufferToSend);
            }

            if (RcvStatus == TDI_MORE_PROCESSING) {
                PIO_STACK_LOCATION IrpSp;
                PTDI_REQUEST_KERNEL_RECEIVEDG DatagramInformation;

                ASSERT(ERB != NULL);
                ASSERT(BytesTaken <= Packet->ContigSize);

                //
                // For NT, ERBs are really IRPs.
                //
                IrpSp = IoGetCurrentIrpStackLocation(ERB);
                DatagramInformation = (PTDI_REQUEST_KERNEL_RECEIVEDG)
                    &(IrpSp->Parameters);

                //
                // Copy data to the IRP, skipping the bytes
                // that were already taken.
                //
                Position += BytesTaken;
                Length -= BytesTaken;
                RcvdSize = CopyToBufferChain(ERB->MdlAddress, 0,
                                             Packet->NdisPacket,
                                             Position,
                                             Packet->FlatData,
                                             Length);

                //
                // Update the return address info.
                //
                RcvStatus = UpdateConnInfo(
                    DatagramInformation->ReturnDatagramInformation,
                    Packet->SrcAddr, SrcScopeId, SrcPort);

                //
                // Complete the IRP.
                //
                ERB->IoStatus.Information = RcvdSize;
                ERB->IoStatus.Status = RcvStatus;
                IoCompleteRequest(ERB, 2);
            } else {
                ASSERT((RcvStatus == TDI_SUCCESS) ||
                       (RcvStatus == TDI_NOT_ACCEPTED));
                ASSERT(ERB == NULL);
            }

            DELAY_DEREF_AO(RcvAO);

            return;

        } else
            UStats.us_inerrors++;

        //
        // When we get here, we didn't have a buffer to put this data into.
        // Fall through to the return case.
        //
    } else
        UStats.us_inerrors++;

    KeReleaseSpinLock(&RcvAO->ao_lock, Irql0);
}


//* UDPReceive - Receive a UDP datagram.
//
//  The routine called by IP when a UDP datagram arrived.  We look up the
//  port/local address pair in our address table, and deliver the data to
//  a user if we find one.  For multicast frames we may deliver it to
//  multiple users.
//
//  Returns the next header value.  Since no other header is allowed to
//  follow the UDP header, this is always IP_PROTOCOL_NONE.
//
uchar
UDPReceive(
    IPv6Packet *Packet)         // Packet IP handed up to us.
{
    Interface *IF = Packet->NTEorIF->IF;
    UDPHeader *UDP;
    KIRQL OldIrql;
    AddrObj *ReceivingAO;
    uint Length;
    ushort Checksum;
    AOMCastAddr *AMA, *PrevAMA;
    int MCastReceiverFound;
    uint SrcScopeId, DestScopeId;
    uint Loop;

    //
    // Verify that the source address is reasonable.
    //
    ASSERT(!IsInvalidSourceAddress(Packet->SrcAddr));
    if (IsUnspecified(Packet->SrcAddr)) {
        UStats.us_inerrors++;
        return IP_PROTOCOL_NONE;  // Drop packet.
    }

    //
    // Verify that we have enough contiguous data to overlay a UDPHeader
    // structure on the incoming packet.  Then do so.
    //
    if (! PacketPullup(Packet, sizeof(UDPHeader),
                       __builtin_alignof(UDPHeader), 0)) {
        // Pullup failed.
        UStats.us_inerrors++;
        if (Packet->TotalSize < sizeof(UDPHeader)) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "UDPv6: data buffer too small to contain UDP header\n"));
            ICMPv6SendError(Packet,
                            ICMPv6_PARAMETER_PROBLEM,
                            ICMPv6_ERRONEOUS_HEADER_FIELD,
                            FIELD_OFFSET(IPv6Header, PayloadLength),
                            IP_PROTOCOL_NONE, FALSE);
        }
        return IP_PROTOCOL_NONE;  // Drop packet.
    }
    UDP = (UDPHeader *)Packet->Data;

    //
    // Verify IPSec was performed.
    //
    if (InboundSecurityCheck(Packet, IP_PROTOCOL_UDP, net_short(UDP->Source),
                             net_short(UDP->Dest), IF) != TRUE) {
        //
        // No policy was found or the policy found was to drop the packet.
        //
        UStats.us_inerrors++;
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "UDPReceive: IPSec Policy caused packet to be dropped\n"));
        return IP_PROTOCOL_NONE;  // Drop packet.
    }

    //
    // Verify UDP length is reasonable.
    //
    // NB: If Length < PayloadLength, then UDP-Lite semantics apply.
    // We checksum only the UDP Length bytes, but we deliver
    // all the bytes to the application.
    //
    Length = (uint) net_short(UDP->Length);
    if ((Length > Packet->TotalSize) || (Length < sizeof *UDP)) {
        //
        // UDP jumbo-gram support: if the UDP length is zero,
        // then use the payload length from IP.
        //
        if (Length != 0) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                       "UDPv6: bogus UDP length (%u vs %u payload)\n",
                       Length, Packet->TotalSize));
            UStats.us_inerrors++;
            return IP_PROTOCOL_NONE;  // Drop packet.
        }

        Length = Packet->TotalSize;
    }

    //
    // Set the source's scope id value as appropriate.
    //
    SrcScopeId = DetermineScopeId(Packet->SrcAddr, IF);

    //
    // At this point, we've decided it's okay to accept the packet.
    // Figure out who to give it to.
    //
    if (IsMulticast(AlignAddr(&Packet->IP->Dest))) {
        //
        // This is a multicast packet, so we need to find all interested
        // AddrObj's.  We get the AddrObjTable lock, and then loop through
        // all AddrObj's and give the packet to any who are listening to
        // this multicast address, interface & port.
        // REVIEW: We match on interface, NOT scope id.  Multicast is weird.
        //
        KeAcquireSpinLock(&AddrObjTableLock, &OldIrql);

        MCastReceiverFound = FALSE;
        for (Loop = 0; Loop < AddrObjTableSize; Loop++) {
            for (ReceivingAO = AddrObjTable[Loop]; ReceivingAO != NULL;
                 ReceivingAO = ReceivingAO->ao_next) {

                CHECK_STRUCT(ReceivingAO, ao);

                if (ReceivingAO->ao_prot != IP_PROTOCOL_UDP ||
                    ReceivingAO->ao_port != UDP->Dest)
                    continue;

                if ((AMA = FindAOMCastAddr(ReceivingAO,
                                           AlignAddr(&Packet->IP->Dest),
                                           IF->Index, &PrevAMA,
                                           FALSE)) == NULL)
                    continue;

                //
                // We have a matching address object.  Trade in the table lock
                // for a lock on just this object.
                //
                KeAcquireSpinLockAtDpcLevel(&ReceivingAO->ao_lock);
                KeReleaseSpinLockFromDpcLevel(&AddrObjTableLock);

                //
                // If this is the first AO we've found, verify the checksum.
                //
                if (!MCastReceiverFound) {
                    Checksum = ChecksumPacket(Packet->NdisPacket,
                                              Packet->Position,
                                              Packet->FlatData,
                                              Length,
                                              Packet->SrcAddr,
                                              AlignAddr(&Packet->IP->Dest),
                                              IP_PROTOCOL_UDP);
                    if ((Checksum != 0xffff) || (UDP->Checksum == 0)) {
                        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                                   "UDPReceive: Checksum failed %0x\n",
                                   Checksum));
                        KeReleaseSpinLock(&ReceivingAO->ao_lock, OldIrql);
                        UStats.us_inerrors++;
                        return IP_PROTOCOL_NONE;  // Drop packet.
                    }

                    //
                    // Skip over the UDP header.
                    //
                    AdjustPacketParams(Packet, sizeof(UDPHeader));

                    MCastReceiverFound = TRUE;
                }

                UDPDeliver(ReceivingAO, Packet, SrcScopeId, UDP->Source,
                           Packet->TotalSize, OldIrql);

                //
                // UDPDeliver released the lock on the address object.
                // We earlier released the AddrObjTableLock, so grab it again.
                //
                KeAcquireSpinLock(&AddrObjTableLock, &OldIrql);
            }
        }

        if (!MCastReceiverFound)
            UStats.us_noports++;

        KeReleaseSpinLock(&AddrObjTableLock, OldIrql);

    } else {
        //
        // This is a unicast packet.  We need to perform the checksum
        // regardless of whether or not we find a matching AddrObj,
        // since we send an ICMP port unreachable message for unicast
        // packets that don't match a port.  So verify the checksum now.
        //
        Checksum = ChecksumPacket(Packet->NdisPacket, Packet->Position,
                                  Packet->FlatData, Length, Packet->SrcAddr,
                                  AlignAddr(&Packet->IP->Dest),
                                  IP_PROTOCOL_UDP);
        if ((Checksum != 0xffff) || (UDP->Checksum == 0)) {
            UStats.us_inerrors++;
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "UDPReceive: Checksum failed %0x\n", Checksum));
            return IP_PROTOCOL_NONE;  // Drop packet.
        }

        //
        // Skip over the UDP header.
        //
        AdjustPacketParams(Packet, sizeof(UDPHeader));

        //
        // Try to find an AddrObj to give this packet to.
        //
        DestScopeId = DetermineScopeId(AlignAddr(&Packet->IP->Dest), IF);
        KeAcquireSpinLock(&AddrObjTableLock, &OldIrql);
        ReceivingAO = GetBestAddrObj(AlignAddr(&Packet->IP->Dest),
                                     Packet->SrcAddr,
                                     DestScopeId, UDP->Dest,
                                     IP_PROTOCOL_UDP, IF);
        if (ReceivingAO != NULL) {
            //
            // We have a matching address object.  Trade in the table lock
            // for a lock on just this object, and then deliver the packet.
            //
            KeAcquireSpinLockAtDpcLevel(&ReceivingAO->ao_lock);
            KeReleaseSpinLockFromDpcLevel(&AddrObjTableLock);

            UDPDeliver(ReceivingAO, Packet, SrcScopeId, UDP->Source,
                       Packet->TotalSize, OldIrql);

            // Note UDPDeliver released the lock on the address object.

        } else {
            KeReleaseSpinLock(&AddrObjTableLock, OldIrql);

            // Send ICMP Destination Port Unreachable.
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                       "UDPReceive: No match for packet's address and port\n"));

            ICMPv6SendError(Packet,
                            ICMPv6_DESTINATION_UNREACHABLE,
                            ICMPv6_PORT_UNREACHABLE, 0,
                            IP_PROTOCOL_NONE, FALSE);

            UStats.us_noports++;
        }
    }

    return IP_PROTOCOL_NONE;
}


//* UDPControlReceive - handler for UDP control messages.
//
//  This routine is called if we receive an ICMPv6 error message that
//  was generated by some remote site as a result of receiving a UDP
//  packet from us.
//
uchar
UDPControlReceive(
    IPv6Packet *Packet,  // Packet handed to us by ICMPv6ErrorReceive.
    StatusArg *StatArg)  // Error Code, Argument, and invoking IP header.
{
    UDPHeader *InvokingUDP;
    Interface *IF = Packet->NTEorIF->IF;
    uint SrcScopeId, DestScopeId;
    KIRQL Irql0;
    AddrObj *AO;

    //
    // Handle ICMPv6 errors that are meaningful to UDP clients.
    //

    switch (StatArg->Status) {

    case IP_DEST_ADDR_UNREACHABLE:
    case IP_DEST_PORT_UNREACHABLE:
    case IP_DEST_UNREACHABLE:

        //
        // The next thing in the packet should be the UDP header of the
        // original packet which invoked this error.
        //

        if (! PacketPullup(Packet, sizeof(UDPHeader),
                           __builtin_alignof(UDPHeader), 0)) {
            // Pullup failed.
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_BAD_PACKET,
                      "UDPv6: Packet too small to contain UDP header "
                      "from invoking packet\n"));
            return IP_PROTOCOL_NONE;  // Drop packet.
        }

        InvokingUDP = (UDPHeader *)Packet->Data;

        //
        // Determining the scope identifiers for the addreses in the
        // invoking packet is potentially problematic, since we have
        // no way to be certain which interface we sent the packet on.
        // Use the interface the icmp error arrived on to determine
        // the scope ids for both the local and remote addresses.
        //
        SrcScopeId = DetermineScopeId(AlignAddr(&StatArg->IP->Source), IF);

        KeAcquireSpinLock(&AddrObjTableLock, &Irql0);

        AO = GetBestAddrObj(AlignAddr(&StatArg->IP->Source), 
                            AlignAddr(&StatArg->IP->Dest), SrcScopeId,
                            InvokingUDP->Source, IP_PROTOCOL_UDP, IF);

        if (AO != NULL && AO_VALID(AO) && (AO->ao_errorex != NULL)) {

            uchar AddressBuffer[TCP_TA_SIZE];
            PVOID ErrContext = AO->ao_errorexcontext;
            PTDI_IND_ERROR_EX ErrEvent = AO->ao_errorex;;

            KeAcquireSpinLockAtDpcLevel(&AO->ao_lock);
            KeReleaseSpinLockFromDpcLevel(&AddrObjTableLock);
            REF_AO(AO);

            KeReleaseSpinLock(&AO->ao_lock, Irql0);

            DestScopeId = DetermineScopeId(AlignAddr(&StatArg->IP->Dest), IF);
            BuildTDIAddress(AddressBuffer, AlignAddr(&StatArg->IP->Dest),
                            DestScopeId, InvokingUDP->Dest);
            (*ErrEvent) (ErrContext,
                         MapIPError(StatArg->Status, TDI_DEST_UNREACHABLE),
                         AddressBuffer);

            DELAY_DEREF_AO(AO);

        } else {
            KeReleaseSpinLock(&AddrObjTableLock, Irql0);
        }

    }

    return IP_PROTOCOL_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\udp\raw.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// Raw IP interface code.  This file contains the code for the raw IP
// interface functions, principally send and receive datagram.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include "tdistat.h"
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "raw.h"
#include "info.h"
#include "route.h"
#include "security.h"

//
// TDI_CMSG_SPACE generates the following warning.
//
#pragma warning(disable:4116) // unnamed type definition in parentheses

#define NO_TCP_DEFS 1
#include "tcpdeb.h"

//
// REVIEW: Shouldn't this be in an include file somewhere?
//
#ifdef POOL_TAGGING

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, '6WAR')

#endif // POOL_TAGGING


extern KSPIN_LOCK AddrObjTableLock;



//* RawSend - Send a raw datagram.
//
//  The real send datagram routine.  We assume that the busy bit is
//  set on the input AddrObj, and that the address of the SendReq
//  has been verified.
//
//  We start by sending the input datagram, and we loop until there's
//  nothing left on the send queue.
//
void                     // Returns: Nothing.
RawSend(
    AddrObj *SrcAO,      // Address Object of endpoint doing the send.
    DGSendReq *SendReq)  // Datagram send request describing the send.
{
    KIRQL Irql0;
    RouteCacheEntry *RCE;
    NetTableEntryOrInterface *NTEorIF;
    NetTableEntry *NTE;
    Interface *IF;
    IPv6Header UNALIGNED *IP;
    PNDIS_PACKET Packet;
    PNDIS_BUFFER RawBuffer;
    void *Memory = NULL;
    IP_STATUS Status;
    NDIS_STATUS NdisStatus;
    TDI_STATUS ErrorValue;
    uint Offset;
    uint HeaderLength;
    int Hops;

    CHECK_STRUCT(SrcAO, ao);
    ASSERT(SrcAO->ao_usecnt != 0);

    //
    // Loop while we have something to send, and can get
    // the resources to send it.
    //
    for (;;) {

        CHECK_STRUCT(SendReq, dsr);

        //
        // Determine NTE to send on (if user cares).
        // We do this prior to allocating packet header buffers so
        // we know how much room to leave for the link-level header.
        //
        if (!IsUnspecified(&SrcAO->ao_addr)) {
            //
            // We need to get the NTE of this bound address.
            //
            NTE = FindNetworkWithAddress(&SrcAO->ao_addr, SrcAO->ao_scope_id);
            if (NTE == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                           "RawSend: Bad source address\n"));
                ErrorValue = TDI_INVALID_REQUEST;
            ReturnError:
                //
                // If possible, complete the request with an error.
                // Free the request structure.
                //
                if (SendReq->dsr_rtn != NULL)
                    (*SendReq->dsr_rtn)(SendReq->dsr_context,
                                        ErrorValue, 0);
                KeAcquireSpinLock(&DGSendReqLock, &Irql0);
                FreeDGSendReq(SendReq);
                KeReleaseSpinLock(&DGSendReqLock, Irql0);
                goto SendComplete;
            }
        } else {
            //
            // We are not binding to any address.
            //
            NTE = NULL;
        }
        NTEorIF = CastFromNTE(NTE);
        //
        // If this is a multicast packet, check if the application
        // has specified an interface. Note that ao_mcast_if
        // overrides ao_addr if both are specified and they conflict.
        // 
        if (IsMulticast(&SendReq->dsr_addr) && (SrcAO->ao_mcast_if != 0) &&
            ((NTE == NULL) || (NTE->IF->Index != SrcAO->ao_mcast_if))) {
            if (NTE != NULL) {
                ReleaseNTE(NTE);
                NTE = NULL;
            }
            IF = FindInterfaceFromIndex(SrcAO->ao_mcast_if);
            if (IF == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_USER_ERROR,
                        "RawSend: Bad mcast interface number\n"));
                ErrorValue = TDI_INVALID_REQUEST;
                goto ReturnError;
            }
            NTEorIF = CastFromIF(IF);
        } else {
            IF = NULL;
        }
        //
        // Get the route.
        //
        Status = RouteToDestination(&SendReq->dsr_addr, SendReq->dsr_scope_id,
                                    NTEorIF, RTD_FLAG_NORMAL, &RCE);
        if (IF != NULL)
            ReleaseIF(IF);
        if (Status != IP_SUCCESS) {
            //
            // Failed to get a route to the destination.  Error out.
            //
            if ((Status == IP_PARAMETER_PROBLEM) ||
                (Status == IP_BAD_ROUTE))
                ErrorValue = TDI_BAD_ADDR;
            else if (Status == IP_NO_RESOURCES)
                ErrorValue = TDI_NO_RESOURCES;
            else
                ErrorValue = TDI_DEST_UNREACHABLE;
            if (NTE != NULL)
                ReleaseNTE(NTE);
            goto ReturnError;
        }

        //
        // If our address object didn't have a source address,
        // take the one of the sending net from the RCE.
        // Otherwise, use address from AO.
        //
        if (NTE == NULL) {
            NTE = RCE->NTE;
            AddRefNTE(NTE);
        }

        //
        // Allocate a packet header to anchor the buffer list.
        //
        NdisAllocatePacket(&NdisStatus, &Packet, IPv6PacketPool);
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "RawSend: Couldn't allocate packet header!?!\n"));
            //
            // If we can't get a packet header from the pool, we push
            // the send request back on the queue and queue the address
            // object for when we get resources.
            //
          OutOfResources:
            ReleaseRCE(RCE);
            ReleaseNTE(NTE);
            KeAcquireSpinLock(&SrcAO->ao_lock, &Irql0);
            PUSHQ(&SrcAO->ao_sendq, &SendReq->dsr_q);
            PutPendingQ(SrcAO);
            KeReleaseSpinLock(&SrcAO->ao_lock, Irql0);
            return;
        }

        InitializeNdisPacket(Packet);
        PC(Packet)->CompletionHandler = DGSendComplete;
        PC(Packet)->CompletionData = SendReq;

        //
        // Create our header buffer.
        // It will contain the link-level header and possibly the
        // IPv6 header.  The user has the option of contributing
        // the IPv6 header, otherwise we generate it below.
        //
        Offset = HeaderLength = RCE->NCE->IF->LinkHeaderSize;
        if (!AO_HDRINCL(SrcAO))
            HeaderLength += sizeof(*IP);
        if (HeaderLength > 0) {
            Memory = ExAllocatePool(NonPagedPool, HeaderLength);
            if (Memory == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "RawSend: couldn't allocate header memory!?!\n"));
                NdisFreePacket(Packet);
                goto OutOfResources;
            }
    
            NdisAllocateBuffer(&NdisStatus, &RawBuffer, IPv6BufferPool,
                               Memory, HeaderLength);
            if (NdisStatus != NDIS_STATUS_SUCCESS) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "RawSend: couldn't allocate buffer!?!\n"));
                ExFreePool(Memory);
                NdisFreePacket(Packet);
                goto OutOfResources;
            }
    
            //
            // Link the data buffers from the send request onto the buffer
            // chain headed by our header buffer.  Then attach this chain
            // to the packet.
            //
            NDIS_BUFFER_LINKAGE(RawBuffer) = SendReq->dsr_buffer;
            NdisChainBufferAtFront(Packet, RawBuffer);
        }
        else
            NdisChainBufferAtFront(Packet, SendReq->dsr_buffer);

        //
        // We now have all the resources we need to send.
        // Prepare the actual packet.
        //

        if (!AO_HDRINCL(SrcAO)) {
            //
            // We can not allow the user to supply extension headers.
            // IPv6Send assumes that any extension headers are
            // syntactically correct and resident in the first buffer.
            // Currently TCPCreate prevents the user from opening raw
            // sockets with extension header protocols.
            //
            ASSERT(!IsExtensionHeader(SrcAO->ao_prot));

            //
            // We need to provide the IPv6 header.
            // Place it after the link-layer header.
            //
            IP = (IPv6Header UNALIGNED *)((uchar *)Memory + Offset);
            IP->VersClassFlow = IP_VERSION;
            IP->NextHeader = SrcAO->ao_prot;
            IP->Source = NTE->Address;
            IP->Dest = SendReq->dsr_addr;

            //
            // Apply the multicast or unicast hop limit, as appropriate.
            //
            if (IsMulticast(AlignAddr(&IP->Dest))) {
                //
                // Also disable multicast loopback, if requested.
                //
                if (! SrcAO->ao_mcast_loop)
                    PC(Packet)->Flags |= NDIS_FLAGS_DONT_LOOPBACK;
                Hops = SrcAO->ao_mcast_hops;
            }
            else
                Hops = SrcAO->ao_ucast_hops;
            if (Hops != -1)
                IP->HopLimit = (uchar) Hops;
            else
                IP->HopLimit = (uchar) RCE->NCE->IF->CurHopLimit;
            
            //
            // Allow the AO to receive data when in firewall mode.
            //
            SET_AO_SENTDATA(SrcAO);

            //
            // Everything's ready.  Now send the packet.
            //
            // Note that IPv6Send does not return a status code.
            // Instead it *always* completes the packet
            // with an appropriate status code.
            //
            IPv6Send(Packet, Offset, IP, SendReq->dsr_size, RCE, 0,
                     SrcAO->ao_prot, 0, 0);
        }
        else {
            //
            // Our header buffer contains only the link-level header.
            // The IPv6 header and any extension headers are expected to
            // be provided by the user. In some cases the kernel
            // will attempt to access the IPv6 header so we must
            // ensure that the mappings exist now.
            //
            if (! MapNdisBuffers(NdisFirstBuffer(Packet))) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "RawSend(%p): buffer mapping failed\n",
                           Packet));
                IPv6SendComplete(NULL, Packet, IP_GENERAL_FAILURE);
            }
            else {
                //
                // Everything's ready.  Now send the packet.
                //
                IPv6SendND(Packet, HeaderLength,
                           RCE->NCE, &(RCE->NTE->Address));
            }
        }

        UStats.us_outdatagrams++;

        //
        // Release the route.
        //
        ReleaseRCE(RCE);
        ReleaseNTE(NTE);

    SendComplete:

        //
        // Check the send queue for more to send.
        //
        KeAcquireSpinLock(&SrcAO->ao_lock, &Irql0);
        if (!EMPTYQ(&SrcAO->ao_sendq)) {
            //
            // More to go.  Dequeue next request and loop back to top.
            //
            DEQUEUE(&SrcAO->ao_sendq, SendReq, DGSendReq, dsr_q);
            KeReleaseSpinLock(&SrcAO->ao_lock, Irql0);
        } else {
            //
            // Nothing more to send.
            //
            CLEAR_AO_REQUEST(SrcAO, AO_SEND);
            KeReleaseSpinLock(&SrcAO->ao_lock, Irql0);
            return;
        }
    }
}


//* RawDeliver - Deliver a datagram to a user.
//
//  This routine delivers a datagram to a raw user.  We're called with
//  the AddrObj to deliver on, and with the AddrObjTable lock held.
//  We try to find a receive on the specified AddrObj, and if we do
//  we remove it and copy the data into the buffer.  Otherwise we'll
//  call the receive datagram event handler, if there is one.  If that
//  fails we'll discard the datagram.
//
void  // Returns: Nothing.
RawDeliver(
    AddrObj *RcvAO,             // Address object to receive the datagram.
    IPv6Packet *Packet,         // Packet handed up by IP.
    uint SrcScopeId,            // Scope id for source address.
    KIRQL Irql0)                // IRQL prior to acquiring AddrObj table lock.
{
    Queue *CurrentQ;
    KIRQL Irql1;
    DGRcvReq *RcvReq;
    ULONG BytesTaken = 0;
    uchar AddressBuffer[TCP_TA_SIZE];
    uint RcvdSize;
    EventRcvBuffer *ERB = NULL;
    uint Position = Packet->Position;
    uint Length = Packet->TotalSize;

    CHECK_STRUCT(RcvAO, ao);

    KeAcquireSpinLock(&RcvAO->ao_lock, &Irql1);
    KeReleaseSpinLock(&AddrObjTableLock, Irql1);

    if (AO_VALID(RcvAO)) {
        CurrentQ = QHEAD(&RcvAO->ao_rcvq);

        // Walk the list, looking for a receive buffer that matches.
        while (CurrentQ != QEND(&RcvAO->ao_rcvq)) {
            RcvReq = QSTRUCT(DGRcvReq, CurrentQ, drr_q);

            CHECK_STRUCT(RcvReq, drr);

            //
            // If this request is a wildcard request (accept from anywhere),
            // or matches the source IP address and scope id, deliver it.
            //
            if (IsUnspecified(&RcvReq->drr_addr) ||
                (IP6_ADDR_EQUAL(&RcvReq->drr_addr, Packet->SrcAddr) &&
                 (RcvReq->drr_scope_id == SrcScopeId))) {

                TDI_STATUS Status;

                // Remove this from the queue.
                REMOVEQ(&RcvReq->drr_q);

                // We're done. We can free the AddrObj lock now.
                KeReleaseSpinLock(&RcvAO->ao_lock, Irql0);

                // Copy the data, and then complete the request.
                RcvdSize = CopyToBufferChain(RcvReq->drr_buffer, 0,
                                             Packet->NdisPacket,
                                             Position,
                                             Packet->FlatData,
                                             MIN(Length, RcvReq->drr_size));

                ASSERT(RcvdSize <= RcvReq->drr_size);

                Status = UpdateConnInfo(RcvReq->drr_conninfo, Packet->SrcAddr,
                                        SrcScopeId, 0);

                UStats.us_indatagrams++;

                (*RcvReq->drr_rtn)(RcvReq->drr_context, Status, RcvdSize);

                FreeDGRcvReq(RcvReq);

                return;  // All done.
            }

            // Not a matching request.  Get the next one off the queue.
            CurrentQ = QNEXT(CurrentQ);
        }

        //
        // We've walked the list, and not found a buffer.
        // Call the receive handler now, if we have one.
        //
        if (RcvAO->ao_rcvdg != NULL) {
            PRcvDGEvent RcvEvent = RcvAO->ao_rcvdg;
            PVOID RcvContext = RcvAO->ao_rcvdgcontext;
            TDI_STATUS RcvStatus;
            ULONG Flags = TDI_RECEIVE_COPY_LOOKAHEAD;
            int BufferSize = 0;
            PVOID BufferToSend = NULL;
            uchar *CurrPosition;

            REF_AO(RcvAO);
            KeReleaseSpinLock(&RcvAO->ao_lock, Irql0);

            BuildTDIAddress(AddressBuffer, Packet->SrcAddr, SrcScopeId, 0);

            UStats.us_indatagrams++;

            if (IsMulticast(AlignAddr(&Packet->IP->Dest))) {
                Flags |= TDI_RECEIVE_MULTICAST;
            }

            // If the IPV6_PKTINFO or IPV6_HOPLIMIT options were set, then
            // create the control information to be passed to the handler.
            // Currently this is the only place such options are filled in,
            // so we just have one buffer. If other places are added in the
            // future, we may want to support a list or array of buffers to
            // copy into the user's buffer.
            //
            if (AO_PKTINFO(RcvAO)) {
                BufferSize += TDI_CMSG_SPACE(sizeof(IN6_PKTINFO));
            }
            if (AO_RCV_HOPLIMIT(RcvAO)) {
                BufferSize += TDI_CMSG_SPACE(sizeof(int));
            }
            if (BufferSize > 0) {
                CurrPosition = BufferToSend = ExAllocatePool(NonPagedPool,
                                                             BufferSize);
                if (BufferToSend == NULL) {
                    BufferSize = 0;
                } else {
                    if (AO_PKTINFO(RcvAO)) {
                        DGFillIpv6PktInfo(&Packet->IP->Dest,
                                          Packet->NTEorIF->IF->Index,
                                          &CurrPosition);
    
                        // Set the receive flag so the receive handler knows
                        // we are passing up control info.
                        //
                        Flags |= TDI_RECEIVE_CONTROL_INFO;
                    }
    
                    if (AO_RCV_HOPLIMIT(RcvAO)) {
                        DGFillIpv6HopLimit(Packet->IP->HopLimit, &CurrPosition);
    
                        Flags |= TDI_RECEIVE_CONTROL_INFO;
                    }
                }
            }

            RcvStatus  = (*RcvEvent)(RcvContext, TCP_TA_SIZE,
                                     (PTRANSPORT_ADDRESS)AddressBuffer,
                                     BufferSize, BufferToSend, Flags,
                                     Packet->ContigSize, Length, &BytesTaken,
                                     Packet->Data, &ERB);

            if (BufferToSend) {
                ExFreePool(BufferToSend);
            }

            if (RcvStatus == TDI_MORE_PROCESSING) {
                PIO_STACK_LOCATION IrpSp;
                PTDI_REQUEST_KERNEL_RECEIVEDG DatagramInformation;

                //
                // We were passed back a receive buffer.  Copy the data in now.
                // Receive event handler can't have taken more than was in the
                // indicated buffer, but in debug builds we'll check this.
                //
                ASSERT(ERB != NULL);
                ASSERT(BytesTaken <= Packet->ContigSize);

                //
                // For NT, ERBs are really IRPs.
                //
                IrpSp = IoGetCurrentIrpStackLocation(ERB);
                DatagramInformation = (PTDI_REQUEST_KERNEL_RECEIVEDG)
                    &(IrpSp->Parameters);

                //
                // Copy data to the IRP, skipping the bytes
                // that were already taken.
                //
                Position += BytesTaken;
                Length -= BytesTaken;
                RcvdSize = CopyToBufferChain(ERB->MdlAddress, 0,
                                             Packet->NdisPacket,
                                             Position,
                                             Packet->FlatData,
                                             Length);

                //
                // Update the return address info.
                //
                RcvStatus = UpdateConnInfo(
                    DatagramInformation->ReturnDatagramInformation,
                    Packet->SrcAddr, SrcScopeId, 0);

                //
                // Complete the IRP.
                //
                ERB->IoStatus.Information = RcvdSize;
                ERB->IoStatus.Status = RcvStatus;
                IoCompleteRequest(ERB, 2);

            } else {
                ASSERT((RcvStatus == TDI_SUCCESS) ||
                       (RcvStatus == TDI_NOT_ACCEPTED));
                ASSERT(ERB == NULL);
            }

            DELAY_DEREF_AO(RcvAO);

            return;

        } else
            UStats.us_inerrors++;

        //
        // When we get here, we didn't have a buffer to put this data into.
        // Fall through to the return case.
        //

    } else
        UStats.us_inerrors++;

    KeReleaseSpinLock(&RcvAO->ao_lock, Irql0);
}


//* RawReceive - Receive a Raw datagram.
//
//  This routine is called by IP when a Raw datagram arrives.  We
//  lookup the protocol/address pair in our address table, and deliver
//  the data to any users we find.
//
//  Note that we'll only get here if all headers in the packet
//  preceeding the one we're filtering on were acceptable.
//
//  We return TRUE if we find a receiver to take the packet, FALSE otherwise.
//
int
RawReceive(
    IPv6Packet *Packet,  // Packet IP handed up to us.
    uchar Protocol)      // Protocol we think we're handling.
{
    Interface *IF = Packet->NTEorIF->IF;
    KIRQL OldIrql;
    AddrObj *ReceivingAO;
    AOSearchContext Search;
    AOMCastAddr *AMA, *PrevAMA;
    int ReceiverFound = FALSE;
    uint SrcScopeId, DestScopeId;
    uint Loop;

    //
    // This being the raw receive routine, we perform no checks on
    // the packet data.
    //

    //
    // Verify IPSec was performed.
    //
    if (InboundSecurityCheck(Packet, Protocol, 0, 0, IF) != TRUE) {
        //
        // No policy was found or the policy found was to drop the packet.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NET_ERROR,
                   "RawReceive: IPSec Policy caused packet to be refused\n"));
        return FALSE;  // Drop packet.
    }

    //
    // Set the source's scope id value as appropriate.
    //
    SrcScopeId = DetermineScopeId(Packet->SrcAddr, IF);

    //
    // At this point, we've decided it's okay to accept the packet.
    // Figure out who to give this packet to.
    //
    if (IsMulticast(AlignAddr(&Packet->IP->Dest))) {
        //
        // This is a multicast packet, so we need to find all interested
        // AddrObj's.  We get the AddrObjTable lock, and then loop through
        // all AddrObj's and give the packet to any who are listening to
        // this multicast address, interface & protocol.
        // REVIEW: We match on interface, NOT scope id.  Multicast is weird.
        //
        KeAcquireSpinLock(&AddrObjTableLock, &OldIrql);

        for (Loop = 0; Loop < AddrObjTableSize; Loop++) {
            for (ReceivingAO = AddrObjTable[Loop]; ReceivingAO != NULL;
                 ReceivingAO = ReceivingAO->ao_next) {

                CHECK_STRUCT(ReceivingAO, ao);

                if (ReceivingAO->ao_prot != Protocol)
                    continue;

                if ((AMA = FindAOMCastAddr(ReceivingAO,
                                           AlignAddr(&Packet->IP->Dest),
                                           IF->Index, &PrevAMA,
                                           FALSE)) == NULL)
                    continue;

                //
                // We have a matching address object.  Hand it the packet.
                //
                RawDeliver(ReceivingAO, Packet, SrcScopeId, OldIrql);

                //
                // RawDeliver released the AddrObjTableLock, so grab it again.
                //
                KeAcquireSpinLock(&AddrObjTableLock, &OldIrql);
                ReceiverFound = TRUE;
            }
        }

    } else {
        //
        // This is a unicast packet.  Try to find some AddrObj(s) to
        // give it to.  We deliver to all matches, not just the first.
        //
        DestScopeId = DetermineScopeId(AlignAddr(&Packet->IP->Dest), IF);
        KeAcquireSpinLock(&AddrObjTableLock, &OldIrql);
        ReceivingAO = GetFirstAddrObj(AlignAddr(&Packet->IP->Dest),
                                      Packet->SrcAddr,
                                      DestScopeId, 0,
                                      Protocol, IF, &Search);
        for (; ReceivingAO != NULL; ReceivingAO = GetNextAddrObj(&Search)) {
            //
            // We have a matching address object.  Hand it the packet.
            //
            RawDeliver(ReceivingAO, Packet, SrcScopeId, OldIrql);

            //
            // RawDeliver released the AddrObjTableLock, so grab it again.
            //
            KeAcquireSpinLock(&AddrObjTableLock, &OldIrql);
            ReceiverFound = TRUE;
        }
    }

    KeReleaseSpinLock(&AddrObjTableLock, OldIrql);

    return ReceiverFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\udp\init.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// User Datagram Protocol initialization code.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include "tdistat.h"
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "udp.h"
#include "info.h"

//* UDPInit - Initialize the User Datagram Protocol.
//
//  Initialize UDP and raw IP.
//
int
UDPInit(void)
{
    //
    // First initialize the underlying datagram processing code
    // that both UDP and raw IP depend upon.
    //
    if (!InitDG())
        return FALSE;

    //
    // Clear UDP statistics.
    //
    RtlZeroMemory(&UStats, sizeof(UDPStats));

    //
    // Register our UDP protocol handler with the IP layer.
    //
    IPv6RegisterULProtocol(IP_PROTOCOL_UDP, UDPReceive, UDPControlReceive);

    return TRUE;
}

//* UDPUnload
//
//  Cleanup and prepare UDP and raw IP for stack unload.
//
void
UDPUnload(void)
{
    DGUnload();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\ttcp\ttcp.c ===
/*
 * TTCP
 *
 * Test TCP connection.  Makes a connection on port 5001
 * and transfers fabricated buffers or data copied from stdin.
 *
 * Usable on 4.2, 4.3, and 4.1a systems by defining one of
 * BSD42 BSD43 (BSD41a)
 * Machines using System V with BSD sockets should define SYSV.
 *
 * Modified for operation under 4.2BSD, 18 Dec 84
 *      T.C. Slattery, USNA
 * Minor improvements, Mike Muuss and Terry Slattery, 16-Oct-85.
 * Modified in 1989 at Silicon Graphics, Inc.
 *      catch SIGPIPE to be able to print stats when receiver has died
 *      for tcp, don't look for sentinel during reads to allow small transfers
 *      increased default buffer size to 8K, nbuf to 2K to transfer 16MB
 *      moved default port to 5001, beyond IPPORT_USERRESERVED
 *      make sinkmode default because it is more popular,
 *              -s now means don't sink/source
 *      count number of _read/_write system calls to see effects of
 *              blocking from full socket buffers
 *      for tcp, -D option turns off buffered writes (sets SO_NODELAY sockopt)
 *      buffer alignment options, -A and -O
 *      print stats in a format that's a bit easier to use with grep & awk
 *      for SYSV, mimic BSD routines to use most of the existing timing code
 *
 * Distribution Status -
 *      Public Domain.  Distribution Unlimited.
 */

#define BSD43
/* #define BSD42 */
/* #define BSD41a */
#if defined(sgi) || defined(CRAY)
#define SYSV
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <signal.h>
#include <ctype.h>
#include <sys/types.h>

#include <winsock2.h>
#include <ws2tcpip.h>
#include <ws2ip6.h>
#include <wspiapi.h>
#include <mswsock.h>

//
// Localization library and MessageIds.
//
#include <nls.h>
#include <winnlsp.h>
#include "localmsg.h"

#if defined(SYSV)
#include <sys/times.h>
#include <sys/param.h>
struct rusage {
    struct timeval ru_utime, ru_stime;
};
#define RUSAGE_SELF 0
#else
#endif

u_short prot; // 0 (don't care), PF_INET, PF_INET6

struct sockaddr_storage sinsrcStorage;
struct sockaddr *sinsrc = (struct sockaddr *)&sinsrcStorage;
struct sockaddr_storage sinmeStorage;
struct sockaddr *sinme = (struct sockaddr *)&sinmeStorage;
struct sockaddr_storage sinhimStorage;
struct sockaddr *sinhim = (struct sockaddr *)&sinhimStorage;
DWORD tmpbuf;

struct addrinfo *aihim;

SOCKET fd;                      /* fd of network socket */
SOCKET fd2;                     /* fd of accepted connection */

int buflen = 8 * 1024;          /* length of buffer */
char *buf;                      /* ptr to dynamic buffer */
int nbuf = 2 * 1024;            /* number of buffers to send in sinkmode */

int bufoffset = 0;              /* align buffer to this */
int bufalign = 16*1024;         /* modulo this */

int udp = 0;                    /* 0 = tcp, !0 = udp */
int udpcoverage = 0;            /* UDP Lite checksum coverage */
int options = 0;                /* socket options */
int one = 1;                    /* for 4.3 BSD style setsockopt() */
short port = 5001;              /* TCP port number */
char *host;                     /* ptr to name of host */
int trans;                      /* 0=receive, !0=transmit mode */
int sinkmode = 1;               /* 0=normal I/O, !0=sink/source mode */
int verbose = 0;                /* 0=print basic info, 1=print cpu rate, proc
                                 * resource usage. */
int nodelay = 0;                /* set TCP_NODELAY socket option */
int b_flag = 0;                 /* use mread() */
int write_delay = 0;            /* milliseconds of delay before each write */
int hops = -1;                  /* hop limit */

int udp_connect = 0;            /* connect UDP sockets */

#define SOBUF_DEFAULT -1
int sobuf = SOBUF_DEFAULT;      /* SO_RCVBUF/SO_SNDBUF setting; 0 == default */
int async = 0;                  /* async vs. synchronous io calls. value == */
                                /* number of simultaneous async calls. */
int connecttest = 0;

char *filename = NULL;
HANDLE filehandle;

WSADATA WsaData;

char stats[128];
unsigned long nbytes;           /* bytes on net */
unsigned long numCalls;         /* # of I/O system calls */

int Nread( SOCKET fd, PBYTE buf, INT count );
int mread( SOCKET fd, PBYTE bufp, INT n);
int Nwrite( SOCKET fd, PBYTE buf, INT count );

void err(unsigned int message);
void pattern(char *cp, int cnt );

void prep_timer();
double read_timer(char *s, int l);
//double cput, realt;             /* user, real time (seconds) */
DWORD realt;

typedef struct _TTCP_ASYNC_INFO {
    PVOID Buffer;
    DWORD BytesWritten;
    OVERLAPPED Overlapped;
} TTCP_ASYNC_INFO, *PTTCP_ASYNC_INFO;

void
sigpipe()
{
}

int parse_addr(char *s, struct sockaddr *sa);
char *format_addr(struct sockaddr *sa);
void set_port(struct sockaddr *sa, u_short port);
u_short get_port(struct sockaddr *sa);
u_int addr_len(struct sockaddr *sa);

void __cdecl
main(argc,argv)
int argc;
char **argv;
{
        char *Term;
        struct in_addr IPv4Group;
        struct in6_addr IPv6Group;
        int error;
        int i;
        BOOL ret;

        //
        // This will ensure the correct language message is displayed when
        // NlsPutMsg is called.
        //
        SetThreadUILanguage(0);

        error = WSAStartup(MAKEWORD(2, 0), &WsaData );
        if ( error == SOCKET_ERROR ) {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_0, WSAGetLastError());
// printf("ttcp: WSAStartup failed %ld:", WSAGetLastError());

        }

        if (argc < 2) goto usage;

        for (i = 1; i < argc; i++) {

                if ((argv[i][0] != '-') &&
                    (argv[i][0] != '/'))
                    break;

                switch (argv[i][1]) {

                case 'B':
                        b_flag = 1;
                        break;
                case 't':
                        trans = 1;
                        break;
                case 'f':
                        trans = 1;
                        filename = &argv[i][2];
                        break;
                case 'r':
                        trans = 0;
                        break;
                case 'd':
                        options |= SO_DEBUG;
                        break;
                case 'D':
                        nodelay = 1;
                        break;
                case 'n':
                        nbuf = atoi(&argv[i][2]);
                        break;
                case 'l':
                        buflen = atoi(&argv[i][2]);
                        break;
                case 'h':
                        sobuf = atoi(&argv[i][2]);
                        break;
                case 'H':
                        hops = atoi(&argv[i][2]);
                        break;
                case 's':
                        sinkmode = 0;   /* sink/source data */
                        break;
                case 'p':
                        port = (short) atoi(&argv[i][2]);
                        break;
                case 'u':
                        udp = 1;
                        connecttest = 0;
                        if (argv[i][2] == '\0')
                            udpcoverage = 0;
                        else
                            udpcoverage = atoi(&argv[i][2]);
                        break;
                case 'v':
                        verbose = 1;
                        break;
                case 'A':
                        bufalign = atoi(&argv[i][2]);
                        break;
                case 'O':
                        bufoffset = atoi(&argv[i][2]);
                        break;
                case 'c':
                        udp_connect = 1;
                        break;
                case 'a':
                        if (argv[i][2] == '\0') {
                            async = 3;
                        } else {
                            async = atoi(&argv[i][2]);
                        }
                        break;
                case 'C':
                        connecttest = 1;
                        udp = 0;
                        break;
                case 'S':
                    if (!parse_addr(&argv[i][2], sinsrc))
                        err(TTCP_MESSAGE_31); // "bad source address"
                    break;
                case 'w':
                    if (argv[i][2] == '\0')
                        goto usage;
                    write_delay = atoi(&argv[i][2]);
                    break;
                case 'P':
                    if (argv[i][2] == '4')
                        prot = PF_INET;
                    else if (argv[i][2] == '6')
                        prot = PF_INET6;
                    else
                        goto usage;
                    break;
                case 'j':
                    trans = 0;
                    udp = 1;

                    // Figure out if this is an IPv4 or IPv6 group.
                    if (NT_SUCCESS(RtlIpv6StringToAddressA(&argv[i][2],
                                                           &Term,
                                                           &IPv6Group))) {
                        // We should use IPv6.
                        if (prot == 0)
                            prot = PF_INET6;
                        else if (prot != PF_INET6)
                            goto usage;
                    }
                    else if (NT_SUCCESS(RtlIpv4StringToAddressA(&argv[i][2],
                                                                TRUE,
                                                                &Term,
                                                                &IPv4Group))) {
                        // We should use IPv4.
                        if (prot == 0)
                            prot = PF_INET;
                        else if (prot != PF_INET)
                            goto usage;
                    }
                    else
                        goto usage;

                    // Sanity-check the interface index, if present.
                    if (*Term == '\0')
                        ; // No interface index.
                    else if (*Term == '/') {
                        if (atoi(Term+1) == 0)
                            goto usage;
                    } else
                        goto usage;
                    break;

                default:
                    goto usage;
                }
        }

        if (filename != NULL) {
            filehandle = CreateFile(
                             filename,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL
                             );
            if ( filehandle == INVALID_HANDLE_VALUE ) {
                NlsPutMsg(STDOUT, TTCP_MESSAGE_1, filename, GetLastError());
// printf("failed to open file %s: %ld\n", filename, GetLastError( ) );

                exit(1);
            }
            NlsPutMsg(STDOUT, TTCP_MESSAGE_2, filename );
// printf("ttcp-t: opened file %s\n", filename );

        }

        if ((async != 0) && trans && (sobuf == SOBUF_DEFAULT)) {
            sobuf = 0;
            NlsPutMsg(STDOUT, TTCP_MESSAGE_3);
// printf("ttcp-t: for async write, setting SO_SNDBUF to 0.\n");

        }

        if (udp && !trans && (sobuf == SOBUF_DEFAULT))
            sobuf = 65536;

        if (connecttest) {
            INT zero = 0;

            // ??? What is this?
            // disable socket sharing in the process
            setsockopt((SOCKET)NULL, SOL_SOCKET, 0x8002, (char *)&zero, 4);
        }

        if (trans) {
            /* xmitr */
            struct addrinfo hints;

            if (i + 1 != argc) goto usage;
            host = argv[i];

            memset(&hints, 0, sizeof hints);
            hints.ai_flags = AI_NUMERICHOST;
            hints.ai_family = prot;

            if (getaddrinfo(host, NULL, &hints, &aihim) != 0) {
                struct addrinfo *aitmp;

                hints.ai_flags = AI_CANONNAME;

                if (getaddrinfo(host, NULL, &hints, &aihim) != 0)
                    err(TTCP_MESSAGE_32); // "getaddrinfo"

                for (aitmp = aihim; aitmp != NULL; aitmp = aitmp->ai_next)
                    NlsPutMsg(STDOUT, TTCP_MESSAGE_4,
                              aihim->ai_canonname,
                              format_addr(aitmp->ai_addr));
// printf("ttcp-t: %s -> %s\n",
//        aihim->ai_canonname,
//        format_addr(aitmp->ai_addr));

            }

          retry:
            if (aihim == NULL)
                err(TTCP_MESSAGE_54); // "connect"
            memcpy(sinhim, aihim->ai_addr, aihim->ai_addrlen);
            aihim = aihim->ai_next;

            memcpy(sinme, sinsrc, sizeof(struct sockaddr_storage));
            if (sinme->sa_family == 0) {
                // Use same family as destination.
                sinme->sa_family = sinhim->sa_family;
            } else {
                // Source and destination family should be the same.
                // Let connect() check for this.
            }
            set_port(sinhim, htons(port));
            set_port(sinme, 0); // free choice
        } else {
            /* rcvr */
            if (i != argc) goto usage;

            memcpy(sinme, sinsrc, sizeof(struct sockaddr_storage));
            if (sinme->sa_family == 0)
                sinme->sa_family = prot;
            set_port(sinme, htons(port));
        }

        //
        // Create the socket and prepare it for the test.
        //

        if (trans) {
            fd = socket(sinme->sa_family, udp?SOCK_DGRAM:SOCK_STREAM, 0);
            if (fd == SOCKET_ERROR)
                err(TTCP_MESSAGE_48); // "socket"

            if (bind(fd, sinme, addr_len(sinme)) < 0)
                err(TTCP_MESSAGE_33); // "bind"

            if (options) {
#if defined(BSD42)
                if (setsockopt(fd, SOL_SOCKET, options, 0, 0) < 0)
#else // BSD43
                if (setsockopt(fd, SOL_SOCKET, options,
                               (char *)&one, sizeof(one)) < 0)
#endif
                    err(TTCP_MESSAGE_50); // "setsockopt"
            }

            if (!udp && nodelay) {
                if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY,
                               (char *)&one, sizeof(one)) < 0)
                    err(TTCP_MESSAGE_34); // "setsockopt: nodelay"
            }

            if (udp && udpcoverage) {
                if (setsockopt(fd, IPPROTO_UDP, UDP_CHECKSUM_COVERAGE,
                               (char *)&udpcoverage, sizeof(udpcoverage)) < 0)
                    err(TTCP_MESSAGE_35); // "setsockopt: udp checksum coverage"
            }

            if (sobuf != SOBUF_DEFAULT) {
                if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF,
                               (char *)&sobuf, sizeof(sobuf)) < 0)
                    err(TTCP_MESSAGE_36); // "setsockopt: SO_SNDBUF"
            }

            if (hops != -1) {
                switch (sinme->sa_family) {
                case AF_INET:
                    if (setsockopt(fd, IPPROTO_IP, IP_TTL,
                                   (char *)&hops, sizeof(hops)) < 0)
                        err(TTCP_MESSAGE_37); // "setsockopt: IP_TTL"
                    if (udp) {
                        if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,
                                       (char *)&hops, sizeof(hops)) < 0)
                            err(TTCP_MESSAGE_38); // "setsockopt: IP_MULTICAST_TTL"
                    }
                    break;

                case AF_INET6:
                    if (setsockopt(fd, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
                                   (char *)&hops, sizeof(hops)) < 0)
                        err(TTCP_MESSAGE_39); // "setsockopt: IPV6_UNICAST_HOPS"
                    if (udp) {
                        if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
                                       (char *)&hops, sizeof(hops)) < 0)
                            err(TTCP_MESSAGE_40); // "setsockopt: IPV6_MULTICAST_HOPS"
                    }
                    break;
                }
            }

            if (!udp || udp_connect) {
                if (connect(fd, sinhim, addr_len(sinhim)) < 0)
                    goto retry;

                tmpbuf = sizeof(struct sockaddr_storage);
                if (getpeername(fd, (struct sockaddr *)sinhim, &tmpbuf) < 0)
                    err(TTCP_MESSAGE_41); // "getpeername"
            }

            tmpbuf = sizeof(struct sockaddr_storage);
            if (getsockname(fd, (struct sockaddr *)sinme, &tmpbuf) < 0)
                err(TTCP_MESSAGE_42); // "getsockname"

        } else { // if not (trans)
            if (sinme->sa_family == 0) {
                SOCKET fd4, fd6;
                fd_set fdset;
                int numsockets;
                struct sockaddr_in sin;
                struct sockaddr_in6 sin6;

                //
                // We do not know apriori whether to use IPv4 or IPv6.
                // So we create two sockets and listen on both.
                // socket() will fail if the protocol is not installed,
                // and bind() will fail if the stack is stopped,
                // so we allow for those errors.
                //

                FD_ZERO(&fdset);
                numsockets = 0;

                fd4 = socket(AF_INET, udp?SOCK_DGRAM:SOCK_STREAM, 0);
                if (fd4 != INVALID_SOCKET) {

                    memset(&sin, 0, sizeof sin);
                    sin.sin_family = AF_INET;
                    sin.sin_port = get_port(sinme);
                    if (bind(fd4, (struct sockaddr *)&sin, sizeof sin) == 0) {

                        if (!udp) {
                            if (hops != -1) {
                                if (setsockopt(fd4, IPPROTO_IP, IP_TTL,
                                        (char *)&hops, sizeof(hops)) < 0)
                                    err(TTCP_MESSAGE_37); // "setsockopt: IP_TTL"
                            }

                            if (listen(fd4, 0) < 0)
                                err(TTCP_MESSAGE_44); // "listen"
                        }

                        numsockets++;
                        FD_SET(fd4, &fdset);
                    }
                }

                fd6 = socket(AF_INET6, udp?SOCK_DGRAM:SOCK_STREAM, 0);
                if (fd6 != INVALID_SOCKET) {

                    memset(&sin6, 0, sizeof sin6);
                    sin6.sin6_family = AF_INET6;
                    sin6.sin6_port = get_port(sinme);
                    if (bind(fd6, (struct sockaddr *)&sin6, sizeof sin6) == 0) {

                        if (!udp) {
                            if (hops != -1) {
                                if (setsockopt(fd6, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
                                        (char *)&hops, sizeof(hops)) < 0)
                                    err(TTCP_MESSAGE_39); // "setsockopt: IPV6_UNICAST_HOPS"
                            }

                            if (listen(fd6, 0) < 0)
                                err(TTCP_MESSAGE_44); // "listen"
                        }

                        numsockets++;
                        FD_SET(fd6, &fdset);
                    }
                }

                if (numsockets == 0)
                    err(TTCP_MESSAGE_48); // "socket"

                if (select(numsockets, &fdset, NULL, NULL, NULL) != 1)
                    err(TTCP_MESSAGE_47); // "select"

                if ((fd4 != INVALID_SOCKET) && FD_ISSET(fd4, &fdset)) {
                    fd = fd4;
                    if (fd6 != INVALID_SOCKET)
                        closesocket(fd6);
                    memcpy(sinme, &sin, sizeof sin);
                }
                else if ((fd6 != INVALID_SOCKET) && FD_ISSET(fd6, &fdset)) {
                    fd = fd6;
                    if (fd4 != INVALID_SOCKET)
                        closesocket(fd4);
                    memcpy(sinme, &sin6, sizeof sin6);
                }
                else {
                    NlsPutMsg(STDOUT, TTCP_MESSAGE_5);
// printf("select() bug\n");

                    exit(1);
                }
            } else { // if not (sinme->sa_family == 0)
                fd = socket(sinme->sa_family, udp?SOCK_DGRAM:SOCK_STREAM, 0);
                if (fd == SOCKET_ERROR)
                    err(TTCP_MESSAGE_48); // "socket"

                if (bind(fd, sinme, addr_len(sinme)) < 0)
                    err(TTCP_MESSAGE_33); // "bind"

                if (!udp) {
                    if (hops != -1) {
                        switch (sinme->sa_family) {
                        case AF_INET:
                            if (setsockopt(fd, IPPROTO_IP, IP_TTL,
                                    (char *)&hops, sizeof(hops)) < 0)
                                err(TTCP_MESSAGE_43); // "setsockopt: IP_TTL"
                            break;
                        case AF_INET6:
                            if (setsockopt(fd, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
                                    (char *)&hops, sizeof(hops)) < 0)
                                err(TTCP_MESSAGE_39); // "setsockopt: IPV6_UNICAST_HOPS"
                            break;
                        }
                    }

                    if (listen(fd, 0) < 0)   /* allow a queue of 0 */
                        err(TTCP_MESSAGE_44); // "listen"
                }
            } // end if (sinme->sa_family == 0)

            if (options) {
#if defined(BSD42)
                if (setsockopt(fd, SOL_SOCKET, options, 0, 0) < 0)
#else // BSD43
                if (setsockopt(fd, SOL_SOCKET, options,
                               (char *)&one, sizeof(one)) < 0)
#endif
                    err(TTCP_MESSAGE_50); // "setsockopt"
            }

            if (sobuf != SOBUF_DEFAULT) {
                if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF,
                               (char *)&sobuf, sizeof(sobuf)) < 0)
                    err(TTCP_MESSAGE_51); // "setsockopt: SO_RCVBUF"
            }

            if (!udp) {
                tmpbuf = sizeof(struct sockaddr_storage);
                fd2 = accept(fd, (struct sockaddr *)sinhim, &tmpbuf);
                if (fd2 == SOCKET_ERROR)
                    err(TTCP_MESSAGE_52); // "accept"

                tmpbuf = sizeof(struct sockaddr_storage);
                if (getsockname(fd2, (struct sockaddr *)sinme, &tmpbuf) < 0)
                    err(TTCP_MESSAGE_42); // "getsockname"

            } else {
                tmpbuf = sizeof(struct sockaddr_storage);
                if (getsockname(fd, (struct sockaddr *)sinme, &tmpbuf) < 0)
                    err(TTCP_MESSAGE_42); // "getsockname"

                // Join multicast groups.
                for (i = 1; i < argc; i++) {
                    if ((argv[i][0] != '-') &&
                        (argv[i][0] != '/'))
                        break;
                    if (argv[i][1] == 'j') {
                        if (sinme->sa_family == AF_INET) {
                            struct ip_mreq mreq;

                            (void) RtlIpv4StringToAddressA(&argv[i][2],
                                                           TRUE,
                                                           &Term,
                                                           &mreq.imr_multiaddr);
                            if ((*Term == ':') || (*Term == '/')) {
                                // In Whistler, this ioctl allows an
                                // interface index in addition to an address.
                                mreq.imr_interface.s_addr = htonl(atoi(Term+1));
                            } else {
                                mreq.imr_interface.s_addr = 0;
                            }

                            if (setsockopt(fd, IPPROTO_IP,
                                           IP_ADD_MEMBERSHIP,
                                           (char *)&mreq, sizeof mreq) < 0)
                                err(TTCP_MESSAGE_SSO_IP_ADD_MEMBERSHIP);

                        } else { // sinme->sa_family == AF_INET6
                            struct ipv6_mreq mreq;

                            (void) RtlIpv6StringToAddressA(&argv[i][2],
                                                           &Term,
                                                           &mreq.ipv6mr_multiaddr);
                            if ((*Term == ':') || (*Term == '/')) {
                                mreq.ipv6mr_interface = atoi(Term+1);
                            } else {
                                mreq.ipv6mr_interface = 0;
                            }

                            if (setsockopt(fd, IPPROTO_IPV6,
                                           IPV6_ADD_MEMBERSHIP,
                                           (char *)&mreq, sizeof mreq) < 0)
                                err(TTCP_MESSAGE_SSO_IPV6_ADD_MEMBERSHIP);
                        }
                    }
                }
            }
        } // end if (trans)

        if (trans) {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_6, format_addr(sinme));
// printf("ttcp-t: local %s", format_addr(sinme));

            NlsPutMsg(STDOUT, TTCP_MESSAGE_7, format_addr(sinhim));
// printf(" -> remote %s\n", format_addr(sinhim));

        } else {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_8, format_addr(sinme));
// printf("ttcp-r: local %s", format_addr(sinme));

            if (udp)
                NlsPutMsg(STDOUT, TTCP_MESSAGE_9);
// printf("\n");

            else
                NlsPutMsg(STDOUT, TTCP_MESSAGE_10, format_addr(sinhim));
// printf(" <- remote %s\n", format_addr(sinhim));

        }

        if (connecttest) {

            //
            // Instead of testing data transfer,
            // test connection setup/teardown.
            //

            if (trans) {
                //
                // Close the socket that we have from above.
                //
                closesocket(fd);

                prep_timer();

                for (i = 1; i < nbuf; i++) {

                    fd = socket(sinme->sa_family, SOCK_STREAM, 0);
                    if (fd == INVALID_SOCKET)
                        err(TTCP_MESSAGE_48); // "socket"

                    if (bind(fd, sinme, addr_len(sinme)) < 0)
                        err(TTCP_MESSAGE_33); // "bind"

                    if (connect(fd, sinhim, addr_len(sinhim)) < 0)
                        err(TTCP_MESSAGE_54); // "connect"

                    if (recv(fd, (char *)&tmpbuf, sizeof(tmpbuf), 0) < 0)
                        err(TTCP_MESSAGE_55); // "recv"

                    closesocket(fd);
                }

            } else { // if not (trans)
                //
                // Close the socket that we have from above.
                //
                closesocket(fd2);

                prep_timer();

                for (i = 1; i < nbuf; i++) {

                    fd2 = accept(fd, NULL, NULL);
                    if (fd2 == INVALID_SOCKET)
                        err(TTCP_MESSAGE_52); // "accept"

                    closesocket(fd2);
                }

            } // end if (trans)

            numCalls = i;
            (void)read_timer(stats,sizeof(stats));
            goto display;

        } // end if (connecttest)

        //
        // Send/receive data using the socket.
        //

        if (!udp && !trans) {
            closesocket(fd);
            fd = fd2;
        }

        if (udp && buflen < 5) {
            buflen = 5;         /* send more than the sentinel size */
        }

        if ( (buf = (char *)malloc(buflen+bufalign)) == (char *)NULL)
            err(TTCP_MESSAGE_57); // "malloc"
        if (bufalign != 0)
            buf +=(bufalign - (PtrToUlong(buf) % bufalign) + bufoffset) % bufalign;

        if (trans) {
            if (udp) {
                NlsPutMsg(STDOUT, TTCP_MESSAGE_11,
                          buflen, nbuf, bufalign, bufoffset, port, argv[i]);
            } else {
                NlsPutMsg(STDOUT, TTCP_MESSAGE_58,
                          buflen, nbuf, bufalign, bufoffset, port, argv[i]);
            }                
// printf("ttcp"
//        "-t: buflen=%d, nbuf=%d, align=%d/+%d, port=%d  %s  -> %s\n",
//        buflen, nbuf, bufalign, bufoffset, port,
//        udp?"udp":"tcp",
//        argv[i]);

        } else {
            if (udp) {
                NlsPutMsg(STDOUT, TTCP_MESSAGE_12,
                          buflen, nbuf, bufalign, bufoffset, port);
            } else {
                NlsPutMsg(STDOUT, TTCP_MESSAGE_59,
                          buflen, nbuf, bufalign, bufoffset, port);
            }
// printf("ttcp"
//        "-r: buflen=%d, nbuf=%d, align=%d/+%d, port=%d  %s\n",
//        buflen, nbuf, bufalign, bufoffset, port,
//        udp?"udp":"tcp");

        }

        prep_timer();

        if (async != 0) {
            TTCP_ASYNC_INFO *info;
            HANDLE *events;

            info = malloc( sizeof(*info) * async );
            if ( info == NULL ) {
                NlsPutMsg(STDOUT, TTCP_MESSAGE_13);
// printf("malloc failed.\n" );

                exit(1);
            }

            events = malloc( sizeof(HANDLE) * async );
            if ( events == NULL ) {
                NlsPutMsg(STDOUT, TTCP_MESSAGE_13);
// printf("malloc failed.\n" );

                exit(1);
            }

            for ( i = 0; i < async; i++ ) {

                info[i].Buffer = malloc(buflen);
                if ( info[i].Buffer == NULL ) {
                    NlsPutMsg(STDOUT, TTCP_MESSAGE_13);
// printf("malloc failed.\n" );

                    exit(1);
                }

                events[i] = CreateEvent( NULL, FALSE, FALSE, NULL );
                if ( events[i] == NULL ) {
                    NlsPutMsg(STDOUT, TTCP_MESSAGE_14, GetLastError());
// printf("CreateEvent failed: %ld\n", GetLastError( ) );

                    exit(1);
                }

                info[i].Overlapped.Internal = 0;
                info[i].Overlapped.InternalHigh = 0;
                info[i].Overlapped.Offset = 0;
                info[i].Overlapped.OffsetHigh = 0;
                info[i].Overlapped.hEvent = events[i];
            }

            if (trans) {

                for ( i = 0; i < async; i++ ) {

                    ret = WriteFile(
                              (HANDLE)fd,
                              info[i].Buffer,
                              buflen,
                              &info[i].BytesWritten,
                              &info[i].Overlapped
                              );
                    if ( !ret && GetLastError( ) != ERROR_IO_PENDING ) {
                        NlsPutMsg(STDOUT, TTCP_MESSAGE_15, GetLastError());
// printf("WriteFile failed: %ld\n", GetLastError( ) );

                        break;
                    }
                    nbuf--;
                    numCalls++;
                }

                while (nbuf > 0) {
                    ret = WaitForMultipleObjects( async, events, FALSE, INFINITE );
                    i = ret - WAIT_OBJECT_0;

                    ret = GetOverlappedResult(
                              (HANDLE)fd,
                              &info[i].Overlapped,
                              &info[i].BytesWritten,
                              FALSE
                              );
                    if ( !ret ) {
                        NlsPutMsg(STDOUT, TTCP_MESSAGE_16, GetLastError());
// printf("pended WriteFile failed: %ld\n", GetLastError( ) );

                        break;
                    }

                    nbytes += info[i].BytesWritten;

                    ret = WriteFile(
                              (HANDLE)fd,
                              info[i].Buffer,
                              buflen,
                              &info[i].BytesWritten,
                              &info[i].Overlapped
                              );
                    if ( !ret && GetLastError( ) != ERROR_IO_PENDING ) {
                        NlsPutMsg(STDOUT, TTCP_MESSAGE_15, GetLastError());
// printf("WriteFile failed: %ld\n", GetLastError( ) );

                        break;
                    }
                    nbuf--;
                    numCalls++;
                }

                for ( i = 0; i < async; i++ ) {
                    ret = GetOverlappedResult(
                              (HANDLE)fd,
                              &info[i].Overlapped,
                              &info[i].BytesWritten,
                              TRUE
                              );
                    if ( !ret ) {
                        NlsPutMsg(STDOUT, TTCP_MESSAGE_16, GetLastError());
// printf("pended WriteFile failed: %ld\n", GetLastError());

                        break;
                    }

                    nbytes += info[i].BytesWritten;
                }

            } else { // if not (trans)

                for ( i = 0; i < async; i++ ) {

                    ret = ReadFile(
                              (HANDLE)fd,
                              info[i].Buffer,
                              buflen,
                              &info[i].BytesWritten,
                              &info[i].Overlapped
                              );
                    if ( !ret && GetLastError( ) != ERROR_IO_PENDING ) {
                        NlsPutMsg(STDOUT, TTCP_MESSAGE_17, GetLastError());
// printf("ReadFile failed: %ld\n", GetLastError( ) );

                        break;
                    }
                    nbuf--;
                    numCalls++;
                }

                while (TRUE) {
                    ret = WaitForMultipleObjects( async, events, FALSE, INFINITE );
                    i = ret - WAIT_OBJECT_0;

                    ret = GetOverlappedResult(
                              (HANDLE)fd,
                              &info[i].Overlapped,
                              &info[i].BytesWritten,
                              FALSE
                              );
                    if ( !ret ) {
                        NlsPutMsg(STDOUT, TTCP_MESSAGE_18, GetLastError());
// printf("pended ReadFile failed: %ld\n", GetLastError( ) );

                        break;
                    }

                    nbytes += info[i].BytesWritten;
                    if (info[i].BytesWritten == 0) {
                        break;
                    }

                    ret = ReadFile(
                              (HANDLE)fd,
                              info[i].Buffer,
                              buflen,
                              &info[i].BytesWritten,
                              &info[i].Overlapped
                              );
                    if ( !ret && GetLastError( ) != ERROR_IO_PENDING ) {
                        NlsPutMsg(STDOUT, TTCP_MESSAGE_17, GetLastError());
// printf("ReadFile failed: %ld\n", GetLastError( ) );

                        break;
                    }
                    nbuf--;
                    numCalls++;
                }

                for ( i = 0; i < async; i++ ) {
                    ret = GetOverlappedResult(
                              (HANDLE)fd,
                              &info[i].Overlapped,
                              &info[i].BytesWritten,
                              TRUE
                              );
                    if ( !ret ) {
                        NlsPutMsg(STDOUT, TTCP_MESSAGE_18, GetLastError( ) );
// printf("pended ReadFile failed: %ld\n", GetLastError( ) );

                        break;
                    }

                    nbytes += info[i].BytesWritten;
                }
            } // end if (trans)

        } // end if (async != 0)

        else if (filename != NULL ) {

            ret = TransmitFile( fd, filehandle,
                                0,      // nNumberOfBytesToWrite
                                0,      // nNumberOfBytesPerSend
                                NULL,   // lpOverlapped
                                NULL,   // lpTransmitBuffers
                                0 );    // dwFlags

            if ( !ret ) {
                NlsPutMsg(STDOUT, TTCP_MESSAGE_19, GetLastError());
// printf("TransmitFile failed: %ld\n", GetLastError( ) );

                exit(1);
            }

        } else if (sinkmode) {
                register int cnt;

                if (trans)  {
                        pattern( buf, buflen );
                        if(udp)  (void)Nwrite( fd, buf, 4 ); /* rcvr start */
                        while (nbuf-- && Nwrite(fd,buf,buflen) == buflen)
                                nbytes += buflen;
                        NlsPutMsg(STDOUT, TTCP_MESSAGE_20, nbuf);
// printf("ttcp-t: done sending, nbuf = %d\n", nbuf );

                        if(udp)  {
                            Sleep( 10 );
                            (void)Nwrite( fd, buf, 4 ); /* rcvr end */
                        }
                } else {
                        if (udp) {
                            while ((cnt=Nread(fd,buf,buflen)) > 0)  {
                                    static int going = 0;
                                    if( cnt <= 4 )  {
                                            if( going ) {
                                                    break;      /* "EOF" */
                                            }
                                            going = 1;
                                            prep_timer();
                                    } else {
                                            nbytes += cnt;
                                    }
                            }
                        } else {
                            while ((cnt=Nread(fd,buf,buflen)) > 0)  {
                                    nbytes += cnt;
                            }
                        }
                }

        } else {
                register int cnt;
                if (trans)  {
			_setmode(0, _O_BINARY);
                        while((cnt=_read(0,buf,buflen)) > 0 &&
                            Nwrite(fd,buf,cnt) == cnt)
                                nbytes += cnt;
                }  else  {
			_setmode(1, _O_BINARY);
                        while((cnt=Nread(fd,buf,buflen)) > 0 &&
                            _write(1,buf,cnt) == cnt)
                                nbytes += cnt;
                }
        }

        //if(errno) err(TTCP_MESSAGE_); // "IO"
        (void)read_timer(stats,sizeof(stats));
        if(udp&&trans)  {
                (void)Nwrite( fd, buf, 4 ); /* rcvr end */
                (void)Nwrite( fd, buf, 4 ); /* rcvr end */
                (void)Nwrite( fd, buf, 4 ); /* rcvr end */
                (void)Nwrite( fd, buf, 4 ); /* rcvr end */
        }
display:
        closesocket(fd);
        //if( cput <= 0.0 )  cput = 0.001;
        if ( numCalls == 0 ) {
            numCalls = 1;
        }
        if ( realt == 0 ) {
            realt = 1;
        }
        if (trans) {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_21,
                      nbytes, realt,
                      (int)((1000.0*(nbytes/(double)realt))/1024.0));
        } else {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_60,
                      nbytes, realt,
                      (int)((1000.0*(nbytes/(double)realt))/1024.0));
        }
// printf("ttcp"
//        "%s: %ld bytes in %ld real milliseconds = %ld KB/sec\n",
//        trans?"-t":"-r",
//        nbytes, realt, (int)((1000.0*(nbytes/(double)realt))/1024.0) );

#if 0
        printf("ttcp"
               "%s: %ld bytes in %.2f CPU seconds = %.2f KB/cpu sec\n",
               trans?"-t":"-r",
               nbytes, cput, ((double)nbytes)/cput/1024 );
#endif

        if (trans) {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_22,
                      numCalls, realt/numCalls,
                      (1000*numCalls)/realt, nbytes/numCalls);
        } else {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_61,
                      numCalls, realt/numCalls,
                      (1000*numCalls)/realt, nbytes/numCalls);
        }
// printf("ttcp"
//        "%s: %ld I/O calls, msec/call = %ld, calls/sec = %ld, "
//        "bytes/call = %ld\n",
//        trans?"-t":"-r",
//        numCalls,
//        realt/numCalls,
//        (1000*numCalls)/realt,
//        nbytes/numCalls);

#if 0
printf("ttcp%s: %s\n", trans?"-t":"-r", stats);

#endif
#if 0
printf("ttcp%s: system CPU %ld%%, User %ld%%, Kernel %ld%%, "
                "User/Kernel ratio %ld%%\n",
                trans?"-t":"-r",
                ((systemUserTime+systemKernelTime)*100+50)/realt,
                (systemUserTime*100+50)/realt,
                (systemKernelTime*100+50)/realt,
                (systemUserTime+systemKernelTime == 0) ? 100 :
                (systemUserTime*100+50)/(systemUserTime+systemKernelTime));

fprintf(stdout, "ttcp%s: process CPU %ld%%, User %ld%%, Kernel %ld%%, "
                "User/Kernel ratio %ld%%\n",
                trans?"-t":"-r",
                ((processUserTime+processKernelTime)*100+50)/realt,
                (processUserTime*100+50)/realt,
                (processKernelTime*100+50)/realt,
                (processUserTime+processKernelTime == 0) ? 100 :
                (processUserTime*100+50)/(processUserTime+processKernelTime));

#endif
        if (verbose) {
            if (trans) {
                NlsPutMsg(STDOUT, TTCP_MESSAGE_23, buf);
            } else {
                NlsPutMsg(STDOUT, TTCP_MESSAGE_62, buf);
            }
            
                
// printf("ttcp%s: buffer address %#p\n", trans?"-t":"-r", buf);

        }

        WSACleanup();
        exit(0);

usage:
        NlsPutMsg(STDERR, TTCP_MESSAGE_24);
// fprintf(stderr, "Usage: ttcp -t [-options] host [ < in ]\n");
// fprintf(stderr,"       ttcp -r [-options > out]\n");
// fprintf(stderr,"Common options:\n");
// fprintf(stderr,"        -l##    length of bufs read from or written to network (default 8192)\n");
// fprintf(stderr,"        -u      use UDP instead of TCP\n");
// fprintf(stderr,"        -p##    port number to send to or listen at (default 5001)\n");
// fprintf(stderr,"        -P4     use IPv4\n");
// fprintf(stderr,"        -P6     use IPv6\n");
// fprintf(stderr,"        -s      -t: don't source a pattern to network, get data from stdin\n");
// fprintf(stderr,"                -r: don't sink (discard), print data on stdout\n");
// fprintf(stderr,"        -A      align the start of buffers to this modulus (default 16384)\n");
// fprintf(stderr,"        -O      start buffers at this offset from the modulus (default 0)\n");
// fprintf(stderr,"        -v      verbose: print more statistics\n");
// fprintf(stderr,"        -d      set SO_DEBUG socket option\n");
// fprintf(stderr,"        -h      set SO_SNDBUF or SO_RCVBUF\n");
// fprintf(stderr,"        -a      use asynchronous I/O calls\n");
// fprintf(stderr,"        -S##    specify source address\n");
// fprintf(stderr,"        -H##    specify TTL or hop limit\n");
// fprintf(stderr,"Options specific to -t:\n");
// fprintf(stderr,"        -n##    number of source bufs written to network (default 2048)\n");
// fprintf(stderr,"        -D      don't buffer TCP writes (sets TCP_NODELAY socket option)\n");
// fprintf(stderr,"        -w##    milliseconds of delay before each write\n");
// fprintf(stderr,"        -f##    specify a file name for TransmitFile\n");
// fprintf(stderr,"Options specific to -r:\n");
// fprintf(stderr,"        -B      for -s, only output full blocks as specified by -l (for TAR)\n");
// fprintf(stderr,"        -j##[/##] specify multicast group and optional ifindex (UDP-only)\n");
        WSACleanup();
        exit(1);
}

void err(message)
unsigned int message;
{
        if (trans) {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_25);
        } else {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_63);
        }
// fprintf(stdout, "ttcp%s: ", trans?"-t":"-r");

        NlsPerror(message, WSAGetLastError());
        // perror(message);

        NlsPutMsg(STDERR, TTCP_MESSAGE_26, WSAGetLastError());
// fprintf(stderr, "errno=%d\n",WSAGetLastError());
    
        WSACleanup();
        exit(1);
}

void pattern( cp, cnt )
register char *cp;
register int cnt;
{
        register char c;
        c = 0;
        while( cnt-- > 0 )  {
                while( !isprint((c&0x7F)) )  c++;
                *cp++ = (c++&0x7F);
        }
}


static void prusage();
static void tvadd();
static void tvsub();
static void psecs();

#if defined(SYSV)
/*ARGSUSED*/
static
getrusage(ignored, ru)
    int ignored;
    register struct rusage *ru;
{
    struct tms buf;

    times(&buf);

    /* Assumption: HZ <= 2147 (LONG_MAX/1000000) */
    ru->ru_stime.tv_sec  = buf.tms_stime / HZ;
    ru->ru_stime.tv_usec = ((buf.tms_stime % HZ) * 1000000) / HZ;
    ru->ru_utime.tv_sec  = buf.tms_utime / HZ;
    ru->ru_utime.tv_usec = ((buf.tms_utime % HZ) * 1000000) / HZ;
}

#if !defined(sgi)
/*ARGSUSED*/
static
gettimeofday(tp, zp)
    struct timeval *tp;
    struct timezone *zp;
{
    tp->tv_sec = time(0);
    tp->tv_usec = 0;
}
#endif
#endif // SYSV

__int64 time0;
__int64 time1;
__int64 freq;

/*
 *                      P R E P _ T I M E R
 */
void
prep_timer()
{
#if 0
    gettimeofday(&time0, (struct timezone *)0);
    getrusage(RUSAGE_SELF, &ru0);
#endif

    (void) QueryPerformanceFrequency((LARGE_INTEGER *)&freq);
    (void) QueryPerformanceCounter((LARGE_INTEGER *)&time0);
}

/*
 *                      R E A D _ T I M E R
 *
 */
double
read_timer(str,len)
char *str;
int len;
{
#if 0
    char line[132];

    getrusage(RUSAGE_SELF, &ru1);
    gettimeofday(&timedol, (struct timezone *)0);
    prusage(&ru0, &ru1, &timedol, &time0, line);
    (void)strncpy( str, line, len );

    /* Get real time */
    tvsub( &td, &timedol, &time0 );
    realt = td.tv_sec + ((double)td.tv_usec) / 1000000;

    /* Get CPU time (user+sys) */
    tvadd( &tend, &ru1.ru_utime, &ru1.ru_stime );
    tvadd( &tstart, &ru0.ru_utime, &ru0.ru_stime );
    tvsub( &td, &tend, &tstart );
    cput = td.tv_sec + ((double)td.tv_usec) / 1000000;
    if( cput < 0.00001 )  cput = 0.00001;
    return( cput );
#endif

    (void) QueryPerformanceCounter((LARGE_INTEGER *)&time1);

    // realt is real elapsed time in milliseconds
    realt = (DWORD) ((1000 * (time1 - time0)) / freq);

    return 0;
}

#if 0
static void
prusage(r0, r1, e, b, outp)
        register struct rusage *r0, *r1;
        struct timeval *e, *b;
        char *outp;
{
        struct timeval tdiff;
        register time_t t;
        register char *cp;
        register int i;
        int ms;

        t = (r1->ru_utime.tv_sec-r0->ru_utime.tv_sec)*100+
            (r1->ru_utime.tv_usec-r0->ru_utime.tv_usec)/10000+
            (r1->ru_stime.tv_sec-r0->ru_stime.tv_sec)*100+
            (r1->ru_stime.tv_usec-r0->ru_stime.tv_usec)/10000;
        ms =  (e->tv_sec-b->tv_sec)*100 + (e->tv_usec-b->tv_usec)/10000;

#define END(x)  {while(*x) x++;}
#if defined(SYSV)
        cp = "%Uuser %Zsys %Ereal %P";
#else
        cp = "%Uuser %Zsys %Ereal %P %Xi+%Dd %Mmaxrss %F+%Rpf %Xcsw";
#endif
        for (; *cp; cp++)  {
                if (*cp != '%')
                        *outp++ = *cp;
                else if (cp[1]) switch(*++cp) {

                case 'U':
                        tvsub(&tdiff, &r1->ru_utime, &r0->ru_utime);
                        sprintf(outp,"%d.%01d", tdiff.tv_sec, tdiff.tv_usec/100000);
                        END(outp);
                        break;

                case 'S':
                        tvsub(&tdiff, &r1->ru_stime, &r0->ru_stime);
                        sprintf(outp,"%d.%01d", tdiff.tv_sec, tdiff.tv_usec/100000);
                        END(outp);
                        break;

                case 'E':
                        psecs(ms / 100, outp);
                        END(outp);
                        break;

                case 'P':
                        sprintf(outp,"%d%%", (int) (t*100 / ((ms ? ms : 1))));
                        END(outp);
                        break;

#if !defined(SYSV)
                case 'W':
                        i = r1->ru_nswap - r0->ru_nswap;
                        sprintf(outp,"%d", i);
                        END(outp);
                        break;

                case 'X':
                        sprintf(outp,"%d", t == 0 ? 0 : (r1->ru_ixrss-r0->ru_ixrss)/t);
                        END(outp);
                        break;

                case 'D':
                        sprintf(outp,"%d", t == 0 ? 0 :
                            (r1->ru_idrss+r1->ru_isrss-(r0->ru_idrss+r0->ru_isrss))/t);
                        END(outp);
                        break;

                case 'K':
                        sprintf(outp,"%d", t == 0 ? 0 :
                            ((r1->ru_ixrss+r1->ru_isrss+r1->ru_idrss) -
                            (r0->ru_ixrss+r0->ru_idrss+r0->ru_isrss))/t);
                        END(outp);
                        break;

                case 'M':
                        sprintf(outp,"%d", r1->ru_maxrss/2);
                        END(outp);
                        break;

                case 'F':
                        sprintf(outp,"%d", r1->ru_majflt-r0->ru_majflt);
                        END(outp);
                        break;

                case 'R':
                        sprintf(outp,"%d", r1->ru_minflt-r0->ru_minflt);
                        END(outp);
                        break;

                case 'I':
                        sprintf(outp,"%d", r1->ru_inblock-r0->ru_inblock);
                        END(outp);
                        break;

                case 'O':
                        sprintf(outp,"%d", r1->ru_oublock-r0->ru_oublock);
                        END(outp);
                        break;
                case 'C':
                        sprintf(outp,"%d+%d", r1->ru_nvcsw-r0->ru_nvcsw,
                                r1->ru_nivcsw-r0->ru_nivcsw );
                        END(outp);
                        break;
#endif !SYSV
                }
        }
        *outp = '\0';
}
#endif

static void
tvadd(tsum, t0, t1)
        struct timeval *tsum, *t0, *t1;
{

        tsum->tv_sec = t0->tv_sec + t1->tv_sec;
        tsum->tv_usec = t0->tv_usec + t1->tv_usec;
        if (tsum->tv_usec > 1000000)
                tsum->tv_sec++, tsum->tv_usec -= 1000000;
}

static void
tvsub(tdiff, t1, t0)
        struct timeval *tdiff, *t1, *t0;
{

        tdiff->tv_sec = t1->tv_sec - t0->tv_sec;
        tdiff->tv_usec = t1->tv_usec - t0->tv_usec;
        if (tdiff->tv_usec < 0)
                tdiff->tv_sec--, tdiff->tv_usec += 1000000;
}

#if 0
static void
psecs(l,cp)
long l;
register char *cp;
{
        register int i;

        i = l / 3600;
        if (i) {
                sprintf(cp,"%d:", i);
                END(cp);
                i = l % 3600;
                sprintf(cp,"%d%d", (i/60) / 10, (i/60) % 10);
                END(cp);
        } else {
                i = l;
                sprintf(cp,"%d", i / 60);
                END(cp);
        }
        i %= 60;
        *cp++ = ':';
        sprintf(cp,"%d%d", i / 10, i % 10);
}
#endif

/*
 *                      N R E A D
 */
int
Nread( SOCKET fd, PBYTE buf, INT count )
{
        static int didit = 0;
        int len = sizeof(sinhimStorage);
        register int cnt;
        if( udp )  {
            if (udp_connect) {
                cnt = recv( fd, buf, count, 0 );
                numCalls++;
            } else {
                cnt = recvfrom( fd, buf, count, 0, sinhim, &len );
                if ((recvfrom > 0) && !didit) {
                    didit = 1;
                    NlsPutMsg(STDOUT, TTCP_MESSAGE_28, format_addr(sinhim));
// fprintf(stdout, "ttcp-r: recvfrom %s\n", format_addr(sinhim));

                }
                numCalls++;
            }
        } else {
                if( b_flag )
                        cnt = mread( fd, buf, count );  /* fill buf */
                else {
                        cnt = recv( fd, buf, count, 0 );
                        numCalls++;
                }
        }
        if (cnt<0) {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_29, WSAGetLastError());
// printf("recv(from) failed: %ld\n", WSAGetLastError( ) );

        }
        return(cnt);
}

/*
 *                      N W R I T E
 */
int
Nwrite( SOCKET fd, PBYTE buf, INT count )
{
        register int cnt = 0;
        int bytesToSend = count;

        if (write_delay)
                Sleep(write_delay);
        if( udp && !udp_connect)  {
again:
                cnt = sendto( fd, buf, count, 0, sinhim, addr_len(sinhim) );
                numCalls++;
                if( cnt<0 && WSAGetLastError( ) == WSAENOBUFS )  {
                        Sleep(18000);
                        goto again;
                }
        } else {
                while( count > 0 )
                {
                    cnt = send( fd, buf, count, 0 );
                    numCalls++;

                    //if (count != cnt) {
                    //    printf("Tried %d, sent %d\n", count, cnt );
                    //} else {
                    //    printf("send %d bytes as requested.\n", cnt );
                    //}

                    if( cnt == SOCKET_ERROR )
                    {
                        break;
                    }

                    count -= cnt;
                    buf += cnt;
                }
        }
        if (cnt<0) {
            NlsPutMsg(STDOUT, TTCP_MESSAGE_30, WSAGetLastError());
// printf("send(to) failed: %ld\n", WSAGetLastError( ) );

            return -1;
        }
        return(bytesToSend);
}

/*
 *                      M R E A D
 *
 * This function performs the function of a read(II) but will
 * call read(II) multiple times in order to get the requested
 * number of characters.  This can be necessary because
 * network connections don't deliver data with the same
 * grouping as it is written with.  Written by Robert S. Miles, BRL.
 */
int
mread( SOCKET fd, PBYTE bufp, INT n)
{
        register unsigned       count = 0;
        register int            nread;

        do {
                nread = recv(fd, bufp, n-count, 0);
                numCalls++;
                if(nread < 0)  {
                        return(-1);
                }
                if(nread == 0)
                        return((int)count);
                count += (unsigned)nread;
                bufp += nread;
         } while(count < (UINT)n);

        return((int)count);
}


int
parse_addr(char *s, struct sockaddr *sa)
{
    struct addrinfo hints;
    struct addrinfo *result;

    memset(&hints, 0, sizeof hints);
    hints.ai_family = prot;

    if (getaddrinfo(s, NULL, &hints, &result) != 0)
        return FALSE; // Failed to parse/resolve the address.

    memcpy(sa, result->ai_addr, result->ai_addrlen);
    freeaddrinfo(result);
    return TRUE;
}

u_int
addr_len(struct sockaddr *sa)
{
    u_int salen;

    switch (sa->sa_family) {
    case AF_INET:
        salen = sizeof(struct sockaddr_in);
        break;
    case AF_INET6:
        salen = sizeof(struct sockaddr_in6);
        break;
    default:
        salen = 0;
        break;
    }

    return salen;
}

char *
format_addr(struct sockaddr *sa)
{
    static char buffer[NI_MAXHOST];

    if (getnameinfo(sa, addr_len(sa),
                    buffer, sizeof buffer,
                    NULL, 0, NI_NUMERICHOST) != 0)
        strcpy(buffer, "<invalid>");

    return buffer;
}

void
set_port(struct sockaddr *sa, u_short port)
{
    //
    // The port field is in the same location
    // for both sockaddr_in and sockaddr_in6.
    //
    ((struct sockaddr_in *)sa)->sin_port = port;
}

u_short
get_port(struct sockaddr *sa)
{
    //
    // The port field is in the same location
    // for both sockaddr_in and sockaddr_in6.
    //
    return ((struct sockaddr_in *)sa)->sin_port;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\tcpip6\tcp\tcpsend.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// TCP send code.
//
// This file contains the code for sending Data and Control segments.
//


#include "oscfg.h"
#include "ndis.h"
#include "ip6imp.h"
#include "ip6def.h"
#include "tdi.h"
#include "tdint.h"
#include "tdistat.h"
#include "queue.h"
#include "transprt.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tcpsend.h"
#include "tcprcv.h"
#include "info.h"
#include "tcpcfg.h"
#include "route.h"
#include "security.h"

void *TCPProtInfo;  // TCP protocol info for IP.

SLIST_HEADER TCPSendReqFree;  // Send req. free list.

KSPIN_LOCK TCPSendReqFreeLock;
KSPIN_LOCK TCPSendReqCompleteLock;

uint NumTCPSendReq;            // Current number of SendReqs in system.
uint MaxSendReq = 0xffffffff;  // Maximum allowed number of SendReqs.

extern KSPIN_LOCK TCBTableLock;

//
// All of the init code can be discarded.
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, InitTCPSend)

#endif // ALLOC_PRAGMA

extern void ResetSendNext(TCB *SeqTCB, SeqNum NewSeq);

#define MIN_INITIAL_RTT 3  // In msec.


//* FreeSendReq - Free a send request structure.
//
//  Called to free a send request structure.
//
void                       // Returns: Nothing.
FreeSendReq(
    TCPSendReq *FreedReq)  // Connection request structure to be freed.
{
    PSLIST_ENTRY BufferLink;

    CHECK_STRUCT(FreedReq, tsr);

    BufferLink = CONTAINING_RECORD(&(FreedReq->tsr_req.tr_q.q_next),
                                   SLIST_ENTRY, Next);

    ExInterlockedPushEntrySList(&TCPSendReqFree, BufferLink,
                                &TCPSendReqFreeLock);
}


//* GetSendReq - Get a send request structure.
//
//  Called to get a send request structure.
//
TCPSendReq *  // Returns: Pointer to SendReq structure, or NULL if none.
GetSendReq(
    void)     // Nothing.
{
    TCPSendReq *Temp;
    PSLIST_ENTRY BufferLink;
    Queue *QueuePtr;
    TCPReq *ReqPtr;

    BufferLink = ExInterlockedPopEntrySList(&TCPSendReqFree,
                                            &TCPSendReqFreeLock);

    if (BufferLink != NULL) {
        QueuePtr = CONTAINING_RECORD(BufferLink, Queue, q_next);
        ReqPtr = CONTAINING_RECORD(QueuePtr, TCPReq, tr_q);
        Temp = CONTAINING_RECORD(ReqPtr, TCPSendReq, tsr_req);
        CHECK_STRUCT(Temp, tsr);
    } else {
        if (NumTCPSendReq < MaxSendReq)
            Temp = ExAllocatePool(NonPagedPool, sizeof(TCPSendReq));
        else
            Temp = NULL;

        if (Temp != NULL) {
            ExInterlockedAddUlong((PULONG)&NumTCPSendReq, 1, &TCPSendReqFreeLock);
#if DBG
            Temp->tsr_req.tr_sig = tr_signature;
            Temp->tsr_sig = tsr_signature;
#endif
        }
    }

    return Temp;
}


//* TCPHopLimit
//
//  Given a TCB, returns the Hop Limit to use in a sent packet.
//  Assumes the caller holds a lock on the TCB.
//
uchar
TCPHopLimit(TCB *Tcb)
{
    if (Tcb->tcb_hops != -1)
        return (uchar) Tcb->tcb_hops;
    else
        return (uchar) Tcb->tcb_rce->NCE->IF->CurHopLimit;
}


//* TCPSendComplete - Complete a TCP send.
//
//  Called by IP when a send we've made is complete.  We free the buffer,
//  and possibly complete some sends.  Each send queued on a TCB has a ref.
//  count with it, which is the number of times a pointer to a buffer
//  associated with the send has been passed to the underlying IP layer.  We
//  can't complete a send until that count it 0.  If this send was actually
//  from a send of data, we'll go down the chain of send and decrement the
//  refcount on each one.  If we have one going to 0 and the send has already
//  been acked we'll complete the send.  If it hasn't been acked we'll leave
//  it until the ack comes in.
//
//  NOTE: We aren't protecting any of this with locks.  When we port this to
//  NT we'll need to fix this, probably with a global lock.  See the comments
//  in ACKSend() in TCPRCV.C for more details.
//
void                      // Returns: Nothing.
TCPSendComplete(
    PNDIS_PACKET Packet,  // Packet that was sent.
    IP_STATUS Status)
{
    PNDIS_BUFFER BufferChain;
    SendCmpltContext *SCContext;
    PVOID Memory;
    UINT Unused;

    UNREFERENCED_PARAMETER(Status);

    //
    // Pull values we care about out of the packet structure.
    //
    SCContext = (SendCmpltContext *) PC(Packet)->CompletionData;
    BufferChain = NdisFirstBuffer(Packet);
    NdisQueryBufferSafe(BufferChain, &Memory, &Unused, LowPagePriority);
    ASSERT(Memory != NULL);

    //
    // See if we have a send complete context.  It will be present for data
    // packets and means we have extra work to do.  For non-data packets, we
    // can just skip all this as there is only the header buffer to deal with.
    //
    if (SCContext != NULL) {
        KIRQL OldIrql;
        PNDIS_BUFFER CurrentBuffer;
        TCPSendReq *CurrentSend;
        uint i;

        CHECK_STRUCT(SCContext, scc);

        //
        // First buffer in chain is the TCP header buffer.
        // Skip over it for now.
        //
        CurrentBuffer = NDIS_BUFFER_LINKAGE(BufferChain);

        //
        // Also skip over any 'user' buffers (those loaned out to us
        // instead of copied) as we don't need to free them.
        //
        for (i = 0; i < (uint)SCContext->scc_ubufcount; i++) {
            ASSERT(CurrentBuffer != NULL);
            CurrentBuffer = NDIS_BUFFER_LINKAGE(CurrentBuffer);
        }

        //
        // Now loop through and free our (aka 'transport') buffers.
        // We need to do this before decrementing the reference count to avoid
        // destroying the buffer chain if we have to zap tsr_lastbuf->Next to
        // NULL.
        //
        for (i = 0; i < (uint)SCContext->scc_tbufcount; i++) {
            PNDIS_BUFFER TempBuffer;

            ASSERT(CurrentBuffer != NULL);

            TempBuffer = CurrentBuffer;
            CurrentBuffer = NDIS_BUFFER_LINKAGE(CurrentBuffer);
            NdisFreeBuffer(TempBuffer);
        }

        //
        // Loop through the send requests attached to this packet,
        // reducing the reference count on each and enqueing them for
        // completion where appropriate.
        //
        CurrentSend = SCContext->scc_firstsend;
        for (i = 0; i< SCContext->scc_count; i++) {
            Queue *TempQ;
            long Result;

            TempQ = QNEXT(&CurrentSend->tsr_req.tr_q);
            CHECK_STRUCT(CurrentSend, tsr);

            Result = InterlockedDecrement(&(CurrentSend->tsr_refcnt));
            ASSERT(Result >= 0);

            if (Result <= 0) {
                //
                // Reference count has gone to 0 which means the send has
                // been ACK'd or cancelled.  Complete it now.
                //
                // If we've sent directly from this send, NULL out the next
                // pointer for the last buffer in the chain.
                //
                if (CurrentSend->tsr_lastbuf != NULL) {
                    NDIS_BUFFER_LINKAGE(CurrentSend->tsr_lastbuf) = NULL;
                    CurrentSend->tsr_lastbuf = NULL;
                }

                KeAcquireSpinLock(&RequestCompleteLock, &OldIrql);
                ENQUEUE(&SendCompleteQ, &CurrentSend->tsr_req.tr_q);
                RequestCompleteFlags |= SEND_REQUEST_COMPLETE;
                KeReleaseSpinLock(&RequestCompleteLock, OldIrql);
            }

            CurrentSend = CONTAINING_RECORD(QSTRUCT(TCPReq, TempQ, tr_q),
                                            TCPSendReq, tsr_req);
        }
    }

    //
    // Free the TCP header buffer and our packet structure proper.
    //
    NdisFreeBuffer(BufferChain);
    ExFreePool(Memory);
    NdisFreePacket(Packet);

    //
    // If there are any TCP send requests to complete, do so now.
    //
    if (RequestCompleteFlags & SEND_REQUEST_COMPLETE)
        TCPRcvComplete();
}


//* RcvWin - Figure out the receive window to offer in an ack.
//
//  A routine to figure out what window to offer on a connection.  We
//  take into account SWS avoidance, what the default connection window is,
//  and what the last window we offered is.
//
uint              //  Returns: Window to be offered.
RcvWin(
    TCB *WinTCB)  // TCB on which to perform calculations.
{
    int CouldOffer;  // The window size we could offer.

    CHECK_STRUCT(WinTCB, tcb);

    CheckPacketList(WinTCB->tcb_pendhead, WinTCB->tcb_pendingcnt);

    ASSERT(WinTCB->tcb_rcvwin >= 0);

    CouldOffer = WinTCB->tcb_defaultwin - WinTCB->tcb_pendingcnt;

    ASSERT(CouldOffer >= 0);
    ASSERT(CouldOffer >= WinTCB->tcb_rcvwin);

    if ((CouldOffer - WinTCB->tcb_rcvwin) >=
        (int) MIN(WinTCB->tcb_defaultwin/2, WinTCB->tcb_mss)) {
        WinTCB->tcb_rcvwin = CouldOffer;
    }

    return WinTCB->tcb_rcvwin;
}


//* ValidateSourceAndRoute - Validate the NTE and RCE.
//
// Checks that the NTE and RCE referenced by this TCB are still ok to use.
//
BOOLEAN
ValidateSourceAndRoute(
    TCB *Tcb)  // TCB being validated.
{
    KIRQL Irql0;

    //
    // Update our copy of the validation counter.
    // We need to do this before making the validation checks below
    // (to avoid missing any additional changes while we're in here).
    //
    Tcb->tcb_routing = RouteCacheValidationCounter;

    //
    // Check that our NTE hasn't gone away.
    //
    KeAcquireSpinLock(&Tcb->tcb_nte->IF->Lock, &Irql0);
    if (!IsValidNTE(Tcb->tcb_nte)) {

        //
        // Can't use this one anymore.
        //
        KeReleaseSpinLock(&Tcb->tcb_nte->IF->Lock, Irql0);
        ReleaseNTE(Tcb->tcb_nte);

        //
        // See if this address lives on as a different NTE.
        //
        Tcb->tcb_nte = FindNetworkWithAddress(&Tcb->tcb_saddr,
                                              Tcb->tcb_sscope_id);
        if (Tcb->tcb_nte == NULL) {

            //
            // The address is gone.
            //
            return FALSE;
        }
    } else {
        KeReleaseSpinLock(&Tcb->tcb_nte->IF->Lock, Irql0);
    }

    //
    // Also check that the RCE is still around.
    //
    Tcb->tcb_rce = ValidateRCE(Tcb->tcb_rce, Tcb->tcb_nte);

    return TRUE;
}


//* SendSYN - Send a SYN segment.
//
//  This is called during connection establishment time to send a SYN
//  segment to the peer.  We get a buffer if we can, and then fill
//  it in.  There's a tricky part here where we have to build the MSS
//  option in the header - we find the MSS by finding the MSS offered
//  by the net for the local address.  After that, we send it.
//
void                    // Returns: Nothing.
SendSYN(
    TCB *SYNTcb,        // TCB from which SYN is to be sent.
    KIRQL PreLockIrql)  // IRQL prior to acquiring TCB lock.
{
    PNDIS_PACKET Packet;
    void *Memory;
    IPv6Header UNALIGNED *IP;
    TCPHeader UNALIGNED *TCP;
    uchar *OptPtr;
    NDIS_STATUS NdisStatus;
    uint Offset;
    uint Length;
    uint PayloadLength;
    ushort TempWin;
    ushort MSS;
    RouteCacheEntry *RCE;


    CHECK_STRUCT(SYNTcb, tcb);

    //
    // Go ahead and set the retransmission timer now, in case we can't get a
    // packet or a buffer.  In the future we might want to queue the
    // connection for when we get resources.
    //
    START_TCB_TIMER(SYNTcb->tcb_rexmittimer, SYNTcb->tcb_rexmit);

    //
    // In most cases, we will already have a route at this point.
    // However, if we failed to get one earlier in the passive receive
    // path, we may need to retry here.
    //
    if (SYNTcb->tcb_rce == NULL) {
        InitRCE(SYNTcb);
        if (SYNTcb->tcb_rce == NULL) {
            goto ErrorReturn;
        }
    }

    //
    // Validate that the address we're sourcing from and the route we're
    // sending upon are still okay to use.
    //
    if (SYNTcb->tcb_routing != RouteCacheValidationCounter) {
        if (!ValidateSourceAndRoute(SYNTcb)) {
            //
            // Even though we're about to close this TCB,
            // we should leave it in a consistent state.
            //
            SYNTcb->tcb_sendnext++;
            if (SEQ_GT(SYNTcb->tcb_sendnext, SYNTcb->tcb_sendmax)) {
                SYNTcb->tcb_sendmax = SYNTcb->tcb_sendnext;
            }

            TryToCloseTCB(SYNTcb, TCB_CLOSE_ABORTED, PreLockIrql);
            return;
        }
    }

    //
    // Allocate a packet header/buffer/data region for this SYN.
    //
    // Our buffer has space at the beginning which will be filled in
    // later by the link level.  At this level we add the IPv6Header,
    // TCPHeader, and TCP Maximum Segment Size option which follow.
    //
    // REVIEW: This grabs packets and buffers from the IPv6PacketPool and
    // REVIEW: the IPv6BufferPool respectively.  Have seperate pools for TCP?
    //
    Offset = SYNTcb->tcb_rce->NCE->IF->LinkHeaderSize;
    Length = Offset + sizeof(*IP) + sizeof(*TCP) + MSS_OPT_SIZE;
    NdisStatus = IPv6AllocatePacket(Length, &Packet, &Memory);
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        //
        // Upon failure, advance tcb_sendnext anyway.
        // We need to do this because TCBTimeout will *retreat* tcb_sendnext
        // if this SYN is later retransmitted, and if that retreat occurs
        // without this advance, we end up with a hole in the sequence-space.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TCP SendSYN: Couldn't allocate IPv6 packet header!?!\n"));
      ErrorReturn:
        SYNTcb->tcb_sendnext++;
        if (SEQ_GT(SYNTcb->tcb_sendnext, SYNTcb->tcb_sendmax)) {
            SYNTcb->tcb_sendmax = SYNTcb->tcb_sendnext;
        }
        KeReleaseSpinLock(&SYNTcb->tcb_lock, PreLockIrql);
        return;
    }
    PC(Packet)->CompletionHandler = TCPSendComplete;
    PC(Packet)->CompletionData = NULL;

    //
    // Since this is a SYN-only packet (maybe someday we'll send data with
    // the SYN?) we only have the one buffer and nothing to link on after.
    //

    //
    // We now have all the resources we need to send.
    // Prepare the actual packet.
    //

    //
    // Our header buffer has extra space for other headers to be
    // prepended to ours without requiring further allocation calls.
    // Put the actual TCP/IP header at the end of the buffer.
    //
    IP = (IPv6Header UNALIGNED *)((uchar *)Memory + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->NextHeader = IP_PROTOCOL_TCP;

    IP->HopLimit = TCPHopLimit(SYNTcb);
    IP->Source = SYNTcb->tcb_saddr;
    IP->Dest = SYNTcb->tcb_daddr;

    TCP = (TCPHeader UNALIGNED *)(IP + 1);
    TCP->tcp_src = SYNTcb->tcb_sport;
    TCP->tcp_dest = SYNTcb->tcb_dport;
    TCP->tcp_seq = net_long(SYNTcb->tcb_sendnext);

    //
    // The SYN flag takes up one element in sequence number space.
    // Record that we've sent it here (if we need to retransmit the SYN
    // segment, TCBTimeout will reset sendnext before calling us again).
    //
    SYNTcb->tcb_sendnext++;
    if (SEQ_GT(SYNTcb->tcb_sendnext, SYNTcb->tcb_sendmax)) {
        TStats.ts_outsegs++;
        SYNTcb->tcb_sendmax = SYNTcb->tcb_sendnext;
    } else
        TStats.ts_retranssegs++;

    TCP->tcp_ack = net_long(SYNTcb->tcb_rcvnext);

    //
    // REVIEW: TCP flags are entirely based upon our state, so this could
    // REVIEW: be replaced by a (quicker) array lookup.
    //
    if (SYNTcb->tcb_state == TCB_SYN_RCVD)
        TCP->tcp_flags = MAKE_TCP_FLAGS(6, TCP_FLAG_SYN | TCP_FLAG_ACK);
    else
        TCP->tcp_flags = MAKE_TCP_FLAGS(6, TCP_FLAG_SYN);

    TempWin = (ushort)SYNTcb->tcb_rcvwin;
    TCP->tcp_window = net_short(TempWin);
    TCP->tcp_urgent = 0;
    TCP->tcp_xsum = 0;
    OptPtr = (uchar *)(TCP + 1);

    //
    // Compose the Maximum Segment Size option.
    //
    // TBD: If we add IPv6 Jumbogram support, we should also add LFN
    // TBD: support to TCP and change this to handle a larger MSS.
    //
    MSS = SYNTcb->tcb_rce->NTE->IF->LinkMTU
        - sizeof(IPv6Header) - sizeof(TCPHeader);
    IF_TCPDBG(TCP_DEBUG_MSS) {
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INFO_TCPDBG,
                   "SendSYN: Sending MSS option value of %d\n", MSS));
    }
    *OptPtr++ = TCP_OPT_MSS;
    *OptPtr++ = MSS_OPT_SIZE;
    *(ushort UNALIGNED *)OptPtr = net_short(MSS);

    PayloadLength = sizeof(TCPHeader) + MSS_OPT_SIZE;

    //
    // Compute the TCP checksum.  It covers the entire TCP segment
    // starting with the TCP header, plus the IPv6 pseudo-header.
    //
    // REVIEW: The IPv4 implementation kept the IPv4 psuedo-header around
    // REVIEW: in the TCB rather than recalculate it every time.  Do this?
    //
    TCP->tcp_xsum = 0;
    TCP->tcp_xsum = ChecksumPacket(
        Packet, Offset + sizeof *IP, NULL, PayloadLength,
        AlignAddr(&IP->Source), AlignAddr(&IP->Dest), IP_PROTOCOL_TCP);
    ASSERT(TCP->tcp_xsum != 0);

    //
    // Capture and reference the RCE while we still hold the TCB lock.
    // The TCB's reference on this particular RCE might go away at any point
    // after we release the lock (or because we drop it ourselves below).
    //
    RCE = SYNTcb->tcb_rce;
    AddRefRCE(RCE);

    //
    // If connection-acceptance has been delayed, release the TCB's RCE.
    // This prevents TCBs in pre-established states from consuming
    // an unbounded number of RCEs.
    //
    if (SYNTcb->tcb_flags & ACCEPT_PENDING) {
        SYNTcb->tcb_rce = NULL;
        ReleaseRCE(RCE);
    }

    //
    // Everything's ready.  Now send the packet.
    //
    // Note that IPv6Send does not return a status code.
    // Instead it *always* completes the packet
    // with an appropriate status code.
    //
    KeReleaseSpinLock(&SYNTcb->tcb_lock, PreLockIrql);

    IPv6Send(Packet, Offset, IP, PayloadLength, RCE, 0,
             IP_PROTOCOL_TCP,
             net_short(TCP->tcp_src),
             net_short(TCP->tcp_dest));

    //
    // Release the extra reference we took on the RCE above.
    //
    ReleaseRCE(RCE);
}


//* SendKA - Send a keep alive segment.
//
//  This is called when we want to send a keep-alive.  The idea is to provoke
//  a response from our peer on an otherwise idle connection.  We send a
//  garbage byte of data in our keep-alives in order to cooperate with broken
//  TCP implementations that don't respond to segments outside the window
//  unless they contain data.
//
void                    // Returns: Nothing.
SendKA(
    TCB *KATcb,         // TCB from which keep alive is to be sent.
    KIRQL PreLockIrql)  // IRQL prior to acquiring lock on TCB.
{
    PNDIS_PACKET Packet;
    void *Memory;
    IPv6Header UNALIGNED *IP;
    TCPHeader UNALIGNED *TCP;
    NDIS_STATUS NdisStatus;
    int Offset;
    uint Length;
    uint PayloadLength;
    ushort TempWin;
    SeqNum TempSeq;
    RouteCacheEntry *RCE;

    CHECK_STRUCT(KATcb, tcb);

    //
    // In most cases, we will already have a route at this point.
    // However, if we failed to get one earlier in the passive receive
    // path, we may need to retry here.
    //
    if (KATcb->tcb_rce == NULL) {
        InitRCE(KATcb);
        if (KATcb->tcb_rce == NULL) {
            KeReleaseSpinLock(&KATcb->tcb_lock, PreLockIrql);
            return;
        }
    }

    //
    // Validate that the address we're sourcing from and the route we're
    // sending upon are still okay to use.
    //
    if (KATcb->tcb_routing != RouteCacheValidationCounter) {
        if (!ValidateSourceAndRoute(KATcb)) {
            TryToCloseTCB(KATcb, TCB_CLOSE_ABORTED, PreLockIrql);
            return;
        }
    }

    //
    // Allocate a packet header/buffer/data region for this keepalive packet.
    //
    // Our buffer has space at the beginning which will be filled in
    // later by the link level.  At this level we add the IPv6Header,
    // TCPHeader, and a single byte of data which follow.
    //
    // REVIEW: This grabs packets and buffers from the IPv6PacketPool and
    // REVIEW: the IPv6BufferPool respectively.  Have seperate pools for TCP?
    //
    Offset = KATcb->tcb_rce->NCE->IF->LinkHeaderSize;
    Length = Offset + sizeof(*IP) + sizeof(*TCP) + 1;
    NdisStatus = IPv6AllocatePacket(Length, &Packet, &Memory);
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        //
        // REVIEW: What to do if this fails.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TCP SendKA: Couldn't allocate IPv6 packet header!?!\n"));
        KeReleaseSpinLock(&KATcb->tcb_lock, PreLockIrql);
        return;
    }
    PC(Packet)->CompletionHandler = TCPSendComplete;
    PC(Packet)->CompletionData = NULL;

    //
    // Since this is a keepalive packet we only have the one buffer and
    // nothing to link on after.
    //

    //
    // Our header buffer has extra space for other headers to be
    // prepended to ours without requiring further allocation calls.
    // Put the actual TCP/IP header at the end of the buffer.
    //
    IP = (IPv6Header UNALIGNED *)((uchar *)Memory + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->NextHeader = IP_PROTOCOL_TCP;
    IP->HopLimit = TCPHopLimit(KATcb);
    IP->Source = KATcb->tcb_saddr;
    IP->Dest = KATcb->tcb_daddr;

    TCP = (TCPHeader UNALIGNED *)(IP + 1);
    TCP->tcp_src = KATcb->tcb_sport;
    TCP->tcp_dest = KATcb->tcb_dport;
    TempSeq = KATcb->tcb_senduna - 1;
    TCP->tcp_seq = net_long(TempSeq);
    TCP->tcp_ack = net_long(KATcb->tcb_rcvnext);
    TCP->tcp_flags = MAKE_TCP_FLAGS(5, TCP_FLAG_ACK);
    TempWin = (ushort)RcvWin(KATcb);
    TCP->tcp_window = net_short(TempWin);
    TCP->tcp_urgent = 0;

    //
    // Initialize the single byte that we're resending.
    // N.B. Adequate space for this byte was allocated above.
    //
    *(uchar *)(TCP + 1) = 0;

    TStats.ts_retranssegs++;

    PayloadLength = sizeof(TCPHeader) + 1;

    //
    // Compute the TCP checksum.  It covers the entire TCP segment
    // starting with the TCP header, plus the IPv6 pseudo-header.
    //
    TCP->tcp_xsum = 0;
    TCP->tcp_xsum = ChecksumPacket(
        Packet, Offset + sizeof *IP, NULL, PayloadLength,
        AlignAddr(&IP->Source), AlignAddr(&IP->Dest), IP_PROTOCOL_TCP);
    ASSERT(TCP->tcp_xsum != 0);

    //
    // Capture and reference the RCE while we still hold the TCB lock.
    // The TCB's reference on this particular RCE might go away at any
    // point after we release the lock.
    //
    RCE = KATcb->tcb_rce;
    AddRefRCE(RCE);

    //
    // Everything's ready.  Now send the packet.
    //
    // Note that IPv6Send does not return a status code.
    // Instead it *always* completes the packet
    // with an appropriate status code.
    //
    KATcb->tcb_kacount++;
    KeReleaseSpinLock(&KATcb->tcb_lock, PreLockIrql);

    IPv6Send(Packet, Offset, IP, PayloadLength, RCE, 0,
             IP_PROTOCOL_TCP,
             net_short(TCP->tcp_src),
             net_short(TCP->tcp_dest));

    //
    // Release the extra reference we took on the RCE above.
    //
    ReleaseRCE(RCE);
}


//* SendACK - Send an ACK segment.
//
//  This is called whenever we need to send an ACK for some reason.  Nothing
//  fancy, we just do it.
//
void              // Returns: Nothing.
SendACK(
    TCB *ACKTcb)  // TCB from which ACK is to be sent.
{
    PNDIS_PACKET Packet;
    void *Memory;
    IPv6Header UNALIGNED *IP;
    TCPHeader UNALIGNED *TCP;
    NDIS_STATUS NdisStatus;
    KIRQL OldIrql;
    int Offset;
    uint Length;
    uint PayloadLength;
    SeqNum SendNext;
    ushort TempWin;
    RouteCacheEntry *RCE;

    CHECK_STRUCT(ACKTcb, tcb);

    KeAcquireSpinLock(&ACKTcb->tcb_lock, &OldIrql);

    //
    // In most cases, we will already have a route at this point.
    // However, if we failed to get one earlier in the passive receive
    // path, we may need to retry here.
    //
    if (ACKTcb->tcb_rce == NULL) {
        InitRCE(ACKTcb);
        if (ACKTcb->tcb_rce == NULL) {
            KeReleaseSpinLock(&ACKTcb->tcb_lock, OldIrql);
            return;
        }

    }

    //
    // Validate that the address we're sourcing from and the route we're
    // sending upon are still okay to use.
    //
    if (ACKTcb->tcb_routing != RouteCacheValidationCounter) {
        if (!ValidateSourceAndRoute(ACKTcb)) {
            TryToCloseTCB(ACKTcb, TCB_CLOSE_ABORTED, OldIrql);
            return;
        }
    }

    //
    // Allocate a packet header/buffer/data region for this ACK packet.
    //
    // Our buffer has space at the beginning which will be filled in
    // later by the link level.  At this level we add the IPv6Header
    // and the TCPHeader.
    //
    // REVIEW: This grabs packets and buffers from the IPv6PacketPool and
    // REVIEW: the IPv6BufferPool respectively.  Have seperate pools for TCP?
    //
    Offset = ACKTcb->tcb_rce->NCE->IF->LinkHeaderSize;
    Length = Offset + sizeof(*IP) + sizeof(*TCP);
    NdisStatus = IPv6AllocatePacket(Length, &Packet, &Memory);
    if (NdisStatus != NDIS_STATUS_SUCCESS) {

        KeReleaseSpinLock(&ACKTcb->tcb_lock, OldIrql);

        //
        // REVIEW: What to do if this fails.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TCP SendACK: Couldn't allocate IPv6 packet header!?!\n"));
        return;
    }
    PC(Packet)->CompletionHandler = TCPSendComplete;
    PC(Packet)->CompletionData = NULL;


    //
    // Our header buffer has extra space for other headers to be
    // prepended to ours without requiring further allocation calls.
    // Put the actual TCP/IP header at the end of the buffer.
    //
    IP = (IPv6Header UNALIGNED *)((uchar *)Memory + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->NextHeader = IP_PROTOCOL_TCP;
    IP->HopLimit = TCPHopLimit(ACKTcb);
    IP->Source = ACKTcb->tcb_saddr;
    IP->Dest = ACKTcb->tcb_daddr;

    TCP = (TCPHeader UNALIGNED *)(IP + 1);
    TCP->tcp_src = ACKTcb->tcb_sport;
    TCP->tcp_dest = ACKTcb->tcb_dport;
    TCP->tcp_ack = net_long(ACKTcb->tcb_rcvnext);

    //
    // If the remote peer is advertising a window of zero, we need to send
    // this ack with a sequence number of his rcv_next (which in that case
    // should be our senduna).  We have code here ifdef'd out that makes
    // sure that we don't send outside the RWE, but this doesn't work.  We
    // need to be able to send a pure ACK exactly at the RWE.
    //
    if (ACKTcb->tcb_sendwin != 0) {
        SendNext = ACKTcb->tcb_sendnext;
#if 0
        SeqNum MaxValidSeq;

        MaxValidSeq = ACKTcb->tcb_senduna + ACKTcb->tcb_sendwin - 1;

        SendNext = (SEQ_LT(SendNext, MaxValidSeq) ? SendNext : MaxValidSeq);
#endif

    } else
        SendNext = ACKTcb->tcb_senduna;

    if ((ACKTcb->tcb_flags & FIN_SENT) &&
        SEQ_EQ(SendNext, ACKTcb->tcb_sendmax - 1)) {
        TCP->tcp_flags = MAKE_TCP_FLAGS(5, TCP_FLAG_FIN | TCP_FLAG_ACK);
    } else
        TCP->tcp_flags = MAKE_TCP_FLAGS(5, TCP_FLAG_ACK);

    TCP->tcp_seq = net_long(SendNext);
    TempWin = (ushort)RcvWin(ACKTcb);
    TCP->tcp_window = net_short(TempWin);
    TCP->tcp_urgent = 0;

    PayloadLength = sizeof(*TCP);

    //
    // Compute the TCP checksum.  It covers the entire TCP segment
    // starting with the TCP header, plus the IPv6 pseudo-header.
    //
    TCP->tcp_xsum = 0;
    TCP->tcp_xsum = ChecksumPacket(
        Packet, Offset + sizeof *IP, NULL, PayloadLength,
        AlignAddr(&IP->Source), AlignAddr(&IP->Dest), IP_PROTOCOL_TCP);
    ASSERT(TCP->tcp_xsum != 0);

    STOP_TCB_TIMER(ACKTcb->tcb_delacktimer);
    ACKTcb->tcb_flags &= ~(NEED_ACK | ACK_DELAYED);
    TStats.ts_outsegs++;

    //
    // Capture and reference the RCE while we still hold the TCB lock.
    // The TCB's reference on this particular RCE might go away at any point
    // after we release the lock (or because we drop it ourselves below).
    //
    RCE = ACKTcb->tcb_rce;
    AddRefRCE(RCE);

    //
    // If connection-acceptance has been delayed, release the TCB's RCE.
    // This prevents TCBs in pre-established states from consuming
    // an unbounded number of RCEs.
    //
    if (ACKTcb->tcb_flags & ACCEPT_PENDING) {
        ACKTcb->tcb_rce = NULL;
        ReleaseRCE(RCE);
    }

    //
    // Everything's ready.  Now send the packet.
    //
    // Note that IPv6Send does not return a status code.
    // Instead it *always* completes the packet
    // with an appropriate status code.
    //
    KeReleaseSpinLock(&ACKTcb->tcb_lock, OldIrql);

    IPv6Send(Packet, Offset, IP, PayloadLength, RCE, 0,
             IP_PROTOCOL_TCP,
             net_short(TCP->tcp_src),
             net_short(TCP->tcp_dest));

    //
    // Release the extra reference we took on the RCE above.
    //
    ReleaseRCE(RCE);
}


//* SendRSTFromTCB - Send a RST from a TCB.
//
//  This is called during close when we need to send a RST.
//
//  Called only when TCB is going away, so we have exclusive access.
//
void              // Returns: Nothing.
SendRSTFromTCB(
    TCB *RSTTcb)  // TCB from which RST is to be sent.
{
    PNDIS_PACKET Packet;
    void *Memory;
    IPv6Header UNALIGNED *IP;
    TCPHeader UNALIGNED *TCP;
    NDIS_STATUS NdisStatus;
    int Offset;
    uint Length;
    uint PayloadLength;
    SeqNum RSTSeq;

    CHECK_STRUCT(RSTTcb, tcb);

    ASSERT(RSTTcb->tcb_state == TCB_CLOSED);

    //
    // In most cases, we will already have a route at this point.
    // However, if we failed to get one earlier in the passive receive
    // path, we may need to retry here.
    //
    if (RSTTcb->tcb_rce == NULL) {
        InitRCE(RSTTcb);
        if (RSTTcb->tcb_rce == NULL) {
            return;
        }
    }

    //
    // Validate that the address we're sourcing from and the route we're
    // sending upon are still okay to use.
    //
    if (RSTTcb->tcb_routing != RouteCacheValidationCounter) {
        if (!ValidateSourceAndRoute(RSTTcb)) {
            return;
        }
    }

    //
    // Allocate a packet header/buffer/data region for this RST packet.
    //
    // Our buffer has space at the beginning which will be filled in
    // later by the link level.  At this level we add the IPv6Header
    // and the TCPHeader.
    //
    // REVIEW: This grabs packets and buffers from the IPv6PacketPool and
    // REVIEW: the IPv6BufferPool respectively.  Have seperate pools for TCP?
    //
    Offset = RSTTcb->tcb_rce->NCE->IF->LinkHeaderSize;
    Length = Offset + sizeof(*IP) + sizeof(*TCP);
    NdisStatus = IPv6AllocatePacket(Length, &Packet, &Memory);
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        //
        // REVIEW: What to do if this fails.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TCP SendRSTFromTCB: "
                   "Couldn't alloc IPv6 packet header!\n"));
        return;
    }
    PC(Packet)->CompletionHandler = TCPSendComplete;
    PC(Packet)->CompletionData = NULL;

    //
    // Since this is an RST-only packet we only have the one buffer and
    // nothing to link on after.
    //

    //
    // Our header buffer has extra space for other headers to be
    // prepended to ours without requiring further allocation calls.
    // Put the actual TCP/IP header at the end of the buffer.
    //
    IP = (IPv6Header UNALIGNED *)((uchar *)Memory + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->NextHeader = IP_PROTOCOL_TCP;
    IP->HopLimit = TCPHopLimit(RSTTcb);
    IP->Source = RSTTcb->tcb_saddr;
    IP->Dest = RSTTcb->tcb_daddr;

    TCP = (TCPHeader UNALIGNED *)(IP + 1);
    TCP->tcp_src = RSTTcb->tcb_sport;
    TCP->tcp_dest = RSTTcb->tcb_dport;

    //
    // If the remote peer has a window of 0, send with a seq. # equal
    // to senduna so he'll accept it.  Otherwise send with send max.
    //
    if (RSTTcb->tcb_sendwin != 0)
        RSTSeq = RSTTcb->tcb_sendmax;
    else
        RSTSeq = RSTTcb->tcb_senduna;

    TCP->tcp_seq = net_long(RSTSeq);
    TCP->tcp_ack = net_long(RSTTcb->tcb_rcvnext);
    TCP->tcp_flags = MAKE_TCP_FLAGS(5, TCP_FLAG_RST | TCP_FLAG_ACK);
    TCP->tcp_window = 0;
    TCP->tcp_urgent = 0;

    PayloadLength = sizeof(*TCP);

    //
    // Compute the TCP checksum.  It covers the entire TCP segment
    // starting with the TCP header, plus the IPv6 pseudo-header.
    //
    TCP->tcp_xsum = 0;
    TCP->tcp_xsum = ChecksumPacket(
        Packet, Offset + sizeof *IP, NULL, PayloadLength,
        AlignAddr(&IP->Source), AlignAddr(&IP->Dest), IP_PROTOCOL_TCP);
    ASSERT(TCP->tcp_xsum != 0);

    TStats.ts_outsegs++;
    TStats.ts_outrsts++;

    //
    // Everything's ready.  Now send the packet.
    //
    // Note that IPv6Send does not return a status code.
    // Instead it *always* completes the packet
    // with an appropriate status code.
    //
    IPv6Send(Packet, Offset, IP, PayloadLength, RSTTcb->tcb_rce, 0,
             IP_PROTOCOL_TCP,
             net_short(TCP->tcp_src),
             net_short(TCP->tcp_dest));
}


//* SendRSTFromHeader - Send a RST back, based on a header.
//
//  Called when we need to send a RST, but don't necessarily have a TCB.
//
void                               // Returns: Nothing.
SendRSTFromHeader(
    TCPHeader UNALIGNED *RecvTCP,  // TCP header to be RST.
    uint Length,                   // Length of the incoming segment.
    IPv6Addr *Dest,                // Destination IP address for RST.
    uint DestScopeId,              // Scope id for destination address.
    IPv6Addr *Src,                 // Source IP address for RST.
    uint SrcScopeId)               // Scope id for source address.
{
    PNDIS_PACKET Packet;
    void *Memory;
    IPv6Header UNALIGNED *IP;
    TCPHeader UNALIGNED *SendTCP;
    NetTableEntry *NTE;
    RouteCacheEntry *RCE;
    IP_STATUS Status;
    NDIS_STATUS NdisStatus;
    uint Offset;
    uint SendLength;
    uint PayloadLength;

    //
    // Never send a RST in response to a RST.
    //
    if (RecvTCP->tcp_flags & TCP_FLAG_RST)
        return;

    //
    // Determine NTE to send on based on incoming packet's destination.
    // REVIEW: Alternatively, we could/should just pass the NTE in.
    //
    NTE = FindNetworkWithAddress(Src, SrcScopeId);
    if (NTE == NULL) {
        //
        // This should only happen if the NTE became invalid 
        // between accepting the packet and getting here.  It
        // cannot completely go away since the packet's Packet 
        // structure holds a reference to it.
        //
        return;
    }

    //
    // Get the route to the destination (incoming packet's source).
    //
    Status = RouteToDestination(Dest, DestScopeId, CastFromNTE(NTE),
                                RTD_FLAG_NORMAL, &RCE);
    if (Status != IP_SUCCESS) {
        //
        // Failed to get a route to the destination.  Error out.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_INTERNAL_ERROR,
                   "TCP SendRSTFromHeader: Can't get a route?!?\n"));
        ReleaseNTE(NTE);
        return;
    }

    //
    // Allocate a packet header/buffer/data region for this RST packet.
    //
    // Our buffer has space at the beginning which will be filled in
    // later by the link level.  At this level we add the IPv6Header
    // and the TCPHeader.
    //
    // REVIEW: This grabs packets and buffers from the IPv6PacketPool and
    // REVIEW: the IPv6BufferPool respectively.  Have seperate pools for TCP?
    //
    Offset = RCE->NCE->IF->LinkHeaderSize;
    SendLength = Offset + sizeof(*IP) + sizeof(*SendTCP);
    NdisStatus = IPv6AllocatePacket(SendLength, &Packet, &Memory);
    if (NdisStatus != NDIS_STATUS_SUCCESS) {
        //
        // Failed to allocate a packet header/buffer/data region.  Error out.
        //
        KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                   "TCP SendRSTFromHeader: Couldn't alloc IPv6 pkt header!\n"));
        ReleaseRCE(RCE);
        ReleaseNTE(NTE);
        return;
    }
    PC(Packet)->CompletionHandler = TCPSendComplete;
    PC(Packet)->CompletionData = NULL;

    //
    // We now have all the resources we need to send.  Since this is a
    // RST-only packet we only have the one header buffer and nothing
    // to link on after.
    //

    //
    // Our header buffer has extra space for other headers to be
    // prepended to ours without requiring further allocation calls.
    // Put the actual TCP/IP header at the end of the buffer.
    //
    IP = (IPv6Header UNALIGNED *)((uchar *)Memory + Offset);
    IP->VersClassFlow = IP_VERSION;
    IP->NextHeader = IP_PROTOCOL_TCP;
    IP->HopLimit = (uchar)RCE->NCE->IF->CurHopLimit;
    IP->Source = *Src;
    IP->Dest = *Dest;

    //
    // Fill in the header so as to make it believable to our peer, and send it.
    //
    SendTCP = (TCPHeader UNALIGNED *)(IP + 1);
    if (RecvTCP->tcp_flags & TCP_FLAG_SYN)
        Length++;

    if (RecvTCP->tcp_flags & TCP_FLAG_FIN)
        Length++;

    if (RecvTCP->tcp_flags & TCP_FLAG_ACK) {
        SendTCP->tcp_seq = RecvTCP->tcp_ack;
        SendTCP->tcp_ack = 0;
        SendTCP->tcp_flags = MAKE_TCP_FLAGS(sizeof(TCPHeader)/sizeof(ulong),
                                            TCP_FLAG_RST);
    } else {
        SeqNum TempSeq;

        SendTCP->tcp_seq = 0;
        TempSeq = net_long(RecvTCP->tcp_seq);
        TempSeq += Length;
        SendTCP->tcp_ack = net_long(TempSeq);
        SendTCP->tcp_flags = MAKE_TCP_FLAGS(sizeof(TCPHeader)/sizeof(ulong),
                                            TCP_FLAG_RST | TCP_FLAG_ACK);
    }

    SendTCP->tcp_window = 0;
    SendTCP->tcp_urgent = 0;
    SendTCP->tcp_dest = RecvTCP->tcp_src;
    SendTCP->tcp_src = RecvTCP->tcp_dest;

    PayloadLength = sizeof(*SendTCP);

    //
    // Compute the TCP checksum.  It covers the entire TCP segment
    // starting with the TCP header, plus the IPv6 pseudo-header.
    //
    SendTCP->tcp_xsum = 0;
    SendTCP->tcp_xsum = ChecksumPacket(
        Packet, Offset + sizeof *IP, NULL, PayloadLength,
        AlignAddr(&IP->Source), AlignAddr(&IP->Dest), IP_PROTOCOL_TCP);
    ASSERT(SendTCP->tcp_xsum != 0);

    TStats.ts_outsegs++;
    TStats.ts_outrsts++;

    //
    // Everything's ready.  Now send the packet.
    //
    // Note that IPv6Send does not return a status code.
    // Instead it *always* completes the packet
    // with an appropriate status code.
    //
    IPv6Send(Packet, Offset, IP, PayloadLength, RCE, 0,
             IP_PROTOCOL_TCP,
             net_short(SendTCP->tcp_src),
             net_short(SendTCP->tcp_dest));

    //
    // Release the Route and the NTE.
    //
    ReleaseRCE(RCE);
    ReleaseNTE(NTE);
} // end of SendRSTFromHeader()


//* GoToEstab - Transition to the established state.
//
//  Called when we are going to the established state and need to finish up
//  initializing things that couldn't be done until now.  We assume the TCB
//  lock is held by the caller on the TCB we're called with.
//
void                // Returns: Nothing.
GoToEstab(
    TCB *EstabTCB)  // TCB to transition.
{

    //
    // Initialize our slow start and congestion control variables.
    //
    EstabTCB->tcb_cwin = 2 * EstabTCB->tcb_mss;
    EstabTCB->tcb_ssthresh = 0xffffffff;

    EstabTCB->tcb_state = TCB_ESTAB;

    //
    // We're in established.  We'll subtract one from slow count for this fact,
    // and if the slowcount goes to 0 we'll move onto the fast path.
    //
    if (--(EstabTCB->tcb_slowcount) == 0)
        EstabTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;

    InterlockedIncrement((PLONG)&TStats.ts_currestab);

    EstabTCB->tcb_flags &= ~ACTIVE_OPEN;  // Turn off the active opening flag.
}


//* InitSendState - Initialize the send state of a connection.
//
//  Called during connection establishment to initialize our send state.
//  (In this case, this refers to all information we'll put on the wire as
//  well as pure send state).  We pick an ISS, set up a rexmit timer value,
//  etc.  We assume the tcb_lock is held on the TCB when we are called.
//
void              // Returns: Nothing.
InitSendState(
    TCB *NewTCB)  // TCB to be set up.
{
    uint InitialRTT;
    CHECK_STRUCT(NewTCB, tcb);

    if (NewTCB->tcb_flags & ACTIVE_OPEN) {
        GetRandomISN(&NewTCB->tcb_sendnext, (uchar*)&NewTCB->tcb_md5data);
    }
    NewTCB->tcb_senduna = NewTCB->tcb_sendnext;
    NewTCB->tcb_sendmax = NewTCB->tcb_sendnext;
    NewTCB->tcb_error = IP_SUCCESS;

    //
    // Initialize retransmit and delayed ack stuff.
    //
    NewTCB->tcb_rexmitcnt = 0;
    NewTCB->tcb_rtt = 0;
    NewTCB->tcb_smrtt = 0;

    //
    // Check for interface specific initial RTT.
    // This can be as low as 3ms.
    //
    if ((NewTCB->tcb_rce != NULL) &&
        ((InitialRTT = GetInitialRTTFromRCE(NewTCB->tcb_rce)) > 
         MIN_INITIAL_RTT)) {
        NewTCB->tcb_delta = MS_TO_TICKS(InitialRTT * 2);
        NewTCB->tcb_rexmit = MS_TO_TICKS(InitialRTT);
    } else {
        NewTCB->tcb_delta = MS_TO_TICKS(6000);
        NewTCB->tcb_rexmit = MS_TO_TICKS(3000);
    }

    STOP_TCB_TIMER(NewTCB->tcb_rexmittimer);
    STOP_TCB_TIMER(NewTCB->tcb_delacktimer);
}


//* FillTCPHeader - Fill the TCP header in.
//
//  A utility routine to fill in the TCP header.
//
void  // Returns: Nothing.
FillTCPHeader(
    TCB *SendTCB,                 // TCB to fill from.
    TCPHeader UNALIGNED *Header)  // Header to fill into.
{
    ushort S;
    ulong L;

    Header->tcp_src = SendTCB->tcb_sport;
    Header->tcp_dest = SendTCB->tcb_dport;
    L = SendTCB->tcb_sendnext;
    Header->tcp_seq = net_long(L);
    L = SendTCB->tcb_rcvnext;
    Header->tcp_ack = net_long(L);
    Header->tcp_flags = 0x1050;
    *(ulong UNALIGNED *)&Header->tcp_xsum = 0;
    S = (ushort)RcvWin(SendTCB);
    Header->tcp_window = net_short(S);
    Header->tcp_urgent = 0;
}


//* TCPSend - Send data from a TCP connection.
//
//  This is the main 'send data' routine.  We go into a loop, trying
//  to send data until we can't for some reason.  First we compute
//  the useable window, use it to figure the amount we could send.  If
//  the amount we could send meets certain criteria we'll build a frame
//  and send it, after setting any appropriate control bits.  We assume
//  the caller has put a reference on the TCB.
//
void                    // Returns: Nothing.
TCPSend(
    TCB *SendTCB,       // TCB to be sent from.
    KIRQL PreLockIrql)  // IRQL prior to acquiring TCB lock.
{
    int SendWin;                              // Useable send window.
    uint AmountToSend;                        // Amount to send this time.
    uint AmountLeft;
    IPv6Header UNALIGNED *IP;
    TCPHeader UNALIGNED *TCP;
    PNDIS_PACKET Packet;
    PNDIS_BUFFER FirstBuffer, CurrentBuffer;
    void *Memory;
    TCPSendReq *CurSend;
    SendCmpltContext *SCC;
    SeqNum OldSeq;
    NDIS_STATUS NdisStatus;
    uint AmtOutstanding, AmtUnsent;
    int ForceWin;                             // Window we're forced to use.
    uint HeaderLength;
    uint LinkOffset;
    uint PMTU;
    RouteCacheEntry *RCE;

    CHECK_STRUCT(SendTCB, tcb);
    ASSERT(SendTCB->tcb_refcnt != 0);

    ASSERT(*(int *)&SendTCB->tcb_sendwin >= 0);
    ASSERT(*(int *)&SendTCB->tcb_cwin >= SendTCB->tcb_mss);

    ASSERT(!(SendTCB->tcb_flags & FIN_OUTSTANDING) ||
           (SendTCB->tcb_sendnext == SendTCB->tcb_sendmax));

    //
    // See if we should even be here.  If another instance of ourselves is
    // already in this code, or is about to enter it after completing a
    // receive, then just skip on out.
    //
    if ((SendTCB->tcb_flags & IN_TCP_SEND) ||
        (SendTCB->tcb_fastchk & TCP_FLAG_IN_RCV)) {
        SendTCB->tcb_flags |= SEND_AFTER_RCV;
        goto bail;
    }
    SendTCB->tcb_flags |= IN_TCP_SEND;

    //
    // In most cases, we will already have a route at this point.
    // However, if we failed to get one earlier in the passive receive
    // path, we may need to retry here.
    //
    if (SendTCB->tcb_rce == NULL) {
        InitRCE(SendTCB);
        if (SendTCB->tcb_rce == NULL) {
            SendTCB->tcb_flags &= ~IN_TCP_SEND;
            goto bail;
        }
    }

    //
    // Validate that the address we're sourcing from and the route we're
    // sending upon are still okay to use.
    //
    // We fail existing send requests for TCBs with a disconnected
    // outgoing interface, except when a loopback route is used.
    //
    if (SendTCB->tcb_routing != RouteCacheValidationCounter) {
        if (!ValidateSourceAndRoute(SendTCB) ||
            IsDisconnectedAndNotLoopbackRCE(SendTCB->tcb_rce)) {

            SendTCB->tcb_flags &= ~IN_TCP_SEND;
            ASSERT(SendTCB->tcb_refcnt != 0);
            TryToCloseTCB(SendTCB, TCB_CLOSE_ABORTED, PreLockIrql);
            KeAcquireSpinLock(&SendTCB->tcb_lock, &PreLockIrql);
            goto bail;
        }
    }
    
    //
    // Verify that our cached Path MTU is still valid.
    // Watch for changes to IPsec policies since they can also effect our MSS.
    // REVIEW: This the best spot to do this?
    //
    PMTU = GetEffectivePathMTUFromRCE(SendTCB->tcb_rce);
    if (PMTU != SendTCB->tcb_pmtu ||
        SecurityStateValidationCounter != SendTCB->tcb_security) {
        //
        // Either our Path MTU or the global security state has changed.
        // Cache current values and then calculate a new MSS.
        //
        SendTCB->tcb_pmtu = PMTU;
        SendTCB->tcb_security = SecurityStateValidationCounter;
        CalculateMSSForTCB(SendTCB);
    }

    //
    // We'll continue this loop until we send a FIN, or we break out
    // internally for some other reason.
    //
    while (!(SendTCB->tcb_flags & FIN_OUTSTANDING)) {

        CheckTCBSends(SendTCB);

        AmtOutstanding = (uint)(SendTCB->tcb_sendnext - SendTCB->tcb_senduna);
        AmtUnsent = SendTCB->tcb_unacked - AmtOutstanding;

        ASSERT(*(int *)&AmtUnsent >= 0);

        SendWin = (int)(MIN(SendTCB->tcb_sendwin, SendTCB->tcb_cwin) -
                        AmtOutstanding);

        //
        // If this send is after a fast recovery and sendwin is zero because
        // of amount outstanding, then at least force 1 segment to prevent
        // delayed ack timeouts from peer.
        //
        if (SendTCB->tcb_force) {
            SendTCB->tcb_force = 0;
            if (SendWin < SendTCB->tcb_mss) {
                SendWin = SendTCB->tcb_mss;
            }
        }

        //
        // Since the window could have shrank, need to get it to zero at
        // least.
        //
        ForceWin = (int)((SendTCB->tcb_flags & FORCE_OUTPUT) >>
                         FORCE_OUT_SHIFT);
        SendWin = MAX(SendWin, ForceWin);

        AmountToSend = MIN(MIN((uint)SendWin, AmtUnsent), SendTCB->tcb_mss);

        ASSERT(SendTCB->tcb_mss > 0);

        //
        // See if we have enough to send.  We'll send if we have at least a
        // segment, or if we really have some data to send and we can send
        // all that we have, or the send window is > 0 and we need to force
        // output or send a FIN (note that if we need to force output
        // SendWin will be at least 1 from the check above), or if we can
        // send an amount == to at least half the maximum send window
        // we've seen.
        //
        if (AmountToSend == SendTCB->tcb_mss ||
            (AmountToSend != 0 && AmountToSend == AmtUnsent) ||
            (SendWin != 0 &&
             (((SendTCB->tcb_flags & FIN_NEEDED) &&
               AmtUnsent <= SendTCB->tcb_mss) ||
              (SendTCB->tcb_flags & FORCE_OUTPUT) ||
              AmountToSend >= (SendTCB->tcb_maxwin / 2)))) {

            //
            // It's OK to send something.  Allocate a packet header.
            //
            // REVIEW: It was easier to code all these allocations directly
            // REVIEW: rather than use IPv6AllocatePacket.
            //
            // REVIEW: This grabs packets and buffers from the IPv6PacketPool
            // REVIEW: and the IPv6BufferPool respectively.  Should we instead
            // REVIEW: have separate pools for TCP?
            //
            NdisAllocatePacket(&NdisStatus, &Packet, IPv6PacketPool);
            if (NdisStatus != NDIS_STATUS_SUCCESS) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "TCPSend: couldn't allocate packet header!?!\n"));
                goto error_oor;
            }

            // We'll fill in the CompletionData below.
            InitializeNdisPacket(Packet);
            PC(Packet)->CompletionHandler = TCPSendComplete;

            //
            // Our header buffer has extra space at the beginning for other
            // headers to be prepended to ours without requiring further
            // allocation calls.  It also has extra space at the end to hold
            // the send completion data.
            //
            LinkOffset = SendTCB->tcb_rce->NCE->IF->LinkHeaderSize;
            HeaderLength =
                (LinkOffset + sizeof(*IP) + sizeof(*TCP) +
                    sizeof(SendCmpltContext) +
                    __builtin_alignof(SendCmpltContext) - 1) &~
                (UINT_PTR)(__builtin_alignof(SendCmpltContext) - 1);
            Memory = ExAllocatePool(NonPagedPool, HeaderLength);
            if (Memory == NULL) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "TCPSend: couldn't allocate header memory!?!\n"));
                NdisFreePacket(Packet);
                goto error_oor;
            }

            //
            // When allocating the NDIS buffer describing this memory region,
            // we don't tell it about the extra space on the end that we
            // allocated for the send completion data.
            //
            NdisAllocateBuffer(&NdisStatus, &FirstBuffer, IPv6BufferPool,
                               Memory, LinkOffset + sizeof(*IP) + sizeof(*TCP));
            if (NdisStatus != NDIS_STATUS_SUCCESS) {
                KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                           "TCPSend: couldn't allocate buffer!?!\n"));
                ExFreePool(Memory);
                NdisFreePacket(Packet);
                goto error_oor;
            }

            //
            // Skip over the extra space that will be filled in later by the
            // link level.  At this level we add the IPv6Header, the
            // TCPHeader, and the data.
            //
            IP = (IPv6Header UNALIGNED *)((uchar *)Memory + LinkOffset);
            IP->VersClassFlow = IP_VERSION;
            IP->NextHeader = IP_PROTOCOL_TCP;
            IP->HopLimit = TCPHopLimit(SendTCB);
            IP->Source = SendTCB->tcb_saddr;
            IP->Dest = SendTCB->tcb_daddr;

            //
            // Begin preparing the TCP header.
            //
            TCP = (TCPHeader UNALIGNED *)(IP + 1);
            FillTCPHeader(SendTCB, TCP);

            //
            // Store the send completion data in the same buffer as the TCP
            // header, right after the TCP header.  This saves allocation
            // overhead and works because we don't consider this area to be
            // part of the packet data (we set this buffer's length to
            // indicate that the data ends with the TCP header above).
            //
            // Note that this code relies on the fact that we don't include
            // any TCP options (and thus don't have a variable length TCP
            // header) in our data packets.
            //
            SCC = (SendCmpltContext *)((uchar *)Memory + HeaderLength -
                                       sizeof(*SCC));
            PC(Packet)->CompletionData = SCC;
#if DBG
            SCC->scc_sig = scc_signature;
#endif
            SCC->scc_ubufcount = 0;
            SCC->scc_tbufcount = 0;
            SCC->scc_count = 0;

            AmountLeft = AmountToSend;

            if (AmountToSend != 0) {
                long Result;

                //
                // Loop through the sends on the TCB, building a frame.
                //
                CurrentBuffer = FirstBuffer;
                CurSend = SendTCB->tcb_cursend;
                CHECK_STRUCT(CurSend, tsr);
                SCC->scc_firstsend = CurSend;

                do {
                    ASSERT(CurSend->tsr_refcnt > 0);
                    Result = InterlockedIncrement(&(CurSend->tsr_refcnt));

                    ASSERT(Result > 0);

                    SCC->scc_count++;
                    //
                    // If the current send offset is 0 and the current
                    // send is less than or equal to what we have left
                    // to send, we haven't already put a transport
                    // buffer on this send, and nobody else is using
                    // the buffer chain directly, just use the input
                    // buffers.  We check for other people using them
                    // by looking at tsr_lastbuf.  If it's NULL,
                    // nobody else is using the buffers.  If it's not
                    // NULL, somebody is.
                    //
                    if (SendTCB->tcb_sendofs == 0 &&
                        (SendTCB->tcb_sendsize <= AmountLeft) &&
                        (SCC->scc_tbufcount == 0) &&
                        CurSend->tsr_lastbuf == NULL) {

                        PNDIS_BUFFER LastBuf = SendTCB->tcb_sendbuf;
                        uint UBufLength = NdisBufferLength(LastBuf);
                        ushort UBufCount = 1;
    
                        while (NDIS_BUFFER_LINKAGE(LastBuf) != NULL) {
                            LastBuf = NDIS_BUFFER_LINKAGE(LastBuf);
                            UBufLength += NdisBufferLength(LastBuf);
                            UBufCount++;
                        }
    
                        if (SendTCB->tcb_sendsize == UBufLength) {
                            SCC->scc_ubufcount += UBufCount;
                            NDIS_BUFFER_LINKAGE(CurrentBuffer) =
                                SendTCB->tcb_sendbuf;
                            CurSend->tsr_lastbuf = CurrentBuffer = LastBuf;
                            AmountLeft -= SendTCB->tcb_sendsize;
                            SendTCB->tcb_sendsize = 0;
                        } else {
                            //
                            // Fall through with a non-zero tcb_sendsize.
                            //
                            ASSERT(SendTCB->tcb_sendsize != 0);
                        }
                    }

                    if (SendTCB->tcb_sendsize != 0) {
                        uint AmountToDup;
                        PNDIS_BUFFER NewBuf, Buf;
                        uint Offset;
                        NDIS_STATUS NStatus;
                        uchar *VirtualAddress;
                        uint Length;

                        //
                        // Either the current send has more data than
                        // we want to send, or the starting offset is
                        // not 0.  In either case we'll need to loop
                        // through the current send, allocating
                        // buffers.
                        //
                        Buf = SendTCB->tcb_sendbuf;
                        Offset = SendTCB->tcb_sendofs;

                        do {
                            ASSERT(Buf != NULL);

                            NdisQueryBufferSafe(Buf, &VirtualAddress, &Length,
                                                LowPagePriority);
                            if (VirtualAddress == NULL) {
                                //
                                // Couldn't map into kernel address space.
                                // If the packet is already partly built,
                                // send what we've got, otherwise error out.
                                //
                                goto error_oor2;
                            }

                            ASSERT((Offset < Length) ||
                                   (Offset == 0 && Length == 0));

                            //
                            // Adjust the length for the offset into
                            // this buffer.
                            //
                            Length -= Offset;

                            AmountToDup = MIN(AmountLeft, Length);

                            NdisAllocateBuffer(&NStatus, &NewBuf,
                                               IPv6BufferPool,
                                               VirtualAddress + Offset,
                                               AmountToDup);
                            if (NStatus == NDIS_STATUS_SUCCESS) {
                                SCC->scc_tbufcount++;

                                NDIS_BUFFER_LINKAGE(CurrentBuffer) = NewBuf;

                                CurrentBuffer = NewBuf;
                                if (AmountToDup >= Length) {
                                    // Exhausted this buffer.
                                    Buf = NDIS_BUFFER_LINKAGE(Buf);
                                    Offset = 0;
                                } else {
                                    Offset += AmountToDup;
                                    ASSERT(Offset < NdisBufferLength(Buf));
                                }

                                SendTCB->tcb_sendsize -= AmountToDup;
                                AmountLeft -= AmountToDup;
                            } else {
                                //
                                // Couldn't allocate a buffer.  If
                                // the packet is already partly built,
                                // send what we've got, otherwise
                                // error out.
                                //
                            error_oor2:
                                if (SCC->scc_tbufcount == 0 &&
                                    SCC->scc_ubufcount == 0) {
                                    NdisChainBufferAtFront(Packet, FirstBuffer);
                                    TCPSendComplete(Packet, IP_GENERAL_FAILURE);
                                    goto error_oor;
                                }
                                AmountToSend -= AmountLeft;
                                AmountLeft = 0;
                                break;
                            }
                        } while (AmountLeft && SendTCB->tcb_sendsize);

                        SendTCB->tcb_sendbuf = Buf;
                        SendTCB->tcb_sendofs = Offset;
                    }

                    if (CurSend->tsr_flags & TSR_FLAG_URG) {
                        ushort UP;
                        //
                        // This send is urgent data.  We need to figure
                        // out what the urgent data pointer should be.
                        // We know sendnext is the starting sequence
                        // number of the frame, and that at the top of
                        // this do loop sendnext identified a byte in
                        // the CurSend at that time.  We advanced CurSend
                        // at the same rate we've decremented
                        // AmountLeft (AmountToSend - AmountLeft ==
                        // AmountBuilt), so sendnext +
                        // (AmountToSend - AmountLeft) identifies a byte
                        // in the current value of CurSend, and that
                        // quantity plus tcb_sendsize is the sequence
                        // number one beyond the current send.
                        //
                        UP = (ushort)(AmountToSend - AmountLeft) +
                            (ushort)SendTCB->tcb_sendsize -
                            ((SendTCB->tcb_flags & BSD_URGENT) ? 0 : 1);

                        TCP->tcp_urgent = net_short(UP);
                        TCP->tcp_flags |= TCP_FLAG_URG;
                    }

                    //
                    // See if we've exhausted this send.  If we have,
                    // set the PUSH bit in this frame and move on to
                    // the next send.  We also need to check the
                    // urgent data bit.
                    //
                    if (SendTCB->tcb_sendsize == 0) {
                        Queue *Next;
                        uchar PrevFlags;

                        //
                        // We've exhausted this send.  Set the PUSH bit.
                        //
                        TCP->tcp_flags |= TCP_FLAG_PUSH;
                        PrevFlags = CurSend->tsr_flags;
                        Next = QNEXT(&CurSend->tsr_req.tr_q);
                        if (Next != QEND(&SendTCB->tcb_sendq)) {
                            CurSend = CONTAINING_RECORD(
                                QSTRUCT(TCPReq, Next, tr_q),
                                TCPSendReq, tsr_req);
                            CHECK_STRUCT(CurSend, tsr);
                            SendTCB->tcb_sendsize = CurSend->tsr_unasize;
                            SendTCB->tcb_sendofs = CurSend->tsr_offset;
                            SendTCB->tcb_sendbuf = CurSend->tsr_buffer;
                            SendTCB->tcb_cursend = CurSend;

                            //
                            // Check the urgent flags.  We can't combine new
                            // urgent data on to the end of old non-urgent
                            // data.
                            //
                            if ((PrevFlags & TSR_FLAG_URG) &&
                                !(CurSend->tsr_flags & TSR_FLAG_URG))
                                break;
                        } else {
                            ASSERT(AmountLeft == 0);
                            SendTCB->tcb_cursend = NULL;
                            SendTCB->tcb_sendbuf = NULL;
                        }
                    }
                } while (AmountLeft != 0);

            } else {
                //
                // We're in the loop, but AmountToSend is 0.  This
                // should happen only when we're sending a FIN.  Check
                // this, and return if it's not true.
                //
                ASSERT(AmtUnsent == 0);
                if (!(SendTCB->tcb_flags & FIN_NEEDED)) {
                    // KdBreakPoint();
                    ExFreePool(NdisBufferVirtualAddress(FirstBuffer));
                    NdisFreeBuffer(FirstBuffer);
                    NdisFreePacket(Packet);
                    break;
                }

                SCC->scc_firstsend = NULL;  // REVIEW: looks unneccessary.
                NDIS_BUFFER_LINKAGE(FirstBuffer) = NULL;
            }

            // Adjust for what we're really going to send.
            AmountToSend -= AmountLeft;

            //
            // Update the sequence numbers, and start a RTT measurement
            // if needed.
            //
            OldSeq = SendTCB->tcb_sendnext;
            SendTCB->tcb_sendnext += AmountToSend;

            if (!SEQ_EQ(OldSeq, SendTCB->tcb_sendmax)) {
                //
                // We have at least some retransmission.  Bump the stat.
                //
                TStats.ts_retranssegs++;
            }

            if (SEQ_GT(SendTCB->tcb_sendnext, SendTCB->tcb_sendmax)) {
                //
                // We're sending at least some new data.
                // We can't advance sendmax once FIN_SENT is set.
                //
                ASSERT(!(SendTCB->tcb_flags & FIN_SENT));
                SendTCB->tcb_sendmax = SendTCB->tcb_sendnext;
                TStats.ts_outsegs++;

                //
                // Check the Round-Trip Timer.
                //
                if (SendTCB->tcb_rtt == 0) {
                    // No RTT running, so start one.
                    SendTCB->tcb_rtt = TCPTime;
                    SendTCB->tcb_rttseq = OldSeq;
                }
            }

            //
            // We've built the frame entirely.  If we've sent everything
            // we have and there's a FIN pending, OR it in.
            //
            if (AmtUnsent == AmountToSend) {
                if (SendTCB->tcb_flags & FIN_NEEDED) {
                    ASSERT(!(SendTCB->tcb_flags & FIN_SENT) ||
                           (SendTCB->tcb_sendnext ==
                            (SendTCB->tcb_sendmax - 1)));
                    //
                    // See if we still have room in the window for a FIN.
                    //
                    if (SendWin > (int) AmountToSend) {
                        TCP->tcp_flags |= TCP_FLAG_FIN;
                        SendTCB->tcb_sendnext++;
                        SendTCB->tcb_sendmax = SendTCB->tcb_sendnext;
                        SendTCB->tcb_flags |= (FIN_SENT | FIN_OUTSTANDING);
                        SendTCB->tcb_flags &= ~FIN_NEEDED;
                    }
                }
            }

            AmountToSend += sizeof(TCPHeader);

            if (!TCB_TIMER_RUNNING(SendTCB->tcb_rexmittimer))
                START_TCB_TIMER(SendTCB->tcb_rexmittimer, SendTCB->tcb_rexmit);

            SendTCB->tcb_flags &= ~(NEED_ACK | ACK_DELAYED | FORCE_OUTPUT);
            STOP_TCB_TIMER(SendTCB->tcb_delacktimer);
            STOP_TCB_TIMER(SendTCB->tcb_swstimer);
            SendTCB->tcb_alive = TCPTime;

            // Add the buffers to the packet.
            NdisChainBufferAtFront(Packet, FirstBuffer);

            //
            // Compute the TCP checksum.  It covers the entire TCP segment
            // starting with the TCP header, plus the IPv6 pseudo-header.
            //
            TCP->tcp_xsum = 0;
            TCP->tcp_xsum = ChecksumPacket(
                Packet, LinkOffset + sizeof *IP, NULL, AmountToSend,
                AlignAddr(&IP->Source), AlignAddr(&IP->Dest), IP_PROTOCOL_TCP);

            //
            // Capture and reference the RCE while we still hold the TCB lock.
            // The TCB's reference on this particular RCE might go away at any
            // point after we release the lock.
            //
            RCE = SendTCB->tcb_rce;
            AddRefRCE(RCE);

            //
            // Everything's ready.  Now send the packet.
            //
            // Note that IPv6Send does not return a status code.
            // Instead it *always* completes the packet
            // with an appropriate status code.
            //
            KeReleaseSpinLock(&SendTCB->tcb_lock, PreLockIrql);

            if (TCP->tcp_xsum == 0) {
                //
                // ChecksumPacket failed, so abort the transmission.
                //
                IPv6SendComplete(NULL, Packet, IP_NO_RESOURCES);

            } else {
                IPv6Send(Packet, LinkOffset, IP,
                         AmountToSend, RCE, 0,
                         IP_PROTOCOL_TCP,
                         net_short(TCP->tcp_src),
                         net_short(TCP->tcp_dest));
            }

            ReleaseRCE(RCE);
            KeAcquireSpinLock(&SendTCB->tcb_lock, &PreLockIrql);
            continue;
        } else {
            //
            // We've decided we can't send anything now.  Figure out why, and
            // see if we need to set a timer.
            //
            if (SendTCB->tcb_sendwin == 0) {
                if (!(SendTCB->tcb_flags & FLOW_CNTLD)) {
                    SendTCB->tcb_flags |= FLOW_CNTLD;
                    SendTCB->tcb_rexmitcnt = 0;
                    START_TCB_TIMER(SendTCB->tcb_rexmittimer,
                                    SendTCB->tcb_rexmit);
                    SendTCB->tcb_slowcount++;
                    SendTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                } else
                    if (!TCB_TIMER_RUNNING(SendTCB->tcb_rexmittimer))
                        START_TCB_TIMER(SendTCB->tcb_rexmittimer,
                                        SendTCB->tcb_rexmit);
            } else
                if (AmountToSend != 0)
                    // We have something to send, but we're not sending
                    // it, presumably due to SWS avoidance.
                    if (!TCB_TIMER_RUNNING(SendTCB->tcb_swstimer))
                        START_TCB_TIMER(SendTCB->tcb_swstimer, SWS_TO);

            break;
        }
    } // while (!FIN_OUTSTANDING)

    //
    // We're done sending, so we don't need the output flags set.
    //
    SendTCB->tcb_flags &= ~(IN_TCP_SEND | NEED_OUTPUT | FORCE_OUTPUT |
                            SEND_AFTER_RCV);
  bail:
    DerefTCB(SendTCB, PreLockIrql);
    return;

//
// Common case error handling code for out of resource conditions.  Start the
// retransmit timer if it's not already running (so that we try this again
// later), clean up and return.
//
  error_oor:
    if (!TCB_TIMER_RUNNING(SendTCB->tcb_rexmittimer))
        START_TCB_TIMER(SendTCB->tcb_rexmittimer, SendTCB->tcb_rexmit);

    // We had an out of resource problem, so clear the OUTPUT flags.
    SendTCB->tcb_flags &= ~(IN_TCP_SEND | NEED_OUTPUT | FORCE_OUTPUT);
    DerefTCB(SendTCB, PreLockIrql);
    return;
} // end of TCPSend()


//* ResetSendNextAndFastSend - Set the sendnext value of a TCB.
//
//  Called to fast retransmit the dropped segment.
//
//  We assume the caller has put a reference on the TCB, and the TCB is locked
//  on entry. The reference is dropped and the lock released before returning.
//
void  // Returns: Nothing.
ResetAndFastSend(
    TCB *SeqTCB,    // TCB for this connection.
    SeqNum NewSeq,  // Sequence number to set.
    uint NewCWin)   // New value for congestion window.
{
    TCPSendReq      *SendReq;
    Queue           *CurQ;
    PNDIS_BUFFER    Buffer;
    uint            Offset;
    uint            SendSize;

    CHECK_STRUCT(SeqTCB, tcb);
    ASSERT(SEQ_GTE(NewSeq, SeqTCB->tcb_senduna));

    //
    // The new seq must be less than send max, or NewSeq, senduna, sendnext,
    // and sendmax must all be equal. (The latter case happens when we're
    // called exiting TIME_WAIT, or possibly when we're retransmitting
    // during a flow controlled situation).
    //
    ASSERT(SEQ_LT(NewSeq, SeqTCB->tcb_sendmax) ||
           (SEQ_EQ(SeqTCB->tcb_senduna, SeqTCB->tcb_sendnext) &&
            SEQ_EQ(SeqTCB->tcb_senduna, SeqTCB->tcb_sendmax) &&
            SEQ_EQ(SeqTCB->tcb_senduna, NewSeq)));

    if (SYNC_STATE(SeqTCB->tcb_state) &&
        (SeqTCB->tcb_state != TCB_TIME_WAIT)) {

        if (!EMPTYQ(&SeqTCB->tcb_sendq)) {

            CurQ = QHEAD(&SeqTCB->tcb_sendq);

            SendReq = (TCPSendReq *) CONTAINING_RECORD(CurQ, TCPReq, tr_q);

            //
            // SendReq points to the first send request on the send queue.
            // We're pointing at the proper send req now.  We need to go down.
            //
            // SendReq points to the cursend.
            // SendSize point to sendsize in the cursend.
            //
            SendSize = SendReq->tsr_unasize;

            Buffer = SendReq->tsr_buffer;
            Offset = SendReq->tsr_offset;

            // Call the fast retransmit send now.
            TCPFastSend(SeqTCB, Buffer, Offset, SendReq, SendSize, NewSeq,
                        SeqTCB->tcb_mss);
        } else {
            ASSERT(SeqTCB->tcb_cursend == NULL);
        }
    }
    SeqTCB->tcb_cwin = NewCWin;
    DerefTCB(SeqTCB, DISPATCH_LEVEL);
    return;
}


//* TCPFastSend - To send a segment without changing TCB state.
//
//  Called to handle fast retransmit of the lost segment.
//  tcb_lock will be held while entering (called by TCPRcv).
//
void  // Returns: Nothing.
TCPFastSend(
    TCB *SendTCB,             // TCB for this connection.
    PNDIS_BUFFER in_SendBuf,  // NDIS buffer.
    uint SendOfs,             // Send offset.
    TCPSendReq *CurSend,      // Current send request.
    uint SendSize,            // Size of this send.
    SeqNum SendNext,          // Sequence number to use for this send.
    int in_ToBeSent)          // Cap on SendSize (REVIEW: Callee should cap).
{
    uint AmountToSend;                        // Amount to send this time.
    uint AmountLeft;
    IPv6Header UNALIGNED *IP;
    TCPHeader UNALIGNED *TCP;
    PNDIS_PACKET Packet;
    PNDIS_BUFFER FirstBuffer, CurrentBuffer;
    void *Memory;
    SendCmpltContext *SCC;
    NDIS_STATUS NdisStatus;
    uint AmtOutstanding, AmtUnsent;
    uint HeaderLength;
    uint LinkOffset;
    uint PMTU;
    KIRQL PreLockIrql;
    PNDIS_BUFFER SendBuf = in_SendBuf;
    RouteCacheEntry *RCE;

    PreLockIrql = DISPATCH_LEVEL;

    CHECK_STRUCT(SendTCB, tcb);
    ASSERT(SendTCB->tcb_refcnt != 0);

    ASSERT(*(int *)&SendTCB->tcb_sendwin >= 0);
    ASSERT(*(int *)&SendTCB->tcb_cwin >= SendTCB->tcb_mss);

    ASSERT(!(SendTCB->tcb_flags & FIN_OUTSTANDING) ||
              (SendTCB->tcb_sendnext == SendTCB->tcb_sendmax));

    //
    // In most cases, we will already have a route at this point.
    // However, if we failed to get one earlier in the passive receive
    // path, we may need to retry here.
    //
    if (SendTCB->tcb_rce == NULL) {
        InitRCE(SendTCB);
        if (SendTCB->tcb_rce == NULL) {
            DerefTCB(SendTCB, PreLockIrql);
            return;
        }
    }

    //
    // Validate that the address we're sourcing from and the route we're
    // sending upon are still okay to use.
    //
    // We fail existing send requests for TCBs with a disconnected
    // outgoing interface, except when a loopback route is used.
    //
    if (SendTCB->tcb_routing != RouteCacheValidationCounter) {
        if (!ValidateSourceAndRoute(SendTCB) ||
            IsDisconnectedAndNotLoopbackRCE(SendTCB->tcb_rce)) {

            ASSERT(SendTCB->tcb_refcnt != 0);
            TryToCloseTCB(SendTCB, TCB_CLOSE_ABORTED, PreLockIrql);
            KeAcquireSpinLock(&SendTCB->tcb_lock, &PreLockIrql);
            DerefTCB(SendTCB, PreLockIrql);
            return;
        }
    }
    
    //
    // Verify that our cached Path MTU is still valid.
    // Watch for changes to IPsec policies since they can also effect our MSS.
    // REVIEW: This the best spot to do this?
    //
    PMTU = GetEffectivePathMTUFromRCE(SendTCB->tcb_rce);
    if (PMTU != SendTCB->tcb_pmtu ||
        SecurityStateValidationCounter != SendTCB->tcb_security) {
        //
        // Either our Path MTU or the global security state has changed.
        // Cache current values and then calculate a new MSS.
        //
        SendTCB->tcb_pmtu = PMTU;
        SendTCB->tcb_security = SecurityStateValidationCounter;
        CalculateMSSForTCB(SendTCB);
    }

    AmtOutstanding = (uint)(SendTCB->tcb_sendnext - SendTCB->tcb_senduna);
    AmtUnsent = MIN(MIN(in_ToBeSent, (int)SendSize),
                    (int)SendTCB->tcb_sendwin);

    while (AmtUnsent > 0) {

        if (SEQ_GT(SendTCB->tcb_senduna, SendNext)) {
            //
            // Since tcb_lock is released in this loop
            // it is possible that delayed ack acked
            // what we are trying to retransmit.
            //
            goto error_oor;
        }

        // AmtUnsent below was minimum of sendwin and amtunsent
        AmountToSend = MIN(AmtUnsent, SendTCB->tcb_mss);

        ASSERT((int)AmtUnsent >= 0);

        //
        // We're going to send something.  Allocate a packet header.
        //
        // REVIEW: It was easier to code all these allocations directly
        // REVIEW: rather than use IPv6AllocatePacket.
        //
        // REVIEW: This grabs packets and buffers from the IPv6PacketPool
        // REVIEW: and the IPv6BufferPool respectively.  Should we instead
        // REVIEW: have separate pools for TCP?
        //
        NdisAllocatePacket(&NdisStatus, &Packet, IPv6PacketPool);
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "TCPSend: couldn't allocate packet header!?!\n"));
            goto error_oor;
        }

        // We'll fill in the CompletionData below.
        InitializeNdisPacket(Packet);
        PC(Packet)->CompletionHandler = TCPSendComplete;

        //
        // Our header buffer has extra space at the beginning for other
        // headers to be prepended to ours without requiring further
        // allocation calls.  It also has extra space at the end to hold
        // the send completion data.
        //
        LinkOffset = SendTCB->tcb_rce->NCE->IF->LinkHeaderSize;
        HeaderLength = (LinkOffset + sizeof(*IP) + sizeof(*TCP) +
                        sizeof(SendCmpltContext) +
                        __builtin_alignof(SendCmpltContext) - 1) &~
            (UINT_PTR)(__builtin_alignof(SendCmpltContext) - 1);
        Memory = ExAllocatePool(NonPagedPool, HeaderLength);
        if (Memory == NULL) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "TCPSend: couldn't allocate header memory!?!\n"));
            NdisFreePacket(Packet);
            goto error_oor;
        }

        //
        // When allocating the NDIS buffer describing this memory region,
        // we don't tell it about the extra space on the end that we
        // allocated for the send completion data.
        //
        NdisAllocateBuffer(&NdisStatus, &FirstBuffer, IPv6BufferPool,
                           Memory, LinkOffset + sizeof(*IP) + sizeof(*TCP));
        if (NdisStatus != NDIS_STATUS_SUCCESS) {
            KdPrintEx((DPFLTR_TCPIP6_ID, DPFLTR_NTOS_ERROR,
                       "TCPSend: couldn't allocate buffer!?!\n"));
            ExFreePool(Memory);
            NdisFreePacket(Packet);
            goto error_oor;
        }

        //
        // Skip over the extra space that will be filled in later by the
        // link level.  At this level we add the IPv6Header, the
        // TCPHeader, and the data.
        //
        IP = (IPv6Header UNALIGNED *)((uchar *)Memory + LinkOffset);
        IP->VersClassFlow = IP_VERSION;
        IP->NextHeader = IP_PROTOCOL_TCP;
        IP->HopLimit = TCPHopLimit(SendTCB);
        IP->Source = SendTCB->tcb_saddr;
        IP->Dest = SendTCB->tcb_daddr;

        //
        // Begin preparing the TCP header.
        //
        TCP = (TCPHeader UNALIGNED *)(IP + 1);
        FillTCPHeader(SendTCB, TCP);
        TCP->tcp_seq = net_long(SendNext);

        //
        // Store the send completion data in the same buffer as the TCP
        // header, right after the TCP header.  This saves allocation
        // overhead and works because we don't consider this area to be
        // part of the packet data (we set this buffer's length to
        // indicate that the data ends with the TCP header above).
        //
        // Note that this code relies on the fact that we don't include
        // any TCP options (and thus don't have a variable length TCP
        // header) in our data packets.
        //
        SCC = (SendCmpltContext *)((uchar *)Memory + HeaderLength -
                                   sizeof(*SCC));
        PC(Packet)->CompletionData = SCC;
#if DBG
        SCC->scc_sig = scc_signature;
#endif
        SCC->scc_ubufcount = 0;
        SCC->scc_tbufcount = 0;
        SCC->scc_count = 0;

        AmountLeft = AmountToSend;

        if (AmountToSend != 0) {
            long Result;

            //
            // Loop through the sends on the TCB, building a frame.
            //
            CurrentBuffer = FirstBuffer;
            CHECK_STRUCT(CurSend, tsr);
            SCC->scc_firstsend = CurSend;

            do {
                ASSERT(CurSend->tsr_refcnt > 0);
                Result = InterlockedIncrement(&(CurSend->tsr_refcnt));

                ASSERT(Result > 0);

                SCC->scc_count++;

                //
                // If the current send offset is 0 and the current
                // send is less than or equal to what we have left
                // to send, we haven't already put a transport
                // buffer on this send, and nobody else is using
                // the buffer chain directly, just use the input
                // buffers. We check for other people using them
                // by looking at tsr_lastbuf. If it's NULL,
                // nobody else is using the buffers. If it's not
                // NULL, somebody is.
                //
                if (SendOfs == 0 &&
                    (SendSize <= AmountLeft) &&
                    (SCC->scc_tbufcount == 0) &&
                    CurSend->tsr_lastbuf == NULL) {

                    PNDIS_BUFFER LastBuf = SendBuf;
                    uint UBufLength = NdisBufferLength(LastBuf);
                    ushort UBufCount = 1;

                    while (NDIS_BUFFER_LINKAGE(LastBuf) != NULL) {
                        LastBuf = NDIS_BUFFER_LINKAGE(LastBuf);
                        UBufLength += NdisBufferLength(LastBuf);
                        UBufCount++;
                    }

                    if (SendSize == UBufLength) {
                        SCC->scc_ubufcount += UBufCount;
                        NDIS_BUFFER_LINKAGE(CurrentBuffer) = SendBuf;
                        CurSend->tsr_lastbuf = CurrentBuffer = LastBuf;
                        AmountLeft -= SendSize;
                        SendSize = 0;
                    } else {
                        //
                        // Fall through with a non-zero SendSize.
                        //
                        ASSERT(SendSize != 0);
                    }
                }

                if (SendSize != 0) {
                    uint AmountToDup;
                    PNDIS_BUFFER NewBuf, Buf;
                    uint Offset;
                    NDIS_STATUS NStatus;
                    uchar *VirtualAddress;
                    uint Length;

                    //
                    // Either the current send has more data than
                    // we want to send, or the starting offset is
                    // not 0. In either case we'll need to loop
                    // through the current send, allocating buffers.
                    //
                    Buf = SendBuf;
                    Offset = SendOfs;

                    do {
                        ASSERT(Buf != NULL);

                        NdisQueryBufferSafe(Buf, &VirtualAddress, &Length,
                                            LowPagePriority);

                        if (VirtualAddress == NULL) {
                            goto error_oor2;
                        }

                        ASSERT((Offset < Length) ||
                               (Offset == 0 && Length == 0));

                        //
                        // Adjust the length for the offset into
                        // this buffer.
                        //
                        Length -= Offset;

                        AmountToDup = MIN(AmountLeft, Length);

                        NdisAllocateBuffer(&NStatus, &NewBuf,
                                           IPv6BufferPool,
                                           VirtualAddress + Offset,
                                           AmountToDup);

                        if (NStatus == NDIS_STATUS_SUCCESS) {
                            SCC->scc_tbufcount++;

                            NDIS_BUFFER_LINKAGE(CurrentBuffer) = NewBuf;

                            CurrentBuffer = NewBuf;
                            if (AmountToDup >= Length) {
                                // Exhausted this buffer.
                                Buf = NDIS_BUFFER_LINKAGE(Buf);
                                Offset = 0;
                            } else {
                                Offset += AmountToDup;
                                ASSERT(Offset < NdisBufferLength(Buf));
                            }

                            SendSize -= AmountToDup;
                            AmountLeft -= AmountToDup;
                        } else {
                            //
                            // Couldn't allocate a buffer. If
                            // the packet is already partly built,
                            // send what we've got, otherwise
                            // error out.
                            //
                          error_oor2:
                            if (SCC->scc_tbufcount == 0 &&
                                SCC->scc_ubufcount == 0) {
                                KeReleaseSpinLockFromDpcLevel(
                                    &SendTCB->tcb_lock);
                                NdisChainBufferAtFront(Packet, FirstBuffer);
                                TCPSendComplete(Packet, IP_GENERAL_FAILURE);
                                KeAcquireSpinLockAtDpcLevel(&SendTCB->tcb_lock);
                                goto error_oor;
                            }
                            AmountToSend -= AmountLeft;
                            AmountLeft = 0;
                            break;
                        }
                    } while (AmountLeft && SendSize);

                    SendBuf = Buf;
                    SendOfs = Offset;
                }

                if (CurSend->tsr_flags & TSR_FLAG_URG) {
                    ushort UP;
                    //
                    // This send is urgent data. We need to figure
                    // out what the urgent data pointer should be.
                    // We know sendnext is the starting sequence
                    // number of the frame, and that at the top of
                    // this do loop sendnext identified a byte in
                    // the CurSend at that time. We advanced CurSend
                    // at the same rate we've decremented
                    // AmountLeft (AmountToSend - AmountLeft ==
                    // AmountBuilt), so sendnext +
                    // (AmountToSend - AmountLeft) identifies a byte
                    // in the current value of CurSend, and that
                    // quantity plus tcb_sendsize is the sequence
                    // number one beyond the current send.
                    //
                    UP = (ushort) (AmountToSend - AmountLeft) +
                        (ushort) SendSize -
                        ((SendTCB->tcb_flags & BSD_URGENT) ? 0 : 1);

                    TCP->tcp_urgent = net_short(UP);
                    TCP->tcp_flags |= TCP_FLAG_URG;
                }

                //
                // See if we've exhausted this send. If we have,
                // set the PUSH bit in this frame and move on to
                // the next send. We also need to check the
                // urgent data bit.
                //
                if (SendSize == 0) {
                    Queue *Next;
                    ulong PrevFlags;

                    //
                    // We've exhausted this send. Set the PUSH bit.
                    //
                    TCP->tcp_flags |= TCP_FLAG_PUSH;
                    PrevFlags = CurSend->tsr_flags;
                    Next = QNEXT(&CurSend->tsr_req.tr_q);
                    if (Next != QEND(&SendTCB->tcb_sendq)) {
                        CurSend = CONTAINING_RECORD(
                            QSTRUCT(TCPReq, Next, tr_q),
                            TCPSendReq, tsr_req);
                        CHECK_STRUCT(CurSend, tsr);
                        SendSize = CurSend->tsr_unasize;
                        SendOfs = CurSend->tsr_offset;
                        SendBuf = CurSend->tsr_buffer;

                        //
                        // Check the urgent flags.  We can't combine new
                        // urgent data on to the end of old non-urgent
                        // data.
                        //
                        if ((PrevFlags & TSR_FLAG_URG) &&
                            !(CurSend->tsr_flags & TSR_FLAG_URG)) {
                            break;
                        }
                    } else {
                        ASSERT(AmountLeft == 0);
                        CurSend = NULL;
                        SendBuf = NULL;
                    }
                }
            } while (AmountLeft != 0);

        } else {
            //
            // Amt to send is 0.
            // Just bail out and start timer.
            //
            if (!TCB_TIMER_RUNNING(SendTCB->tcb_rexmittimer)) {
                START_TCB_TIMER(SendTCB->tcb_rexmittimer,
                                SendTCB->tcb_rexmit);
            }

            ExFreePool(NdisBufferVirtualAddress(FirstBuffer));
            NdisFreeBuffer(FirstBuffer);
            NdisFreePacket(Packet);
            return;
        }

        //
        // Adjust for what we're really going to send.
        //
        AmountToSend -= AmountLeft;

        SendNext += AmountToSend;
        AmtUnsent -= AmountToSend;

        TStats.ts_retranssegs++;

        AmountToSend += sizeof(TCPHeader);

        if (!TCB_TIMER_RUNNING(SendTCB->tcb_rexmittimer)) {
            START_TCB_TIMER(SendTCB->tcb_rexmittimer, SendTCB->tcb_rexmit);
        }

        SendTCB->tcb_flags &= ~(NEED_ACK | ACK_DELAYED | FORCE_OUTPUT);
        STOP_TCB_TIMER(SendTCB->tcb_delacktimer);
        STOP_TCB_TIMER(SendTCB->tcb_swstimer);

        //
        // Add the buffers to the packet.
        //
        NdisChainBufferAtFront(Packet, FirstBuffer);

        //
        // Compute the TCP checksum.  It covers the entire TCP segment
        // starting with the TCP header, plus the IPv6 pseudo-header.
        //
        TCP->tcp_xsum = 0;
        TCP->tcp_xsum = ChecksumPacket(
            Packet, LinkOffset + sizeof *IP, NULL, AmountToSend,
            AlignAddr(&IP->Source), AlignAddr(&IP->Dest), IP_PROTOCOL_TCP);

        //
        // Capture and reference the RCE while we still hold the TCB lock.
        // The TCB's reference on this particular RCE might go away at any
        // point after we release the lock.
        //
        RCE = SendTCB->tcb_rce;
        AddRefRCE(RCE);

        //
        // Everything's ready.  Now send the packet.
        //
        // Note that IPv6Send does not return a status code.
        // Instead it *always* completes the packet
        // with an appropriate status code.
        //
        KeReleaseSpinLock(&SendTCB->tcb_lock, PreLockIrql);

        if (TCP->tcp_xsum == 0) {
            //
            // ChecksumPacket failed, so abort the transmission.
            //
            IPv6SendComplete(NULL, Packet, IP_NO_RESOURCES);

        } else {
            IPv6Send(Packet, LinkOffset, IP,
                     AmountToSend, RCE, 0,
                     IP_PROTOCOL_TCP,
                     net_short(TCP->tcp_src),
                     net_short(TCP->tcp_dest));
        }

        //
        // Release reference and reacquire lock we dropped before sending.
        //
        ReleaseRCE(RCE);
        KeAcquireSpinLock(&SendTCB->tcb_lock, &PreLockIrql);
    }

    return;

    //
    // Common case error handling code for out of resource conditions.
    // Start the retransmit timer if it's not already running
    // (so that we try this again later), clean up and return.
    //
  error_oor:
    if (!TCB_TIMER_RUNNING(SendTCB->tcb_rexmittimer)) {
        START_TCB_TIMER(SendTCB->tcb_rexmittimer, SendTCB->tcb_rexmit);
    }

    return;
}


//* TDISend - Send data on a connection.
//
//  The main TDI send entry point.  We take the input parameters, validate
//  them, allocate a send request, etc.  We then put the send request on the
//  queue.  If we have no other sends on the queue or Nagling is disabled we'll
//  call TCPSend to send the data.
//
TDI_STATUS                    // Returns: Status of attempt to send.
TdiSend(
    PTDI_REQUEST Request,     // TDI request for the call.
    ushort Flags,             // Flags for this send.
    uint SendLength,          // Length in bytes of send.
    PNDIS_BUFFER SendBuffer)  // Buffer chain to be sent.
{
    TCPConn *Conn;
    TCB *SendTCB;
    TCPSendReq *SendReq;
    KIRQL OldIrql;
    TDI_STATUS Error;
    uint EmptyQ;

#if DBG
    uint RealSendSize;
    PNDIS_BUFFER Temp;

    //
    // Loop through the buffer chain, and make sure that the length matches
    // up with SendLength.
    //
    Temp = SendBuffer;
    RealSendSize = 0;
    do {
        ASSERT(Temp != NULL);

        RealSendSize += NdisBufferLength(Temp);
        Temp = NDIS_BUFFER_LINKAGE(Temp);
    } while (Temp != NULL);

    ASSERT(RealSendSize == SendLength);
#endif

    //
    // Grab lock on Connection Table.  Then get our connection info from
    // the TDI request, and our TCP control block from that.
    //
    Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext),
                             &OldIrql);
    if (Conn == NULL) {
        Error = TDI_INVALID_CONNECTION;
        goto abort;
    }
    CHECK_STRUCT(Conn, tc);

    SendTCB = Conn->tc_tcb;
    if (SendTCB == NULL) {
        Error = TDI_INVALID_STATE;
        KeReleaseSpinLock(&Conn->tc_ConnBlock->cb_lock, OldIrql);
      abort:
        return Error;
    }
    CHECK_STRUCT(SendTCB, tcb);

    //
    // Switch to a finer-grained lock:
    // Drop lock on the Connection Table in favor of one on our TCB.
    //
    KeAcquireSpinLockAtDpcLevel(&SendTCB->tcb_lock);
    KeReleaseSpinLockFromDpcLevel(&Conn->tc_ConnBlock->cb_lock);

    //
    // Make sure our TCB is in a send-able state.
    //
    if (!DATA_SEND_STATE(SendTCB->tcb_state) || CLOSING(SendTCB)) {
        Error = TDI_INVALID_STATE;
        goto abort2;
    }

    CheckTCBSends(SendTCB);  // Just a debug check.

    //
    // If we've released our RCE for some reason, reacquire one.
    //
    if (SendTCB->tcb_rce == NULL) {
        InitRCE(SendTCB);
        if (SendTCB->tcb_rce == NULL) {
            Error = TDI_DEST_NET_UNREACH;
            goto abort2;
        }
    }

    //
    // Verify that the cached RCE is still valid.
    //
    SendTCB->tcb_rce = ValidateRCE(SendTCB->tcb_rce, SendTCB->tcb_nte);
    ASSERT(SendTCB->tcb_rce != NULL);
    if (IsDisconnectedAndNotLoopbackRCE(SendTCB->tcb_rce)) {
        //
        // Fail new send requests for TCBs with a disconnected
        // outgoing interface, except when the loopback route is used.
        //
        Error = TDI_DEST_NET_UNREACH;
        goto abort2;
    }

    if (SendLength == 0) {
        //
        // Wow, nothing to do!
        //
        // REVIEW: Can't we do this check earlier (like before we even grab the
        // REVIEW: Connection Table lock?  The only reason I can think not to
        // REVIEW: would be if something cared about the return code if a bad
        // REVIEW: Tdi Request was given to us.
        //
        Error = TDI_SUCCESS;
        goto abort2;
    }

    //
    // We have a TCB, and it's valid.  Allocate a send request now.
    //
    SendReq = GetSendReq();
    if (SendReq == NULL) {
        Error = TDI_NO_RESOURCES;
      abort2:
        KeReleaseSpinLock(&SendTCB->tcb_lock, OldIrql);
        return Error;
    }

    //
    // Prepare a TCP send request based on the TDI request and the
    // passed in buffer chain.
    //
    SendReq->tsr_req.tr_rtn = Request->RequestNotifyObject;
    SendReq->tsr_req.tr_context = Request->RequestContext;
    SendReq->tsr_buffer = SendBuffer;
    SendReq->tsr_size = SendLength;
    SendReq->tsr_unasize = SendLength;
    SendReq->tsr_refcnt = 1;  // ACK will decrement this ref
    SendReq->tsr_offset = 0;
    SendReq->tsr_lastbuf = NULL;
    SendReq->tsr_time = TCPTime;
    SendReq->tsr_flags = (Flags & TDI_SEND_EXPEDITED) ? TSR_FLAG_URG : 0;

    //
    // Check current status of our send queue.
    //
    EmptyQ = EMPTYQ(&SendTCB->tcb_sendq);

    //
    // Add this send request to our send queue.
    //
    SendTCB->tcb_unacked += SendLength;
    ENQUEUE(&SendTCB->tcb_sendq, &SendReq->tsr_req.tr_q);
    if (SendTCB->tcb_cursend == NULL) {
        //
        // No existing current send request, so make this new one
        // the current send.
        //
        // REVIEW: Is this always equivalent to EMPTYQ test above?
        // REVIEW: If so, why not just set EmptyQ flag here and save a test?
        //
        SendTCB->tcb_cursend = SendReq;
        SendTCB->tcb_sendbuf = SendBuffer;
        SendTCB->tcb_sendofs = 0;
        SendTCB->tcb_sendsize = SendLength;
    }

    //
    // See if we should try to send now.  We attempt to do so if we weren't
    // already blocked, or if we were and either the Nagle Algorithm is turned
    // off or we now have at least one max segment worth of data to send.
    //
    if (EmptyQ || (!(SendTCB->tcb_flags & NAGLING) ||
            (SendTCB->tcb_unacked -
             (SendTCB->tcb_sendmax - SendTCB->tcb_senduna))
                   >= SendTCB->tcb_mss)) {
        SendTCB->tcb_refcnt++;
        TCPSend(SendTCB, OldIrql);
    } else
        KeReleaseSpinLock(&SendTCB->tcb_lock, OldIrql);

    //
    // When TCPSend returns, we may or may not have already sent the data
    // associated with this particular request.
    //
    return TDI_PENDING;
}


#pragma BEGIN_INIT

//* InitTCPSend - Initialize our send side.
//
//  Called during init time to initialize our TCP send state.
//
int           //  Returns: TRUE if we inited, false if we didn't.
InitTCPSend(
    void)     // Nothing.
{
    ExInitializeSListHead(&TCPSendReqFree);
    KeInitializeSpinLock(&TCPSendReqFreeLock);

    IPv6RegisterULProtocol(IP_PROTOCOL_TCP, TCPReceive, TCPControlReceive);

    return TRUE;
}

#pragma END_INIT

//* UnloadTCPSend
//
//  Cleanup and prepare for stack unload.
//
void
UnloadTCPSend(void)
{
    PSLIST_ENTRY BufferLink;

    while ((BufferLink = ExInterlockedPopEntrySList(&TCPSendReqFree,
                                                    &TCPSendReqFreeLock))
                                                        != NULL) {
        Queue *QueuePtr = CONTAINING_RECORD(BufferLink, Queue, q_next);
        TCPReq *Req = CONTAINING_RECORD(QueuePtr, TCPReq, tr_q);
        TCPSendReq *SendReq = CONTAINING_RECORD(Req, TCPSendReq, tsr_req);

        CHECK_STRUCT(SendReq, tsr);
        ExFreePool(SendReq);
    }

    IPv6RegisterULProtocol(IP_PROTOCOL_TCP, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\wship6\wship6.c ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This module contains necessary routines for the Windows Sockets
// Helper DLL.  This DLL provides the transport-specific support necessary
// for the Windows Sockets DLL to use IPv6 as a transport.
//
// Revision History:
//
// Ported from wshsmple.c in the DDK.
//
#pragma warning(disable:4152) // function/data pointer conversion in expression

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define UDP_HEADER_SIZE 8

#include <wchar.h>

#include <winsock2.h>
#include <ws2tcpip.h>
#include <ws2ip6.h>
#include <ip6.h>        // IPv6 protocol definitions.
#include <wsahelp.h>

// private socket options to be accessed via WSAIoctl
#include <mstcpip.h>

#include <ntddip6.h>
#include <ntddtcp.h>

#include <tdiinfo.h>

#include <smpletcp.h>

#include <nspapi.h>

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))


///////////////////////////////////////////////////
#define TCP_NAME L"TCP/IPv6"
#define UDP_NAME L"UDP/IPv6"
#define RAW_NAME L"RAW/IPv6"

#define IS_DGRAM_SOCK(type)  (((type) == SOCK_DGRAM) || ((type) == SOCK_RAW))

//
// Define valid flags for WSHOpenSocket2().
//

#define VALID_TCP_FLAGS         (WSA_FLAG_OVERLAPPED)

#define VALID_UDP_FLAGS         (WSA_FLAG_OVERLAPPED |          \
                                 WSA_FLAG_MULTIPOINT_C_LEAF |   \
                                 WSA_FLAG_MULTIPOINT_D_LEAF)


//
// Structure and variables to define the triples supported by TCP/IP. The
// first entry of each array is considered the canonical triple for
// that socket type; the other entries are synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE TcpMappingTriples[] = { AF_INET6,  SOCK_STREAM, IPPROTO_TCP,
                                       AF_INET6,  SOCK_STREAM, 0,
                                       AF_INET6,  0,           IPPROTO_TCP };

MAPPING_TRIPLE UdpMappingTriples[] = { AF_INET6,  SOCK_DGRAM,  IPPROTO_UDP,
                                       AF_INET6,  SOCK_DGRAM,  0,
                                       AF_INET6,  0,           IPPROTO_UDP };

MAPPING_TRIPLE RawMappingTriples[] = { AF_INET6,  SOCK_RAW,    0 };

//
// Winsock 2 WSAPROTOCOL_INFO structures for all supported protocols.
//

#define WINSOCK_SPI_VERSION 2
// sizeof(UDPHeader) == 8
#define UDP_MESSAGE_SIZE    (MAX_IPv6_PAYLOAD - 8)

WSAPROTOCOL_INFOW Winsock2Protocols[] =
    {
        //
        // TCP
        //

        {
            XP1_GUARANTEED_DELIVERY                 // dwServiceFlags1
                | XP1_GUARANTEED_ORDER
                | XP1_GRACEFUL_CLOSE
                | XP1_EXPEDITED_DATA
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET6,                               // iAddressFamily
            sizeof(SOCKADDR_IN6),                   // iMaxSockAddr
            sizeof(SOCKADDR_IN6),                   // iMinSockAddr
            SOCK_STREAM,                            // iSocketType
            IPPROTO_TCP,                            // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            0,                                      // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [" TCP_NAME L"]"          // szProtocol
        },

        //
        // UDP
        //

        {
            XP1_CONNECTIONLESS                      // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                | XP1_SUPPORT_BROADCAST
                | XP1_SUPPORT_MULTIPOINT
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET6,                               // iAddressFamily
            sizeof(SOCKADDR_IN6),                   // iMaxSockAddr
            sizeof(SOCKADDR_IN6),                   // iMinSockAddr
            SOCK_DGRAM,                             // iSocketType
            IPPROTO_UDP,                            // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            UDP_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [" UDP_NAME L"]"          // szProtocol
        },

        //
        // RAW
        //

        {
            XP1_CONNECTIONLESS                      // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                | XP1_SUPPORT_BROADCAST
                | XP1_SUPPORT_MULTIPOINT
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO               // dwProviderFlags
                | PFL_HIDDEN,
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET6,                               // iAddressFamily
            sizeof(SOCKADDR_IN6),                   // iMaxSockAddr
            sizeof(SOCKADDR_IN6),                   // iMinSockAddr
            SOCK_RAW,                               // iSocketType
            0,                                      // iProtocol
            255,                                    // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            UDP_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [" RAW_NAME L"]"          // szProtocol
        }

    };

#define NUM_WINSOCK2_PROTOCOLS  \
            ( sizeof(Winsock2Protocols) / sizeof(Winsock2Protocols[0]) )

//
// The GUID identifying this provider.
//

GUID IPv6ProviderGuid = { /* f9eab0c0-26d4-11d0-bbbf-00aa006c34e4 */
    0xf9eab0c0,
    0x26d4,
    0x11d0,
    {0xbb, 0xbf, 0x00, 0xaa, 0x00, 0x6c, 0x34, 0xe4}
    };

#define TL_INSTANCE 0

//
// Forward declarations of internal routines.
//

VOID
CompleteTdiActionApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock
    );

INT
SetTdiInformation (
    IN HANDLE TdiConnectionObjectHandle,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN BOOLEAN WaitForCompletion
    );

BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    );

//
// The socket context structure for this DLL.  Each open TCP/IP socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHTCPIP_SOCKET_CONTEXT {
    INT      AddressFamily;
    INT      SocketType;
    INT      Protocol;
    INT      ReceiveBufferSize;
    DWORD    Flags;
    INT      MulticastHops;
    INT      UnicastHops;
    ULONG    MulticastInterface;
    INT      MulticastLoopback;
    BOOLEAN  KeepAlive;
    BOOLEAN  NoDelay;
    BOOLEAN  BsdUrgent;
    BOOLEAN  MultipointLeaf;
    BOOLEAN  Reserved3;
    IN6_ADDR MultipointTarget;
    HANDLE   MultipointRootTdiAddressHandle;
    USHORT   UdpChecksumCoverage;
    struct tcp_keepalive KeepAliveVals;
    INT      Ipv6PktInfo;
    INT      Ipv6HopLimit;
    INT      HeaderInclude;
    INT      ProtectionLevel;

} WSHTCPIP_SOCKET_CONTEXT, *PWSHTCPIP_SOCKET_CONTEXT;

#define DEFAULT_RECEIVE_BUFFER_SIZE     8192
#define DEFAULT_MULTICAST_HOPS          -1
#define DEFAULT_MULTICAST_INTERFACE     0
#define DEFAULT_MULTICAST_LOOPBACK      TRUE
#define DEFAULT_UDP_CHECKSUM_COVERAGE   0
#define DEFAULT_UNICAST_HOPS            -1
#define DEFAULT_HEADER_INCLUDE          FALSE

BOOLEAN
DllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Context);

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need to receive thread attach and detach
        // notifications, so disable them to help application
        // performance.
        //

        DisableThreadLibraryCalls( DllHandle );

        return TRUE;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;

} // SockInitialize

INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    SOCKADDR_IN6 *sockaddr = (PSOCKADDR_IN6)Sockaddr;

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_IN6) ) {
        return WSAEFAULT;
    }

    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->sin6_family != AF_INET6 ) {
        return WSAEAFNOSUPPORT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address portion of the sockaddr.
    // Note that IPv6 does not have a broadcast address.
    //

    if (IN6_IS_ADDR_UNSPECIFIED(&sockaddr->sin6_addr))
        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
    else if (IN6_IS_ADDR_LOOPBACK(&sockaddr->sin6_addr))
        SockaddrInfo->AddressInfo = SockaddrAddressInfoLoopback;
    else
        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;

    //
    // Determine the type of the port (endpoint) in the sockaddr.
    //

    if ( sockaddr->sin6_port == 0 ) {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    } else if ( ntohs( sockaddr->sin6_port ) < 2000 ) {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoReserved;
    } else {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;
    }

    return NO_ERROR;

} // WSHGetSockaddrType


INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

This routine retrieves information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE, SO_DONTROUTE, and TCP_EXPEDITED_1122.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to getsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( OptionValue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *OptionLength < sizeof(*context) ) {
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            CopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        return NO_ERROR;
    }

    //
    // The only other levels we support here are SOL_SOCKET,
    // IPPROTO_TCP, IPPROTO_UDP, and IPPROTO_IPV6.
    //

    if ( Level != SOL_SOCKET &&
         Level != IPPROTO_TCP &&
         Level != IPPROTO_UDP &&
         Level != IPPROTO_IPV6 ) {
        return WSAEINVAL;
    }

    //
    // Make sure that the output buffer is sufficiently large.
    //

    if ( *OptionLength < sizeof(int) ) {
        return WSAEFAULT;
    }

    //
    // Handle TCP-level options.
    //

    if ( Level == IPPROTO_TCP ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        switch ( OptionName ) {

        case TCP_NODELAY:

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = context->NoDelay;
            *OptionLength = sizeof(int);
            break;

        case TCP_EXPEDITED_1122:

            ZeroMemory( OptionValue, *OptionLength );

            *OptionValue = !context->BsdUrgent;
            *OptionLength = sizeof(int);
            break;

        default:

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle UDP-level options.
    //

    if ( Level == IPPROTO_UDP ) {

        if ( !IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Note that UDP_NOCHECKSUM is not supported for IPv6.
        //

        switch ( OptionName ) {

        case UDP_CHECKSUM_COVERAGE:
            *(PULONG)OptionValue = context->UdpChecksumCoverage;
            *OptionLength = sizeof(int);
            break;

        default:

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle IP-level options.
    //

    if ( Level == IPPROTO_IPV6 ) {


        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IPV6_UNICAST_HOPS:

            *(PINT)OptionValue = context->UnicastHops;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IPV6_PROTECTION_LEVEL:

            *(PINT)OptionValue = context->ProtectionLevel;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        default:
            //
            // No match, fall through.
            //
            break;
        }

        //
        // The following IP options are only valid on datagram sockets.
        //

        if ( !IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IPV6_MULTICAST_HOPS:

            *(PINT)OptionValue = context->MulticastHops;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IPV6_MULTICAST_IF:

            *(PULONG)OptionValue = context->MulticastInterface;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IPV6_MULTICAST_LOOP:

            *(PINT)OptionValue = context->MulticastLoopback;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IPV6_HDRINCL:

            *(PINT)OptionValue = context->HeaderInclude;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IPV6_PKTINFO:

            *OptionValue = (char)context->Ipv6PktInfo;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IPV6_HOPLIMIT:

            *OptionValue = (char)context->Ipv6HopLimit;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        default:

            return WSAENOPROTOOPT;
        }
    }

    //
    // Handle socket-level options.
    //

    switch ( OptionName ) {

    case SO_KEEPALIVE:

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        ZeroMemory( OptionValue, *OptionLength );

        *OptionValue = context->KeepAlive;
        *OptionLength = sizeof(int);

        break;

    default:

        return WSAENOPROTOOPT;
    }

    return NO_ERROR;

} // WSHGetSocketInformation


INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For IPv6, a wildcard address has address ::0 and port 0.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNREFERENCED_PARAMETER(HelperDllSocketContext);

    if ( *SockaddrLength < sizeof(SOCKADDR_IN6) ) {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_IN6);

    //
    // Just zero out the address and set the family to AF_INET6--this is
    // a wildcard address for IPv6.
    //

    ZeroMemory( Sockaddr, sizeof(SOCKADDR_IN6) );

    Sockaddr->sa_family = AF_INET6;

    return NO_ERROR;

} // WSAGetWildcardSockaddr


DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;

    mappingLength = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) +
                        sizeof(TcpMappingTriples) + sizeof(UdpMappingTriples)
                        + sizeof(RawMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength ) {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows = sizeof(TcpMappingTriples) / sizeof(TcpMappingTriples[0])
                     + sizeof(UdpMappingTriples) / sizeof(UdpMappingTriples[0])
                     + sizeof(RawMappingTriples) / sizeof(RawMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);
    MoveMemory(
        Mapping->Mapping,
        TcpMappingTriples,
        sizeof(TcpMappingTriples)
        );
    MoveMemory(
        (PCHAR)Mapping->Mapping + sizeof(TcpMappingTriples),
        UdpMappingTriples,
        sizeof(UdpMappingTriples)
        );
    MoveMemory(
        (PCHAR)Mapping->Mapping + sizeof(TcpMappingTriples)
                                + sizeof(UdpMappingTriples),
        RawMappingTriples,
        sizeof(RawMappingTriples)
        );

    //
    // Return the number of bytes we wrote.
    //

    return mappingLength;

} // WSHGetWinsockMapping


INT
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )
{
    return WSHOpenSocket2(
               AddressFamily,
               SocketType,
               Protocol,
               0,           // Group
               0,           // Flags
               TransportDeviceName,
               HelperDllSocketContext,
               NotificationEvents
               );

} // WSHOpenSocket


INT
WSHOpenSocket2 (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    Group - Identifies the group for the new socket.

    Flags - Zero or more WSA_FLAG_* flags as passed into WSASocket().

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context;

    //
    // Determine whether this is to be a TCP, UDP, or RAW socket.
    //

    if ( IsTripleInList(
             TcpMappingTriples,
             sizeof(TcpMappingTriples) / sizeof(TcpMappingTriples[0]),
             *AddressFamily,
             *SocketType,
             *Protocol ) ) {

        //
        // It's a TCP socket. Check the flags.
        //

        if( ( Flags & ~VALID_TCP_FLAGS ) != 0 ) {

            return WSAEINVAL;

        }

        //
        // Return the canonical form of a TCP socket triple.
        //

        *AddressFamily = TcpMappingTriples[0].AddressFamily;
        *SocketType = TcpMappingTriples[0].SocketType;
        *Protocol = TcpMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_STREAM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, DD_TCPV6_DEVICE_NAME );

    } else if ( IsTripleInList(
                    UdpMappingTriples,
                    sizeof(UdpMappingTriples) / sizeof(UdpMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) ) {

        //
        // It's a UDP socket. Check the flags & group ID.
        //

        if( ( Flags & ~VALID_UDP_FLAGS ) != 0 ||
            Group == SG_CONSTRAINED_GROUP ) {

            return WSAEINVAL;

        }

        //
        // Return the canonical form of a UDP socket triple.
        //

        *AddressFamily = UdpMappingTriples[0].AddressFamily;
        *SocketType = UdpMappingTriples[0].SocketType;
        *Protocol = UdpMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_DGRAM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, DD_UDPV6_DEVICE_NAME );

    } else if ( IsTripleInList(
                    RawMappingTriples,
                    sizeof(RawMappingTriples) / sizeof(RawMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) )
    {
        UNICODE_STRING  unicodeString;
        NTSTATUS        status;


        //
        // There is no canonicalization to be done for SOCK_RAW.
        //

        if (*Protocol < 0 || *Protocol > 255) {
            return(WSAEINVAL);
        }

        //
        // Indicate the name of the TDI device that will service
        // SOCK_RAW sockets in the internet address family.
        //
        RtlInitUnicodeString(&unicodeString, DD_RAW_IPV6_DEVICE_NAME);
        RtlInitUnicodeString(TransportDeviceName, NULL);

        TransportDeviceName->MaximumLength = unicodeString.Length +
                                                 (4 * sizeof(WCHAR) +
                                                 sizeof(UNICODE_NULL));

        TransportDeviceName->Buffer = HeapAlloc(GetProcessHeap(), 0,
                                          TransportDeviceName->MaximumLength
                                          );

        if (TransportDeviceName->Buffer == NULL) {
            return(WSAENOBUFS);
        }

        //
        // Append the device name.
        //
        status = RtlAppendUnicodeStringToString(
                     TransportDeviceName,
                     &unicodeString
                     );

        ASSERT(NT_SUCCESS(status));

        //
        // Append a separator.
        //
        TransportDeviceName->Buffer[TransportDeviceName->Length/sizeof(WCHAR)] =
                                                      OBJ_NAME_PATH_SEPARATOR;

        TransportDeviceName->Length += sizeof(WCHAR);

        TransportDeviceName->Buffer[TransportDeviceName->Length/sizeof(WCHAR)] =
                                                      UNICODE_NULL;

        //
        // Append the protocol number.
        //
        unicodeString.Buffer = TransportDeviceName->Buffer +
                                 (TransportDeviceName->Length / sizeof(WCHAR));
        unicodeString.Length = 0;
        unicodeString.MaximumLength = TransportDeviceName->MaximumLength -
                                           TransportDeviceName->Length;

        status = RtlIntegerToUnicodeString(
                     (ULONG) *Protocol,
                     10,
                     &unicodeString
                     );

        TransportDeviceName->Length = TransportDeviceName->Length + 
                                      unicodeString.Length;

        ASSERT(NT_SUCCESS(status));

    } else {

        //
        // This should never happen if the registry information about this
        // helper DLL is correct.  If somehow this did happen, just return
        // an error.
        //

        return WSAEINVAL;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = HeapAlloc(GetProcessHeap(), 0, sizeof(*context) );
    if ( context == NULL ) {
        return WSAENOBUFS;
    }

    //
    // Initialize the context for the socket.
    //

    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;
    context->ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
    context->Flags = Flags;
    context->MulticastHops = DEFAULT_MULTICAST_HOPS;
    context->MulticastInterface = DEFAULT_MULTICAST_INTERFACE;
    context->MulticastLoopback = DEFAULT_MULTICAST_LOOPBACK;
    context->KeepAlive = FALSE;
    context->NoDelay = FALSE;
    context->BsdUrgent = TRUE;
    context->UnicastHops = DEFAULT_UNICAST_HOPS;
    context->MultipointLeaf = FALSE;
    context->Reserved3 = FALSE;
    context->MultipointRootTdiAddressHandle = NULL;
    context->UdpChecksumCoverage = DEFAULT_UDP_CHECKSUM_COVERAGE;
    context->KeepAliveVals.onoff = FALSE;
    context->Ipv6PktInfo = FALSE;
    context->Ipv6HopLimit = FALSE;
    context->HeaderInclude = DEFAULT_HEADER_INCLUDE;
    context->ProtectionLevel = PROTECTION_LEVEL_DEFAULT;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.  The only times we need to be
    // called is after a connect has completed so that we can turn on
    // the sending of keepalives if SO_KEEPALIVE was set before the
    // socket was connected, when the socket is closed so that we can
    // free context information, and when a connect fails so that we
    // can, if appropriate, dial in to the network that will support the
    // connect attempt.
    //

    *NotificationEvents =
        WSH_NOTIFY_CONNECT | WSH_NOTIFY_CLOSE | WSH_NOTIFY_CONNECT_ERROR;

    if (IS_DGRAM_SOCK(*SocketType)) {
        *NotificationEvents |= WSH_NOTIFY_BIND;
    } else {
        *NotificationEvents |= WSH_NOTIFY_LISTEN;
    }

    //
    // Everything worked, return success.
    //

    *HelperDllSocketContext = context;
    return NO_ERROR;

} // WSHOpenSocket


INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;

    UNREFERENCED_PARAMETER(SocketHandle);

    //
    // We should only be called after a connect() completes or when the
    // socket is being closed.
    //

    if ( NotifyEvent == WSH_NOTIFY_CONNECT ) {

        ULONG true = TRUE;
        ULONG false = FALSE;

        //
        // If a connection-object option was set on the socket before
        // it was connected, set the option for real now.
        //

        if ( context->KeepAlive ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_KEEPALIVE,
                      &true,
                      sizeof(true),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->KeepAliveVals.onoff ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_KEEPALIVE_VALS,
                      &context->KeepAliveVals,
                      sizeof(struct tcp_keepalive),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->NoDelay ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_NODELAY,
                      &true,
                      sizeof(true),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->ReceiveBufferSize != DEFAULT_RECEIVE_BUFFER_SIZE ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_WINDOW,
                      &context->ReceiveBufferSize,
                      sizeof(context->ReceiveBufferSize),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( !context->BsdUrgent ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_BSDURGENT,
                      &false,
                      sizeof(false),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

    } else if ( NotifyEvent == WSH_NOTIFY_CLOSE ) {

        //
        // If this is a multipoint leaf, then remove the multipoint target
        // from the session.
        //

        if( context->MultipointLeaf &&
            context->MultipointRootTdiAddressHandle != NULL ) {

            struct ipv6_mreq req;

            req.ipv6mr_multiaddr = context->MultipointTarget;
            req.ipv6mr_interface = 0;

            SetTdiInformation(
                context->MultipointRootTdiAddressHandle,
                CL_TL_ENTITY,
                INFO_CLASS_PROTOCOL,
                INFO_TYPE_ADDRESS_OBJECT,
                AO_OPTION_DEL_MCAST,
                &req,
                sizeof(req),
                TRUE
                );

        }

        //
        // Free the socket context.
        //

        HeapFree(GetProcessHeap(), 0, context );

    } else if ( NotifyEvent == WSH_NOTIFY_CONNECT_ERROR ) {

        //
        // Return WSATRY_AGAIN to get wsock32 to attempt the connect
        // again.  Any other return code is ignored.
        //

    } else if ( NotifyEvent == WSH_NOTIFY_BIND ) {
        ULONG true = TRUE;

        if ( context->UnicastHops != DEFAULT_UNICAST_HOPS ) {
            int value = context->UnicastHops;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_TTL,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->MulticastHops != DEFAULT_MULTICAST_HOPS ) {
            int value = (int) context->MulticastHops;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_MCASTTTL,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->MulticastInterface != DEFAULT_MULTICAST_INTERFACE ) {
            int value = (int) context->MulticastInterface;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_MCASTIF,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->MulticastLoopback != DEFAULT_MULTICAST_LOOPBACK ) {
            int value = (int) context->MulticastLoopback;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_MCASTLOOP,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->UdpChecksumCoverage != DEFAULT_UDP_CHECKSUM_COVERAGE ) {

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CL_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_UDP_CHKSUM_COVER,
                      &context->UdpChecksumCoverage,
                      sizeof context->UdpChecksumCoverage,
                      TRUE
                      );

            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->HeaderInclude != DEFAULT_HEADER_INCLUDE ) {
            int value = (int) context->HeaderInclude;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_IP_HDRINCL,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->Ipv6PktInfo ) {

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_IP_PKTINFO,
                      &true,
                      sizeof (TRUE),
                      TRUE
                      );

            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->Ipv6HopLimit ) {

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_RCV_HOPLIMIT,
                      &true,
                      sizeof (TRUE),
                      TRUE
                      );

            if ( err != NO_ERROR ) {
                return err;
            }
        }
        
        if ( context->ProtectionLevel != PROTECTION_LEVEL_DEFAULT ) {
            err = SetTdiInformation(
                        TdiAddressObjectHandle,
                        CL_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_ADDRESS_OBJECT,
                        AO_OPTION_PROTECT,
                        &context->ProtectionLevel,
                        sizeof context->ProtectionLevel,
                        TRUE
                        );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

    } else if ( NotifyEvent == WSH_NOTIFY_LISTEN ) {
        if ( context->ProtectionLevel != PROTECTION_LEVEL_DEFAULT ) {
            err = SetTdiInformation(
                        TdiAddressObjectHandle,
                        CL_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_ADDRESS_OBJECT,
                        AO_OPTION_PROTECT,
                        &context->ProtectionLevel,
                        sizeof context->ProtectionLevel,
                        TRUE
                        );
            if ( err != NO_ERROR ) {
                return err;
            }
        }
    } else {
        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify


INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE, SO_DONTROUTE, and TCP_EXPEDITED_1122.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT error;
    INT optionValue;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = HeapAlloc(GetProcessHeap(), 0, sizeof(*context) );
            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            CopyMemory( context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHTCPIP_SOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;

        } else {

            PWSHTCPIP_SOCKET_CONTEXT parentContext;
            INT one = 1;

            //
            // The socket was accept()'ed and it needs to have the same
            // properties as it's parent.  The OptionValue buffer
            // contains the context information of this socket's parent.
            //

            parentContext = (PWSHTCPIP_SOCKET_CONTEXT)OptionValue;

            ASSERT( context->AddressFamily == parentContext->AddressFamily );
            ASSERT( context->SocketType == parentContext->SocketType );
            ASSERT( context->Protocol == parentContext->Protocol );

            //
            // Turn on in the child any options that have been set in
            // the parent.
            //

            if ( parentContext->KeepAlive ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_KEEPALIVE,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( parentContext->KeepAliveVals.onoff ) {
                struct tcp_keepalive *optionval;

                  //
                  // Atempt to turn on or off keepalive sending, as necessary.
                  //

                optionval = &parentContext->KeepAliveVals;

                if ( TdiConnectionObjectHandle != NULL ) {
                    error = SetTdiInformation(
                        TdiConnectionObjectHandle,
                        CO_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_CONNECTION,
                        TCP_SOCKET_KEEPALIVE_VALS,
                        optionval,
                        sizeof(struct tcp_keepalive),
                        TRUE
                        );
                    if ( error != NO_ERROR ) {
                        return error;
                    }
                }

                //
                // Remember that keepalives are enabled for this socket.
                //

                context->KeepAliveVals = *optionval;
            }

            if ( parentContext->NoDelay ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            IPPROTO_TCP,
                            TCP_NODELAY,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( parentContext->ReceiveBufferSize != DEFAULT_RECEIVE_BUFFER_SIZE ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_RCVBUF,
                            (PCHAR)&parentContext->ReceiveBufferSize,
                            sizeof(parentContext->ReceiveBufferSize)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            if ( !parentContext->BsdUrgent ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            IPPROTO_TCP,
                            TCP_EXPEDITED_1122,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            return NO_ERROR;
        }
    }

    //
    // The only other levels we support here are SOL_SOCKET,
    // IPPROTO_TCP, IPPROTO_UDP, and IPPROTO_IPV6.
    //

    if ( Level != SOL_SOCKET &&
         Level != IPPROTO_TCP &&
         Level != IPPROTO_UDP &&
         Level != IPPROTO_IPV6 ) {
        return WSAEINVAL;
    }

    //
    // Make sure that the option length is sufficient.
    //

    if ( OptionLength < sizeof(int) ) {
        return WSAEFAULT;
    }

    optionValue = *(INT UNALIGNED *)OptionValue;

    //
    // Handle TCP-level options.
    //

    if ( Level == IPPROTO_TCP && OptionName == TCP_NODELAY ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Atempt to turn on or off Nagle's algorithm, as necessary.
        //

        if ( !context->NoDelay && optionValue != 0 ) {

            optionValue = TRUE;

            //
            // NoDelay is currently off and the application wants to
            // turn it on.  If the TDI connection object handle is NULL,
            // then the socket is not yet connected.  In this case we'll
            // just remember that the no delay option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_NODELAY,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is enabled for this socket.
            //

            context->NoDelay = TRUE;

        } else if ( context->NoDelay && optionValue == 0 ) {

            //
            // No delay is currently enabled and the application wants
            // to turn it off.  If the TDI connection object is NULL,
            // the socket is not yet connected.  In this case we'll just
            // remember that nodelay is disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_NODELAY,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is disabled for this socket.
            //

            context->NoDelay = FALSE;
        }

        return NO_ERROR;
    }

    if ( Level == IPPROTO_TCP && OptionName == TCP_EXPEDITED_1122 ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Atempt to turn on or off BSD-style urgent data semantics as
        // necessary.
        //

        if ( !context->BsdUrgent && optionValue == 0 ) {

            optionValue = TRUE;

            //
            // BsdUrgent is currently off and the application wants to
            // turn it on.  If the TDI connection object handle is NULL,
            // then the socket is not yet connected.  In this case we'll
            // just remember that the no delay option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_BSDURGENT,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is enabled for this socket.
            //

            context->BsdUrgent = TRUE;

        } else if ( context->BsdUrgent && optionValue != 0 ) {

            //
            // No delay is currently enabled and the application wants
            // to turn it off.  If the TDI connection object is NULL,
            // the socket is not yet connected.  In this case we'll just
            // remember that BsdUrgent is disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_BSDURGENT,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that BSD urgent is disabled for this socket.
            //

            context->BsdUrgent = FALSE;
        }

        return NO_ERROR;
    }

    //
    // Handle UDP-level options.
    //

    if ( Level == IPPROTO_UDP ) {

        //
        // These options are only valid for datagram sockets.
        //
        if ( !IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Note that UDP_NOCHECKSUM is not supported for IPv6.
        //

        switch ( OptionName ) {

        case UDP_CHECKSUM_COVERAGE:

            //
            // The default is 0 which covers the entire datagram.
            // The minimum is the UDP header.
            //
            if ((optionValue != DEFAULT_UDP_CHECKSUM_COVERAGE) &&
                (optionValue < UDP_HEADER_SIZE)) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                    TdiAddressObjectHandle,
                    CL_TL_ENTITY,
                    INFO_CLASS_PROTOCOL,
                    INFO_TYPE_ADDRESS_OBJECT,
                    AO_OPTION_UDP_CHKSUM_COVER,
                    &optionValue,
                    sizeof(optionValue),
                    TRUE
                    );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            context->UdpChecksumCoverage = (USHORT)optionValue;
            break;

        default :

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle IP-level options.
    //

    if ( Level == IPPROTO_IPV6 ) {

        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IPV6_UNICAST_HOPS:

            //
            // An attempt to change the unicast TTL sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //
            if ( optionValue > 255 || optionValue < -1 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_TTL,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->UnicastHops = optionValue;

            return NO_ERROR;

        case IPV6_MULTICAST_HOPS:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // An attempt to change the TTL on multicasts sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //

            if ( optionValue > 255 || optionValue < -1 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCASTTTL,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->MulticastHops = optionValue;

            return NO_ERROR;

        case IPV6_MULTICAST_IF:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCASTIF,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->MulticastInterface = optionValue;

            return NO_ERROR;

        case IPV6_MULTICAST_LOOP:
            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // This is a boolean option.  0 = false, 1 = true.
            // All other values are illegal.
            //

            if ( optionValue > 1) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCASTLOOP,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->MulticastLoopback = optionValue;

            return NO_ERROR;


        case IPV6_ADD_MEMBERSHIP:
        case IPV6_DROP_MEMBERSHIP:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // Make sure that the option buffer is large enough.
            //

            if ( OptionLength < sizeof(struct ipv6_mreq) ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            OptionName == IPV6_ADD_MEMBERSHIP ?
                                AO_OPTION_ADD_MCAST : AO_OPTION_DEL_MCAST,
                            OptionValue,
                            OptionLength,
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            return NO_ERROR;


        case IPV6_HDRINCL:
            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // This is a boolean option.  0 = false, 1 = true.
            // All other values are illegal.
            //

            if ( optionValue > 1) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_IP_HDRINCL,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->HeaderInclude = optionValue;

            return NO_ERROR;


        case IPV6_PKTINFO:

            //
            // This option is only valid for datagram sockets.
            //

            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // This is a boolean option.  0 = false, 1 = true.
            // All other values are illegal.
            //

            if ( optionValue > 1) {
                return WSAEINVAL;
            }

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_IP_PKTINFO,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->Ipv6PktInfo = optionValue;

            return NO_ERROR;

        case IPV6_HOPLIMIT:

            //
            // This option is only valid for datagram sockets.
            //

            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // This is a boolean option.  0 = false, 1 = true.
            // All other values are illegal.
            //

            if ( optionValue > 1) {
                return WSAEINVAL;
            }

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_RCV_HOPLIMIT,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->Ipv6HopLimit = optionValue;

            return NO_ERROR;

        case IPV6_PROTECTION_LEVEL:

            if ((optionValue != PROTECTION_LEVEL_RESTRICTED) &&
                (optionValue != PROTECTION_LEVEL_DEFAULT) &&
                (optionValue != PROTECTION_LEVEL_UNRESTRICTED)) {
                return WSAEINVAL;
            }

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_PROTECT,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->ProtectionLevel = optionValue;

            return NO_ERROR;

        default:
            //
            // No match, fall through.
            //
            break;
        }

        //
        // We don't support this option.
        //
        return WSAENOPROTOOPT;
    }

    //
    // Handle socket-level options.
    //

    switch ( OptionName ) {

    case SO_KEEPALIVE:

        //
        // Atempt to turn on or off keepalive sending, as necessary.
        //

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        if ( !context->KeepAlive && optionValue != 0 ) {

            optionValue = TRUE;

            //
            // Keepalives are currently off and the application wants to
            // turn them on.  If the TDI connection object handle is
            // NULL, then the socket is not yet connected.  In this case
            // we'll just remember that the keepalive option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_KEEPALIVE,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that keepalives are enabled for this socket.
            //

            context->KeepAlive = TRUE;

        } else if ( context->KeepAlive && optionValue == 0 ) {

            //
            // Keepalives are currently enabled and the application
            // wants to turn them off.  If the TDI connection object is
            // NULL, the socket is not yet connected.  In this case
            // we'll just remember that keepalives are disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_KEEPALIVE,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that keepalives are disabled for this socket.
            //

            context->KeepAlive = FALSE;
        }

        break;

    case SO_RCVBUF:

        //
        // If the receive buffer size is being changed, tell TCP about
        // it.  Do nothing if this is a datagram.
        //

        if ( context->ReceiveBufferSize == optionValue ||
                 IS_DGRAM_SOCK(context->SocketType)
           ) {
            break;
        }

        if ( TdiConnectionObjectHandle != NULL ) {
            error = SetTdiInformation(
                        TdiConnectionObjectHandle,
                        CO_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_CONNECTION,
                        TCP_SOCKET_WINDOW,
                        &optionValue,
                        sizeof(optionValue),
                        TRUE
                        );
            if ( error != NO_ERROR ) {
                return error;
            }
        }

        context->ReceiveBufferSize = optionValue;

        break;

    default:

        return WSAENOPROTOOPT;
    }

    return NO_ERROR;

} // WSHSetSocketInformation


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Enumerates the protocols supported by this helper.

Arguments:

    lpiProtocols - Pointer to a NULL-terminated array of protocol
        identifiers. Only protocols specified in this array will
        be returned by this function. If this pointer is NULL,
        all protocols are returned.

    lpTransportKeyName -

    lpProtocolBuffer - Pointer to a buffer to fill with PROTOCOL_INFO
        structures.

    lpdwBufferLength - Pointer to a variable that, on input, contains
        the size of lpProtocolBuffer. On output, this value will be
        updated with the size of the data actually written to the buffer.

Return Value:

    INT - The number of protocols returned if successful, -1 if not.

--*/

{
    DWORD bytesRequired;
    PPROTOCOL_INFO tcpProtocolInfo;
    PPROTOCOL_INFO udpProtocolInfo;
    BOOL useTcp = FALSE;
    BOOL useUdp = FALSE;
    DWORD i;

    lpTransportKeyName;         // Avoid compiler warnings.

    //
    // Make sure that the caller cares about TCP and/or UDP.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {

        for ( i = 0; lpiProtocols[i] != 0; i++ ) {
            if ( lpiProtocols[i] == IPPROTO_TCP ) {
                useTcp = TRUE;
            }
            if ( lpiProtocols[i] == IPPROTO_UDP ) {
                useUdp = TRUE;
            }
        }

    } else {

        useTcp = TRUE;
        useUdp = TRUE;
    }

    if ( !useTcp && !useUdp ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (DWORD)((sizeof(PROTOCOL_INFO) * 2) +
                        ( (wcslen( TCP_NAME ) + 1) * sizeof(WCHAR)) +
                        ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR)));

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in TCP info, if requested.
    //

    if ( useTcp ) {

        tcpProtocolInfo = lpProtocolBuffer;

        tcpProtocolInfo->dwServiceFlags = XP_GUARANTEED_DELIVERY |
                                              XP_GUARANTEED_ORDER |
                                              XP_GRACEFUL_CLOSE |
                                              XP_EXPEDITED_DATA |
                                              XP_FRAGMENTATION;
        tcpProtocolInfo->iAddressFamily = AF_INET6;
        tcpProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_IN6);
        tcpProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_IN6);
        tcpProtocolInfo->iSocketType = SOCK_STREAM;
        tcpProtocolInfo->iProtocol = IPPROTO_TCP;
        tcpProtocolInfo->dwMessageSize = 0;
        tcpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( TCP_NAME ) + 1) * sizeof(WCHAR) ) );
        wcscpy( tcpProtocolInfo->lpProtocol, TCP_NAME );

        udpProtocolInfo = tcpProtocolInfo + 1;
        udpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)tcpProtocolInfo->lpProtocol -
                ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR) ) );

    } else {

        udpProtocolInfo = lpProtocolBuffer;
        udpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR) ) );
    }

    //
    // Fill in UDP info, if requested.
    //

    if ( useUdp ) {

        udpProtocolInfo->dwServiceFlags = XP_CONNECTIONLESS |
                                              XP_MESSAGE_ORIENTED |
                                              XP_SUPPORTS_BROADCAST |
                                              XP_SUPPORTS_MULTICAST |
                                              XP_FRAGMENTATION;
        udpProtocolInfo->iAddressFamily = AF_INET6;
        udpProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_IN6);
        udpProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_IN6);
        udpProtocolInfo->iSocketType = SOCK_DGRAM;
        udpProtocolInfo->iProtocol = IPPROTO_UDP;
        udpProtocolInfo->dwMessageSize = UDP_MESSAGE_SIZE;
        wcscpy( udpProtocolInfo->lpProtocol, UDP_NAME );
    }

    *lpdwBufferLength = bytesRequired;

    return (useTcp && useUdp) ? 2 : 1;

} // WSHEnumProtocols



BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    )

/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/

{
    ULONG i;

    //
    // Walk through the list searching for an exact match.
    //

    for ( i = 0; i < ListLength; i++ ) {

        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //

        if ( AddressFamily == List[i].AddressFamily &&
             SocketType == List[i].SocketType &&
             ( (Protocol == List[i].Protocol) || (SocketType == SOCK_RAW) )
           ) {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;

} // IsTripleInList


INT
NtStatusToSocketError (
    IN NTSTATUS Status
    )
{

    switch ( Status ) {

    case STATUS_PENDING:
        ASSERT (FALSE);
        return WSASYSCALLFAILURE;

    case STATUS_INVALID_HANDLE:
    case STATUS_OBJECT_TYPE_MISMATCH:
        return WSAENOTSOCK;

    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_PAGEFILE_QUOTA:
    case STATUS_COMMITMENT_LIMIT:
    case STATUS_WORKING_SET_QUOTA:
    case STATUS_NO_MEMORY:
    case STATUS_CONFLICTING_ADDRESSES:
    case STATUS_QUOTA_EXCEEDED:
    case STATUS_TOO_MANY_PAGING_FILES:
    case STATUS_REMOTE_RESOURCES:
    case STATUS_TOO_MANY_ADDRESSES:
        return WSAENOBUFS;

    case STATUS_SHARING_VIOLATION:
    case STATUS_ADDRESS_ALREADY_EXISTS:
        return WSAEADDRINUSE;

    case STATUS_LINK_TIMEOUT:
    case STATUS_IO_TIMEOUT:
    case STATUS_TIMEOUT:
        return WSAETIMEDOUT;

    case STATUS_GRACEFUL_DISCONNECT:
        return WSAEDISCON;

    case STATUS_REMOTE_DISCONNECT:
    case STATUS_CONNECTION_RESET:
    case STATUS_LINK_FAILED:
    case STATUS_CONNECTION_DISCONNECTED:
    case STATUS_PORT_UNREACHABLE:
        return WSAECONNRESET;

    case STATUS_LOCAL_DISCONNECT:
    case STATUS_TRANSACTION_ABORTED:
    case STATUS_CONNECTION_ABORTED:
        return WSAECONNABORTED;

    case STATUS_BAD_NETWORK_PATH:
    case STATUS_NETWORK_UNREACHABLE:
    case STATUS_PROTOCOL_UNREACHABLE:
        return WSAENETUNREACH;

    case STATUS_HOST_UNREACHABLE:
        return WSAEHOSTUNREACH;

    case STATUS_CANCELLED:
    case STATUS_REQUEST_ABORTED:
        return WSAEINTR;

    case STATUS_BUFFER_OVERFLOW:
    case STATUS_INVALID_BUFFER_SIZE:
        return WSAEMSGSIZE;

    case STATUS_BUFFER_TOO_SMALL:
    case STATUS_ACCESS_VIOLATION:
        return WSAEFAULT;

    case STATUS_DEVICE_NOT_READY:
    case STATUS_REQUEST_NOT_ACCEPTED:
        return WSAEWOULDBLOCK;

    case STATUS_INVALID_NETWORK_RESPONSE:
    case STATUS_NETWORK_BUSY:
    case STATUS_NO_SUCH_DEVICE:
    case STATUS_NO_SUCH_FILE:
    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_UNEXPECTED_NETWORK_ERROR:
        return WSAENETDOWN;

    case STATUS_INVALID_CONNECTION:
        return WSAENOTCONN;

    case STATUS_REMOTE_NOT_LISTENING:
    case STATUS_CONNECTION_REFUSED:
        return WSAECONNREFUSED;

    case STATUS_PIPE_DISCONNECTED:
        return WSAESHUTDOWN;

    case STATUS_INVALID_ADDRESS:
    case STATUS_INVALID_ADDRESS_COMPONENT:
        return WSAEADDRNOTAVAIL;

    case STATUS_NOT_SUPPORTED:
    case STATUS_NOT_IMPLEMENTED:
        return WSAEOPNOTSUPP;

    case STATUS_ACCESS_DENIED:
        return WSAEACCES;

    default:

        if ( NT_SUCCESS(Status) ) {

#if DBG
            DbgPrint ("SockNtStatusToSocketError: success status %lx "
                       "not mapped\n", Status );
#endif

            return NO_ERROR;
        }

#if DBG
        DbgPrint ("SockNtStatusToSocketError: unable to map 0x%lX, returning\n",
                     Status );
#endif

        return WSAENOBUFS;

    case STATUS_UNSUCCESSFUL:
    case STATUS_INVALID_PARAMETER:
    case STATUS_ADDRESS_CLOSED:
    case STATUS_CONNECTION_INVALID:
    case STATUS_ADDRESS_ALREADY_ASSOCIATED:
    case STATUS_ADDRESS_NOT_ASSOCIATED:
    case STATUS_CONNECTION_ACTIVE:
    case STATUS_INVALID_DEVICE_STATE:
    case STATUS_INVALID_DEVICE_REQUEST:
        return WSAEINVAL;

    }

} // NtStatusToSocketError


INT
SetTdiInformation (
    IN HANDLE TdiConnectionObjectHandle,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN BOOLEAN WaitForCompletion
    )

/*++

Routine Description:

    Performs a TDI action to the TCP/IP driver.  A TDI action translates
    into a streams T_OPTMGMT_REQ.

Arguments:

    TdiConnectionObjectHandle - a TDI connection object on which to perform
        the TDI action.

    Entity - value to put in the tei_entity field of the TDIObjectID
        structure.

    Class - value to put in the toi_class field of the TDIObjectID
        structure.

    Type - value to put in the toi_type field of the TDIObjectID
        structure.

    Id - value to put in the toi_id field of the TDIObjectID structure.

    Value - a pointer to a buffer to set as the information.

    ValueLength - the length of the buffer.

    WaitForCompletion - TRUE if we should wait for the TDI action to
        complete, FALSE if we're at APC level and cannot do a wait.

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    PTCP_REQUEST_SET_INFORMATION_EX setInfoEx;
    PIO_STATUS_BLOCK ioStatusBlock;
    PVOID completionApc;
    PVOID apcContext;

    //
    // Allocate space to hold the TDI set information buffers and the IO
    // status block.  These cannot be stack variables in case we must
    // return before the operation is complete.
    //

    ioStatusBlock = HeapAlloc(GetProcessHeap(), 0,
                        sizeof(*ioStatusBlock) + sizeof(*setInfoEx) +
                            ValueLength
                        );
    if ( ioStatusBlock == NULL ) {
        return WSAENOBUFS;
    }

    //
    // Initialize the TDI information buffers.
    //

    setInfoEx = (PTCP_REQUEST_SET_INFORMATION_EX)(ioStatusBlock + 1);

    setInfoEx->ID.toi_entity.tei_entity = Entity;
    setInfoEx->ID.toi_entity.tei_instance = TL_INSTANCE;
    setInfoEx->ID.toi_class = Class;
    setInfoEx->ID.toi_type = Type;
    setInfoEx->ID.toi_id = Id;

    CopyMemory( setInfoEx->Buffer, Value, ValueLength );
    setInfoEx->BufferSize = ValueLength;

    //
    // If we need to wait for completion of the operation, create an
    // event to wait on.  If we can't wait for completion because we
    // are being called at APC level, we'll use an APC routine to
    // free the heap we allocated above.
    //

    if ( WaitForCompletion ) {

        completionApc = NULL;
        apcContext = NULL;

    } else {

        completionApc = CompleteTdiActionApc;
        apcContext = ioStatusBlock;
    }

    //
    // Make the actual TDI action call.  The Streams TDI mapper will
    // translate this into a TPI option management request for us and
    // give it to TCP/IP.
    //

    status = NtDeviceIoControlFile(
                 TdiConnectionObjectHandle,
                 NULL,
                 completionApc,
                 apcContext,
                 ioStatusBlock,
                 IOCTL_TCP_WSH_SET_INFORMATION_EX,
                 setInfoEx,
                 sizeof(*setInfoEx) + ValueLength,
                 NULL,
                 0
                 );

    //
    // If the call pended and we were supposed to wait for completion,
    // then wait.
    //

    if ( status == STATUS_PENDING && WaitForCompletion ) {
        while (ioStatusBlock->Status==STATUS_PENDING) {
            LARGE_INTEGER   timeout;
            //
            // Wait one millisecond
            //
            timeout.QuadPart = -1i64*1000i64*10i64;
            NtDelayExecution (FALSE, &timeout);
        }
        status = ioStatusBlock->Status;
    }

    if ( WaitForCompletion || !NT_SUCCESS(status) ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, ioStatusBlock );
    }

    if (NT_SUCCESS (status)) {
        return NO_ERROR;
    }
    else {
        return NtStatusToSocketError (status);
    }

} // SetTdiInformation


VOID
CompleteTdiActionApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock
    )
{
    UNREFERENCED_PARAMETER(IoStatusBlock);

    //
    // Just free the heap we allocated to hold the IO status block and
    // the TDI action buffer.  There is nothing we can do if the call
    // failed.
    //

    HeapFree(GetProcessHeap(), 0, ApcContext );

} // CompleteTdiActionApc


INT
WINAPI
WSHJoinLeaf (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    )

/*++

Routine Description:

    Performs the protocol-dependent portion of creating a multicast
    socket.

Arguments:

    The following four parameters correspond to the socket passed into
    the WSAJoinLeaf() API:

    HelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    SocketHandle - The handle of the socket used to establish the
        multicast "session".

    TdiAddressObjectHandle - The TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - The TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    The next two parameters correspond to the newly created socket that
    identifies the multicast "session":

    LeafHelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    LeafSocketHandle - The handle of the socket that identifies the
        multicast "session".

    Sockaddr - The name of the peer to which the socket is to be joined.

    SockaddrLength - The length of Sockaddr.

    CallerData - Pointer to user data to be transferred to the peer
        during multipoint session establishment.

    CalleeData - Pointer to user data to be transferred back from
        the peer during multipoint session establishment.

    SocketQOS - Pointer to the flowspecs for SocketHandle, one in each
        direction.

    GroupQOS - Pointer to the flowspecs for the socket group, if any.

    Flags - Flags to indicate if the socket is acting as sender,
        receiver, or both.

Return Value:

    INT - 0 if successful, a WinSock error code if not.

--*/

{

    struct ipv6_mreq req;
    INT err;
    PWSHTCPIP_SOCKET_CONTEXT context;

    UNREFERENCED_PARAMETER(TdiConnectionObjectHandle);
    UNREFERENCED_PARAMETER(Flags);

    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        TdiAddressObjectHandle == NULL ||
        Sockaddr == NULL ||
        Sockaddr->sa_family != AF_INET6 ||
        SockaddrLength < sizeof(SOCKADDR_IN6) ||
        ( CallerData != NULL && CallerData->len > 0 ) ||
        ( CalleeData != NULL && CalleeData->len > 0 ) ||
        SocketQOS != NULL ||
        GroupQOS != NULL ) {

        return WSAEINVAL;

    }

    //
    // Add membership.
    //

    req.ipv6mr_multiaddr = ((LPSOCKADDR_IN6)Sockaddr)->sin6_addr;

    req.ipv6mr_interface = 0;

    err = SetTdiInformation(
              TdiAddressObjectHandle,
              CL_TL_ENTITY,
              INFO_CLASS_PROTOCOL,
              INFO_TYPE_ADDRESS_OBJECT,
              AO_OPTION_ADD_MCAST,
              &req,
              sizeof(req),
              TRUE
              );

    if( err == NO_ERROR ) {

        //
        // On NT4, we are called with a leaf socket.
        // On NT5, the leaf socket is null.
        //
        if ((LeafHelperDllSocketContext != NULL) &&
            (LeafSocketHandle != INVALID_SOCKET)) {
            //
            // Record this fact in the leaf socket so we can drop membership
            // when the leaf socket is closed.
            //

            context = LeafHelperDllSocketContext;

            context->MultipointLeaf = TRUE;
            context->MultipointTarget = req.ipv6mr_multiaddr;
            context->MultipointRootTdiAddressHandle = TdiAddressObjectHandle;
        }
    }

    return err;

} // WSHJoinLeaf


INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    )

/*++

Routine Description:

    Retrieves a pointer to the WSAPROTOCOL_INFOW structure(s) describing
    the protocol(s) supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProtocolInfo - Receives a pointer to the WSAPROTOCOL_INFOW array.

    ProtocolInfoEntries - Receives the number of entries in the array.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProtocolInfo == NULL ||
        ProtocolInfoEntries == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, TCPIPV6_NAME ) == 0 ) {

        *ProtocolInfo = Winsock2Protocols;
        *ProtocolInfoEntries = NUM_WINSOCK2_PROTOCOLS;

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetWSAProtocolInfo


INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    PSOCKADDR_IN6 addr;

    UNREFERENCED_PARAMETER(ProtocolInfo);

    //
    // Quick sanity checks.
    //
    if ((Address == NULL) ||
        (AddressLength < sizeof(SOCKADDR_IN6)) ||
        (AddressString == NULL) ||
        (AddressStringLength == NULL)) {

        return WSAEFAULT;
    }
    addr = (PSOCKADDR_IN6)Address;
    if (addr->sin6_family != AF_INET6) {
        return WSAEINVAL;
    }
    if (!NT_SUCCESS(RtlIpv6AddressToStringExW(&addr->sin6_addr, 
                                              addr->sin6_scope_id, 
                                              addr->sin6_port,
                                              AddressString, 
                                              AddressStringLength))) {
        return WSAEFAULT;
    }
    return NO_ERROR;
} // WSHAddressToString


INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    )

/*++

Routine Description:

    Fills in a SOCKADDR structure by parsing a human-readable string.

    The syntax is address%scope-id or [address%scope-id]:port, where 
    the scope-id and port are optional.
    Note that since the IPv6 address format uses a varying number
    of ':' characters, the IPv4 convention of address:port cannot
    be supported without the braces.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    AddressFamily - The address family to which the string belongs.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    Address - Receives the SOCKADDR structure.

    AddressLength - On input, contains the length of Address. On output,
        contains the number of bytes actually written to Address.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    PSOCKADDR_IN6 addr;

    UNREFERENCED_PARAMETER(ProtocolInfo);

    //
    // Quick sanity checks.
    //
    if ((AddressString == NULL) ||
        (Address == NULL) ||
        (AddressLength == NULL) ||
        (*AddressLength < sizeof(SOCKADDR_IN6))) {

        return WSAEFAULT;
    }

    if (AddressFamily != AF_INET6) {

        return WSAEINVAL;
    }
    addr = (PSOCKADDR_IN6)Address;
    ZeroMemory(Address, sizeof(SOCKADDR_IN6));
    if (!NT_SUCCESS(RtlIpv6StringToAddressExW(AddressString,  
                                              &addr->sin6_addr, 
                                              &addr->sin6_scope_id,
                                              &addr->sin6_port))) {
        return WSAEINVAL;
    } 
    addr->sin6_family = AF_INET6;
    *AddressLength = sizeof(SOCKADDR_IN6);
    return NO_ERROR;

} // WSHStringToAddress


INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, TCPIPV6_NAME ) == 0 ) {

        CopyMemory(
            ProviderGuid,
            &IPv6ProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid

INT
SortIPv6Addrs(
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned)
{
    PBYTE            pBuff = NULL;
    PBYTE            pDupIn = NULL;
    TDI_ADDRESS_IP6 *pTDI;
    SOCKET_ADDRESS_LIST *pIn  = (SOCKET_ADDRESS_LIST *)InputBuffer;
    SOCKET_ADDRESS_LIST *pOut = (SOCKET_ADDRESS_LIST *)OutputBuffer;
    SOCKADDR_IN6   *pAddr6;
    HANDLE Handle = INVALID_HANDLE_VALUE;
    DWORD          *pKey, i, NumAddrsIn;
    DWORD           NumAddrsOut, InListLength;
    u_long AddrListBytes;
    int rc;
    INT err = 0;

    *NumberOfBytesReturned = 0;

    // Make sure input buffer is big enough to contain a list
    if (InputBufferLength < sizeof(SOCKET_ADDRESS_LIST)) {
        return WSAEINVAL;
    }

    NumAddrsIn = pIn->iAddressCount;

    // Make sure input buffer is actually big enough to hold the whole list
    InListLength = (DWORD)FIELD_OFFSET(SOCKET_ADDRESS_LIST,Address[NumAddrsIn]);
    if (InputBufferLength < InListLength) {
        return WSAEINVAL;
    }

    //
    // Open a handle to the IPv6 device.
    //
    Handle = CreateFileW(WIN_IPV6_DEVICE_NAME,
        0,      // access mode
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,   // security attributes
        OPEN_EXISTING,
        0,      // flags & attributes
        NULL);  // template file

    if (Handle == INVALID_HANDLE_VALUE) {
        //
        // We can not sort the list.
        //
        err = WSASERVICE_NOT_FOUND;
        goto Done;
    }

    //
    // Convert input to TDI list,
    // with extra space for an array of indices
    // following the array of addresses.
    //
    AddrListBytes = ALIGN_UP(NumAddrsIn * sizeof(TDI_ADDRESS_IP6), DWORD);
    AddrListBytes += NumAddrsIn * sizeof(DWORD);
    pBuff = HeapAlloc(GetProcessHeap(), 0, AddrListBytes);
    if (!pBuff) {
        err = WSAENOBUFS;
        goto Done;
    }
    pTDI = (TDI_ADDRESS_IP6 *)pBuff;

    for (i=0; i<NumAddrsIn; i++) {
        pAddr6 = (LPSOCKADDR_IN6)(pIn->Address[i].lpSockaddr);

        // Make sure it's an IPv6 sockaddr
        if (pAddr6->sin6_family != AF_INET6) {
            err = WSAEINVAL;
            break;
        }

        memcpy(&pTDI[i], &pAddr6->sin6_port, sizeof(TDI_ADDRESS_IP6));
    }
    if (err)
        goto Done;

    rc = DeviceIoControl(Handle, IOCTL_IPV6_SORT_DEST_ADDRS,
                         pBuff, NumAddrsIn * sizeof(TDI_ADDRESS_IP6),
                         pBuff, AddrListBytes,
                         &AddrListBytes, NULL);
    if (! rc) {
        //
        // We can not sort the list.
        //
        err = GetLastError();
        goto Done;
    }

    //
    // There might be fewer addresses now.
    //
    NumAddrsOut = (AddrListBytes - NumAddrsIn * sizeof(TDI_ADDRESS_IP6))
                    / sizeof(DWORD);

    //
    // The key array starts after the address array.
    //
    pKey = (PDWORD)ALIGN_UP_POINTER(pBuff + 
              NumAddrsIn * sizeof(TDI_ADDRESS_IP6), DWORD);

    *NumberOfBytesReturned = FIELD_OFFSET(SOCKET_ADDRESS_LIST,
                                          Address[NumAddrsOut]);

    if (OutputBufferLength < *NumberOfBytesReturned) {
        err = WSAEFAULT;
        goto Done;
    }

    // First go and update all the scope ids
    for (i=0; i<NumAddrsIn; i++) {
        ((LPSOCKADDR_IN6)pIn->Address[i].lpSockaddr)->sin6_scope_id =
            pTDI[i].sin6_scope_id;
    }

    // Make a copy of the input buffer in case we will overwrite it
    if (pIn == pOut) {
        pDupIn = HeapAlloc(GetProcessHeap(), 0, InListLength);
        if (!pDupIn) {
            err = WSAENOBUFS;
            goto Done;
        }
        CopyMemory(pDupIn, InputBuffer, InListLength );
        pIn = (SOCKET_ADDRESS_LIST *)pDupIn;
    }

    // Now fill in the output sockaddr list
    pOut->iAddressCount = NumAddrsOut;
    for (i=0; i<NumAddrsOut; i++) {
        pOut->Address[i] = pIn->Address[pKey[i]];
    }

Done:
    if (pDupIn)
        HeapFree(GetProcessHeap(), 0, pDupIn);

    if (pBuff)
        HeapFree(GetProcessHeap(), 0, pBuff);

    if (Handle != INVALID_HANDLE_VALUE)
        CloseHandle(Handle);

    return err;
}

INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    )

/*++

Routine Description:

    Performs queries & controls on the socket. This is basically an
    "escape hatch" for IOCTLs not supported by MSAFD.DLL. Any unknown
    IOCTLs are routed to the socket's helper DLL for protocol-specific
    processing.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    IoControlCode - Control code of the operation to perform.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

    OutputBuffer - Address of the output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to the output buffer.

    Overlapped - Pointer to a WSAOVERLAPPED structure for overlapped
        operations.

    CompletionRoutine - Pointer to a completion routine to call when
        the operation is completed.

    NeedsCompletion - WSAIoctl() can be overlapped, with all the gory
        details that involves, such as setting events, queuing completion
        routines, and posting to IO completion ports. Since the majority
        of the IOCTL codes can be completed quickly "in-line", MSAFD.DLL
        can optionally perform the overlapped completion of the operation.

        Setting *NeedsCompletion to TRUE (the default) causes MSAFD.DLL
        to handle all of the IO completion details iff this is an
        overlapped operation on an overlapped socket.

        Setting *NeedsCompletion to FALSE tells MSAFD.DLL to take no
        further action because the helper DLL will perform any necessary
        IO completion.

        Note that if a helper performs its own IO completion, the helper
        is responsible for maintaining the "overlapped" mode of the socket
        at socket creation time and NOT performing overlapped IO completion
        on non-overlapped sockets.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    INT err;

    UNREFERENCED_PARAMETER(Overlapped);
    UNREFERENCED_PARAMETER(CompletionRoutine);

    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        NumberOfBytesReturned == NULL ||
        NeedsCompletion == NULL ) {

        return WSAEINVAL;

    }

    *NeedsCompletion = TRUE;

    switch( IoControlCode ) {

    case SIO_MULTIPOINT_LOOPBACK :
        err = WSHSetSocketInformation(
                  HelperDllSocketContext,
                  SocketHandle,
                  TdiAddressObjectHandle,
                  TdiConnectionObjectHandle,
                  IPPROTO_IPV6,
                  IPV6_MULTICAST_LOOP,
                  (PCHAR)InputBuffer,
                  (INT)InputBufferLength
                  );
        break;

    case SIO_MULTICAST_SCOPE :
        err = WSHSetSocketInformation(
                  HelperDllSocketContext,
                  SocketHandle,
                  TdiAddressObjectHandle,
                  TdiConnectionObjectHandle,
                  IPPROTO_IPV6,
                  IPV6_MULTICAST_HOPS,
                  (PCHAR)InputBuffer,
                  (INT)InputBufferLength
                  );
        break;

    case SIO_ADDRESS_LIST_SORT:
        err = SortIPv6Addrs(InputBuffer, InputBufferLength,
                            OutputBuffer, OutputBufferLength,
                            NumberOfBytesReturned);
        break;

    case SIO_KEEPALIVE_VALS: {
        struct tcp_keepalive *optionval;
        PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;

        //
        // Atempt to turn on or off keepalive sending, as necessary.
        //

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        if ( InputBufferLength != sizeof(struct tcp_keepalive) ) {
            return WSAEINVAL;
        }

        optionval = (struct tcp_keepalive *)InputBuffer;

        if (optionval->onoff != 0 ) {

            //
            // Application wants to turn the keepalive on and also give the
            // relevant parameters for it. If the TDI connection object handle
            // is NULL, then the socket is not yet connected.  In this case
            // we'll just remember that the keepalive option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                err = SetTdiInformation(
                    TdiConnectionObjectHandle,
                    CO_TL_ENTITY,
                    INFO_CLASS_PROTOCOL,
                    INFO_TYPE_CONNECTION,
                    TCP_SOCKET_KEEPALIVE_VALS,
                    optionval,
                    InputBufferLength,
                    TRUE
                    );
                if ( err != NO_ERROR ) {
                    return err;
                }
            }

            //
            // Remember that keepalives are enabled for this socket.
            //

            context->KeepAliveVals.onoff = TRUE;
            context->KeepAliveVals.keepalivetime = optionval->keepalivetime;
            context->KeepAliveVals.keepaliveinterval = optionval->keepaliveinterval;

        } else if ( optionval->onoff == 0 ) {

            //
            // Application wants to turn keepalive off.  If the TDI
            // connection object is NULL, the socket is not yet
            // connected.  In this case we'll just remember that
            // keepalives are disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                err = SetTdiInformation(
                    TdiConnectionObjectHandle,
                    CO_TL_ENTITY,
                    INFO_CLASS_PROTOCOL,
                    INFO_TYPE_CONNECTION,
                    TCP_SOCKET_KEEPALIVE_VALS,
                    optionval,
                    InputBufferLength,
                    TRUE
                    );
                if ( err != NO_ERROR ) {
                    return err;
                }
            }

            //
            // Remember that keepalives are disabled for this socket.
            //

            context->KeepAliveVals.onoff = FALSE;
        }

        err = NO_ERROR;
        break;
      }

    default :
        err = WSAEINVAL;
        break;
    }

    return err;

}   // WSHIoctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\tpipv6\wship6\smpletcp.h ===
// -*- mode: C++; tab-width: 4; indent-tabs-mode: nil -*- (for GNU Emacs)
//
// Copyright (c) 1985-2000 Microsoft Corporation
//
// This file is part of the Microsoft Research IPv6 Network Protocol Stack.
// You should have received a copy of the Microsoft End-User License Agreement
// for this software along with this release; see the file "license.txt".
// If not, please see http://www.research.microsoft.com/msripv6/license.htm,
// or write to Microsoft Research, One Microsoft Way, Redmond, WA 98052-6399.
//
// Abstract:
//
// This file contains public definitions exported to transport layer and
// application software.
//


#define TCP_SOCKET_NODELAY      1
#define TCP_SOCKET_KEEPALIVE    2
#define TCP_SOCKET_OOBINLINE    3
#define TCP_SOCKET_BSDURGENT    4
#define TCP_SOCKET_ATMARK       5
#define TCP_SOCKET_WINDOW       6
#define TCP_SOCKET_KEEPALIVE_VALS 7

#define AO_OPTION_TTL              1
#define AO_OPTION_MCASTTTL         2
#define AO_OPTION_MCASTIF          3
#define AO_OPTION_XSUM             4
#define AO_OPTION_IPOPTIONS        5
#define AO_OPTION_ADD_MCAST        6
#define AO_OPTION_DEL_MCAST        7
#define AO_OPTION_TOS              8
#define AO_OPTION_IP_DONTFRAGMENT  9
#define AO_OPTION_MCASTLOOP        10
#define AO_OPTION_UDP_CHKSUM_COVER 11
#define AO_OPTION_IP_HDRINCL       12
#define AO_OPTION_IP_PKTINFO       27
#define AO_OPTION_RCV_HOPLIMIT     36
#define AO_OPTION_PROTECT          38

typedef struct IPSNMPInfo {
    ulong       ipsi_forwarding;
    ulong       ipsi_defaultttl;
    ulong       ipsi_inreceives;
    ulong       ipsi_inhdrerrors;
    ulong       ipsi_inaddrerrors;
    ulong       ipsi_forwdatagrams;
    ulong       ipsi_inunknownprotos;
    ulong       ipsi_indiscards;
    ulong       ipsi_indelivers;
    ulong       ipsi_outrequests;
    ulong       ipsi_routingdiscards;
    ulong       ipsi_outdiscards;
    ulong       ipsi_outnoroutes;
    ulong       ipsi_reasmtimeout;
    ulong       ipsi_reasmreqds;
    ulong       ipsi_reasmoks;
    ulong       ipsi_reasmfails;
    ulong       ipsi_fragoks;
    ulong       ipsi_fragfails;
    ulong       ipsi_fragcreates;
    ulong       ipsi_numif;
    ulong       ipsi_numaddr;
    ulong       ipsi_numroutes;
} IPSNMPInfo;

typedef struct IPAddrEntry {
    ulong       iae_addr;
    ulong       iae_index;
    ulong       iae_mask;
    ulong       iae_bcastaddr;
    ulong       iae_reasmsize;
    ushort      iae_context;
    ushort      iae_pad;
} IPAddrEntry;

#define IP_MIB_STATS_ID                 1
#define IP_MIB_ADDRTABLE_ENTRY_ID       0x102
#define IP_INTFC_FLAG_P2P   1

typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define IF_MIB_STATS_ID     1
#define MAX_PHYSADDR_SIZE   8
#define MAX_IFDESCR_LEN         256

typedef struct IFEntry {
    ulong           if_index;
    ulong           if_type;
    ulong           if_mtu;
    ulong           if_speed;
    ulong           if_physaddrlen;
    uchar           if_physaddr[MAX_PHYSADDR_SIZE];
    ulong           if_adminstatus;
    ulong           if_operstatus;
    ulong           if_lastchange;
    ulong           if_inoctets;
    ulong           if_inucastpkts;
    ulong           if_innucastpkts;
    ulong           if_indiscards;
    ulong           if_inerrors;
    ulong           if_inunknownprotos;
    ulong           if_outoctets;
    ulong           if_outucastpkts;
    ulong           if_outnucastpkts;
    ulong           if_outdiscards;
    ulong           if_outerrors;
    ulong           if_outqlen;
    ulong           if_descrlen;
    uchar           if_descr[1];
} IFEntry;

#define IP_INTFC_INFO_ID                0x103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\winsock\wshtcpip.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    WshTcpip.c

Abstract:

    This module contains necessary routines for the TCP/IP Windows Sockets
    Helper DLL.  This DLL provides the transport-specific support necessary
    for the Windows Sockets DLL to use TCP/IP as a transport.

Author:

    David Treadwell (davidtr)    19-Jul-1992

Revision History:

    Keith Moore (keithmo)        02-May-1996
        Added WinSock 2 support.
    Dave Thaler (dthaler)        17-Jan-2000
        Added IGMPv3 support.

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <tdi.h>

#include <ws2tcpip.h>
#include <wsahelp.h>
#include <ipexport.h>

#include <tdistat.h>
#include <tdiinfo.h>
#include <llinfo.h>
#include <ipinfo.h>
#include <ntddtcp.h>

typedef unsigned long   ulong;
typedef unsigned short  ushort;
typedef unsigned int    uint;
typedef unsigned char   uchar;
#define TL_INSTANCE 0

// private socket options to be accessed via WSAIoctl
#include <mstcpip.h>

#include <ntddtcp.h>

#define NT // temporarily needed by tdiinfo.h...

#include <ipexport.h>
#include <tdiinfo.h>
#include <tcpinfo.h>
#include <ipinfo.h>

#include <basetyps.h>
#include <nspapi.h>
#include <nspapip.h>

#include <afd.h>

#define TCP_NAME L"TCP/IP"
#define UDP_NAME L"UDP/IP"

#define IS_DGRAM_SOCK(type)  (((type) == SOCK_DGRAM) || ((type) == SOCK_RAW))

//
// Define valid flags for WSHOpenSocket2().
//

#define VALID_TCP_FLAGS         (WSA_FLAG_OVERLAPPED)

#define VALID_UDP_FLAGS         (WSA_FLAG_OVERLAPPED |          \
                                 WSA_FLAG_MULTIPOINT_C_LEAF |   \
                                 WSA_FLAG_MULTIPOINT_D_LEAF)

//
// Buffer management constants for GetTcpipInterfaceList().
//

#define MAX_FAST_ENTITY_BUFFER ( sizeof(TDIEntityID) * 10 )
#define MAX_FAST_ADDRESS_BUFFER ( sizeof(IPAddrEntry) * 4 )


//
// Structure and variables to define the triples supported by TCP/IP. The
// first entry of each array is considered the canonical triple for
// that socket type; the other entries are synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE TcpMappingTriples[] = { AF_INET,   SOCK_STREAM, IPPROTO_TCP,
                                       AF_INET,   SOCK_STREAM, 0,
                                       AF_INET,   0,           IPPROTO_TCP,
                                       AF_UNSPEC, 0,           IPPROTO_TCP,
                                       AF_UNSPEC, SOCK_STREAM, IPPROTO_TCP };

MAPPING_TRIPLE UdpMappingTriples[] = { AF_INET,   SOCK_DGRAM,  IPPROTO_UDP,
                                       AF_INET,   SOCK_DGRAM,  0,
                                       AF_INET,   0,           IPPROTO_UDP,
                                       AF_UNSPEC, 0,           IPPROTO_UDP,
                                       AF_UNSPEC, SOCK_DGRAM,  IPPROTO_UDP };

MAPPING_TRIPLE RawMappingTriples[] = { AF_INET,   SOCK_RAW,    0 };

//
// Winsock 2 WSAPROTOCOL_INFO structures for all supported protocols.
//

#define WINSOCK_SPI_VERSION 2
#define UDP_MESSAGE_SIZE    (65535-68)

WSAPROTOCOL_INFOW Winsock2Protocols[] =
    {
        //
        // TCP
        //

        {
            XP1_GUARANTEED_DELIVERY                 // dwServiceFlags1
                | XP1_GUARANTEED_ORDER
                | XP1_GRACEFUL_CLOSE
                | XP1_EXPEDITED_DATA
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_STREAM,                            // iSocketType
            IPPROTO_TCP,                            // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            0,                                      // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [TCP/IP]"                 // szProtocol
        },

        //
        // UDP
        //

        {
            XP1_CONNECTIONLESS                      // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                | XP1_SUPPORT_BROADCAST
                | XP1_SUPPORT_MULTIPOINT
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO,              // dwProviderFlags
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_DGRAM,                             // iSocketType
            IPPROTO_UDP,                            // iProtocol
            0,                                      // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            UDP_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [UDP/IP]"                 // szProtocol
        },

        //
        // RAW
        //

        {
            XP1_CONNECTIONLESS                      // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                | XP1_SUPPORT_BROADCAST
                | XP1_SUPPORT_MULTIPOINT
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO               // dwProviderFlags
                | PFL_HIDDEN,
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_INET,                                // iAddressFamily
            sizeof(SOCKADDR_IN),                    // iMaxSockAddr
            sizeof(SOCKADDR_IN),                    // iMinSockAddr
            SOCK_RAW,                               // iSocketType
            0,                                      // iProtocol
            255,                                    // iProtocolMaxOffset
            BIGENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            UDP_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Tcpip [RAW/IP]"                 // szProtocol
        }

    };

#define NUM_WINSOCK2_PROTOCOLS  \
            ( sizeof(Winsock2Protocols) / sizeof(Winsock2Protocols[0]) )

//
// The GUID identifying this provider.
//

GUID TcpipProviderGuid = { /* e70f1aa0-ab8b-11cf-8ca3-00805f48a192 */
    0xe70f1aa0,
    0xab8b,
    0x11cf,
    {0x8c, 0xa3, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}
    };

//
// Forward declarations of internal routines.
//

VOID
CompleteTdiActionApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock
    );

INT
GetTdiInformation (
    IN HANDLE TdiConnectionObjectHandle,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG InValueLength,
    IN ULONG OutValueLength
    );

INT
SetTdiInformation (
    IN HANDLE TdiConnectionObjectHandle,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN BOOLEAN WaitForCompletion
    );

BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    );

NTSTATUS
GetTcpipInterfaceList(
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned
    );

INT
NtStatusToSocketError (
    IN NTSTATUS Status
    );


//
// The socket context structure for this DLL.  Each open TCP/IP socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHTCPIP_SOCKET_CONTEXT {
    INT     AddressFamily;
    INT     SocketType;
    INT     Protocol;
    INT     ReceiveBufferSize;
    DWORD   Flags;
    INT     MulticastTtl;
    ULONG   MulticastInterface;
    struct tcp_keepalive KeepAliveVals;
    IN_ADDR MultipointTarget;
    INT     HdrInclude;
    BOOLEAN UcastIf;
    BOOLEAN MulticastLoopback;
    BOOLEAN KeepAlive;
    BOOLEAN DontRoute;
    
    BOOLEAN NoDelay;
    BOOLEAN BsdUrgent;
    BOOLEAN MultipointLeaf;
    BOOLEAN UdpNoChecksum;
    
    BOOLEAN ReceiveBroadcast;
    BOOLEAN HdrIncludeSet;
    BOOLEAN LimitBroadcasts;
    UCHAR   IpPktInfo;

    UCHAR   IpTtl;
    UCHAR   IpTos;
    UCHAR   IpDontFragment;
    UCHAR   IpOptionsLength;

    UCHAR   IpOptions[MAX_OPT_SIZE];

} WSHTCPIP_SOCKET_CONTEXT, *PWSHTCPIP_SOCKET_CONTEXT;

#define DEFAULT_RECEIVE_BUFFER_SIZE 8192
#define DEFAULT_MULTICAST_TTL 1
#define DEFAULT_MULTICAST_INTERFACE INADDR_ANY
#define DEFAULT_MULTICAST_LOOPBACK TRUE
#define DEFAULT_RECEIVE_BROADCAST TRUE
#define DEFAULT_UCAST_IF  FALSE

//
//
#define DEFAULT_IP_TTL 32
#define DEFAULT_IP_TOS 0



BOOLEAN
DllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need to receive thread attach and detach
        // notifications, so disable them to help application
        // performance.
        //

        DisableThreadLibraryCalls( DllHandle );

        return TRUE;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;

} // SockInitialize

INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNALIGNED SOCKADDR_IN *sockaddr = (PSOCKADDR_IN)Sockaddr;
    ULONG i;

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_IN) ) {
        return WSAEFAULT;
    }
    
    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->sin_family != AF_INET ) {
        return WSAEAFNOSUPPORT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address portion of the sockaddr.
    //

    if ( sockaddr->sin_addr.s_addr == INADDR_ANY ) {
        ASSERT (htonl(INADDR_ANY)==INADDR_ANY);
        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
    } else if ( sockaddr->sin_addr.s_addr == INADDR_BROADCAST ) {
        ASSERT (htonl(INADDR_BROADCAST)==INADDR_BROADCAST);
        SockaddrInfo->AddressInfo = SockaddrAddressInfoBroadcast;
    } else if ( sockaddr->sin_addr.s_addr == htonl(INADDR_LOOPBACK) ) {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoLoopback;
    } else {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;
    }

    //
    // Determine the type of the port (endpoint) in the sockaddr.
    //

    if ( sockaddr->sin_port == 0 ) {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    } else if ( ntohs( sockaddr->sin_port ) < 1025 ) {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoReserved;
    } else {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;
    }

    //
    // Zero out the sin_zero part of the address.  We silently allow
    // nonzero values in this field.
    //

    for ( i = 0; i < sizeof(sockaddr->sin_zero); i++ ) {
        sockaddr->sin_zero[i] = 0;
    }

    return NO_ERROR;

} // WSHGetSockaddrType


INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE, SO_DONTROUTE, and TCP_EXPEDITED_1122.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to getsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( OptionValue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *OptionLength < sizeof(*context) ) {
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            RtlCopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        return NO_ERROR;
    }

    //
    // The only other levels we support here are SOL_SOCKET,
    // IPPROTO_TCP, IPPROTO_UDP, and IPPROTO_IP.
    //

    if ( Level != SOL_SOCKET &&
         Level != IPPROTO_TCP &&
         Level != IPPROTO_UDP &&
         Level != IPPROTO_IP ) {
        return WSAEINVAL;
    }

    //
    // Make sure that the output buffer is sufficiently large.
    //

    if ( *OptionLength < sizeof(char)) {
        return WSAEFAULT;
    }

    __try {
        RtlZeroMemory( OptionValue, *OptionLength );
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return WSAEFAULT;
    }

    //
    // Handle TCP-level options.
    //

    if ( Level == IPPROTO_TCP ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        switch ( OptionName ) {

        case TCP_NODELAY:


            *OptionValue = context->NoDelay;
            *OptionLength = *OptionLength<sizeof (int) ? sizeof (char) : sizeof(int);
            break;

        case TCP_EXPEDITED_1122:


            *OptionValue = !context->BsdUrgent;
            *OptionLength = *OptionLength<sizeof (int) ? sizeof (char) : sizeof(int);
            break;

        default:

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle UDP-level options.
    //

    if ( Level == IPPROTO_UDP ) {

        switch ( OptionName ) {

        case UDP_NOCHECKSUM :

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            *OptionValue = context->UdpNoChecksum;
            *OptionLength = *OptionLength<sizeof (int) ? sizeof (char) : sizeof(int);
            break;


            break;
        default :

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle IP-level options.
    //

    if ( Level == IPPROTO_IP ) {


        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IP_TTL:

            *OptionValue = (char) context->IpTtl;
            *OptionLength = *OptionLength<sizeof (int) ? sizeof (char) : sizeof(int);

            return NO_ERROR;

        case IP_TOS:

            *OptionValue = (char) context->IpTos;
            *OptionLength = *OptionLength<sizeof (int) ? sizeof (char) : sizeof(int);

            return NO_ERROR;

        case IP_DONTFRAGMENT:

            *OptionValue = (char) context->IpDontFragment;
            *OptionLength = *OptionLength<sizeof (int) ? sizeof (char) : sizeof(int);

            return NO_ERROR;

        case IP_OPTIONS:
            if ( *OptionLength < context->IpOptionsLength ) {
                return WSAEFAULT;
            }

            if (context->IpOptionsLength>0) {
                RtlMoveMemory(
                    OptionValue,
                    context->IpOptions,
                    context->IpOptionsLength
                    );
            }

            *OptionLength = context->IpOptionsLength;

            return NO_ERROR;

        default:
            //
            // No match, fall through.
            //
            break;
        }

        //
        // The following IP options are only valid on datagram sockets.
        //

        if ( !IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IP_MULTICAST_TTL:


            *OptionValue = (char)context->MulticastTtl;
            *OptionLength = *OptionLength<sizeof (int) ? sizeof (char) : sizeof(int);

            return NO_ERROR;

        case IP_MULTICAST_IF:

            *(int *)OptionValue = context->MulticastInterface;
            *OptionLength = sizeof(int);

            return NO_ERROR;

        case IP_MULTICAST_LOOP:


            *OptionValue = context->MulticastLoopback;
            *OptionLength = *OptionLength<sizeof (int) ? sizeof (char) : sizeof(int);

            return NO_ERROR;

        case IP_HDRINCL:
            // User hdr include option
            //
            //
            if (*OptionLength<sizeof (int))
                return WSAEFAULT;

            if (context->HdrIncludeSet == TRUE) {
                *((PINT)OptionValue) = context->HdrInclude;
            }
            else {
                *((PINT)OptionValue) = 0;
            }

            *OptionLength = sizeof(int);
            return NO_ERROR;

        case IP_PKTINFO:

            *OptionValue = (char) context->IpPktInfo;
            *OptionLength = *OptionLength < sizeof (int) ? sizeof (char) : sizeof(int);

            return NO_ERROR;

        case IP_RECEIVE_BROADCAST:
            if (*OptionLength < sizeof(int))
                return WSAEFAULT;

            *((PINT)OptionValue) = context->ReceiveBroadcast;
            *OptionLength = sizeof(int);
            return NO_ERROR;

        default:

            return WSAENOPROTOOPT;
        }
    }

    //
    // Handle socket-level options.
    //

    switch ( OptionName ) {

    case SO_KEEPALIVE:

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        *OptionValue = context->KeepAlive;
        *OptionLength = *OptionLength<sizeof (int) ? sizeof (char) : sizeof(int);

        break;

    case SO_DONTROUTE:

        *OptionValue = context->DontRoute;
        *OptionLength = *OptionLength<sizeof (int) ? sizeof (char) : sizeof(int);

        break;

    default:

        return WSAENOPROTOOPT;
    }

    return NO_ERROR;

} // WSHGetSocketInformation


INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For TCP/IP, a wildcard address has IP address ==
    0.0.0.0 and port = 0.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    if ( *SockaddrLength < sizeof(SOCKADDR_IN) ) {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_IN);

    //
    // Just zero out the address and set the family to AF_INET--this is
    // a wildcard address for TCP/IP.
    //

    RtlZeroMemory( Sockaddr, sizeof(SOCKADDR_IN) );

    Sockaddr->sa_family = AF_INET;

    return NO_ERROR;

} // WSAGetWildcardSockaddr


DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;

    mappingLength = sizeof(WINSOCK_MAPPING) - sizeof(MAPPING_TRIPLE) +
                        sizeof(TcpMappingTriples) + sizeof(UdpMappingTriples)
                        + sizeof(RawMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength ) {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows = sizeof(TcpMappingTriples) / sizeof(TcpMappingTriples[0])
                     + sizeof(UdpMappingTriples) / sizeof(UdpMappingTriples[0])
                     + sizeof(RawMappingTriples) / sizeof(RawMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);
    RtlMoveMemory(
        Mapping->Mapping,
        TcpMappingTriples,
        sizeof(TcpMappingTriples)
        );
    RtlMoveMemory(
        (PCHAR)Mapping->Mapping + sizeof(TcpMappingTriples),
        UdpMappingTriples,
        sizeof(UdpMappingTriples)
        );
    RtlMoveMemory(
        (PCHAR)Mapping->Mapping + sizeof(TcpMappingTriples)
                                + sizeof(UdpMappingTriples),
        RawMappingTriples,
        sizeof(RawMappingTriples)
        );

    //
    // Return the number of bytes we wrote.
    //

    return mappingLength;

} // WSHGetWinsockMapping


INT
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )
{
    return WSHOpenSocket2(
               AddressFamily,
               SocketType,
               Protocol,
               0,           // Group
               0,           // Flags
               TransportDeviceName,
               HelperDllSocketContext,
               NotificationEvents
               );

} // WSHOpenSocket


INT
WSHOpenSocket2 (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    Group - Identifies the group for the new socket.

    Flags - Zero or more WSA_FLAG_* flags as passed into WSASocket().

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context;
    BOOLEAN FreeDeviceNameBuffer = FALSE;
    
    //
    // Determine whether this is to be a TCP, UDP, or RAW socket.
    //

    if ( IsTripleInList(
             TcpMappingTriples,
             sizeof(TcpMappingTriples) / sizeof(TcpMappingTriples[0]),
             *AddressFamily,
             *SocketType,
             *Protocol ) ) {

        //
        // It's a TCP socket. Check the flags.
        //

        if( ( Flags & ~VALID_TCP_FLAGS ) != 0 ) {

            return WSAEINVAL;

        }

        //
        // Return the canonical form of a TCP socket triple.
        //

        *AddressFamily = TcpMappingTriples[0].AddressFamily;
        *SocketType = TcpMappingTriples[0].SocketType;
        *Protocol = TcpMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_STREAM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, DD_TCP_DEVICE_NAME );

    } else if ( IsTripleInList(
                    UdpMappingTriples,
                    sizeof(UdpMappingTriples) / sizeof(UdpMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) ) {

        //
        // It's a UDP socket. Check the flags & group ID.
        //

        if( ( Flags & ~VALID_UDP_FLAGS ) != 0 ||
            Group == SG_CONSTRAINED_GROUP ) {

            return WSAEINVAL;

        }

        //
        // Return the canonical form of a UDP socket triple.
        //

        *AddressFamily = UdpMappingTriples[0].AddressFamily;
        *SocketType = UdpMappingTriples[0].SocketType;
        *Protocol = UdpMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_DGRAM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, DD_UDP_DEVICE_NAME );

    } else if ( IsTripleInList(
                    RawMappingTriples,
                    sizeof(RawMappingTriples) / sizeof(RawMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) )
    {
        UNICODE_STRING  unicodeString;
        NTSTATUS        status;


        //
        // There is no canonicalization to be done for SOCK_RAW.
        //

        if (*Protocol < 0 || *Protocol > 255) {
            return(WSAEINVAL);
        }

        //
        // Indicate the name of the TDI device that will service
        // SOCK_RAW sockets in the internet address family.
        //
        RtlInitUnicodeString(&unicodeString, DD_RAW_IP_DEVICE_NAME);
        RtlInitUnicodeString(TransportDeviceName, NULL);

        TransportDeviceName->MaximumLength = unicodeString.Length +
                                                 (4 * sizeof(WCHAR) +
                                                 sizeof(UNICODE_NULL));

        TransportDeviceName->Buffer = RtlAllocateHeap(
                                          RtlProcessHeap( ),
                                          0,
                                          TransportDeviceName->MaximumLength
                                          );

        if (TransportDeviceName->Buffer == NULL) {
            return(WSAENOBUFS);
        }

        FreeDeviceNameBuffer = TRUE;
        
        //
        // Append the device name.
        //
        status = RtlAppendUnicodeStringToString(
                     TransportDeviceName,
                     &unicodeString
                     );

        ASSERT(NT_SUCCESS(status));

        //
        // Append a separator.
        //
        TransportDeviceName->Buffer[TransportDeviceName->Length/sizeof(WCHAR)] =
                                                      OBJ_NAME_PATH_SEPARATOR;

        TransportDeviceName->Length += sizeof(WCHAR);

        TransportDeviceName->Buffer[TransportDeviceName->Length/sizeof(WCHAR)] =
                                                      UNICODE_NULL;

        //
        // Append the protocol number.
        //
        unicodeString.Buffer = TransportDeviceName->Buffer +
                                 (TransportDeviceName->Length / sizeof(WCHAR));
        unicodeString.Length = 0;
        unicodeString.MaximumLength = TransportDeviceName->MaximumLength -
                                           TransportDeviceName->Length;

        status = RtlIntegerToUnicodeString(
                     (ULONG) *Protocol,
                     10,
                     &unicodeString
                     );

        TransportDeviceName->Length += unicodeString.Length;

        ASSERT(NT_SUCCESS(status));

    } else {

        //
        // This should never happen if the registry information about this
        // helper DLL is correct.  If somehow this did happen, just return
        // an error.
        //

        return WSAEINVAL;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );
    if ( context == NULL ) {
        if ( FreeDeviceNameBuffer ) {
            RtlFreeHeap( RtlProcessHeap( ), 0, TransportDeviceName->Buffer );
        }
        TransportDeviceName->Buffer = NULL;
        return WSAENOBUFS;
    }

    //
    // Initialize the context for the socket.
    //

    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;
    context->ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
    context->Flags = Flags;
    context->MulticastTtl = DEFAULT_MULTICAST_TTL;
    context->MulticastInterface = DEFAULT_MULTICAST_INTERFACE;
    context->MulticastLoopback = DEFAULT_MULTICAST_LOOPBACK;
    context->KeepAlive = FALSE;
    context->DontRoute = FALSE;
    context->NoDelay = FALSE;
    context->BsdUrgent = TRUE;
    context->IpDontFragment = FALSE;
    context->IpTtl = DEFAULT_IP_TTL;
    context->IpTos = DEFAULT_IP_TOS;
    context->IpOptionsLength = 0;
    context->MultipointLeaf = FALSE;
    context->UdpNoChecksum = FALSE;
    context->ReceiveBroadcast = DEFAULT_RECEIVE_BROADCAST;
    context->HdrIncludeSet = FALSE;
    context->KeepAliveVals.onoff = FALSE;
    context->UcastIf = DEFAULT_UCAST_IF;
    context->LimitBroadcasts = FALSE;
    context->IpPktInfo = FALSE;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.  The only times we need to be
    // called is after a connect has completed so that we can turn on
    // the sending of keepalives if SO_KEEPALIVE was set before the
    // socket was connected, when the socket is closed so that we can
    // free context information, and when a connect fails so that we
    // can, if appropriate, dial in to the network that will support the
    // connect attempt.
    //

    if (*SocketType == SOCK_STREAM) {

        *NotificationEvents =
            WSH_NOTIFY_CONNECT | WSH_NOTIFY_CLOSE | WSH_NOTIFY_CONNECT_ERROR;
    }
    else { // *SocketType == SOCK_DGRAM  ||  *SocketType == SOCK_RAW

        *NotificationEvents =
            WSH_NOTIFY_CONNECT | WSH_NOTIFY_CLOSE | WSH_NOTIFY_CONNECT_ERROR |
            WSH_NOTIFY_BIND;
    }

    //
    // Everything worked, return success.
    //

    *HelperDllSocketContext = context;
    return NO_ERROR;

} // WSHOpenSocket


INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;

    //
    // We should only be called after a connect() completes or when the
    // socket is being closed.
    //

    if ( NotifyEvent == WSH_NOTIFY_CONNECT ) {

        ULONG true = TRUE;
        ULONG false = FALSE;

        //
        // If a connection-object option was set on the socket before
        // it was connected, set the option for real now.
        //

        if ( context->KeepAlive ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_KEEPALIVE,
                      &true,
                      sizeof(true),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }


        if ( context->KeepAliveVals.onoff ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_KEEPALIVE_VALS,
                      &context->KeepAliveVals,
                      sizeof(struct tcp_keepalive),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->NoDelay ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_NODELAY,
                      &true,
                      sizeof(true),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( !context->BsdUrgent ) {
            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_BSDURGENT,
                      &false,
                      sizeof(false),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->IpTos != DEFAULT_IP_TOS ) {
            int value = (int) context->IpTos;

            err = SetTdiInformation(
                      TdiConnectionObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_CONNECTION,
                      TCP_SOCKET_TOS,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }
    } else if ( NotifyEvent == WSH_NOTIFY_CLOSE ) {

        //
        // If this is a multipoint leaf, then remove the multipoint target
        // from the session.
        //

        if( context->MultipointLeaf &&
            TdiAddressObjectHandle != NULL ) {

            struct ip_mreq req;

            req.imr_multiaddr = context->MultipointTarget;
            req.imr_interface.s_addr = 0;

            SetTdiInformation(
                TdiAddressObjectHandle,
                CL_TL_ENTITY,
                INFO_CLASS_PROTOCOL,
                INFO_TYPE_ADDRESS_OBJECT,
                AO_OPTION_DEL_MCAST,
                &req,
                sizeof(req),
                TRUE
                );
        }

        //
        // Free the socket context.
        //

        RtlFreeHeap( RtlProcessHeap( ), 0, context );

    } else if ( NotifyEvent == WSH_NOTIFY_CONNECT_ERROR ) {

        //
        // Return WSATRY_AGAIN to get wsock32 to attempt the connect
        // again.  Any other return code is ignored.
        //

    } else if ( NotifyEvent == WSH_NOTIFY_BIND ) {
        ULONG true = TRUE;

        if( context->UdpNoChecksum ) {
            ULONG flag = FALSE;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CL_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_XSUM,
                      &flag,
                      sizeof(flag),
                      TRUE
                      );

            if( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->IpTtl != DEFAULT_IP_TTL ) {
            int value = (int) context->IpTtl;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_TTL,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->IpTos != DEFAULT_IP_TOS ) {
            int value = (int) context->IpTos;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_TOS,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->MulticastTtl != DEFAULT_MULTICAST_TTL ) {
            int value = (int) context->MulticastTtl;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_MCASTTTL,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->MulticastInterface != DEFAULT_MULTICAST_INTERFACE ) {
            int value = (int) context->MulticastInterface;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_MCASTIF,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->MulticastLoopback != DEFAULT_MULTICAST_LOOPBACK ) {
            int value = (int) context->MulticastLoopback;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_MCASTLOOP,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->HdrIncludeSet ) {

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_IP_HDRINCL,
                      &context->HdrInclude,
                      sizeof (context->HdrInclude),
                      TRUE
                      );

            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if (context->IpOptionsLength > 0 ) {
            err = SetTdiInformation(
                        TdiAddressObjectHandle,
                        CO_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_ADDRESS_OBJECT,
                        AO_OPTION_IPOPTIONS,
                        context->IpOptions,
                        context->IpOptionsLength,
                        TRUE
                        );

            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->UcastIf != DEFAULT_UCAST_IF ) {
            int value = (int) context->UcastIf;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_IP_UCASTIF,
                      &value,
                      sizeof(int),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->IpDontFragment ) {
            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_IP_DONTFRAGMENT,
                      &true,
                      sizeof(true),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }


        if ( context->ReceiveBroadcast != DEFAULT_RECEIVE_BROADCAST ) {
            int value = (int) context->ReceiveBroadcast;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_BROADCAST,
                      &value,
                      sizeof(int),
                      TRUE
                      );

            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->LimitBroadcasts ) {

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_LIMIT_BCASTS,
                      &true,
                      sizeof(true),
                      TRUE
                      );
            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->IpPktInfo ) {

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_IP_PKTINFO,
                      &true,
                      sizeof (TRUE),
                      TRUE
                      );

            if ( err != NO_ERROR ) {
                return err;
            }
        }

        if ( context->ReceiveBufferSize != DEFAULT_RECEIVE_BUFFER_SIZE ) {
            int value = (int) context->ReceiveBufferSize;

            err = SetTdiInformation(
                      TdiAddressObjectHandle,
                      CO_TL_ENTITY,
                      INFO_CLASS_PROTOCOL,
                      INFO_TYPE_ADDRESS_OBJECT,
                      AO_OPTION_WINDOW,
                      &value,
                      sizeof(int),
                      TRUE
                      );

            if ( err != NO_ERROR ) {
                return err;
            }
        }

    } else {
        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify


INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  The options supported here
    are SO_KEEPALIVE, SO_DONTROUTE, and TCP_EXPEDITED_1122.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;
    INT error;
    INT optionValue;

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) || ( OptionValue == NULL)) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {
            
            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );
            if ( context == NULL ) {
                return WSAENOBUFS;
            }
            
            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHTCPIP_SOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;

        } else {

            PWSHTCPIP_SOCKET_CONTEXT parentContext;
            INT one = 1;
            INT zero = 0;

            //
            // The socket was accept()'ed and it needs to have the same
            // properties as it's parent.  The OptionValue buffer
            // contains the context information of this socket's parent.
            //

            parentContext = (PWSHTCPIP_SOCKET_CONTEXT)OptionValue;

            ASSERT( context->AddressFamily == parentContext->AddressFamily );
            ASSERT( context->SocketType == parentContext->SocketType );
            ASSERT( context->Protocol == parentContext->Protocol );

            //
            // Turn on in the child any options that have been set in
            // the parent. First restore the child context to default context. 
            // Ignore all the changes made by APP before acceptex complete. 
            //

            context->KeepAlive = FALSE;
            if ( parentContext->KeepAlive ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_KEEPALIVE,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->KeepAliveVals.onoff = FALSE;
            if ( parentContext->KeepAliveVals.onoff ) {
                struct tcp_keepalive *optionval;

                  //
                  // Atempt to turn on or off keepalive sending, as necessary.
                  //

                optionval = (struct tcp_keepalive *)&parentContext->KeepAliveVals;

                if ( TdiConnectionObjectHandle != NULL ) {
                    error = SetTdiInformation(
                        TdiConnectionObjectHandle,
                        CO_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_CONNECTION,
                        TCP_SOCKET_KEEPALIVE_VALS,
                        optionval,
                        sizeof(struct tcp_keepalive),
                        TRUE
                        );
                    if ( error != NO_ERROR ) {
                        return error;
                    }
                }

                //
                // Remember that keepalives are enabled for this socket.
                //

                context->KeepAliveVals.onoff = TRUE;
                context->KeepAliveVals.keepalivetime = optionval->keepalivetime;
                context->KeepAliveVals.keepaliveinterval = optionval->keepaliveinterval;
            }

            context->DontRoute = FALSE;
            if ( parentContext->DontRoute ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_DONTROUTE,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->NoDelay = FALSE;
            if ( parentContext->NoDelay ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            IPPROTO_TCP,
                            TCP_NODELAY,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
            if ( parentContext->ReceiveBufferSize != DEFAULT_RECEIVE_BUFFER_SIZE ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            SOL_SOCKET,
                            SO_RCVBUF,
                            (PCHAR)&parentContext->ReceiveBufferSize,
                            sizeof(parentContext->ReceiveBufferSize)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->BsdUrgent = TRUE;
            if ( !parentContext->BsdUrgent ) {

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            IPPROTO_TCP,
                            TCP_EXPEDITED_1122,
                            (PCHAR)&one,
                            sizeof(one)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->IpTos = DEFAULT_IP_TOS;
            if ( parentContext->IpTos != DEFAULT_IP_TOS ) {
                int value = (int) parentContext->IpTos;

                error = WSHSetSocketInformation(
                            HelperDllSocketContext,
                            SocketHandle,
                            TdiAddressObjectHandle,
                            TdiConnectionObjectHandle,
                            IPPROTO_IP,
                            IP_TOS,
                            (PCHAR)&value,
                            sizeof(value)
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            return NO_ERROR;
        }
    }

    //
    // The only other levels we support here are SOL_SOCKET,
    // IPPROTO_TCP, IPPROTO_UDP, and IPPROTO_IP.
    //

    if ( Level != SOL_SOCKET &&
         Level != IPPROTO_TCP &&
         Level != IPPROTO_UDP &&
         Level != IPPROTO_IP ) {
        return WSAEINVAL;
    }

    //
    // Make sure that the option length is sufficient.
    //

    if ( OptionLength < sizeof(char) || (OptionValue == NULL) ) {
        return WSAEFAULT;
    }

    if ( OptionLength >= sizeof (int)) {
        optionValue = *((INT UNALIGNED *)OptionValue);
    }
    else {
        optionValue = (UCHAR)*OptionValue;
    }

    //
    // Handle TCP-level options.
    //

    if ( Level == IPPROTO_TCP && OptionName == TCP_NODELAY ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Atempt to turn on or off Nagle's algorithm, as necessary.
        //

        if ( !context->NoDelay && optionValue != 0 ) {

            optionValue = TRUE;

            //
            // NoDelay is currently off and the application wants to
            // turn it on.  If the TDI connection object handle is NULL,
            // then the socket is not yet connected.  In this case we'll
            // just remember that the no delay option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_NODELAY,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is enabled for this socket.
            //

            context->NoDelay = TRUE;

        } else if ( context->NoDelay && optionValue == 0 ) {

            //
            // No delay is currently enabled and the application wants
            // to turn it off.  If the TDI connection object is NULL,
            // the socket is not yet connected.  In this case we'll just
            // remember that nodelay is disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_NODELAY,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that no delay is disabled for this socket.
            //

            context->NoDelay = FALSE;
        }

        return NO_ERROR;
    }

    if ( Level == IPPROTO_TCP && OptionName == TCP_EXPEDITED_1122 ) {

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        //
        // Atempt to turn on or off BSD-style urgent data semantics as
        // necessary.
        //

        if ( !context->BsdUrgent && optionValue == 0 ) {

            optionValue = TRUE;

            //
            // BsdUrgent is currently off and the application wants to
            // turn it on.  If the TDI connection object handle is NULL,
            // then the socket is not yet connected.  In this case we'll
            // just remember that the no delay option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_BSDURGENT,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that BSD urgent is enabled for this socket.
            //

            context->BsdUrgent = TRUE;

        } else if ( context->BsdUrgent && optionValue != 0 ) {

            //
            // No delay is currently enabled and the application wants
            // to turn it off.  If the TDI connection object is NULL,
            // the socket is not yet connected.  In this case we'll just
            // remember that BsdUrgent is disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_BSDURGENT,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that BSD urgent is disabled for this socket.
            //

            context->BsdUrgent = FALSE;
        }

        return NO_ERROR;
    }

    //
    // Handle UDP-level options.
    //

    if ( Level == IPPROTO_UDP ) {

        switch ( OptionName ) {

        case UDP_NOCHECKSUM :

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            if( TdiAddressObjectHandle != NULL ) {

                ULONG flag;

                //
                // Note that the incoming flag is TRUE if XSUM should
                // be *disabled*, but the flag we pass to TDI is TRUE
                // if it should be *enabled*, so we must negate the flag.
                //

                flag = (ULONG)!optionValue;

                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_XSUM,
                            &flag,
                            sizeof(flag),
                            TRUE
                            );
                if( error != NO_ERROR ) {
                    return error;
                }

            }

            context->UdpNoChecksum = !!optionValue;
            break;

        default :

            return WSAEINVAL;
        }

        return NO_ERROR;
    }

    //
    // Handle IP-level options.
    //

    if ( Level == IPPROTO_IP ) {

        //
        // Act based on the specific option.
        //
        switch ( OptionName ) {

        case IP_TTL:

            //
            // An attempt to change the unicast TTL sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //
            if ( optionValue > 255 || optionValue < 0 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_TTL,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->IpTtl = (uchar) optionValue;

            return NO_ERROR;

        case IP_TOS:
            //
            // An attempt to change the Type Of Service of packets sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //

            if ( optionValue > 255 || optionValue < 0 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address or connectionobject,
            // set this option to it.  If we don't have a TDI
            // object then we'll have to wait until after the socket
            // is bound or connected.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                          TdiConnectionObjectHandle,
                          CO_TL_ENTITY,
                          INFO_CLASS_PROTOCOL,
                          INFO_TYPE_CONNECTION,
                          TCP_SOCKET_TOS,
                          &optionValue,
                          sizeof(optionValue),
                          TRUE
                          );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }
            else if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_TOS,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->IpTos = (uchar) optionValue;

            return NO_ERROR;

        case IP_MULTICAST_TTL:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // An attempt to change the TTL on multicasts sent on
            // this socket.  It is illegal to set this to a value
            // greater than 255.
            //

            if ( optionValue > 255 || optionValue < 0 ) {
                return WSAEINVAL;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCASTTTL,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->MulticastTtl = optionValue;

            return NO_ERROR;

        case IP_MULTICAST_IF:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }
            
            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //
            
            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCASTIF,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->MulticastInterface = optionValue;

            return NO_ERROR;

        case IP_MULTICAST_LOOP:

            //
            // This option is only valid for datagram sockets.
            //

            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }


            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCASTLOOP,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->MulticastLoopback = optionValue ? TRUE : FALSE;

            return NO_ERROR;

        case IP_ADD_MEMBERSHIP:
        case IP_DROP_MEMBERSHIP:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // Make sure that the option buffer is large enough.
            //

            if ( OptionLength < sizeof(struct ip_mreq) ) {
                return WSAEFAULT;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            OptionName == IP_ADD_MEMBERSHIP ?
                                AO_OPTION_ADD_MCAST : AO_OPTION_DEL_MCAST,
                            OptionValue,
                            OptionLength,
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            return NO_ERROR;

        case IP_BLOCK_SOURCE:
        case IP_UNBLOCK_SOURCE:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // Make sure that the option buffer is large enough.
            //

            if ( OptionLength < sizeof(struct ip_mreq_source) ) {
                return WSAEFAULT;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            OptionName == IP_BLOCK_SOURCE ?
                                AO_OPTION_BLOCK_MCAST_SRC :
                                AO_OPTION_UNBLOCK_MCAST_SRC,
                            OptionValue,
                            OptionLength,
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            return NO_ERROR;

        case IP_ADD_SOURCE_MEMBERSHIP:
        case IP_DROP_SOURCE_MEMBERSHIP:

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            //
            // Make sure that the option buffer is large enough.
            //

            if ( OptionLength < sizeof(struct ip_mreq_source) ) {
                return WSAEFAULT;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            OptionName == IP_ADD_SOURCE_MEMBERSHIP ?
                                AO_OPTION_ADD_MCAST_SRC :
                                AO_OPTION_DEL_MCAST_SRC,
                            OptionValue,
                            OptionLength,
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }

            } else {
                return WSAEINVAL;
            }

            return NO_ERROR;

        case IP_HDRINCL:
            // User hdr include option
            //
            //

            if ( OptionLength != 4) {
                return WSAEINVAL;
            }

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_IP_HDRINCL,
                            &optionValue,
                            OptionLength,
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->HdrIncludeSet = TRUE;
            context->HdrInclude = optionValue;

            return NO_ERROR;

        case IP_PKTINFO:

            //
            // This option is only valid for datagram sockets.
            //

            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }


            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_IP_PKTINFO,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->IpPktInfo = optionValue ? TRUE : FALSE;

            return NO_ERROR;

        case IP_RECEIVE_BROADCAST:

            //
            // This option is only valid for datagram sockets.
            //

            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                return WSAENOPROTOOPT;
            }

            if ( OptionLength != sizeof(uint)) {
                return WSAEINVAL;
            }

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_BROADCAST,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            context->ReceiveBroadcast = optionValue ? TRUE : FALSE;

            return NO_ERROR;

        default:
            //
            // No match, fall through.
            //
            break;
        }

        if ( OptionName == IP_OPTIONS ) {


            //
            // Setting IP options.
            //
            if (OptionLength < 0 || OptionLength > MAX_OPT_SIZE ||
                ( OptionValue == NULL) ) {
                return WSAEINVAL;
            }

            //
            // Try to set these options. If the TDI address object handle
            // is NULL, then the socket is not yet bound.  In this case we'll
            // just remember options and actually set them in WSHNotify()
            // after a bind has completed on the socket.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_IPOPTIONS,
                            OptionValue,
                            OptionLength,
                            TRUE
                            );

                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // They were successfully set. Copy them.
            //

            RtlMoveMemory(context->IpOptions, OptionValue, OptionLength);
            context->IpOptionsLength = (UCHAR)OptionLength;

            return NO_ERROR;
        }

        if ( OptionName == IP_DONTFRAGMENT ) {

            //
            // Attempt to turn on or off the DF bit in the IP header.
            //
            if ( !context->IpDontFragment && optionValue != 0 ) {

                optionValue = TRUE;

                //
                // DF is currently off and the application wants to
                // turn it on.  If the TDI address object handle is NULL,
                // then the socket is not yet bound.  In this case we'll
                // just remember that the header inclusion option was set and
                // actually turn it on in WSHNotify() after a bind
                // has completed on the socket.
                //

                if ( TdiAddressObjectHandle != NULL ) {
                    error = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CO_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_IP_DONTFRAGMENT,
                                &optionValue,
                                sizeof(optionValue),
                                TRUE
                                );
                    if ( error != NO_ERROR ) {
                        return error;
                    }
                }

                //
                // Remember that header inclusion is enabled for this socket.
                //

                context->IpDontFragment = TRUE;

            } else if ( context->IpDontFragment && optionValue == 0 ) {

                //
                // The DF flag is currently set and the application wants
                // to turn it off.  If the TDI address object is NULL,
                // the socket is not yet bound.  In this case we'll just
                // remember that the flag is turned off.
                //

                if ( TdiAddressObjectHandle != NULL ) {
                    error = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CO_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_IP_DONTFRAGMENT,
                                &optionValue,
                                sizeof(optionValue),
                                TRUE
                                );
                    if ( error != NO_ERROR ) {
                        return error;
                    }
                }

                //
                // Remember that DF flag is not set for this socket.
                //

                context->IpDontFragment = FALSE;
            }

            return NO_ERROR;
        }

        //
        // We don't support this option.
        //
        return WSAENOPROTOOPT;
    }

    //
    // Handle socket-level options.
    //

    switch ( OptionName ) {

    case SO_KEEPALIVE:

        //
        // Atempt to turn on or off keepalive sending, as necessary.
        //

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        if ( !context->KeepAlive && optionValue != 0 ) {

            optionValue = TRUE;

            //
            // Keepalives are currently off and the application wants to
            // turn them on.  If the TDI connection object handle is
            // NULL, then the socket is not yet connected.  In this case
            // we'll just remember that the keepalive option was set and
            // actually turn them on in WSHNotify() after a connect()
            // has completed on the socket.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_KEEPALIVE,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that keepalives are enabled for this socket.
            //

            context->KeepAlive = TRUE;

        } else if ( context->KeepAlive && optionValue == 0 ) {

            //
            // Keepalives are currently enabled and the application
            // wants to turn them off.  If the TDI connection object is
            // NULL, the socket is not yet connected.  In this case
            // we'll just remember that keepalives are disabled.
            //

            if ( TdiConnectionObjectHandle != NULL ) {
                error = SetTdiInformation(
                            TdiConnectionObjectHandle,
                            CO_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_CONNECTION,
                            TCP_SOCKET_KEEPALIVE,
                            &optionValue,
                            sizeof(optionValue),
                            TRUE
                            );
                if ( error != NO_ERROR ) {
                    return error;
                }
            }

            //
            // Remember that keepalives are disabled for this socket.
            //

            context->KeepAlive = FALSE;
        }

        break;

    case SO_DONTROUTE:

        //
        // We don't really support SO_DONTROUTE.  Just remember that the
        // option was set or unset.
        //

        if ( optionValue != 0 ) {
            context->DontRoute = TRUE;
        } else if ( optionValue == 0 ) {
            context->DontRoute = FALSE;
        }

        break;

    case SO_RCVBUF:

        //
        // If the receive buffer size is being changed, tell TCP about
        // it.  Do nothing if this is a datagram.
        //

        if ( context->ReceiveBufferSize == optionValue ||
                 IS_DGRAM_SOCK(context->SocketType)
           ) {
            break;
        }

        if ( TdiConnectionObjectHandle != NULL ) {
            error = SetTdiInformation(
                        TdiConnectionObjectHandle,
                        CO_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_CONNECTION,
                        TCP_SOCKET_WINDOW,
                        &optionValue,
                        sizeof(optionValue),
                        TRUE
                        );
            if ( error != NO_ERROR ) {
                return error;
            }
        } else if ( TdiAddressObjectHandle != NULL ) {
            error = SetTdiInformation(
                        TdiAddressObjectHandle,
                        CO_TL_ENTITY,
                        INFO_CLASS_PROTOCOL,
                        INFO_TYPE_ADDRESS_OBJECT,
                        AO_OPTION_WINDOW,
                        &optionValue,
                        sizeof(optionValue),
                        TRUE
                        );
            if ( error != NO_ERROR ) {
                return error;
            }
        }

        context->ReceiveBufferSize = optionValue;

        break;

    default:

        return WSAENOPROTOOPT;
    }

    return NO_ERROR;

} // WSHSetSocketInformation


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Enumerates the protocols supported by this helper.

Arguments:

    lpiProtocols - Pointer to a NULL-terminated array of protocol
        identifiers. Only protocols specified in this array will
        be returned by this function. If this pointer is NULL,
        all protocols are returned.

    lpTransportKeyName -

    lpProtocolBuffer - Pointer to a buffer to fill with PROTOCOL_INFO
        structures.

    lpdwBufferLength - Pointer to a variable that, on input, contains
        the size of lpProtocolBuffer. On output, this value will be
        updated with the size of the data actually written to the buffer.

Return Value:

    INT - The number of protocols returned if successful, -1 if not.

--*/

{
    DWORD bytesRequired;
    PPROTOCOL_INFO tcpProtocolInfo;
    PPROTOCOL_INFO udpProtocolInfo;
    BOOL useTcp = FALSE;
    BOOL useUdp = FALSE;
    DWORD i;

    lpTransportKeyName;         // Avoid compiler warnings.

    //
    // Make sure that the caller cares about TCP and/or UDP.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {

        for ( i = 0; lpiProtocols[i] != 0; i++ ) {
            if ( lpiProtocols[i] == IPPROTO_TCP ) {
                useTcp = TRUE;
            }
            if ( lpiProtocols[i] == IPPROTO_UDP ) {
                useUdp = TRUE;
            }
        }

    } else {

        useTcp = TRUE;
        useUdp = TRUE;
    }

    if ( !useTcp && !useUdp ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (DWORD)((sizeof(PROTOCOL_INFO) * 2) +
                        ( (wcslen( TCP_NAME ) + 1) * sizeof(WCHAR)) +
                        ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR)));

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in TCP info, if requested.
    //

    if ( useTcp ) {

        tcpProtocolInfo = lpProtocolBuffer;

        tcpProtocolInfo->dwServiceFlags = XP_GUARANTEED_DELIVERY |
                                              XP_GUARANTEED_ORDER |
                                              XP_GRACEFUL_CLOSE |
                                              XP_EXPEDITED_DATA |
                                              XP_FRAGMENTATION;
        tcpProtocolInfo->iAddressFamily = AF_INET;
        tcpProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_IN);
        tcpProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_IN);
        tcpProtocolInfo->iSocketType = SOCK_STREAM;
        tcpProtocolInfo->iProtocol = IPPROTO_TCP;
        tcpProtocolInfo->dwMessageSize = 0;
        tcpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( TCP_NAME ) + 1) * sizeof(WCHAR) ) );
        wcscpy( tcpProtocolInfo->lpProtocol, TCP_NAME );

        udpProtocolInfo = tcpProtocolInfo + 1;
        udpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)tcpProtocolInfo->lpProtocol -
                ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR) ) );

    } else {

        udpProtocolInfo = lpProtocolBuffer;
        udpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( UDP_NAME ) + 1) * sizeof(WCHAR) ) );
    }

    //
    // Fill in UDP info, if requested.
    //

    if ( useUdp ) {

        udpProtocolInfo->dwServiceFlags = XP_CONNECTIONLESS |
                                              XP_MESSAGE_ORIENTED |
                                              XP_SUPPORTS_BROADCAST |
                                              XP_SUPPORTS_MULTICAST |
                                              XP_FRAGMENTATION;
        udpProtocolInfo->iAddressFamily = AF_INET;
        udpProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_IN);
        udpProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_IN);
        udpProtocolInfo->iSocketType = SOCK_DGRAM;
        udpProtocolInfo->iProtocol = IPPROTO_UDP;
        udpProtocolInfo->dwMessageSize = UDP_MESSAGE_SIZE;
        wcscpy( udpProtocolInfo->lpProtocol, UDP_NAME );
    }

    *lpdwBufferLength = bytesRequired;

    return (useTcp && useUdp) ? 2 : 1;
  
} // WSHEnumProtocols



BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    )

/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/

{
    ULONG i;

    //
    // Walk through the list searching for an exact match.
    //

    for ( i = 0; i < ListLength; i++ ) {

        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //

        if ( AddressFamily == List[i].AddressFamily &&
             SocketType == List[i].SocketType &&
             ( (Protocol == List[i].Protocol) || (SocketType == SOCK_RAW) )
           ) {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;

} // IsTripleInList


INT
GetTdiInformation (
    IN HANDLE TdiConnectionObjectHandle,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG InValueLength,
    IN ULONG OutValueLength
    )
{
    NTSTATUS status;
    TCP_REQUEST_QUERY_INFORMATION_EX tcpRequest;
    IO_STATUS_BLOCK ioStatusBlock;

    ASSERT(InValueLength <= CONTEXT_SIZE);

    //
    // Initialize the TDI information buffers.
    //

    RtlZeroMemory( &tcpRequest, sizeof(tcpRequest) );
    tcpRequest.ID.toi_entity.tei_entity = Entity;
    tcpRequest.ID.toi_entity.tei_instance = TL_INSTANCE;
    tcpRequest.ID.toi_class = Class;
    tcpRequest.ID.toi_type = Type;
    tcpRequest.ID.toi_id = Id;
    RtlCopyMemory(tcpRequest.Context, Value, InValueLength);

    //
    // Make the actual TDI action call.  The Streams TDI mapper will
    // translate this into a TPI option management request for us and
    // give it to TCP/IP.
    //

    status = NtDeviceIoControlFile(
                 TdiConnectionObjectHandle,
                 NULL,
                 NULL, // ApcRoutine
                 NULL, // ApcContext
                 &ioStatusBlock,
                 IOCTL_TCP_QUERY_INFORMATION_EX,
                 &tcpRequest,
                 sizeof(tcpRequest),
                 Value,
                 OutValueLength
                 );

    if (NT_SUCCESS (status)) {
        return NO_ERROR;
    } else {
        return NtStatusToSocketError (status);
    }
}


INT
SetTdiInformation (
    IN HANDLE TdiConnectionObjectHandle,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN BOOLEAN WaitForCompletion
    )

/*++

Routine Description:

    Performs a TDI action to the TCP/IP driver.  A TDI action translates
    into a streams T_OPTMGMT_REQ.

Arguments:

    TdiConnectionObjectHandle - a TDI connection object on which to perform
        the TDI action.

    Entity - value to put in the tei_entity field of the TDIObjectID
        structure.

    Class - value to put in the toi_class field of the TDIObjectID
        structure.

    Type - value to put in the toi_type field of the TDIObjectID
        structure.

    Id - value to put in the toi_id field of the TDIObjectID structure.

    Value - a pointer to a buffer to set as the information.

    ValueLength - the length of the buffer.

    WaitForCompletion - TRUE if we should wait for the TDI action to
        complete, FALSE if we're at APC level and cannot do a wait.

Return Value:

    INT - NO_ERROR, or a Windows Sockets error code.

--*/

{
    NTSTATUS status;
    PTCP_REQUEST_SET_INFORMATION_EX setInfoEx;
    PIO_STATUS_BLOCK ioStatusBlock;
    PVOID completionApc;
    PVOID apcContext;
    CHAR  localBuffer[sizeof (IO_STATUS_BLOCK) +
                        sizeof (TCP_REQUEST_SET_INFORMATION_EX) +
                        32];


    if (WaitForCompletion || ValueLength>32) {


        //
        // Allocate space to hold the TDI set information buffers and the IO
        // status block.  These cannot be stack variables in case we must
        // return before the operation is complete.
        //

        ioStatusBlock = RtlAllocateHeap(
                            RtlProcessHeap( ),
                            0,
                            sizeof(*ioStatusBlock) + sizeof(*setInfoEx) +
                                ValueLength
                            );
        if ( ioStatusBlock == NULL ) {
            return WSAENOBUFS;
        }

    }
    else {
        ioStatusBlock = (PIO_STATUS_BLOCK)&localBuffer;
    }

    //
    // Initialize the TDI information buffers.
    //

    setInfoEx = (PTCP_REQUEST_SET_INFORMATION_EX)(ioStatusBlock + 1);
    setInfoEx->ID.toi_entity.tei_entity = Entity;
    setInfoEx->ID.toi_entity.tei_instance = TL_INSTANCE;
    setInfoEx->ID.toi_class = Class;
    setInfoEx->ID.toi_type = Type;
    setInfoEx->ID.toi_id = Id;

    RtlCopyMemory( setInfoEx->Buffer, Value, ValueLength );
    setInfoEx->BufferSize = ValueLength;

    //
    // If we need to wait for completion of the operation, create an
    // event to wait on.  If we can't wait for completion because we
    // are being called at APC level, we'll use an APC routine to
    // free the heap we allocated above.
    //

    if ( WaitForCompletion ) {

        completionApc = NULL;
        apcContext = NULL;

    } else {

        completionApc = CompleteTdiActionApc;
        apcContext = ioStatusBlock;
    }

    //
    // Make the actual TDI action call.  The Streams TDI mapper will
    // translate this into a TPI option management request for us and
    // give it to TCP/IP.
    //

    ioStatusBlock->Status = STATUS_PENDING;

    status = NtDeviceIoControlFile(
                 TdiConnectionObjectHandle,
                 NULL,
                 completionApc,
                 apcContext,
                 ioStatusBlock,
                 IOCTL_TCP_WSH_SET_INFORMATION_EX,
                 setInfoEx,
                 sizeof(*setInfoEx) + ValueLength,
                 NULL,
                 0
                 );

    //
    // If the call pended and we were supposed to wait for completion,
    // then wait.
    //

    if ( status == STATUS_PENDING && WaitForCompletion ) {
#if DBG
        INT count=0;
#endif


        while (ioStatusBlock->Status==STATUS_PENDING) {
            LARGE_INTEGER   timeout;
            //
            // Wait one millisecond
            //
            timeout.QuadPart = -1i64*1000i64*10i64;
            NtDelayExecution (FALSE, &timeout);
#if DBG
            if (count++>10*1000) {
                DbgPrint ("WSHTCPIP: Waiting for TCP/IP IOCTL completion for more than 10 seconds!!!!\n");
                DbgBreakPoint ();
            }
#endif
        }
        status = ioStatusBlock->Status;
    }


    if ( (ioStatusBlock != (PIO_STATUS_BLOCK)&localBuffer) &&
            (WaitForCompletion || !NT_SUCCESS(status)) ){
        RtlFreeHeap( RtlProcessHeap( ), 0, ioStatusBlock );
    }

    if (NT_SUCCESS (status)) {
        return NO_ERROR;
    }
    else {
        return NtStatusToSocketError (status);
    }

} // SetTdiInformation


VOID
CompleteTdiActionApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock
    )
{
    //
    // Just free the heap we allocated to hold the IO status block and
    // the TDI action buffer.  There is nothing we can do if the call
    // failed.
    //

    RtlFreeHeap( RtlProcessHeap( ), 0, ApcContext );

} // CompleteTdiActionApc


INT
WINAPI
WSHJoinLeaf (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN PVOID LeafHelperDllSocketContext,
    IN SOCKET LeafSocketHandle,
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    IN LPWSABUF CallerData,
    IN LPWSABUF CalleeData,
    IN LPQOS SocketQOS,
    IN LPQOS GroupQOS,
    IN DWORD Flags
    )

/*++

Routine Description:

    Performs the protocol-dependent portion of creating a multicast
    socket.

Arguments:

    The following four parameters correspond to the socket passed into
    the WSAJoinLeaf() API:

    HelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    SocketHandle - The handle of the socket used to establish the
        multicast "session".

    TdiAddressObjectHandle - The TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - The TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    The next two parameters correspond to the newly created socket that
    identifies the multicast "session":

    LeafHelperDllSocketContext - The context pointer returned from
        WSHOpenSocket().

    LeafSocketHandle - The handle of the socket that identifies the
        multicast "session".

    Sockaddr - The name of the peer to which the socket is to be joined.

    SockaddrLength - The length of Sockaddr.

    CallerData - Pointer to user data to be transferred to the peer
        during multipoint session establishment.

    CalleeData - Pointer to user data to be transferred back from
        the peer during multipoint session establishment.

    SocketQOS - Pointer to the flowspecs for SocketHandle, one in each
        direction.

    GroupQOS - Pointer to the flowspecs for the socket group, if any.

    Flags - Flags to indicate if the socket is acting as sender,
        receiver, or both.

Return Value:

    INT - 0 if successful, a WinSock error code if not.

--*/

{

    struct ip_mreq req;
    INT err;
    BOOL bSet_IP_MULTICAST_IF = FALSE;
    PWSHTCPIP_SOCKET_CONTEXT context;


    //
    // Note: at this time we only support non-rooted control schemes,
    //       and therefore no leaf socket is created
    //

    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        TdiAddressObjectHandle == NULL ||
        LeafHelperDllSocketContext != NULL ||
        LeafSocketHandle != INVALID_SOCKET ||
        Sockaddr == NULL ||
        SockaddrLength < sizeof(SOCKADDR_IN) ||
        Sockaddr->sa_family != AF_INET ||
        ( CallerData != NULL && CallerData->len > 0 ) ||
        ( CalleeData != NULL && CalleeData->len > 0 ) ||
        SocketQOS != NULL ||
        GroupQOS != NULL ) {

        return WSAEINVAL;

    }

    context = HelperDllSocketContext;

    //
    // The multicast group to join...
    //

    req.imr_multiaddr = ((LPSOCKADDR_IN)Sockaddr)->sin_addr;

    //
    // Now figure out the local interface. Note that the local interface
    // specified in IP_ADD_MEMBERSHIP applies to that on which you wish
    // to receive datagrams, while the local interface specified in
    // IP_MULTICAST_IF applies to that from which to send multicast
    // packets.  If there is >1 local interface then we want to be
    // consistent regarding the send/recv interfaces.
    //

    if (context->MulticastInterface == DEFAULT_MULTICAST_INTERFACE) {

        TDI_REQUEST_QUERY_INFORMATION query;
        char            tdiAddressInfo[FIELD_OFFSET (TDI_ADDRESS_INFO, Address)
                                        + sizeof (TA_IP_ADDRESS)];
        NTSTATUS        status;
        IO_STATUS_BLOCK ioStatusBlock;


        //
        // App hasn't set IP_MULTICAST_IF, so retrieve the bound
        // address and use that for the send & recv interfaces
        //
        //

        RtlZeroMemory (&query, sizeof (query));
        query.QueryType = TDI_QUERY_ADDRESS_INFO;

        status = NtDeviceIoControlFile(
                    TdiAddressObjectHandle,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    IOCTL_TDI_QUERY_INFORMATION,
                    &query,
                    sizeof (query),
                    tdiAddressInfo,
                    sizeof(tdiAddressInfo)
                    );

        if( NT_SUCCESS(status) ) {

            PTA_IP_ADDRESS  pIpAddress =
                (PTA_IP_ADDRESS)(tdiAddressInfo+FIELD_OFFSET (TDI_ADDRESS_INFO, Address));


            req.imr_interface.s_addr = pIpAddress->Address[0].Address[0].in_addr;

            if (req.imr_interface.s_addr != DEFAULT_MULTICAST_INTERFACE) {

                bSet_IP_MULTICAST_IF = TRUE;
                context->MulticastInterface = req.imr_interface.s_addr;
            }

        } else {

            req.imr_interface.s_addr = DEFAULT_MULTICAST_INTERFACE;
        }

    } else {

        req.imr_interface.s_addr = context->MulticastInterface;
    }


    //
    // If the Flags param indicates that caller is a sender only,
    // then there's no point in actually joining the group (anyone
    // can send to a multicast group, but it's only members of the
    // group who recv the packets).  So, just check to see if it
    // is necessary to set the IP_MULTICAST_IF to remain consistent
    // ith the bound address.
    //
    // Otherwise, caller is a receiver (possibly a sender too), so
    // we really do want to join the group.
    //

    if (Flags == JL_SENDER_ONLY) {

        if (bSet_IP_MULTICAST_IF) {

            WSHSetSocketInformation (
                HelperDllSocketContext,
                SocketHandle,
                TdiAddressObjectHandle,
                TdiConnectionObjectHandle,
                IPPROTO_IP,
                IP_MULTICAST_IF,
                (char *) &req.imr_interface.s_addr,
                sizeof (req.imr_interface.s_addr)
                );
        }

        err = NO_ERROR;

    } else {

        err = SetTdiInformation(
                  TdiAddressObjectHandle,
                  CL_TL_ENTITY,
                  INFO_CLASS_PROTOCOL,
                  INFO_TYPE_ADDRESS_OBJECT,
                  AO_OPTION_ADD_MCAST,
                  &req,
                  sizeof(req),
                  TRUE
                  );

        if( err == NO_ERROR ) {

            //
            // Record this fact in the leaf socket so we can drop membership
            // when the leaf socket is closed.
            //

            context->MultipointLeaf = TRUE;
            context->MultipointTarget = req.imr_multiaddr;


            //
            // Stay consistent, i.e. send interface should match recv interface
            //

            if (bSet_IP_MULTICAST_IF && (Flags != JL_RECEIVER_ONLY)) {

                WSHSetSocketInformation (
                    HelperDllSocketContext,
                    SocketHandle,
                    TdiAddressObjectHandle,
                    TdiConnectionObjectHandle,
                    IPPROTO_IP,
                    IP_MULTICAST_IF,
                    (char *) &req.imr_interface.s_addr,
                    sizeof (req.imr_interface.s_addr)
                    );
            }
        }
    }

    return err;

} // WSHJoinLeaf


INT
WINAPI
WSHGetBroadcastSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a broadcast socket address.  A broadcast address
    may be used as a destination for the sendto() API to send a datagram
    to all interested clients.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a broadcast
        address.

    Sockaddr - points to a buffer which will receive the broadcast socket
        address.

    SockaddrLength - receives the length of the broadcast sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{

    LPSOCKADDR_IN addr;

    if( *SockaddrLength < sizeof(SOCKADDR_IN) || (Sockaddr == NULL) ) {

        return WSAEFAULT;

    }

    *SockaddrLength = sizeof(SOCKADDR_IN);

    //
    // Build the broadcast address.
    //

    addr = (LPSOCKADDR_IN)Sockaddr;

    RtlZeroMemory(
        addr,
        sizeof(*addr)
        );

    addr->sin_family = AF_INET;
    ASSERT (htonl(INADDR_BROADCAST)==INADDR_BROADCAST);
    addr->sin_addr.s_addr = INADDR_BROADCAST;

    return NO_ERROR;

} // WSAGetBroadcastSockaddr


INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    )

/*++

Routine Description:

    Retrieves a pointer to the WSAPROTOCOL_INFOW structure(s) describing
    the protocol(s) supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProtocolInfo - Receives a pointer to the WSAPROTOCOL_INFOW array.

    ProtocolInfoEntries - Receives the number of entries in the array.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProtocolInfo == NULL ||
        ProtocolInfoEntries == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"TcpIp" ) == 0 ) {

        *ProtocolInfo = Winsock2Protocols;
        *ProtocolInfoEntries = NUM_WINSOCK2_PROTOCOLS;

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetWSAProtocolInfo


INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    LPSOCKADDR_IN addr;
    INT err = NO_ERROR;
    NTSTATUS Status;

    //
    // Quick sanity checks.
    //

    if( AddressLength < sizeof(SOCKADDR_IN)) {

        return WSAEFAULT;

    }
    __try {
        addr = (LPSOCKADDR_IN)Address;
        if (addr->sin_family != AF_INET) {
            return WSAEFAULT;
        }
     
        //
        // Now calling rtl functions to do the address conversion
        //
        Status = RtlIpv4AddressToStringExW(&addr->sin_addr,
                                           addr->sin_port, 
                                           AddressString, 
                                           AddressStringLength
                                          );
        if (!NT_SUCCESS(Status)) {
            err = WSAEFAULT;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = WSAEFAULT;
    }

    return err;

} // WSHAddressToString


INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    )

/*++

Routine Description:

    Fills in a SOCKADDR structure by parsing a human-readable string.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    AddressFamily - The address family to which the string belongs.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    Address - Receives the SOCKADDR structure.

    AddressLength - On input, contains the length of Address. On output,
        contains the number of bytes actually written to Address.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    LPWSTR terminator;
    ULONG ipAddress;
    USHORT port;
    LPSOCKADDR_IN addr;
    NTSTATUS Status;

    __try {
        if (*AddressLength < sizeof(SOCKADDR_IN) ) {
            *AddressLength = sizeof(SOCKADDR_IN);
            return WSAEFAULT;
        }
        if (AddressFamily != AF_INET) {
            return WSAEINVAL;
        }
        addr = (LPSOCKADDR_IN)Address;
        RtlZeroMemory(addr, sizeof(SOCKADDR_IN));
        //
        // Now calling Rtl routine to do the address conversion
        //
        Status = RtlIpv4StringToAddressExW(AddressString,
                                           FALSE,
                                           &addr->sin_addr, 
                                           &addr->sin_port
                                          );
                                       
        if (!NT_SUCCESS(Status)) {
            return WSAEINVAL;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return WSAEFAULT;
    }
    *AddressLength = sizeof(SOCKADDR_IN);
    addr->sin_family = AF_INET;

    return NO_ERROR;

} // WSHStringToAddress


INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, L"TcpIp" ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &TcpipProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid

INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    )

/*++

Routine Description:

    Performs queries & controls on the socket. This is basically an
    "escape hatch" for IOCTLs not supported by MSAFD.DLL. Any unknown
    IOCTLs are routed to the socket's helper DLL for protocol-specific
    processing.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    IoControlCode - Control code of the operation to perform.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

    OutputBuffer - Address of the output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to the output buffer.

    Overlapped - Pointer to a WSAOVERLAPPED structure for overlapped
        operations.

    CompletionRoutine - Pointer to a completion routine to call when
        the operation is completed.

    NeedsCompletion - WSAIoctl() can be overlapped, with all the gory
        details that involves, such as setting events, queuing completion
        routines, and posting to IO completion ports. Since the majority
        of the IOCTL codes can be completed quickly "in-line", MSAFD.DLL
        can optionally perform the overlapped completion of the operation.

        Setting *NeedsCompletion to TRUE (the default) causes MSAFD.DLL
        to handle all of the IO completion details iff this is an
        overlapped operation on an overlapped socket.

        Setting *NeedsCompletion to FALSE tells MSAFD.DLL to take no
        further action because the helper DLL will perform any necessary
        IO completion.

        Note that if a helper performs its own IO completion, the helper
        is responsible for maintaining the "overlapped" mode of the socket
        at socket creation time and NOT performing overlapped IO completion
        on non-overlapped sockets.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    INT err;
    NTSTATUS status;
    PWSHTCPIP_SOCKET_CONTEXT context;
    
    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        NumberOfBytesReturned == NULL ||
        NeedsCompletion == NULL ) {

        return WSAEINVAL;

    }

    *NeedsCompletion = TRUE;
    context = (PWSHTCPIP_SOCKET_CONTEXT) HelperDllSocketContext;
    
    switch( IoControlCode ) {

    case SIO_MULTIPOINT_LOOPBACK :

        if ( !IS_DGRAM_SOCK(context->SocketType) ) {
            err = WSAENOPROTOOPT;
            break;
        }
        
        err = WSHSetSocketInformation(
                  HelperDllSocketContext,
                  SocketHandle,
                  TdiAddressObjectHandle,
                  TdiConnectionObjectHandle,
                  IPPROTO_IP,
                  IP_MULTICAST_LOOP,
                  (PCHAR)InputBuffer,
                  (INT)InputBufferLength
                  );
        break;

    case SIO_MULTICAST_SCOPE :
        err = WSHSetSocketInformation(
                  HelperDllSocketContext,
                  SocketHandle,
                  TdiAddressObjectHandle,
                  TdiConnectionObjectHandle,
                  IPPROTO_IP,
                  IP_MULTICAST_TTL,
                  (PCHAR)InputBuffer,
                  (INT)InputBufferLength
                  );
        break;

    case SIO_GET_MULTICAST_FILTER :
        if ( OutputBufferLength < IP_MSFILTER_SIZE(0) ||
             (OutputBuffer == NULL) ) {
            err = WSAEFAULT;
            break;
        }

        if ( TdiAddressObjectHandle == NULL ) {
            err = WSAEINVAL;
            break;
        }

        if ( !IS_DGRAM_SOCK(context->SocketType) ) {
            err = WSAENOPROTOOPT;
            break;
        }
        
        err = GetTdiInformation(
                    TdiAddressObjectHandle,
                    CL_TL_ENTITY,
                    INFO_CLASS_PROTOCOL,
                    INFO_TYPE_ADDRESS_OBJECT,
                    AO_OPTION_MCAST_FILTER,
                    OutputBuffer,
                    FIELD_OFFSET(UDPMCastFilter, umf_fmode),
                    OutputBufferLength
                    );
        break;

    case SIO_SET_MULTICAST_FILTER :
        {
            PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;

            //
            // This option is only valid for datagram sockets.
            //
            if ( !IS_DGRAM_SOCK(context->SocketType) ) {
                err = WSAENOPROTOOPT;
                break;
            }

            //
            // Make sure that the option buffer is large enough.
            //

            if ( InputBufferLength < IP_MSFILTER_SIZE(0) ) {
                err = WSAEFAULT;
                break;
            }

            //
            // If we have a TDI address object, set this option to
            // the address object.  If we don't have a TDI address
            // object then we'll have to wait until after the socket
            // is bound.
            //

            if ( TdiAddressObjectHandle != NULL ) {
                err = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_MCAST_FILTER,
                            InputBuffer,
                            InputBufferLength,
                            TRUE
                            );
                if ( err != NO_ERROR ) {
                    break;
                }
            }

            err = NO_ERROR;
            break;
        }

    case SIO_GET_INTERFACE_LIST :
        if ( OutputBuffer == NULL ) {
            err = WSAEFAULT;
            break;
        }
        status = GetTcpipInterfaceList(
                     OutputBuffer,
                     OutputBufferLength,
                     NumberOfBytesReturned
                     );

        if( NT_SUCCESS(status) ) {
            err = NO_ERROR;
        } else {
            err = NtStatusToSocketError (status);
        }
        break;

    case SIO_RCVALL:
      //
      // This option is only valid for raw sockets.
      //

      if (((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->SocketType != SOCK_RAW) {
    return WSAENOPROTOOPT;
      }

      if ( InputBufferLength != sizeof(uint)) {
    return WSAEINVAL;
      }

      if ( TdiAddressObjectHandle != NULL ) {
    err = SetTdiInformation(
        TdiAddressObjectHandle,
        CL_TL_ENTITY,
        INFO_CLASS_PROTOCOL,
        INFO_TYPE_ADDRESS_OBJECT,
        AO_OPTION_RCVALL,
        InputBuffer,
        InputBufferLength,
        TRUE
        );

    if ( err != NO_ERROR ) {
      return err;
    }
      } else {
    return WSAEINVAL;
      }

      return NO_ERROR;

    case SIO_RCVALL_MCAST:
      //
      // This option is only valid for raw sockets.
      //

      if (((PWSHTCPIP_SOCKET_CONTEXT) HelperDllSocketContext)->SocketType != SOCK_RAW) {
    return WSAENOPROTOOPT;
      }

      if ( InputBufferLength != sizeof(uint)) {
    return WSAEINVAL;
      }

      if ( TdiAddressObjectHandle != NULL ) {
    err = SetTdiInformation(
        TdiAddressObjectHandle,
        CL_TL_ENTITY,
        INFO_CLASS_PROTOCOL,
        INFO_TYPE_ADDRESS_OBJECT,
        AO_OPTION_RCVALL_MCAST,
        InputBuffer,
        InputBufferLength,
        TRUE
        );

    if ( err != NO_ERROR ) {
      return err;
    }
      } else {
    return WSAEINVAL;
      }

      return NO_ERROR;

    case SIO_RCVALL_IGMPMCAST:
      //
      // This option is only valid for raw sockets.
      //

      if (((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->SocketType != SOCK_RAW) {
    return WSAENOPROTOOPT;
      }

      if ( InputBufferLength != sizeof(uint)) {
    return WSAEINVAL;
      }

      if ( TdiAddressObjectHandle != NULL ) {
    err = SetTdiInformation(
        TdiAddressObjectHandle,
        CL_TL_ENTITY,
        INFO_CLASS_PROTOCOL,
        INFO_TYPE_ADDRESS_OBJECT,
        AO_OPTION_RCVALL_IGMPMCAST,
        InputBuffer,
        InputBufferLength,
        TRUE
        );

    if ( err != NO_ERROR ) {
      return err;
    }
      } else {
    return WSAEINVAL;
      }

      return NO_ERROR;

    case SIO_ABSORB_RTRALERT:
      //
      // This option is only valid for raw sockets.
      //

      if (((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->SocketType != SOCK_RAW) {
        return WSAENOPROTOOPT;
      }

      if ( InputBufferLength != sizeof(uint)) {
        return WSAEINVAL;
      }

      if ( TdiAddressObjectHandle != NULL ) {
        err = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CL_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_ABSORB_RTRALERT,
                                InputBuffer,
                                InputBufferLength,
                                TRUE
                                );

        if ( err != NO_ERROR ) {
          return err;
        }
      } else {
        return WSAEINVAL;
      }

      return NO_ERROR;

    case SIO_UCAST_IF:
      {
            uint   OptionValue;

            //
            // This option is only valid for raw sockets.
            //

            if (((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->SocketType != SOCK_RAW) {
              return WSAENOPROTOOPT;
            }

            // this option is valid only if hdr include option is set

            if ( !(((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->HdrIncludeSet && ((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->HdrInclude) ) {
                return WSAEINVAL;
            }

            if ( InputBufferLength != sizeof(uint)) {
              return WSAEINVAL;
            }

            if ( TdiAddressObjectHandle != NULL ) {
                err = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_IP_UCASTIF,
                            InputBuffer,
                            InputBufferLength,
                            TRUE
                            );

                if ( err != NO_ERROR ) {
                    return err;
                }
            }

            OptionValue = *((uint UNALIGNED *)InputBuffer);

            ((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->UcastIf = OptionValue ? TRUE : FALSE;

            return NO_ERROR;
      }

    case SIO_LIMIT_BROADCASTS:
      {
            uint   OptionValue;

            //
            // This option is only valid for UDP sockets.
            //

            if ( !IS_DGRAM_SOCK(
                ((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->SocketType
                )) {
                return WSAENOPROTOOPT;
            }


            if ( InputBufferLength != sizeof(uint)) {
                return WSAEINVAL;
            }

            if ( TdiAddressObjectHandle != NULL ) {
                err = SetTdiInformation(
                            TdiAddressObjectHandle,
                            CL_TL_ENTITY,
                            INFO_CLASS_PROTOCOL,
                            INFO_TYPE_ADDRESS_OBJECT,
                            AO_OPTION_LIMIT_BCASTS,
                            InputBuffer,
                            InputBufferLength,
                            TRUE
                            );

                if ( err != NO_ERROR ) {
                    return err;
                }
            }

            OptionValue = *((uint UNALIGNED *)InputBuffer);

            ((PWSHTCPIP_SOCKET_CONTEXT)
                HelperDllSocketContext)->LimitBroadcasts =
                    OptionValue ? TRUE : FALSE;

            return NO_ERROR;
      }

    case SIO_INDEX_BIND:

      //
      // This option is only valid for raw sockets.
      //

      if (((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->SocketType != SOCK_RAW) {
        return WSAENOPROTOOPT;
      }

      if ( TdiAddressObjectHandle != NULL ) {
        err = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CL_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_INDEX_BIND,
                                InputBuffer,
                                InputBufferLength,
                                TRUE
                                );

        if ( err != NO_ERROR ) {
          return err;
        }
      } else {
        return WSAEINVAL;
      }

      return NO_ERROR;

    case SIO_INDEX_MCASTIF:

      //
      // This option is only valid for raw sockets.
      //

      if (((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->SocketType != SOCK_RAW) {
        return WSAENOPROTOOPT;
      }


      if ( TdiAddressObjectHandle != NULL ) {
        err = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CL_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_INDEX_MCASTIF,
                                InputBuffer,
                                InputBufferLength,
                                TRUE
                                );

        if ( err != NO_ERROR ) {
          return err;
        }
      } else {
        return WSAEINVAL;
      }

      return NO_ERROR;

    case SIO_INDEX_ADD_MCAST:

      //
      // This option is only valid for raw sockets.
      //

      if (((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->SocketType != SOCK_RAW) {
        return WSAENOPROTOOPT;
      }


      if ( TdiAddressObjectHandle != NULL ) {
        err = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CL_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_INDEX_ADD_MCAST,
                                InputBuffer,
                                InputBufferLength,
                                TRUE
                                );

        if ( err != NO_ERROR ) {
          return err;
        }
      } else {
        return WSAEINVAL;
      }

      return NO_ERROR;

    case SIO_INDEX_DEL_MCAST:

      //
      // This option is only valid for raw sockets.
      //

      if (((PWSHTCPIP_SOCKET_CONTEXT)HelperDllSocketContext)->SocketType != SOCK_RAW) {
        return WSAENOPROTOOPT;
      }

      if ( TdiAddressObjectHandle != NULL ) {
        err = SetTdiInformation(
                                TdiAddressObjectHandle,
                                CL_TL_ENTITY,
                                INFO_CLASS_PROTOCOL,
                                INFO_TYPE_ADDRESS_OBJECT,
                                AO_OPTION_INDEX_DEL_MCAST,
                                InputBuffer,
                                InputBufferLength,
                                TRUE
                                );

        if ( err != NO_ERROR ) {
          return err;
        }
      } else {
        return WSAEINVAL;
      }

      return NO_ERROR;

    case SIO_KEEPALIVE_VALS:
      {
        struct tcp_keepalive *optionval;
        PWSHTCPIP_SOCKET_CONTEXT context = HelperDllSocketContext;
        //
        // Atempt to turn on or off keepalive sending, as necessary.
        //

        if ( IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        if ( InputBufferLength != sizeof(struct tcp_keepalive) ) {
            return WSAEINVAL;
        }

        optionval = (struct tcp_keepalive *)InputBuffer;

        if (optionval->onoff != 0 ) {

           // Application wants to turn the keepalive on and also give the
           // relevant parameters for it. If the TDI connection object handle is
           // NULL, then the socket is not yet connected.  In this case
           // we'll just remember that the keepalive option was set and
           // actually turn them on in WSHNotify() after a connect()
           // has completed on the socket.
           //

           if ( TdiConnectionObjectHandle != NULL ) {
               err = SetTdiInformation(
                     TdiConnectionObjectHandle,
                     CO_TL_ENTITY,
                     INFO_CLASS_PROTOCOL,
                     INFO_TYPE_CONNECTION,
                     TCP_SOCKET_KEEPALIVE_VALS,
                     optionval,
                     InputBufferLength,
                     TRUE
                     );
                if ( err != NO_ERROR ) {
                     return err;
                }
           }

           //
           // Remember that keepalives are enabled for this socket.
           //

           context->KeepAliveVals.onoff = TRUE;
           context->KeepAliveVals.keepalivetime = optionval->keepalivetime;
           context->KeepAliveVals.keepaliveinterval = optionval->keepaliveinterval;

        } else if ( optionval->onoff == 0 ) {

           //
           // Application wants to turn keepalive off.  If the TDI
           // connection object is NULL, the socket is not yet
           // connected.  In this case we'll just remember that
           // keepalives are disabled.

           if ( TdiConnectionObjectHandle != NULL ) {
               err = SetTdiInformation(
                   TdiConnectionObjectHandle,
                   CO_TL_ENTITY,
                   INFO_CLASS_PROTOCOL,
                   INFO_TYPE_CONNECTION,
                   TCP_SOCKET_KEEPALIVE_VALS,
                   optionval,
                   InputBufferLength,
                   TRUE
                   );

               if ( err != NO_ERROR ) {
                   return err;
               }
           }

           //
           // Remember that keepalives are disabled for this socket.
           //

           context->KeepAliveVals.onoff = FALSE;
        }

           // break;
           return NO_ERROR;
    }

    default :
        err = WSAEINVAL;
        break;
    }

    return err;

}   // WSHIoctl


NTSTATUS
GetTcpipInterfaceList(
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned
    )

/*++

Routine Description:

    This routine queries the INTERFACE_INFO array for all supported
    IP interfaces in the system. This is a helper routine for handling
    the SIO_GET_INTERFACE_LIST IOCTL.

Arguments:

    OutputBuffer - Points to a buffer that will receive the INTERFACE_INFO
        array.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to OutputBuffer.

Return Value:

    NTSTATUS - The completion status.

--*/

{

    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING deviceName;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE deviceHandle;
    TCP_REQUEST_QUERY_INFORMATION_EX tcpRequest;
    TDIObjectID objectId;
    IPSNMPInfo snmpInfo;
    IPInterfaceInfo * interfaceInfo;
    IFEntry * ifentry;
    IPAddrEntry * addressBuffer;
    IPAddrEntry * addressScan;
    TDIEntityID * entityBuffer;
    TDIEntityID * entityScan;
    ULONG i, j;
    ULONG entityCount;
    ULONG entityBufferLength;
    ULONG entityType;
    ULONG addressBufferLength;
    LPINTERFACE_INFO outputInterfaceInfo;
    DWORD outputBytesRemaining;
    LPSOCKADDR_IN sockaddr;
    CHAR fastAddressBuffer[MAX_FAST_ADDRESS_BUFFER];
    CHAR fastEntityBuffer[MAX_FAST_ENTITY_BUFFER];
    CHAR ifentryBuffer[sizeof(IFEntry) + MAX_IFDESCR_LEN];
    CHAR interfaceInfoBuffer[sizeof(IPInterfaceInfo) + MAX_PHYSADDR_SIZE];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    deviceHandle = NULL;
    addressBuffer = NULL;
    entityBuffer = (PVOID)fastEntityBuffer;
    entityBufferLength = sizeof(fastEntityBuffer);
    interfaceInfo = NULL;

    outputInterfaceInfo = OutputBuffer;
    outputBytesRemaining = OutputBufferLength;

    //
    // Open a handle to the TCP/IP device.
    //

    RtlInitUnicodeString(
        &deviceName,
        DD_TCP_DEVICE_NAME
        );

    InitializeObjectAttributes(
        &objectAttributes,
        &deviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtCreateFile(
                 &deviceHandle,
                 SYNCHRONIZE | GENERIC_EXECUTE,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_IF,
                 FILE_SYNCHRONOUS_IO_NONALERT,
                 NULL,
                 0
                 );

    if( !NT_SUCCESS(status) ) {

        goto exit;

    }

    //
    // Get the entities supported by the TCP device.
    //

    RtlZeroMemory(
        &tcpRequest,
        sizeof(tcpRequest)
        );

    tcpRequest.ID.toi_entity.tei_entity = GENERIC_ENTITY;
    tcpRequest.ID.toi_entity.tei_instance = 0;
    tcpRequest.ID.toi_class = INFO_CLASS_GENERIC;
    tcpRequest.ID.toi_type = INFO_TYPE_PROVIDER;
    tcpRequest.ID.toi_id = ENTITY_LIST_ID;

    for( ; ; ) {

        status = NtDeviceIoControlFile(
                     deviceHandle,
                     NULL,                              // Event
                     NULL,                              // ApcRoutine
                     NULL,                              // ApcContext
                     &ioStatusBlock,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     entityBuffer,
                     entityBufferLength
                     );

        if( NT_SUCCESS(status) ) {

            break;

        }

        if( status != STATUS_BUFFER_TOO_SMALL ) {

            goto exit;

        }

        if( entityBuffer != (PVOID)fastEntityBuffer ) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                entityBuffer
                );

        }

        entityBufferLength += sizeof(TDIEntityID);

        entityBuffer = RtlAllocateHeap(
                           RtlProcessHeap(),
                           0,
                           entityBufferLength
                           );

        if( entityBuffer == NULL ) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto exit;

        }

    }

    entityCount = ((ULONG) ioStatusBlock.Information) / sizeof(*entityBuffer);

    //
    // Scan the entities looking for IP.
    //

    for( i = 0, entityScan = entityBuffer ;
         i < entityCount ;
         i++, entityScan++ ) {

        if( entityScan->tei_entity != CL_NL_ENTITY ) {

            continue;

        }

        RtlZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        objectId.toi_entity = *entityScan;
        objectId.toi_class = INFO_CLASS_GENERIC;
        objectId.toi_type = INFO_TYPE_PROVIDER;
        objectId.toi_id = ENTITY_TYPE_ID;

        tcpRequest.ID = objectId;

        status = NtDeviceIoControlFile(
                     deviceHandle,
                     NULL,                              // Event
                     NULL,                              // ApcRoutine
                     NULL,                              // ApcContext
                     &ioStatusBlock,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     &entityType,
                     sizeof(entityType)
                     );

        if( !NT_SUCCESS(status) ) {

            goto exit;

        }

        if( entityType != CL_NL_IP ) {

            continue;

        }

        //
        // OK, we found an IP entity. Now lookup its addresses.
        // Start by querying the number of addresses supported by
        // this interface.
        //

        RtlZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        objectId.toi_class = INFO_CLASS_PROTOCOL;
        objectId.toi_id = IP_MIB_STATS_ID;

        tcpRequest.ID = objectId;

        status = NtDeviceIoControlFile(
                     deviceHandle,
                     NULL,                              // Event
                     NULL,                              // ApcRoutine
                     NULL,                              // ApcContext
                     &ioStatusBlock,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     &snmpInfo,
                     sizeof(snmpInfo)
                     );

        if( !NT_SUCCESS(status) ) {

         goto exit;

        }

        if( snmpInfo.ipsi_numaddr <= 0 ) {

            continue;

        }

        //
        // This interface has addresses. Cool. Allocate a temporary
        // buffer so we can query them.
        //

        addressBufferLength = snmpInfo.ipsi_numaddr * sizeof(*addressBuffer);

        if( addressBufferLength <= sizeof(fastAddressBuffer) ) {

            addressBuffer = (PVOID)fastAddressBuffer;

        } else {

            addressBuffer = RtlAllocateHeap(
                                RtlProcessHeap(),
                                0,
                                addressBufferLength
                                );

            if( addressBuffer == NULL ) {

                status = STATUS_INSUFFICIENT_RESOURCES;
                goto exit;

            }

        }

        RtlZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        objectId.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;

        tcpRequest.ID = objectId;

        status = NtDeviceIoControlFile(
                     deviceHandle,
                     NULL,                              // Event
                     NULL,                              // ApcRoutine
                     NULL,                              // ApcContext
                     &ioStatusBlock,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     addressBuffer,
                     addressBufferLength
                     );

        if( !NT_SUCCESS(status) ) {

            goto exit;

        }

        addressBufferLength = (ULONG)ioStatusBlock.Information;
        snmpInfo.ipsi_numaddr = addressBufferLength /
            sizeof(*addressBuffer);

        //
        // Try to get the IFEntry info so we can tell if the interface
        // is "up".
        //

        ifentry = (PVOID)ifentryBuffer;

        RtlZeroMemory(
            ifentryBuffer,
            sizeof(ifentryBuffer)
            );

        RtlZeroMemory(
            &tcpRequest,
            sizeof(tcpRequest)
            );

        addressScan = (IPAddrEntry *) addressBuffer;

        RtlCopyMemory(
            &tcpRequest.Context,
            &addressScan->iae_addr,
            sizeof(addressScan->iae_addr)
            );

        objectId.toi_id = IF_MIB_STATS_ID;

        tcpRequest.ID = objectId;
        tcpRequest.ID.toi_entity.tei_entity = IF_ENTITY;

        status = NtDeviceIoControlFile(
                     deviceHandle,
                     NULL,                              // Event
                     NULL,                              // ApcRoutine
                     NULL,                              // ApcContext
                     &ioStatusBlock,
                     IOCTL_TCP_QUERY_INFORMATION_EX,
                     &tcpRequest,
                     sizeof(tcpRequest),
                     ifentry,
                     sizeof(ifentryBuffer)
                     );

        if( !NT_SUCCESS(status ) ) {

            ifentry->if_adminstatus = 0;

        }
        
                
        //
        // Now scan the list
        //
        
        for( j = 0, addressScan = addressBuffer ;
             j < snmpInfo.ipsi_numaddr ;
             j++, addressScan++ ) {

            //
            // Skip any entries that don't have IP addresses yet.
            //

            if( addressScan->iae_addr == 0 ) {

                continue;

            }

            //
            // If the output buffer is full, fail the request now.
            //

            if( outputBytesRemaining <= sizeof(*outputInterfaceInfo) ) {

                status = STATUS_BUFFER_TOO_SMALL;
                goto exit;

            }

            //
            // Setup the output structure.
            //

            RtlZeroMemory(
                outputInterfaceInfo,
                sizeof(*outputInterfaceInfo)
                );

            outputInterfaceInfo->iiFlags = IFF_MULTICAST;

            sockaddr = &outputInterfaceInfo->iiAddress.AddressIn;
            sockaddr->sin_family = AF_INET;
            sockaddr->sin_addr.s_addr = addressScan->iae_addr;
            if( sockaddr->sin_addr.s_addr == htonl( INADDR_LOOPBACK ) ) {

                outputInterfaceInfo->iiFlags |= IFF_LOOPBACK;

            }

            sockaddr = &outputInterfaceInfo->iiNetmask.AddressIn;
            sockaddr->sin_family = AF_INET;
            sockaddr->sin_addr.s_addr = addressScan->iae_mask;

            if( addressScan->iae_bcastaddr != 0 ) {

                outputInterfaceInfo->iiFlags |= IFF_BROADCAST;
                sockaddr = &outputInterfaceInfo->iiBroadcastAddress.AddressIn;
                sockaddr->sin_family = AF_INET;
                ASSERT (htonl(INADDR_BROADCAST)==INADDR_BROADCAST);
                sockaddr->sin_addr.s_addr = INADDR_BROADCAST;

            }

            //
            // Grrr...
            //
            // I know how to enumerate the entities supported by the
            // driver (those are stored in entityBuffer).
            //
            // I know how to find the IP entities in that buffer.
            //
            // I know how to enumerate the IP addresses supported
            // by a given IP entity (those are stored in addressBuffer).
            //
            // I also know (but haven't done yet) how to find the IF
            // entities (interfaces; basically NICs) and determine if
            // a given IF is "up" or "down".
            //
            // What I don't know how to do is associate the addresses
            // in addressBuffer with specific IF entities. Without
            // this information, I cannot determine if a given *address*
            // is "up" or "down", so for now I'll just assume they're
            // all "up".
            //

//            if( ifentry->if_adminstatus == IF_STATUS_UP )
            {

                outputInterfaceInfo->iiFlags |= IFF_UP;

            }

            //
            // Get the IP interface info for this interface so we can
            // determine if it's "point-to-point".
            //

            interfaceInfo = (PVOID)interfaceInfoBuffer;

            RtlZeroMemory(
                interfaceInfoBuffer,
                sizeof(interfaceInfoBuffer)
                );

            RtlZeroMemory(
                &tcpRequest,
                sizeof(tcpRequest)
                );

            RtlCopyMemory(
                &tcpRequest.Context,
                &addressScan->iae_addr,
                sizeof(addressScan->iae_addr)
                );

            objectId.toi_id = IP_INTFC_INFO_ID;

            tcpRequest.ID = objectId;

            status = NtDeviceIoControlFile(
                         deviceHandle,
                         NULL,                              // Event
                         NULL,                              // ApcRoutine
                         NULL,                              // ApcContext
                         &ioStatusBlock,
                         IOCTL_TCP_QUERY_INFORMATION_EX,
                         &tcpRequest,
                         sizeof(tcpRequest),
                         interfaceInfo,
                         sizeof(interfaceInfoBuffer)
                         );

            if( NT_SUCCESS(status) ) {

                if( interfaceInfo->iii_flags & IP_INTFC_FLAG_P2P ) {

                    outputInterfaceInfo->iiFlags |= IFF_POINTTOPOINT;

                }

            } else {

                //
                // Print something informative here, then press on.
                //

            }

            //
            // Advance to the next output structure.
            //

            outputInterfaceInfo++;
            outputBytesRemaining -= sizeof(*outputInterfaceInfo);

        }

        //
        // Free the temporary buffer.
        //

        if( addressBuffer != (PVOID)fastAddressBuffer ) {

            RtlFreeHeap(
                RtlProcessHeap(),
                0,
                addressBuffer
                );

        }

        addressBuffer = NULL;

    }

    //
    // Success!
    //

    *NumberOfBytesReturned = OutputBufferLength - outputBytesRemaining;
    status = STATUS_SUCCESS;

exit:

    if( addressBuffer != (PVOID)fastAddressBuffer &&
        addressBuffer != NULL ) {

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            addressBuffer
            );

    }

    if( entityBuffer != (PVOID)fastEntityBuffer &&
        entityBuffer != NULL ) {

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            entityBuffer
            );

    }

    if( deviceHandle != NULL ) {

        NtClose( deviceHandle );

    }

    return status;

}   // GetTcpipInterfaceList


INT
NtStatusToSocketError (
    IN NTSTATUS Status
    )
{

    switch ( Status ) {

    case STATUS_PENDING:
        ASSERT (FALSE);
        return WSASYSCALLFAILURE;

    case STATUS_INVALID_HANDLE:
    case STATUS_OBJECT_TYPE_MISMATCH:
        return WSAENOTSOCK;

    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_PAGEFILE_QUOTA:
    case STATUS_COMMITMENT_LIMIT:
    case STATUS_WORKING_SET_QUOTA:
    case STATUS_NO_MEMORY:
    case STATUS_CONFLICTING_ADDRESSES:
    case STATUS_QUOTA_EXCEEDED:
    case STATUS_TOO_MANY_PAGING_FILES:
    case STATUS_REMOTE_RESOURCES:
    case STATUS_TOO_MANY_ADDRESSES:
        return WSAENOBUFS;

    case STATUS_SHARING_VIOLATION:
    case STATUS_ADDRESS_ALREADY_EXISTS:
        return WSAEADDRINUSE;

    case STATUS_LINK_TIMEOUT:
    case STATUS_IO_TIMEOUT:
    case STATUS_TIMEOUT:
        return WSAETIMEDOUT;

    case STATUS_GRACEFUL_DISCONNECT:
        return WSAEDISCON;

    case STATUS_REMOTE_DISCONNECT:
    case STATUS_CONNECTION_RESET:
    case STATUS_LINK_FAILED:
    case STATUS_CONNECTION_DISCONNECTED:
    case STATUS_PORT_UNREACHABLE:
        return WSAECONNRESET;

    case STATUS_LOCAL_DISCONNECT:
    case STATUS_TRANSACTION_ABORTED:
    case STATUS_CONNECTION_ABORTED:
        return WSAECONNABORTED;

    case STATUS_BAD_NETWORK_PATH:
    case STATUS_NETWORK_UNREACHABLE:
    case STATUS_PROTOCOL_UNREACHABLE:
        return WSAENETUNREACH;

    case STATUS_HOST_UNREACHABLE:
        return WSAEHOSTUNREACH;

    case STATUS_CANCELLED:
    case STATUS_REQUEST_ABORTED:
        return WSAEINTR;

    case STATUS_BUFFER_OVERFLOW:
    case STATUS_INVALID_BUFFER_SIZE:
        return WSAEMSGSIZE;

    case STATUS_BUFFER_TOO_SMALL:
    case STATUS_ACCESS_VIOLATION:
        return WSAEFAULT;

    case STATUS_DEVICE_NOT_READY:
    case STATUS_REQUEST_NOT_ACCEPTED:
        return WSAEWOULDBLOCK;

    case STATUS_INVALID_NETWORK_RESPONSE:
    case STATUS_NETWORK_BUSY:
    case STATUS_NO_SUCH_DEVICE:
    case STATUS_NO_SUCH_FILE:
    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_UNEXPECTED_NETWORK_ERROR:
        return WSAENETDOWN;

    case STATUS_INVALID_CONNECTION:
        return WSAENOTCONN;

    case STATUS_REMOTE_NOT_LISTENING:
    case STATUS_CONNECTION_REFUSED:
        return WSAECONNREFUSED;

    case STATUS_PIPE_DISCONNECTED:
        return WSAESHUTDOWN;

    case STATUS_INVALID_ADDRESS:
    case STATUS_INVALID_ADDRESS_COMPONENT:
        return WSAEADDRNOTAVAIL;

    case STATUS_NOT_SUPPORTED:
    case STATUS_NOT_IMPLEMENTED:
        return WSAEOPNOTSUPP;

    case STATUS_ACCESS_DENIED:
        return WSAEACCES;

    default:

        if ( NT_SUCCESS(Status) ) {

#if DBG
            DbgPrint ("SockNtStatusToSocketError: success status %lx "
                       "not mapped\n", Status );
#endif

            return NO_ERROR;
        }

#if DBG
        DbgPrint ("SockNtStatusToSocketError: unable to map 0x%lX, returning\n", Status );
#endif

        return WSAENOBUFS;

    case STATUS_UNSUCCESSFUL:
    case STATUS_INVALID_PARAMETER:
    case STATUS_ADDRESS_CLOSED:
    case STATUS_CONNECTION_INVALID:
    case STATUS_ADDRESS_ALREADY_ASSOCIATED:
    case STATUS_ADDRESS_NOT_ASSOCIATED:
    case STATUS_CONNECTION_ACTIVE:
    case STATUS_INVALID_DEVICE_STATE:
    case STATUS_INVALID_DEVICE_REQUEST:
        return WSAEINVAL;

    }

} // NtStatusToSocketError
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\inc\glbtypes.h ===
//////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       glbtypes.h
//
//    Abstract:
//       Common type definitions for tdisample.sys and its
//       associated lib.  Also includes inline functions...
//
////////////////////////////////////////////////////////////////////


#ifndef _TDISAMPLE_GLOBAL_TYPES_
#define _TDISAMPLE_GLOBAL_TYPES_

//-----------------------------------------------------------------
// inline functions
//-----------------------------------------------------------------

//
// DeviceIoControl IoControlCode related functions for this device.
//
// Warning:  Remember that the low two bits of the code represent the
//           method, and specify how the input and output buffers are
//           passed to the driver via DeviceIoControl()
//           These constants defined in glbconst.h
//

//
// some things from ntddk.h (final source = sdk\inc\devioctl.h)
//  these are used in inline functions that set up the IOCTL
// command values for DeviceIoControl
//
#ifndef  METHOD_OUT_DIRECT
#define  METHOD_OUT_DIRECT       2
#define  FILE_DEVICE_TRANSPORT   0x00000021
#endif

#define  IOCTL_METHOD            METHOD_OUT_DIRECT
#define  IOCTL_TDI_BASE          FILE_DEVICE_TRANSPORT

//
// function to convert command to iocontrol code for DeviceIoControl
//
inline ULONG ulTdiCommandToIoctl(ULONG cmd)
{
   return ( (IOCTL_TDI_BASE << 16) | (cmd << 2) | IOCTL_METHOD);
}

//
// function to convert iocontrolcode back to command
//
inline ULONG ulTdiIoctlToCommand(ULONG ioctl)
{
   return  ((ioctl >> 2) & ulTDI_COMMAND_MASK);
}


//------------------------------------------------------------------
// types
//------------------------------------------------------------------

//
// force dword alignment..
//
#include <pshpack4.h>

//
// the structures defined below all hold data passed between the dll and the
// driver.  Most are either arguments passed as part of the DeviceIoControl
// inputbuffer or the results which are part of the DeviceIoControl
// outputbuffer
//

//
// varient of UNICODE string that does not have an allocated buffer
// maximumstringlength is 256
//
const ULONG ulMAX_CNTSTRING_LENGTH = 256;

struct   UCNTSTRING
{
   USHORT   usLength;
   WCHAR    wcBuffer[ulMAX_CNTSTRING_LENGTH];
};
typedef UCNTSTRING   *PUCNTSTRING;

//
// varient of the TRANSPORT_ADDRESS structure to hold 1 address
// of the largest variaent size
//
const ULONG ulMAX_TABUFFER_LENGTH = 80;
struct   TRANSADDR
{
   LONG           TAAddressCount;
   TA_ADDRESS     TaAddress;
   UCHAR          ucBuffer[ulMAX_TABUFFER_LENGTH];
};
typedef  TRANSADDR   *PTRANSADDR;


// -------------------------------------------
// structures used for arguments
// -------------------------------------------

//
// arguments for getnumdevices/getdevice/getaddress
//
struct   GETDEV_ARGS
{
   ULONG    ulAddressType;
   ULONG    ulSlotNum;
};
typedef  GETDEV_ARGS *PGETDEV_ARGS;

//
// arguments to open functions
//
struct   OPEN_ARGS
{
   UCNTSTRING  ucsDeviceName;
   TRANSADDR   TransAddr;
};
typedef  OPEN_ARGS   *POPEN_ARGS;


//
// arguments for connect
//
struct CONNECT_ARGS
{
   TRANSADDR      TransAddr;
   ULONG          ulTimeout;
};
typedef CONNECT_ARGS *PCONNECT_ARGS;

//
// arguments for senddatagram
//
struct SEND_ARGS
{
   TRANSADDR      TransAddr;
   ULONG          ulFlags;
   ULONG          ulBufferLength;
   PUCHAR         pucUserModeBuffer;
};
typedef  SEND_ARGS   *PSEND_ARGS;


//
// this structure is used for passing data TO the driver.  It is the
// inputbuffer parameter of DeviceIoControl.  Basically, it's a union
// of the above structures
//

struct SEND_BUFFER
{
   //
   // common to most commands, only arg for close, getevents,
   //
   ULONG       TdiHandle;     // handle for open object

   //
   // here is the union of all the args.  Each command will use
   // only the one specific to it when unpacking the data..
   //
   union    _COMMAND_ARGS
   {
      //
      // arguments for debuglevel
      //
      ULONG          ulDebugLevel;

      //
      // arguments for getnumdevices, getdevice, getaddress
      //
      GETDEV_ARGS    GetDevArgs;

      //
      // argument for disconnect
      //
      ULONG          ulFlags;
      //
      // arguments for opencontrol, openaddress
      //
      OPEN_ARGS      OpenArgs;

      //
      // arguments for tdiquery
      //
      ULONG          ulQueryId;

      //
      // arguments for seteventhandler
      //
      ULONG          ulEventId;

      //
      // arguments for senddatagram
      //
      SEND_ARGS      SendArgs;

      //
      // arguments for receivedatagram
      //
      TRANSADDR      TransAddr;

      //
      // arguments for connect
      //
      CONNECT_ARGS   ConnectArgs;

   }COMMAND_ARGS;

   //
   // these two fields are used only within the driver.  They deal help deal
   // with cancelling a command.  At the bottom because their size differs
   // between 32bit and 64bit
   //
   PVOID       pvLowerIrp;
   PVOID       pvDeviceContext;


};
typedef SEND_BUFFER *PSEND_BUFFER;

//---------------------------------------------
// structures used for return data
//---------------------------------------------

//
// return data from tdiquery
//
struct QUERY_RET
{
   ULONG    ulBufferLength;      // use this if possible
   UCHAR    pucDataBuffer[ulMAX_BUFFER_LENGTH];
};
typedef  QUERY_RET   *PQUERY_RET;

//
// This structure used for returning data FROM driver to the dll.  Basically,
// it is the outputbuffer argument to DeviceIoControl.  It is mostly a union
// of structures defined up above..
//
struct RECEIVE_BUFFER
{
   LONG  lStatus;          // status result of command

   //
   // union of all the result structures
   //
   union    _RESULTS
   {
      //
      // handle return
      //
      ULONG          TdiHandle;

      //
      // simple integer return value (used as appropriate)
      //
      ULONG          ulReturnValue;

      //
      // counted wide string return
      //
      UCNTSTRING     ucsStringReturn;

      //
      // return for tdiquery
      //
      QUERY_RET      QueryRet;

      //
      // transport address return
      //
      TRANSADDR      TransAddr;

      //
      // receivedatagram return
      //
      SEND_ARGS      RecvDgramRet;

   }RESULTS;
};
typedef RECEIVE_BUFFER *PRECEIVE_BUFFER;

#include <poppack.h>

#endif         // _TDISAMPLE_GLOBAL_TYPES_

//////////////////////////////////////////////////////////////////////////
// end of file glbtypes.h
//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\connect.cpp ===
//////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       connect.cpp
//
//    Abstract:
//       This module contains code which implements connection-related
//       commands from the exe
//
//////////////////////////////////////////////////////////

#include "stdafx.h"


// --------------------------------------------------------------------
//
// Function:   DoConnect
//
// Arguments:  ulTdiEndpointHandle -- handle of endpoint
//             pTransportAddress -- address to connect to
//             ulTimeout -- how long to wait for connection
//
// Returns:    Final status of connect
//
// Descript:   This function causes the driver to try and connect to
//             a remote address
//
//---------------------------------------------------------------------


NTSTATUS
DoConnect(ULONG               ulTdiEndpointHandle,
          PTRANSPORT_ADDRESS  pTransportAddress,
          ULONG               ulTimeout)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiEndpointHandle;
   SendBuffer.COMMAND_ARGS.ConnectArgs.ulTimeout = ulTimeout;

   memcpy(&SendBuffer.COMMAND_ARGS.ConnectArgs.TransAddr,
          pTransportAddress,
          (FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
            + FIELD_OFFSET(TA_ADDRESS, Address)
               + pTransportAddress->Address[0].AddressLength));

   //
   // call the driver
   //
   return   TdiLibDeviceIO(ulCONNECT,
                           &SendBuffer,
                           &ReceiveBuffer);
}


// --------------------------------------------------------------------
//
// Function:   DoDisconnect
//
// Arguments:  TdiEndpointHandle -- handle of endpoint object
//             ulFlags -- how to perform disconnect
//
// Returns:    none
//
// Descript:   This function causes the driver to disconnect the local
//             endpoint from its connection with a remote endpoint
//
//---------------------------------------------------------------------


VOID
DoDisconnect(ULONG   ulTdiEndpointHandle,
             ULONG   ulFlags)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiEndpointHandle;
   SendBuffer.COMMAND_ARGS.ulFlags = ulFlags;

   //
   // call the driver
   //
   NTSTATUS lStatus = TdiLibDeviceIO(ulDISCONNECT,
                                     &SendBuffer,
                                     &ReceiveBuffer);
   
   if (lStatus != STATUS_SUCCESS)
   {
      _tprintf(TEXT("DoDisconnect: failure, status = %s\n"), TdiLibStatusMessage(lStatus));
   }
}


// --------------------------------------------------------------------
//
// Function:   DoListen
//
// Arguments:  TdiEndpointHandle -- handle of endpoint object
//
// Returns:    final status of command
//
// Descript:   This function causes the driver to listen for a connection
//             request from a remote endpoint
//
//---------------------------------------------------------------------


NTSTATUS
DoListen(ULONG ulTdiEndpointHandle)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiEndpointHandle;

   //
   // call the driver
   //
   return TdiLibDeviceIO(ulLISTEN,
                         &SendBuffer,
                         &ReceiveBuffer);
}


// --------------------------------------------------------------------
//
// Function:   DoIsConnected
//
// Arguments:  TdiEndpointHandle -- handle of endpoint object
//
// Returns:    TRUE if connected, FALSE if not
//
// Descript:   This function causes the driver to check on the connect
//             status of an endpoint
//
//---------------------------------------------------------------------


BOOLEAN
DoIsConnected(ULONG  ulTdiEndpointHandle)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiEndpointHandle;

   //
   // call the driver
   //
   if (TdiLibDeviceIO(ulISCONNECTED,
                      &SendBuffer,
                      &ReceiveBuffer) == STATUS_SUCCESS)
   {
      return (BOOLEAN)ReceiveBuffer.RESULTS.ulReturnValue;
   }

   return FALSE;
}


////////////////////////////////////////////////////////////////////
// end of file connect.cpp
////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\events.cpp ===
//////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       events.cpp
//
//    Abstract:
//       This module contains code which implements eventhandler
//       commands from the dll
//
//////////////////////////////////////////////////////////

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////
// Public functions
///////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------
//
// Function:   DoEnableEventHandler
//
// Arguments:  TdiHandle -- handle of address object
//             EventId   -- event type number
//
// Returns:    None
//
// Descript:   This function causes the driver to enable the
//             specified event handler
//
//---------------------------------------------------------------------


VOID
DoEnableEventHandler(ULONG ulTdiHandleDriver,
                     ULONG ulEventId)
{
   RECEIVE_BUFFER    ReceiveBuffer;    // return info from command
   SEND_BUFFER       SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiHandleDriver;
   SendBuffer.COMMAND_ARGS.ulEventId = ulEventId;

   //
   // call the driver
   //
   NTSTATUS lStatus = TdiLibDeviceIO(ulSETEVENTHANDLER,
                                     &SendBuffer,
                                     &ReceiveBuffer);

   if (lStatus != STATUS_SUCCESS)
   {
      _tprintf(TEXT("DoEnableEventHandler:  failure, status = %s\n"), TdiLibStatusMessage(lStatus));
   }
}


////////////////////////////////////////////////////////////////////
// end of file events.cpp
////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\inc\glbconst.h ===
//////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       glbconst.h
//
//    Abstract:
//       Common const and defs definitions for tdisample.sys and its
//       associated lib
//
////////////////////////////////////////////////////////////////////


#ifndef _TDISAMPLE_GLOBAL_CONSTS_
#define _TDISAMPLE_GLOBAL_CONSTS_

//
// warning names, used with pragma warning enable/disable
//
#define  NO_RETURN_VALUE         4035
#define  UNREFERENCED_PARAM      4100
#define  CONSTANT_CONDITIONAL    4127
#define  ZERO_SIZED_ARRAY        4200
#define  NAMELESS_STRUCT_UNION   4201
#define  BIT_FIELD_NOT_INT       4214
#define  UNREFERENCED_INLINE     4514
#define  UNREACHABLE_CODE        4702
#define  FUNCTION_NOT_INLINED    4710

//
// disable warnings dealing with inlines
//
#pragma warning(disable: UNREFERENCED_INLINE)
#pragma warning(disable: FUNCTION_NOT_INLINED)


//
// version constants (used in rc file as well as source)
//

#define VER_FILEVERSION          2,05,01,001
#define VER_FILEVERSION_STR      "2.05"

//
// version identifier for current dll/driver
// increment for every change that makes dll/driver incompatible
//
#define TDI_SAMPLE_VERSION_ID    0x20010328

//
// DeviceIoControl timed out
//
#define  TDI_STATUS_TIMEDOUT     0x4001FFFD

// C++ style const definitions
//

#ifndef  ULONG
typedef unsigned long ULONG;
#endif

const ULONG ulMAX_OPEN_NAME_LENGTH     = 128;   // max strlen for adapter
const ULONG ulMAX_BUFFER_LENGTH        = 2048;  // max len of buf for tdiquery

const ULONG ulDebugShowCommand         = 0x01;
const ULONG ulDebugShowHandlers        = 0x02;

/////////////////////////////////////////////////////////////
// TdiSample Command Codes
// NOTE:  ulVERSION_CHECK must NEVER change its value....
/////////////////////////////////////////////////////////////

//
// commands that do not require an object handle
//
const ULONG ulNO_COMMAND         = 0x00000000;     // invalid command
const ULONG ulVERSION_CHECK      = 0x00000001;     // check version of tester
const ULONG ulABORT_COMMAND      = 0x00000002;     // abort previous command
const ULONG ulDEBUGLEVEL         = 0x00000003;     // set debug level
const ULONG ulGETNUMDEVICES      = 0x00000004;     // get #devices in list
const ULONG ulGETDEVICE          = 0x00000005;     // get specific device#
const ULONG ulGETADDRESS         = 0x00000006;     // get specific address
const ULONG ulOPENCONTROL        = 0x00000007;     // open control channel
const ULONG ulOPENADDRESS        = 0x00000008;     // open address object
const ULONG ulOPENENDPOINT       = 0x00000009;     // open an endpoint object

//
// commands that require a control channel object
//
const ULONG ulCLOSECONTROL       = 0x0000000A;     // close a control channel

//
// commands that require an address object
//
const ULONG ulCLOSEADDRESS       = 0x0000000B;     // close address object
const ULONG ulSENDDATAGRAM       = 0x0000000C;     // send a datagram
const ULONG ulRECEIVEDATAGRAM    = 0x0000000D;     // receive a datagram

//
// commands that require a connection endpoint object
//

const ULONG ulCLOSEENDPOINT      = 0x0000000E;     // close an endpoint object
const ULONG ulCONNECT            = 0x0000000F;
const ULONG ulDISCONNECT         = 0x00000010;
const ULONG ulISCONNECTED        = 0x00000011;
const ULONG ulSEND               = 0x00000012;
const ULONG ulRECEIVE            = 0x00000013;
const ULONG ulLISTEN             = 0x00000014;

//
// commands that require an object which could be of more than 1 type
//
const ULONG ulQUERYINFO          = 0x00000015;
const ULONG ulSETEVENTHANDLER    = 0x00000016;     // enable/disable event handler
const ULONG ulPOSTRECEIVEBUFFER  = 0x00000017;
const ULONG ulFETCHRECEIVEBUFFER = 0x00000018;

//
// number of commands defined
//
const ULONG ulNUM_COMMANDS       = 0x00000019;

const ULONG ulTDI_COMMAND_MASK   = 0x0000003F;  // mask for legal commands

#endif         // _TDISAMPLE_GLOBAL_CONSTS_

//////////////////////////////////////////////////////////////////////////
// end of file glbconst.h
//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\inc\libbase.h ===
//////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       libbase.h
//
//    Abstract:
//       Definition that are shared by tdisamp.exe and the library
//
////////////////////////////////////////////////////////////////////


#if !defined(TDILIB_LIBBASE_H_)
#define TDILIB_LIBBASE_H_

//#define UNICODE
//#define _UNICODE

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <stdarg.h>
#include <ntstatus.h>
#define WIN32_NO_STATUS
typedef long NTSTATUS;

#include <windef.h>
#include <winbase.h>

//
// required by tdi.h
//
struct UNICODE_STRING 
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
};

#include <tdi.h>
#include <stdio.h>
#include <tchar.h>

//
// definitions from nb30.h, which part of the sdk but not ddk
//
#define NCBNAMSZ        16    // absolute length of a net name

typedef struct _ADAPTER_STATUS 
{
   UCHAR   adapter_address[6];
   UCHAR   rev_major;
   UCHAR   reserved0;
   UCHAR   adapter_type;
   UCHAR   rev_minor;
   WORD    duration;
   WORD    frmr_recv;
   WORD    frmr_xmit;
   WORD    iframe_recv_err;
   WORD    xmit_aborts;
   DWORD   xmit_success;
   DWORD   recv_success;
   WORD    iframe_xmit_err;
   WORD    recv_buff_unavail;
   WORD    t1_timeouts;
   WORD    ti_timeouts;
   DWORD   reserved1;
   WORD    free_ncbs;
   WORD    max_cfg_ncbs;
   WORD    max_ncbs;
   WORD    xmit_buf_unavail;
   WORD    max_dgram_size;
   WORD    pending_sess;
   WORD    max_cfg_sess;
   WORD    max_sess;
   WORD    max_sess_pkt_size;
   WORD    name_count;
} ADAPTER_STATUS, *PADAPTER_STATUS;

typedef struct _NAME_BUFFER 
{
   UCHAR   name[NCBNAMSZ];
   UCHAR   name_num;
   UCHAR   name_flags;
} NAME_BUFFER, *PNAME_BUFFER;

//  values for name_flags bits.

#define NAME_FLAGS_MASK 0x87

#define GROUP_NAME      0x80
#define UNIQUE_NAME     0x00

#define REGISTERING     0x00
#define REGISTERED      0x04
#define DEREGISTERED    0x05
#define DUPLICATE       0x06
#define DUPLICATE_DEREG 0x07

//
// end of defines stolen from nb30.h
//

#include "libprocs.h"

/////////////////////////////////////////////////////////////////////
// some defines
/////////////////////////////////////////////////////////////////////

inline
PVOID
LocalAllocateMemory(ULONG ulLength)
{
   return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulLength);
}

inline
void
LocalFreeMemory(PVOID pvAddr)
{
   (VOID)HeapFree(GetProcessHeap(), 0, pvAddr);
}

#endif // !defined(TDILIB_LIBBASE_H_)

///////////////////////////////////////////////////////////////////////////////
// end of file libbase.h
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\libvars.h ===
//////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       libvars.h
//
//    Abstract:
//       definitions (types, consts, vars) visible only within library
//       functions.  Also prototypes for functions visible only within
//       the library
//
//////////////////////////////////////////////////////////////////////////


#ifndef _TDILIB_VARS_
#define _TDILIB_VARS_


//
// externs for global variables visible only within library
//
extern   HANDLE            hTdiSampleDriver;    // handle used to call driver
extern   CRITICAL_SECTION  LibCriticalSection;  // serialize DeviceIoControl calls...


//
// functions from utils.cpp
//
LONG
TdiLibDeviceIO(
   ULONG             ulControlCode,
   PSEND_BUFFER      psbInBuffer,
   PRECEIVE_BUFFER   prbOutBuffer
   );


LONG
TdiLibStartDeviceIO(
   ULONG             ulControlCode,
   PSEND_BUFFER      psbInBuffer,
   PRECEIVE_BUFFER   prbOutBuffer,
   OVERLAPPED        *pOverLapped
   );


LONG
TdiLibWaitForDeviceIO(
   OVERLAPPED        *pOverlapped
   );


#endif         // _TDILIB_VARS_

//////////////////////////////////////////////////////////////////////////
//  End of libvars.h
//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\inc\libprocs.h ===
//////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       libprocs.h
//
//    Abstract:
//       prototypes for functions exported from library to dll/exe
//       Also contains prototypes for functions exported from dll/exe to
//       library
//
//////////////////////////////////////////////////////////////////////////

#ifndef _TDILIB_PROCS_
#define _TDILIB_PROCS_


typedef  ULONG TDIHANDLE;

//////////////////////////////////////////////////////////////////////////
// prototypes of lib functions called from dll
//////////////////////////////////////////////////////////////////////////

//
// functions from lib\connect.cpp
//
NTSTATUS
DoConnect(
   TDIHANDLE            TdiHandle,
   PTRANSPORT_ADDRESS   pTransportAddress,
   ULONG                ulTimeout
   );

NTSTATUS
DoListen(
   TDIHANDLE   TdiHandle
   );

VOID
DoDisconnect(
   TDIHANDLE   TdiHandle,
   ULONG       ulFlags
   );


BOOLEAN
DoIsConnected(
   TDIHANDLE   TdiHandle
   );

//
// functions from lib\events.cpp
//
VOID
DoEnableEventHandler(
   TDIHANDLE   TdiHandle,
   ULONG       ulEventId
   );

//
// functions from lib\misc.cpp
//
VOID
DoDebugLevel(
   ULONG       ulDebugLevel
   );


//
// functions from lib\open.cpp
//
ULONG
DoGetNumDevices(
   ULONG       ulAddressType
   );


NTSTATUS
DoGetDeviceName(
   ULONG       ulAddressType,
   ULONG       ulSlotNum,
   TCHAR       *strName
   );

NTSTATUS
DoGetAddress(
   ULONG                ulAddressType,
   ULONG                ulSlotNum,
   PTRANSPORT_ADDRESS   pTransAddr
   );


TDIHANDLE
DoOpenControl(
   TCHAR    *strDeviceName
   );


VOID
DoCloseControl(
   TDIHANDLE   TdiHandle
   );


TDIHANDLE
DoOpenAddress(
   TCHAR              * strDeviceName,
   PTRANSPORT_ADDRESS   pTransportAddress
   );


VOID
DoCloseAddress(
   TDIHANDLE   TdiHandle
   );


TDIHANDLE
DoOpenEndpoint(
   TCHAR                *strDeviceName,
   PTRANSPORT_ADDRESS   pTransportAddress
   );

VOID
DoCloseEndpoint(
   TDIHANDLE   TdiHandle
   );

//
// functions from lib\receive.cpp
//

ULONG
DoReceiveDatagram(
   TDIHANDLE            TdiHandle,
   PTRANSPORT_ADDRESS   pInTransportAddress,
   PTRANSPORT_ADDRESS   pOutTransportAddress,
   PUCHAR               *ppucBuffer
   );

ULONG
DoReceive(
   TDIHANDLE   TdiHandle,
   PUCHAR     *ppucBuffer
   );


VOID
DoPostReceiveBuffer(
   TDIHANDLE   TdiHandle,
   ULONG       ulBufferLength
   );

ULONG
DoFetchReceiveBuffer(
   TDIHANDLE   TdiHandle,
   PUCHAR    * ppDataBuffer
   );

//
// functions from lib\send.cpp
//
VOID
DoSendDatagram(
   TDIHANDLE            TdiHandle,
   PTRANSPORT_ADDRESS   pTransportAddress,
   PUCHAR               pucBuffer,
   ULONG                ulBufferLength
   );

VOID
DoSend(
   TDIHANDLE   TdiHandle,
   PUCHAR      pucBuffer,
   ULONG       ulBufferLength,
   ULONG       ulFlags
   );


//
// functions from lib\tdilib.cpp
//
BOOLEAN
TdiLibInit(VOID);

VOID
TdiLibClose(VOID);

//
// functions from lib\tdiquery.cpp
//


PVOID
DoTdiQuery(
   TDIHANDLE   Tdihandle,
   ULONG       QueryId
   );

VOID
DoPrintProviderInfo(
   PTDI_PROVIDER_INFO pInfo
   );


VOID
DoPrintProviderStats(
   PTDI_PROVIDER_STATISTICS pStats
   );

VOID
DoPrintAdapterStatus(
   PADAPTER_STATUS   pStatus
   );


//
// functions from lib\utils.cpp
//
TCHAR *
TdiLibStatusMessage(
   LONG        lGeneralStatus
   );

VOID
DoPrintAddress(
   PTRANSPORT_ADDRESS   pTransportAddress
   );


#endif         // _TDILIB_PROCS_

//////////////////////////////////////////////////////////////////////
//  End of libprocs.h
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(TDILIB_STDAFX_H_)
#define TDILIB_STDAFX_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include "libbase.h"

#include "glbconst.h"
#include "glbtypes.h"
#include "libvars.h"

#endif // !defined(TDILIB_STDAFX_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\open.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       open.cpp
//
//    Abstract:
//       This module contains functions associated with enumerating,
//       opening, and closing the tdi device objects
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////////
// private prototype
//////////////////////////////////////////////////////////////////////////


VOID
StringToUcntString(
   PUCNTSTRING pusDestination,
   TCHAR       *sSource
   );


//////////////////////////////////////////////////////////////////////////
// Public functions
//////////////////////////////////////////////////////////////////////////


// --------------------------------------------------------------------
//
// Function:   DoGetNumDevices
//
// Arguments:  ulAddressType -- address type to scan list for
//
// Returns:    number of devices found
//
// Descript:   This function gets the number of openable devices
//             of this address type registered with tdisample.sys
//
//---------------------------------------------------------------------


ULONG
DoGetNumDevices(ULONG   ulAddressType)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.COMMAND_ARGS.GetDevArgs.ulAddressType = ulAddressType;

   //
   // call driver to execute command, and deal with results
   //
   if (TdiLibDeviceIO(ulGETNUMDEVICES,
                      &SendBuffer,
                      &ReceiveBuffer) == STATUS_SUCCESS)
   {
      return ReceiveBuffer.RESULTS.ulReturnValue;
   }
   else
   {
      return 0;
   }
}


// --------------------------------------------------------------------
//
// Function:   DoGetDeviceName
//
// Arguments:  addresstype  -- address type to get
//             slotnum      -- which device to get of that type
//             pName        -- buffer large enough to hold name
//                             (supplied by caller)
//
// Returns:    status of command
//
// Descript:   This function gets the n'th device from the list of devices
//             of this address type registered with tdisample.sys
//
//---------------------------------------------------------------------


NTSTATUS
DoGetDeviceName(ULONG   ulAddressType,
                ULONG   ulSlotNum,
                TCHAR   *pName)     // buffer from caller!!
{
   NTSTATUS       lStatus;          // status of command
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.COMMAND_ARGS.GetDevArgs.ulAddressType  = ulAddressType;
   SendBuffer.COMMAND_ARGS.GetDevArgs.ulSlotNum      = ulSlotNum;

   //
   // call the driver
   //
   lStatus = TdiLibDeviceIO(ulGETDEVICE,
                            &SendBuffer,
                            &ReceiveBuffer);

   //
   // deal with results
   //
   if (lStatus == STATUS_SUCCESS)
   {
      WCHAR *pSourceTemp = ReceiveBuffer.RESULTS.ucsStringReturn.wcBuffer;
      for(;;)
      {
         *pName = (TCHAR)*pSourceTemp++;
         if (*pName == 0)
         {
            break;
         }
         pName++;
      }
   }
   return lStatus;
}


// --------------------------------------------------------------------
//
// Function:   DoGetAddress
//
// Arguments:  addresstype  -- address type to get
//             slotnum      -- which device to get
//             pTransAddr   -- transport address (allocated by calleer,
//                             filled by this function)
//
// Returns:    status of command
//             if successful, pTransAddr is filled
//
// Descript:   This function gets the address of the n'th device from the
//             list of devices registered with tdisample.sys
//
//---------------------------------------------------------------------


NTSTATUS
DoGetAddress(ULONG               ulAddressType,
             ULONG               ulSlotNum,
             PTRANSPORT_ADDRESS  pTransAddr)
{
   NTSTATUS       lStatus;          // status of command
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.COMMAND_ARGS.GetDevArgs.ulAddressType  = ulAddressType;
   SendBuffer.COMMAND_ARGS.GetDevArgs.ulSlotNum      = ulSlotNum;

   //
   // call the driver
   //
   lStatus = TdiLibDeviceIO(ulGETADDRESS,
                            &SendBuffer,
                            &ReceiveBuffer);

   //
   // deal with the results
   //
   if (lStatus == STATUS_SUCCESS)
   {
      PTRANSPORT_ADDRESS   pTransportAddress
                           = (PTRANSPORT_ADDRESS)&ReceiveBuffer.RESULTS.TransAddr;
      ULONG    ulLength
               = FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
               + FIELD_OFFSET(TA_ADDRESS, Address)
               + pTransportAddress->Address[0].AddressLength;


      memcpy(pTransAddr,
             pTransportAddress,
             ulLength);
   }

   return lStatus;

}


// ------------------------------------------
//
// Function:   DoOpenControl
//
// Arguments:  strDeviceName  -- device name to open 
//
// Returns:    TdiHandle (ULONG) if successful; 0 if failure
//
// Descript:   calls the driver to open control channel
//
// ------------------------------------------

TDIHANDLE
DoOpenControl(TCHAR  *strDeviceName)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up the arguments
   //
   StringToUcntString(&SendBuffer.COMMAND_ARGS.OpenArgs.ucsDeviceName,
                      strDeviceName);

   //
   // call the driver
   //
   if (TdiLibDeviceIO(ulOPENCONTROL,
                      &SendBuffer,
                      &ReceiveBuffer) == STATUS_SUCCESS)
   {
      return ReceiveBuffer.RESULTS.TdiHandle;
   }
   else
   {
      return NULL;
   }
}


//-------------------------------------------------------------
//
//    Function:   DoCloseControl
//
//    Argument:   ulTdiHandle -- handle for control channel
//
//    Returns:    none
//
//    Descript:   This function closes the indicated control channel
//
//-------------------------------------------------------------

VOID
DoCloseControl(ULONG ulTdiHandle)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command
   
   //
   // set up the arguments
   //
   SendBuffer.TdiHandle = ulTdiHandle;

   //
   // call the driver
   //
   NTSTATUS lStatus =  TdiLibDeviceIO(ulCLOSECONTROL,
                                      &SendBuffer,
                                      &ReceiveBuffer);

   if (lStatus != STATUS_SUCCESS)
   {
      _tprintf(TEXT("DoCloseControl: failure, status = %s\n"), TdiLibStatusMessage(lStatus));
   }
}




// ------------------------------------------
//
// Function:   DoOpenAddress
//
// Arguments:  strDeviceName  -- device name to open 
//             pTransportAddress -- address to open
//             pulTdiHandle   -- returned handle if successful
//
// Returns:    status of command
//
// Descript:   calls the driver to open address object
//
// ------------------------------------------

TDIHANDLE
DoOpenAddress(TCHAR              *strDeviceName,
              PTRANSPORT_ADDRESS pTransportAddress)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   StringToUcntString(&SendBuffer.COMMAND_ARGS.OpenArgs.ucsDeviceName,
                      strDeviceName);

   memcpy(&SendBuffer.COMMAND_ARGS.OpenArgs.TransAddr,
          pTransportAddress,
          (FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
            + FIELD_OFFSET(TA_ADDRESS, Address)
               + pTransportAddress->Address[0].AddressLength));

   //
   // call the driver
   //
   if (TdiLibDeviceIO(ulOPENADDRESS,
                      &SendBuffer,
                      &ReceiveBuffer) == STATUS_SUCCESS)
   {
      return ReceiveBuffer.RESULTS.TdiHandle;
   }
   else
   {
      return NULL;
   }
}


//-------------------------------------------------------------
//
//    Function:   DoCloseAddress
//
//    Argument:   ulTdiHandle -- handle for address object
//
//    Returns:    None
//
//    Descript:   This function closes the indicated address object
//
//-------------------------------------------------------------

VOID
DoCloseAddress(ULONG ulTdiHandle)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command
   
   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiHandle;

   //
   // call the driver
   //
   NTSTATUS lStatus = TdiLibDeviceIO(ulCLOSEADDRESS,
                                     &SendBuffer,
                                     &ReceiveBuffer);

   if (lStatus != STATUS_SUCCESS)
   {
      _tprintf(TEXT("DoCloseAddress: failure, status = %s\n"), TdiLibStatusMessage(lStatus));
   }
}




// ------------------------------------------
//
// Function:   DoOpenEndpoint
//
// Arguments:  strDeviceName  -- device name to open 
//             pTransportAddress -- address to open
//             pulTdiHandle -- returned handled (if successful)
//
// Returns:    status of command
//
// Descript:   calls the driver to open endpoint object
//
// ------------------------------------------

TDIHANDLE
DoOpenEndpoint(TCHAR                *strDeviceName,
               PTRANSPORT_ADDRESS   pTransportAddress)

{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up the arguments
   //
   StringToUcntString(&SendBuffer.COMMAND_ARGS.OpenArgs.ucsDeviceName,
                      strDeviceName);

   memcpy(&SendBuffer.COMMAND_ARGS.OpenArgs.TransAddr,
          pTransportAddress,
          (FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
            + FIELD_OFFSET(TA_ADDRESS, Address)
               + pTransportAddress->Address[0].AddressLength));

   //
   // call the driver
   //
   if (TdiLibDeviceIO(ulOPENENDPOINT,
                      &SendBuffer,
                      &ReceiveBuffer) == STATUS_SUCCESS)
   {
      return ReceiveBuffer.RESULTS.TdiHandle;
   }
   else
   {
      return NULL;
   }
}

//-------------------------------------------------------------
//
//    Function:   DoCloseEndpoint
//
//    Argument:   pTdiHandle  -- handle for endpoint object
//
//    Returns:    none
//
//    Descript:   This function closes the indicated endpoint object
//
//-------------------------------------------------------------

VOID
DoCloseEndpoint(ULONG   ulTdiHandle)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiHandle;

   //
   // call the driver
   //
   NTSTATUS lStatus = TdiLibDeviceIO(ulCLOSEENDPOINT,
                                     &SendBuffer,
                                     &ReceiveBuffer);

   if (lStatus != STATUS_SUCCESS)
   {
      _tprintf(TEXT("DoCloseEndpoint: failure, status = %s\n"), TdiLibStatusMessage(lStatus));
   }
}

///////////////////////////////////////////
// private functions
///////////////////////////////////////////


// -------------------------------
//
// Function:   StringToUcntString
//
// Arguments:  pusDestination -- counted wide string
//             pcSource       -- asci string
//
// Returns:    none
//
// Descript:   copies ansi (ascii) string to counted wide string
//
// -------------------------------

VOID
StringToUcntString(PUCNTSTRING   pusDestination,
                   TCHAR         *Source)
{
   PWCHAR   pwcString                     // ptr to data of wide string
            = pusDestination->wcBuffer;
   ULONG    ulLength = _tcslen(Source);
   
   for(ULONG ulCount = 0; ulCount < ulLength; ulCount++)
   {
      *pwcString++ = Source[ulCount];
   }
   *pwcString = 0;
   pusDestination->usLength = (USHORT)(ulLength * 2);
}

////////////////////////////////////////////////////////////////////
// end of file open.cpp
////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	lib.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\send.cpp ===
//////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       send.cpp
//
//    Abstract:
//       This module contains code which implements send
//       commands from the dll
//
//////////////////////////////////////////////////////////

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////
// Public functions
///////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------
//
// Function:   DoSendDatagram
//
// Arguments:  TdiHandle -- handle of address object
//             pTransportAddress -- TA to send data to
//             pucBuffer   -- data buffer to send
//             ulBufferLength -- length of data buffer
//
// Returns:    none
//
// Descript:   This function causes the driver to send a datagram
//
//---------------------------------------------------------------------


VOID
DoSendDatagram(ULONG                ulTdiHandle,
               PTRANSPORT_ADDRESS   pTransportAddress,
               PUCHAR               pucBuffer,
               ULONG                ulBufferLength)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiHandle;

   memcpy(&SendBuffer.COMMAND_ARGS.SendArgs.TransAddr,
          pTransportAddress,
          (FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
            + FIELD_OFFSET(TA_ADDRESS, Address)
               + pTransportAddress->Address[0].AddressLength));

   SendBuffer.COMMAND_ARGS.SendArgs.ulBufferLength = ulBufferLength;
   SendBuffer.COMMAND_ARGS.SendArgs.pucUserModeBuffer = pucBuffer;

   //
   // call the driver
   //
   NTSTATUS lStatus = TdiLibDeviceIO(ulSENDDATAGRAM,
                                     &SendBuffer,
                                     &ReceiveBuffer);
   
   if (lStatus != STATUS_SUCCESS)
   {
      _tprintf(TEXT("DoSendDatagram: failure, status = %s\n"), TdiLibStatusMessage(lStatus));
   }
}


// --------------------------------------------------------------------
//
// Function:   DoSend
//
// Arguments:  TdiHandle -- handle of endpoint
//             pucBuffer   -- data buffer to send
//             ulBufferLength -- length of data buffer
//             ulSendFlags    -- send options
//
// Returns:    none
//
// Descript:   This function causes the driver to send data over
//             a connection
//
//---------------------------------------------------------------------


VOID
DoSend(ULONG   ulTdiHandle,
       PUCHAR  pucBuffer,
       ULONG   ulBufferLength,
       ULONG   ulSendFlags)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiHandle;

   SendBuffer.COMMAND_ARGS.SendArgs.ulFlags = ulSendFlags;
   SendBuffer.COMMAND_ARGS.SendArgs.ulBufferLength = ulBufferLength;
   SendBuffer.COMMAND_ARGS.SendArgs.pucUserModeBuffer = pucBuffer;

   //
   // call the driver
   //
   NTSTATUS lStatus = TdiLibDeviceIO(ulSEND,
                                     &SendBuffer,
                                     &ReceiveBuffer);

   if (lStatus != STATUS_SUCCESS)
   {
      _tprintf(TEXT("DoSend: failure, status = %s\n"), TdiLibStatusMessage(lStatus));
   }
}

////////////////////////////////////////////////////////////////////
// end of file send.cpp
////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\receive.cpp ===
//////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       receive.cpp
//
//    Abstract:
//       This module contains code which implements receive
//       commands from the dll
//
//////////////////////////////////////////////////////////

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////
// Public functions
///////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------
//
// Function:   DoReceiveDatagram
//
// Arguments:  TdiHandle -- handle of address object
//             pInTransportAddress -- TA for receiving on
//             pOutTransportAddress -- full TA data was received on
//             ppucBuffer   -- buffer to stuff with received data
//
// Returns:    length of data in buffer (0 if none or error)
//
// Descript:   This function causes the driver to receive a datagram
//
//---------------------------------------------------------------------


ULONG
DoReceiveDatagram(ULONG                ulTdiHandle,
                  PTRANSPORT_ADDRESS   pInTransportAddress,
                  PTRANSPORT_ADDRESS   pOutTransportAddress,
                  PUCHAR               *ppucBuffer)
{
   PUCHAR   pucBuffer = (PUCHAR)LocalAllocateMemory(ulMAX_BUFFER_LENGTH);

   if (!pucBuffer)
   {
      return 0;
   }

   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiHandle;
   SendBuffer.COMMAND_ARGS.SendArgs.ulBufferLength = ulMAX_BUFFER_LENGTH;
   SendBuffer.COMMAND_ARGS.SendArgs.pucUserModeBuffer = pucBuffer;
   
   //
   // if passed in a transport address to receive on
   //
   if (pInTransportAddress)
   {
      memcpy(&SendBuffer.COMMAND_ARGS.SendArgs.TransAddr,
             pInTransportAddress,
             (FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
               + FIELD_OFFSET(TA_ADDRESS, Address)
                  + pInTransportAddress->Address[0].AddressLength));

   }
   //
   // else, set the number of addresses field to 0
   //
   else
   {
      SendBuffer.COMMAND_ARGS.SendArgs.TransAddr.TAAddressCount = 0;
   }

   //
   // call the driver
   //
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   NTSTATUS       lStatus = TdiLibDeviceIO(ulRECEIVEDATAGRAM,
                                           &SendBuffer,
                                           &ReceiveBuffer);

   //
   // deal with results -- assume no packet received or error occurred
   //
   ULONG    ulBufferLength = 0;
   *ppucBuffer = NULL;

      
   //
   // will return with success but ulBufferLength = 0 if there is no
   // packet available 
   //
   if (lStatus == STATUS_SUCCESS)
   {
      ulBufferLength = ReceiveBuffer.RESULTS.RecvDgramRet.ulBufferLength;
   }
   
   if (ulBufferLength)
   {
      if (pOutTransportAddress)
      {
         memcpy(pOutTransportAddress,
                &ReceiveBuffer.RESULTS.RecvDgramRet.TransAddr,
                (FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
                  + FIELD_OFFSET(TA_ADDRESS, Address)
                     + ReceiveBuffer.RESULTS.RecvDgramRet.TransAddr.TaAddress.AddressLength));
      }
      *ppucBuffer = pucBuffer;   
   }
   else
   {
      LocalFreeMemory(pucBuffer);
   }
   return ulBufferLength;
}


// --------------------------------------------------------------------
//
// Function:   DoReceive
//
// Arguments:  TdiHandle -- handle of endpoint object
//             ppucBuffer   -- buffer to stuff with received data
//
// Returns:    length of data in buffer (0 if error)
//
// Descript:   This function causes the driver to receive data sent
//             over a connection
//
//---------------------------------------------------------------------


ULONG
DoReceive(ULONG   ulTdiHandle,
          PUCHAR  *ppucBuffer)
{
   PUCHAR   pucBuffer = (PUCHAR)LocalAllocateMemory(ulMAX_BUFFER_LENGTH);

   if (!pucBuffer)
   {
      return 0;
   }

   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiHandle;
   SendBuffer.COMMAND_ARGS.SendArgs.ulBufferLength = ulMAX_BUFFER_LENGTH;
   SendBuffer.COMMAND_ARGS.SendArgs.pucUserModeBuffer = pucBuffer;

   //
   // call the driver
   //
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   NTSTATUS       lStatus = TdiLibDeviceIO(ulRECEIVE,
                                           &SendBuffer,
                                           &ReceiveBuffer);

   //
   // deal with results -- assume no data or error
   //
   *ppucBuffer = NULL;
   ULONG ulBufferLength = 0;   // data length to return
   
   //
   // will return success with 0 bufferlength if no packet available
   //
   if (lStatus == STATUS_SUCCESS)
   {
      ulBufferLength = ReceiveBuffer.RESULTS.RecvDgramRet.ulBufferLength;
   }

   if (ulBufferLength)
   {
      *ppucBuffer = pucBuffer;   
   }
   else
   {
      LocalFreeMemory(pucBuffer);
   }
   return ulBufferLength;
}


// ---------------------------------------
//
// Function:   DoPostReceiveBuffer
//
// Arguments:  TdiHandle -- handle for address object or endpoint
//             ulBufferLength -- length of buffer to post for receive
//
// Returns:    status of command
//
// Descript:   This function allocates a buffer, which it then passed to
//             the driver.  The driver locks the buffer down, and posts it
//             for a receive or receivedatagram.
//
// ----------------------------------------


VOID
DoPostReceiveBuffer(ULONG  ulTdiHandle,
                    ULONG  ulBufferLength)
{
   NTSTATUS       lStatus;          // status of command
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiHandle;
   SendBuffer.COMMAND_ARGS.SendArgs.ulBufferLength = ulBufferLength;

   PUCHAR   pucBuffer = (PUCHAR)LocalAllocateMemory(ulBufferLength);
   if (pucBuffer)
   {
      SendBuffer.COMMAND_ARGS.SendArgs.pucUserModeBuffer = pucBuffer;

      //
      // call the driver
      //
      lStatus = TdiLibDeviceIO(ulPOSTRECEIVEBUFFER,
                               &SendBuffer,
                               &ReceiveBuffer);
   
      if (lStatus != STATUS_SUCCESS)
      {
         _tprintf(TEXT("DoPostReceiveBuffer: failure, status = %s\n"), TdiLibStatusMessage(lStatus));
         LocalFreeMemory(pucBuffer);
      }
   }
   else
   {
      _putts(TEXT("DoPostReceiveBuffer:  failed to allocate buffer\n"));
   }
}


// ------------------------------------------
//
// Function:   DoFetchReceiveBuffer
//
// Arguments:  TdiHandle -- handle of address object or endpoint
//             pulBufferLength -- length of data returned
//             ppDataBuffer -- allocated buffer with data
//
// Returns:    status of operation
//
// Descript:   This function retrieves the oldest posted buffer.  If no
//             data is available, it will cancel the appropriate irp
//             It then returns the data to the caller as appropriate
//
// -------------------------------------------

ULONG
DoFetchReceiveBuffer(ULONG    ulTdiHandle,
                     PUCHAR   *ppDataBuffer)
{
   NTSTATUS       lStatus;          // status of command
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command
   ULONG          ulBufferLength = 0;   
   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiHandle;
   *ppDataBuffer        = NULL;

   //
   // call the driver
   //
   lStatus = TdiLibDeviceIO(ulFETCHRECEIVEBUFFER,
                            &SendBuffer,
                            &ReceiveBuffer);
      
   if (lStatus == STATUS_SUCCESS)
   {
      PUCHAR   pucTempBuffer  = ReceiveBuffer.RESULTS.RecvDgramRet.pucUserModeBuffer;
                  
      ulBufferLength = ReceiveBuffer.RESULTS.RecvDgramRet.ulBufferLength;
      if (ulBufferLength)
      {
         *ppDataBuffer = pucTempBuffer;
      }
      else if (pucTempBuffer)
      {
         LocalFreeMemory(pucTempBuffer);
      }
   }

   return ulBufferLength;
}

////////////////////////////////////////////////////////////////////
// end of file receive.cpp
////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\tdilib.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       tdilib.cpp
//
//    Abstract:
//       tdilib initialization and shutdown functions
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "winsvc.h"

//
// library global variables are defined here
//
HANDLE            hTdiSampleDriver;      // handle used to call driver
CRITICAL_SECTION  LibCriticalSection;  // serialize DeviceIoControl calls...


// ----------------------------------------------
//
//    Function:   TdiLibInit
//
//    Arguments:  none
//
//    Returns:    TRUE  -- everything initialized ok
//                FALSE -- initialization error (usually, unable to attach driver)
//
//    Descript:   This function is called by the by the exe to
//                initialize communication with the driver.  It loads the
//                driver, and establishes communication with it
//
// ----------------------------------------------

BOOLEAN
TdiLibInit(VOID)
{
   //
   // the handle to tdisample.sys should always be null on entry
   // Complain loadly if it is not.
   //
   if (hTdiSampleDriver != NULL)
   {
      OutputDebugString(TEXT("hTdiSampleDriver non-null on entry!\n"));
      return FALSE;
   }

   //
   // find out what operating system we are using.  
   //
   OSVERSIONINFO  OsVersionInfo;

   OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   if (GetVersionEx(&OsVersionInfo))
   {
      if (OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
      {
         if (OsVersionInfo.dwMajorVersion < 5)
         {
            OutputDebugString(TEXT("Not supported for versions prior to Windows 2000\n"));
            return FALSE;
         }
      }
      else
      {
         OutputDebugString(TEXT("Unrecognized OS version\n"));
         return FALSE;
      }
   }
   else
   {
      OutputDebugString(TEXT("Cannot get OS version -- aborting\n"));
      return FALSE;
   }

   //
   // assume tdisample.sys driver is loaded -- try to attach it
   // normally driver will be loaded
   //
   hTdiSampleDriver = CreateFile(TEXT("\\\\.\\TDISAMPLE"),
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,              // lpSecurityAttirbutes
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                 NULL);             // lpTemplateFile
   //
   // If the driver is not loaded, then we have to try and load it...
   //
   if (hTdiSampleDriver == INVALID_HANDLE_VALUE)
   {
      OutputDebugString(TEXT("Tdisample.sys not loaded.  Attempting to load\n"));

      SC_HANDLE      hSCMan = NULL;
      SC_HANDLE      hDriver = NULL;

      if ((hSCMan = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)) == NULL)
      {
         OutputDebugString(TEXT("Failed to Open ServiceManager\n"));
         return FALSE;
      }

      //
      // open service
      //
      if((hDriver = OpenService(hSCMan, TEXT("tdisample"), SERVICE_ALL_ACCESS)) == NULL)
      {
         //
         // service doesn't exist -- try to create it
         //
         OutputDebugString(TEXT("Service does not exist -- try to create it"));
         hDriver = CreateService(hSCMan,
                                 TEXT("tdisample"),
                                 TEXT("tdisample"),
                                 SERVICE_ALL_ACCESS,
                                 SERVICE_KERNEL_DRIVER,
                                 SERVICE_DEMAND_START,
                                 SERVICE_ERROR_NORMAL,
                                 TEXT("\\SystemRoot\\system32\\drivers\\tdisample.sys"),
                                 NULL, NULL, NULL, NULL, NULL);
      }

      if (hDriver != NULL)
      {
         SERVICE_STATUS ServiceStatus;

         if(QueryServiceStatus(hDriver, &ServiceStatus))
         {
            if(ServiceStatus.dwServiceType != SERVICE_KERNEL_DRIVER)
            {
               CloseServiceHandle(hDriver);
               CloseServiceHandle(hSCMan);
               return FALSE;
            }

            switch(ServiceStatus.dwCurrentState)
            {
               //
               // this is the one we expect!  try and start it
               //
               case SERVICE_STOPPED:
               {
                  int i;

                  if(!StartService(hDriver, 0, NULL))
                  {
                     CloseServiceHandle(hDriver);
                     CloseServiceHandle(hSCMan);
                     return FALSE;
                  }     

                  //
                  // we need to make sure tdisample.sys is actually running
                  //
                  for(i=0; i < 30; i++)
                  {
                     Sleep(500);
                     if(QueryServiceStatus(hDriver, &ServiceStatus))
                     {  
                        if(ServiceStatus.dwCurrentState == SERVICE_RUNNING)
                        {
                           break;
                        }
                     }
                  }
                  if (ServiceStatus.dwCurrentState != SERVICE_RUNNING)
                  {
                     OutputDebugString(TEXT("Failed to start tdisample service\n"));
                     CloseServiceHandle(hDriver);
                     CloseServiceHandle(hSCMan);
                     return FALSE;
                  }
                  break;
               }

               //
               // we don't expect this, but (technically) it is not an error
               // If it happens, just assume that the load succeeded
               //
               case SERVICE_RUNNING:
                  OutputDebugString(TEXT("ServiceStatus thinks driver is running\n"));
                  break;

               //
               // anything else is an error
               //
               default:
                  OutputDebugString(TEXT("ServiceStatusError\n"));
                  CloseServiceHandle(hDriver);
                  CloseServiceHandle(hSCMan);
                  return FALSE;
            }
         }
         else
         {
            OutputDebugString(TEXT("QueryServiceStatus failed\n"));
            CloseServiceHandle(hDriver);
            CloseServiceHandle(hSCMan);
            return FALSE;
         }
      }
      else
      {
         OutputDebugString(TEXT("Tdisample service does not exist!\n"));
         CloseServiceHandle(hSCMan);
         return FALSE;
      }

      //
      // if get to here, system thinks it is loaded.  So try again
      //
      hTdiSampleDriver = CreateFile(TEXT("\\\\.\\TDISAMPLE"),
                                    GENERIC_READ | GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,              // lpSecurityAttirbutes
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                    NULL);             // lpTemplateFile

      //
      // if fails again, give up
      //
      if (hTdiSampleDriver == INVALID_HANDLE_VALUE)
      {
         OutputDebugString(TEXT("Unable to load Tdisample.sys\n"));
         hTdiSampleDriver = NULL;
         return FALSE;
      }
   }

   //
   // if get to here, tdisample.sys is loaded, and hTdiSampleDriver is valid
   //
   try
   {
      InitializeCriticalSection(&LibCriticalSection);
   }
   catch(...)
   {
      CloseHandle(hTdiSampleDriver);
      hTdiSampleDriver = NULL;
      return FALSE;
   }
   
   //
   // make sure the dll and driver are the same version (ie, are compatible)
   //
   {
      NTSTATUS          lStatus;          // status of command
      ULONG             ulVersion = 0;    // default value (error)
      RECEIVE_BUFFER    ReceiveBuffer;    // return info from command
      SEND_BUFFER       SendBuffer;       // arguments for command

      //
      // call driver to execute command
      //
      lStatus = TdiLibDeviceIO(ulVERSION_CHECK,
                               &SendBuffer,
                               &ReceiveBuffer);

      if (lStatus == STATUS_SUCCESS)
      {
         ulVersion = ReceiveBuffer.RESULTS.ulReturnValue;
      }

      //
      // check results..
      //
      if (ulVersion == TDI_SAMPLE_VERSION_ID)
      {
         return TRUE;         // only successful completion!!!
      }
      else
      {
         OutputDebugString(TEXT("Incompatible driver version.\n"));
      }

      //
      // if get to here, had an error and need to clean up
      //
      DeleteCriticalSection(&LibCriticalSection);
      CloseHandle(hTdiSampleDriver);
      hTdiSampleDriver = NULL;
   }

   return FALSE;
}

// ----------------------------------------------
//
//    Function:   TdiLibClose
//
//    Arguments:  none
//
//    Returns:    none
//
//    Descript:   This function is called by the by the dll or exe to
//                shut down communication with the driver.  
//
// ----------------------------------------------

VOID
TdiLibClose(VOID)
{
   //
   // need to check for NULL since function will be called
   // if the open above failed..
   //
   if (hTdiSampleDriver != NULL)
   {
      DeleteCriticalSection(&LibCriticalSection);

      //
      // close the connection to tdisample.sys
      //
      if (!CloseHandle(hTdiSampleDriver))
      {
         OutputDebugString(TEXT("\n TdiLibClose:  closehandle failed\n"));
      }
      hTdiSampleDriver = NULL;
   }
}

//////////////////////////////////////////////////////////////////////////
// end of file tdilib.cpp
//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\misc.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       misc.cpp
//
//    Abstract:
//       This module contains code which implements various misc
//       commands from the dll
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"


// --------------------------------------------------------------------
//
// Function:   DoDebugLevel
//
// Arguments:  ulLevel -- debug level to set driver to
//
// Returns:    none
//
// Descript:   This function sets the amount of debug output generated by
//             the driver (tdisample.sys)
//
//---------------------------------------------------------------------


VOID
DoDebugLevel(ULONG   ulLevel)
{
   RECEIVE_BUFFER    ReceiveBuffer;    // return info from command
   SEND_BUFFER       SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.COMMAND_ARGS.ulDebugLevel = ulLevel & 0x0000FFFF;

   //
   // call the driver
   //
   NTSTATUS lStatus = TdiLibDeviceIO(ulDEBUGLEVEL,
                                     &SendBuffer,
                                     &ReceiveBuffer);
   
   if (lStatus != STATUS_SUCCESS)
   {
      _tprintf(TEXT("DoDebugLevel: failure, status = %s\n"), TdiLibStatusMessage(lStatus));
   }
}

//////////////////////////////////////////////////////////////////////////
// end of misc.cpp
//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\tdiquery.cpp ===
//////////////////////////////////////////////////////////
//
//    Copyright (c) 2001 Microsoft Corporation
//
//    Module Name:
//       tdiquery.cpp
//
//    Abstract:
//       This module contains functions associated with querying
//       the tdi device objects
//
//////////////////////////////////////////////////////////

#include "stdafx.h"

// -------------------------------
//
// Function:   DoTdiQuery
//
// Arguments:  TdiHandle -- handle to use for query
//             QueryId   -- which query to do
//             ppvData   -- allocated block containing results
//
// Returns:    none
//
// Descript:   Handles all tdi query commands
//
// -------------------------------

PVOID
DoTdiQuery(ULONG  ulTdiHandle,
           ULONG  ulQueryId)
{
   RECEIVE_BUFFER ReceiveBuffer;    // return info from command
   SEND_BUFFER    SendBuffer;       // arguments for command

   //
   // set up arguments
   //
   SendBuffer.TdiHandle = ulTdiHandle;
   SendBuffer.COMMAND_ARGS.ulQueryId = ulQueryId;

   //
   // call the driver
   //
   NTSTATUS lStatus = TdiLibDeviceIO(ulQUERYINFO,
                                     &SendBuffer,
                                     &ReceiveBuffer);

   //
   // deal with results
   //
   PVOID pvBuffer = NULL;  // buffer to return to caller
   if (lStatus == STATUS_SUCCESS)
   {
      ULONG ulCopyLength = ReceiveBuffer.RESULTS.QueryRet.ulBufferLength;
      if (ulCopyLength)
      {
         pvBuffer = LocalAllocateMemory(ulCopyLength);
         if (pvBuffer)
         {
             memcpy(pvBuffer,
                    ReceiveBuffer.RESULTS.QueryRet.pucDataBuffer,
                    ulCopyLength);
         }
         else
         {
            _putts(TEXT("DoTdiQuery:  allocation failure\n"));
         }
      }
      else
      {
         _putts(TEXT("DoTdiQuery: length = 0\n"));
      }
   }
   else
   {
      _tprintf(TEXT("DoTdiQuery: failure, status = %s\n"), TdiLibStatusMessage(lStatus));
   }
   return pvBuffer;
}


// -------------------------------
//
// Function:   DoPrintProviderInfo
//
// Arguments:  pInfo -- ProviderInfo to print
//
// Returns:    none
//
// Descript:   Prints provider info to console
//
// -------------------------------

VOID
DoPrintProviderInfo(PTDI_PROVIDER_INFO pInfo)
{
   _tprintf(TEXT("\nTDI_PROVIDER_INFO\n")
            TEXT("--Version:           0x%08x\n")
            TEXT("--MaxSendSize:       %u\n")
            TEXT("--MaxConnUserData:   %u\n")
            TEXT("--MaxDatagramSize:   %u\n")
            TEXT("--MinLookaheadData:  %u\n")
            TEXT("--MaxLookaheadData:  %u\n")
            TEXT("--NumOfResources:    %u\n")
            TEXT("--StartTime:         %I64u\n")
            TEXT("--ServiceFlags:      0x%08x\n"),
            pInfo->Version,
            pInfo->MaxSendSize,
            pInfo->MaxConnectionUserData,
            pInfo->MaxDatagramSize,
            pInfo->MinimumLookaheadData,
            pInfo->MaximumLookaheadData,
            pInfo->NumberOfResources,
            pInfo->StartTime.QuadPart,
            pInfo->ServiceFlags);

   ULONG ulServiceFlags = pInfo->ServiceFlags;
   if (ulServiceFlags & TDI_SERVICE_CONNECTION_MODE)
   {
      _putts(TEXT("TDI_SERVICE_CONNECTION_MODE\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_ORDERLY_RELEASE)
   {
      _putts(TEXT("TDI_SERVICE_ORDERLY_RELEASE\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_CONNECTIONLESS_MODE)
   {
      _putts(TEXT("TDI_SERVICE_CONNECTIONLESS_MODE\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_ERROR_FREE_DELIVERY)
   {
      _putts(TEXT("TDI_SERVICE_ERROR_FREE_DELIVERY\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_SECURITY_LEVEL)
   {
      _putts(TEXT("TDI_SERVICE_SECURITY_LEVEL\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_BROADCAST_SUPPORTED)
   {
      _putts(TEXT("TDI_SERVICE_BROADCAST_SUPPORTED\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_MULTICAST_SUPPORTED)
   {
      _putts(TEXT("TDI_SERVICE_MULTICAST_SUPPORTED\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_DELAYED_ACCEPTANCE)
   {
      _putts(TEXT("TDI_SERVICE_DELAYED_ACCEPTANCE\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_EXPEDITED_DATA)
   {
      _putts(TEXT("TDI_SERVICE_EXPEDITED_DATA\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_INTERNAL_BUFFERING)
   {
      _putts(TEXT("TDI_SERVICE_INTERNAL_BUFFERING\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_ROUTE_DIRECTED)
   {
      _putts(TEXT("TDI_SERVICE_ROUTE_DIRECTED\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_NO_ZERO_LENGTH)
   {
      _putts(TEXT("TDI_SERVICE_NO_ZERO_LENGTH\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_POINT_TO_POINT)
   {
      _putts(TEXT("TDI_SERVICE_POINT_TO_POINT\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_MESSAGE_MODE)
   {
      _putts(TEXT("TDI_SERVICE_MESSAGE_MODE\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_HALF_DUPLEX)
   {
      _putts(TEXT("TDI_SERVICE_HALF_DUPLEX\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_DGRAM_CONNECTION)
   {
      _putts(TEXT("TDI_SERVICE_DGRAM_CONNECTION\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_FORCE_ACCESS_CHECK)
   {
      _putts(TEXT("TDI_SERVICE_FORCE_ACCESS_CHECK\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_SEND_AND_DISCONNECT)
   {
      _putts(TEXT("TDI_SERVICE_SEND_AND_DISCONNECT\n"));
   }
   if (ulServiceFlags & TDI_SERVICE_DIRECT_ACCEPT)
   {
      _putts(TEXT("TDI_SERVICE_DIRECT_ACCEPT\n"));
   }
   _putts(TEXT("\n"));
}


// -------------------------------
//
// Function:   DoPrintProviderStats
//
// Arguments:  pInfo -- ProviderStats to print
//
// Returns:    none
//
// Descript:   Prints provider stats to console
//
// -------------------------------

VOID
DoPrintProviderStats(PTDI_PROVIDER_STATISTICS pStats)
{
   _tprintf(TEXT("\nTDI_PROVIDER_STATISTICS\n")
            TEXT("--Version:           0x%08x\n")
            TEXT("--OpenConnections:   %u\n")
            TEXT("--ConnectsNoRetry:   %u\n")
            TEXT("--ConnectsWithRetry: %u\n")
            TEXT("--LocalDisconnects:  %u\n")
            TEXT("--RemoteDisconnects: %u\n")
            TEXT("--LinkFailures:      %u\n")
            TEXT("--AdapterFailures:   %u\n")
            TEXT("--SessionTimeouts:   %u\n")
            TEXT("--CancelledConnects: %u\n")
            TEXT("--RemResourceFails:  %u\n")
            TEXT("--LocResourceFails:  %u\n"),
            pStats->Version,
            pStats->OpenConnections,
            pStats->ConnectionsAfterNoRetry,
            pStats->ConnectionsAfterRetry,
            pStats->LocalDisconnects,
            pStats->RemoteDisconnects,
            pStats->LinkFailures,
            pStats->AdapterFailures,
            pStats->SessionTimeouts,
            pStats->CancelledConnections,
            pStats->RemoteResourceFailures,
            pStats->LocalResourceFailures);

   _tprintf(TEXT("--NotFoundFailures:  %u\n")
            TEXT("--NoListenFailures:  %u\n")
            TEXT("--DatagramsSent:     %u\n")
            TEXT("--DatagramBytesSent: %I64u\n")
            TEXT("--DatagramsRecv:     %u\n")
            TEXT("--DatagramBytesRecv: %I64u\n")
            TEXT("--PacketsSent:       %u\n")
            TEXT("--PacketsRecv:       %u\n")
            TEXT("--DataFramesSent:    %u\n")
            TEXT("--DataFrmBytesSent:  %I64u\n")
            TEXT("--DataFramesRecv:    %u\n")
            TEXT("--DataFrmBytesRecv:  %I64u\n"),
            pStats->NotFoundFailures,
            pStats->NoListenFailures,
            pStats->DatagramsSent,
            pStats->DatagramBytesSent.QuadPart,
            pStats->DatagramsReceived,
            pStats->DatagramBytesReceived.QuadPart,
            pStats->PacketsSent,
            pStats->PacketsReceived,
            pStats->DataFramesSent,
            pStats->DataFrameBytesSent.QuadPart,
            pStats->DataFramesReceived,
            pStats->DataFrameBytesReceived.QuadPart);

   _tprintf(TEXT("--DataFramesResent:  %u\n")
            TEXT("--DataFrBytesResent: %I64u\n")
            TEXT("--DataFrmRejected:   %u\n")
            TEXT("--DataFrmBytesRejd:  %I64u\n")
            TEXT("--RespTimerExpires:  %u\n")
            TEXT("--AckTimerExpires:   %u\n")
            TEXT("--MaximumSendWindow: %u\n")
            TEXT("--AverageSendWindow: %u\n")
            TEXT("--PigbackAckQueued:  %u\n")
            TEXT("--PigbackAckTimeout: %u\n")
            TEXT("--WastedPacketSpace: %I64u\n")
            TEXT("--WastedSpacePkts:   %u\n")
            TEXT("--NumberOfResources: %u\n"),
            pStats->DataFramesResent,
            pStats->DataFrameBytesResent.QuadPart,
            pStats->DataFramesRejected,
            pStats->DataFrameBytesRejected.QuadPart,
            pStats->ResponseTimerExpirations,
            pStats->AckTimerExpirations,
            pStats->MaximumSendWindow,
            pStats->AverageSendWindow,
            pStats->PiggybackAckQueued,
            pStats->PiggybackAckTimeouts,
            pStats->WastedPacketSpace.QuadPart,
            pStats->WastedSpacePackets,
            pStats->NumberOfResources);
   
   if (pStats->NumberOfResources)
   {
      PTDI_PROVIDER_RESOURCE_STATS  pResourceStats = pStats->ResourceStats;

      for (ULONG ulCount = 0; ulCount < pStats->NumberOfResources; ulCount++)
      {
         _tprintf(TEXT("--Resource #%u\n")
                  TEXT("----ResourceId       %u\n")
                  TEXT("----MaxResourceUsed: %u\n")
                  TEXT("----AveResourceUsed: %u\n")
                  TEXT("----ResExhausted:    %u\n"),
                  ulCount,
                  pResourceStats->ResourceId,
                  pResourceStats->MaximumResourceUsed,
                  pResourceStats->AverageResourceUsed,
                  pResourceStats->ResourceExhausted);

         pResourceStats++;
      }
   }
   _putts(TEXT("\n"));
}


// -------------------------------
//
// Function:   DoPrintAdapterStatus
//
// Arguments:  pInfo -- AdapterStatus to print
//
// Returns:    none
//
// Descript:   Prints Adapter Status to console
//
// -------------------------------

VOID
DoPrintAdapterStatus(PADAPTER_STATUS   pStatus)
{
   _tprintf(TEXT("\nADAPTER_STATUS\n")
            TEXT("--AdapterAddress: %02x-%02x-%02x-%02x-%02x-%02x\n"),
            pStatus->adapter_address[0],
            pStatus->adapter_address[1],
            pStatus->adapter_address[2],
            pStatus->adapter_address[3],
            pStatus->adapter_address[4],
            pStatus->adapter_address[5]);

   _tprintf(TEXT("--RevMajor:       %u\n")
            TEXT("--RevMinor:       %u\n")
            TEXT("--AdapterType:    %u\n")
            TEXT("--Duration:       %u\n")
            TEXT("--FrmrRecv:       %u\n")
            TEXT("--FrmrXmit:       %u\n")
            TEXT("--FrameRecvErr:   %u\n")
            TEXT("--XmitAbofts:     %u\n")
            TEXT("--XmitSuccess:    %u\n")
            TEXT("--RecvSuccess:    %u\n")
            TEXT("--FrameXmitErr:   %u\n"),
            pStatus->rev_major,
            pStatus->rev_minor,
            pStatus->adapter_type,
            pStatus->duration,
            pStatus->frmr_recv,
            pStatus->frmr_xmit,
            pStatus->iframe_recv_err,
            pStatus->xmit_aborts,
            pStatus->xmit_success,
            pStatus->recv_success,
            pStatus->iframe_xmit_err);

   _tprintf(TEXT("--RecvBufUnavail: %u\n")
            TEXT("--T1 Timeouts:    %u\n")
            TEXT("--TI Timeouts:    %u\n")
            TEXT("--FreeNcbs:       %u\n")
            TEXT("--MaxCfgNcbs:     %u\n")
            TEXT("--MaxNcbs:        %u\n")
            TEXT("--XmitBufUnavail: %u\n")
            TEXT("--MaxDgramSize:   %u\n")
            TEXT("--PendingSess:    %u\n")
            TEXT("--MaxCfgSess:     %u\n")
            TEXT("--MaxSess:        %u\n")
            TEXT("--MaxSessPktSize: %u\n")
            TEXT("--Names:          %u\n"),
            pStatus->recv_buff_unavail,
            pStatus->t1_timeouts,
            pStatus->ti_timeouts,
            pStatus->free_ncbs,
            pStatus->max_cfg_ncbs,
            pStatus->max_ncbs,
            pStatus->xmit_buf_unavail,
            pStatus->max_dgram_size,
            pStatus->pending_sess,
            pStatus->max_cfg_sess,
            pStatus->max_sess,
            pStatus->max_sess_pkt_size,
            pStatus->name_count);

   if (pStatus->name_count)
   {
      PUCHAR         pucTemp     = (PUCHAR)pStatus + sizeof(ADAPTER_STATUS);
      PNAME_BUFFER   pNameBuffer = (PNAME_BUFFER)pucTemp;
      TCHAR          pName[NCBNAMSZ+1];
      UCHAR          ucFlags;

      pName[NCBNAMSZ] = 0;
      _putts(TEXT("NameBuffers\n"));

      for (ULONG ulCount = pStatus->name_count; ulCount != 0; ulCount--)
      {
         //
         // note:  pNameBuffer->name not necessarily 0 terminated
         //
         for(ULONG ulIndex = 0; ulIndex < NCBNAMSZ; ulIndex++)
         {
            pName[ulIndex] = pNameBuffer->name[ulIndex];
         }
         pName[NCBNAMSZ] = 0;

         ucFlags = pNameBuffer->name_flags;

         _tprintf(TEXT("--Name:        %s\n")
                  TEXT("--NameNum:     %u\n")
                  TEXT("--NameFlags:   0x%02x\n")
                  TEXT("               "),
                  pName,
                  pNameBuffer->name_num,
                  ucFlags);

         if (ucFlags & GROUP_NAME)
         {
            _putts(TEXT("GROUP_NAME "));
         }
         else
         {
            _putts(TEXT("UNIQUE_NAME "));
         }
         ucFlags &= 0x07;

         switch (ucFlags)
         {
            case REGISTERING:
               _putts(TEXT("Registering\n"));
               break;
            case REGISTERED:
               _putts(TEXT("Registered\n"));
               break;
            case DEREGISTERED:
               _putts(TEXT("Deregistered\n"));
               break;
            case DUPLICATE:
               _putts(TEXT("Duplicate\n"));
               break;
            case DUPLICATE_DEREG:
               _putts(TEXT("Duplicate Dereg\n"));
               break;
            default:
               _putts(TEXT("UNKNOWN\n"));
               break;
         }
         pNameBuffer++;
      }
   }
   _putts(TEXT("\n"));
}


////////////////////////////////////////////////////////////////////
// end of file tdiquery.cpp
////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\connect.cpp ===
/////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       connect.cpp
//
//    Abstract:
//       This module contains code which deals with making and breaking
//       connections
//
//////////////////////////////////////////////////////////


#include "sysvars.h"

//////////////////////////////////////////////////////////////
// private constants, types, and prototypes
//////////////////////////////////////////////////////////////

const PCHAR strFunc1  = "TSConnect";
const PCHAR strFunc2  = "TSDisconnect";
// const PCHAR strFunc3  = "TSIsConnected";
const PCHAR strFunc4  = "TSConnectHandler";
const PCHAR strFunc5  = "TSDisconnectHandler";
const PCHAR strFunc6  = "TSListen";
// const PCHAR strFuncP1 = "TSGenAcceptComplete";
const PCHAR strFuncP2 = "TSGenConnectComplete";

//
// this context structure stores information needed to complete
// the request in the completion handler
//
struct   CONNECT_CONTEXT
{
   PIRP              pUpperIrp;           // irp from dll to complete
   ULONG             ulWhichCommand;      // command that is being completed
   ULONG             ulListenFlag;        // 0 or TDI_QUERY_ACCEPT
   PENDPOINT_OBJECT  pEndpoint;           // connection endpoint
   PIRP_POOL         pIrpPool;
   PTDI_CONNECTION_INFORMATION
                     pTdiConnectInfo;
};
typedef  CONNECT_CONTEXT  *PCONNECT_CONTEXT;


//
// completion functions
//
TDI_STATUS
TSGenConnectComplete(
   PDEVICE_OBJECT DeviceObject,
   PIRP           Irp,
   PVOID          Context
   );

TDI_STATUS
TSGenAcceptComplete(
   PDEVICE_OBJECT DeviceObject,
   PIRP           Irp,
   PVOID          Context
   );

/////////////////////////////////////////////////////////////
// public functions
//////////////////////////////////////////////////////////////



// -----------------------------------------------------------------
//
// Function:   TSConnect
//
// Arguments:  pEndpoint   -- connection endpoint structure
//             pSendBuffer -- arguments from user dll
//             pIrp        -- completion information
//
// Returns:    NTSTATUS (normally pending)
//
// Descript:   This function attempts to connect the local endpoint object
//             with a remote endpoint
//
// -----------------------------------------------------------------

NTSTATUS
TSConnect(PENDPOINT_OBJECT pEndpoint,
          PSEND_BUFFER     pSendBuffer,
          PIRP             pUpperIrp)
{
   PTRANSPORT_ADDRESS   pTransportAddress
                        = (PTRANSPORT_ADDRESS)&pSendBuffer->COMMAND_ARGS.ConnectArgs.TransAddr;
   ULONG                ulTimeout
                        = pSendBuffer->COMMAND_ARGS.ConnectArgs.ulTimeout;
   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint2("\nCommand = ulCONNECT\n"
                  "FileObject = %p\n"
                  "Timeout    = %u\n",
                   pEndpoint,
                   ulTimeout);
      TSPrintTaAddress(pTransportAddress->Address);
   }

   //
   // make sure all is kosher
   //
   if (pEndpoint->fIsConnected)
   {
      DebugPrint1("%s:  endpoint already connected\n", strFunc1);
      return STATUS_UNSUCCESSFUL;
   }
   if (!pEndpoint->pAddressObject)
   {
      DebugPrint1("%s:  endpoint not associated with transport address\n",
                   strFunc1);
      return STATUS_UNSUCCESSFUL;
   }
   
   //
   // allocate all the necessary structures
   //
   PCONNECT_CONTEXT              pConnectContext;
   PTDI_CONNECTION_INFORMATION   pTdiConnectInfo = NULL;
   
   //
   // our context
   //
   if ((TSAllocateMemory((PVOID *)&pConnectContext,
                          sizeof(CONNECT_CONTEXT),
                          strFunc1,
                          "ConnectContext")) != STATUS_SUCCESS)
   {
      goto cleanup;
   }

   //
   // the connection information structure
   //
   if ((TSAllocateMemory((PVOID *)&pTdiConnectInfo,
                          sizeof(TDI_CONNECTION_INFORMATION) 
                          + sizeof(TRANSADDR),
                          strFunc1,
                          "TdiConnectionInformation")) == STATUS_SUCCESS)
   //
   // set up the TdiConnectionInformation
   //
   {
      PUCHAR   pucTemp = (PUCHAR)pTdiConnectInfo;
      ULONG    ulAddrLength
               = FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
                 + FIELD_OFFSET(TA_ADDRESS, Address)
                   + pTransportAddress->Address[0].AddressLength;

      pucTemp += sizeof(TDI_CONNECTION_INFORMATION);

      pTdiConnectInfo->RemoteAddress       = pucTemp;
      pTdiConnectInfo->RemoteAddressLength = ulAddrLength;
      RtlCopyMemory(pucTemp,
                    pTransportAddress,
                    ulAddrLength);

   }
   else
   {
      goto cleanup;
   }

   //
   // set up the completion context
   //
   pConnectContext->pUpperIrp       = pUpperIrp;
   pConnectContext->pTdiConnectInfo = pTdiConnectInfo;
   pConnectContext->pEndpoint       = pEndpoint;
   pConnectContext->ulWhichCommand  = TDI_CONNECT;


   //
   // finally, the irp itself
   //
   PIRP  pLowerIrp = TSAllocateIrp(pEndpoint->GenHead.pDeviceObject,
                                   NULL);

   if (pLowerIrp)
   {
      LONGLONG    llTimeout;
      PLONGLONG   pllTimeout = NULL;

      if (ulTimeout)
      {
         llTimeout = Int32x32To64(ulTimeout, -10000);
         pllTimeout = &llTimeout;
      }

      //
      // if made it to here, everything is correctly allocated
      // set up irp and and call the tdi provider
      //
#pragma  warning(disable: CONSTANT_CONDITIONAL)

      TdiBuildConnect(pLowerIrp,
                      pEndpoint->GenHead.pDeviceObject,
                      pEndpoint->GenHead.pFileObject,
                      TSGenConnectComplete,
                      pConnectContext,
                      pllTimeout,
                      pTdiConnectInfo,
                      NULL);        // ReturnConnectionInfo

#pragma  warning(default: CONSTANT_CONDITIONAL)

      //
      // make the call to the tdi provider
      //
      pSendBuffer->pvLowerIrp = pLowerIrp;   // so command can be cancelled

      NTSTATUS lStatus = IoCallDriver(pEndpoint->GenHead.pDeviceObject,
                                      pLowerIrp);

      if ((!NT_SUCCESS(lStatus)) && (ulDebugLevel & ulDebugShowCommand))
      {
         DebugPrint2("%s: unexpected status for IoCallDriver [0x%08x]\n", 
                      strFunc1,
                       lStatus);
      }
      return STATUS_PENDING;
   }

//
// get here if there was an allocation failure
// need to clean up everything else...
//
cleanup:
   if (pConnectContext)
   {
      TSFreeMemory(pConnectContext);
   }
   if (pTdiConnectInfo)
   {
      TSFreeMemory(pTdiConnectInfo);
   }
   return STATUS_INSUFFICIENT_RESOURCES;
}



// -----------------------------------------------------------------
//
// Function:   TSDisconnect
//
// Arguments:  pEndpoint   -- connection endpoint structure
//             pIrp        -- completion information
//
// Returns:    NTSTATUS (normally pending)
//
// Descript:   This function attempts to disconnect a local endpoint from 
//             a remote endpoint
//
// -----------------------------------------------------------------

NTSTATUS
TSDisconnect(PENDPOINT_OBJECT pEndpoint,
             PSEND_BUFFER     pSendBuffer,
             PIRP             pUpperIrp)
{
   ULONG ulFlags = pSendBuffer->COMMAND_ARGS.ulFlags;

   if (ulFlags != TDI_DISCONNECT_RELEASE)
   {
      ulFlags = TDI_DISCONNECT_ABORT;
   }

   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint2("\nCommand = ulDISCONNECT\n"
                  "EndpointObject = %p\n"
                  "Flags          = 0x%x\n",
                   pEndpoint,
                   ulFlags);
   }

   //
   // make sure all is kosher
   //
   if (!pEndpoint->fIsConnected)
   {
      DebugPrint1("%s:  endpoint not currently connected\n", strFunc2);
      return STATUS_SUCCESS;
   }

   //
   // allocate all the necessary structures
   //
   PCONNECT_CONTEXT  pConnectContext;

   //
   // first, our context
   //
   if ((TSAllocateMemory((PVOID *)&pConnectContext,
                          sizeof(CONNECT_CONTEXT),
                          strFunc2,
                          "ConnectContext")) == STATUS_SUCCESS)
   {
      pConnectContext->pUpperIrp      = pUpperIrp;
      pConnectContext->ulWhichCommand = TDI_DISCONNECT;
      pConnectContext->pEndpoint      = pEndpoint;

      //
      // then the irp itself
      //
      PIRP  pLowerIrp = TSAllocateIrp(pEndpoint->GenHead.pDeviceObject,
                                      NULL);

      if (pLowerIrp)
      {
         //
         // if made it to here, everything is correctly allocated
         // set up everything and call the tdi provider
         //

#pragma  warning(disable: CONSTANT_CONDITIONAL)

         TdiBuildDisconnect(pLowerIrp,
                            pEndpoint->GenHead.pDeviceObject,
                            pEndpoint->GenHead.pFileObject,
                            TSGenConnectComplete,
                            pConnectContext,
                            NULL,      // pLargeInteger Time
                            ulFlags,   // TDI_DISCONNECT _ABORT or _RELEASE
                            NULL,      // RequestConnectionInfo
                            NULL);     // ReturnConnectionInfo

#pragma  warning(default: CONSTANT_CONDITIONAL)

         //
         // make the call to the tdi provider
         //
         pSendBuffer->pvLowerIrp = pLowerIrp;   // so command can be cancelled
         pEndpoint->fStartedDisconnect = TRUE;

         NTSTATUS lStatus = IoCallDriver(pEndpoint->GenHead.pDeviceObject,
                                         pLowerIrp);

         if ((!NT_SUCCESS(lStatus)) && (ulDebugLevel & ulDebugShowCommand))
         {
            DebugPrint2("%s: unexpected status for IoCallDriver [0x%08x]\n", 
                         strFunc2,
                         lStatus);
         }
         return STATUS_PENDING;
      }
      TSFreeMemory(pConnectContext);
   }
   return STATUS_INSUFFICIENT_RESOURCES;
}



// --------------------------------------------------
//
// Function:   TSListen
//
// Arguments:  pEndpoint   -- connection endpoint structure
//
// Returns:    status of operation (usually success)
//
// Descript:   Wait for an incoming call request
//
// --------------------------------------------------

NTSTATUS
TSListen(PENDPOINT_OBJECT  pEndpoint)
{
   ULONG ulListenFlag = 0;

   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint1("\nCommand = ulLISTEN\n"
                  "FileObject = %p\n",
                   pEndpoint);
   }

   //
   // make sure all is kosher
   //
   if (pEndpoint->fIsConnected)
   {
      DebugPrint1("%s:  endpoint already connected\n", strFunc6);
      return STATUS_UNSUCCESSFUL;
   }
   if (!pEndpoint->pAddressObject)
   {
      DebugPrint1("%s:  endpoint not associated with transport address\n",
                   strFunc6);
      return STATUS_UNSUCCESSFUL;
   }
   
   //
   // allocate all the necessary structures
   //
   PCONNECT_CONTEXT              pConnectContext;
   PTDI_CONNECTION_INFORMATION   pTdiConnectInfo = NULL;
   
   //
   // our context
   //
   if ((TSAllocateMemory((PVOID *)&pConnectContext,
                          sizeof(CONNECT_CONTEXT),
                          strFunc6,
                          "ConnectContext")) != STATUS_SUCCESS)
   {
      goto cleanup;
   }

   //
   // the connection information structure
   //
   if ((TSAllocateMemory((PVOID *)&pTdiConnectInfo,
                          sizeof(TDI_CONNECTION_INFORMATION), 
                          strFunc6,
                          "TdiConnectionInformation")) == STATUS_SUCCESS)
   //
   // set up the TdiConnectionInformation
   //
   {
      pTdiConnectInfo->UserData = NULL;
      pTdiConnectInfo->UserDataLength = 0;
      pTdiConnectInfo->RemoteAddress = NULL;
      pTdiConnectInfo->RemoteAddressLength = 0;
      pTdiConnectInfo->Options = &pConnectContext->ulListenFlag;
      pTdiConnectInfo->OptionsLength = sizeof(ULONG);


      //
      // set up the completion context
      // note that the upper irp is NOT passed!
      //
      pConnectContext->pUpperIrp       = NULL;
      pConnectContext->pTdiConnectInfo = pTdiConnectInfo;
      pConnectContext->pEndpoint       = pEndpoint;
      pConnectContext->ulWhichCommand  = TDI_LISTEN;
      pConnectContext->ulListenFlag    = ulListenFlag;

      if (!pEndpoint->pAddressObject->pIrpPool)
      {
         pEndpoint->pAddressObject->pIrpPool 
                  = TSAllocateIrpPool(pEndpoint->pAddressObject->GenHead.pDeviceObject,
                                      ulIrpPoolSize);
         pConnectContext->pIrpPool = pEndpoint->pAddressObject->pIrpPool;
      }

      //
      // finally, the irp itself
      //
      PIRP  pLowerIrp = TSAllocateIrp(pEndpoint->GenHead.pDeviceObject,
                                      pEndpoint->pAddressObject->pIrpPool);

      if (pLowerIrp)
      {
         //
         // if made it to here, everything is correctly allocated
         // set up irp and call the tdi provider
         //
#pragma  warning(disable: CONSTANT_CONDITIONAL)

         TdiBuildListen(pLowerIrp,
                        pEndpoint->GenHead.pDeviceObject,
                        pEndpoint->GenHead.pFileObject,
                        TSGenAcceptComplete,
                        pConnectContext,
                        ulListenFlag,
                        pTdiConnectInfo,
                        NULL);        // ReturnConnectionInfo

#pragma  warning(default: CONSTANT_CONDITIONAL)

         NTSTATUS lStatus = IoCallDriver(pEndpoint->GenHead.pDeviceObject,
                                         pLowerIrp);

         if ((!NT_SUCCESS(lStatus)) && (ulDebugLevel & ulDebugShowCommand))
         {
            DebugPrint2("%s: unexpected status for IoCallDriver [0x%08x]\n", 
                         strFunc6,
                         lStatus);
         }
         return STATUS_SUCCESS;
      }
   }

//
// get here if there was an allocation failure
// need to clean up everything else...
//
cleanup:
   if (pConnectContext)
   {
      TSFreeMemory(pConnectContext);
   }
   if (pTdiConnectInfo)
   {
      TSFreeMemory(pTdiConnectInfo);
   }
   return STATUS_INSUFFICIENT_RESOURCES;
}


// --------------------------------------------------
//
// Function:   TSIsConnected
//
// Arguments:  pEndpoint      -- connection endpoint structure
//             pReceiveBuffer -- put results in here
//
// Returns:    STATUS_SUCCESS
//
// Descript:   Checks to see if endpoint is currently connected
//
// --------------------------------------------------

NTSTATUS
TSIsConnected(PENDPOINT_OBJECT   pEndpoint,
              PRECEIVE_BUFFER    pReceiveBuffer)
{
   pReceiveBuffer->RESULTS.ulReturnValue = pEndpoint->fIsConnected;
   return STATUS_SUCCESS;
}


// --------------------------------------------------
//
// Function:   TSConnectHandler
//
// Arguments:  pvTdiEventContext    -- here, ptr to address object
//             lRemoteAddressLength -- # bytes in remote address
//             pvRemoteAddress      -- pTransportAddress of remote
//             lUserDataLength      -- length of data at pvUserData
//             pvUserData           -- connect data from remote
//             lOptionsLength       -- length of data in pvOptions
//             pvOptions            -- transport-specific connect options
//             pConnectionContext   -- return ptr to connection context
//             ppAcceptIrp          -- return ptr to TdiBuildAccept irp
//
// Returns:    STATUS_CONNECTION_REFUSED if are rejecting connection
//             STATUS_MORE_PROCESSING_REQUIRED is accepting and have supplied
//             a ppAcceptIrp
//
// Descript:   listens for an offerred connection, then
//             accepts it or rejects it
//
// --------------------------------------------------

TDI_STATUS
TSConnectHandler(PVOID              pvTdiEventContext,
                 LONG               lRemoteAddressLength,
                 PVOID              pvRemoteAddress,
                 LONG               lUserDataLength,
                 PVOID              pvUserData,
                 LONG               lOptionsLength,
                 PVOID              pvOptions,
                 CONNECTION_CONTEXT *pConnectionContext,
                 PIRP               *ppAcceptIrp)
{
   PADDRESS_OBJECT   pAddressObject = (PADDRESS_OBJECT)pvTdiEventContext;
   PENDPOINT_OBJECT  pEndpoint      = pAddressObject->pEndpoint;

   //
   // show the information passed in.
   // Note that we actually use very little of it..
   //
   if (ulDebugLevel & ulDebugShowHandlers)
   {
      DebugPrint1("\n >>>> %s\n", strFunc4);
      DebugPrint2("pAddressObject      = %p\n"
                  "RemoteAddressLength = %d\n",
                   pAddressObject,
                   lRemoteAddressLength);

      if (lRemoteAddressLength)
      {
         PTRANSPORT_ADDRESS   pTransportAddress = (PTRANSPORT_ADDRESS)pvRemoteAddress;
         
         DebugPrint0("RemoteAddress:  ");
         TSPrintTaAddress(&pTransportAddress->Address[0]);
      }

      DebugPrint1("UserDataLength = %d\n", lUserDataLength);
      if (lUserDataLength)
      {
         PUCHAR   pucTemp = (PUCHAR)pvUserData;
   
         DebugPrint0("UserData:  ");
         for (LONG lCount = 0; lCount < lUserDataLength; lCount++)
         {
            DebugPrint1("%02x ", *pucTemp);
            ++pucTemp;
         }
         DebugPrint0("\n");
      }

      DebugPrint1("OptionsLength = %d\n", lOptionsLength);

      if (lOptionsLength)
      {
         PUCHAR   pucTemp = (PUCHAR)pvOptions;

         DebugPrint0("Options:  ");
         for (LONG lCount = 0; lCount < (LONG)lOptionsLength; lCount++)
         {
            DebugPrint1("%02x ", *pucTemp);
            ++pucTemp;
         }
         DebugPrint0("\n");
      }
   }

   //
   // now do the work
   //
   if (pEndpoint->fIsConnected || pEndpoint->fAcceptInProgress)
   {
      return TDI_CONN_REFUSED;
   }
   pEndpoint->fAcceptInProgress = TRUE;


   //
   // allocate all the necessary structures
   //
   PCONNECT_CONTEXT  pConnectContext;


   //
   // first, our context
   //
   if ((TSAllocateMemory((PVOID *)&pConnectContext,
                          sizeof(CONNECT_CONTEXT),
                          strFunc4,
                          "ConnectContext")) == STATUS_SUCCESS)
   {
      pConnectContext->pUpperIrp      = NULL;
      pConnectContext->ulWhichCommand = TDI_ACCEPT;
      pConnectContext->pEndpoint      = pEndpoint;

      //
      // then the irp itself
      //
      PIRP  pLowerIrp = TSAllocateIrp(pEndpoint->GenHead.pDeviceObject,
                                      pAddressObject->pIrpPool);

      pConnectContext->pIrpPool = pAddressObject->pIrpPool;
      if (pLowerIrp)
      {
         //
         // if made it to here, everything is correctly allocated
         // set up irp and call the tdi provider
         //

#pragma  warning(disable: CONSTANT_CONDITIONAL)

         TdiBuildAccept(pLowerIrp,
                        pEndpoint->GenHead.pDeviceObject,
                        pEndpoint->GenHead.pFileObject,
                        TSGenAcceptComplete,
                        pConnectContext,
                        NULL,      // RequestConnectionInfo
                        NULL);     // ReturnConnectionInfo

#pragma  warning(default: CONSTANT_CONDITIONAL)


         //
         // need to do this since we are not calling IoCallDriver
         //
         IoSetNextIrpStackLocation(pLowerIrp);

         *pConnectionContext = pEndpoint;
         *ppAcceptIrp = pLowerIrp;

         return TDI_MORE_PROCESSING;
      }
      TSFreeMemory(pConnectContext);
   }
   pEndpoint->fAcceptInProgress = FALSE;
   return TDI_CONN_REFUSED;
}


// --------------------------------------------------
//
// Function:   TdiDisconnectHandler
//
// Arguments:  pvTdiEventContext    -- here, our address object
//             ConnectionContext    -- here, our connection object
//             lDisconnectDataLength   -- length of data in pvDisconnectData
//             pvDisconnectData  -- data sent by remote as part of disconnect
//             lDisconnectInformationLength -- length of pvDisconnectInformation
//             pvDisconnectInformation -- transport-specific sidconnect info
//             ulDisconnectFlags -- nature of disconnect
//
// Returns:    STATUS_SUCCESS
//
// Descript:   deals with an incoming disconnect.  Note that the disconnect
//             is really complete at this point, as far as the protocol
//             is concerned.  We just need to clean up our stuff
//
// --------------------------------------------------

TDI_STATUS
TSDisconnectHandler(PVOID              pvTdiEventContext,
                    CONNECTION_CONTEXT ConnectionContext,
                    LONG               lDisconnectDataLength,
                    PVOID              pvDisconnectData,
                    LONG               lDisconnectInformationLength,
                    PVOID              pvDisconnectInformation,
                    ULONG              ulDisconnectFlags)

{
   PENDPOINT_OBJECT  pEndpoint = (PENDPOINT_OBJECT)ConnectionContext;

   //
   // show info in arguments
   //
   if (ulDebugLevel & ulDebugShowHandlers)
   {
      DebugPrint1("\n >>>> %s\n", strFunc5);
      DebugPrint3("pAddressObject       = %p\n"
                  "pEndpoint            = %p\n"
                  "DisconnectDataLength = %d\n",
                   pvTdiEventContext,
                   pEndpoint,
                   lDisconnectDataLength);

      if (lDisconnectDataLength)
      {
         PUCHAR   pucTemp = (PUCHAR)pvDisconnectData;

         DebugPrint0("DisconnectData:  ");
         for (LONG lCount = 0; lCount < (LONG)lDisconnectDataLength; lCount++)
         {
            DebugPrint1("%02x ", *pucTemp);
            ++pucTemp;
         }
         DebugPrint0("\n");
      }

      DebugPrint1("DisconnectInformationLength = %d\n", 
                   lDisconnectInformationLength);

      if (lDisconnectInformationLength)
      {
         PUCHAR   pucTemp = (PUCHAR)pvDisconnectInformation;

         DebugPrint0("DisconnectInformation:  ");
         for (LONG lCount = 0; lCount < (LONG)lDisconnectInformationLength; lCount++)
         {
            DebugPrint1("%02x ", *pucTemp);
            ++pucTemp;
         }
         DebugPrint0("\n");
      }
      DebugPrint1("DisconnectFlags = 0x%08x\n", ulDisconnectFlags);
      if (ulDisconnectFlags & TDI_DISCONNECT_ABORT)
      {
         DebugPrint0("                  TDI_DISCONNECT_ABORT\n");
      }
      if (ulDisconnectFlags & TDI_DISCONNECT_RELEASE)
      {
         DebugPrint0("                  TDI_DISCONNECT_RELEASE\n");
      }

   }

   //
   // do our cleanup..
   //
   pEndpoint->fIsConnected = FALSE;

   if ((ulDisconnectFlags & TDI_DISCONNECT_RELEASE) &&
       (!pEndpoint->fStartedDisconnect))
   {
      //
      // allocate all the necessary structures
      //
      PCONNECT_CONTEXT  pConnectContext;
   
      //
      // first, our context
      //
      if ((TSAllocateMemory((PVOID *)&pConnectContext,
                             sizeof(CONNECT_CONTEXT),
                             strFunc5,
                             "ConnectContext")) == STATUS_SUCCESS)
      {
         pConnectContext->pUpperIrp      = NULL;
         pConnectContext->ulWhichCommand = TDI_DISCONNECT;
         pConnectContext->pEndpoint      = pEndpoint;
   
         //
         // then the irp itself
         //
         PIRP  pLowerIrp = TSAllocateIrp(pEndpoint->GenHead.pDeviceObject,
                                         pEndpoint->pAddressObject->pIrpPool);
   
         pConnectContext->pIrpPool = pEndpoint->pAddressObject->pIrpPool;
         if (pLowerIrp)
         {
            //
            // if made it to here, everything is correctly allocated
            // set up irp and call the tdi provider
            //
   
#pragma  warning(disable: CONSTANT_CONDITIONAL)
   
            TdiBuildDisconnect(pLowerIrp,
                               pEndpoint->GenHead.pDeviceObject,
                               pEndpoint->GenHead.pFileObject,
                               TSGenAcceptComplete,
                               pConnectContext,
                               NULL,      // pLargeInteger Time
                               TDI_DISCONNECT_RELEASE,
                               NULL,      // RequestConnectionInfo
                               NULL);     // ReturnConnectionInfo
   
#pragma  warning(default: CONSTANT_CONDITIONAL)
   
            //
            // make the call to the tdi provider
            //
            NTSTATUS lStatus = IoCallDriver(pEndpoint->GenHead.pDeviceObject,
                                            pLowerIrp);
   
            if ((!NT_SUCCESS(lStatus)) && (ulDebugLevel & ulDebugShowCommand))
            {
               DebugPrint2("%s: unexpected status for IoCallDriver [0x%08x]\n", 
                            strFunc5,
                            lStatus);
            }
         }
         else
         {
            TSFreeMemory(pConnectContext);
         }
      }
   }

   //
   // get here if do NOT need to send TDI_DISCONNECT_RELEASE message back
   // to other end of connection
   //
   else
   {
      pEndpoint->fAcceptInProgress = FALSE;
      pEndpoint->fIsConnected      = FALSE;
   }

   return TDI_SUCCESS;
}


/////////////////////////////////////////////////////////////
// private functions
/////////////////////////////////////////////////////////////

// ---------------------------------------------------------
//
// Function:   TSGenAcceptComplete
//
// Arguments:  pDeviceObject  -- device object on which call was made
//             pIrp           -- IRP used in the call
//             pContext       -- context used for the call
//
// Returns:    status of operation (STATUS_MORE_PROCESSING_REQUIRED)
//
// Descript:   Gets the result of the command, stuffs results into 
//             receive buffer, cleans up the Irp and associated data 
//             structures, etc
//             This is used to complete cases where this no IRP from the
//             dll to complete (ie, connect handler, listen, listen-accept,
//             listen-disconnect)
//
// ---------------------------------------------------------

#pragma  warning(disable:  UNREFERENCED_PARAM)

TDI_STATUS
TSGenAcceptComplete(PDEVICE_OBJECT  pDeviceObject,
                    PIRP            pLowerIrp,
                    PVOID           pvContext)
{
   PCONNECT_CONTEXT  pConnectContext = (PCONNECT_CONTEXT)pvContext;
   NTSTATUS          lStatus         = pLowerIrp->IoStatus.Status;

   //
   // dealing with completions where there is no DLL irp associated
   //
   switch (pConnectContext->ulWhichCommand)
   {
      case TDI_ACCEPT:
         if (NT_SUCCESS(lStatus))
         {
            pConnectContext->pEndpoint->fIsConnected = TRUE;
         }
         pConnectContext->pEndpoint->fAcceptInProgress = FALSE;
         break;

      case TDI_LISTEN:
         if (NT_SUCCESS(lStatus))
         {
            pConnectContext->pEndpoint->fIsConnected = TRUE;
         }
         else
         {
            DebugPrint1("Failure in TSListen:  status = 0x%08x\n", lStatus);
         }
         break;

      case TDI_DISCONNECT:
         pConnectContext->pEndpoint->fAcceptInProgress  = FALSE;
         pConnectContext->pEndpoint->fIsConnected       = FALSE;
         pConnectContext->pEndpoint->fStartedDisconnect = FALSE;
         break;
   }

   TSFreeIrp(pLowerIrp, pConnectContext->pIrpPool);

   //
   // generic cleanup
   //
   if (pConnectContext->pTdiConnectInfo)
   {
      TSFreeMemory(pConnectContext->pTdiConnectInfo);
   }
   TSFreeMemory(pConnectContext);

   return TDI_MORE_PROCESSING;
}

#pragma  warning(default:  UNREFERENCED_PARAM)


// ---------------------------------------------------------
//
// Function:   TSGenConnectComplete
//
// Arguments:  pDeviceObject  -- device object on which call was made
//             pIrp           -- IRP used in the call
//             pContext       -- context used for the call
//
// Returns:    status of operation (STATUS_MORE_PROCESSING_REQUIRED)
//
// Descript:   Gets the result of the command, stuffs results into 
//             receive buffer, completes the IRP from the dll, 
//             cleans up the Irp and associated data structures, etc
//             Deals only with commands that carry an IRP from the dll
//
// ---------------------------------------------------------

#pragma  warning(disable:  UNREFERENCED_PARAM)

TDI_STATUS
TSGenConnectComplete(PDEVICE_OBJECT pDeviceObject,
                     PIRP           pLowerIrp,
                     PVOID          pvContext)
{
   PCONNECT_CONTEXT  pConnectContext = (PCONNECT_CONTEXT)pvContext;
   NTSTATUS          lStatus         = pLowerIrp->IoStatus.Status;

   //
   // this is completing a command from the dll
   //
   PRECEIVE_BUFFER   pReceiveBuffer = TSGetReceiveBuffer(pConnectContext->pUpperIrp);

   pReceiveBuffer->lStatus = lStatus;

   if (NT_SUCCESS(lStatus))
   {
      if (ulDebugLevel & ulDebugShowCommand)
      {
         if (pLowerIrp->IoStatus.Information)
         {
            DebugPrint2("%s:  Information = 0x%08x\n",
                         strFuncP2,
                         pLowerIrp->IoStatus.Information);
         }
      }
         
      switch (pConnectContext->ulWhichCommand)
      {
         case TDI_CONNECT:
            pConnectContext->pEndpoint->fIsConnected = TRUE;
            break;

         case TDI_DISCONNECT:
            pConnectContext->pEndpoint->fIsConnected = FALSE;
            break;

         default:
            DebugPrint2("%s: invalid command value [0x%08x]\n",
                         strFuncP2,
                         pConnectContext->ulWhichCommand);
            DbgBreakPoint();
            break;
      }
   }
   else
   {
      if (ulDebugLevel & ulDebugShowCommand)
      {
         DebugPrint2("%s:  Completed with status 0x%08x\n", 
                      strFuncP2,
                      lStatus);
      }
   }
   TSCompleteIrp(pConnectContext->pUpperIrp);
   TSFreeIrp(pLowerIrp, NULL);

   //
   // generic cleanup
   //
   if (pConnectContext->pTdiConnectInfo)
   {
      TSFreeMemory(pConnectContext->pTdiConnectInfo);
   }
   TSFreeMemory(pConnectContext);

   return TDI_MORE_PROCESSING;
}

#pragma  warning(default:  UNREFERENCED_PARAM)



///////////////////////////////////////////////////////////////////////////////
// end of file connect.cpp
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\rcvdgram.cpp ===
/////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       rcvdgram
//
//    Abstract:
//       This module contains code which deals with receiving datagrams
//
//////////////////////////////////////////////////////////


#include "sysvars.h"


//////////////////////////////////////////////////////////////
// private constants, types, and prototypes
//////////////////////////////////////////////////////////////

const PCHAR strFunc1  = "TSReceiveDatagram";
const PCHAR strFunc2  = "TSRcvDatagramHandler";
const PCHAR strFunc3  = "TSChainedRcvDatagramHandler";
const PCHAR strFuncP1 = "TSReceiveDgramComplete";
const PCHAR strFuncP2 = "TSGetRestOfDgram";
const PCHAR strFuncP3 = "TSShowDgramInfo";


//
// completion information structure
//
struct   RECEIVE_CONTEXT
{
   PMDL              pLowerMdl;           // mdl from lower irp
   PRECEIVE_DATA     pReceiveData;        // above structure
   PADDRESS_OBJECT   pAddressObject;      // associate address object
   PIRP_POOL         pIrpPool;
};
typedef  RECEIVE_CONTEXT  *PRECEIVE_CONTEXT;


//
// completion function
//
TDI_STATUS
TSReceiveDgramComplete(
   PDEVICE_OBJECT DeviceObject,
   PIRP           Irp,
   PVOID          Context
   );


PIRP
TSGetRestOfDgram(
   PADDRESS_OBJECT   pAddressObject,
   PRECEIVE_DATA     pReceiveData
   );


VOID
TSShowDgramInfo(
   PVOID    pvTdiEventContext,
   LONG     lSourceAddressLength,
   PVOID    pvSourceAddress,
   LONG     lOptionsLength,
   PVOID    pvOptions,
   ULONG    ulReceiveDatagramFlags
   );

//////////////////////////////////////////////////////////////
// public functions
//////////////////////////////////////////////////////////////


// -----------------------------------------------------------------
//
// Function:   TSReceiveDatagram
//
// Arguments:  pAddressObject -- address object
//             pSendBuffer    -- arguments from user dll
//             pIrp           -- completion information
//
// Returns:    STATUS_SUCCESS
//
// Descript:   This function checks to see if a datagram has been received
//             on this address object.  If so, and if it matches certain
//             criteria, it returns it.  Otherwise it returns with no data.
//
// ----------------------------------------------------------------------------

NTSTATUS
TSReceiveDatagram(PADDRESS_OBJECT   pAddressObject,
                  PSEND_BUFFER      pSendBuffer,
                  PRECEIVE_BUFFER   pReceiveBuffer)
{
   PTRANSPORT_ADDRESS   pTransportAddress 
                        = (PTRANSPORT_ADDRESS)&pSendBuffer->COMMAND_ARGS.SendArgs.TransAddr;
   BOOLEAN              fMatchAddress 
                        = (BOOLEAN)(pTransportAddress->TAAddressCount > 0);
   PRECEIVE_DATA        pReceiveData = NULL;
                  
   //
   // if need to match to address, return the first packet in the queue
   // that was sent from the specified address. 
   //
   if (fMatchAddress)
   {
      ULONG    ulCompareLength
               = FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
                 + FIELD_OFFSET(TA_ADDRESS, Address)
                   + pTransportAddress->Address[0].AddressLength;

      if (pTransportAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP)
      {
         ulCompareLength -= 8;      // ignore sin_zero[8]
      }

      TSAcquireSpinLock(&pAddressObject->TdiSpinLock);
      pReceiveData = pAddressObject->pHeadReceiveData;
      while(pReceiveData)
      {
         if (RtlEqualMemory(pTransportAddress,
                            &pReceiveData->TransAddr,
                            ulCompareLength))
         {
            break;
         }
         pReceiveData = pReceiveData->pNextReceiveData;
      }

      //
      // did we find anything?
      //
      if (pReceiveData)
      {
         //
         // fix up the lists as necessary
         //
         if (pReceiveData->pPrevReceiveData)
         {
            pReceiveData->pPrevReceiveData->pNextReceiveData 
                        = pReceiveData->pNextReceiveData;
         }
         else
         {
            pAddressObject->pHeadReceiveData = pReceiveData->pNextReceiveData;
         }

         if (pReceiveData->pNextReceiveData)
         {
            pReceiveData->pNextReceiveData->pPrevReceiveData 
                        = pReceiveData->pPrevReceiveData;
         }
         else
         {
            pAddressObject->pTailReceiveData = pReceiveData->pPrevReceiveData;
         }
      }
      TSReleaseSpinLock(&pAddressObject->TdiSpinLock);
   }

   //
   // if not matching address, just get the first packet from the queue
   //
   else
   {
      TSAcquireSpinLock(&pAddressObject->TdiSpinLock);
      pReceiveData = pAddressObject->pHeadReceiveData;
      if (pReceiveData)
      {
         //
         // fix up the lists as necessary
         //
         if (pReceiveData->pNextReceiveData)
         {
            pReceiveData->pNextReceiveData->pPrevReceiveData = NULL;
         }
         else
         {
            pAddressObject->pTailReceiveData = NULL;
         }
         pAddressObject->pHeadReceiveData = pReceiveData->pNextReceiveData;
      }
      TSReleaseSpinLock(&pAddressObject->TdiSpinLock);
   }
      
   //
   // if we got a packet to return, then lets return it..
   // and release its memory
   //
   if (pReceiveData)
   {
      //
      // we are only showing debug if we actually return a packet
      //
      if (ulDebugLevel & ulDebugShowCommand)
      {
         DebugPrint1("\nCommand = ulRECEIVEDATAGRAM\n"
                     "FileObject = %p\n",
                      pAddressObject);
         if (pTransportAddress->TAAddressCount)
         {
            TSPrintTaAddress(pTransportAddress->Address);
         }
      }

      if (pReceiveData->ulBufferLength > pSendBuffer->COMMAND_ARGS.SendArgs.ulBufferLength)
      {
         pReceiveData->ulBufferLength = pSendBuffer->COMMAND_ARGS.SendArgs.ulBufferLength;
      }


      //
      // attempt to lock down the memory
      //
      PMDL  pMdl = TSMakeMdlForUserBuffer(pSendBuffer->COMMAND_ARGS.SendArgs.pucUserModeBuffer, 
                                          pReceiveData->ulBufferLength,
                                          IoModifyAccess);
      if (pMdl)
      {
         RtlCopyMemory(&pReceiveBuffer->RESULTS.RecvDgramRet.TransAddr,
                       &pReceiveData->TransAddr,
                       sizeof(TRANSADDR));
         
         RtlCopyMemory(MmGetSystemAddressForMdl(pMdl),
                       pReceiveData->pucDataBuffer,
                       pReceiveData->ulBufferLength);
         TSFreeUserBuffer(pMdl);
      }
      else
      {
         pReceiveData->ulBufferLength = 0;
      }

      pReceiveBuffer->RESULTS.RecvDgramRet.ulBufferLength = pReceiveData->ulBufferLength;

      TSFreeMemory(pReceiveData->pucDataBuffer);
      TSFreeMemory(pReceiveData);

   }
   else
   {
      pReceiveBuffer->RESULTS.RecvDgramRet.ulBufferLength = 0;
   }

   return STATUS_SUCCESS;
}


// -----------------------------------------------
//
// Function:   TSRcvDatagramHandler
//
// Arguments:  pvTdiEventContext -- really pointer to our AddressObject
//             lSourceAddressLength -- #bytes of source address
//             pvSourceAddress -- TransportAddress
//             lOptionsLength -- #bytes of transport-specific options
//             pvOptions -- options string
//             ulReceiveDatagramFlags -- nature of datagram received
//             ulBytesIndicated --- length of data in buffer
//             ulBytesTotal     -- total length of datagram
//             pulBytesTaken -- stuff with bytes used by this driver
//             pvTsdu        -- data buffer
//             pIoRequestPacket -- pIrp in case not all data received
//
// Returns:    STATUS_DATA_NOT_ACCEPTED (we didn't want data)
//             STATUS_SUCCESS (we used all data & are done with it)
//             STATUS_MORE_PROCESSING_REQUIRED -- we supplied an IRP for rest
//
// Descript:   Event handler for incoming datagrams
//
// -----------------------------------------------

TDI_STATUS
TSRcvDatagramHandler(PVOID    pvTdiEventContext,
                     LONG     lSourceAddressLength,
                     PVOID    pvSourceAddress,
                     LONG     lOptionsLength,
                     PVOID    pvOptions,
                     ULONG    ulReceiveDatagramFlags,
                     ULONG    ulBytesIndicated,
                     ULONG    ulBytesTotal,
                     PULONG   pulBytesTaken,
                     PVOID    pvTsdu,
                     PIRP     *pIoRequestPacket)

{
   //
   // show debug information
   //
   if (ulDebugLevel & ulDebugShowHandlers)
   {
      DebugPrint1("\n >>>> %s\n", strFunc2);
      TSShowDgramInfo(pvTdiEventContext,
                      lSourceAddressLength,
                      pvSourceAddress,
                      lOptionsLength,
                      pvOptions,
                      ulReceiveDatagramFlags);

      DebugPrint3("BytesIndicated = %u\n"
                  "BytesTotal     = %u\n"
                  "pTSDU          = %p\n",
                   ulBytesIndicated,
                   ulBytesTotal,
                   pvTsdu);
   }

   //
   // bad situation if more bytes are indicated than the total in the packet
   //
   if (ulBytesIndicated > ulBytesTotal)
   {
      DebugPrint2("%d bytes indicated > %u bytes total\n",
                   ulBytesIndicated,
                   ulBytesTotal);
   }

   //
   // now start doing the work...
   //
   PADDRESS_OBJECT   pAddressObject = (PADDRESS_OBJECT)pvTdiEventContext;
   PRECEIVE_DATA     pReceiveData;
   TDI_STATUS        TdiStatus = TDI_SUCCESS;   // default -- we are done with packet
                                                // (also returned in case of error)
   
   if ((TSAllocateMemory((PVOID *)&pReceiveData,
                          sizeof(RECEIVE_DATA),
                          strFunc2,
                          "ReceiveData")) == STATUS_SUCCESS)
   {
      PUCHAR   pucDataBuffer = NULL;
      
      if ((TSAllocateMemory((PVOID *)&pucDataBuffer,
                             ulBytesTotal,
                             strFunc2,
                             "DataBuffer")) == STATUS_SUCCESS)
      {
         RtlCopyMemory(&pReceiveData->TransAddr,
                       pvSourceAddress,
                       lSourceAddressLength);

         pReceiveData->pucDataBuffer  = pucDataBuffer;
         pReceiveData->ulBufferLength = ulBytesTotal;
         
         TdiCopyLookaheadData(pucDataBuffer,
                              pvTsdu,
                              ulBytesIndicated,
                              ulReceiveDatagramFlags);
         
         pReceiveData->ulBufferUsed = ulBytesIndicated;


         if (ulBytesIndicated == ulBytesTotal)     // note: should never be >
         {
            TSPacketReceived(pAddressObject, 
                             pReceiveData,
                             FALSE);

            *pulBytesTaken    = ulBytesTotal;
            *pIoRequestPacket = NULL;
         }

         else        // not all data is present!!
         {
            PIRP  pLowerIrp = TSGetRestOfDgram(pAddressObject,
                                               pReceiveData);

            if (pLowerIrp)
            {
               //
               // need to do this since we are bypassing IoCallDriver
               //
               IoSetNextIrpStackLocation(pLowerIrp);
         
               *pulBytesTaken    = ulBytesIndicated;
               *pIoRequestPacket = pLowerIrp;
               TdiStatus         = TDI_MORE_PROCESSING;
            }
            else
            {
               TSFreeMemory(pReceiveData->pucDataBuffer);
               TSFreeMemory(pReceiveData);
            }
         }
      }
      else        // unable to allocate pucDataBuffer
      {
         TSFreeMemory(pReceiveData);
      }
   }
   return TdiStatus;
}


// ----------------------------------------------
//
// Function:   TSChainedRcvDatagramHandler
//
// Arguments:  pvTdiEventContext -- really pointer to our AddressObject
//             lSourceAddressLength -- #bytes of source address
//             pvSourceAddress -- TransportAddress
//             lOptionsLength -- #bytes of transport-specific options
//             pvOptions -- options string
//             ulReceiveDatagramFlags -- nature of datagram received
//             ulReceiveDatagramLength -- bytes in received datagram
//             ulStartingOffset -- starting offset of data within MDL
//             pTsdu        -- data buffer (as an mdl)
//             pvTsduDescriptor -- handle to use when completing if pend
//
// Returns:    STATUS_DATA_NOT_ACCEPTED or STATUS_SUCCESS
//
// Descript:   Deals with receiving chained datagrams (where the
//             entire datagram is always available)
// 
// -----------------------------------------------

#pragma warning(disable: UNREFERENCED_PARAM)

TDI_STATUS
TSChainedRcvDatagramHandler(PVOID   pvTdiEventContext,
                            LONG    lSourceAddressLength,
                            PVOID   pvSourceAddress,
                            LONG    lOptionsLength,
                            PVOID   pvOptions,
                            ULONG   ulReceiveDatagramFlags,
                            ULONG   ulReceiveDatagramLength,
                            ULONG   ulStartingOffset,
                            PMDL    pMdl,
                            PVOID   pvTsduDescriptor)
{
   if (ulDebugLevel & ulDebugShowHandlers)
   {
      DebugPrint1("\n >>>> %s\n", strFunc3);
      TSShowDgramInfo(pvTdiEventContext,
                      lSourceAddressLength,
                      pvSourceAddress,
                      lOptionsLength,
                      pvOptions,
                      ulReceiveDatagramFlags);

      DebugPrint3("DataLength     = %u\n"
                  "StartingOffset = %u\n"
                  "pTSDU          = %p\n",
                   ulReceiveDatagramLength,
                   ulStartingOffset,
                   pMdl);
   }


   //
   // now do the work..
   //
   PRECEIVE_DATA     pReceiveData;
   PADDRESS_OBJECT   pAddressObject = (PADDRESS_OBJECT)pvTdiEventContext;

   if ((TSAllocateMemory((PVOID *)&pReceiveData,
                          sizeof(RECEIVE_DATA),
                          strFunc3,
                          "ReceiveData")) == STATUS_SUCCESS)
   {
      PUCHAR   pucDataBuffer = NULL;
      
      if ((TSAllocateMemory((PVOID *)&pucDataBuffer,
                             ulReceiveDatagramLength,
                             strFunc3,
                             "DataBuffer")) == STATUS_SUCCESS)
      {
         ULONG    ulBytesCopied;

         RtlCopyMemory(&pReceiveData->TransAddr,
                       pvSourceAddress,
                       lSourceAddressLength);

         TdiCopyMdlToBuffer(pMdl,
                            ulStartingOffset,
                            pucDataBuffer,
                            0,
                            ulReceiveDatagramLength,
                            &ulBytesCopied);

         //
         // if successfully copied all data
         //
         if (ulBytesCopied == ulReceiveDatagramLength)
         {
            UCHAR ucFirstChar = *pucDataBuffer;

            pReceiveData->pucDataBuffer  = pucDataBuffer;
            pReceiveData->ulBufferLength = ulReceiveDatagramLength;
            pReceiveData->ulBufferUsed   = ulReceiveDatagramLength;
            TSPacketReceived(pAddressObject,
                             pReceiveData,
                             FALSE);
         }

         //
         // error in copying data!
         //
         else
         {
            DebugPrint1("%s: error copying data\n", strFunc3);

            TSFreeMemory(pucDataBuffer);
            TSFreeMemory(pReceiveData);
         }
      }
      else        // unable to allocate pucDataBuffer
      {
         TSFreeMemory(pReceiveData);
      }

   }

   return TDI_SUCCESS;     // we are done with packet
}


#pragma warning(default: UNREFERENCED_PARAM)


/////////////////////////////////////////////////////////////
// private functions
/////////////////////////////////////////////////////////////

// ---------------------------------------------------------
//
// Function:   TSReceiveDgramComplete
//
// Arguments:  pDeviceObject  -- device object that called ReceiveDatagram
//             pIrp           -- IRP used in the call
//             pContext       -- context used for the call
//
// Returns:    status of operation (STATUS_MORE_PROCESSING_REQUIRED)
//
// Descript:   Gets the result of the receive and adds the packet
//             to the receive queue of the address object.  Then
//             cleans up
//
// ---------------------------------------------------------

#pragma warning(disable: UNREFERENCED_PARAM)

TDI_STATUS
TSReceiveDgramComplete(PDEVICE_OBJECT  pDeviceObject,
                       PIRP            pLowerIrp,
                       PVOID           pvContext)

{
   PRECEIVE_CONTEXT  pReceiveContext = (PRECEIVE_CONTEXT)pvContext;
   NTSTATUS          lStatus         = pLowerIrp->IoStatus.Status;
   ULONG             ulBytesCopied   = (ULONG)pLowerIrp->IoStatus.Information;
   PADDRESS_OBJECT   pAddressObject  = pReceiveContext->pAddressObject;
   PRECEIVE_DATA     pReceiveData    = pReceiveContext->pReceiveData;

   if (NT_SUCCESS(lStatus))
   {
      if (ulDebugLevel & ulDebugShowCommand)
      {
         DebugPrint2("%s:  %u BytesCopied\n",
                      strFuncP1,
                      ulBytesCopied);
      }
      pReceiveData->ulBufferUsed += ulBytesCopied;

      if (pReceiveData->ulBufferUsed >=  pReceiveData->ulBufferLength)
      {
         TSPacketReceived(pAddressObject,
                          pReceiveData,
                          FALSE);
      }
      else
      {
         DebugPrint1("%s:  Data Incomplete\n", strFuncP1);
         TSFreeMemory(pReceiveData->pucDataBuffer);
         TSFreeMemory(pReceiveData);
      }
   }
   else
   {
      DebugPrint2("%s:  Completed with status 0x%08x\n", 
                   strFuncP1,
                   lStatus);
      
      TSFreeMemory(pReceiveData->pucDataBuffer);
      TSFreeMemory(pReceiveData);
   }

   //
   // now cleanup
   //
   TSFreeIrp(pLowerIrp, pReceiveContext->pIrpPool);
   TSFreeBuffer(pReceiveContext->pLowerMdl);

   TSFreeMemory(pReceiveContext);

   return STATUS_MORE_PROCESSING_REQUIRED;

}

#pragma warning(default: UNREFERENCED_PARAM)

// ------------------------------------------------------
//
// Function:   TSGetRestOfDgram
//
// Arguments:  pAddressObject -- address object we are receiving on
//             pReceiveData   -- what we have received so far..
//
// Returns:    Irp to return to transport, to get rest of data (NULL if error)
//
// Descript:   This function sets up the IRP to get the rest of a datagram
//             that was only partially delivered via the event handler
//
// -------------------------------------------------

PIRP
TSGetRestOfDgram(PADDRESS_OBJECT pAddressObject,
                 PRECEIVE_DATA   pReceiveData)
{
   PUCHAR            pucDataBuffer   = pReceiveData->pucDataBuffer + pReceiveData->ulBufferUsed;
   ULONG             ulBufferLength  = pReceiveData->ulBufferLength - pReceiveData->ulBufferUsed;
   PRECEIVE_CONTEXT  pReceiveContext = NULL;
   PMDL              pReceiveMdl     = NULL;

   //
   // allocate all the necessary structures
   // our context
   //
   if ((TSAllocateMemory((PVOID *)&pReceiveContext,
                          sizeof(RECEIVE_CONTEXT),
                          strFuncP2,
                          "ReceiveContext")) != STATUS_SUCCESS)
   {
      goto cleanup;
   }


   //
   // then the actual mdl
   //
   pReceiveMdl = TSAllocateBuffer(pucDataBuffer, 
                                  ulBufferLength);

   if (pReceiveMdl)
   {
      //
      // set up the completion context
      //
      pReceiveContext->pLowerMdl      = pReceiveMdl;
      pReceiveContext->pReceiveData   = pReceiveData;
      pReceiveContext->pAddressObject = pAddressObject;

      //
      // finally, the irp itself
      //
      PIRP  pLowerIrp = TSAllocateIrp(pAddressObject->GenHead.pDeviceObject,
                                      pAddressObject->pIrpPool);

      if (pLowerIrp)
      {
         pReceiveContext->pIrpPool = pAddressObject->pIrpPool;
         //
         // if made it to here, everything is correctly allocated
         // set up the irp for the call
         //
#pragma  warning(disable: CONSTANT_CONDITIONAL)

         TdiBuildReceiveDatagram(pLowerIrp,
                                 pAddressObject->GenHead.pDeviceObject,
                                 pAddressObject->GenHead.pFileObject,
                                 TSReceiveDgramComplete,
                                 pReceiveContext,
                                 pReceiveMdl,
                                 0,    /// ulBufferLength,    // 0 doesn't work with ipx
                                 NULL,
                                 NULL,
                                 TDI_RECEIVE_NORMAL);

#pragma  warning(default: CONSTANT_CONDITIONAL)

         //
         // mark it pending before returning control to transport
         //
         return pLowerIrp;
      }
   }

//
// get here if there was an allocation failure
// need to clean up everything else...
//
cleanup:
   if (pReceiveContext)
   {
      TSFreeMemory(pReceiveContext);
   }
   if (pReceiveMdl)
   {
      TSFreeBuffer(pReceiveMdl);
   }
   return NULL;
}

// ---------------------------------
//
// Function:   TSShowDgramInfo
//
// Arguments:  pvTdiEventContext -- really pointer to our AddressObject
//             lSourceAddressLength -- #bytes of source address
//             pvSourceAddress -- TransportAddress
//             lOptionsLength -- #bytes of transport-specific options
//             pvOptions -- options string
//             ulReceiveDatagramFlags -- nature of datagram received
//
// Returns:    none
//
// Descript:   shows info passed to the dgram handlers
//
// --------------------------------

VOID
TSShowDgramInfo(PVOID   pvTdiEventContext,
                LONG    lSourceAddressLength,
                PVOID   pvSourceAddress,
                LONG    lOptionsLength,
                PVOID   pvOptions,
                ULONG   ulReceiveDatagramFlags)
{
   DebugPrint2("pAddressObject      = %p\n"
               "SourceAddressLength = %d\n",
                pvTdiEventContext,
                lSourceAddressLength);

   if (lSourceAddressLength)
   {
      PTRANSPORT_ADDRESS   pTransportAddress = (PTRANSPORT_ADDRESS)pvSourceAddress;
      
      DebugPrint0("SourceAddress:  ");
      TSPrintTaAddress(&pTransportAddress->Address[0]);
   }

   DebugPrint1("OptionsLength = %d\n", lOptionsLength);

   if (lOptionsLength)
   {
      PUCHAR   pucTemp = (PUCHAR)pvOptions;

      DebugPrint0("Options:  ");
      for (LONG lCount = 0; lCount < lOptionsLength; lCount++)
      {
         DebugPrint1("%02x ", *pucTemp);
         ++pucTemp;
      }
      DebugPrint0("\n");
   }

   DebugPrint1("ReceiveDatagramFlags: 0x%08x\n", ulReceiveDatagramFlags);
   if (ulReceiveDatagramFlags & TDI_RECEIVE_BROADCAST)
   {
      DebugPrint0("TDI_RECEIVE_BROADCAST\n");
   }
   if (ulReceiveDatagramFlags & TDI_RECEIVE_MULTICAST)
   {
      DebugPrint0("TDI_RECEIVE_MULTICAST\n");
   }
   if (ulReceiveDatagramFlags & TDI_RECEIVE_PARTIAL)
   {
      DebugPrint0("TDI_RECEIVE_PARTIAL (legacy)\n");
   }
   if (ulReceiveDatagramFlags & TDI_RECEIVE_NORMAL)   // shouldn't see for datagram
   {
      DebugPrint0("TDI_RECEIVE_NORMAL\n");
   }
   if (ulReceiveDatagramFlags & TDI_RECEIVE_EXPEDITED)   // shouldn't see for datagram
   {
      DebugPrint0("TDI_RECEIVE_EXPEDITED\n");
   }
   if (ulReceiveDatagramFlags & TDI_RECEIVE_PEEK)
   {
      DebugPrint0("TDI_RECEIVE_PEEK\n");
   }
   if (ulReceiveDatagramFlags & TDI_RECEIVE_NO_RESPONSE_EXP)   // not for datagrams
   {
      DebugPrint0("TDI_RECEIVE_NO_RESPONSE_EXP\n");
   }
   if (ulReceiveDatagramFlags & TDI_RECEIVE_COPY_LOOKAHEAD)
   {
      DebugPrint0("TDI_RECEIVE_COPY_LOOKAHEAD\n");
   }
   if (ulReceiveDatagramFlags & TDI_RECEIVE_ENTIRE_MESSAGE)
   {
      DebugPrint0("TDI_RECEIVE_ENTIRE_MESSAGE\n");
   }
   if (ulReceiveDatagramFlags & TDI_RECEIVE_AT_DISPATCH_LEVEL)
   {
      DebugPrint0("TDI_RECEIVE_AT_DISPATCH_LEVEL\n");
   }
}


///////////////////////////////////////////////////////////////////////////////
// end of file rcvdgram.cpp
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\open.cpp ===
/////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       open.cpp
//
//    Abstract:
//       This module contains code which deals with opening and closing
//       of the various types of tdi objects
//
//////////////////////////////////////////////////////////


#include "sysvars.h"
extern "C"
{
#pragma warning(disable: NAMELESS_STRUCT_UNION)
#include "tdiinfo.h"
#pragma warning(default: NAMELESS_STRUCT_UNION)
}


//
// defines stolen from include files not in ddk
//
#define AO_OPTION_IP_UCASTIF        17
#define FSCTL_TCP_BASE     FILE_DEVICE_NETWORK

#define _TCP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_TCP_BASE, function, method, access)
#define IOCTL_TCP_WSH_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(10, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// end of stolen defines
//

//////////////////////////////////////////////////////////////
// private constants and prototypes
//////////////////////////////////////////////////////////////

const PCHAR strFunc1 = "TSOpenControl";
const PCHAR strFunc2 = "TSCloseControl";
const PCHAR strFunc3 = "TSOpenAddress";
const PCHAR strFunc4 = "TSCloseAddress";
const PCHAR strFunc5 = "TSOpenEndpoint";
const PCHAR strFunc6 = "TSCloseEndpoint";

//const PCHAR strFuncP1 = "TSCompleteCommand";
const PCHAR strFuncP2 = "TSPerformOpenControl";
const PCHAR strFuncP3 = "TSPerformOpenAddress";
const PCHAR strFuncP4 = "TSPerformOpenEndpoint";
const PCHAR strFuncP5 = "TSPerformAssociate";
const PCHAR strFuncP6 = "TSPerformDisassociate";


TDI_STATUS
TSCompleteCommand(
   PDEVICE_OBJECT pDeviceObject,
   PIRP           pLowerIrp,
   PVOID          pvContext
   );

NTSTATUS
TSPerformOpenControl(
   PCONTROL_CHANNEL  pControlChannel,
   PUCNTSTRING       pucString
   );

NTSTATUS
TSPerformOpenAddress(
   PADDRESS_OBJECT      pAddressObject,
   PUCNTSTRING          pucString,
   PTRANSPORT_ADDRESS   pTransportAddress,
   BOOLEAN              fIsConnect
   );


NTSTATUS
TSPerformOpenEndpoint(
   PENDPOINT_OBJECT  pEndpointObject,
   PUCNTSTRING       pucString
   );


NTSTATUS
TSPerformAssociate(
   PENDPOINT_OBJECT  pEndpoint
   );

VOID
TSPerformDisassociate(
   PENDPOINT_OBJECT  pEndpoint
   );

//////////////////////////////////////////////////////////////
// public functions
//////////////////////////////////////////////////////////////


// ----------------------------------------------------------------------------
//
// Function:   TSOpenControl
//
// Arguments:  pSendBuffer    -- arguments from user dll for open command
//             pIrp           -- completion information
//
// Returns:    Final status of the open (STATUS_SUCCESSFUL or STATUS_errorcode)
//
// Descript:   This function sets up the structure for a new control channel,
//             and attempts to open the specified control channel
//
// ----------------------------------------------------------------------------

NTSTATUS
TSOpenControl(PSEND_BUFFER    pSendBuffer,
              PRECEIVE_BUFFER pReceiveBuffer)
{
   PUCNTSTRING pucString = &pSendBuffer->COMMAND_ARGS.OpenArgs.ucsDeviceName;

   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint1("\nCommand = ulOPENCONTROL\n"
                  "DeviceName = %ws\n",
                   pucString->wcBuffer);
   }

   //
   // allocate our structure and put it in the linked list...
   //
   PCONTROL_CHANNEL  pControlChannel;
   NTSTATUS          lStatus = TSAllocateMemory((PVOID *)&pControlChannel,
                                                 sizeof(CONTROL_CHANNEL),
                                                 strFunc1,
                                                 "ControlChannel");
   
   if (lStatus == STATUS_SUCCESS)
   {    
      pControlChannel->GenHead.ulSignature = ulControlChannelObject;

      ULONG ulTdiHandle = TSInsertNode(&pControlChannel->GenHead);

      if (ulTdiHandle)
      {
         lStatus = TSPerformOpenControl(pControlChannel, pucString);
         if (lStatus == STATUS_SUCCESS)
         {
            pReceiveBuffer->RESULTS.TdiHandle = ulTdiHandle;
            return STATUS_SUCCESS;
         }

         //
         // handle errors in PerformOpenControl
         //
         TSRemoveNode(ulTdiHandle);
      }
      else
      {
         lStatus = STATUS_INSUFFICIENT_RESOURCES;
      }
      TSFreeMemory(pControlChannel);
   }
   return lStatus;
}



// -----------------------------------------------------------------
//
// Function:   TSCloseControl
//
// Arguments:  pControlChannel   -- our control channel object to close
//
// Returns:    none
//
// Descript:   This function frees the resources for a control channel,
//             and calls the tdi provider to close it
//
// ----------------------------------------------------------------------------

VOID
TSCloseControl(PCONTROL_CHANNEL  pControlChannel)
{
   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint1("\nCommand = ulCLOSECONTROL\n"
                  "ControlChannel = %p\n",
                   pControlChannel);
   }


   ObDereferenceObject(pControlChannel->GenHead.pFileObject);

   
   NTSTATUS    lStatus = ZwClose(pControlChannel->GenHead.FileHandle);

   if (lStatus != STATUS_SUCCESS)
   {
      DebugPrint2("%s: ZwClose failed with status 0x%08x\n",
                   strFunc2,
                   lStatus);
   }
   
   TSFreeMemory(pControlChannel);
}




// -----------------------------------------------------------------
//
// Function:   TSOpenAddress
//
// Arguments:  pSendBuffer    -- arguments from user dll for open command
//             pIrp           -- completion information
//
// Returns:    Final status of the open (STATUS_SUCCESSFUL or STATUS_errorcode)
//
// Descript:   This function sets up the structure for a new address object,
//             and attempts to open the specified address object
//
// ----------------------------------------------------------------------------

NTSTATUS
TSOpenAddress(PSEND_BUFFER    pSendBuffer,
              PRECEIVE_BUFFER pReceiveBuffer)
{
   PUCNTSTRING          pucString   = &pSendBuffer->COMMAND_ARGS.OpenArgs.ucsDeviceName;
   PTRANSPORT_ADDRESS   pTransportAddress 
                        = (PTRANSPORT_ADDRESS)&pSendBuffer->COMMAND_ARGS.OpenArgs.TransAddr;

   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint1("\nCommand = ulOPENADDRESS\n"
                  "DeviceName = %ws\n",
                   pucString->wcBuffer);
      TSPrintTaAddress(pTransportAddress->Address);
   }

   //
   // allocate our structure and put it in the linked list...
   //
   PADDRESS_OBJECT   pAddressObject;
   NTSTATUS          lStatus = TSAllocateMemory((PVOID *)&pAddressObject,
                                                 sizeof(ADDRESS_OBJECT),
                                                 strFunc3,
                                                 "AddressObject");
   
   if (lStatus == STATUS_SUCCESS)
   {    
      pAddressObject->GenHead.ulSignature = ulAddressObject;

      ULONG ulTdiHandle = TSInsertNode(&pAddressObject->GenHead);

      if (ulTdiHandle)
      {
         lStatus = TSPerformOpenAddress(pAddressObject, pucString, pTransportAddress, FALSE);
         if (lStatus == STATUS_SUCCESS)
         {
            pReceiveBuffer->RESULTS.TdiHandle = ulTdiHandle;
            return STATUS_SUCCESS;
         }

         //
         // handle error in PerformOpenAddress
         //
         TSRemoveNode(ulTdiHandle);
      }
      else
      {
         lStatus = STATUS_INSUFFICIENT_RESOURCES;
      }
      TSFreeMemory(pAddressObject);
   }
   return lStatus;
}


// -----------------------------------------------------------------
//
// Function:   TSCloseAddress
//
// Arguments:  pAddressObject -- address object to close
//
// Returns:    none
//
// Descript:   This function frees the resources for an address object,
//             and calls the tdi provider to close it
//
// ----------------------------------------------------------------------------


VOID
TSCloseAddress(PADDRESS_OBJECT pAddressObject)
{
   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint1("\nCommand = ulCLOSEADDRESS\n"
                  "AddressObject = %p\n",
                   pAddressObject);
   }

   TSFreeSpinLock(&pAddressObject->TdiSpinLock);
   TSFreePacketData(pAddressObject);

   ObDereferenceObject(pAddressObject->GenHead.pFileObject);

   if (pAddressObject->pIrpPool)
   {
      TSFreeIrpPool(pAddressObject->pIrpPool);
   }
   
   NTSTATUS lStatus = ZwClose(pAddressObject->GenHead.FileHandle);

   if (lStatus != STATUS_SUCCESS)
   {
      DebugPrint2("%s: ZwClose failed with status 0x%08x\n",
                   strFunc4,
                   lStatus);
   }
   TSFreeMemory(pAddressObject);
}


// -----------------------------------------------------------------
//
// Function:   TSOpenEndpoint
//
// Arguments:  pSendBuffer    -- arguments from user dll for open command
//             pIrp           -- completion information
//
// Returns:    Final status of the open (STATUS_SUCCESSFUL or STATUS_errorcode)
//
// Descript:   This function sets up the structure for an endpoint.  This 
//             involves opening an endpoint, opening an address object, and 
//             associating them...
//
// ----------------------------------------------------------------------------

NTSTATUS
TSOpenEndpoint(PSEND_BUFFER      pSendBuffer,
               PRECEIVE_BUFFER   pReceiveBuffer)
{
   PUCNTSTRING          pucString   = &pSendBuffer->COMMAND_ARGS.OpenArgs.ucsDeviceName;
   PTRANSPORT_ADDRESS   pTransportAddress
                        = (PTRANSPORT_ADDRESS)&pSendBuffer->COMMAND_ARGS.OpenArgs.TransAddr;

   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint1("\nCommand = ulOPENENDPOINT\n"
                  "DeviceName = %ws\n",
                   pucString->wcBuffer);
      TSPrintTaAddress(pTransportAddress->Address);
   }

   //
   // set up for the file open
   // need to do our "context" structure first, since the
   // eabuffer requires it...
   //
   PENDPOINT_OBJECT  pEndpoint;
   NTSTATUS          lStatus = TSAllocateMemory((PVOID *)&pEndpoint,
                                                 sizeof(ENDPOINT_OBJECT),
                                                 strFunc5,
                                                 "EndpointObject");

   if (lStatus == STATUS_SUCCESS)
   {    
      pEndpoint->GenHead.ulSignature = ulEndpointObject;

      ULONG    ulTdiHandle = TSInsertNode(&pEndpoint->GenHead);
      
      if (ulTdiHandle)
      {
         lStatus = TSPerformOpenEndpoint(pEndpoint, pucString);
         if (lStatus == STATUS_SUCCESS)
         {
            PADDRESS_OBJECT   pAddressObject;
         
            lStatus = TSAllocateMemory((PVOID *)&pAddressObject,
                                        sizeof(ADDRESS_OBJECT),
                                        strFunc5,
                                        "AddressObject");
            
            if (lStatus == STATUS_SUCCESS)
            {    
               pAddressObject->GenHead.ulSignature = ulAddressObject;
         
               lStatus = TSPerformOpenAddress(pAddressObject, pucString, pTransportAddress, TRUE);
               if (lStatus == STATUS_SUCCESS)
               {
                  pEndpoint->pAddressObject = pAddressObject;
                  pAddressObject->pEndpoint = pEndpoint;
                  lStatus = TSPerformAssociate(pEndpoint);
                  if (lStatus == STATUS_SUCCESS)
                  {
                     pReceiveBuffer->RESULTS.TdiHandle = ulTdiHandle;
                     return STATUS_SUCCESS;
                  }
               }
            }
//
// fall thru to here on open/associate failures
//
         }
         else
         {
            TSRemoveNode(ulTdiHandle);
         }
      }
      else
      {
         lStatus = STATUS_INSUFFICIENT_RESOURCES;
      }
      TSCloseEndpoint(pEndpoint);    // also frees it!
   }
   return lStatus;
}


// -----------------------------------------------------------------
//
// Function:   TSCloseEndpoint
//
// Arguments:  pEndpoint   -- endpoint object to close
//
// Returns:    none
//
// Descript:   This function frees the resources for a connection object,
//             and calls the tdi provider to close it
//
// ----------------------------------------------------------------------------


VOID
TSCloseEndpoint(PENDPOINT_OBJECT  pEndpoint)
{
   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint1("\nCommand = ulCLOSEENDPOINT\n"
                  "Endpoint = %p\n",
                   pEndpoint);
   }

   if (pEndpoint->pAddressObject)
   {
      if (pEndpoint->fIsAssociated)
      {
         TSPerformDisassociate(pEndpoint);
      }
      TSCloseAddress(pEndpoint->pAddressObject);
      pEndpoint->pAddressObject = NULL;
   }

   if (pEndpoint->GenHead.pFileObject)
   {
      ObDereferenceObject(pEndpoint->GenHead.pFileObject);

      NTSTATUS lStatus = ZwClose(pEndpoint->GenHead.FileHandle);
      if (lStatus != STATUS_SUCCESS)
      {
         DebugPrint2("%s: ZwClose failed with status 0x%08x\n",
                      strFunc6,
                      lStatus);
      }
   }
                  
   TSFreeMemory(pEndpoint);
}

////////////////////////////////////////////////////////////////
// Private Functions
///////////////////////////////////////////////////////////////


// ------------------------------------------------------
//
// Function:   TSCompleteCommand
//
// Arguments:  ptr to address object or endpoint to close for command
//             lstatus = status of close attempt (as TDI_STATUS)
//             param = 0
//
// Returns:    none
//
// Descript:   This function is called to complete a CloseAddress or
//             a CloseEndpoint on Win98
//
// -------------------------------------------------------

#pragma warning(disable: UNREFERENCED_PARAM)

TDI_STATUS
TSCompleteCommand(PDEVICE_OBJECT pDeviceObject,
                  PIRP           pLowerIrp,
                  PVOID          pvContext)
{
   TDI_STATUS        TdiStatus = pLowerIrp->IoStatus.Status;
   PGENERIC_HEADER   pGenHead = (PGENERIC_HEADER)pvContext;

   TSSetEvent(&pGenHead->TdiEvent);
   pGenHead->lStatus = TdiStatus;

   TSFreeIrp(pLowerIrp, NULL);
   return TDI_MORE_PROCESSING;
}

#pragma warning(default: UNREFERENCED_PARAM)



// -----------------------------------------------
//
// Function:   TSPerformOpenControl
//
// Arguments:  pControlChannel -- used to store file information
//             pucString       -- name of device to open
//
// Returns:    status of operation
//
// Descript:   Actually opens the control channel, and then sets the
//             appropriate fields in our structure
//
// -----------------------------------------------

NTSTATUS
TSPerformOpenControl(PCONTROL_CHANNEL  pControlChannel,
                     PUCNTSTRING       pucString)
{
   UNICODE_STRING ustrDeviceName;

   //
   // we need a unicode string to actually do the open
   //
   NTSTATUS lStatus = TSAllocateMemory((PVOID *)&ustrDeviceName.Buffer,
                                        pucString->usLength + 2,
                                        strFuncP2,
                                        "StringBuffer");

   if (lStatus == STATUS_SUCCESS)
   {
      HANDLE            FileHandle;
      IO_STATUS_BLOCK   IoStatusBlock;
      OBJECT_ATTRIBUTES ObjectAttributes;
   
      //
      // create the unicode string
      //
      ustrDeviceName.Length        = pucString->usLength;
      ustrDeviceName.MaximumLength = (USHORT)(pucString->usLength + 2);
      RtlCopyMemory(ustrDeviceName.Buffer,
                    pucString->wcBuffer,
                    ustrDeviceName.Length);

      //
      // set up the object attributes needed to open this...
      //
      InitializeObjectAttributes(&ObjectAttributes,
                                 &ustrDeviceName,
                                 OBJ_CASE_INSENSITIVE,
                                 NULL,
                                 NULL);

      lStatus = ZwCreateFile(&FileHandle,
                             GENERIC_READ | GENERIC_WRITE,  // desired access.
                             &ObjectAttributes,             // object attributes.
                             &IoStatusBlock,                // returned status information.
                             NULL,                          // Allocation size (unused).
                             FILE_ATTRIBUTE_NORMAL,         // file attributes.
                             FILE_SHARE_WRITE,
                             FILE_CREATE,
                             0,                             // create options.
                             NULL,
                             0);

      //
      // make sure it really succeeded
      //
      if (NT_SUCCESS(lStatus)) 
      {
         lStatus = IoStatusBlock.Status;
      }

      //
      // clean up this now (don't need it anymore)
      //
      TSFreeMemory(ustrDeviceName.Buffer);

      //
      // if it succeeded, then set up our node structure
      //
      if (NT_SUCCESS(lStatus)) 
      {
         PFILE_OBJECT pFileObject;
   
         lStatus = ObReferenceObjectByHandle(FileHandle,
                                             0,
                                             NULL,
                                             KernelMode,
                                             (PVOID *)&pFileObject,
                                             NULL);
         if (NT_SUCCESS(lStatus))
         {
            pControlChannel->GenHead.FileHandle    = FileHandle;
            pControlChannel->GenHead.pFileObject   = pFileObject;
            pControlChannel->GenHead.pDeviceObject = IoGetRelatedDeviceObject(pFileObject);
            return STATUS_SUCCESS;     // only successful exit point     
         }
         else
         {
            DebugPrint1("ObReferenceObjectByHandle failed with status = 0x%08x\n",
                         lStatus);
         }
      }
      //
      // get here if ZwCreateFile failed
      //
      else 
      {
         DebugPrint3("OpenControlChannel failed for %ws with code %x iostatus %x\n",
                      pucString->wcBuffer,
                      lStatus,
                      IoStatusBlock.Status);
      }
   }
   return lStatus;
}



// -----------------------------------------------
//
// Function:   TSPerformOpenAddress
//
// Arguments:  pAddressObject -- used to store file information
//             pucString      -- name of device to open
//             pTransportAddr -- address to open on the device
//             fIsConnect     -- TRUE for connection, false for datagram
//
// Returns:    status of operation
//
// Descript:   Actually opens the address object, and then sets the
//             appropriate fields in our structure
//
// -----------------------------------------------

NTSTATUS
TSPerformOpenAddress(PADDRESS_OBJECT      pAddressObject,
                     PUCNTSTRING          pucString,
                     PTRANSPORT_ADDRESS   pTransportAddress,
                     BOOLEAN              fIsConnect)
{

   //
   // address open uses an ea buffer that contains the transport address
   //
   ULONG    ulAddressLength
            = FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
              + FIELD_OFFSET(TA_ADDRESS, Address)
                + pTransportAddress->Address[0].AddressLength;
   ULONG    ulEaLengthNeeded
            = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0])
              + (TDI_TRANSPORT_ADDRESS_LENGTH + 1) 
                + ulAddressLength;

   //
   // allocate the ea buffer first...
   //
   PFILE_FULL_EA_INFORMATION  EaBuffer;
   NTSTATUS lStatus = TSAllocateMemory((PVOID *)&EaBuffer,
                                        ulEaLengthNeeded,
                                        strFuncP3,
                                       "EaBuffer");
   
   if (lStatus == STATUS_SUCCESS)
   {
      UNICODE_STRING    ustrDeviceName;

      //
      // setup the ea buffer
      //
      EaBuffer->NextEntryOffset = 0;
      EaBuffer->Flags          = 0;
      EaBuffer->EaNameLength   = TDI_TRANSPORT_ADDRESS_LENGTH;
      EaBuffer->EaValueLength  = (USHORT)ulAddressLength;
      RtlCopyMemory(&EaBuffer->EaName[0], 
                    TdiTransportAddress, 
                    TDI_TRANSPORT_ADDRESS_LENGTH + 1);

      RtlCopyMemory(&EaBuffer->EaName[TDI_TRANSPORT_ADDRESS_LENGTH+1],
                    pTransportAddress,
                    ulAddressLength);

      //
      // we need a unicode string to actually do the open
      //
      lStatus = TSAllocateMemory((PVOID *)&ustrDeviceName.Buffer,
                                  pucString->usLength + 2,
                                  strFuncP3,
                                  "StringBuffer");
      
      if (lStatus == STATUS_SUCCESS)
      {
         IO_STATUS_BLOCK   IoStatusBlock;
         OBJECT_ATTRIBUTES ObjectAttributes;
         HANDLE            FileHandle;
   
         //
         // create the unicode string
         //
         ustrDeviceName.Length        = pucString->usLength;
         ustrDeviceName.MaximumLength = (USHORT)(pucString->usLength + 2);
         RtlCopyMemory(ustrDeviceName.Buffer,
                       pucString->wcBuffer,
                       ustrDeviceName.Length);

         //
         // set up the object attributes needed to open this...
         //
         InitializeObjectAttributes(&ObjectAttributes,
                                    &ustrDeviceName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

         lStatus = ZwCreateFile(&FileHandle,
                                GENERIC_READ | GENERIC_WRITE,  // desired access.
                                &ObjectAttributes,             // object attributes.
                                &IoStatusBlock,                // returned status information.
                                NULL,                          // Allocation size (unused).
                                FILE_ATTRIBUTE_NORMAL,         // file attributes.
                                FILE_SHARE_WRITE,
                                FILE_CREATE,
                                0,                             // create options.
                                EaBuffer,
                                ulEaLengthNeeded);

         //
         // make sure it really succeeded
         //
         if (NT_SUCCESS(lStatus)) 
         {
            lStatus = IoStatusBlock.Status;
         }

         //
         // clean up what we can here...
         //
         TSFreeMemory(ustrDeviceName.Buffer);
         TSFreeMemory(EaBuffer);

         //
         // if it succeeded, then set up our node structure
         //
         if (NT_SUCCESS(lStatus)) 
         {
            PFILE_OBJECT pFileObject;

            lStatus = ObReferenceObjectByHandle(FileHandle,
                                                0,
                                                NULL,
                                                KernelMode,
                                                (PVOID *)&pFileObject,
                                                NULL);
            if (NT_SUCCESS(lStatus))
            {
               pAddressObject->GenHead.FileHandle = FileHandle;
               pAddressObject->GenHead.pFileObject = pFileObject;
               pAddressObject->GenHead.pDeviceObject = IoGetRelatedDeviceObject(pFileObject);
               TSAllocateSpinLock(&pAddressObject->TdiSpinLock);

               //
               // if ipv4, set up socket for strong host
               //
               if (fIsConnect && (pTransportAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP))
               {
                  TCP_REQUEST_SET_INFORMATION_EX* pInfo;
                  CHAR              achBuf[ sizeof(*pInfo) + sizeof(ULONG) ];
                  ULONG             ulValue = 1;
                  IO_STATUS_BLOCK   iosb;

                  pInfo = (TCP_REQUEST_SET_INFORMATION_EX* )achBuf;
                  pInfo->ID.toi_entity.tei_entity   = CL_TL_ENTITY;
                  pInfo->ID.toi_entity.tei_instance = 0;
                  pInfo->ID.toi_class = INFO_CLASS_PROTOCOL;
                  pInfo->ID.toi_type  = INFO_TYPE_ADDRESS_OBJECT;
                  pInfo->ID.toi_id    = AO_OPTION_IP_UCASTIF;

                  RtlCopyMemory(pInfo->Buffer, &ulValue, sizeof(ULONG));
                  pInfo->BufferSize = sizeof(ULONG);

                  PIRP  pIrp = IoBuildDeviceIoControlRequest(IOCTL_TCP_WSH_SET_INFORMATION_EX,
                                                             pAddressObject->GenHead.pDeviceObject,
                                                             (PVOID )pInfo,
                                                             sizeof(*pInfo) + sizeof(ULONG),
                                                             NULL,
                                                             0,
                                                             FALSE,
                                                             NULL,
                                                             &iosb);

                  if (pIrp)
                  {
                     PIO_STACK_LOCATION pIrpSp = IoGetNextIrpStackLocation(pIrp);
                     pIrpSp->FileObject = pFileObject;

                     IoCallDriver(pAddressObject->GenHead.pDeviceObject, pIrp);
                  }
               }

               return STATUS_SUCCESS;     // only successful exit
            }
            else
            {
               DebugPrint1("ObReferenceObjectByHandle failed with status = 0x%08x\n",
                            lStatus);
            }
            ZwClose(FileHandle);
         }

         //
         // get here if ZwCreateFile failed
         //
         else 
         {
            DebugPrint3("OpenAddressObject failed for %ws with code %x iostatus %x\n",
                         pucString->wcBuffer,
                         lStatus,
                         IoStatusBlock.Status);
         }
      }

      //
      // get here if cannot allocate unicode string buffer
      //
      else
      {
         TSFreeMemory(EaBuffer);
      }
   }

   return lStatus;
}




// -----------------------------------------------
//
// Function:   TSPerformOpenEndpoint
//
// Arguments:  pEndpoint -- used to store file information
//             pucString -- name of device to open
//
// Returns:    status of operation
//
// Descript:   Actually opens the endpoint object, and then sets the
//             appropriate fields in our structure
//
// -----------------------------------------------


NTSTATUS
TSPerformOpenEndpoint(PENDPOINT_OBJECT pEndpoint,
                      PUCNTSTRING      pucString)
{

   //
   // NOTE:  CONNECTION_CONTEXT == PVOID
   //
   ULONG    ulEaLengthNeeded
            = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0])
              + (TDI_CONNECTION_CONTEXT_LENGTH + 1) 
                + sizeof(CONNECTION_CONTEXT);

   //
   // allocate the ea buffer...
   //
   PFILE_FULL_EA_INFORMATION  EaBuffer;
   NTSTATUS lStatus = TSAllocateMemory((PVOID *)&EaBuffer,
                                        ulEaLengthNeeded,
                                        strFunc5,
                                        "EaBuffer");
      
   if (lStatus == STATUS_SUCCESS)
   {
      UNICODE_STRING    ustrDeviceName;

      //
      // setup the ea buffer
      //
      EaBuffer->NextEntryOffset = 0;
      EaBuffer->Flags           = 0;
      EaBuffer->EaNameLength    = TDI_CONNECTION_CONTEXT_LENGTH;
      EaBuffer->EaValueLength   = sizeof(CONNECTION_CONTEXT);
      RtlCopyMemory(&EaBuffer->EaName[0], 
                    TdiConnectionContext, 
                    TDI_CONNECTION_CONTEXT_LENGTH + 1);

      RtlCopyMemory(&EaBuffer->EaName[TDI_CONNECTION_CONTEXT_LENGTH+1],
                    &pEndpoint,
                    sizeof(CONNECTION_CONTEXT));

      //
      // we need a unicode string to actually do the open
      //
      lStatus = TSAllocateMemory((PVOID *)&ustrDeviceName.Buffer,
                                  pucString->usLength + 2,
                                  strFunc5,
                                  "StringBuffer");
         
      if (lStatus == STATUS_SUCCESS)
      {
         IO_STATUS_BLOCK   IoStatusBlock;
         OBJECT_ATTRIBUTES ObjectAttributes;
         HANDLE            FileHandle;
   
         //
         // create the unicode string
         //
         ustrDeviceName.Length        = pucString->usLength;
         ustrDeviceName.MaximumLength = (USHORT)(pucString->usLength + 2);
         RtlCopyMemory(ustrDeviceName.Buffer,
                       pucString->wcBuffer,
                       ustrDeviceName.Length);

         //
         // set up the object attributes needed to open this...
         //
         InitializeObjectAttributes(&ObjectAttributes,
                                    &ustrDeviceName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

         lStatus = ZwCreateFile(&FileHandle,
                                GENERIC_READ | GENERIC_WRITE,  // desired access.
                                &ObjectAttributes,             // object attributes.
                                &IoStatusBlock,                // returned status information.
                                NULL,                          // Allocation size (unused).
                                FILE_ATTRIBUTE_NORMAL,         // file attributes.
                                FILE_SHARE_WRITE,
                                FILE_CREATE,
                                0,                             // create options.
                                EaBuffer,
                                ulEaLengthNeeded);

         //
         // make sure it really succeeded
         //
         if (NT_SUCCESS(lStatus)) 
         {
            lStatus = IoStatusBlock.Status;
         }

         //
         // free up what we can here...
         //
         TSFreeMemory(ustrDeviceName.Buffer);
         TSFreeMemory(EaBuffer);

         //
         // if it succeeded, then set up our node structure
         //
         if (NT_SUCCESS(lStatus)) 
         {
            PFILE_OBJECT pFileObject;

            lStatus = ObReferenceObjectByHandle(FileHandle,
                                                0,
                                                NULL,
                                                KernelMode,
                                                (PVOID *)&pFileObject,
                                                NULL);
            if (NT_SUCCESS(lStatus))
            {
               pEndpoint->GenHead.FileHandle = FileHandle;
               pEndpoint->GenHead.pFileObject = pFileObject;
               pEndpoint->GenHead.pDeviceObject = IoGetRelatedDeviceObject(pFileObject);
               return STATUS_SUCCESS;     // only successful exit
            }
      
            else
            {
               DebugPrint1("ObReferenceObjectByHandle failed with status = 0x%08x\n",
                            lStatus);
            }
            ZwClose(FileHandle);
         }

         //
         // get here if ZwCreateFile failed
         //
         else 
         {
            DebugPrint3("OpenEndpointObject failed for %ws with code %x iostatus %x\n",
                         pucString->wcBuffer,
                         lStatus,
                         IoStatusBlock.Status);
         }
      }

      //
      // get here if cannot allocate unicode string buffer
      //
      else
      {
         TSFreeMemory(EaBuffer);
      }
   }
   return lStatus;
}


// -----------------------------------------------------------------
//
// Function:   TSPerformAssociate
//
// Arguments:  pEndpoint      -- connection endpoint structure
//
// Returns:    NTSTATUS (normally success)
//
// Descript:   This function attempts to associate a transport address 
//             object with an endpoint object
//
// -----------------------------------------------------------------------------

NTSTATUS
TSPerformAssociate(PENDPOINT_OBJECT pEndpoint)
{
   TSInitializeEvent(&pEndpoint->GenHead.TdiEvent);

   PIRP  pLowerIrp = TSAllocateIrp(pEndpoint->GenHead.pDeviceObject,
                                   NULL);

   if (!pLowerIrp)
   {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   //
   // set up everything and call the tdi provider
   //

#pragma  warning(disable: CONSTANT_CONDITIONAL)

   TdiBuildAssociateAddress(pLowerIrp,
                            pEndpoint->GenHead.pDeviceObject,
                            pEndpoint->GenHead.pFileObject,
                            TSCompleteCommand,
                            pEndpoint,
                            pEndpoint->pAddressObject->GenHead.FileHandle);

#pragma  warning(default:  CONSTANT_CONDITIONAL)

   //
   // (should ALWAYS be pending)
   //
   NTSTATUS lStatus = IoCallDriver(pEndpoint->GenHead.pDeviceObject,
                                   pLowerIrp);

   if (lStatus == STATUS_PENDING)
   {
      TSWaitEvent(&pEndpoint->GenHead.TdiEvent);
      lStatus = pEndpoint->GenHead.lStatus;
   }

   if (lStatus == STATUS_SUCCESS)
   {
      pEndpoint->fIsAssociated = TRUE;
   }
   return lStatus;
}



// -----------------------------------------------------------------
//
// Function:   TSPerformDisassociateAddress
//
// Arguments:  pEndpoint   -- connection endpoint structure
//
// Returns:    NTSTATUS (normally pending)
//
// Descript:   This function attempts to disassociate a transport address 
//             object from its associated endpoint object
//
// ----------------------------------------------------------------------------


VOID
TSPerformDisassociate(PENDPOINT_OBJECT  pEndpoint)
{
   TSInitializeEvent(&pEndpoint->GenHead.TdiEvent);

   PIRP  pLowerIrp = TSAllocateIrp(pEndpoint->GenHead.pDeviceObject,
                                   NULL);

   if (!pLowerIrp)
   {
      return;
   }

   //
   // set up everything and call the tdi provider
   //

#pragma  warning(disable: CONSTANT_CONDITIONAL)

   TdiBuildDisassociateAddress(pLowerIrp,
                               pEndpoint->GenHead.pDeviceObject,
                               pEndpoint->GenHead.pFileObject,
                               TSCompleteCommand,
                               pEndpoint);

#pragma  warning(default: CONSTANT_CONDITIONAL)
      
   NTSTATUS lStatus = IoCallDriver(pEndpoint->GenHead.pDeviceObject,
                                   pLowerIrp);

   if (lStatus == STATUS_PENDING)
   {
      TSWaitEvent(&pEndpoint->GenHead.TdiEvent);
   }
}

////////////////////////////////////////////////////////////////////////////////
// end of file open.cpp
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\receive.cpp ===
/////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       receive
//
//    Abstract:
//       This module contains code which deals with receiving data
//
//////////////////////////////////////////////////////////


#include "sysvars.h"


//////////////////////////////////////////////////////////////
// private constants, types, and prototypes
//////////////////////////////////////////////////////////////

const PCHAR strFunc1  = "TSReceive";
const PCHAR strFunc2  = "TSReceiveHandler";
const PCHAR strFunc3  = "TSRcvExpeditedHandler";
const PCHAR strFunc4  = "TSChainedReceiveHandler";
const PCHAR strFunc5  = "TSChainedRcvExpeditedHandler";
const PCHAR strFuncP1 = "TSReceiveComplete";
const PCHAR strFuncP2 = "TSShowReceiveInfo";
const PCHAR strFuncP3 = "TSGetRestOfData";
const PCHAR strFuncP4 = "TSCommonReceive";
const PCHAR strFuncP5 = "TSCommonChainedReceive";

//
// completion context
//
struct   RECEIVE_CONTEXT
{
   PMDL              pLowerMdl;           // mdl from lower irp
   PRECEIVE_DATA     pReceiveData;        // above structure
   PADDRESS_OBJECT   pAddressObject;
   BOOLEAN           fIsExpedited;
};
typedef  RECEIVE_CONTEXT  *PRECEIVE_CONTEXT;


//
// completion function
//
TDI_STATUS
TSReceiveComplete(
   PDEVICE_OBJECT DeviceObject,
   PIRP           Irp,
   PVOID          Context
   );


PIRP
TSGetRestOfData(
   PADDRESS_OBJECT   pAddressObject,
   PRECEIVE_DATA     pReceiveData,
   BOOLEAN           fIsExpedited
   );

VOID
TSShowReceiveInfo(
   PADDRESS_OBJECT      pAddressObject,
   CONNECTION_CONTEXT   ConnectionContext,
   ULONG                ulReceiveFlags,
   ULONG                ulBytesIndicated,
   ULONG                ulBytesAvailable,
   PVOID                pvTsdu,
   BOOLEAN              fIsChained
   );


TDI_STATUS
TSCommonReceive(
   PADDRESS_OBJECT   pAddressObject,
   ULONG             ulBytesTotal,
   ULONG             ulBytesIndicated,
   ULONG             ulReceiveFlags,
   PVOID             pvTsdu,
   BOOLEAN           fIsExpedited,
   PULONG            pulBytesTaken,
   PIRP              *pIoRequestPacket
   );



TDI_STATUS
TSCommonChainedReceive(
   PADDRESS_OBJECT   pAddressObject,
   ULONG             ulReceiveLength,
   ULONG             ulStartingOffset,
   PMDL              pReceiveMdl,
   BOOLEAN           fIsExpedited,
   PVOID             pvTsduDescriptor
   );


//////////////////////////////////////////////////////////////
// public functions
//////////////////////////////////////////////////////////////


// -----------------------------------------------------------------
//
// Function:   TSReceive
//
// Arguments:  pEndpointObject -- current endpoint
//             pIrp           -- completion information
//
// Returns:    NTSTATUS (normally pending)
//
// Descript:   This function receives data over a connection
//
// ----------------------------------------------------------------------------

NTSTATUS
TSReceive(PENDPOINT_OBJECT pEndpoint,
          PSEND_BUFFER     pSendBuffer,
          PRECEIVE_BUFFER  pReceiveBuffer)
{
   PADDRESS_OBJECT   pAddressObject = pEndpoint->pAddressObject;

   //
   // assume no packet
   //
   pReceiveBuffer->RESULTS.RecvDgramRet.ulBufferLength = 0;

   if (pAddressObject)
   {
      PRECEIVE_DATA  pReceiveData;

      //
      // just get the first packet from the queue
      //  check expedited list First
      //
      TSAcquireSpinLock(&pAddressObject->TdiSpinLock);
      pReceiveData = pAddressObject->pHeadRcvExpData;
      if (pReceiveData)
      {
         //
         // fix up the lists as necessary
         //
         if (pReceiveData->pNextReceiveData)
         {
            pReceiveData->pNextReceiveData->pPrevReceiveData = NULL;
         }
         else
         {
            pAddressObject->pTailRcvExpData = NULL;
         }
         pAddressObject->pHeadRcvExpData = pReceiveData->pNextReceiveData;
      }

      //
      // if no expedited receives, check normal list
      //
      else
      {
         pReceiveData = pAddressObject->pHeadReceiveData;
         if (pReceiveData)
         {
            //
            // fix up the lists as necessary
            //
            if (pReceiveData->pNextReceiveData)
            {
               pReceiveData->pNextReceiveData->pPrevReceiveData = NULL;
            }
            else
            {
               pAddressObject->pTailReceiveData = NULL;
            }
            pAddressObject->pHeadReceiveData = pReceiveData->pNextReceiveData;
         }
      }
      TSReleaseSpinLock(&pAddressObject->TdiSpinLock);
      
      //
      // if we got a packet to return, then lets return it..
      // and release its memory
      //
      if (pReceiveData)
      {
         //
         // show debug, if it is turned on, and only if we actually
         // are returning a packet
         //
         if (ulDebugLevel & ulDebugShowCommand)
         {
            DebugPrint1("\nCommand = ulRECEIVE\n"
                        "FileObject = %p\n",
                         pEndpoint);
         }
   
         if (pReceiveData->ulBufferLength > pSendBuffer->COMMAND_ARGS.SendArgs.ulBufferLength)
         {
            pReceiveData->ulBufferLength = pSendBuffer->COMMAND_ARGS.SendArgs.ulBufferLength;
         }
   
         //
         // attempt to lock down the memory
         //
         PMDL  pMdl = TSMakeMdlForUserBuffer(pSendBuffer->COMMAND_ARGS.SendArgs.pucUserModeBuffer, 
                                             pReceiveData->ulBufferLength,
                                             IoModifyAccess);
         if (pMdl)
         {
            RtlCopyMemory(MmGetSystemAddressForMdl(pMdl),
                          pReceiveData->pucDataBuffer,
                          pReceiveData->ulBufferLength);
            TSFreeUserBuffer(pMdl);
         }
         else
         {
            pReceiveData->ulBufferLength = 0;
         }
   
         pReceiveBuffer->RESULTS.RecvDgramRet.ulBufferLength = pReceiveData->ulBufferLength;

         TSFreeMemory(pReceiveData->pucDataBuffer);
         TSFreeMemory(pReceiveData);
      }
   }

   return STATUS_SUCCESS;
}

// -----------------------------------------------
//
// Function:   TSReceiveHandler
//
// Arguments:  pvTdiEventContext -- really pointer to our AddressObject
//             Connection_Context -- really pointer to our Endpoint
//             ReceiveFlags -- nature of received data
//             ulBytesIndicated --- length of data in buffer
//             ulBytesTotal     -- total length of datagram
//             pulBytesTaken -- stuff with bytes used by this driver
//             pvTsdu        -- data buffer
//             pIoRequestPacket -- pIrp in case not all data received
//
// Returns:    STATUS_DATA_NOT_ACCEPTED (we didn't want data)
//             STATUS_SUCCESS (we used all data & are done with it)
//             STATUS_MORE_PROCESSING_REQUIRED -- we supplied an IRP for rest
//
// Descript:   Event handler for incoming receives on connection
//
// -----------------------------------------------

TDI_STATUS
TSReceiveHandler(PVOID              pvTdiEventContext,
                 CONNECTION_CONTEXT ConnectionContext,
                 ULONG              ulReceiveFlags,
                 ULONG              ulBytesIndicated,
                 ULONG              ulBytesTotal,
                 PULONG             pulBytesTaken,
                 PVOID              pvTsdu,
                 PIRP               *ppIoRequestPacket)

{
   PADDRESS_OBJECT   pAddressObject = (PADDRESS_OBJECT)pvTdiEventContext;

   if (ulDebugLevel & ulDebugShowHandlers)
   {
      DebugPrint1("\n >>>> %s\n", strFunc2);
      TSShowReceiveInfo(pAddressObject,
                        ConnectionContext,
                        ulReceiveFlags,
                        ulBytesIndicated,
                        ulBytesTotal,
                        pvTsdu,
                        FALSE);
   }

   return  TSCommonReceive(pAddressObject,
                           ulBytesTotal,
                           ulBytesIndicated,
                           ulReceiveFlags,
                           pvTsdu,
                           ((ulReceiveFlags & TDI_RECEIVE_EXPEDITED) != 0),
                           pulBytesTaken,
                           ppIoRequestPacket);
}



// -----------------------------------------------
//
// Function:   TSRcvExpeditedHandler
//
// Arguments:  pvTdiEventContext -- really pointer to our AddressObject
//             Connection_Context -- really pointer to our Endpoint
//             ReceiveFlags -- nature of received data
//             ulBytesIndicated --- length of data in buffer
//             ulBytesTotal     -- total length of datagram
//             pulBytesTaken -- stuff with bytes used by this driver
//             pvTsdu        -- data buffer
//             pIoRequestPacket -- pIrp in case not all data received
//
// Returns:    STATUS_DATA_NOT_ACCEPTED (we didn't want data)
//             STATUS_SUCCESS (we used all data & are done with it)
//             STATUS_MORE_PROCESSING_REQUIRED -- we supplied an IRP for rest
//
// Descript:   Event handler for incoming expedited receives on connection
//
// -----------------------------------------------

TDI_STATUS
TSRcvExpeditedHandler(PVOID               pvTdiEventContext,
                      CONNECTION_CONTEXT  ConnectionContext,
                      ULONG               ulReceiveFlags,
                      ULONG               ulBytesIndicated,
                      ULONG               ulBytesTotal,
                      PULONG              pulBytesTaken,
                      PVOID               pvTsdu,
                      PIRP                *ppIoRequestPacket)

{
   PADDRESS_OBJECT   pAddressObject = (PADDRESS_OBJECT)pvTdiEventContext;

   if (ulDebugLevel & ulDebugShowHandlers)
   {
      DebugPrint1("\n >>>> %s\n", strFunc3);
      TSShowReceiveInfo(pAddressObject,
                        ConnectionContext,
                        ulReceiveFlags,
                        ulBytesIndicated,
                        ulBytesTotal,
                        pvTsdu,
                        FALSE);
   }
   
   return TSCommonReceive(pAddressObject,
                          ulBytesTotal,
                          ulBytesIndicated,
                          ulReceiveFlags,
                          pvTsdu,
                          TRUE,
                          pulBytesTaken,
                          ppIoRequestPacket);
}


// -----------------------------------------------
//
// Function:   TSChainedReceiveHandler
//
// Arguments:  pvTdiEventContext -- really pointer to our AddressObject
//             Connection_Context -- really pointer to our Endpoint
//             ReceiveFlags -- nature of received data
//             ulReceiveLength --- length of data in buffer
//             ulStartingOffset     -- total length of datagram
//             pReceiveMdl        -- data buffer
//             pTsduDescriptor -- returns value for TdiReturnChainedReceives
//
// Returns:    STATUS_DATA_NOT_ACCEPTED (we didn't want data)
//             STATUS_SUCCESS (we used all data & are done with it)
//             STATUS_MORE_PROCESSING_REQUIRED -- we supplied an IRP for rest
//
// Descript:   Event handler for incoming receives on connection
//
// -----------------------------------------------

TDI_STATUS
TSChainedReceiveHandler(PVOID                pvTdiEventContext,
                        CONNECTION_CONTEXT   ConnectionContext,
                        ULONG                ulReceiveFlags,
                        ULONG                ulReceiveLength,
                        ULONG                ulStartingOffset,
                        PMDL                 pReceiveMdl,
                        PVOID                pvTsduDescriptor)
{
   PADDRESS_OBJECT   pAddressObject = (PADDRESS_OBJECT)pvTdiEventContext;
   
   if (ulDebugLevel & ulDebugShowHandlers)
   {
      DebugPrint1("\n >>>> %s\n", strFunc4);
      TSShowReceiveInfo(pAddressObject,
                        ConnectionContext,
                        ulReceiveFlags,
                        ulReceiveLength,
                        ulStartingOffset,
                        pReceiveMdl,
                        TRUE);
   }

   return TSCommonChainedReceive(pAddressObject,
                                 ulReceiveLength,
                                 ulStartingOffset,
                                 pReceiveMdl,
                                 ((ulReceiveFlags & TDI_RECEIVE_EXPEDITED) != 0),
                                 pvTsduDescriptor);
}


// -----------------------------------------------
//
// Function:   TSChainedRcvExpeditedHandler
//
// Arguments:  pvTdiEventContext -- really pointer to our AddressObject
//             Connection_Context -- really pointer to our Endpoint
//             ReceiveFlags -- nature of received data
//             ulReceiveLength --- length of data in buffer
//             ulStartingOffset     -- total length of datagram
//             pReceiveMdl        -- data buffer
//             pTsduDescriptor -- returns value for TdiReturnChainedReceives
//
// Returns:    STATUS_DATA_NOT_ACCEPTED (we didn't want data)
//             STATUS_SUCCESS (we used all data & are done with it)
//             STATUS_MORE_PROCESSING_REQUIRED -- we supplied an IRP for rest
//
// Descript:   Event handler for incoming receives on connection
//
// -----------------------------------------------


TDI_STATUS
TSChainedRcvExpeditedHandler(PVOID              pvTdiEventContext,
                             CONNECTION_CONTEXT ConnectionContext,
                             ULONG              ulReceiveFlags,
                             ULONG              ulReceiveLength,
                             ULONG              ulStartingOffset,
                             PMDL               pReceiveMdl,
                             PVOID              pvTsduDescriptor)
{
   PADDRESS_OBJECT   pAddressObject = (PADDRESS_OBJECT)pvTdiEventContext;

   if (ulDebugLevel & ulDebugShowHandlers)
   {
      DebugPrint1("\n >>>> %s\n", strFunc5);
      TSShowReceiveInfo(pAddressObject,
                        ConnectionContext,
                        ulReceiveFlags,
                        ulReceiveLength,
                        ulStartingOffset,
                        pReceiveMdl,
                        TRUE);
   }

   return TSCommonChainedReceive(pAddressObject,
                                 ulReceiveLength,
                                 ulStartingOffset,
                                 pReceiveMdl,
                                 TRUE,
                                 pvTsduDescriptor);
}


/////////////////////////////////////////////////////////////
// private functions
/////////////////////////////////////////////////////////////

// ---------------------------------------------------------
//
// Function:   TSReceiveComplete
//
// Arguments:  pDeviceObject  -- device object that called Receive/Datagram
//             pIrp           -- IRP used in the call
//             pContext       -- context used for the call
//
// Returns:    status of operation (STATUS_MORE_PROCESSING_REQUIRED)
//
// Descript:   Gets the result of the receive, stuffs result into
//             receive buffer, completes the IRP from the dll, and
//             cleans up the Irp and associated data from the receive
//
// ---------------------------------------------------------

#pragma warning(disable: UNREFERENCED_PARAM)


TDI_STATUS
TSReceiveComplete(PDEVICE_OBJECT pDeviceObject,
                  PIRP           pLowerIrp,
                  PVOID          pvContext)

{
   PRECEIVE_CONTEXT  pReceiveContext = (PRECEIVE_CONTEXT)pvContext;
   NTSTATUS          lStatus         = pLowerIrp->IoStatus.Status;
   ULONG             ulBytesCopied   = (ULONG)pLowerIrp->IoStatus.Information;
   PADDRESS_OBJECT   pAddressObject  = pReceiveContext->pAddressObject;
   PRECEIVE_DATA     pReceiveData    = pReceiveContext->pReceiveData;
                  

   if (NT_SUCCESS(lStatus))
   {
      if (ulDebugLevel & ulDebugShowCommand)
      {
         DebugPrint2("%s:  %u BytesCopied\n",
                      strFuncP1,
                      ulBytesCopied);
      }
      pReceiveData->ulBufferUsed += ulBytesCopied;
      if (pReceiveData->ulBufferUsed >= pReceiveData->ulBufferLength)
      {
         TSPacketReceived(pAddressObject,
                          pReceiveData,
                          pReceiveContext->fIsExpedited);
      }
      else
      {
         DebugPrint1("%s:  Data Incomplete\n", strFuncP1);
         TSFreeMemory(pReceiveData->pucDataBuffer);
         TSFreeMemory(pReceiveData);
      }
   }
   else
   {
      DebugPrint2("%s:  Completed with status 0x%08x\n", 
                   strFuncP1,
                   lStatus);
      TSFreeMemory(pReceiveData->pucDataBuffer);
      TSFreeMemory(pReceiveData);
   }

   //
   // now cleanup
   //
   TSFreeIrp(pLowerIrp, pAddressObject->pIrpPool);
   TSFreeBuffer(pReceiveContext->pLowerMdl);

   TSFreeMemory(pReceiveContext);

   return TDI_MORE_PROCESSING;
}

#pragma warning(default: UNREFERENCED_PARAM)


// ---------------------------------
//
// Function:   TSShowReceiveInfo
//
// Arguments:  pAddressObject -- the address object associated with this endpoint
//             ConnectionContext -- endpoint of this connection
//             ulReceiveFlags -- info about the receive
//             ulBytesIndicated -- bytes indicated up
//             ulBytesAvailable -- total bytes (or starting offset)
//             pvTsdu  -- ptr to the data (or to its mdl)
//             fIsChained -- if TRUE, then this is chained receive
//
// Returns:    none
//
// Descript:   shows info passed to receive handler
//
// --------------------------------

VOID
TSShowReceiveInfo(PADDRESS_OBJECT      pAddressObject,
                  CONNECTION_CONTEXT   ConnectionContext,
                  ULONG                ulReceiveFlags,
                  ULONG                ulBytesIndicated,
                  ULONG                ulBytesAvailable,
                  PVOID                pvTsdu,
                  BOOLEAN              fIsChained)
{
   DebugPrint3("pAddressObject = %p\n"
               "pEndpoint      = %p\n"
               "ulReceiveFlags = 0x%08x\n",
                pAddressObject,
                ConnectionContext,
                ulReceiveFlags);

   if (ulReceiveFlags & TDI_RECEIVE_NORMAL)
   {
      DebugPrint0("                  TDI_RECEIVE_NORMAL\n");
   }
   
   if (ulReceiveFlags & TDI_RECEIVE_EXPEDITED)
   {
      DebugPrint0("                  TDI_RECEIVE_EXPEDITED\n");
   }
   
   if (ulReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE)
   {
      DebugPrint0("                  TDI_RECEIVE_ENTIRE_MESSAGE\n");
   }
   
   if (ulReceiveFlags & TDI_RECEIVE_AT_DISPATCH_LEVEL)
   {
      DebugPrint0("                  TDI_RECEIVE_AT_DISPATCH_LEVEL\n");
   }
   
   if (fIsChained)
   {
      DebugPrint3("ReceiveLength  = %u\n"
                  "StartingOffset = 0x%08x\n"
                  "pMdl           = %p\n",
                   ulBytesIndicated,
                   ulBytesAvailable,
                   pvTsdu);
   }
   else
   {
      DebugPrint3("BytesIndicated = %u\n"
                  "TotalBytes     = %u\n"
                  "pDataBuffer    = %p\n",
                   ulBytesIndicated,
                   ulBytesAvailable,
                   pvTsdu);
   }
}


// ------------------------------------------------------
//
// Function:   TSGetRestOfData
//
// Arguments:  pAddressObject -- address object we are receiving on
//             pReceiveData   -- what we have received so far..
//
// Returns:    Irp to return to transport, to get rest of data (NULL if error)
//
// Descript:   This function sets up the IRP to get the rest of a datagram
//             that was only partially delivered via the event handler
//
// -------------------------------------------------

PIRP
TSGetRestOfData(PADDRESS_OBJECT  pAddressObject,
                PRECEIVE_DATA    pReceiveData,
                BOOLEAN          fIsExpedited)

{
   PUCHAR            pucDataBuffer   = pReceiveData->pucDataBuffer + pReceiveData->ulBufferUsed;
   ULONG             ulBufferLength  = pReceiveData->ulBufferLength - pReceiveData->ulBufferUsed;
   PRECEIVE_CONTEXT  pReceiveContext = NULL;
   PMDL              pReceiveMdl     = NULL;
   

   //
   // allocate all the necessary structures
   // our context
   //
   if ((TSAllocateMemory((PVOID *)&pReceiveContext,
                          sizeof(RECEIVE_CONTEXT),
                          strFuncP3,
                          "ReceiveContext")) != STATUS_SUCCESS)
   {
      goto cleanup;
   }


   //
   // then the actual mdl
   //
   pReceiveMdl = TSAllocateBuffer(pucDataBuffer, 
                                  ulBufferLength);

   if (pReceiveMdl)
   {
      //
      // set up the completion context
      //
      pReceiveContext->pLowerMdl      = pReceiveMdl;
      pReceiveContext->pReceiveData   = pReceiveData;
      pReceiveContext->pAddressObject = pAddressObject;
      pReceiveContext->fIsExpedited   = fIsExpedited;

      //
      // finally, the irp itself
      //
      PIRP  pLowerIrp = TSAllocateIrp(pAddressObject->pEndpoint->GenHead.pDeviceObject,
                                      pAddressObject->pIrpPool);

      if (pLowerIrp)
      {
         //
         // if made it to here, everything is correctly allocated
         // set up the irp for the call
         //
#pragma  warning(disable: CONSTANT_CONDITIONAL)

         TdiBuildReceive(pLowerIrp,
                         pAddressObject->pEndpoint->GenHead.pDeviceObject,
                         pAddressObject->pEndpoint->GenHead.pFileObject,
                         TSReceiveComplete,
                         pReceiveContext,
                         pReceiveMdl,
                         TDI_RECEIVE_NORMAL,
                         ulBufferLength);

#pragma  warning(default: CONSTANT_CONDITIONAL)

         return pLowerIrp;
      }
   }

//
// get here if there was an allocation failure
// need to clean up everything else...
//
cleanup:
   if (pReceiveContext)
   {
      TSFreeMemory(pReceiveContext);
   }
   if (pReceiveMdl)
   {
      TSFreeBuffer(pReceiveMdl);
   }
   return NULL;
}




// ---------------------------------------------
//
// Function:   TSCommonReceive
//
// Arguments:  see TSReceiveHandler
//
// Returns:    status to return to protocol
//
// Descript:   Common code for TSReceiveHandler and 
//             TSRcvExpeditedHandler.  Pretty much all the work is
//             done here
//
// ---------------------------------------------


TDI_STATUS
TSCommonReceive(PADDRESS_OBJECT  pAddressObject,
                ULONG            ulBytesTotal,
                ULONG            ulBytesIndicated,
                ULONG            ulReceiveFlags,
                PVOID            pvTsdu,
                BOOLEAN          fIsExpedited,
                PULONG           pulBytesTaken,
                PIRP             *pIoRequestPacket)
{
   //
   // check for a bad condition -- more bytes indicated that total
   //
   if (ulBytesIndicated > ulBytesTotal)
   {
      DebugPrint2("%u bytes indicated > %u bytes total\n",
                   ulBytesIndicated,
                   ulBytesTotal);
      return TDI_NOT_ACCEPTED;
   }


   PRECEIVE_DATA  pReceiveData;

   if ( (TSAllocateMemory((PVOID *)&pReceiveData,
                           sizeof(RECEIVE_DATA),
                           strFuncP4,
                           "ReceiveData")) == STATUS_SUCCESS)
   {
      PUCHAR   pucDataBuffer = NULL;
         
      if ((TSAllocateMemory((PVOID *)&pucDataBuffer,
                             ulBytesTotal,
                             strFuncP4,
                             "DataBuffer")) == STATUS_SUCCESS)
      {
         pReceiveData->pucDataBuffer = pucDataBuffer;
         pReceiveData->ulBufferLength = ulBytesTotal;
      }
      else
      {
         TSFreeMemory(pReceiveData);
         return TDI_NOT_ACCEPTED;
      }
   }
   else
   {
      return TDI_NOT_ACCEPTED;
   }

   //
   // copy the data indicated to us into the buffer
   //
   TdiCopyLookaheadData(pReceiveData->pucDataBuffer,
                        pvTsdu,
                        ulBytesIndicated,
                        ulReceiveFlags);
         
   pReceiveData->ulBufferUsed = ulBytesIndicated;

   //
   // first case -- entire packet indicated to us
   //
   if (ulBytesIndicated == ulBytesTotal)
   {
      TSPacketReceived(pAddressObject,
                       pReceiveData,
                       fIsExpedited);

      *pulBytesTaken    = ulBytesTotal;
      *pIoRequestPacket = NULL;
      return TDI_SUCCESS;
   }

   //
   // second case -- only part of data indicated up
   //
   else
   {
      PIRP  pLowerIrp = TSGetRestOfData(pAddressObject,
                                        pReceiveData,
                                        fIsExpedited);

      if (pLowerIrp)
      {
         //
         // need to do this since we are bypassing IoCallDriver
         //
         IoSetNextIrpStackLocation(pLowerIrp);
         
         *pulBytesTaken    = ulBytesIndicated;
         *pIoRequestPacket = pLowerIrp;
         return TDI_MORE_PROCESSING;
      }
      else
      {
         DebugPrint1("%s:  unable to get rest of packet\n", strFuncP4);
         TSFreeMemory(pReceiveData->pucDataBuffer);
         TSFreeMemory(pReceiveData);
         return TDI_NOT_ACCEPTED;
      }
   }
}


// ---------------------------------------------
//
// Function:   TSCommonChainedReceive
//
// Arguments:  see TStChainedRcvhandler
//
// Returns:    status
//
// Descript:   Common code for TSChainedReceiveHandler and 
//             TSChainedRcvExpeditedHandler.  Pretty much all the work is
//             done here
//
// ---------------------------------------------

TDI_STATUS
TSCommonChainedReceive(PADDRESS_OBJECT pAddressObject,
                       ULONG           ulReceiveLength,
                       ULONG           ulStartingOffset,
                       PMDL            pReceiveMdl,
                       BOOLEAN         fIsExpedited,
                       PVOID           pvTsduDescriptor)
{
   PRECEIVE_DATA  pReceiveData;


   if ((TSAllocateMemory((PVOID *)&pReceiveData,
                          sizeof(RECEIVE_DATA),
                          strFuncP5,
                          "ReceiveData")) == STATUS_SUCCESS)
   {
      PUCHAR   pucDataBuffer;
      
      if((TSAllocateMemory((PVOID *)&pucDataBuffer,
                            ulReceiveLength,
                            strFuncP5,
                            "DataBuffer")) == STATUS_SUCCESS)
      {
         ULONG ulBytesCopied;

         TdiCopyMdlToBuffer(pReceiveMdl,
                            ulStartingOffset,
                            pucDataBuffer,
                            0,
                            ulReceiveLength,
                            &ulBytesCopied);

         //
         // if successfully copied all data
         //
         if (ulBytesCopied == ulReceiveLength)
         {
            pReceiveData->pucDataBuffer  = pucDataBuffer;
            pReceiveData->ulBufferLength = ulReceiveLength;
            pReceiveData->ulBufferUsed   = ulReceiveLength;
            TSPacketReceived(pAddressObject,
                             pReceiveData,
                             fIsExpedited);

            return TDI_SUCCESS;
         }

         //
         // error in copying data!
         //
         else
         {
            DebugPrint1("%s: error copying data\n", strFuncP5);
            TSFreeMemory(pucDataBuffer);
            TSFreeMemory(pReceiveData);
         }
      }
      else        // unable to allocate pucDataBuffer
      {
         TSFreeMemory(pReceiveData);
      }
   }
   return TDI_NOT_ACCEPTED;
}


///////////////////////////////////////////////////////////////////////////////
// end of file receive.cpp
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\lib\utils.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       utils.cpp
//
//    Abstract:
//       This module contains general utility functions.
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"


// ---------------------------------------------------------
//
// Function:   TdiLibStatusMessage
//
// Arguments:  ulGeneralStatus -- NTSTATUS value to search
//
// Returns:    String with message to print
//
// Descript:   This function finds and returns a string corresponding
//             to the status passed in..
//
// ----------------------------------------------------------


TCHAR *
TdiLibStatusMessage(NTSTATUS  lStatus)

{
   static TCHAR   UnknownMess[64];
   TCHAR          *Message;

   switch(lStatus)
   {
      case STATUS_SUCCESS:
         Message = TEXT("STATUS_SUCCESS");
         break;
      case STATUS_UNSUCCESSFUL:
         Message = TEXT("STATUS_UNSUCCESSFUL");
         break;
      case STATUS_NOT_IMPLEMENTED:
         Message = TEXT("STATUS_NOT_IMPLEMENTED");
         break;
      case STATUS_INVALID_HANDLE:
         Message = TEXT("STATUS_INVALID_HANDLE");
         break;
      case STATUS_INVALID_PARAMETER:
         Message = TEXT("STATUS_INVALID_PARAMETER");
         break;
      case STATUS_INVALID_DEVICE_REQUEST:
         Message = TEXT("STATUS_INVALID_DEVICE_REQUEST");
         break;
      case STATUS_INSUFFICIENT_RESOURCES:
         Message = TEXT("STATUS_INSUFFICIENT_RESOURCES");
         break;
      case STATUS_NOT_SUPPORTED:
         Message = TEXT("STATUS_NOT_SUPPORTED");
         break;
      case STATUS_BUFFER_OVERFLOW:
         Message = TEXT("STATUS_BUFFER_OVERFLOW");
         break;
      case STATUS_PENDING:
         Message = TEXT("STATUS_PENDING");
         break;
      case STATUS_CONNECTION_REFUSED:
         Message = TEXT("STATUS_CONNECTION_REFUSED");
         break;
      case STATUS_GRACEFUL_DISCONNECT:
         Message = TEXT("STATUS_GRACEFUL_DISCONNECT");
         break;
      case STATUS_ADDRESS_ALREADY_ASSOCIATED:
         Message = TEXT("STATUS_ADDRESS_ALREADY_ASSOCIATED");
         break;
      case STATUS_ADDRESS_NOT_ASSOCIATED:
         Message = TEXT("STATUS_ADDRESS_NOT_ASSOCIATED");
         break;
      case STATUS_INVALID_CONNECTION:
         Message = TEXT("STATUS_INVALID_CONNECTION");
         break;
      case STATUS_CONNECTION_INVALID:
         Message = TEXT("STATUS_CONNECTION_INVALID");
         break;
      case STATUS_CONNECTION_DISCONNECTED:
         Message = TEXT("STATUS_CONNECTION_DISCONNECTED");
         break;
      case STATUS_INVALID_ADDRESS_COMPONENT:
         Message = TEXT("STATUS_INVALID_ADDRESS_COMPONENT");
         break;
      case STATUS_LOCAL_DISCONNECT:
         Message = TEXT("STATUS_LOCAL_DISCONNECT");
         break;
      case STATUS_LINK_TIMEOUT:
         Message = TEXT("STATUS_LINK_TIMEOUT");
         break;
      case STATUS_IO_TIMEOUT:
         Message = TEXT("STATUS_IO_TIMEOUT");
         break;
      case STATUS_REMOTE_NOT_LISTENING:
         Message = TEXT("STATUS_REMOTE_NOT_LISTENING");
         break;
      case STATUS_BAD_NETWORK_PATH:
         Message = TEXT("STATUS_BAD_NETWORK_PATH");
         break;

      case TDI_STATUS_TIMEDOUT:
         Message = TEXT("TDI_STATUS_TIMEDOUT");
         break;
      default:
         _stprintf(UnknownMess, TEXT("STATUS_UNKNOWN [0x%x]"), lStatus);
         Message = UnknownMess;
         break;
   };

   return Message;
}


// ---------------------------------------------------------
//
// Function:   DoPrintAddress
//
// Arguments:  pTransportAddress -- address to print
//
// Returns:    none
//
// Descript:   This function prints the address information
//             of the address passed in
//
// ----------------------------------------------------------

VOID
DoPrintAddress(PTRANSPORT_ADDRESS   pTransportAddress)
{
   switch(pTransportAddress->Address[0].AddressType)
   {      
      case TDI_ADDRESS_TYPE_IP:
      {
         PTDI_ADDRESS_IP   pTdiAddressIp
                           = (PTDI_ADDRESS_IP)pTransportAddress->Address[0].Address;
         PUCHAR            pucTemp
                           = (PUCHAR)&pTdiAddressIp->in_addr;

         _tprintf(TEXT("TDI_ADDRESS_TYPE_IP\n")
                  TEXT("sin_port = 0x%04x\n")
                  TEXT("in_addr  = %u.%u.%u.%u\n"),
                  pTdiAddressIp->sin_port,
                  pucTemp[0], pucTemp[1],
                  pucTemp[2], pucTemp[3]);
      }
      break;

      case TDI_ADDRESS_TYPE_IPX:
      {
         PTDI_ADDRESS_IPX  pTdiAddressIpx
                           = (PTDI_ADDRESS_IPX)pTransportAddress->Address[0].Address;

         _tprintf(TEXT("TDI_ADDRESS_TYPE_IPX\n")
                  TEXT("NetworkAddress = 0x%08x\n")
                  TEXT("NodeAddress    = %u.%u.%u.%u.%u.%u\n")
                  TEXT("Socket         = 0x%04x\n"),
                  pTdiAddressIpx->NetworkAddress,
                  pTdiAddressIpx->NodeAddress[0],
                  pTdiAddressIpx->NodeAddress[1],
                  pTdiAddressIpx->NodeAddress[2],
                  pTdiAddressIpx->NodeAddress[3],
                  pTdiAddressIpx->NodeAddress[4],
                  pTdiAddressIpx->NodeAddress[5],
                  pTdiAddressIpx->Socket);
      }
      break;

      case TDI_ADDRESS_TYPE_NETBIOS:
      {
         PTDI_ADDRESS_NETBIOS pTdiAddressNetbios
                              = (PTDI_ADDRESS_NETBIOS)pTransportAddress->Address[0].Address;
         TCHAR                pucName[17];

         //
         // make sure we have a zero-terminated name to print...
         //
         memcpy(pucName, pTdiAddressNetbios->NetbiosName, 16 * sizeof(TCHAR));
         pucName[16] = 0;
            
         _putts(TEXT("TDI_ADDRESS_TYPE_NETBIOS\n")
                TEXT("NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_"));
       
         switch (pTdiAddressNetbios->NetbiosNameType)
         {
            case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE:
               _putts(TEXT("UNIQUE\n"));
               break;
            case TDI_ADDRESS_NETBIOS_TYPE_GROUP:
               _putts(TEXT("GROUP\n"));
               break;
            case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE:
               _putts(TEXT("QUICK_UNIQUE\n"));
               break;
            case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP:
               _putts(TEXT("QUICK_GROUP\n"));
               break;
            default:
               _tprintf(TEXT("INVALID [0x%04x]\n"),
                        pTdiAddressNetbios->NetbiosNameType);
               break;
         }
         _tprintf(TEXT("NetbiosName = %s\n"), pucName);
      }
      break;
      
   }

}


// -----------------------------------------------------------------
//
// Function:   TdiLibDeviceIO
//
// Arguments:  ulCommandCode -- command code of operation to perform
//             pSendBuffer   -- data structure containing arguments for driver
//             pReceiveBuffer-- data structure containing return values from
//                              driver
//             NOTE:  all are passed thru unchanged to DeviceIoControl
//
// Returns:    Final status of operation -- STATUS_SUCCESS or failure code
//
// Descript:   This function acts as a "wrapper" for DeviceIoControl, and is
//             used by those functions that really want a synchronous call,
//             but don't want to be hung up in the driver.  If a call to
//             DeviceIoControl pends, this function waits for up to a minute
//             for it to complete.  If it doesn't complete within a minute,
//             it assumes something is drastically wrong and returns a time-
//             out error.  If a function completes before then, it gets the
//             final completion code and returns that.  Hence,
//             STATUS_PENDING should never be returned by this function.
//
// Status:     ok
//
// -----------------------------------------------------------------


NTSTATUS
TdiLibDeviceIO(ULONG             ulCommandCode,
               PSEND_BUFFER      pSendBuffer,
               PRECEIVE_BUFFER   pReceiveBuffer)

{
   NTSTATUS    lStatus;          // final status from command
   OVERLAPPED  *pOverLapped      // structure for asynchronous completion
               = (OVERLAPPED *)LocalAllocateMemory(sizeof(OVERLAPPED));

   //
   // create the event to wait on
   //
   pOverLapped->hEvent = CreateEvent(NULL,    // non-inheritable
                                     TRUE,    // manually signalled
                                     TRUE,    // initially signalled
                                     NULL);   // un-named

   //
   // need the event object to do asynchronous calls
   //
   if (pOverLapped->hEvent != NULL)
   {
      pOverLapped->Offset = 0;
      pOverLapped->OffsetHigh = 0;

      lStatus = TdiLibStartDeviceIO(ulCommandCode,
                                    pSendBuffer,
                                    pReceiveBuffer,
                                    pOverLapped);

      if (lStatus == STATUS_PENDING)
      {
         ULONG    ulTimeOut = 60;      // 60 seconds

         for (;;)
         {
            lStatus = TdiLibWaitForDeviceIO(pOverLapped);
            if (lStatus == STATUS_SUCCESS)
            {
               lStatus = pReceiveBuffer->lStatus;
               break;
            }
            else if (lStatus == TDI_STATUS_TIMEDOUT)
            {
               if (--ulTimeOut == 0)
               {
                  SEND_BUFFER    SendBuffer;
                  RECEIVE_BUFFER ReceiveBuffer;

                  TdiLibDeviceIO(ulABORT_COMMAND,
                                 &SendBuffer,
                                 &ReceiveBuffer);

                  ulTimeOut = 60;
               }
            }
            else  // some type of error case
            {
               lStatus = STATUS_UNSUCCESSFUL;
               break;
            }
         }
      }
      CloseHandle(pOverLapped->hEvent);
   }

   //
   // get here if CreateEvent failed
   //
   else
   {
      OutputDebugString(TEXT("TdiLibDeviceIo:  CreateEvent failed\n"));
      lStatus = STATUS_UNSUCCESSFUL;
   }

   if (lStatus != TDI_STATUS_TIMEDOUT)
   {
      LocalFreeMemory(pOverLapped);
   }
   if (lStatus == STATUS_SUCCESS)
   {
      lStatus = pReceiveBuffer->lStatus;
   }
   return lStatus;
}


// -----------------------------------------------------------------
//
// Function:   TdiLibStartDeviceIO
//
// Arguments:  ulCommandCode -- control code of operation to perform
//             pSendBuffer   -- data structure containing arguments for driver
//             pReceiveBuffer-- data structure containing return values from
//                              driver
//             pOverlapped   -- overlapped structure
//             NOTE:  all are passed thru unchanged to DeviceIoControl
//
// Returns:    Status of operation -- STATUS_PENDING, STATUS_SUCCESS, or failure code
//
// Descript:   This function acts as a "wrapper" for DeviceIoControl, and is
//             used by those functions that need an asynchronous call.  It
//             is used in association with  TdiWaitForDeviceIO (which
//             checks to see if it is complete)
//
// Status:     ok
//
// -----------------------------------------------------------------


NTSTATUS
TdiLibStartDeviceIO(ULONG           ulCommandCode,
                    PSEND_BUFFER    pSendBuffer,
                    PRECEIVE_BUFFER pReceiveBuffer,
                    OVERLAPPED      *pOverLapped)

{
   NTSTATUS lStatus;             // final status...
   ULONG    ulBytesReturned;     // bytes stored in OutBuffer
   ULONG    fResult;             // immediate result of DeviceIoControl

   //
   // following call to the driver will return TRUE on SUCCESS_SUCCESS,
   // FALSE on everything else
   //
   EnterCriticalSection(&LibCriticalSection);
   fResult = DeviceIoControl(hTdiSampleDriver,
                             ulTdiCommandToIoctl(ulCommandCode),
                             pSendBuffer,
                             sizeof(SEND_BUFFER),
                             pReceiveBuffer,
                             sizeof(RECEIVE_BUFFER),
                             &ulBytesReturned,
                             pOverLapped);
   LeaveCriticalSection(&LibCriticalSection);

   if (!fResult)
   {
      lStatus = GetLastError();
      if (lStatus != ERROR_IO_PENDING)
      {
         OutputDebugString(TEXT("TdiLibStartDeviceIO: DeviceIoControl failed!\n"));
         return STATUS_UNSUCCESSFUL;
      }
      return STATUS_PENDING;
   }

   //
   // gets to here if DeviceIoControl returned SUCCESS
   //
   return STATUS_SUCCESS;
}

// ----------------------------------------------------------------
//
//    Function:   TdiLibWaitForDeviceIO
//
//    Arguments:  hEvent -- event handle associated with asynchronous
//                          deviceio
//                pOverlapped -- overlap structure (so we can get at results)
//
//    Returns:    final ntstatus of asynchronous operation
//
//    Descript:   This function is used to wait for the completion of an
//                asynchronous deviceio call started by TdiStartDeviceIO
//
//    Status:     ok
//
// ----------------------------------------------------------------


const ULONG ulONE_SECOND   = 1000;        // milliseconds in a second

NTSTATUS
TdiLibWaitForDeviceIO(OVERLAPPED *pOverLapped)

{
   NTSTATUS lStatus;             // final status
   ULONG    ulBytesReturned;     // bytes written to outputbuffer

   //
   // DeviceIoControl in TdiStartDeviceIO pended.
   // Will wait for 1 second before timing out....
   //
   lStatus = WaitForSingleObject(pOverLapped->hEvent, ulONE_SECOND);
   if (lStatus == WAIT_OBJECT_0)
   {
      if (GetOverlappedResult(hTdiSampleDriver,
                              pOverLapped,
                              &ulBytesReturned,
                              TRUE))
      {
         return STATUS_SUCCESS;
      }
      else     // unexpected error case
      {
         OutputDebugString(TEXT("TdiLibWaitForDeviceIO: Pended DeviceIoControl failed\n"));
      }
   }
   else if (lStatus == WAIT_TIMEOUT)
   {
      return TDI_STATUS_TIMEDOUT;
   }
   //
   // unexpected return from WaitForSingleObject.  Assume an error
   //
   else
   {
      OutputDebugString(TEXT("TdiLibWaitForDeviceIO: Pended DeviceIoControl had an error..\n"));
   }
   return STATUS_UNSUCCESSFUL;
}


////////////////////////////////////////////////////////////////////////////
// end of file utils.cpp
////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\recvcom.cpp ===
/////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       recvcom
//
//    Abstract:
//       This module contains some common (shared) receive code
//
//////////////////////////////////////////////////////////


#include "sysvars.h"



//////////////////////////////////////////////////////////////
// private constants, types, and prototypes
//////////////////////////////////////////////////////////////

const PCHAR strFunc1 = "TSPacketReceived";
//const PCHAR strFunc2 = "TSFreePacketData";
const PCHAR strFunc3 = "TSMakeMdlForUserBuffer";

//////////////////////////////////////////////////////////////
// public functions
//////////////////////////////////////////////////////////////


// ------------------------------------------
//
// Function:   TSPacketReceived
//
// Arguments:  pAddressObject    -- current address object
//             pReceiveData      -- receive data structure
//             fIsExpedited      -- TRUE if an expedited receive
//
// Returns:    none
//
// Descript:   This function accepts a packet which has been completely
//             received, and deals with it as appropriate for the
//             packets type
//
// ------------------------------------------------

VOID
TSPacketReceived(PADDRESS_OBJECT pAddressObject,
                 PRECEIVE_DATA   pReceiveData,
                 BOOLEAN         fIsExpedited)
{
   TSAcquireSpinLock(&pAddressObject->TdiSpinLock);

   //
   // expedited receives go on expedited list
   // (expedited is only with connected)
   //
   if (fIsExpedited)
   {
      if (pAddressObject->pTailRcvExpData)
      {
         pAddressObject->pTailRcvExpData->pNextReceiveData = pReceiveData;
         pReceiveData->pPrevReceiveData = pAddressObject->pTailRcvExpData;
      }
      else
      {
         pAddressObject->pHeadRcvExpData = pReceiveData;
      }
      pAddressObject->pTailRcvExpData = pReceiveData;
   }
   
   //
   // normal connection receive and all datagram receive
   //
   else
   {
      if (pAddressObject->pTailReceiveData)
      {
         pAddressObject->pTailReceiveData->pNextReceiveData = pReceiveData;
         pReceiveData->pPrevReceiveData = pAddressObject->pTailReceiveData;
      }
      else
      {
         pAddressObject->pHeadReceiveData = pReceiveData;
      }
      pAddressObject->pTailReceiveData = pReceiveData;
   }
   TSReleaseSpinLock(&pAddressObject->TdiSpinLock);
}

// ---------------------------------------------------
//
// Function:   TSFreePacketData
//
// Arguments:  pAddressObject -- current address object
//
// Returns:    none
//
// Descript:   This function cleans up any received data still on
//             the address object prior to its shutting down
//             This is called when closing an address object that was
//             used for receiving datagrams OR that was involved in a
//             connection
//
// ---------------------------------------------------


VOID
TSFreePacketData(PADDRESS_OBJECT pAddressObject)
{
   PRECEIVE_DATA  pReceiveData;

   TSAcquireSpinLock(&pAddressObject->TdiSpinLock);
   pReceiveData = pAddressObject->pHeadReceiveData;
   pAddressObject->pHeadReceiveData = NULL;
   pAddressObject->pTailReceiveData = NULL;
   TSReleaseSpinLock(&pAddressObject->TdiSpinLock);

   while (pReceiveData)
   {
      PRECEIVE_DATA  pNextReceiveData
                     = pReceiveData->pNextReceiveData;

      TSFreeMemory(pReceiveData->pucDataBuffer);
      TSFreeMemory(pReceiveData);

      pReceiveData = pNextReceiveData;
   }
}


// -------------------------------------------------
//
// Function:   TSMakeMdlForUserBuffer
//
// Arguments:  pucDataBuffer -- address of user buffer
//             ulDataLength  -- length of user buffer
//             ProcessorMode -- mode to do probe in?
//             IoAccessMode  -- type of access required
//
// Returns:    pMdl if successful, NULL if exception occurred
//
// Descript:   Creates mdl and locks user mode memory
//
// -------------------------------------------------


PMDL
TSMakeMdlForUserBuffer(PUCHAR pucDataBuffer, 
                       ULONG  ulDataLength,
                       LOCK_OPERATION AccessType)
{
   PMDL  pMdl = IoAllocateMdl(pucDataBuffer,
                              ulDataLength,
                              FALSE,
                              FALSE,
                              NULL);
   if (pMdl)
   {           
      __try 
      {
         MmProbeAndLockPages(pMdl,
                             KernelMode,
                             AccessType);

         PUCHAR   pucBuffer = (PUCHAR)MmGetSystemAddressForMdl(pMdl);
         if (pucBuffer == NULL)
         {
            DebugPrint1("%s:  MmProbeAndLockPages failed\n",
                         strFunc3);
            MmUnlockPages(pMdl);
            IoFreeMdl(pMdl);
            pMdl = NULL;
         }
      } 
      __except(EXCEPTION_EXECUTE_HANDLER) 
      {
         NTSTATUS lStatus = GetExceptionCode();
         DebugPrint2("%s:  Exception %x.\n", 
                      strFunc3,
                      lStatus);
         IoFreeMdl(pMdl);
         pMdl = NULL;
      }
   }

   return pMdl;
}

///////////////////////////////////////////////////////////////////////////////
// end of file recvcom.cpp
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\events.cpp ===
/////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       events.cpp
//
//    Abstract:
//       This module contains code which sets/clears the event handlers
//
//////////////////////////////////////////////////////////


#include "sysvars.h"

//////////////////////////////////////////////////////////////
// private constants, types, and prototypes
//////////////////////////////////////////////////////////////

const PCHAR strFunc1  = "TSSetEventHandler";
const PCHAR strFuncP1 = "TSSetEventComplete";

//
// information necessary to complete the command
//
struct   EVENT_CONTEXT
{
   PIRP  pUpperIrp;           // irp from dll to complete
};
typedef  EVENT_CONTEXT  *PEVENT_CONTEXT;


//
// completion function
//
TDI_STATUS
TSSetEventComplete(
   PDEVICE_OBJECT DeviceObject,
   PIRP           Irp,
   PVOID          Context
   );

//
// dummy event handlers
//
TDI_STATUS
TSErrorHandler(
   PVOID       pvTdiEventContext,
   TDI_STATUS  lStatus
   );


TDI_STATUS
TSSendPossibleHandler(
   PVOID       pvTdiEventContext,
   PVOID       pvConnectionContext,
   ULONG       ulBytesAvailable
   );


TDI_STATUS
TSErrorExHandler(
   PVOID       pvTdiEventContext,
   TDI_STATUS  lStatus,
   PVOID       pvBuffer
   );


//////////////////////////////////////////////////////////////
// public functions
//////////////////////////////////////////////////////////////


// -----------------------------------------------------------------
//
// Function:   TSSetEventHandler
//
// Arguments:  pAddressObject -- our address object structure
//             pSendBuffer    -- arguments from user dll
//             pIrp           -- completion information
//
// Returns:    NTSTATUS (normally pending)
//
// Descript:   This function enables or disables event handlers
//
// -------------------------------------------------------------------------------------------

NTSTATUS
TSSetEventHandler(PGENERIC_HEADER   pGenericHeader,
                  PSEND_BUFFER      pSendBuffer,
                  PIRP              pUpperIrp)
{
   ULONG             ulEventId   = pSendBuffer->COMMAND_ARGS.ulEventId;
   PADDRESS_OBJECT   pAddressObject;


   if (pGenericHeader->ulSignature == ulEndpointObject)
   {
      PENDPOINT_OBJECT  pEndpoint = (PENDPOINT_OBJECT)pGenericHeader;

      pAddressObject = pEndpoint->pAddressObject;
   }
   else
   {
      pAddressObject = (PADDRESS_OBJECT)pGenericHeader;
   }

   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint2("\nCommand = ulSETEVENTHANDLER\n"
                  "AddressObject = %p\n"
                  "EventId       = 0x%08x\n",
                   pAddressObject,
                   ulEventId);
   }

   //
   // allocate all the necessary structures
   //
   PEVENT_CONTEXT pEventContext = NULL;
   
   //
   // first, our context
   //
   if ((TSAllocateMemory((PVOID *)&pEventContext,
                          sizeof(EVENT_CONTEXT),
                          strFunc1,
                          "EventContext")) != STATUS_SUCCESS)
   {
      goto cleanup;
   }

   //
   // then the irp itself
   //
   PIRP  pLowerIrp = TSAllocateIrp(pAddressObject->GenHead.pDeviceObject,
                                   NULL);
   if (pLowerIrp)
   {
      PVOID    pvEventContext = pAddressObject;
      PVOID    pvEventHandler = NULL;
      BOOLEAN  fNeedIrpPool   = FALSE;

      switch (ulEventId)
      {
         case TDI_EVENT_CONNECT:
            pvEventHandler = (PVOID)TSConnectHandler;
            fNeedIrpPool   = TRUE;
            break;
         case TDI_EVENT_DISCONNECT:
            pvEventHandler = (PVOID)TSDisconnectHandler;
            fNeedIrpPool   = TRUE;
            break;
         case TDI_EVENT_ERROR:
            pvEventHandler = (PVOID)TSErrorHandler;
            break;
         case TDI_EVENT_RECEIVE:
            fNeedIrpPool   = TRUE;
            pvEventHandler = (PVOID)TSReceiveHandler;
            break;
         case TDI_EVENT_RECEIVE_DATAGRAM:
            fNeedIrpPool   = TRUE;
            pvEventHandler = (PVOID)TSRcvDatagramHandler;
            break;
         case TDI_EVENT_RECEIVE_EXPEDITED:
            fNeedIrpPool   = TRUE;
            pvEventHandler = (PVOID)TSRcvExpeditedHandler;
            break;
         case TDI_EVENT_SEND_POSSIBLE:
            pvEventHandler = (PVOID)TSSendPossibleHandler;
            break;
         case TDI_EVENT_CHAINED_RECEIVE:
            pvEventHandler = (PVOID)TSChainedReceiveHandler;
            break;
         case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:
            pvEventHandler = (PVOID)TSChainedRcvDatagramHandler;
            break;
         case TDI_EVENT_CHAINED_RECEIVE_EXPEDITED:
            pvEventHandler = (PVOID)TSChainedRcvExpeditedHandler;
            break;
         case TDI_EVENT_ERROR_EX:
            pvEventHandler = (PVOID)TSErrorExHandler;
            break;
      }

      //
      // if need to have irp pool for the handler, make sure that there
      // is one allocated..
      //
      if ((!pAddressObject->pIrpPool) && fNeedIrpPool)
      {
         pAddressObject->pIrpPool 
                        = TSAllocateIrpPool(pAddressObject->GenHead.pDeviceObject,
                                            ulIrpPoolSize);
      }
      
      //
      // if made it to here, everything is correctly allocated
      // set up irp and call the tdi provider
      //
      pEventContext->pUpperIrp = pUpperIrp;

#pragma  warning(disable: CONSTANT_CONDITIONAL)

      TdiBuildSetEventHandler(pLowerIrp,
                              pAddressObject->GenHead.pDeviceObject,
                              pAddressObject->GenHead.pFileObject,
                              TSSetEventComplete,
                              pEventContext,
                              ulEventId,
                              pvEventHandler,
                              pvEventContext);

#pragma  warning(default: CONSTANT_CONDITIONAL)
      //
      // make the call to the tdi provider
      //
      pSendBuffer->pvLowerIrp = pLowerIrp;   // so command can be cancelled

      NTSTATUS lStatus = IoCallDriver(pAddressObject->GenHead.pDeviceObject,
                                      pLowerIrp);

      if (((!NT_SUCCESS(lStatus)) && ulDebugLevel & ulDebugShowCommand))
      {
         DebugPrint2("%s: unexpected status for IoCallDriver [0x%08x]\n", 
                      strFunc1,
                      lStatus);
      }
      return STATUS_PENDING;
   }


//
// get here if an allocation error occurred
//
cleanup:
   if (pEventContext)
   {
      TSFreeMemory(pEventContext);
   }
   return STATUS_INSUFFICIENT_RESOURCES;
}


/////////////////////////////////////////////////////////////
// private functions
/////////////////////////////////////////////////////////////

// ---------------------------------------------------------
//
// Function:   TSSetEventComplete
//
// Arguments:  pDeviceObject  -- device object that called tdiquery
//             pIrp           -- IRP used in the call
//             pContext       -- context used for the call
//
// Returns:    status of operation (STATUS_MORE_PROCESSING_REQUIRED)
//
// Descript:   Gets the result of the setevent, stuffs results into
//             receive buffer, completes the IRP from the dll, and
//             cleans up the Irp and associated data from the setevent
//
// ---------------------------------------------------------

#pragma warning(disable: UNREFERENCED_PARAM)

TDI_STATUS
TSSetEventComplete(PDEVICE_OBJECT   pDeviceObject,
                   PIRP             pLowerIrp,
                   PVOID            pvContext)
{
   PEVENT_CONTEXT    pEventContext  = (PEVENT_CONTEXT)pvContext;
   NTSTATUS          lStatus        = pLowerIrp->IoStatus.Status;
   PRECEIVE_BUFFER   pReceiveBuffer = TSGetReceiveBuffer(pEventContext->pUpperIrp);

   pReceiveBuffer->lStatus = lStatus;

   if (ulDebugLevel & ulDebugShowCommand)
   {
      if (NT_SUCCESS(lStatus))
      {
         if (pLowerIrp->IoStatus.Information)
         {
            DebugPrint2("%s:  Information = 0x%08x\n",
                         strFuncP1,
                         pLowerIrp->IoStatus.Information);
         }
      }
      else
      {
         DebugPrint2("%s:  Completed with status 0x%08x\n", 
                      strFuncP1,
                      lStatus);
      }
   }
   TSCompleteIrp(pEventContext->pUpperIrp);

   //
   // now cleanup
   //
   TSFreeIrp(pLowerIrp, NULL);
   TSFreeMemory(pEventContext);

   return TDI_MORE_PROCESSING;
}

#pragma warning(default: UNREFERENCED_PARAM)


/////////////////////////////////////////////
// dummy event handlers
/////////////////////////////////////////////

#pragma warning(disable: UNREFERENCED_PARAM)


TDI_STATUS
TSErrorHandler(PVOID       pvTdiEventContext,
               TDI_STATUS  TdiStatus)
{
   return TSErrorExHandler(pvTdiEventContext,
                           TdiStatus,
                           NULL);
}


TDI_STATUS
TSSendPossibleHandler(PVOID   pvTdiEventContext,
                      PVOID   pvConnectionContext,
                      ULONG   ulBytesAvailable)
{
   DebugPrint3("TSSendPossibleHandler Called\n"
               "AddressObject  = %p\n"
               "ConnectContext = %p\n"
               "BytesAvail     = 0x%08x\n",
                pvTdiEventContext,
                pvConnectionContext,
                ulBytesAvailable);
   return TDI_SUCCESS;
}


TDI_STATUS
TSErrorExHandler(PVOID        pvTdiEventContext,
                 TDI_STATUS   TdiStatus,
                 PVOID        pvBuffer)
{
   PADDRESS_OBJECT   pAddressObject = (PADDRESS_OBJECT)pvTdiEventContext;

   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint3("TSErrorExHandler Called\n"
                  "AddressObject = %p\n"
                  "Status        = 0x%08x\n"
                  "Buffer        = %p\n",
                   pvTdiEventContext,
                   TdiStatus,
                   pvBuffer);
   }
   return STATUS_SUCCESS;
}

#pragma warning(default: UNREFERENCED_PARAM)

/////////////////////////////////////////////////////////////////////////////////
// end of file events.cpp
/////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\buffer.cpp ===
/////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       buffer
//
//    Abstract:
//       This module contains code which deals with receiving
//       data via posted user mode buffers
//
//////////////////////////////////////////////////////////


#include "sysvars.h"


//////////////////////////////////////////////////////////////
// private constants, types, and prototypes
//////////////////////////////////////////////////////////////

const PCHAR strFunc1  = "TSPostReceiveBuffer";
//const PCHAR strFunc2  = "TSFetchReceiveBuffer";
const PCHAR strFuncP1 = "TSSampleReceiveBufferComplete";

//
// receive completion context.  Also used to track what buffers have
// been posted
//
struct   USERBUF_INFO
{
   USERBUF_INFO   *pNextUserBufInfo;      // next one in chain
   PMDL           pLowerMdl;              // mdl for lower irp
   PIRP           pLowerIrp;              // so can abort it...
   TDI_EVENT      TdiEventCompleted;        // abort completed
   ULONG          ulBytesTransferred;     // #bytes stored in mdl
   PUCHAR         pucUserModeBuffer;
   PTDI_CONNECTION_INFORMATION
                  pReceiveTdiConnectInfo;
   PTDI_CONNECTION_INFORMATION
                  pReturnTdiConnectInfo;
};
typedef  USERBUF_INFO   *PUSERBUF_INFO;



//
// completion function
//
TDI_STATUS
TSReceiveBufferComplete(
   PDEVICE_OBJECT DeviceObject,
   PIRP           Irp,
   PVOID          Context
   );


//////////////////////////////////////////////////////////////
// public functions
//////////////////////////////////////////////////////////////



// --------------------------------------------------------
//
// Function:   TSPostReceiveBuffer
//
// Arguments:  pGenericHeader -- AddressObject or Endpoint to post buffer for
//             pSendBuffer    -- rest of arguments
//
// Returns:    status of operation (STATUS_SUCCESS or a failure)
//
// Descript:   This function posts a user mode buffer for receiving either
//             a datagram or a packet over a connection.  The buffer will
//             be retrieved later by TSFetchReceiveBuffer
//
// --------------------------------------------------------


NTSTATUS
TSPostReceiveBuffer(PGENERIC_HEADER pGenericHeader,
                    PSEND_BUFFER    pSendBuffer)
{
   ULONG    ulDataLength  = pSendBuffer->COMMAND_ARGS.SendArgs.ulBufferLength;
   PUCHAR   pucDataBuffer = pSendBuffer->COMMAND_ARGS.SendArgs.pucUserModeBuffer;
            
   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint3("\nCommand = ulPOSTRECEIVEBUFFER\n"
                  "FileObject = %p\n"
                  "DataLength = %u\n"
                  "Buffer     = %p\n",
                   pGenericHeader,
                   ulDataLength,
                   pucDataBuffer);
   }
         
   //
   // make sure we have a valid object to run on
   //
   PADDRESS_OBJECT   pAddressObject;
   PENDPOINT_OBJECT  pEndpoint;
   
   if (pGenericHeader->ulSignature == ulEndpointObject)
   {
      pEndpoint = (PENDPOINT_OBJECT)pGenericHeader;

      if (pEndpoint->fIsConnected)
      {
         pAddressObject = pEndpoint->pAddressObject;
      }
      else
      {
         return STATUS_UNSUCCESSFUL;
      }
   }
   else
   {
      pEndpoint = NULL;
      pAddressObject = (PADDRESS_OBJECT)pGenericHeader;
   }
                              
   //
   // attempt to lock down the memory
   //
   PMDL  pReceiveMdl = TSMakeMdlForUserBuffer(pucDataBuffer, 
                                              ulDataLength,
                                              IoModifyAccess);

   if (!pReceiveMdl)
   {
      return STATUS_UNSUCCESSFUL;
   }

   //
   // allocate our context
   //
   PUSERBUF_INFO                 pUserBufInfo           = NULL;
   PTDI_CONNECTION_INFORMATION   pReceiveTdiConnectInfo = NULL;
   PTDI_CONNECTION_INFORMATION   pReturnTdiConnectInfo  = NULL;
   PIRP                          pLowerIrp              = NULL;

   //
   // our context
   //
   if ((TSAllocateMemory((PVOID *)&pUserBufInfo,
                          sizeof(USERBUF_INFO),
                          strFunc1,
                          "UserBufInfo")) != STATUS_SUCCESS)
   {
      goto cleanup;
   }


   //
   // do path specific allocations
   //
   if (pEndpoint)
   {
      pLowerIrp = TSAllocateIrp(pEndpoint->GenHead.pDeviceObject,
                                NULL);
   }
   else
   {
      //
      // for datagrams, need the connection information structures
      //
      if ((TSAllocateMemory((PVOID *)&pReceiveTdiConnectInfo,
                             sizeof(TDI_CONNECTION_INFORMATION) + sizeof(TRANSADDR),
                             strFunc1,
                             "ReceiveTdiConnectionInformation")) != STATUS_SUCCESS)
      {
         goto cleanup;
      }
   
   
      if ((TSAllocateMemory((PVOID *)&pReturnTdiConnectInfo,
                             sizeof(TDI_CONNECTION_INFORMATION) + sizeof(TRANSADDR),
                             strFunc1,
                             "ReturnTdiConnectionInformation")) != STATUS_SUCCESS)
      {
         goto cleanup;
      }
      pLowerIrp = TSAllocateIrp(pAddressObject->GenHead.pDeviceObject,
                                NULL);
   }

   //
   // everything is allocated at this point...
   //
   if (pLowerIrp)
   {
      //
      // common code -- mostly dealing with puserbuf structure
      // First, add it to the linked list
      //
      TSAcquireSpinLock(&pAddressObject->TdiSpinLock);
      if (pAddressObject->pTailUserBufInfo)
      {
         pAddressObject->pTailUserBufInfo->pNextUserBufInfo = pUserBufInfo;
      }
      else
      {
         pAddressObject->pHeadUserBufInfo = pUserBufInfo;
      }
      pAddressObject->pTailUserBufInfo = pUserBufInfo;
      TSReleaseSpinLock(&pAddressObject->TdiSpinLock);

      //
      // and fill in all fields that we can
      //
      pUserBufInfo->pLowerMdl              = pReceiveMdl;
      pUserBufInfo->pLowerIrp              = pLowerIrp;
      pUserBufInfo->ulBytesTransferred     = 0;
      pUserBufInfo->pucUserModeBuffer      = pucDataBuffer;
      pUserBufInfo->pReceiveTdiConnectInfo = pReceiveTdiConnectInfo;
      pUserBufInfo->pReturnTdiConnectInfo  = pReturnTdiConnectInfo;
      TSInitializeEvent(&pUserBufInfo->TdiEventCompleted);

      //
      // now do what is necessary for each path..
      //
      if (pEndpoint)
      {
         //
         // set up the irp for the call
         //
   #pragma  warning(disable: CONSTANT_CONDITIONAL)
   
         TdiBuildReceive(pLowerIrp,
                         pEndpoint->GenHead.pDeviceObject,
                         pEndpoint->GenHead.pFileObject,
                         TSReceiveBufferComplete,
                         pUserBufInfo,
                         pReceiveMdl,
                         0,               // flags
                         ulDataLength);
   
   #pragma  warning(default: CONSTANT_CONDITIONAL)
   
   
         NTSTATUS lStatus = IoCallDriver(pEndpoint->GenHead.pDeviceObject,
                                         pLowerIrp);

         if ((!NT_SUCCESS(lStatus)) && (ulDebugLevel & ulDebugShowCommand))
         {
            DebugPrint2(("%s: unexpected status for IoCallDriver [0x%08x]\n"), 
                         strFunc1,
                         lStatus);
         }
      }

      //
      // else a datagram
      //
      else
      {
         pReturnTdiConnectInfo->RemoteAddress       = (PUCHAR)pReturnTdiConnectInfo 
                                                      + sizeof(TDI_CONNECTION_INFORMATION);         
         pReturnTdiConnectInfo->RemoteAddressLength = ulMAX_TABUFFER_LENGTH;
   
         //
         // set up the irp for the call
         //
   
   #pragma  warning(disable: CONSTANT_CONDITIONAL)
   
         TdiBuildReceiveDatagram(pLowerIrp,
                                 pAddressObject->GenHead.pDeviceObject,
                                 pAddressObject->GenHead.pFileObject,
                                 TSReceiveBufferComplete,
                                 pUserBufInfo,
                                 pReceiveMdl,
                                 ulDataLength,
                                 pReceiveTdiConnectInfo,
                                 pReturnTdiConnectInfo,
                                 TDI_RECEIVE_NORMAL);
   
   #pragma  warning(default: CONSTANT_CONDITIONAL)
   
         NTSTATUS lStatus = IoCallDriver(pAddressObject->GenHead.pDeviceObject,
                                         pLowerIrp);

         if ((!NT_SUCCESS(lStatus)) && (ulDebugLevel & ulDebugShowCommand))
         {
            DebugPrint2(("%s: unexpected status for IoCallDriver [0x%08x]\n"), 
                         strFunc1,
                         lStatus);
         }
      }
      return STATUS_SUCCESS;
   }

//
// get here if there was an allocation failure
// need to clean up everything else...
//
cleanup:
   if (pUserBufInfo)
   {
      TSFreeMemory(pUserBufInfo);
   }
   if (pReceiveTdiConnectInfo)
   {
      TSFreeMemory(pReceiveTdiConnectInfo);
   }
   if (pReturnTdiConnectInfo)
   {
      TSFreeMemory(pReturnTdiConnectInfo);
   }

   TSFreeUserBuffer(pReceiveMdl);
   return STATUS_INSUFFICIENT_RESOURCES;
}


// --------------------------------------------------------
//
// Function:   TSFetchReceiveBuffer
//
// Arguments:  pGenericHeader -- AddressObject or Endpoint to fetch buffer for
//             pReceiveBuffer -- for storing actual results
//
// Returns:    status of operation (STATUS_SUCCESS)
//
// Descript:   This function retrieves the user mode buffer posted earlier
//             by function TSPostReceiveBuffer
//
// --------------------------------------------------------

NTSTATUS
TSFetchReceiveBuffer(PGENERIC_HEADER   pGenericHeader,
                     PRECEIVE_BUFFER   pReceiveBuffer)
{

   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint1("\nCommand = ulFETCHRECEIVEBUFFER\n"
                  "FileObject = %p\n",
                   pGenericHeader);
   }
         
   //
   // make sure we have a valid object to run on
   //
   PADDRESS_OBJECT   pAddressObject;
   
   if (pGenericHeader->ulSignature == ulEndpointObject)
   {
      PENDPOINT_OBJECT  pEndpoint = (PENDPOINT_OBJECT)pGenericHeader;

      //
      // note:  it is possible that connection has been broken but that
      // the buffer is still posted
      //
      pAddressObject = pEndpoint->pAddressObject;
      if (!pAddressObject)
      {
         return STATUS_UNSUCCESSFUL;
      }
   }
   else
   {
      pAddressObject = (PADDRESS_OBJECT)pGenericHeader;
   }
                              
   //
   // ok, we got the address object.  See if there are any user buffers
   // attached to it...
   //

   TSAcquireSpinLock(&pAddressObject->TdiSpinLock);

   PUSERBUF_INFO  pUserBufInfo = pAddressObject->pHeadUserBufInfo;
   if (pUserBufInfo)
   {
      if (pUserBufInfo->pNextUserBufInfo)
      {
         pAddressObject->pHeadUserBufInfo = pUserBufInfo->pNextUserBufInfo;
      }
      else
      {
         pAddressObject->pHeadUserBufInfo = NULL;
         pAddressObject->pTailUserBufInfo = NULL;
      }
   }
   TSReleaseSpinLock(&pAddressObject->TdiSpinLock);

   if (!pUserBufInfo)
   {
      return STATUS_UNSUCCESSFUL;
   }

   //
   // ok, we got our buffer.  See if it has completed
   // or if we need to abort it
   //
   if (pUserBufInfo->pLowerIrp)
   {
      IoCancelIrp(pUserBufInfo->pLowerIrp);
      TSWaitEvent(&pUserBufInfo->TdiEventCompleted);
   }

   //
   // it has finished.  stuff the address and length into the receive
   // buffer, delete the UserBufInfo structure, and go home
   //
   pReceiveBuffer->RESULTS.RecvDgramRet.ulBufferLength    = pUserBufInfo->ulBytesTransferred;
   pReceiveBuffer->RESULTS.RecvDgramRet.pucUserModeBuffer = pUserBufInfo->pucUserModeBuffer;

   TSFreeMemory(pUserBufInfo);

   return STATUS_SUCCESS;
}


/////////////////////////////////////////////////////////////
// private functions
/////////////////////////////////////////////////////////////

// ---------------------------------------------------------
//
// Function:   TSReceiveBufferComplete
//
// Arguments:  pDeviceObject  -- device object that called protocol
//             pIrp           -- IRP used in the call
//             pContext       -- context used for the call
//
// Returns:    status of operation (STATUS_MORE_PROCESSING_REQUIRED)
//
// Descript:   Gets the result of the command, unlock the buffer,
//             and does other necessary cleanup
//
// ---------------------------------------------------------

#pragma warning(disable: UNREFERENCED_PARAM)

TDI_STATUS
TSReceiveBufferComplete(PDEVICE_OBJECT pDeviceObject,
                        PIRP           pLowerIrp,
                        PVOID          pvContext)

{
   PUSERBUF_INFO  pUserBufInfo    = (PUSERBUF_INFO)pvContext;
   NTSTATUS       lStatus         = pLowerIrp->IoStatus.Status;
   ULONG          ulBytesReceived = (ULONG)pLowerIrp->IoStatus.Information;

   if (NT_SUCCESS(lStatus))
   {
      if (ulDebugLevel & ulDebugShowCommand)
      {
         DebugPrint2("%s: BytesReceived = 0x%08x\n",
                      strFuncP1,
                      ulBytesReceived);
      }
      pUserBufInfo->ulBytesTransferred = ulBytesReceived;
   }
   else
   {
      if (ulDebugLevel & ulDebugShowCommand)
      {
         DebugPrint2("%s:  Completed with status 0x%08x\n", 
                      strFuncP1,
                      lStatus);
      }
   }

   //
   // now cleanup
   //
   TSFreeUserBuffer(pUserBufInfo->pLowerMdl);
   
   if (pUserBufInfo->pReturnTdiConnectInfo)
   {
      TSFreeMemory(pUserBufInfo->pReturnTdiConnectInfo);
   }
   if (pUserBufInfo->pReceiveTdiConnectInfo)
   {
      TSFreeMemory(pUserBufInfo->pReceiveTdiConnectInfo);
   }

   TSSetEvent(&pUserBufInfo->TdiEventCompleted);
   TSFreeIrp(pLowerIrp, NULL);
   pUserBufInfo->pLowerIrp = NULL;
   return TDI_MORE_PROCESSING;
}

#pragma warning(default: UNREFERENCED_PARAM)


///////////////////////////////////////////////////////////////////////////////
// end of file buffer.cpp
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\tdipnp.cpp ===
////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2001  Microsoft Corporation
//
// Module Name:
//    tdipnp.cpp
//
// Abstract:
//    This module contains the tdi pnp functions called from the tdilib.sys
//
/////////////////////////////////////////////////////////////////////////////


#include "sysvars.h"
extern "C"
{
#pragma warning(disable: NAMELESS_STRUCT_UNION)
#include "tdiinfo.h"
#pragma warning(default: NAMELESS_STRUCT_UNION)
}

////////////////////////////////////////////////////////
// private defines and prototypes
////////////////////////////////////////////////////////


VOID
TSPrintTdiContext(
   PTDI_PNP_CONTEXT  Context
   );


VOID
TSRemoveFromDeviceList(
   PTA_ADDRESS       pTaAddress,
   PCWSTR            pDeviceName,
   ULONG             ulNameLength
   );

VOID
TSAddToDeviceList(
   PTA_ADDRESS    pTaAddress,
   PCWSTR         pDeviceName,
   ULONG          ulNameLength
   );

const PCHAR strFunc1 = "TSPnpBindCallback";
const PCHAR strFunc2 = "TSPnpPowerHandler";
const PCHAR strFunc3 = "TSPnpAddAddressCallback";
const PCHAR strFunc4 = "TSPnpDelAddressCallback";

const PCHAR strFunc5 = "TSGetNumDevices";
const PCHAR strFunc6 = "TSGetDevice";
const PCHAR strFunc7 = "TSGetAddress";

//const PCHAR strFuncP1 = "TSPrintTdiContext";
const PCHAR strFuncP2 = "TSAddToDeviceList";
//const PCHAR strFuncP3 = "TSRemoveFromDeviceList";

///////////////////////////////////////////////////////
// public functions
///////////////////////////////////////////////////////



// ---------------------------------------
//
// Function:   TSPnpBindCallback
//
// Arguments:  TdiPnpOpcode      -- callback type
//             pusDeviceName     -- name of device to deal with
//             pwstrBindingList  -- information from registry Linkage key
//                                  (if appropriate)
//
// Returns:    none
//
// Descript:   This function is called by tdi.sys when tdisample.sys
//             registers its PnpCallbackHandlers.  It is called several
//             times, with the reason for each call in TdiPnpOpcode
//
//             Currently, it just writes the information passed in to the
//             debugger
//
// ---------------------------------------


VOID
TSPnpBindCallback(TDI_PNP_OPCODE    TdiPnpOpcode,
                  PUNICODE_STRING   pusDeviceName,
                  PWSTR             pwstrBindingList)
{
   if (ulDebugLevel & ulDebugShowHandlers)
   {
      if (pusDeviceName) 
      {
         DebugPrint1("DeviceName: %wZ\r\n", pusDeviceName);
      } 
      else 
      {
         DebugPrint0("DeviceName: NULL\n");
      }

      DebugPrint0("OPCODE: ");

      switch (TdiPnpOpcode) 
      {
         case TDI_PNP_OP_MIN:
            DebugPrint0("TDI_PNP_OP_MIN\n");
            break;

         case TDI_PNP_OP_ADD:
            DebugPrint0("TDI_PNP_OP_ADD\n");
            break;

         case TDI_PNP_OP_DEL:
            DebugPrint0("TDI_PNP_OP_DEL\n");
            break;

         case TDI_PNP_OP_UPDATE:
            DebugPrint0("TDI_PNP_OP_UPDATE\n");
            break;
    
         case TDI_PNP_OP_PROVIDERREADY:
            DebugPrint0("TDI_PNP_OP_PROVIDERREADY\n");
            break;
    
         case TDI_PNP_OP_NETREADY:
            DebugPrint0("TDI_PNP_OP_NETREADY\n");
            break;

         default:
            DebugPrint1("INCORRECT OPCODE FROM TDI!! [0x%08x]\n", 
                         TdiPnpOpcode);
            DbgBreakPoint();
            break;

      }

      //
      // this is the information from the registry under
      // HKLM/SYSTEM/CurrentControlSet/Services/clientname/Linkage/Bind
      //
      if( pwstrBindingList == NULL ) 
      {
         DebugPrint0("Bindinglist is NULL\n");
      } 
      else 
      {
         ULONG_PTR ulStrLen;

         DebugPrint0("BindingList:\n");
         while (*pwstrBindingList)
         {
            DebugPrint1("%ws\n", pwstrBindingList);
            ulStrLen = 1 + wcslen(pwstrBindingList);
            pwstrBindingList += ulStrLen;
         }
         DebugPrint0("\n");
      }
   }
}


// --------------------------------------
//
// Function:   TSPnpPowerHandler
//
// Arguments:  pusDeviceName  -- device name to deal with
//             pNetPnpEvent   -- power event to deal with
//             pTdiPnpContext1
//             pTdiPnpContext2
//
// Returns:    status of operation
//
// Descript:   This function deals with pnp and power management issues
//
//             Currently, it just outputs information to the debugger
//
// --------------------------------------


NTSTATUS
TSPnpPowerHandler(PUNICODE_STRING   pusDeviceName,
                  PNET_PNP_EVENT    pNetPnpEvent,
                  PTDI_PNP_CONTEXT  pTdiPnpContext1,
                  PTDI_PNP_CONTEXT  pTdiPnpContext2)

{
   if (ulDebugLevel & ulDebugShowHandlers)
   {
      if (pusDeviceName) 
      {
         DebugPrint1("DeviceName: %wZ\r\n", pusDeviceName);
      } 
      else 
      {
         DebugPrint0("DeviceName: NULL\n");
      }

      switch (pNetPnpEvent->NetEvent)
      {
         case NetEventSetPower:
         case NetEventQueryPower:
         {
            if (pNetPnpEvent->NetEvent == NetEventSetPower)
            {
               DebugPrint1("%s:  NetEventSetPower--", strFunc2);
            }
            else
            {
               DebugPrint1("%s:  NetEventQueryPower -- ", strFunc2);
            }
            NET_DEVICE_POWER_STATE  NetDevicePowerState
                                    = *(PNET_DEVICE_POWER_STATE)pNetPnpEvent->Buffer;

            switch (NetDevicePowerState)
            {
               case  NetDeviceStateUnspecified:
                  DebugPrint0("PowerStateUnspecified\n");
                  break;
               case NetDeviceStateD0:
                  DebugPrint0("PowerUp\n");
                  break;
               case NetDeviceStateD1:
               case NetDeviceStateD2:
               case NetDeviceStateD3:
                  DebugPrint0("PowerDown\n");
                  break;
            }
            break;
         }

         case NetEventQueryRemoveDevice:
            DebugPrint1("%s:  NetEventQueryRemoveDevice\n", strFunc2);
            break;
         case NetEventCancelRemoveDevice:
            DebugPrint1("%s:  NetEventCancelRemoveDevice\n", strFunc2);
            break;
         case NetEventReconfigure:
            DebugPrint1("%s:  NetEventReconfigure\n", strFunc2);
            break;
         case NetEventBindList:
            DebugPrint1("%s:  NetEventBindList\n", strFunc2);
            break;
         case NetEventBindsComplete:
            DebugPrint1("%s:  NetEventBindsComplete\n", strFunc2);
            break;
         case NetEventPnPCapabilities:
            DebugPrint1("%s:  NetEventPnPCapabilities\n", strFunc2);
            break;
      
      }

      if (pTdiPnpContext1)
      {
         DebugPrint0("TdiPnpContext1:\n");
         TSPrintTdiContext(pTdiPnpContext1);
      }
      if (pTdiPnpContext2)
      {
         DebugPrint0("TdiPnpContext2:\n");
         TSPrintTdiContext(pTdiPnpContext2);
      }
   }
   return STATUS_SUCCESS;
}

// -----------------------------------------------
//
// Function:   TSPnpAddAddressCallback
//
// Arguments:  pTaAddress  -- address to register
//             pusDeviceName -- device name associated with address
//             pTdiPnpContext
//
// Returns:    none
//
// Descript:   called by tdi.sys.  When called, tdisample adds this device
//             to its registered list, if it recognizes the address format
//
// -----------------------------------------------

VOID
TSPnpAddAddressCallback(PTA_ADDRESS       pTaAddress, 
                        PUNICODE_STRING   pusDeviceName,
                        PTDI_PNP_CONTEXT  pTdiPnpContext)
{
   if (ulDebugLevel & ulDebugShowHandlers)
   {
      //
      // write info to debugger
      //
      DebugPrint1("DeviceName: %wZ\r\n", pusDeviceName);
      TSPrintTaAddress(pTaAddress);
      if (pTdiPnpContext)
      {
         DebugPrint0("TdiPnpContext:\n");
         TSPrintTdiContext(pTdiPnpContext);
      }
   }

   //
   // add this to our list of devices/addresses, if appropriate
   //
   TSAddToDeviceList(pTaAddress, 
                     pusDeviceName->Buffer,
                     pusDeviceName->Length);
}


// -----------------------------------------------
//
// Function:   TSDelAddAddressCallback
//
// Arguments:  pTaAddress  -- address to de-register
//             pusDeviceName -- device name associated with address
//             pTdiPnpContext
//
// Returns:    none
//
// Descript:   called by tdi.sys.  When called, tdisample removes this device
//             to its registered list, if it recognizes the address format
//
// -----------------------------------------------

VOID
TSPnpDelAddressCallback(PTA_ADDRESS       pTaAddress, 
                        PUNICODE_STRING   pusDeviceName,
                        PTDI_PNP_CONTEXT  pTdiPnpContext)
{
   if (ulDebugLevel & ulDebugShowHandlers)
   {
      DebugPrint1("DeviceName: %wZ\r\n", pusDeviceName);
      TSPrintTaAddress(pTaAddress);
      if (pTdiPnpContext)
      {
         DebugPrint0("TdiPnpContext:\n");
         TSPrintTdiContext(pTdiPnpContext);
      }
   }

   //
   // remove this from our list of devices/addresses, if appropriate
   //
   TSRemoveFromDeviceList(pTaAddress, 
                          pusDeviceName->Buffer,
                          pusDeviceName->Length);
}


// ----------------------------------------
//
// Function:   TSGetNumDevices
//
// Arguments:  pSendBuffer
//             pReceiveBuffer
//
// Returns:    none
//
// Descript:   Finds the number of devices in tdidevicelist,
//             and returns that value..
//
// ----------------------------------------


VOID
TSGetNumDevices(PSEND_BUFFER     pSendBuffer,
                PRECEIVE_BUFFER  pReceiveBuffer)
{
   ULONG    ulSlot        = 0;
   ULONG    ulAddressType = pSendBuffer->COMMAND_ARGS.GetDevArgs.ulAddressType;
  

   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint1("\nCommand = ulGETNUMDEVICES\n"
                  "AddressType = 0x%08x\n",
                   ulAddressType);
   }

   TSAcquireSpinLock(&pTdiDevnodeList->TdiSpinLock);
   for (ULONG ulCount = 0; ulCount < ulMAX_DEVICE_NODES; ulCount++)
   {
      PTDI_DEVICE_NODE  pTdiDeviceNode = &(pTdiDevnodeList->TdiDeviceNode[ulCount]);
      
      if ((pTdiDeviceNode->ulState != ulDEVSTATE_UNUSED) &&
          (pTdiDeviceNode->pTaAddress->AddressType == (USHORT)ulAddressType))
      {
         ++ulSlot;
      }
   }
   TSReleaseSpinLock(&pTdiDevnodeList->TdiSpinLock);

   pReceiveBuffer->RESULTS.ulReturnValue = ulSlot;
}


// ----------------------------------------
//
// Function:   TSGetDevice
//
// Arguments:  pSendBuffer    -- arguments
//             pReceiveBuffer -- where to put result
//
// Returns:    NTSTATUS (success if finds slot, else false)
//
// Descript:   Finds the device name indicated, and returns
//             the string for that value
//
// ----------------------------------------


NTSTATUS
TSGetDevice(PSEND_BUFFER      pSendBuffer,
            PRECEIVE_BUFFER   pReceiveBuffer)
{
   ULONG    ulSlot        = 0;
   ULONG    ulAddressType = pSendBuffer->COMMAND_ARGS.GetDevArgs.ulAddressType;
   ULONG    ulSlotNum     = pSendBuffer->COMMAND_ARGS.GetDevArgs.ulSlotNum;


   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint2("\nCommand = ulGETDEVICE\n"
                  "AddressType = 0x%08x\n"
                  "SlotNum = %d\n",
                   ulAddressType,
                   ulSlotNum);
   }

   TSAcquireSpinLock(&pTdiDevnodeList->TdiSpinLock);
   for (ULONG ulCount = 0; ulCount < ulMAX_DEVICE_NODES; ulCount++)
   {
      PTDI_DEVICE_NODE  pTdiDeviceNode = &(pTdiDevnodeList->TdiDeviceNode[ulCount]);

      if ((pTdiDeviceNode->ulState != ulDEVSTATE_UNUSED) &&
          (pTdiDeviceNode->pTaAddress->AddressType == (USHORT)ulAddressType))
      {
         if (ulSlot == ulSlotNum)
         {
            if (pTdiDeviceNode->ustrDeviceName.MaximumLength > (ulMAX_CNTSTRING_LENGTH * sizeof(WCHAR)))
            {
               DebugPrint0("string length problem!\n");
               DbgBreakPoint();
            }

            RtlZeroMemory(&pReceiveBuffer->RESULTS.ucsStringReturn.wcBuffer,
                          ulMAX_CNTSTRING_LENGTH * sizeof(WCHAR));

            pReceiveBuffer->RESULTS.ucsStringReturn.usLength
                            = pTdiDeviceNode->ustrDeviceName.Length;
            RtlCopyMemory(pReceiveBuffer->RESULTS.ucsStringReturn.wcBuffer,
                          pTdiDeviceNode->ustrDeviceName.Buffer,
                          pTdiDeviceNode->ustrDeviceName.Length);

            TSReleaseSpinLock(&pTdiDevnodeList->TdiSpinLock);
            if (pTdiDeviceNode->ulState == ulDEVSTATE_INUSE)
            {
               return STATUS_SUCCESS;
            }
            else
            {
               return STATUS_UNSUCCESSFUL;
            }
         }
         ++ulSlot;
      }
   }
   TSReleaseSpinLock(&pTdiDevnodeList->TdiSpinLock);

   return STATUS_UNSUCCESSFUL;
}

// ----------------------------------------
//
// Function:   TSGetAddress
//
// Arguments:  pSendBuffer    -- arguments
//             pReceiveBuffer -- where to put result
//
// Returns:    NTSTATUS (success if finds slot, else false)
//
// Descript:   Finds the device name indicated, and returns
//             the string for that value
//
// ----------------------------------------


NTSTATUS
TSGetAddress(PSEND_BUFFER     pSendBuffer,
             PRECEIVE_BUFFER  pReceiveBuffer)
{
   ULONG    ulSlot        = 0;
   ULONG    ulAddressType = pSendBuffer->COMMAND_ARGS.GetDevArgs.ulAddressType;
   ULONG    ulSlotNum     = pSendBuffer->COMMAND_ARGS.GetDevArgs.ulSlotNum;

   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint2("\nCommand = ulGETADDRESS\n"
                  "AddressType = 0x%08x\n"
                  "SlotNum = %d\n",
                   ulAddressType,
                   ulSlotNum);
   }

   TSAcquireSpinLock(&pTdiDevnodeList->TdiSpinLock);
   for (ULONG ulCount = 0; ulCount < ulMAX_DEVICE_NODES; ulCount++)
   {
      PTDI_DEVICE_NODE  pTdiDeviceNode = &(pTdiDevnodeList->TdiDeviceNode[ulCount]);

      if ((pTdiDeviceNode->ulState != ulDEVSTATE_UNUSED) &&
          (pTdiDeviceNode->pTaAddress->AddressType == (USHORT)ulAddressType))
      {
         if (ulSlot == ulSlotNum)
         {
            ULONG ulLength = FIELD_OFFSET(TA_ADDRESS, Address)
                           + pTdiDeviceNode->pTaAddress->AddressLength;

            pReceiveBuffer->RESULTS.TransAddr.TAAddressCount = 1;
            RtlCopyMemory(&pReceiveBuffer->RESULTS.TransAddr.TaAddress,
                          pTdiDeviceNode->pTaAddress,
                          ulLength);

            TSReleaseSpinLock(&pTdiDevnodeList->TdiSpinLock);
            if (pTdiDeviceNode->ulState == ulDEVSTATE_INUSE)
            {
               return STATUS_SUCCESS;
            }
            else
            {
               return STATUS_UNSUCCESSFUL;
            }
         }
         ++ulSlot;
      }
   }
   TSReleaseSpinLock(&pTdiDevnodeList->TdiSpinLock);

   return STATUS_UNSUCCESSFUL;
}


//////////////////////////////////////////////////////
// private functions
//////////////////////////////////////////////////////


// ---------------------------------
//
// Function:   TSPrintTdiContext
//
// Arguments:  pTdiPnpContext -- context to dump
//
// Returns:    none
//
// Descript:   prints out information in pTdiPnpContext structure
//
// ---------------------------------

VOID
TSPrintTdiContext(PTDI_PNP_CONTEXT  pTdiPnpContext)
{
   if (pTdiPnpContext)
   {
      PUCHAR   pucTemp = pTdiPnpContext->ContextData;

      DebugPrint2("TdiPnpContextSize:  %u\n"
                  "TdiPnpContextType:  %u\n"
                  "TdiPnpContextData:  ",
                   pTdiPnpContext->ContextSize,
                   pTdiPnpContext->ContextType);
      
      for (ULONG ulCount = 0; ulCount < pTdiPnpContext->ContextSize; ulCount++)
      {
         DebugPrint1("%02x ", *pucTemp);
         ++pucTemp;
      }
      DebugPrint0("\n");
   }
}

// ------------------------------------------
//
// Function:   TSAddToDeviceList
//
// Arguments:  pTaAddress    -- current address structure
//             pusDeviceName -- actual name of device
//
// Returns:    none
//
// Descript:   Adds this device to our device list, if appropriate
//
// ------------------------------------------

VOID
TSAddToDeviceList(PTA_ADDRESS pTaAddress,
                  PCWSTR      pDeviceName,
                  ULONG       ulNameLength)
{
   //
   // scan list for first available slot.  For any slot before the first
   // available whose entry has been deleted, check to see if this is the
   // same device coming back
   //
   ULONG    ulLengthNeeded = FIELD_OFFSET(TA_ADDRESS, Address) 
                             + pTaAddress->AddressLength;
   ULONG    ulAddressType  = pTaAddress->AddressType;


   TSAcquireSpinLock(&pTdiDevnodeList->TdiSpinLock);
   for (ULONG ulCount = 0; ulCount < ulMAX_DEVICE_NODES; ulCount++)
   {
      PTDI_DEVICE_NODE  pTdiDeviceNode = &(pTdiDevnodeList->TdiDeviceNode[ulCount]);

      switch (pTdiDeviceNode->ulState)
      {
         //
         // this is first unused slot
         // allocate buffers and set
         //
         case ulDEVSTATE_UNUSED:
            if ((TSAllocateMemory((PVOID *)&pTdiDeviceNode->pTaAddress,
                                   ulLengthNeeded,
                                   strFuncP2,
                                   "TaAddress")) == STATUS_SUCCESS)
            {
               if ((TSAllocateMemory((PVOID *)&pTdiDeviceNode->ustrDeviceName.Buffer,
                                      ulNameLength+2,
                                      strFuncP2,
                                      "Buffer")) == STATUS_SUCCESS)
               {
                  RtlCopyMemory(pTdiDeviceNode->pTaAddress,
                                pTaAddress,
                                ulLengthNeeded);
                  
                  pTdiDeviceNode->ustrDeviceName.MaximumLength = (USHORT)(ulNameLength + 2);
                  pTdiDeviceNode->ustrDeviceName.Length        = (USHORT)ulNameLength;
                  RtlCopyMemory(pTdiDeviceNode->ustrDeviceName.Buffer,
                                pDeviceName,
                                ulNameLength);
                  pTdiDeviceNode->ulState = ulDEVSTATE_INUSE;
               }
               else
               {
                  TSFreeMemory(pTdiDeviceNode->pTaAddress);
               }
            }
            TSReleaseSpinLock(&pTdiDevnodeList->TdiSpinLock);
            return;

         //
         // device in slot has been removed.  See if this is the same
         // device coming back
         //
         case ulDEVSTATE_DELETED:
         {
            //
            // check for correct name
            //
            ULONG_PTR   ulCompareLength = RtlCompareMemory(pTdiDeviceNode->ustrDeviceName.Buffer,
                                                           pDeviceName,
                                                           ulNameLength);
            if (ulCompareLength == ulNameLength)
            {
               //
               // for tcpip, netbios, and appletalk this is enough
               // for ipx/spx, need to check address as well
               //
               if (ulAddressType == TDI_ADDRESS_TYPE_IPX)
               {
                  ulCompareLength = RtlCompareMemory(pTdiDeviceNode->pTaAddress,
                                                     pTaAddress,
                                                     pTaAddress->AddressLength + sizeof(ULONG));
                  
                  //
                  // if address is incorrect, not right ipx
                  //
                  if (ulCompareLength != pTaAddress->AddressLength + sizeof(ULONG))
                  {
                     break;
                  }
               }
               else
               {
                  //
                  // copy address info over in case it changed..
                  //
                  RtlCopyMemory(pTdiDeviceNode->pTaAddress,
                                pTaAddress,
                                ulLengthNeeded);
               }

               pTdiDeviceNode->ulState = ulDEVSTATE_INUSE;
               TSReleaseSpinLock(&pTdiDevnodeList->TdiSpinLock);
               return;
            }
         }
         break;

         //
         // device in slot is in used.  Leave it alone
         //
         case ulDEVSTATE_INUSE:
            break;
      }
   }
   TSReleaseSpinLock(&pTdiDevnodeList->TdiSpinLock);
}



// ------------------------------------------
//
// Function:   TSRemoveFromDeviceList
//
// Arguments:  pTaAddress    -- current address structure
//             pusDeviceName -- actual name of device
//
// Returns:    none
//
// Descript:   Remove this device from our device list, if is it
//             on it..
//
// ------------------------------------------

VOID
TSRemoveFromDeviceList(PTA_ADDRESS  pTaAddress,
                       PCWSTR       pDeviceName,
                       ULONG        ulNameLength)
{
   //
   // search list for the item to remove..
   //
   TSAcquireSpinLock(&pTdiDevnodeList->TdiSpinLock);
   for (ULONG ulCount = 0; ulCount < ulMAX_DEVICE_NODES; ulCount++)
   {
      PTDI_DEVICE_NODE  pTdiDeviceNode = &(pTdiDevnodeList->TdiDeviceNode[ulCount]);

      //
      // check to see that it is the right node...
      // first check to see if the address is correct
      //
      ULONG_PTR   ulCompareLength = RtlCompareMemory(pTdiDeviceNode->pTaAddress,
                                                     pTaAddress,
                                                     pTaAddress->AddressLength + sizeof(ULONG));
      
      //
      // if address is correct, check for correct name
      //
      if (ulCompareLength == pTaAddress->AddressLength + sizeof(ULONG))
      {
         ulCompareLength = RtlCompareMemory(pTdiDeviceNode->ustrDeviceName.Buffer,
                                            pDeviceName,
                                            ulNameLength);

         //
         // if this matches, it's the right node.  Delete it!
         //
         if (ulCompareLength == ulNameLength)
         {
            pTdiDeviceNode->ulState = ulDEVSTATE_DELETED;
            break;
         }
      }
   }
   TSReleaseSpinLock(&pTdiDevnodeList->TdiSpinLock);

}


/////////////////////////////////////////////////////////////////
// end of file tdipnp.cpp
/////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\requests.cpp ===
/////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       requests.cpp
//
//    Abstract:
//       This module contains code which handles the IRP_MJ_DEVICE_CONTROL
//       calls, which corresponds to DeviceIoControl calls make by the dll
//
//////////////////////////////////////////////////////////

#include "sysvars.h"

///////////////////////////////////
// private constants
///////////////////////////////////

const PCHAR strFunc1 = "TSIssueRequest";

const ULONG ulNoHandleUsed       = ulINVALID_OBJECT;

ULONG ulCommandHandleUsage[ulNUM_COMMANDS] =
      {  
         ulNoHandleUsed,         // ulNO_COMMAND
         ulNoHandleUsed,         // ulVERSION_CHECK
         ulNoHandleUsed,         // ulABORT_COMMAND
         ulNoHandleUsed,         // ulDEBUGLEVEL
         ulNoHandleUsed,         // ulGETNUMDEVICES
         ulNoHandleUsed,         // ulGETDEVICE
         ulNoHandleUsed,         // ulGETADDRESS
         ulNoHandleUsed,         // ulOPENCONTROL
         ulNoHandleUsed,         // ulOPENADDRESS
         ulNoHandleUsed,         // ulOPENENDPOINT

         ulControlChannelObject, // ulCLOSECONTROL

         ulAddressObject,        // ulCLOSEADDRESS
         ulAddressObject,        // ulSENDDATAGRAM
         ulAddressObject,        // ulRECEIVEDATAGRAM

         ulEndpointObject,       // ulCLOSEENDPOINT
         ulEndpointObject,       // ulCONNECT
         ulEndpointObject,       // ulDISCONNECT
         ulEndpointObject,       // ulISCONNECTED
         ulEndpointObject,       // ulSEND
         ulEndpointObject,       // ulRECEIVE
         ulEndpointObject,       // ulLISTEN

         ulControlChannelObject  |
          ulAddressObject        |
          ulEndpointObject,      // ulQUERYINFO

         ulAddressObject   |
            ulEndpointObject,    // ulSETEVENTHANDLER
         ulAddressObject   |
            ulEndpointObject,    // ulPOSTRECEIVEBUFFER
         ulAddressObject   |
            ulEndpointObject     // ulFETCHRECEIVEBUFFER

      };

//------------------------------------------------------
//
// Function:   TSIssueRequest
//
// Arguments:  DeviceContext -- DeviceContext for ndistest.sys.
//             Irp           -- ptr to current irp structure
//             IrpSp         -- ptr to current irp stack
//
// Returns:    final status of whatever operation performed-- STATUS_SUCCESS,
//             STATUS_PENDING, or error status (usually STATUS_UNSUCCESSFUL)
//
// Descript:   This function calls the appropriate function(s) to deal with
//             an IRP_DEVICE_CONTROL request.  Basically all commands from
//             the dll come thru here.
//
// --------------------------------------------------------

NTSTATUS
TSIssueRequest(PDEVICE_CONTEXT      pDeviceContext,
               PIRP                 pIrp,
               PIO_STACK_LOCATION   pIrpSp)

{
   NTSTATUS          lStatus;
   PGENERIC_HEADER   pGenericHeader;      // node used as main argument
   ULONG             ulCmdCode            // IOCTL command to execute
                     = ulTdiIoctlToCommand(pIrpSp->Parameters.DeviceIoControl.IoControlCode);
   PSEND_BUFFER      pSendBuffer          // arguments for command (inputbuffer)
                     = TSGetSendBuffer(pIrp);
   PRECEIVE_BUFFER   pReceiveBuffer       // data to return to dll (outputbuffer)
                     = TSGetReceiveBuffer(pIrp);
   PIRP              pLastCommandIrp
                     = pDeviceContext->pLastCommandIrp;

   //
   // check for an illegal command number
   //
   if (ulCmdCode >= ulNUM_COMMANDS)
   {
      DebugPrint2("\n%s:  Illegal command code:  0x%08x\n", 
                   strFunc1, 
                   ulCmdCode);
      ulCmdCode = ulNO_COMMAND;
   }

   //
   // check for commands that don't require a handle
   //
   if (ulCommandHandleUsage[ulCmdCode] == ulNoHandleUsed)
   {
      pGenericHeader = NULL;
   }

   //
   // for commands that require a handle, make sure that they
   // have the correct type!
   //
   else
   {
      pGenericHeader = TSGetObjectFromHandle(pSendBuffer->TdiHandle,
                                             ulCommandHandleUsage[ulCmdCode]);

      if (pGenericHeader)
      {
         TSAcquireSpinLock(&pObjectList->TdiSpinLock);
         if (pGenericHeader->fInCommand)
         {
            DebugPrint1("\n%s:  ERROR -- command already in progress!\n", 
                         strFunc1);
            ulCmdCode      = ulNO_COMMAND;
            pGenericHeader = NULL;
         }
         else
         {
            pGenericHeader->fInCommand = TRUE;
         }
         TSReleaseSpinLock(&pObjectList->TdiSpinLock);
      }
      else
      {
         DebugPrint1("\n%s:  handle type invalid for command!\n", strFunc1);
         ulCmdCode = ulNO_COMMAND;
      }
   }

   //
   // if a real command, store as last command
   //
   if ((ulCmdCode != ulNO_COMMAND) && (ulCmdCode != ulABORT_COMMAND))
   {
      pDeviceContext->pLastCommandIrp = pIrp;
      pSendBuffer->pvLowerIrp         = NULL;
      pSendBuffer->pvDeviceContext    = pDeviceContext;
   }

   //
   // now deal with the specific command..
   //
   switch (ulCmdCode)
   {
      //-----------------------------------------------------------
      // commands that do not require any handle
      //-----------------------------------------------------------

      //
      // ulNO_COMMAND -- does this if missing required handle type
      //                 (don't want to hit real command OR default..)
      //
      case ulNO_COMMAND:
         lStatus = STATUS_INVALID_PARAMETER;
         break;


      //
      // ulVERSION_CHECK -- return current version id
      //
      case ulVERSION_CHECK:
         //
         // Get the Input and buffers for the Incoming command.
         // Make sure both lengths are ok..
         //
         if ((pIrpSp->Parameters.DeviceIoControl.InputBufferLength  != sizeof(SEND_BUFFER)) ||
             (pIrpSp->Parameters.DeviceIoControl.OutputBufferLength != sizeof(RECEIVE_BUFFER)))
         {
            DebugPrint1("\n%s:  IRP buffer size mismatch!\n"
                        "DLL and driver are mismatched!\n",
                         strFunc1);
            lStatus = STATUS_UNSUCCESSFUL;
         }
         else
         {
            pReceiveBuffer->RESULTS.ulReturnValue = TDI_SAMPLE_VERSION_ID;
            lStatus = STATUS_SUCCESS;
         }
         break;


      //
      // ulABORT_COMMAND -- abort the previous command, if possible
      //
      case ulABORT_COMMAND:
         lStatus = STATUS_SUCCESS;
         if (pLastCommandIrp)
         {
            PSEND_BUFFER   pLastSendBuffer = TSGetSendBuffer(pLastCommandIrp);
            if (pLastSendBuffer)
            {
               if (pLastSendBuffer->pvLowerIrp)
               {
                  DebugPrint0("\nCommand = ulABORT_COMMAND\n");
                  IoCancelIrp((PIRP)pLastSendBuffer->pvLowerIrp);
                  break;
               }
            }
         }
         DebugPrint0("\nCommand = ulABORT_COMMAND w/no command\n");
         break;

      //
      // ulDEBUGLEVEL -- set the current debuglevel
      //
      case ulDEBUGLEVEL:
         ulDebugLevel = pSendBuffer->COMMAND_ARGS.ulDebugLevel;
         DebugPrint1("\nSetting debug level to 0x%x\n", ulDebugLevel);
         lStatus = STATUS_SUCCESS;
         break;

      //
      // ulGETNUMDEVICES -- get number of openable devices
      //
      case ulGETNUMDEVICES:
         TSGetNumDevices(pSendBuffer,
                         pReceiveBuffer);
         lStatus = STATUS_SUCCESS;
         break;

      //
      // ulGETDEVICE -- get the name to open for a specific device
      //
      case ulGETDEVICE:
         lStatus = TSGetDevice(pSendBuffer,
                               pReceiveBuffer);
         break;

      
      //
      // ulGETADDRESS -- get the address to open for a specific device
      //
      case ulGETADDRESS:
         lStatus = TSGetAddress(pSendBuffer,
                                pReceiveBuffer);
         break;

      //
      // ulOPENCONTROL -- open a control channel
      //
      case ulOPENCONTROL:
         lStatus = TSOpenControl(pSendBuffer,
                                 pReceiveBuffer);
         break;

      //
      // ulOPENADDRESS -- open an address object
      //
      case ulOPENADDRESS:
         lStatus = TSOpenAddress(pSendBuffer,
                                 pReceiveBuffer);
         break;

      //
      // ulOPENENDPOINT -- open an endpoint object
      //
      case ulOPENENDPOINT:
         lStatus = TSOpenEndpoint(pSendBuffer,
                                  pReceiveBuffer);
         break;
      
      //-----------------------------------------------------------
      // commands that require a control channel handle
      //-----------------------------------------------------------

      //
      // ulCLOSECONTROL -- close a control channel
      //
      case ulCLOSECONTROL:
         TSRemoveNode(pSendBuffer->TdiHandle);
         TSCloseControl((PCONTROL_CHANNEL)pGenericHeader);
         pGenericHeader = NULL;
         lStatus = STATUS_SUCCESS;
         break;

      //-----------------------------------------------------------
      // commands that require an address handle
      //-----------------------------------------------------------

      //
      // ulCLOSEADDRESS -- close an address object
      //
      case ulCLOSEADDRESS:
         TSRemoveNode(pSendBuffer->TdiHandle);
         TSCloseAddress((PADDRESS_OBJECT)pGenericHeader);
         pGenericHeader = NULL;
         lStatus = STATUS_SUCCESS;
         break;

      //
      // ulSENDDATAGRAM -- send a datagram
      //
      case ulSENDDATAGRAM:
         lStatus = TSSendDatagram((PADDRESS_OBJECT)pGenericHeader,
                                   pSendBuffer,
                                   pIrp);
         break;

      //
      // ulRECEIVEDATAGRAM -- receive a datagram
      //
      case ulRECEIVEDATAGRAM:
         lStatus = TSReceiveDatagram((PADDRESS_OBJECT)pGenericHeader,
                                      pSendBuffer,
                                      pReceiveBuffer);
         break;

      //-----------------------------------------------------------
      // commands that require an endpoint
      //-----------------------------------------------------------

      //
      // ulCLOSEENDPOINT -- close an endpoint object
      //
      case ulCLOSEENDPOINT:
         TSRemoveNode(pSendBuffer->TdiHandle);
         TSCloseEndpoint((PENDPOINT_OBJECT)pGenericHeader);
         pGenericHeader = NULL;
         lStatus = STATUS_SUCCESS;
         break;

      //
      // ulCONNECT -- establish connection between local endpoint and remote endpoint
      //
      case ulCONNECT:
         lStatus = TSConnect((PENDPOINT_OBJECT)pGenericHeader,
                              pSendBuffer,
                              pIrp);
         break;

      //
      // ulDISCONNECT -- removed connection between local and remote endpoints
      //
      case ulDISCONNECT:
         lStatus = TSDisconnect((PENDPOINT_OBJECT)pGenericHeader,
                                 pSendBuffer,
                                 pIrp);
         break;

      //
      // ulISCONNECTED -- check to see if endpoint is connected
      //
      case ulISCONNECTED:
         lStatus = TSIsConnected((PENDPOINT_OBJECT)pGenericHeader,
                                  pReceiveBuffer);
         break;


      //
      // ulSEND -- send data over the connection
      //
      case ulSEND:
         lStatus = TSSend((PENDPOINT_OBJECT)pGenericHeader,
                           pSendBuffer,
                           pIrp);
         break;

      //
      // ulRECEIVE -- receive a packet over the connection
      //
      case ulRECEIVE:
         lStatus = TSReceive((PENDPOINT_OBJECT)pGenericHeader,
                              pSendBuffer,
                              pReceiveBuffer);
         break;

      //
      // ulLISTEN -- wait for an incoming call
      //
      case ulLISTEN:
         lStatus = TSListen((PENDPOINT_OBJECT)pGenericHeader);
         break;

      //-----------------------------------------------------------
      // commands that require a handle, but type may vary
      //-----------------------------------------------------------

      //
      // ulQUERYINFO -- query object for information
      //
      case ulQUERYINFO:
         lStatus = TSQueryInfo(pGenericHeader,
                               pSendBuffer,
                               pIrp);
         break;


      //
      // ulSETEVENTHANDLER -- enable or disable an event handler
      //
      case ulSETEVENTHANDLER:
         lStatus = TSSetEventHandler(pGenericHeader,
                                     pSendBuffer,
                                     pIrp);
         break;

      //
      // ulPOSTRECEIVEBUFFER -- post buffer for receive/recvdgram
      //
      case ulPOSTRECEIVEBUFFER:
         lStatus = TSPostReceiveBuffer(pGenericHeader,
                                       pSendBuffer);
         break;

      //
      // ulFETCHRECEIVEBUFFER -- retrieve a previously posted receive buffer
      //
      case ulFETCHRECEIVEBUFFER:
         lStatus = TSFetchReceiveBuffer(pGenericHeader,
                                        pReceiveBuffer);
         break;

      // --------------------------------------------
      // not a recognized command...
      //---------------------------------------------
      default:
         DebugPrint1("\n%s:  Invalid Command Received\n", strFunc1);
         lStatus = STATUS_INVALID_PARAMETER;
         break;
   }

   if (lStatus != STATUS_PENDING)
   {
      pReceiveBuffer->lStatus = lStatus;
      lStatus = STATUS_SUCCESS;  // return SUCCESS or PENDING for DeviceIoControl
   }

   //
   // clear flag to allow another command in on this handle
   //
   if (pGenericHeader)
   {
      TSAcquireSpinLock(&pObjectList->TdiSpinLock);
      pGenericHeader->fInCommand = FALSE;
      TSReleaseSpinLock(&pObjectList->TdiSpinLock);
   }

   return lStatus;
}


////////////////////////////////////////////////////////////////////////
// end of file requests.cpp
////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\tdiquery.cpp ===
/////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       tdiquery
//
//    Abstract:
//       This module contains code which deals with tdi queries
//
//////////////////////////////////////////////////////////


#include "sysvars.h"

//////////////////////////////////////////////////////////////
// private constants, types, and prototypes
//////////////////////////////////////////////////////////////

const PCHAR strFunc1  = "TSQueryInfo";
const PCHAR strFuncP1 = "TSQueryComplete";


//
// completion context
//
struct   QUERY_CONTEXT
{
   PIRP     pUpperIrp;           // irp from dll to complete
   PMDL     pLowerMdl;           // mdl from lower irp
   PUCHAR   pucLowerBuffer;      // data buffer from lower irp
};
typedef  QUERY_CONTEXT  *PQUERY_CONTEXT;

//
// completion function
//
TDI_STATUS
TSQueryComplete(
   PDEVICE_OBJECT DeviceObject,
   PIRP           Irp,
   PVOID          Context
   );

//////////////////////////////////////////////////////////////
// public functions
//////////////////////////////////////////////////////////////


// -----------------------------------------------------------------
//
// Function:   TSQueryInfo
//
// Arguments:  pGenericHeader -- handle of appropriate type
//             pSendBuffer    -- arguments from user dll
//             pIrp           -- completion information
//
// Returns:    NTSTATUS (normally pending)
//
// Descript:   This function queries the appropriate object for some information
//
// ----------------------------------------------------------------------------

NTSTATUS
TSQueryInfo(PGENERIC_HEADER   pGenericHeader,
            PSEND_BUFFER      pSendBuffer,
            PIRP              pUpperIrp)
{
   ULONG ulQueryId = pSendBuffer->COMMAND_ARGS.ulQueryId;

   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint2("\nCommand = ulQUERYINFO\n"
                  "FileObject = %p\n"
                  "QueryId    = 0x%08x\n",
                   pGenericHeader,
                   ulQueryId);
   }

   //
   // allocate all the necessary structures
   //
   PQUERY_CONTEXT pQueryContext = NULL;
   PUCHAR         pucBuffer = NULL;
   PMDL           pQueryMdl = NULL;


   // first, our context
   //
   if ((TSAllocateMemory((PVOID *)&pQueryContext,
                          sizeof(QUERY_CONTEXT),
                          strFunc1,
                          "QueryContext")) != STATUS_SUCCESS)
   {
      goto cleanup;
   }
   
   //
   // next the data buffer (for the mdl)
   //
   if ((TSAllocateMemory((PVOID *)&pucBuffer,
                          ulMAX_BUFFER_LENGTH,
                          strFunc1,
                          "pucBuffer")) != STATUS_SUCCESS)
   {
      goto cleanup;
   }

   //
   // then the actual mdl
   //
   pQueryMdl = TSAllocateBuffer(pucBuffer, 
                                ulMAX_BUFFER_LENGTH);

   if (pQueryMdl)
   {
      pQueryContext->pUpperIrp      = pUpperIrp;
      pQueryContext->pLowerMdl      = pQueryMdl;
      pQueryContext->pucLowerBuffer = pucBuffer;

      //
      // finally, the irp itself
      //
      PIRP  pLowerIrp = TSAllocateIrp(pGenericHeader->pDeviceObject,
                                      NULL);

      if (pLowerIrp)
      {
         //
         // if made it to here, everything is correctly allocated
         // set up irp and call the tdi provider
         //

#pragma  warning(disable: CONSTANT_CONDITIONAL)

         TdiBuildQueryInformation(pLowerIrp,
                                  pGenericHeader->pDeviceObject,
                                  pGenericHeader->pFileObject,
                                  TSQueryComplete,
                                  pQueryContext,
                                  ulQueryId,
                                  pQueryMdl);

#pragma  warning(default: CONSTANT_CONDITIONAL)

         //
         // make the call to the tdi provider
         //
         pSendBuffer->pvLowerIrp = pLowerIrp;   // so command can be cancelled

         NTSTATUS lStatus = IoCallDriver(pGenericHeader->pDeviceObject,
                                         pLowerIrp);

         if ((!NT_SUCCESS(lStatus)) && (ulDebugLevel & ulDebugShowCommand))
         {
            DebugPrint2("%s: unexpected status for IoCallDriver [0x%08x]\n", 
                         strFunc1,
                         lStatus);
         }
         return STATUS_PENDING;
      }
   }


//
// get to here if there was an error
//
cleanup:
   if (pQueryContext)
   {
      TSFreeMemory(pQueryContext);
   }
   if (pucBuffer)
   {
      TSFreeMemory(pucBuffer);
   }
   if (pQueryMdl)
   {
      TSFreeBuffer(pQueryMdl);
   }

   return STATUS_INSUFFICIENT_RESOURCES;
}

/////////////////////////////////////////////////////////////
// private functions
/////////////////////////////////////////////////////////////


// ---------------------------------------------------------
//
// Function:   TSQueryComplete
//
// Arguments:  pDeviceObject  -- device object that called tdiquery
//             pIrp           -- IRP used in the call
//             pContext       -- context used for the call
//
// Returns:    status of operation (STATUS_MORE_PROCESSING_REQUIRED)
//
// Descript:   Gets the result of the query, stuffs results into
//             receive buffer, completes the IRP from the dll, and
//             cleans up the Irp and associated data from the query
//
// ---------------------------------------------------------

#pragma warning(disable: UNREFERENCED_PARAM)

TDI_STATUS
TSQueryComplete(PDEVICE_OBJECT   pDeviceObject,
                PIRP             pLowerIrp,
                PVOID            pvContext)


{
   PQUERY_CONTEXT    pQueryContext  = (PQUERY_CONTEXT)pvContext;
   NTSTATUS          lStatus        = pLowerIrp->IoStatus.Status;
   ULONG_PTR         ulCopyLength   = pLowerIrp->IoStatus.Information;
   PRECEIVE_BUFFER   pReceiveBuffer = TSGetReceiveBuffer(pQueryContext->pUpperIrp);

   pReceiveBuffer->lStatus = lStatus;

   if (NT_SUCCESS(lStatus))
   {
      pReceiveBuffer->RESULTS.QueryRet.ulBufferLength = (ULONG)ulCopyLength;
      if (ulCopyLength)
      {
         RtlCopyMemory(pReceiveBuffer->RESULTS.QueryRet.pucDataBuffer,
                       pQueryContext->pucLowerBuffer,
                       ulCopyLength);
      }
   }
   else if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint2("%s:  Completed with status 0x%08x\n", 
                   strFuncP1,
                   lStatus);
   }
   TSCompleteIrp(pQueryContext->pUpperIrp);

   //
   // now cleanup
   //
   TSFreeBuffer(pQueryContext->pLowerMdl);
   TSFreeMemory(pQueryContext->pucLowerBuffer);
   TSFreeMemory(pQueryContext);

   TSFreeIrp(pLowerIrp, NULL);
   return TDI_MORE_PROCESSING;
}

#pragma warning(default: UNREFERENCED_PARAM)


///////////////////////////////////////////////////////////////////////////////
// end of file tdiquery.cpp
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\sysvars.h ===
////////////////////////////////////////////////////////////////
//
// Copyright (c) 2001 Microsoft Corporation
//
// Module Name:
//    sysvars.h
//
// Abstract:
//     Definitions for driver portion of tdi sample driver
//
/////////////////////////////////////////////////////////////////

#include "glbconst.h"
extern "C"
{
#pragma warning(disable: NAMELESS_STRUCT_UNION)
#include "wdm.h"
#include "tdikrnl.h"
#pragma warning(default: NAMELESS_STRUCT_UNION)
}
#include "glbtypes.h"
#include <tdistat.h>

/////////////////////////////////////////////////////////////////
// debugging macros
/////////////////////////////////////////////////////////////////

#define DebugPrint0(fmt)                    DbgPrint(fmt)
#define DebugPrint1(fmt,v1)                 DbgPrint(fmt,v1)
#define DebugPrint2(fmt,v1,v2)              DbgPrint(fmt,v1,v2)
#define DebugPrint3(fmt,v1,v2,v3)           DbgPrint(fmt,v1,v2,v3)
#define DebugPrint4(fmt,v1,v2,v3,v4)        DbgPrint(fmt,v1,v2,v3,v4)
#define DebugPrint5(fmt,v1,v2,v3,v4,v5)     DbgPrint(fmt,v1,v2,v3,v4,v5)
#define DebugPrint6(fmt,v1,v2,v3,v4,v5,v6)  DbgPrint(fmt,v1,v2,v3,v4,v5,v6)
#define DebugPrint7(fmt,v1,v2,v3,v4,v5,v6,v7)     \
                                            DbgPrint(fmt,v1,v2,v3,v4,v5,v6,v7)
#define DebugPrint8(fmt,v1,v2,v3,v4,v5,v6,v7,v8)  \
                                            DbgPrint(fmt,v1,v2,v3,v4,v5,v6,v7,v8)


///////////////////////////////////////////////////////////////////////
// constant definitions
///////////////////////////////////////////////////////////////////////

//
// constants for GenericHeader->ulSignature
//
const ULONG ulINVALID_OBJECT        = 0x00000000;
const ULONG ulControlChannelObject  = 0x00001000;
const ULONG ulAddressObject         = 0x00002000;
const ULONG ulEndpointObject        = 0x00004000;

//
// number of irps in irp pool
//
const ULONG ulIrpPoolSize = 32;

//
// max number of open object handles
//
const ULONG    ulMAX_OBJ_HANDLES = 256;
const USHORT   usOBJ_HANDLE_MASK = 0x00FF;     // = 255
const USHORT   usOBJ_TYPE_MASK   = 0xF000;

///////////////////////////////////////////////////////////////////////
// type definitions
///////////////////////////////////////////////////////////////////////


//
// forward definitions
//
struct   DEVICE_CONTEXT;
struct   ENDPOINT_OBJECT;
struct   RECEIVE_DATA;
struct   USERBUF_INFO;

//
// structure used for spinlocks
//
struct TDI_SPIN_LOCK
{
   KSPIN_LOCK  SpinLock;
   KIRQL       OldIrql;
};
typedef TDI_SPIN_LOCK   *PTDI_SPIN_LOCK;

//
// event structure
//
typedef  KEVENT   TDI_EVENT, *PTDI_EVENT;


//
// structure used for list of address/device objects that can be opened
// (maintained via the TSPnpAdd/DelAddressCallback functions
//
struct   TDI_DEVICE_NODE
{
   PTA_ADDRESS       pTaAddress;                // address of object
   UNICODE_STRING    ustrDeviceName;            // name of object
   ULONG             ulState;
};
typedef  TDI_DEVICE_NODE   *PTDI_DEVICE_NODE;

//
// states for device nodes
//
const ULONG ulDEVSTATE_UNUSED  = 0;
const ULONG ulDEVSTATE_DELETED = 1;
const ULONG ulDEVSTATE_INUSE   = 2;
const ULONG ulMAX_DEVICE_NODES = 64;

//
// actual array structure
//
struct  TDI_DEVNODE_LIST
{
   TDI_SPIN_LOCK     TdiSpinLock;      // protects DeviceNode list
   TDI_DEVICE_NODE   TdiDeviceNode[ulMAX_DEVICE_NODES];
};
typedef TDI_DEVNODE_LIST   *PTDI_DEVNODE_LIST;

// structure used for IRP array, used with AddressObjects and Endpoints
// so that we don't have to allocates IRPs in a callback.
//
struct   IRP_POOL
{
   TDI_SPIN_LOCK  TdiSpinLock;         // protects rest of structure
   BOOLEAN        fMustFree;           // true if stangler must free pool
   ULONG          ulPoolSize;          // number of entries in pool
   PIRP           pAvailIrpList;       // irps available to be used
   PIRP           pUsedIrpList;        // irps that have been used
   PIRP           pAllocatedIrp[1];    // all irps in pool
};
typedef  IRP_POOL *PIRP_POOL;

//
// this structure is at the beginning of all the nodes, allows generic functions
// to be used for inserting/deleting nodes
//
struct   GENERIC_HEADER
{
   ULONG          ulSignature;         // type of block
   BOOLEAN        fInCommand;          // true if dealing with command
   GENERIC_HEADER *pPrevNode;          // ptr to previous node -- same type
   GENERIC_HEADER *pNextNode;          // ptr to next node -- same type
   TDI_EVENT      TdiEvent;            // event for CloseAddress/CloseEndpoint
   NTSTATUS       lStatus;
   HANDLE         FileHandle;          // handle of device
   PFILE_OBJECT   pFileObject;         // ptr to file object for handle
   PDEVICE_OBJECT pDeviceObject;       // ptr to device object for handle
};
typedef GENERIC_HEADER  *PGENERIC_HEADER;


//
// structure for control channel object
//
struct   CONTROL_CHANNEL
{
   GENERIC_HEADER GenHead;
};
typedef CONTROL_CHANNEL *PCONTROL_CHANNEL;


//
// structure for address object
//
struct   ADDRESS_OBJECT
{
   GENERIC_HEADER    GenHead;
   ENDPOINT_OBJECT   *pEndpoint;          // associate connection endpoint, if any
   TDI_SPIN_LOCK     TdiSpinLock;         // protects receive queue
   RECEIVE_DATA      *pHeadReceiveData;   // head of normal rcv queue
   RECEIVE_DATA      *pTailReceiveData;   // tail of normal rcv queue
   RECEIVE_DATA      *pHeadRcvExpData;    // head of expedited rcv queue
   RECEIVE_DATA      *pTailRcvExpData;    // tail of expedited rcv queue
   PIRP_POOL         pIrpPool;            // preallocated irps
   USERBUF_INFO      *pHeadUserBufInfo;   // linked list of posted buffers
   USERBUF_INFO      *pTailUserBufInfo;
};
typedef  ADDRESS_OBJECT *PADDRESS_OBJECT;


//
// structure for endpoint connection object
//
struct   ENDPOINT_OBJECT
{
   GENERIC_HEADER    GenHead;
   PADDRESS_OBJECT   pAddressObject;      // associate address object (if any)
   BOOLEAN           fIsConnected;        // true if connection established
   BOOLEAN           fAcceptInProgress;   // true if in process of accepting connection
   BOOLEAN           fIsAssociated;       // true if associated with address object
   BOOLEAN           fStartedDisconnect;
};
typedef  ENDPOINT_OBJECT *PENDPOINT_OBJECT;


//
// structure used to store data received (used for both receive 
// and receive datagram)
//
struct   RECEIVE_DATA
{
   RECEIVE_DATA   *pNextReceiveData;      // next in list
   RECEIVE_DATA   *pPrevReceiveData;      // prev in list
   PUCHAR         pucDataBuffer;          // buffer of received data
   ULONG          ulBufferLength;         // total length of buffer
   ULONG          ulBufferUsed;           // bytes used in buffer
   TRANSADDR      TransAddr;              // address received from  (rd only)
};
typedef  RECEIVE_DATA   *PRECEIVE_DATA;


//
// all objects opened by this driver
//
struct   OBJECT_LIST
{
   TDI_SPIN_LOCK     TdiSpinLock;      // protects openinfo array
   PGENERIC_HEADER   GenHead[ulMAX_OBJ_HANDLES];     // open handles controlled by driver
};
typedef  OBJECT_LIST *POBJECT_LIST;

//
// Device Driver data struct definition
//
// Device Context - hanging off the end of the DeviceObject for the
// driver the device context contains the control structures used
// to administer the tdi sample
//

struct DEVICE_CONTEXT
{
   DEVICE_OBJECT     DeviceObject;     // the I/O system's device object.
   ULONG             ulOpenCount;      // Number of outstanding opens of driver
   PIRP              pLastCommandIrp;  // irp of last submitted command
   BOOLEAN           fInitialized;     // TRUE if TdiTestInit succeeded
};
typedef DEVICE_CONTEXT *PDEVICE_CONTEXT;


//////////////////////////////////////////////////////////////////////
// externs for global variables
//////////////////////////////////////////////////////////////////////


#ifdef   _IN_MAIN_

ULONG             ulDebugLevel;           // show command info?
PVOID             pvMemoryList;           // head of alloced memory list
TDI_SPIN_LOCK     MemTdiSpinLock;         // protects pvMemoryList
PTDI_DEVNODE_LIST pTdiDevnodeList;        // list of devices
POBJECT_LIST      pObjectList;            // list of opened objects

#else

extern   ULONG             ulDebugLevel;
extern   PVOID             pvMemoryList;
extern   TDI_SPIN_LOCK     MemTdiSpinLock;
extern   PTDI_DEVNODE_LIST pTdiDevnodeList;
extern   POBJECT_LIST      pObjectList;

#endif

#include "sysprocs.h"

/////////////////////////////////////////////////////////////////////
// end of file sysvars.h
/////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\sysprocs.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2001  Microsoft Corporation
//
// Module Name:
//     sysprocs.hpp
//
// Abstract:
//     Function prototypes for tdi sample driver.
//
//////////////////////////////////////////////////////////////////////////


//
// public functions in buffer.cpp
//
NTSTATUS
TSPostReceiveBuffer(
   PGENERIC_HEADER   pGenericHeader,
   PSEND_BUFFER      pSendBuffer
   );

NTSTATUS
TSFetchReceiveBuffer(
   PGENERIC_HEADER   pGenericHeader,
   PRECEIVE_BUFFER   pReceiveBuffer
   );

//
// public functions in connect.cpp
//

NTSTATUS
TSConnect(
   PENDPOINT_OBJECT  pEndpointObject,
   PSEND_BUFFER      pSendBuffer,
   PIRP              pIrp
   );

NTSTATUS
TSDisconnect(
   PENDPOINT_OBJECT  pEndpointObject,
   PSEND_BUFFER      pSendBuffer,
   PIRP              pIrp
   );

NTSTATUS
TSListen(
   PENDPOINT_OBJECT  pEndpointObject
   );


NTSTATUS
TSIsConnected(
   PENDPOINT_OBJECT  pEndpointObject,
   PRECEIVE_BUFFER   pReceiveBuffer
   );

TDI_STATUS
TSConnectHandler(
   PVOID                TdiEventContext,
   LONG                 RemoteAddressLength,
   PVOID                RemoteAddress,
   LONG                 UserDataLength,
   PVOID                UserData,
   LONG                 OptionsLength,
   PVOID                Options,
   CONNECTION_CONTEXT   *ConnectionContext,
   PIRP                 *AcceptIrp
   );


TDI_STATUS
TSDisconnectHandler(
   PVOID                TdiEventContext,
   CONNECTION_CONTEXT   ConnectionContext,
   LONG                 DisconnectDataLength,
   PVOID                DisconnectData,
   LONG                 DisconnectInformationLength,
   PVOID                DisconnectInformation,
   ULONG                DisconnectFlags
   );


//
// public functions in events.cpp
//
NTSTATUS
TSSetEventHandler(
   PGENERIC_HEADER   pGenericHeader,
   PSEND_BUFFER      pSendBuffer,
   PIRP              pIrp
   );

//
// public functions in open.cpp
//

NTSTATUS
TSOpenControl(
   PSEND_BUFFER      pSendBuffer,
   PRECEIVE_BUFFER   pReceiveBuffer
   );


VOID
TSCloseControl(
   PCONTROL_CHANNEL  pControlChannel
   );


NTSTATUS
TSOpenAddress(
   PSEND_BUFFER      pSendBuffer,
   PRECEIVE_BUFFER   pReceiveBuffer
   );


VOID
TSCloseAddress(
   PADDRESS_OBJECT   pAddressObject
   );



NTSTATUS
TSOpenEndpoint(
   PSEND_BUFFER      pSendBuffer,
   PRECEIVE_BUFFER   pReceiveBuffer
   );


VOID
TSCloseEndpoint(
   PENDPOINT_OBJECT  pEndpoint
   );


//
// public functions from recvcom.cpp
//
VOID
TSPacketReceived(
   PADDRESS_OBJECT   pAddressObject,
   PRECEIVE_DATA     pReceiveData,
   BOOLEAN           fIsExpedited
   );


VOID
TSFreePacketData(
   PADDRESS_OBJECT   pAddressObject
   );


//
// locks down user buffer, maps to kernel space
//
PMDL
TSMakeMdlForUserBuffer(
   PUCHAR   pucDataBuffer, 
   ULONG    ulDataLength,
   LOCK_OPERATION AccessType
   );

//
// unmaps and unlocks user buffer
//
inline
VOID
TSFreeUserBuffer(PMDL  pMdl)
{
   MmUnlockPages(pMdl);
   IoFreeMdl(pMdl);
}

//
// public functions in rcvdgram.cpp
//
NTSTATUS
TSReceiveDatagram(
   PADDRESS_OBJECT   pAddressObject,
   PSEND_BUFFER      pSendBuffer,
   PRECEIVE_BUFFER   pReceiveBuffer
   );


TDI_STATUS
TSRcvDatagramHandler(
   PVOID    pvTdiEventContext,
   LONG     lSourceAddressLength,
   PVOID    pvSourceAddress,
   LONG     lOptionsLength,
   PVOID    pvOptions,
   ULONG    ulReceiveDatagramFlags,
   ULONG    ulBytesIndicated,
   ULONG    ulBytesAvailable,
   ULONG    *pulBytesTaken,
   PVOID    pvTsdu,
   PIRP     *pIoRequestPacket
   );


TDI_STATUS
TSChainedRcvDatagramHandler(
   PVOID    TdiEventContext,
   LONG     SourceAddressLength,
   PVOID    SourceAddress,
   LONG     OptionsLength,
   PVOID    Options,
   ULONG    ReceiveDatagramFlags,
   ULONG    ReceiveDatagramLength,
   ULONG    StartingOffset,
   PMDL     Tsdu,
   PVOID    TsduDescriptor
   );


//
// public functions in receive.cpp
//
NTSTATUS
TSReceive(
   PENDPOINT_OBJECT  pEndpointObject,
   PSEND_BUFFER      pSendBuffer,
   PRECEIVE_BUFFER   pReceiveBuffer
   );


TDI_STATUS
TSReceiveHandler(
   PVOID                TdiEventContext,
   CONNECTION_CONTEXT   ConnectionContext,
   ULONG                ReceiveFlags,
   ULONG                BytesIndicated,
   ULONG                BytesAvailable,
   ULONG                *BytesTaken,
   PVOID                Tsdu,
   PIRP                 *IoRequestPacket
   );

TDI_STATUS
TSRcvExpeditedHandler(
   PVOID                TdiEventContext,
   CONNECTION_CONTEXT   ConnectionContext,
   ULONG                ReceiveFlags,
   ULONG                BytesIndicated,
   ULONG                BytesAvailable,
   ULONG                *BytesTaken,
   PVOID                Tsdu,
   PIRP                 *IoRequestPacket
   );


TDI_STATUS
TSChainedReceiveHandler(
   PVOID                TdiEventContext,
   CONNECTION_CONTEXT   ConnectionContext,
   ULONG                ReceiveFlags,
   ULONG                ReceiveLength,
   ULONG                StartingOffset,
   PMDL                 Tsdu,
   PVOID                TsduDescriptor
   );


TDI_STATUS
TSChainedRcvExpeditedHandler(
   PVOID                TdiEventContext,
   CONNECTION_CONTEXT   ConnectionContext,
   ULONG                ReceiveFlags,
   ULONG                ReceiveLength,
   ULONG                StartingOffset,
   PMDL                 Tsdu,
   PVOID                TsduDescriptor
   );

//
// public functions in request.cpp
//
NTSTATUS
TSIssueRequest(
   IN PDEVICE_CONTEXT      pDeviceContext,
   IN PIRP                 pIrp,
   IN PIO_STACK_LOCATION   pIrpSp
   );

//
// public functions in send.cpp
//
NTSTATUS
TSSendDatagram(
   PADDRESS_OBJECT   pAddressObject,
   PSEND_BUFFER      pSendBuffer,
   PIRP              pIrp
   );


NTSTATUS
TSSend(
   PENDPOINT_OBJECT  pEndpointObject,
   PSEND_BUFFER      pSendBuffer,
   PIRP              pIrp
   );


//
// functions in tdipnp.cpp
//
VOID
TSPnpBindCallback(
   TDI_PNP_OPCODE    opcode,
   PUNICODE_STRING   devname,
   PWSTR             multiszstring
   );

NTSTATUS
TSPnpPowerHandler(
   PUNICODE_STRING   devname,
   PNET_PNP_EVENT    pnpevent,
   PTDI_PNP_CONTEXT  Context1,
   PTDI_PNP_CONTEXT  Context2
   );


VOID
TSPnpAddAddressCallback(
   PTA_ADDRESS       Address,
   PUNICODE_STRING   DeviceName,
   PTDI_PNP_CONTEXT  Context
   );

VOID
TSPnpDelAddressCallback(
   PTA_ADDRESS       Address,
   PUNICODE_STRING   DeviceName,
   PTDI_PNP_CONTEXT  Context
   );

VOID
TSGetNumDevices(
   PSEND_BUFFER      pSendBuffer,
   PRECEIVE_BUFFER   pReceiveBuffer
   );

NTSTATUS
TSGetDevice(
   PSEND_BUFFER      pSendBuffer,
   PRECEIVE_BUFFER   pReceiveBuffer
   );

NTSTATUS
TSGetAddress(
   PSEND_BUFFER      pSendBuffer,
   PRECEIVE_BUFFER   pReceiveBuffer
   );

//
// functions in tdiquery.cpp
//
NTSTATUS
TSQueryInfo(
   PGENERIC_HEADER   pGenericHeader,
   PSEND_BUFFER      pSendBuffer,
   PIRP              pIrp
   );


//
// functions in utils.cpp
//
NTSTATUS
TSAllocateMemory(
   OUT PVOID         *ppvVirtualAddress,
   IN  ULONG         ulLength,
   IN  CONST PCHAR   strFunction,
   IN  CONST PCHAR   strTitle
   );

VOID
TSFreeMemory(
   IN PVOID    pvVirtualAddress
   );


VOID
TSScanMemoryPool(
   VOID
   );

ULONG
TSInsertNode(
   PGENERIC_HEADER   pNewNode
   );

VOID
TSRemoveNode(
   ULONG    ulTdiHandle
   );


PIRP
TSAllocateIrp(
   PDEVICE_OBJECT    pDeviceObject,
   PIRP_POOL         pIrpPool
   );


VOID
TSFreeIrp(
   PIRP        pIrp,
   PIRP_POOL   pIrpPool
   );

VOID
TSPrintTaAddress(
  PTA_ADDRESS ptaaddr
  );


PIRP_POOL
TSAllocateIrpPool(
   PDEVICE_OBJECT pDeviceObject,
   ULONG          ulPoolSize
   );


VOID
TSFreeIrpPool(
   PIRP_POOL   pIrpPool
   );

PGENERIC_HEADER
TSGetObjectFromHandle(
   ULONG      ulTdiHandle,
   ULONG      ulType
   );


//
// inline functions...
//
inline
PRECEIVE_BUFFER 
TSGetReceiveBuffer(PIRP  pIrp)
{
   return (PRECEIVE_BUFFER)MmGetSystemAddressForMdl(pIrp->MdlAddress);
}

inline
PSEND_BUFFER   
TSGetSendBuffer(PIRP   pIrp)
{
   return (PSEND_BUFFER)pIrp->AssociatedIrp.SystemBuffer;
}

inline
PMDL
TSAllocateBuffer(PVOID   pvAddress,
                 ULONG   ulLength)
{
   PMDL  pMdl
         = IoAllocateMdl(pvAddress,
                         ulLength,
                         FALSE,
                         FALSE,
                         NULL);
   if (pMdl)
   {
      MmBuildMdlForNonPagedPool(pMdl);
   }
   return pMdl;
}

inline
VOID
TSFreeBuffer(PMDL  pMdl)
{
   IoFreeMdl(pMdl);
}



inline
VOID 
TSCompleteIrp(PIRP  pIrp)
{
   PSEND_BUFFER   pSendBuffer = TSGetSendBuffer(pIrp);

   pSendBuffer->pvLowerIrp = NULL;
   ((PDEVICE_CONTEXT)pSendBuffer->pvDeviceContext)->pLastCommandIrp = NULL;

   pIrp->IoStatus.Status = STATUS_SUCCESS;
   IoMarkIrpPending(pIrp);
   IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
}

//
// spinlock and timer functions, mostly stolen from ndis
//
inline
VOID
TSAllocateSpinLock(PTDI_SPIN_LOCK pTdiSpinLock)
{
   KeInitializeSpinLock(&pTdiSpinLock->SpinLock);
}


#pragma warning(disable: UNREFERENCED_PARAM)
inline
VOID
TSFreeSpinLock(PTDI_SPIN_LOCK   pTdiSpinLock)
{

}
#pragma warning(default: UNREFERENCED_PARAM)

inline
VOID
TSAcquireSpinLock(PTDI_SPIN_LOCK   pTdiSpinLock)
{
   KeAcquireSpinLock(&pTdiSpinLock->SpinLock, 
                     &pTdiSpinLock->OldIrql);
}

inline
VOID
TSReleaseSpinLock(PTDI_SPIN_LOCK   pTdiSpinLock)
{
   KeReleaseSpinLock(&pTdiSpinLock->SpinLock,
                     pTdiSpinLock->OldIrql);
}


inline
VOID
TSInitializeEvent(PTDI_EVENT   pTdiEvent)
{
   KeInitializeEvent(pTdiEvent,
                     NotificationEvent,
                     FALSE);
}

inline
VOID
TSWaitEvent(PTDI_EVENT   pTdiEvent)
{
   KeWaitForSingleObject(pTdiEvent,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL);
}

inline
VOID
TSSetEvent(PTDI_EVENT pTdiEvent)
{
   KeSetEvent(pTdiEvent,
              0,
              FALSE);
}


/////////////////////////////////////////////////////////////////////////
// end of file sysprocs.hpp
/////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\tdisample.cpp ===
////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2001  Microsoft Corporation
//
// Module Name:
//    tdisample.cpp
//
// Abstract:
//    This module contains functions called directly from the system,
//    at startup(DriverEntry), at shutdown(TdiUnloadDriver), and to service
//    requests (TdiDispatch).  It also contains functions called only by
//    DriverEntry.
//
/////////////////////////////////////////////////////////////////////////////


#define  _IN_MAIN_
#include "sysvars.h"


///////////////////////////////////////////////////////////////////////////
// local constants, prototypes, and variables
///////////////////////////////////////////////////////////////////////////

const PWCHAR wstrDD_TDI_DEVICE_NAME  = L"\\Device\\TdiSample";
const PWCHAR wstrDOS_DEVICE_NAME     = L"\\DosDevices\\TdiSample";


const PCHAR strFunc1  = "TSDriverEntry";
const PCHAR strFunc2  = "TSDispatch";
const PCHAR strFunc3  = "TSUnloadDriver";
//const PCHAR strFuncP1 = "TSCreateDeviceContext";
//const PCHAR strFuncP2 = "TSCreateSymbolicLinkObject";


HANDLE   hTdiSamplePnp;

////////////////////////////////////////////////////////////////////////////
// Local Prototypes
////////////////////////////////////////////////////////////////////////////


NTSTATUS
TSCreateSymbolicLinkObject(
   VOID
   );


NTSTATUS
TSDispatch(
   IN PDEVICE_OBJECT pDeviceObject,
   IN PIRP           pIrp
   );

VOID
TSUnloadDriver(
   IN PDRIVER_OBJECT pDriverObject
   );

NTSTATUS
TSCreateDeviceContext(
   IN PDRIVER_OBJECT       DriverObject,
   IN OUT PDEVICE_CONTEXT  *ppDeviceContext
   );


///////////////////////////////////////////////////////////////////////////
// Functions called from system
///////////////////////////////////////////////////////////////////////////


// -----------------------------------------------------------------
//
//    Function:   DriverEntry
//
//    Arguments:  DriverObject -- ptr to driver object created by the system
//                RegistryPath -- unreferenced parameter
//
//    Returns:    Final status of the initialization operation
//                (STATUS_SUCCESS if no error, else error code)
//
//    Descript:   This routine performs initialization of the tdi sample
//                driver.  It creates the device objects for the driver and
//                performs other driver initialization.
//
// -----------------------------------------------------------------


#pragma warning(disable: UNREFERENCED_PARAM)



extern "C"
NTSTATUS
DriverEntry(PDRIVER_OBJECT    pDriverObject,
            PUNICODE_STRING   pRegistryPath)

{
   PDEVICE_CONTEXT   pDeviceContext;   // device context (to create)
   NTSTATUS          lStatus;          // status of operations

   //
   // General Version Information
   //
   TSAllocateSpinLock(&MemTdiSpinLock);

   DebugPrint1("\nTdiSample Driver for Windows2000/WindowsXP -- Built %s \n\n",
               __DATE__);

   //
   // show the version id...
   //
   DebugPrint1("TdiSample version %s\n\n", VER_FILEVERSION_STR);

   //
   // First initialize the DeviceContext struct,
   //
   lStatus = TSCreateDeviceContext(pDriverObject,
                                   &pDeviceContext);

   if (!NT_SUCCESS (lStatus))
   {
      DebugPrint2("%s: failed to create device context: Status = 0x%08x\n",
                   strFunc1,
                   lStatus);
      return lStatus;
   }

   //
   // Create symbolic link between the Dos Device name and Nt
   // Device name for the test protocol driver.
   //
   lStatus = TSCreateSymbolicLinkObject();
   if (!NT_SUCCESS(lStatus))
   {
      DebugPrint2("%s: failed to create symbolic link. Status = 0x%08x\n",
                   strFunc1,
                   lStatus);
      return lStatus;
   }

   //
   // put on debug for handlers during pnp callbacks
   //
   ulDebugLevel  = ulDebugShowHandlers;
   
   //
   // allocate all necessary memory blocks
   //

   if ((TSAllocateMemory((PVOID *)&pTdiDevnodeList,
                          sizeof(TDI_DEVNODE_LIST),
                          strFunc1,
                          "DevnodeList")) == STATUS_SUCCESS)
   {
      if ((TSAllocateMemory((PVOID *)&pObjectList,
                             sizeof(OBJECT_LIST),
                             strFunc1,
                             "ObjectList")) != STATUS_SUCCESS)
      {
         TSFreeMemory(pTdiDevnodeList);
         return STATUS_UNSUCCESSFUL;
      }
   }
   else
   {
      return STATUS_UNSUCCESSFUL;
   }

   TSAllocateSpinLock(&pTdiDevnodeList->TdiSpinLock);


   //
   // register pnp handlers
   //
   UNICODE_STRING             Name;
   TDI_CLIENT_INTERFACE_INFO  ClientInfo;

   RtlInitUnicodeString(&Name, L"TDISAMPLE");
   ClientInfo.MajorTdiVersion = 2;
   ClientInfo.MinorTdiVersion = 0;
   ClientInfo.ClientName = &Name;

   ClientInfo.BindingHandler       = TSPnpBindCallback;
   ClientInfo.AddAddressHandlerV2  = TSPnpAddAddressCallback;
   ClientInfo.DelAddressHandlerV2  = TSPnpDelAddressCallback;
   ClientInfo.PnPPowerHandler      = TSPnpPowerHandler;

   lStatus = TdiRegisterPnPHandlers(&ClientInfo,
                                    sizeof(TDI_CLIENT_INTERFACE_INFO),
                                    &hTdiSamplePnp);

   if (!NT_SUCCESS( lStatus ) ) 
   {
      DebugPrint1("TdiRegisterPnPHandlers: status 0x%08x\n", lStatus );
   } 

   //
   // default -- debug on for commands only
   //
   ulDebugLevel  = ulDebugShowCommand;

   TSAllocateSpinLock(&pObjectList->TdiSpinLock);

   return STATUS_SUCCESS;
}
#pragma warning(default: UNREFERENCED_PARAM)


// -------------------------------------------------------------
//
//    Function:   TSDispatch
//
//    Arguments:  pDeviceObject  -- ptr to the device object for this driver
//                pIrp           -- ptr to the request packet representing
//                                  the i/o request
//
//    Returns:    Status of the operation
//                (usually, STATUS_SUCCESS or STATUS_PENDING)
//
//    Descript:   This is the main dispatch routine for the tdisample driver.
//                It deals with requests that the dll sends via
//                DeviceIoControl.  It accepts an I/O request packet,
//                performs the request, and then returns the appropriate
//                status.  If there is an error, the exact error code will
//                be returned as part of the "return buffer"
//
// --------------------------------------------------------------

NTSTATUS
TSDispatch(PDEVICE_OBJECT  pDeviceObject,
           PIRP            pIrp)
{
   PDEVICE_CONTEXT      pDeviceContext    // get global data struct for driver
                        = (PDEVICE_CONTEXT)pDeviceObject;
   PIO_STACK_LOCATION   pIrpSp;           // ptr to DeviceIoControl args
   NTSTATUS             lStatus;          // status of operations

   //
   // Sanity check.  Driver better be initialized.
   //

   if (!pDeviceContext->fInitialized)
   {
      return STATUS_UNSUCCESSFUL;
   }


   //
   // initialize status information
   //
   pIrp->IoStatus.Information = 0;
   pIrp->IoStatus.Status = STATUS_PENDING;


   //
   // Get a pointer to the current stack location in the IRP.  This is where
   // the function codes and parameters are stored.
   //

   pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

   //
   // switch on the function that is being performed by the requestor.  If the
   // operation is a valid one for this device, then make it look like it
   // was successfully completed, where possible.
   //

   switch (pIrpSp->MajorFunction)
   {
      //
      // The Create function is called when the DLL tries to open the driver
      //
      case IRP_MJ_CREATE:
         lStatus = STATUS_SUCCESS;
         pDeviceContext->ulOpenCount++;
         DebugPrint2("\n%s: IRP_MJ_CREATE.  OpenCount = %d\n",
                      strFunc2,
                      pDeviceContext->ulOpenCount);
         break;

      //
      // The Close function is the second function called when the DLL tries
      // to close the driver.  It does nothing (all the work is done by the
      // first part -- IRP_MJ_CLEANUP
      //
      case IRP_MJ_CLOSE:
         DebugPrint1("\n%s: IRP_MJ_CLOSE.\n", strFunc2);
         lStatus = STATUS_SUCCESS;
         break;

      //
      // The DeviceControl function is the main interface to the tdi sample
      // driver.  Every request is has an Io Control
      // code that is used by this function to determine the routine to
      // call.  Returns either STATUS_PENDING or STATUS_SUCCESS
      //
      case IRP_MJ_DEVICE_CONTROL:
         IoMarkIrpPending(pIrp);
         lStatus = TSIssueRequest(pDeviceContext, pIrp, pIrpSp);
         break;

      //
      // Handle the two stage IRP for a file close operation. We really only
      // need to do this work when the last dll closes us.
      //
      case IRP_MJ_CLEANUP:
         if (!pDeviceContext->ulOpenCount)      // sanity check
         {
            DebugPrint1("\n%s: IRP_MJ_CLEANUP -- no active opens!\n", strFunc2);
            lStatus = STATUS_SUCCESS;         // what should happen here?
         }
         else
         {
            pDeviceContext->ulOpenCount--;
            DebugPrint2("\n%s: IRP_MJ_CLEANUP, OpenCount = %d\n",
                         strFunc2,
                         pDeviceContext->ulOpenCount);
            lStatus = STATUS_SUCCESS;
         }
         break;

      default:
         DebugPrint1("\n%s: OTHER (DEFAULT).\n", strFunc2);
         lStatus = STATUS_INVALID_DEVICE_REQUEST;

   }     // major function switch

   //
   // If the request did not pend, then complete it now, otherwise it
   // will be completed when the pending routine finishes.
   //

   if (lStatus != STATUS_PENDING)
   {
      pIrp->IoStatus.Status = STATUS_SUCCESS;
      IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);
   }

   //
   // Return the immediate status code to the caller.
   //
   return lStatus;
}


// ---------------------------------------------------------------
//
//    Function:   TSUnloadDriver
//
//    Arguments:  DriverObject -- ptr to the object for this driver
//
//    Returns:    none
//
//    Descript:   This function deals with cleanup if this driver is ever
//                unloaded by the system.
//
// ---------------------------------------------------------------

BOOLEAN  fInUnload = FALSE;

VOID
TSUnloadDriver(PDRIVER_OBJECT pDriverObject)
{
   if (fInUnload)
   {
      DebugPrint0("TSUnloadDriver:  re-entry!\n");
      return;
   }
   
   fInUnload = TRUE;

   PDEVICE_CONTEXT   pDeviceContext       // global data for driver
                     = (PDEVICE_CONTEXT)pDriverObject->DeviceObject;

   //
   // unload pnp handlers
   //
   NTSTATUS lStatus = TdiDeregisterPnPHandlers(hTdiSamplePnp);

   hTdiSamplePnp = NULL;

   if (lStatus != STATUS_SUCCESS) 
   {
      DebugPrint1("TdiDeregisterPnPHandlers:  0x%08x\n", lStatus);
   }


   //
   // free any device nodes that may still remain
   //
   for (ULONG ulCount = 0; ulCount < ulMAX_DEVICE_NODES; ulCount++)
   {
      PTDI_DEVICE_NODE  pTdiDeviceNode = &(pTdiDevnodeList->TdiDeviceNode[ulCount]);

      if (pTdiDeviceNode->ulState > ulDEVSTATE_UNUSED)
      {
         TSFreeMemory(pTdiDeviceNode->ustrDeviceName.Buffer);
         TSFreeMemory(pTdiDeviceNode->pTaAddress);
      }
   }

   TSFreeSpinLock(&pTdiDevnodeList->TdiSpinLock);
   TSFreeSpinLock(&pObjectList->TdiSpinLock);
   TSFreeMemory(pTdiDevnodeList);
   TSFreeMemory(pObjectList);
   TSScanMemoryPool();
   TSFreeSpinLock(&MemTdiSpinLock);

   //
   // Close the Dos Symbolic link to remove traces of the device
   //
   UNICODE_STRING    wstrDosUnicodeString;   // dosdevices string

   RtlInitUnicodeString(&wstrDosUnicodeString, wstrDOS_DEVICE_NAME);
   IoDeleteSymbolicLink(&wstrDosUnicodeString);

   //
   // Then delete the device object from the system.
   //
   IoDeleteDevice((PDEVICE_OBJECT)pDeviceContext);
}


////////////////////////////////////////////////////////////////////////////
// Local functions
////////////////////////////////////////////////////////////////////////////


// --------------------------------------------------------------
//
//    Function:   TSCreateDeviceContext
//
//    Arguments:  DriverObject  -- ptr to the IO subsystem supplied
//                                 driver object
//                DeviceContext -- ptr to a ptr to a transport device
//                                 context object
//
//    Returns:    STATUS_SUCCESS if ok, else error code
//                (probably STATUS_INSUFFICIENT_RESOURCES)
//
//    Descript:   Create and initialize the driver object for this driver
//
// --------------------------------------------------------------


NTSTATUS
TSCreateDeviceContext(PDRIVER_OBJECT   pDriverObject,
                      PDEVICE_CONTEXT  *ppDeviceContext)
{
   PDEVICE_OBJECT    pDeviceObject;       // local work copy of device object
   PDEVICE_CONTEXT   pLocDeviceContext;   // portion of device object
   NTSTATUS          lStatus;             // operation status
   UNICODE_STRING    wstrDeviceName;      // name of device

   //
   // set up the name of the device
   //
   RtlInitUnicodeString(&wstrDeviceName, wstrDD_TDI_DEVICE_NAME);

   //
   // Create the device object for tditest.sys
   //
   lStatus = IoCreateDevice(pDriverObject,
                            sizeof(DEVICE_CONTEXT) - sizeof(DEVICE_OBJECT),
                            &wstrDeviceName,
                            FILE_DEVICE_TRANSPORT,
                            0,
                            FALSE,
                            &pDeviceObject );

   if (!NT_SUCCESS(lStatus))
   {
      return lStatus;
   }

   pDeviceObject->Flags |= DO_DIRECT_IO;

   //
   // Initialize the driver object with this driver's entry points.
   //
   pDriverObject->MajorFunction [IRP_MJ_CREATE]  = TSDispatch;
   pDriverObject->MajorFunction [IRP_MJ_CLOSE]   = TSDispatch;
   pDriverObject->MajorFunction [IRP_MJ_CLEANUP] = TSDispatch;
   pDriverObject->MajorFunction [IRP_MJ_DEVICE_CONTROL] = TSDispatch;
   pDriverObject->DriverUnload = TSUnloadDriver;

   pLocDeviceContext = (PDEVICE_CONTEXT)pDeviceObject;

   //
   // Now initialize the Device Context structure Signatures.
   //
   pLocDeviceContext->fInitialized = TRUE;

   *ppDeviceContext = pLocDeviceContext;

   return STATUS_SUCCESS;
}


// -------------------------------------------------------------------
//
//    Function:   TSCreateSymbolicLinkObject
//
//    Arguments:  none
//
//    Returns:    status of the operation (STATUS_SUCCESS or error status)
//
//    Descript:   Set up a name for us so our dll can grab hold of us..
//
// -------------------------------------------------------------------

NTSTATUS
TSCreateSymbolicLinkObject(VOID)
{
   UNICODE_STRING    wstrDosUnicodeString;   // dosdevices string
   UNICODE_STRING    wstrNtUnicodeString;    // nt device name

   RtlInitUnicodeString(&wstrDosUnicodeString, wstrDOS_DEVICE_NAME);
   RtlInitUnicodeString(&wstrNtUnicodeString, wstrDD_TDI_DEVICE_NAME);


   return  IoCreateSymbolicLink(&wstrDosUnicodeString, &wstrNtUnicodeString);
}



////////////////////////////////////////////////////////////////////////////
// end of file tditest.cpp
////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\utils.cpp ===
////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       utils.cpp
//
//    Abstract:
//       This module contains some utility functions for the tdi sample driver
//
/////////////////////////////////////////////////////////////////////

#include "sysvars.h"


/////////////////////////////////////////////////////
// private constants
/////////////////////////////////////////////////////


//const PCHAR strFunc1 = "TSAllocateMemory";
const PCHAR strFunc2 = "TSFreeMemory";
const PCHAR strFunc3 = "TSScanMemoryPool";
//const PCHAR strFunc4 = "TSInsertNode";
const PCHAR strFunc5 = "TSRemoveNode";
const PCHAR strFunc6 = "TSGetObjectFromHandle";
//const PCHAR strFunc6 = "TSAllocateIrp";
//const PCHAR strFunc7 = "TSFreeIrp";
//const PCHAR strFunc8 = "TSPrintTaAddress";
const PCHAR strFunc9 = "TSllocateIrpPool";
const PCHAR strFuncA = "TSFreeIrpPool";

////////////////////////////////////////////////////
// public functions
////////////////////////////////////////////////////


// --------------------------------------------------------------------
//
//    Function:   TSAllocateMemory
//
//    Arguments:  ppvVirtualAddress -- addr of pointer to set to allocated block
//                ulLength          -- length of memory to allocate
//                strFunction       -- ptr to function name string
//                strTitle          -- ptr to title of this allocation
//
//    Returns:    lStatus 
//
//    Descript:   This function acts as a wrapper for the ExAllocatePoolWithTag
//                function.  It also stores info for each memory block that can
//                identify them in case of "memory leaks"
//
// ---------------------------------------------------------------------

//
// this structure store information about this memory block to allow
// us to track memory blocks, and verify that they are freed properly, that
// we don't write beyond the end of them, etc
//
struct PRIVATE_MEMORY
{
   ULONG          ulSignature;      // ulMEMORY_BLOCK
   PCHAR          strFunction;      // name of function doing allocate
   PCHAR          strTitle;         // Title for specific allocate
   ULONG          ulLength;         // ulong index of trailer (=(length/4)-1
   PRIVATE_MEMORY *pLastMemPtr;     // ptr to last allocated block
   PRIVATE_MEMORY *pNextMemPtr;     // ptr to next allocated block
};

const ULONG ulTRAIL_PATTERN = 0x0f1e2d3c;
const ULONG ulMEMORY_BLOCK  = 0x4b5a6978;
#define  TDISAMPLE_TAG   'aSDT'


NTSTATUS
TSAllocateMemory(PVOID        *ppvVirtualAddress,
                 ULONG        ulLength,
                 CONST PCHAR  strFunction,
                 CONST PCHAR  strTitle)
{
   PVOID pvBaseMemory;     // base -- where actual memory allocated

   //
   // allocate for length plus header plus trailer, rounded up to next dword
   //
   ulLength += (sizeof(PRIVATE_MEMORY) + sizeof(ULONG) + 3);
   ulLength &= 0xfffffffc;

   //
   // allocate it
   //
   pvBaseMemory = ExAllocatePoolWithTag(NonPagedPool,
                                        ulLength,
                                        TDISAMPLE_TAG);

   //
   // things to do if allocation was successful
   //
   if (pvBaseMemory)
   {
      //
      // zero the memory
      //
      RtlZeroMemory(pvBaseMemory, ulLength);

      //
      // set up our header and trailer info
      //
      PRIVATE_MEMORY *pPrivateMemory   // our header information
                     = (PRIVATE_MEMORY *)pvBaseMemory;
      PULONG         pulBase
                     = (PULONG)pvBaseMemory;
      //
      // adjust the ptr we return to allocated memory
      //
      *ppvVirtualAddress = (PUCHAR)pvBaseMemory + sizeof(PRIVATE_MEMORY);

      //
      // set up our header information
      //
      ulLength /= sizeof(ULONG);       // set ulLength to ulong index of trailer
      --ulLength;

      pPrivateMemory->ulSignature = ulMEMORY_BLOCK;
      pPrivateMemory->strFunction = strFunction;
      pPrivateMemory->strTitle    = strTitle;
      pPrivateMemory->ulLength    = ulLength;

      //
      // set up the trailer information
      //
      pulBase[ulLength] = ulTRAIL_PATTERN;

      //
      // insert at head of linked list..
      // (note that memory is already initialized to null)
      //
      TSAcquireSpinLock(&MemTdiSpinLock);
      if (pvMemoryList)
      {
         ((PRIVATE_MEMORY *)pvMemoryList)->pLastMemPtr = pPrivateMemory;
         pPrivateMemory->pNextMemPtr = (PRIVATE_MEMORY *)pvMemoryList;
      }
      pvMemoryList = pPrivateMemory;
      TSReleaseSpinLock(&MemTdiSpinLock);

      return STATUS_SUCCESS;
   }
   else
   {
      DebugPrint3("%s:  unable to allocate %u bytes for %s\n", 
                   strFunction, ulLength, strTitle);
      *ppvVirtualAddress = NULL;
      return STATUS_INSUFFICIENT_RESOURCES;
   }
}


// -------------------------------------------------------------------
//
//    Function:   TSFreeMemory
//
//    Arguments:  pvVirtualAddress -- address of memory block to free
//
//    Returns:    None
//
//    Descript:   This function is a wrapper around the ExFreePool
//                function.  it helps track memory
//                to make sure that we cleanup up everything...
//
// --------------------------------------------------------------------

VOID
TSFreeMemory(PVOID   pvVirtualAddress)
{
   if (pvVirtualAddress == NULL)
   {
      DebugPrint1("%s:  memory block already freed!\n", strFunc2);
      DbgBreakPoint();
      return;
   }

   //
   // back up to start of header information
   //
   pvVirtualAddress = (PVOID)((PUCHAR)pvVirtualAddress - sizeof(PRIVATE_MEMORY));


   PRIVATE_MEMORY *pPrivateMemory      // ptr to our header block
                  = (PRIVATE_MEMORY *)pvVirtualAddress;
   PULONG         pulTemp              // temp ptr into allocated block
                  = (PULONG)pvVirtualAddress;
   ULONG          ulLength
                  = pPrivateMemory->ulLength;
   //
   // is this a valid memory block?
   //
   if (pPrivateMemory->ulSignature != ulMEMORY_BLOCK)
   {
      DebugPrint2("%s:  invalid memory block at %p!\n",
                   strFunc2,
                   pPrivateMemory);
      DbgBreakPoint();
      return;
   }

   //
   // check that the trailer is still ok
   //
   if (pulTemp[ulLength] != ulTRAIL_PATTERN)
   {
      DebugPrint2("%s:  trailer overwritten for block staring at %p\n",
                   strFunc2,
                   pPrivateMemory);
      DbgBreakPoint();
      return;
   }

   //
   // remove it from the linked list..
   //
   TSAcquireSpinLock(&MemTdiSpinLock);

   //
   // is it first block in list?
   //
   if (pPrivateMemory->pLastMemPtr == (PRIVATE_MEMORY *)NULL)
   {
      pvMemoryList = pPrivateMemory->pNextMemPtr;
   }
   else
   {
      PRIVATE_MEMORY *pLastPrivateMemory
                     = pPrivateMemory->pLastMemPtr;
      pLastPrivateMemory->pNextMemPtr = pPrivateMemory->pNextMemPtr;
   }

   //
   // fix ptr of next memory block if necessary
   //
   if (pPrivateMemory->pNextMemPtr != (PVOID)NULL)
   {
      PRIVATE_MEMORY *pNextPrivateMemory
                     = pPrivateMemory->pNextMemPtr;
      pNextPrivateMemory->pLastMemPtr = pPrivateMemory->pLastMemPtr;
   }
   TSReleaseSpinLock(&MemTdiSpinLock);

   //
   // zero memory and free--make sure we adjust ulLength to be the true length
   //
   RtlZeroMemory(pvVirtualAddress, sizeof(ULONG) * (ulLength + 1));
   ExFreePool(pvVirtualAddress);

}

// -------------------------------------------------------------------
//
// Function:   TSScanMemoryPool
//
// Arguments:  none
//
// Returns:    none
//
// Descript:   Scans to see if any tdi sample owned memory blocks have 
//             not been freed
//
// -------------------------------------------------------------------

VOID
TSScanMemoryPool(VOID)
{
   TSAcquireSpinLock(&MemTdiSpinLock);
   if (pvMemoryList)
   {
      PRIVATE_MEMORY *pPrivateMemory   // our header information
                     = (PRIVATE_MEMORY *)pvMemoryList;
      PULONG         pulTemp;

      DebugPrint0("The following memory blocks have not been freed!\n");
      while (pPrivateMemory)
      {
         //
         // is this a valid memory block?
         //
         if (pPrivateMemory->ulSignature != ulMEMORY_BLOCK)
         {
            DebugPrint1("Memory block at %p has an invalid signature!\n",
                         pPrivateMemory);
            DbgBreakPoint();
         }
         DebugPrint2("Memory block at %p:  total length = %d bytes\n",
                      pPrivateMemory,
                      sizeof(ULONG) * (pPrivateMemory->ulLength + 1));
         DebugPrint2("Block '%s' was allocated by function %s\n",
                      pPrivateMemory->strTitle,
                      pPrivateMemory->strFunction);

         pulTemp = (PULONG)pPrivateMemory;

         //
         // check that the trailer is still ok
         //
         if (pulTemp[pPrivateMemory->ulLength] != ulTRAIL_PATTERN)
         {
            DebugPrint0("The trailer for this memory block has been overwritten\n");
            DbgBreakPoint();
         }
         DebugPrint0("\n");

         pPrivateMemory = pPrivateMemory->pNextMemPtr;
      }
      DebugPrint0("\n\n\n");
   }
   else
   {
      DebugPrint0("All Tdi Sample memory blocks freed properly!\n");
   }
   TSReleaseSpinLock(&MemTdiSpinLock);
}


// --------------------------------------------
//
// Function:   TSInsertNode
//
// Arguments:  pNewNode -- node to insert into list
//
// Returns:    Handle where we put things
//
// Descript:   insert the object at the first empty slot in the
//             table.  Return Handle for it (NULL if error)
//
// --------------------------------------------

ULONG
TSInsertNode(PGENERIC_HEADER  pNewNode)
{
   ULONG    ulTdiHandle = 0;

   for (ULONG ulCount = 0; ulCount < ulMAX_OBJ_HANDLES; ulCount++)
   {
      if (pObjectList->GenHead[ulCount] == NULL)
      {
         pObjectList->GenHead[ulCount] = pNewNode;
         ulTdiHandle = (ulCount + pNewNode->ulSignature);
         break;
      }
   }
   return ulTdiHandle;
}

// ---------------------------------------------
//
// Function:   TSRemoveNode
//
// Arguments:  pOldNode -- node to remove from it's linked list..
//
// Returns:    none
//
// Descript:   remove from appropriate linked list
//
// ---------------------------------------------

VOID
TSRemoveNode(ULONG   ulTdiHandle)
{
   ULONG             ulType;
   ULONG             ulSlot;
   PGENERIC_HEADER   pGenericHeader;

   ulType = ulTdiHandle & usOBJ_TYPE_MASK;

   if ((ulType == ulControlChannelObject) ||
       (ulType == ulAddressObject)        ||
       (ulType == ulEndpointObject))
   {
      ulSlot = ulTdiHandle & usOBJ_HANDLE_MASK;
      
      pGenericHeader = pObjectList->GenHead[ulSlot];
      if (pGenericHeader)
      {
         if (pGenericHeader->ulSignature == ulType)
         {
            pObjectList->GenHead[ulSlot] = NULL;
            return;
         }

//
// from here down, error cases
//
         else
         {
            DebugPrint1("%s:  wrong type for node!\n", strFunc5);
         }
      }
      else
      {
         DebugPrint1("%s:  node is null!\n", strFunc5);
      }
   }
   else
   {
      DebugPrint1("%s: Bad handle type value\n", strFunc5);
   }
}


// ---------------------------------------------
//
// Function:   TSGetObjectFromHandle
//
// Arguments:  TdiHandle      -- the handle passed in to us
//             ulType         -- the type the handle needs to have
//
// Returns:    pGenericHeader of object (NULL if error)
//
// Descript:   fetch object from list via handle
//
// ---------------------------------------------

PGENERIC_HEADER
TSGetObjectFromHandle(ULONG   ulTdiHandle,
                      ULONG   ulType)
{
   ULONG ulHandleType = ulTdiHandle & usOBJ_TYPE_MASK;

   if ((ulHandleType & ulType) == ulHandleType)
   {
      ULONG             ulHandleSlot   = ulTdiHandle & usOBJ_HANDLE_MASK;
      PGENERIC_HEADER   pGenericHeader = pObjectList->GenHead[ulHandleSlot];

      if (pGenericHeader)
      {
         if (pGenericHeader->ulSignature == ulHandleType)
         {
            return pGenericHeader;
         }

//
// from here down, error conditions
//
         else
         {
            DebugPrint1("%s:  wrong type for node!\n", strFunc6);
         }
      }
      else
      {
         DebugPrint1("%s:  node is null!\n", strFunc6);
      }
   }
   else
   {
      DebugPrint1("%s: Bad handle type value\n", strFunc6);
   }
//   DbgBreakPoint();
   return NULL;
}


// ----------------------------------------------------
//
// Function:   TSAllocateIrp
//
// Arguments:  pDeviceObject  -- device object to call with this irp
//             pIrpPool       -- irp pool to allocate from (may be NULL)
//
// Returns:    IRP that was allocated (NULL if error)
//
// Descript:   allocates a single IRP for use in calling the
//             lower level driver (TdiProvider)
//             
// NOTE:  much of this code taken from ntos\io\iosubs.c\IoBuildDeviceIoRequest
//        see TSAllocateIrpPool for how we cheat
//
// ----------------------------------------------------

PIRP
TSAllocateIrp(PDEVICE_OBJECT  pDeviceObject,
              PIRP_POOL       pIrpPool)
{
   PIRP  pNewIrp = NULL;

   if (pIrpPool)
   {
      pNewIrp = pIrpPool->pAvailIrpList;
      if (!pNewIrp)
      {
         TSAcquireSpinLock(&pIrpPool->TdiSpinLock);
         pIrpPool->pAvailIrpList = pIrpPool->pUsedIrpList;
         pIrpPool->pUsedIrpList = NULL;
         TSReleaseSpinLock(&pIrpPool->TdiSpinLock);
         pNewIrp = pIrpPool->pAvailIrpList;
      }
      if (pNewIrp)
      {
         pIrpPool->pAvailIrpList = pNewIrp->AssociatedIrp.MasterIrp;
         pNewIrp->AssociatedIrp.MasterIrp = NULL;
      }
   }
   else
   {
      pNewIrp = IoAllocateIrp(pDeviceObject->StackSize, FALSE);
      pNewIrp->Tail.Overlay.Thread = PsGetCurrentThread();;
   }

   if (pNewIrp)
   {
      PIO_STACK_LOCATION   pIrpSp = IoGetNextIrpStackLocation(pNewIrp);
      
      pIrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
      pIrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
      pIrpSp->Parameters.DeviceIoControl.InputBufferLength  = 0;
      pIrpSp->Parameters.DeviceIoControl.IoControlCode      = 0x00000003;
      pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer   = NULL;
      pNewIrp->UserBuffer = NULL;
      pNewIrp->UserIosb   = NULL;
      pNewIrp->UserEvent  = NULL;
      pNewIrp->RequestorMode = KernelMode;
   }

   return pNewIrp;

}


// ----------------------------------------------------
//
// Function:   TSFreeIrp
//
// Arguments:  IRP to free
//             pIrpPool -- pool to free to (may be NULL)
//
// Returns:    none
//
// Descript:   Frees the IRP passed in
//             See TSAllocateIrpPool for how we cheat..
//
// ----------------------------------------------------

VOID
TSFreeIrp(PIRP       pIrp,
          PIRP_POOL  pIrpPool)
{
   if (pIrpPool)
   {
      TSAcquireSpinLock(&pIrpPool->TdiSpinLock);
      pIrp->AssociatedIrp.MasterIrp = pIrpPool->pUsedIrpList;
      pIrpPool->pUsedIrpList = pIrp;
      TSReleaseSpinLock(&pIrpPool->TdiSpinLock);
      if (pIrpPool->fMustFree)
      {
         TSFreeIrpPool(pIrpPool);
      }
   }
   else
   {
      IoFreeIrp(pIrp);
   }
}


// ---------------------------------
//
// Function:   TSPrintTaAddress
//
// Arguments:  pTaAddress -- address to print out info for
//
// Returns:    none
//
// Descript:   prints out information in pTaAddress structure
//
// ---------------------------------


VOID
TSPrintTaAddress(PTA_ADDRESS  pTaAddress)
{
   BOOLEAN  fShowAddress = TRUE;

   DebugPrint0("AddressType = TDI_ADDRESS_TYPE_");
   switch (pTaAddress->AddressType)
   {
      case TDI_ADDRESS_TYPE_UNSPEC:
         DebugPrint0("UNSPEC\n");
         break;
      case TDI_ADDRESS_TYPE_UNIX:
         DebugPrint0("UNIX\n");
         break;

      case TDI_ADDRESS_TYPE_IP:
         DebugPrint0("IP\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_IP   pTdiAddressIp = (PTDI_ADDRESS_IP)pTaAddress->Address;
            PUCHAR            pucTemp       = (PUCHAR)&pTdiAddressIp->in_addr;
            DebugPrint5("sin_port = 0x%04x\n"
                        "in_addr  = %u.%u.%u.%u\n",
                         pTdiAddressIp->sin_port,
                         pucTemp[0], pucTemp[1],
                         pucTemp[2], pucTemp[3]);
         }
         break;

      case TDI_ADDRESS_TYPE_IMPLINK:
         DebugPrint0("IMPLINK\n");
         break;
      case TDI_ADDRESS_TYPE_PUP:
         DebugPrint0("PUP\n");
         break;
      case TDI_ADDRESS_TYPE_CHAOS:
         DebugPrint0("CHAOS\n");
         break;

      case TDI_ADDRESS_TYPE_IPX:
         DebugPrint0("IPX\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_IPX  pTdiAddressIpx = (PTDI_ADDRESS_IPX)pTaAddress->Address;
            DebugPrint8("NetworkAddress = 0x%08x\n"
                        "NodeAddress    = %u.%u.%u.%u.%u.%u\n"
                        "Socket         = 0x%04x\n",
                         pTdiAddressIpx->NetworkAddress,
                         pTdiAddressIpx->NodeAddress[0],
                         pTdiAddressIpx->NodeAddress[1],
                         pTdiAddressIpx->NodeAddress[2],
                         pTdiAddressIpx->NodeAddress[3],
                         pTdiAddressIpx->NodeAddress[4],
                         pTdiAddressIpx->NodeAddress[5],
                         pTdiAddressIpx->Socket);
                  
         }
         break;

      case TDI_ADDRESS_TYPE_NBS:
         DebugPrint0("NBS\n");
         break;
      case TDI_ADDRESS_TYPE_ECMA:
         DebugPrint0("ECMA\n");
         break;
      case TDI_ADDRESS_TYPE_DATAKIT:
         DebugPrint0("DATAKIT\n");
         break;
      case TDI_ADDRESS_TYPE_CCITT:
         DebugPrint0("CCITT\n");
         break;
      case TDI_ADDRESS_TYPE_SNA:
         DebugPrint0("SNA\n");
         break;
      case TDI_ADDRESS_TYPE_DECnet:
         DebugPrint0("DECnet\n");
         break;
      case TDI_ADDRESS_TYPE_DLI:
         DebugPrint0("DLI\n");
         break;
      case TDI_ADDRESS_TYPE_LAT:
         DebugPrint0("LAT\n");
         break;
      case TDI_ADDRESS_TYPE_HYLINK:
         DebugPrint0("HYLINK\n");
         break;

      case TDI_ADDRESS_TYPE_APPLETALK:
         DebugPrint0("APPLETALK\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_APPLETALK  pTdiAddressAppleTalk = (PTDI_ADDRESS_APPLETALK)pTaAddress->Address;

            DebugPrint3("Network = 0x%04x\n"
                        "Node    = 0x%02x\n"
                        "Socket  = 0x%02x\n",
                         pTdiAddressAppleTalk->Network,
                         pTdiAddressAppleTalk->Node,
                         pTdiAddressAppleTalk->Socket);
         }
         break;

      case TDI_ADDRESS_TYPE_NETBIOS:
         DebugPrint0("NETBIOS\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_NETBIOS pTdiAddressNetbios = (PTDI_ADDRESS_NETBIOS)pTaAddress->Address;
            UCHAR                pucName[17];

            //
            // make sure we have a zero-terminated name to print...
            //
            RtlCopyMemory(pucName, pTdiAddressNetbios->NetbiosName, 16);
            pucName[16] = 0;
            DebugPrint0("NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_");
            switch (pTdiAddressNetbios->NetbiosNameType)
            {
               case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE:
                  DebugPrint0("UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_GROUP:
                  DebugPrint0("GROUP\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE:
                  DebugPrint0("QUICK_UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP:
                  DebugPrint0("QUICK_GROUP\n");
                  break;
               default:
                  DebugPrint1("INVALID [0x%04x]\n", 
                               pTdiAddressNetbios->NetbiosNameType);
                  break;
            }
            DebugPrint1("NetbiosName = %s\n", pucName);
         }
         break;

      case TDI_ADDRESS_TYPE_8022:
         DebugPrint0("8022\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_8022    pTdiAddress8022 = (PTDI_ADDRESS_8022)pTaAddress->Address;
            
            DebugPrint6("Address = %02x-%02x-%02x-%02x-%02x-%02x\n",
                         pTdiAddress8022->MACAddress[0],
                         pTdiAddress8022->MACAddress[1],
                         pTdiAddress8022->MACAddress[2],
                         pTdiAddress8022->MACAddress[3],
                         pTdiAddress8022->MACAddress[4],
                         pTdiAddress8022->MACAddress[5]);

         }
         break;

      case TDI_ADDRESS_TYPE_OSI_TSAP:
         DebugPrint0("OSI_TSAP\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_OSI_TSAP   pTdiAddressOsiTsap = (PTDI_ADDRESS_OSI_TSAP)pTaAddress->Address;
            ULONG                   ulSelectorLength;
            ULONG                   ulAddressLength;
            PUCHAR                  pucTemp = pTdiAddressOsiTsap->tp_addr;

            DebugPrint0("TpAddrType = ISO_");
            switch (pTdiAddressOsiTsap->tp_addr_type)
            {
               case ISO_HIERARCHICAL:
                  DebugPrint0("HIERARCHICAL\n");
                  ulSelectorLength = pTdiAddressOsiTsap->tp_tsel_len;
                  ulAddressLength  = pTdiAddressOsiTsap->tp_taddr_len;
                  break;
               case ISO_NON_HIERARCHICAL:
                  DebugPrint0("NON_HIERARCHICAL\n");
                  ulSelectorLength = 0;
                  ulAddressLength  = pTdiAddressOsiTsap->tp_taddr_len;
                  break;
               default:
                  DebugPrint1("INVALID [0x%04x]\n",
                               pTdiAddressOsiTsap->tp_addr_type);
                  ulSelectorLength = 0;
                  ulAddressLength  = 0;
                  break;
            }
            if (ulSelectorLength)
            {
               ULONG    ulCount;

               DebugPrint0("TransportSelector:  ");
               for (ulCount = 0; ulCount < ulSelectorLength; ulCount++)
               {
                  DebugPrint1("%02x ", *pucTemp);
                  ++pucTemp;
               }
               DebugPrint0("\n");
            }
            if (ulAddressLength)
            {
               ULONG    ulCount;

               DebugPrint0("TransportAddress:  ");
               for (ulCount = 0; ulCount < ulAddressLength; ulCount++)
               {
                  DebugPrint1("%02x ", *pucTemp);
                  ++pucTemp;
               }
               DebugPrint0("\n");
            }
         }
         break;

      case TDI_ADDRESS_TYPE_NETONE:
         DebugPrint0("NETONE\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_NETONE  pTdiAddressNetone = (PTDI_ADDRESS_NETONE)pTaAddress->Address;
            UCHAR                pucName[21];

            //
            // make sure have 0-terminated name
            //
            RtlCopyMemory(pucName,
                          pTdiAddressNetone->NetoneName,
                          20);
            pucName[20] = 0;
            DebugPrint0("NetoneNameType = TDI_ADDRESS_NETONE_TYPE_");
            switch (pTdiAddressNetone->NetoneNameType)
            {
               case TDI_ADDRESS_NETONE_TYPE_UNIQUE:
                  DebugPrint0("UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETONE_TYPE_ROTORED:
                  DebugPrint0("ROTORED\n");
                  break;
               default:
                  DebugPrint1("INVALID [0x%04x]\n", 
                               pTdiAddressNetone->NetoneNameType);
                  break;
            }
            DebugPrint1("NetoneName = %s\n",
                         pucName);
         }
         break;

      case TDI_ADDRESS_TYPE_VNS:
         DebugPrint0("VNS\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_VNS  pTdiAddressVns = (PTDI_ADDRESS_VNS)pTaAddress->Address;

            DebugPrint4("NetAddress:  %02x-%02x-%02x-%02x\n",
                         pTdiAddressVns->net_address[0],
                         pTdiAddressVns->net_address[1],
                         pTdiAddressVns->net_address[2],
                         pTdiAddressVns->net_address[3]);
            DebugPrint5("SubnetAddr:  %02x-%02x\n"
                        "Port:        %02x-%02x\n"
                        "Hops:        %u\n",
                         pTdiAddressVns->subnet_addr[0],
                         pTdiAddressVns->subnet_addr[1],
                         pTdiAddressVns->port[0],
                         pTdiAddressVns->port[1],
                         pTdiAddressVns->hops);


         }
         break;

      case TDI_ADDRESS_TYPE_NETBIOS_EX:
         DebugPrint0("NETBIOS_EX\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_NETBIOS_EX pTdiAddressNetbiosEx = (PTDI_ADDRESS_NETBIOS_EX)pTaAddress->Address;
            UCHAR                   pucEndpointName[17];
            UCHAR                   pucNetbiosName[17];

            //
            // make sure we have zero-terminated names to print...
            //
            RtlCopyMemory(pucEndpointName,
                          pTdiAddressNetbiosEx->EndpointName,
                          16);
            pucEndpointName[16] = 0;
            RtlCopyMemory(pucNetbiosName, 
                          pTdiAddressNetbiosEx->NetbiosAddress.NetbiosName, 
                          16);
            pucNetbiosName[16] = 0;

            DebugPrint1("EndpointName    = %s\n"
                        "NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_",
                         pucEndpointName);

            switch (pTdiAddressNetbiosEx->NetbiosAddress.NetbiosNameType)
            {
               case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE:
                  DebugPrint0("UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_GROUP:
                  DebugPrint0("GROUP\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE:
                  DebugPrint0("QUICK_UNIQUE\n");
                  break;
               case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP:
                  DebugPrint0("QUICK_GROUP\n");
                  break;
               default:
                  DebugPrint1("INVALID [0x%04x]\n", 
                               pTdiAddressNetbiosEx->NetbiosAddress.NetbiosNameType);
                  break;
            }
            DebugPrint1("NetbiosName = %s\n", pucNetbiosName);
         }
         break;

      case TDI_ADDRESS_TYPE_IP6:
         DebugPrint0("IPv6\n");
         fShowAddress = FALSE;
         {
            PTDI_ADDRESS_IP6  pTdiAddressIp6 = (PTDI_ADDRESS_IP6)pTaAddress->Address;
            PUCHAR            pucTemp        = (PUCHAR)&pTdiAddressIp6->sin6_addr;

            DebugPrint3("SinPort6 = 0x%04x\n"
                        "FlowInfo = 0x%08x\n"
                        "ScopeId  = 0x%08x\n",
                         pTdiAddressIp6->sin6_port,
                         pTdiAddressIp6->sin6_flowinfo,
                         pTdiAddressIp6->sin6_scope_id);

            DebugPrint8("In6_addr = %x%02x:%x%02x:%x%02x:%x%02x:",
                         pucTemp[0], pucTemp[1],
                         pucTemp[2], pucTemp[3],
                         pucTemp[4], pucTemp[5],
                         pucTemp[6], pucTemp[7]);
            DebugPrint8("%x%02x:%x%02x:%x%02x:%x%02x\n",
                         pucTemp[8],  pucTemp[9],
                         pucTemp[10], pucTemp[11],
                         pucTemp[12], pucTemp[13],
                         pucTemp[14], pucTemp[15]);
         }
         break;

      default:
         DebugPrint1("UNKNOWN [0x%08x]\n", pTaAddress->AddressType);
         break;
   }

   if (fShowAddress)
   {
      PUCHAR   pucTemp = pTaAddress->Address;

      DebugPrint1("AddressLength = %d\n"
                  "Address       = ",
                   pTaAddress->AddressLength);

      for (ULONG ulCount = 0; ulCount < pTaAddress->AddressLength; ulCount++)
      {
         DebugPrint1("%02x ", *pucTemp);
         pucTemp++;
      }

      DebugPrint0("\n");
   }
}


// ----------------------------------------------------
//
// Function:   TSAllocateIrpPool
//
// Arguments:  device object
//
// Returns:    ptr to irp pool
//
// Descript:   allocates an IRP pool when the driver starts, so
//             we don't have to worry about being in an inappropriate
//             IRQL when we need one...
//
// NOTE:  we cheat a little in maintaining our list of available Irps
//        We use the AssociatedIrp.MasterIrp field to point to the
//        next IRP in our list.  Because of this, we need to explicitly
//        set this field to NULL whenever we remove one of the IRPs from our
//        list..
//
// ----------------------------------------------------

PIRP_POOL
TSAllocateIrpPool(PDEVICE_OBJECT pDeviceObject,
                  ULONG          ulPoolSize)
{
   PIRP_POOL   pIrpPool = NULL;

   if ((TSAllocateMemory((PVOID *)&pIrpPool,
                          sizeof(IRP_POOL) + (ulPoolSize * sizeof(PVOID)),
                          strFunc9,
                          "IrpPool")) == STATUS_SUCCESS)
   {
      PIRP     pNewIrp;

      TSAllocateSpinLock(&pIrpPool->TdiSpinLock);
      pIrpPool->ulPoolSize = ulPoolSize;
      pIrpPool->fMustFree  = FALSE;

      for (ULONG ulCount = 0; ulCount < ulPoolSize; ulCount++) 
      {
         pNewIrp = IoAllocateIrp(pDeviceObject->StackSize, FALSE);
         if (pNewIrp)
         {
            pNewIrp->Tail.Overlay.Thread = PsGetCurrentThread();
            //
            // store this irp in the list of allocated irps
            //
            pIrpPool->pAllocatedIrp[ulCount] = pNewIrp;
            //
            // and add it to the beginning of the list of available irps
            //
            pNewIrp->AssociatedIrp.MasterIrp = pIrpPool->pAvailIrpList;
            pIrpPool->pAvailIrpList = pNewIrp;
         }
      }
   }

   return pIrpPool;
}


// ----------------------------------------------------
//
// Function:   TSFreeIrpPool
//
// Arguments:  ptr to irp pool to free
//
// Returns:    none
//
// Descript:   Frees the IRP pool allocated above
//
// ----------------------------------------------------

VOID
TSFreeIrpPool(PIRP_POOL pIrpPool)
{
   if (pIrpPool)
   {
      //
      // free each irp in the Avail list
      // clearing it from the allocated list
      //
      PIRP     pThisIrp;
      PIRP     pIrpList;

      for(;;)
      {
         //
         // protect irppool structure while get AvailList or UsedList
         //
         TSAcquireSpinLock(&pIrpPool->TdiSpinLock);
         pIrpList = pIrpPool->pAvailIrpList;
         if (pIrpList)
         {
            pIrpPool->pAvailIrpList = NULL;
         }
         else
         {
            //
            // nothing on avail list, try used list
            //
            pIrpList = pIrpPool->pUsedIrpList;
            if (pIrpList)
            {
               pIrpPool->pUsedIrpList = NULL;
            }
            else
            {
               //
               // nothing on either list
               // go thru the pAllocatedIrp list just to be sure all are freed
               //
               for (ULONG ulCount = 0; ulCount < pIrpPool->ulPoolSize; ulCount++)
               {
                  if (pIrpPool->pAllocatedIrp[ulCount])
                  {
                     pIrpPool->fMustFree = TRUE;
                     TSReleaseSpinLock(&pIrpPool->TdiSpinLock);
                     DebugPrint1("Irp at %p not freed!\n", 
                                  pIrpPool->pAllocatedIrp[ulCount]);
                     //
                     // return here if a late irp needs to finish up cleanup
                     //
                     return;
                  }
               }
               TSReleaseSpinLock(&pIrpPool->TdiSpinLock);
               //
               // finished cleanup here -- all irps accounted for
               //
               TSFreeSpinLock(&pIrpPool->TdiSpinLock);
               TSFreeMemory(pIrpPool);
               return;
            }
         }

         TSReleaseSpinLock(&pIrpPool->TdiSpinLock);

         while (pIrpList)
         {
            pThisIrp = pIrpList;
            pIrpList = pIrpList->AssociatedIrp.MasterIrp;
            pThisIrp->AssociatedIrp.MasterIrp = NULL;

            for (ULONG ulCount = 0; ulCount < pIrpPool->ulPoolSize; ulCount++)
            {
               if (pIrpPool->pAllocatedIrp[ulCount] == pThisIrp)
               {
                  pIrpPool->pAllocatedIrp[ulCount] = NULL;
                  break;
               }
            }
            IoFreeIrp(pThisIrp);
         }  // end of while(pIrpList)
      }     // end of for(;;)
   }
}

//////////////////////////////////////////////////////////////////////
// end of file utils.cpp
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tdi\sample\sys\send.cpp ===
/////////////////////////////////////////////////////////
//
//    Copyright (c) 2001  Microsoft Corporation
//
//    Module Name:
//       send
//
//    Abstract:
//       This module contains code which deals with sending data
//
//////////////////////////////////////////////////////////


#include "sysvars.h"

//////////////////////////////////////////////////////////////
// private constants, types, and prototypes
//////////////////////////////////////////////////////////////

const PCHAR strFunc1  = "TSSendDatagram";
const PCHAR strFunc2  = "TSSend";
const PCHAR strFuncP1 = "TSSendComplete";

//
// completion context
//
struct   SEND_CONTEXT
{
   PIRP              pUpperIrp;           // irp from dll to complete
   PMDL              pLowerMdl;           // mdl from lower irp
   PTDI_CONNECTION_INFORMATION
                     pTdiConnectInfo;
};
typedef  SEND_CONTEXT  *PSEND_CONTEXT;


//
// completion function
//
TDI_STATUS
TSSendComplete(
   PDEVICE_OBJECT DeviceObject,
   PIRP           Irp,
   PVOID          Context
   );



//////////////////////////////////////////////////////////////
// public functions
//////////////////////////////////////////////////////////////


// -----------------------------------------------------------------
//
// Function:   TSSendDatagram
//
// Arguments:  pAddressObject -- address object
//             pSendBuffer    -- arguments from user dll
//             pIrp           -- completion information
//
// Returns:    NTSTATUS (normally pending)
//
// Descript:   This function sends a datagram
//
// ---------------------------------------------------------------------------

NTSTATUS
TSSendDatagram(PADDRESS_OBJECT   pAddressObject,
               PSEND_BUFFER      pSendBuffer,
               PIRP              pUpperIrp)
{
   ULONG                ulDataLength  = pSendBuffer->COMMAND_ARGS.SendArgs.ulBufferLength;
   PUCHAR               pucDataBuffer = pSendBuffer->COMMAND_ARGS.SendArgs.pucUserModeBuffer;
   PTRANSPORT_ADDRESS   pTransportAddress
                        = (PTRANSPORT_ADDRESS)&pSendBuffer->COMMAND_ARGS.SendArgs.TransAddr;

   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint2("\nCommand = ulSENDDATAGRAM\n"
                  "FileObject = %p\n"
                  "DataLength = %u\n",
                   pAddressObject,
                   ulDataLength);
      TSPrintTaAddress(pTransportAddress->Address);
   }

   //
   // allocate all the necessary structures
   //
   PSEND_CONTEXT                 pSendContext = NULL;
   PMDL                          pSendMdl = NULL;
   PTDI_CONNECTION_INFORMATION   pTdiConnectInfo = NULL;
   
   //
   // our context
   //
   if ((TSAllocateMemory((PVOID *)&pSendContext,
                          sizeof(SEND_CONTEXT),
                          strFunc1,
                          "SendContext")) != STATUS_SUCCESS)
   {
      goto cleanup;
   }

   //
   // the connection information structure
   //
   if ((TSAllocateMemory((PVOID *)&pTdiConnectInfo,
                          sizeof(TDI_CONNECTION_INFORMATION) 
                          + sizeof(TRANSADDR),
                          strFunc1,
                          "TdiConnectionInformation")) == STATUS_SUCCESS)
   {
      PUCHAR   pucTemp = (PUCHAR)pTdiConnectInfo;
      ULONG    ulAddrLength
               = FIELD_OFFSET(TRANSPORT_ADDRESS, Address)
                 + FIELD_OFFSET(TA_ADDRESS, Address)
                   + pTransportAddress->Address[0].AddressLength;

      pucTemp += sizeof(TDI_CONNECTION_INFORMATION);

      pTdiConnectInfo->RemoteAddress = pucTemp;
      pTdiConnectInfo->RemoteAddressLength = ulAddrLength;
      RtlCopyMemory(pucTemp,
                    pTransportAddress,
                    ulAddrLength);
   }
   else
   {
      goto cleanup;
   }

   //
   // create the message "packet" to send
   //   
   pSendMdl = TSMakeMdlForUserBuffer(pucDataBuffer,
                                     ulDataLength,
                                     IoReadAccess);
   
   if (pSendMdl)
   {
      //
      // set up the completion context
      //
      pSendContext->pUpperIrp       = pUpperIrp;
      pSendContext->pLowerMdl       = pSendMdl;
      pSendContext->pTdiConnectInfo = pTdiConnectInfo;

      //
      // finally, the irp itself
      //
      PIRP  pLowerIrp = TSAllocateIrp(pAddressObject->GenHead.pDeviceObject,
                                      NULL);
      if (pLowerIrp)
      {
         //
         // if made it to here, everything is correctly allocated
         // set up the irp and call the tdi provider
         //

#pragma  warning(disable: CONSTANT_CONDITIONAL)

         TdiBuildSendDatagram(pLowerIrp,
                              pAddressObject->GenHead.pDeviceObject,
                              pAddressObject->GenHead.pFileObject,
                              TSSendComplete,
                              pSendContext,
                              pSendMdl,
                              ulDataLength,
                              pTdiConnectInfo);

#pragma  warning(default: CONSTANT_CONDITIONAL)

         //
         // make the call to the tdi provider
         //
         pSendBuffer->pvLowerIrp = pLowerIrp;   // so command can be cancelled

         NTSTATUS lStatus = IoCallDriver(pAddressObject->GenHead.pDeviceObject,
                                         pLowerIrp);

         if ((!NT_SUCCESS(lStatus)) && (ulDebugLevel & ulDebugShowCommand))
         {
            DebugPrint2("%s: unexpected status for IoCallDriver [0x%08x]\n", 
                         strFunc1,
                         lStatus);
         }
         return STATUS_PENDING;
      }
   }

//
// get here if there was an allocation failure
// need to clean up everything else...
//
cleanup:
   if (pSendContext)
   {
      TSFreeMemory(pSendContext);
   }
   if (pTdiConnectInfo)
   {
      TSFreeMemory(pTdiConnectInfo);
   }
   if (pSendMdl)
   {
      TSFreeUserBuffer(pSendMdl);
   }
   return STATUS_INSUFFICIENT_RESOURCES;
}

// -----------------------------------------------------------------
//
// Function:   TSSend
//
// Arguments:  pEndpointObject -- endpoint object
//             pSendBuffer    -- arguments from user dll
//             pIrp           -- completion information
//
// Returns:    NTSTATUS (normally pending)
//
// Descript:   This function sends data over a connection
//
// ----------------------------------------------------------------------------

NTSTATUS
TSSend(PENDPOINT_OBJECT pEndpoint,
       PSEND_BUFFER     pSendBuffer,
       PIRP             pUpperIrp)
{
   ULONG    ulDataLength  = pSendBuffer->COMMAND_ARGS.SendArgs.ulBufferLength;
   PUCHAR   pucDataBuffer = pSendBuffer->COMMAND_ARGS.SendArgs.pucUserModeBuffer;
   ULONG    ulSendFlags   = pSendBuffer->COMMAND_ARGS.SendArgs.ulFlags;

   //
   // currently only support TDI_SEND_EXPEDITED
   //
   ulSendFlags &= TDI_SEND_EXPEDITED;

   //
   // show debug, if it is turned on
   //
   if (ulDebugLevel & ulDebugShowCommand)
   {
      DebugPrint3("\nCommand = ulSEND\n"
                  "Endpoint = %p\n"
                  "DataLength = %u\n"
                  "SendFlags = 0x%08x\n",
                   pEndpoint,
                   ulDataLength,
                   ulSendFlags);
   }

   //
   // allocate all the necessary structures
   //
   PSEND_CONTEXT  pSendContext = NULL;
   PMDL           pSendMdl = NULL;
   
   //
   // our context
   //
   if ((TSAllocateMemory((PVOID *)&pSendContext,
                          sizeof(SEND_CONTEXT),
                          strFunc2,
                          "SendContext")) != STATUS_SUCCESS)
   {
      goto cleanup;
   }

   pSendMdl = TSMakeMdlForUserBuffer(pucDataBuffer,
                                     ulDataLength,
                                     IoReadAccess);
   if (pSendMdl)
   {
      //
      // set up the completion context
      //
      pSendContext->pUpperIrp = pUpperIrp;
      pSendContext->pLowerMdl = pSendMdl;

      //
      // finally, the irp itself
      //
      PIRP  pLowerIrp = TSAllocateIrp(pEndpoint->GenHead.pDeviceObject,
                                      NULL);
      if (pLowerIrp)
      {
         //
         // if made it to here, everything is correctly allocated
         // set up the irp for the call
         //
#pragma  warning(disable: CONSTANT_CONDITIONAL)

         TdiBuildSend(pLowerIrp,
                      pEndpoint->GenHead.pDeviceObject,
                      pEndpoint->GenHead.pFileObject,
                      TSSendComplete,
                      pSendContext,
                      pSendMdl,
                      ulSendFlags,               // flags
                      ulDataLength);

#pragma  warning(default: CONSTANT_CONDITIONAL)

         //
         // make the call to the tdi provider
         //
         pSendBuffer->pvLowerIrp = pLowerIrp;   // so command can be cancelled

         NTSTATUS lStatus = IoCallDriver(pEndpoint->GenHead.pDeviceObject,
                                         pLowerIrp);

         if ((!NT_SUCCESS(lStatus)) && (ulDebugLevel & ulDebugShowCommand))
         {
            DebugPrint2("%s: unexpected status for IoCallDriver [0x%08x]\n", 
                         strFunc2,
                         lStatus);
         }
         return STATUS_PENDING;
      }
   }

//
// get here if there was an allocation failure
// need to clean up everything else...
//
cleanup:
   if (pSendContext)
   {
      TSFreeMemory(pSendContext);
   }
   if (pSendMdl)
   {
      TSFreeUserBuffer(pSendMdl);
   }
   return STATUS_INSUFFICIENT_RESOURCES;
}

/////////////////////////////////////////////////////////////
// private functions
/////////////////////////////////////////////////////////////

// ---------------------------------------------------------
//