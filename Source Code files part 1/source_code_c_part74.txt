turn Type       :BOOL
   Global Variables  :None
   Calling Syntax    :CompareTokensChars(pszToken1,pszToken2,cchToken)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CompareTokensChars(_TCHAR* pszToken1, _TCHAR* pszToken2, DWORD cchToken)
{	
	DWORD cchSize = cchToken ;
	cchSize = min ( (pszToken1) ? lstrlen(pszToken1) : 0, cchSize ) ;
	cchSize = min ( (pszToken2) ? lstrlen(pszToken2) : 0, cchSize ) ;

	return	(CSTR_EQUAL == CompareString	(	LOCALE_SYSTEM_DEFAULT, 
												NORM_IGNORECASE | NORM_IGNOREWIDTH,	
												pszToken1,
												cchSize,
												pszToken2,
												cchSize
											) 
			) ? TRUE : FALSE;
}

/*----------------------------------------------------------------------------
   Name				 :Connect
   Synopsis	         :To connect to WMI namespace on a given server  with the
					  set of input user credentials.
   Type	             :Global Function
   Input parameter(s):
		pILocator	 -	Locator object 
		bstrNS		 -	Namespae to be connected to 
		bstrUser	 -	User name with which to connect 
		bstrPwd		 -	Password  for the user name  with which to connect
		bstrLocale	 -	Locale specified 
   Output parameters :
			pISvc	 -	WMI services object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :Connect(pILocator, &pISvc, bstrNS, bstrUser, bstPwd,
							  bstrLocale)
   Notes             :None
----------------------------------------------------------------------------*/
HRESULT Connect(IWbemLocator* pILocator, IWbemServices** pISvc,
				BSTR bstrNS, BSTR bstrUser, BSTR bstrPwd, 
				BSTR bstrLocale, CParsedInfo& rParsedInfo)
{
	HRESULT hr						= S_OK;
	BSTR	bstrPass				= NULL;
	BSTR	bstrAuthorityPrinciple  = NULL;

	// If the user name is not NULL and the password is 
	// a) NULL, treat the password as BLANK
	// b) not NULL, treat the password as it is.
	try 
	{
		// Get the <authority principle> specified, and pass in with ConnectServer
		if(NULL != rParsedInfo.GetAuthorityPrinciple())
		{
			bstrAuthorityPrinciple =
				::SysAllocString(rParsedInfo.GetAuthorityPrinciple());
			if (bstrAuthorityPrinciple == NULL)
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
		
		if (bstrUser)
		{
			if (!bstrPwd)
			{
				bstrPass = ::SysAllocString(L"");
				if (bstrPass == NULL)
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

				// Set the credentials flag to TRUE - BLANK password
				rParsedInfo.GetCmdSwitchesObject().SetCredentialsFlag(TRUE);
			}
		}
		
		if (pILocator != NULL)
		{	
			// Call the ConnectServer method of the IWbemLocator
			hr = pILocator->ConnectServer(bstrNS, 
							bstrUser, 
							(!bstrPass) ? bstrPwd : bstrPass, 
							bstrLocale,	
							0L,	bstrAuthorityPrinciple, NULL,	pISvc);

			// If the username is specified and the password is not 
			// specified (the remote machine also has the same password)
			if (FAILED(hr) && bstrUser && (hr == E_ACCESSDENIED))
			{

				hr = pILocator->ConnectServer(bstrNS, 
								bstrUser, 
								NULL, 
								bstrLocale,	
								0L,	bstrAuthorityPrinciple, NULL,	pISvc);

				// Set the credentials flag to FALSE - NULL password
				rParsedInfo.GetCmdSwitchesObject().SetCredentialsFlag(FALSE);
			}
		}
		else
			hr = E_FAIL;

		if (bstrPass)
			::SysFreeString(bstrPass);
		if (bstrAuthorityPrinciple)
			::SysFreeString(bstrAuthorityPrinciple);
	}
	catch(CHeap_Exception)
	{
		if (bstrAuthorityPrinciple)
			::SysFreeString(bstrAuthorityPrinciple);
		if (bstrPass)
			::SysFreeString(bstrPass);
		hr = E_FAIL;
	}

	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :SetSecurity
   Synopsis	         :To set the security privileges at the interface level
   Type	             :Global Function
   Input parameter(s):
		pIUnknown	 -	Interface pointer
		pszDomain	 -	domain name
		pszAuthority -	authority (always passed as NULL)
		pszUser		 -	Username
		pszPassword	 -	Password
		uAuthLevel	 -	Authentication Level
		uImpLevel	 -	Impersonation Level
   Output parameter(s):None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :SetSecurity(pIUnknown, pszDomain, pszUser, 
								  pszPassword, uAuthLevel, uImpLevel)
   Notes             :(partly taken from WMI VC samples 'utillib'
----------------------------------------------------------------------------*/
HRESULT SetSecurity(IUnknown* pIUnknown, _TCHAR* pszAuthority, 
					_TCHAR* pszDomain, _TCHAR* pszUser, 
					_TCHAR* pszPassword, UINT uAuthLevel, 
					UINT uImpLevel) throw(WMICLIINT)
{
	SCODE						sc				= S_OK;
	BSTR						bstrAuthArg		= NULL, 
								bstrUserArg		= NULL;
	SEC_WINNT_AUTH_IDENTITY_W*	pAuthIdentity	= NULL;
	try
	{
		if(pIUnknown == NULL)
			return E_INVALIDARG;

		// If we are lowering the security, no need to deal with the 
		// identification information
		if(uAuthLevel == RPC_C_AUTHN_LEVEL_NONE)
			return CoSetProxyBlanket(pIUnknown, RPC_C_AUTHN_WINNT, 
							RPC_C_AUTHZ_NONE,
							NULL, RPC_C_AUTHN_LEVEL_NONE, 
							RPC_C_IMP_LEVEL_IDENTIFY,
							NULL, EOAC_NONE);

		// If we are doing trivial case, just pass in a null authentication 
		// structure which is used if the current logged in user's credentials
		// are OK.
		if((pszAuthority == NULL || lstrlen((LPCTSTR)pszAuthority) < 1) && 
			(pszUser == NULL || lstrlen((LPCTSTR)pszUser) < 1) && 
			(pszPassword == NULL || lstrlen((LPCTSTR)pszPassword) < 1))
				return CoSetProxyBlanket(pIUnknown, RPC_C_AUTHN_WINNT, 
							RPC_C_AUTHZ_NONE, NULL, uAuthLevel,
							uImpLevel, NULL, EOAC_NONE);

		// If user, or Authority was passed in, the we need 
		// to create an authority argument for the login
		sc = ParseAuthorityUserArgs(bstrAuthArg, bstrUserArg, 
						pszAuthority, pszUser);
		if(FAILED(sc))
			return sc;
		
		pAuthIdentity = new SEC_WINNT_AUTH_IDENTITY_W;

		// Check whether the memory allocation has been successful
		if (pAuthIdentity == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		ZeroMemory(pAuthIdentity, sizeof(SEC_WINNT_AUTH_IDENTITY_W));

		if(bstrUserArg)
		{
			WMICLIULONG wulUserLen = (WMICLIULONG)
												 lstrlen((LPWSTR)bstrUserArg);
			pAuthIdentity->User = new WCHAR [wulUserLen + 1];
			if (pAuthIdentity->User == NULL)
				throw OUT_OF_MEMORY;
			wcscpy(pAuthIdentity->User, (LPWSTR)bstrUserArg);
			pAuthIdentity->UserLength = wulUserLen;
		}
		if(bstrAuthArg)
		{
			WMICLIULONG wulDomainLen = (WMICLIULONG)
												lstrlen((LPWSTR) bstrAuthArg);
			pAuthIdentity->Domain = new WCHAR [wulDomainLen + 1];
			if (pAuthIdentity->Domain == NULL)
				throw OUT_OF_MEMORY;
			wcscpy(pAuthIdentity->Domain, (LPWSTR)bstrAuthArg);
			pAuthIdentity->DomainLength = wulDomainLen;
		}

		if(pszPassword)
		{
			WMICLIULONG wulPasswordLen = (WMICLIULONG)
												lstrlen((LPWSTR) pszPassword);
			pAuthIdentity->Password = new WCHAR [wulPasswordLen + 1];
			if (pAuthIdentity->Password == NULL)
				throw OUT_OF_MEMORY;
			wcscpy(pAuthIdentity->Password, pszPassword);
			pAuthIdentity->PasswordLength= wulPasswordLen;
		}
		pAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

		if( pszAuthority != NULL &&
			_tcslen(pszAuthority) > 9 &&
			_tcsnicmp(pszAuthority, _T("KERBEROS:"), 9) == 0)
		{
			// get the <principal name> that is passed with <authority type>
			// and send it to CoSetProxyBlanket()
			BSTR	bstrPrincipalName = ::SysAllocString(&pszAuthority[9]);

			sc = CoSetProxyBlanket(pIUnknown,
						   RPC_C_AUTHN_GSS_KERBEROS,
						   RPC_C_AUTHZ_NONE ,
						   bstrPrincipalName,
						   uAuthLevel,
						   uImpLevel,
						   pAuthIdentity,
						   EOAC_NONE);

			SAFEBSTRFREE(bstrPrincipalName);
		}
		else
		{
			sc = CoSetProxyBlanket(pIUnknown, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
							NULL, uAuthLevel, uImpLevel, pAuthIdentity, EOAC_NONE);
		}

		SAFEDELETE(pAuthIdentity->User);
		SAFEDELETE(pAuthIdentity->Domain);
		SAFEDELETE(pAuthIdentity->Password);
		delete pAuthIdentity;
		SAFEBSTRFREE(bstrUserArg);
		SAFEBSTRFREE(bstrAuthArg);
	}
	catch(WMICLIINT nErr)
	{
		if (nErr == OUT_OF_MEMORY)
			sc = WBEM_E_OUT_OF_MEMORY;
		SAFEDELETE(pAuthIdentity->User);
		SAFEDELETE(pAuthIdentity->Domain);
		SAFEDELETE(pAuthIdentity->Password);
		if (pAuthIdentity)
			delete pAuthIdentity;
		SAFEBSTRFREE(bstrUserArg);
		SAFEBSTRFREE(bstrAuthArg);
	}
    return sc;
}

/*----------------------------------------------------------------------------
   Name				 :ConvertWCToMBCS
   Synopsis	         :Converts the wide character string to MBCS string 
					  after applying the codepage settings
   Type	             :Global Function 
   Input parameters  :
			lpszMsg  - string  (widechar string)
			uCP		 - codepage value	
   Output parameters :
			lpszDisp - string  (multibyte string)
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ConvertWCToMBCS(lpszMsg, lpszDisp, uCP)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL ConvertWCToMBCS(LPTSTR lpszMsg, LPVOID* lpszDisp, UINT uCP)
{
	BOOL bRet = TRUE;

	if (lpszMsg != NULL && lpszDisp != NULL)
	{
		WMICLIINT nRet = 0;		
		nRet = WideCharToMultiByte(uCP,		// code page
						 0,					// performance and mapping flags
						 (LPCWSTR)lpszMsg,	// wide-character string
						 -1,				// number of chars in string
						 NULL,				// buffer for new string
						 0,					// size of buffer	
						 NULL,				// default for unmappable chars
						 NULL);	

		// allocate memory to hold the message
		*lpszDisp = (LPSTR) new char [nRet]; 

		if (*lpszDisp)
		{
			nRet = WideCharToMultiByte(uCP,		// code page
							 0,					// performance and mapping flags
							 (LPCWSTR)lpszMsg,	// wide-character string
							 -1,				// number of chars in string
							 (LPSTR) *lpszDisp,	// buffer for new string
							 nRet,				// size of buffer	
							 NULL,				// default for unmappable chars
							 NULL);	
		}
		else
			bRet = FALSE;
	}
	else
	{
		if ( lpszDisp )
		{
			*lpszDisp = NULL;
		}
	}

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ConvertMBCSToWC
   Synopsis	         :Converts the MBCS string to wide character string
					  after applying the codepage settings
   Type	             :Global Function 
   Input parameters  :
			lpszMsg  - string  (MBCS string)
			uCP		 - codepage value	
   Output parameters :
			lpszDisp - string  (multibyte string)
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ConvertMBCSToWC(lpszMsg, lpszDisp, uCP)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL ConvertMBCSToWC(LPSTR lpszMsg, LPVOID* lpszDisp, UINT uCP)
{
	BOOL bRet = TRUE;

	if (lpszMsg != NULL && lpszDisp != NULL)
	{
		WMICLIINT nRet = 0;		
		nRet = MultiByteToWideChar	(
										uCP,				// code page
										0,					// performance and mapping flags
										(LPCSTR)lpszMsg,	// wide-character string
										-1,					// number of chars in string
										NULL,				// buffer for new string
										0
									);	

		// allocate memory to hold the message
		*lpszDisp = (LPWSTR) new WCHAR [nRet]; 

		if (*lpszDisp)
		{
			nRet = MultiByteToWideChar	(
											uCP,				// code page
											0,					// performance and mapping flags
											(LPCSTR)lpszMsg,	// wide-character string
											-1,					// number of chars in string
											(LPWSTR) *lpszDisp,	// buffer for new string
											nRet				// size of buffer	
										);	
		}
		else
			bRet = FALSE;
	}
	else
	{
		if ( lpszDisp )
		{
			*lpszDisp = NULL;
		}
	}

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :Revert_mbtowc
   Synopsis	         :Reverts string when created by mbtowc
   Type	             :Global Function 
   Input parameters  :
			wszBuffer	- string
   Output parameters :
			szBuffer	- output	
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :Revert_mbtowc(wszBuffer, &szBuffer)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL Revert_mbtowc ( LPCWSTR wszBuffer, LPSTR* szBuffer )
{
	BOOL bRet = FALSE ;

	LPWSTR help  = const_cast < LPWSTR > ( wszBuffer ) ;
	int    helpi = lstrlen ( wszBuffer ) ;

	(*szBuffer) = new char [ helpi + 1 ] ;
	if ( NULL != (*szBuffer) )
	{
		for ( int i = 0; i < helpi+1; i++ )
		{
			(*szBuffer)[ i ] = 0 ;
		}

		for ( int i = 0; i < helpi; i++ )
		{
			wctomb ( & (*szBuffer)[i], *help ) ;
			help++;
		}

		bRet = TRUE ;
	}

	return bRet ;
}

/*----------------------------------------------------------------------------
   Name				 :Find
   Synopsis	         :Searches for a given string in the vector list
   Input parameter(s):
		cvVector	 -	vector list
		pszStrToFind -  serach string
   Output parameter(s):None
   Return Type       :BOOL
   		TRUE		 - if match is found
		FALSE		 - if no match found
   Global Variables  :None
   Calling Syntax    :Find(cvVector, pszStrToFind)
   Notes             :overloaded function
----------------------------------------------------------------------------*/
BOOL Find(CHARVECTOR& cvVector,
		  _TCHAR* pszStrToFind,
		  CHARVECTOR::iterator& theIterator)
{
	BOOL bRet = FALSE;
	theIterator = cvVector.begin();
	CHARVECTOR ::iterator theEnd = cvVector.end();
	while (theIterator != theEnd)
	{
		if (CompareTokens(*theIterator, pszStrToFind))
		{
			bRet = TRUE;
			break;
		}
		theIterator++;
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :Find
   Synopsis	         :Find a property name in the property details map
   Type	             :Global Function
   Input parameter(s):
		pdmPropDetMap   - property map
		pszPropToFind   - property to search for
		theIterator     - Iterator
		bExcludeNumbers - Boolean value
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :Find(pdmPropDetMap, pszPropToFind, tempIterator)
   Notes             :overloaded function, 
					  bExcludeNumbers = FALSE by default.
----------------------------------------------------------------------------*/
BOOL Find(PROPDETMAP& pdmPropDetMap, 
		  _TCHAR* pszPropToFind,
		  PROPDETMAP::iterator& theIterator,
		  BOOL bExcludeNumbers)
{
	BOOL bRet = FALSE;
	theIterator = pdmPropDetMap.begin();
	PROPDETMAP::iterator theEnd = pdmPropDetMap.end();
	while (theIterator != theEnd)
	{
		_TCHAR* pszPropName = (*theIterator).first;
		if ( bExcludeNumbers == TRUE )
			pszPropName = pszPropName + 5;

		if (CompareTokens(pszPropName, pszPropToFind))
		{
			bRet = TRUE;
			break;
		}
		theIterator++;
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :Find
   Synopsis	         :Find a property name in the property details map
   Type	             :Global Function
   Input parameter(s):
		bmBstrMap    - BSTR map
		pszStrToFind - property to search for
		theIterator	 - Iterator. 	
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :Find(pdmPropDetMap, pszPropToFind)
   Notes             :overloaded function
----------------------------------------------------------------------------*/
BOOL Find(BSTRMAP& bmBstrMap, 
		  _TCHAR* pszStrToFind,
		  BSTRMAP::iterator& theIterator)
{
	BOOL bRet = FALSE;
	theIterator = bmBstrMap.begin();
	BSTRMAP::iterator theEnd = bmBstrMap.end();
	while (theIterator != theEnd)
	{
		if (CompareTokens((*theIterator).first, pszStrToFind))
		{
			bRet = TRUE;
			break;
		}
		theIterator++;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :FrameFileAndAddToXSLTDetVector
   Synopsis          :Frames the XSL File Path
   Type	             :Global Function
   Input parameter(s):
		stylesheet   - name of XSL File
		keyword      - name of keyword from mapping which could be possibly used
		rParsedInfo  - reference to object of CParsedInfo
   Output parameter(s): None
   Return Type       :BOOL  
   Global Variables  :None
   Calling Syntax    :FrameXSLFilePath(stylesheet, keyword, rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL FrameFileAndAddToXSLTDetVector(LPCWSTR stylesheet,
									LPCWSTR keyword,
									CParsedInfo& rParsedInfo)
{
	BOOL	bRet	  = FALSE;
	_TCHAR* pszBuffer = new _TCHAR [MAX_PATH+1];
	UINT	nSize	  = 0;

	try
	{
		if (pszBuffer != NULL)
		{
			// Obtain the windows system directory		
			nSize = GetSystemDirectory(pszBuffer, MAX_PATH+1);

			if (nSize)
			{
				if (nSize > MAX_PATH)
				{
					SAFEDELETE(pszBuffer);
					pszBuffer =	new _TCHAR [nSize + 1];
				
					if(pszBuffer == NULL)
					{
						throw OUT_OF_MEMORY;
					}

					if (!GetSystemDirectory(pszBuffer, nSize+1))
					{
						SAFEDELETE(pszBuffer);
						throw (::GetLastError());
					}
				}

				_bstr_t bstrPath = pszBuffer;
				SAFEDELETE(pszBuffer);
				bstrPath +=  WBEM_LOCATION;

				//
				// we have %windir%\system32\wbem in bstrPath now
				//

				BOOL bStyleSheet = TRUE;

				_bstr_t bstrFile = bstrPath;

				BSTRMAP::iterator theMapIterator = NULL;
				const BSTRMAP* pMap = g_wmiCmd.GetMappingsMap();
				if ( pMap )
				{
					if ( Find	(
									*( const_cast < BSTRMAP*> ( pMap ) ) ,
									const_cast < LPWSTR > ( keyword ) ,
									theMapIterator
								)
					   )
					{
						bstrFile += (*theMapIterator).second;

						//
						// check for existence
						//
						SmartCloseHandle hCheckFile = CreateFile	(
																		bstrFile,
																		0,
																		FILE_SHARE_READ ,
																		NULL,
																		OPEN_EXISTING,
																		0,
																		NULL
																	);
						if (hCheckFile != INVALID_HANDLE_VALUE)
						{
							bStyleSheet = FALSE;
							bRet = TRUE;
						}
						else
						{
							bstrFile = bstrPath;
						}
					}
				}
				else
				{
					//
					// there is no mapping ?
					// critical and very strange
					// we can still try shipped file
					//
				}

				if ( bStyleSheet && NULL != stylesheet )
				{
					bstrFile += stylesheet;

					//
					// check for existence
					//
					SmartCloseHandle hCheckFile = CreateFile	(
																	bstrFile,
																	0,
																	FILE_SHARE_READ ,
																	NULL,
																	OPEN_EXISTING,
																	0,
																	NULL
																);

					if (hCheckFile != INVALID_HANDLE_VALUE)
					{
						bRet = TRUE;
					}
					else
					{
						bstrFile = bstrPath;
					}
				}

				//
				// stylesheet structure to be added to vector
				// it is used by transform function
				//

				//
				// there is possibly adding "directory path" as path to file
				// hence: LOAD method of DOM will fail during transform
				//
				// this is intented as we are not really checking file validity
				// when /format has used and we wait for transform to deal with it
				//

				XSLTDET xdXSLTDet;
				xdXSLTDet.FileName = bstrFile;
				rParsedInfo.GetCmdSwitchesObject().AddToXSLTDetailsVector(xdXSLTDet);
			}
			else
			{
				SAFEDELETE(pszBuffer);	
				throw (::GetLastError());
			}
			SAFEDELETE(pszBuffer);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
			bRet = FALSE;
		}
	}
	catch(_com_error& e)
	{
		SAFEDELETE(pszBuffer);
		bRet = FALSE;
		_com_issue_error(e.Error());
	}
	catch (DWORD dwError)
	{
		SAFEDELETE(pszBuffer);
		::SetLastError(dwError);
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);
		DisplayWin32Error();
		::SetLastError(dwError);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :FrameFileAndAddToXSLTDetVector
   Synopsis          :Frames the XSL File Path
   Type	             :Global Function
   Input parameter(s):
		pszXSLFile   - the XSL File
		rParsedInfo  - reference to object of CParsedInfo
   Output parameter(s): None
   Return Type       :BOOL  
   Global Variables  :None
   Calling Syntax    :FrameXSLFilePath(pszXSLFile, rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
BOOL FrameFileAndAddToXSLTDetVector(XSLTDET& xdXSLTDet,
									CParsedInfo& rParsedInfo)
{
	BOOL	bRet	  = TRUE;
	_TCHAR* pszBuffer = new _TCHAR [MAX_PATH+1];
	UINT	nSize	  = 0;

	try
	{
		if (pszBuffer != NULL)
		{
			// Obtain the windows system directory		
			nSize = GetSystemDirectory(pszBuffer, MAX_PATH+1);

			if (nSize)
			{
				if (nSize > MAX_PATH)
				{
					SAFEDELETE(pszBuffer);
					pszBuffer =	new _TCHAR [nSize + 1];
				
					if(pszBuffer == NULL)
					{
						throw OUT_OF_MEMORY;
					}

					if (!GetSystemDirectory(pszBuffer, nSize+1))
					{
						SAFEDELETE(pszBuffer);
						throw (::GetLastError());
					}
				}

				_bstr_t bstrPath = _bstr_t(pszBuffer);
				SAFEDELETE(pszBuffer);
				// Append the following path
				// if (xdXSLTDet.FileName != NULL)
				if (!(!xdXSLTDet.FileName))
				{
					bstrPath +=  _bstr_t(WBEM_LOCATION) + _bstr_t(xdXSLTDet.FileName);
					xdXSLTDet.FileName = bstrPath;
					rParsedInfo.GetCmdSwitchesObject().AddToXSLTDetailsVector(
													   xdXSLTDet);
				}
			}
			else
			{
				SAFEDELETE(pszBuffer);	
				throw (::GetLastError());
			}
			SAFEDELETE(pszBuffer);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
			bRet = FALSE;
		}
	}
	catch(_com_error& e)
	{
		SAFEDELETE(pszBuffer);
		bRet = FALSE;
		_com_issue_error(e.Error());
	}
	catch (DWORD dwError)
	{
		SAFEDELETE(pszBuffer);
		::SetLastError(dwError);
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);
		DisplayWin32Error();
		::SetLastError(dwError);
		bRet = FALSE;
	}
	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :UnquoteString
   Synopsis          :Removes the starting and ending quotes of a string
					  enclosed in double quotes.
   Type	             :Global Function
   Input parameter(s):
		pszString	 - string input
   Output parameter(s): 
   		pszString	 - string input
   Return Type       :void  
   Global Variables  :None
   Calling Syntax    :UnQuoteString(pszString)
   Notes             :None
------------------------------------------------------------------------*/
void UnQuoteString(_TCHAR*& pszString)
{
	if ((lstrlen(pszString) - 1) > 0)
	{

		if(_tcsicmp(pszString, _T("\"NULL\"")) == 0)  return;

		// Check if the string is enclosed within quotes
		if ((pszString[0] == _T('"') && (pszString[lstrlen(pszString)-1] == _T('"'))) ||
			 (pszString[0] == _T('\'') && (pszString[lstrlen(pszString)-1] == _T('\''))))
		{
			WMICLIINT nLoop = 1, nLen = lstrlen(pszString)-1; 
			while (nLoop < nLen)
			{
				pszString[nLoop-1] = pszString[nLoop];
				nLoop++;
			}
			pszString[nLen-1] = _T('\0');
		}
	}
}

/*------------------------------------------------------------------------
   Name				 :ParseAuthorityUserArgs
   Synopsis          :Examines the Authority and User argument and 
					  determines the authentication type and possibly 
					  extracts the domain name from the user arugment in the 
					  NTLM case.  For NTLM, the domain can be at the end of
					  the authentication string, or in the front of the 
					  user name, ex:  "MSOFT\csriram"
   Type	             :Global Function
   Input parameter(s):
		   ConnType			-  Returned with the connection type, ie wbem,
							   ntlm
		   bstrAuthArg		-  Output, contains the domain name
		   bstrUserArg		-  Output, user name
		   bstrAuthority	-  Input
		   User				-  Input
   Output parameter(s):None 
   Return Type       :
			SCODE 
   Global Variables  :None
   Calling Syntax    :ParseAuthorityUserArgs(bstrAuthArg, bstrUserArg,
							bstrAuthority, bstrUser)
   Notes             :(taken from WMI VC samples 'utillib'
------------------------------------------------------------------------*/
SCODE ParseAuthorityUserArgs(BSTR& bstrAuthArg, BSTR& bstrUserArg,
							BSTR& bstrAuthority, BSTR& bstrUser)
{

    // Determine the connection type by examining the Authority string

    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"

    // first step is to determine if there is a backslash in the user 
	// name somewhere between the second and second to last character

	try
	{
		WCHAR * pSlashInUser = NULL;
		if(bstrUser)
		{
			WCHAR * pEnd = bstrUser + lstrlen((LPCTSTR)bstrUser) - 1;
			for(pSlashInUser = bstrUser; pSlashInUser <= pEnd; pSlashInUser++)
				// dont think forward slash is allowed!
				if(*pSlashInUser == L'\\')      
					break;
			if(pSlashInUser > pEnd)
				pSlashInUser = NULL;
		}

		if(bstrAuthority && lstrlen((LPCTSTR)bstrAuthority) > 11 &&
						_tcsnicmp((LPCTSTR)bstrAuthority, _T("NTLMDOMAIN:"), 11) == 0) 
		{
			if(pSlashInUser)
				return E_INVALIDARG;

			bstrAuthArg = SysAllocString(bstrAuthority + 11);
			if (bstrAuthArg == NULL)
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

			if(bstrUser) 
			{
				bstrUserArg = SysAllocString(bstrUser);
				if (bstrUserArg == NULL)
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
			return S_OK;
		}
		else if(pSlashInUser)
		{
			WMICLIINT iDomLen = pSlashInUser-bstrUser;
			WCHAR *pszTemp = new WCHAR [iDomLen+1];
			if ( pszTemp != NULL )
			{
				wcsncpy(pszTemp, bstrUser, iDomLen);
				pszTemp[iDomLen] = 0;
				bstrAuthArg = SysAllocString(pszTemp);
                if (bstrAuthArg == NULL){
                    delete pszTemp;
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                }

				if(lstrlen((LPCTSTR)pSlashInUser+1))
				{
					bstrUserArg = SysAllocString(pSlashInUser+1);
                    if (bstrAuthArg == NULL){
                        delete pszTemp;
						throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                    }
				}
				SAFEDELETE(pszTemp);
			}
			else
				throw OUT_OF_MEMORY;
		}
		else
			if(bstrUser)
			{
				bstrUserArg = SysAllocString(bstrUser);
				if (bstrUserArg == NULL)
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
	}
	catch(CHeap_Exception)
	{
        if(bstrAuthArg) SysFreeString(bstrAuthArg); bstrAuthArg = NULL;
        if(bstrUserArg) SysFreeString(bstrUserArg); bstrUserArg = NULL;
		throw OUT_OF_MEMORY;
	}

    return S_OK;
}

/*----------------------------------------------------------------------------
   Name				 :DisplayVARIANTContent
   Synopsis	         :Displays the content of a VARIANT type data object
   Type	             :Member Function
   Input Parameter(s):
		vtObject	 - VARIANT object
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :DisplayVARIANTContent(vtObject)
   Notes             :none
----------------------------------------------------------------------------*/
void DisplayVARIANTContent(VARIANT vtObject)
{
	_TCHAR szMsg[BUFFER255] = NULL_STRING;
	switch ( vtObject.vt )
	{
	case VT_UI1:
		_stprintf(szMsg, _T("%c"), vtObject.bVal);
		break;
	case VT_I2:
		_stprintf(szMsg, _T("%i"), vtObject.iVal);
		break;
	case VT_I4:
		_stprintf(szMsg, _T("%li"),	vtObject.lVal);
		break;
	case VT_R4:
		_stprintf(szMsg, _T("%f"),	vtObject.fltVal);
		break;
	case VT_R8:
		_stprintf(szMsg, _T("%e"),	vtObject.dblVal);
		break;
	case VT_BOOL:
		_stprintf(szMsg, _T("%i"),	vtObject.boolVal);
		break;
	case VT_I1:
		_stprintf(szMsg, _T("%c"),	vtObject.cVal);
		break;
	case VT_UI2:
		_stprintf(szMsg, _T("%i"),	vtObject.uiVal);
		break;
	case VT_UI4:
		_stprintf(szMsg, _T("%ld"),	vtObject.ulVal);
		break;
	case VT_INT:
		_stprintf(szMsg, _T("%i"),	vtObject.intVal);
		break;
	case VT_UINT:
		_stprintf(szMsg, _T("%i"),	vtObject.uintVal);
		break;
	}
	DisplayMessage(szMsg, CP_OEMCP, FALSE, TRUE);
}

/*----------------------------------------------------------------------------
   Name				 :GetPropertyAttributes
   Synopsis	         :This function obtains the information about the class
					  properties 
   Type	             :Member Function
   Input Parameter(s):
		pIObj	     - pointer to IWbemClassObject object
		bstrProp     - property name
		bTrace	     - trace flag
   Output parameter(s):
   		pdPropDet    - property details structure
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :GetPropertyAttributes(pIObj, bstrProp, 
											pdPropDet, bTrace)
   Notes             :none
----------------------------------------------------------------------------*/
HRESULT GetPropertyAttributes(IWbemClassObject* pIObj, 
							  BSTR bstrProp,
							  PROPERTYDETAILS& pdPropDet,
							  BOOL bTrace)
{
	HRESULT				hr			= S_OK;
	IWbemQualifierSet*	pIQualSet	= NULL;
	VARIANT				vtType, vtOper, vtDesc, vtTypeProp;
    CIMTYPE             ctCimType;
	VariantInit(&vtType);
	VariantInit(&vtOper);
	VariantInit(&vtDesc);
	VariantInit(&vtTypeProp);
	try
	{
		// Obtain the property qualifier set for the property
   		hr = pIObj->GetPropertyQualifierSet(bstrProp, &pIQualSet);
		if ( pIQualSet != NULL )
		{
			// Obtain the CIM type of the property
			hr = pIQualSet->Get(_bstr_t(L"CIMTYPE"), 0L, &vtType, NULL);

			if (SUCCEEDED(hr))
			{
				if ( vtType.vt == VT_BSTR )
                {
					pdPropDet.Type = _bstr_t(vtType.bstrVal);
	
                    // Obtain the CIM type of the property
		            hr = pIObj->Get(bstrProp, 0L, &vtTypeProp, &ctCimType, NULL);
			        if (SUCCEEDED(hr))
                    {
                        if ( ctCimType & VT_ARRAY )
                        {
                            pdPropDet.Type = _bstr_t("array of ") + 
                                             pdPropDet.Type;
                        }
			            VARIANTCLEAR(vtTypeProp);
                    }
                }
				else
					pdPropDet.Type = _bstr_t("Not Found");
			}
			else
				pdPropDet.Type = _bstr_t("Not Found");
			// Should not break here, hence the HRESULT should be set to S_OK
			hr = S_OK;
			VARIANTCLEAR(vtType);

			// Check whether the property has 'read' flag set
			_bstr_t bstrOper;
			hr = pIQualSet->Get(_bstr_t(L"read"), 0L, &vtOper, NULL);
			if (SUCCEEDED(hr))
			{
				if (vtOper.vt == VT_BOOL && vtOper.boolVal)
					bstrOper = _bstr_t(L"Read");
			}
			VARIANTCLEAR(vtOper);
			// Should not break here, hence the HRESULT should be set to S_OK
			hr = S_OK;

			// Check whether the property has 'write' flag set
			VariantInit(&vtOper);
			hr = pIQualSet->Get(_bstr_t(L"write"), 0L, &vtOper, NULL);
			if (SUCCEEDED(hr))
			{
				if ((vtOper.vt == VT_BOOL) && vtOper.boolVal)
				{
					if (!bstrOper)
						bstrOper = _bstr_t(L"Write");
					else
						bstrOper += _bstr_t(L"/Write");	
				}
			}
			VARIANTCLEAR(vtOper);
			// Should not break here, hence the HRESULT should be set to S_OK
			hr = S_OK;

			if (!bstrOper)
				pdPropDet.Operation = _bstr_t(TOKEN_NA);
			else
				pdPropDet.Operation = _bstr_t(bstrOper);

			// Retrieve the 'Description' text for the property
			if (FAILED(pIQualSet->Get(_bstr_t(L"Description"), 0L, 
						&vtDesc,NULL)))
				pdPropDet.Description = _bstr_t("Not Available");
			else
				pdPropDet.Description = _bstr_t(vtDesc.bstrVal);
			VARIANTCLEAR(vtDesc);
			SAFEIRELEASE(pIQualSet);
		}
		else
			hr = S_OK;
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(vtType);
		VARIANTCLEAR(vtOper);
		VARIANTCLEAR(vtDesc);
		SAFEIRELEASE(pIQualSet);
		hr = e.Error();
	}
	return hr;
}  

/*----------------------------------------------------------------------------
   Name				 :GetNumber
   Synopsis	         :converts string to number
   Input Parameter(s):string 
   Output parameters :
   Return Type       :WMICLIINT 
   Global Variables  :None
   Calling Syntax    :GetNumber(string)
   Notes             :none
----------------------------------------------------------------------------*/
WMICLIINT GetNumber ( WCHAR* wsz )
{
	WMICLIINT iResult = -1;

	if ( wsz )
	{
		WCHAR* wszTemp = wsz;

		if ( *wszTemp == L'0' )
		{
			wszTemp++;

			if ( *wszTemp )
			{
				if ( towlower ( *wszTemp ) == L'x' )
				{
					WMICLIINT i = 0;
					i = swscanf ( wsz, L"%x", &iResult );
					if ( !i || i == EOF )
					{
						iResult = -1;
					}
				}
				else
				{
					// do not support octal strings
				}
			}
			else
			{
				// this is plain 0
				iResult = 0;
			}
		}
		else
		{
			WMICLIINT i = 0;
			i = swscanf ( wsz, L"%d", &iResult );
			if ( !i || i == EOF )
			{
				iResult = -1;
			}
		}
	}

	return iResult;
}

/*----------------------------------------------------------------------------
   Name				 :ReturnFileType
   Synopsis	         :type of file
   Input Parameter(s):FILE* 
   Output parameters :none
   Return Type       :FILETYPE 
   Global Variables  :None
   Calling Syntax    :ReturnFileType(file)
   Notes             :none
----------------------------------------------------------------------------*/
FILETYPE ReturnFileType ( FILE* fpFile )
{
	FILETYPE eftFileType = ANSI_FILE ;

	// Indentifing the file type whether Unicode or ANSI.
	char szFirstTwoBytes [2] = { '\0' } ;

    if( fread(szFirstTwoBytes, 2, 1, fpFile) )
	{
		if ( memcmp(szFirstTwoBytes, UNICODE_SIGNATURE, 2)	== 0 )
		{
			eftFileType = UNICODE_FILE;
		} 
		else if (memcmp(szFirstTwoBytes, UNICODE_BIGEND_SIGNATURE, 2) == 0 )
		{
			eftFileType = UNICODE_BIGENDIAN_FILE;
		}
		else if( memcmp(szFirstTwoBytes, UTF8_SIGNATURE, 2) == 0 )
		{
			eftFileType = UTF8_FILE;
		}

		fseek(fpFile, 0, SEEK_SET);
    }

	return eftFileType ;
}

/*----------------------------------------------------------------------------
   Name				 :ReturnVarType
   Synopsis	         :Does the CIMTYPE to VARIANT conversion
   Input Parameter(s):
		bstrCIMType	 - CIMTYPE 
   Output parameters :
   Return Type       :VARTYPE 
   Global Variables  :None
   Calling Syntax    :ReturnVarType(bstrCIMType)
   Notes             :none
----------------------------------------------------------------------------*/
VARTYPE ReturnVarType( _TCHAR* bstrCIMType )
{
	if (CompareTokens(bstrCIMType, _T("")))
		return VT_NULL;
	else if (CompareTokens(bstrCIMType,_T("string")))
		return VT_BSTR;
	else if (CompareTokens(bstrCIMType,_T("Sint16")))
		return VT_I2;
	else if (CompareTokens(bstrCIMType,_T("Sint8")))
		return VT_I2;
	else if ( CompareTokens(bstrCIMType,_T("Sint32")))
		return VT_I4;
	else if ( CompareTokens(bstrCIMType,_T("Real32")))
		return VT_R4;
	else if ( CompareTokens(bstrCIMType,_T("Sint64")))
		return VT_BSTR;
	else if ( CompareTokens(bstrCIMType,_T("Uint64")))
		return VT_BSTR;
	else if ( CompareTokens(bstrCIMType,_T("Real64")))
		return VT_R8;
	else if ( CompareTokens(bstrCIMType,_T("Boolean")))
		return VT_BOOL;
	else if ( CompareTokens(bstrCIMType,_T("Object")))
		return VT_DISPATCH;
	else if ( CompareTokens(bstrCIMType,_T("Sint8")))
		return VT_INT;
	else if ( CompareTokens(bstrCIMType,_T("Uint8")))
		return VT_UI1;
	else if ( CompareTokens(bstrCIMType,_T("Uint16")))
		return VT_I4;
	else if ( CompareTokens(bstrCIMType,_T("Uint32")))
		return VT_I4;
	else if ( CompareTokens(bstrCIMType,_T("Datetime")))
		return VT_BSTR; // In WMI Date is treated as string
	else if ( CompareTokensChars(bstrCIMType,_T("ref:"),lstrlen(_T("ref:"))))
		return VT_BSTR; // In WMI ref is treated as string
	else if ( CompareTokens(bstrCIMType,_T("Char16")))
		return VT_I2;
	else // (CIM_OBJECT)
		return VT_NULL;

	return VT_EMPTY;
}

/*----------------------------------------------------------------------------
   Name				 :ConvertCIMTYPEToVarType
   Synopsis	         :Does the CIMTYPE to VARIANT conversion
   Type	             :Member Function
   Input Parameter(s):
		varSrc		 - VARIANT source 
		bstrCIMType	 - CIMTYPE 
   Output parameters :
		varDest		 - VARIANT destination
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :ConvertCIMTYPEToVarType(varDest, varSrc, bstrCIMType)
   Notes             :none
----------------------------------------------------------------------------*/
HRESULT ConvertCIMTYPEToVarType( VARIANT& varDest, VARIANT& varSrc,
								_TCHAR* bstrCIMType )
{
	HRESULT hr = S_OK;

	if (CompareTokens(bstrCIMType,_T("string")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_BSTR);
	else if (CompareTokens(bstrCIMType,_T("Sint16")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_I2);
	else if (CompareTokens(bstrCIMType,_T("Sint8")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_I2);
	else if ( CompareTokens(bstrCIMType,_T("Sint32")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_I4);
	else if ( CompareTokens(bstrCIMType,_T("Real32")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_R4);
	else if ( CompareTokens(bstrCIMType,_T("Sint64")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_BSTR);
	else if ( CompareTokens(bstrCIMType,_T("Uint64")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_BSTR);
	else if ( CompareTokens(bstrCIMType,_T("Real64")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_R8);
	else if ( CompareTokens(bstrCIMType,_T("Boolean")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_BOOL);
	else if ( CompareTokens(bstrCIMType,_T("Object")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_DISPATCH);
	else if ( CompareTokens(bstrCIMType,_T("Sint8")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_INT);
	else if ( CompareTokens(bstrCIMType,_T("Uint8")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_UI1);
	else if ( CompareTokens(bstrCIMType,_T("Uint16")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_I4);
	else if ( CompareTokens(bstrCIMType,_T("Uint32")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_I4);
	else if ( CompareTokens(bstrCIMType,_T("Datetime")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_BSTR); // In WMI Date is treated as string
	else if ( CompareTokensChars(bstrCIMType,_T("ref:"),lstrlen(_T("ref:"))))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_BSTR); // In WMI ref is treated as string
	else if ( CompareTokens(bstrCIMType,_T("Char16")))
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_I2);
	else // (CIM_OBJECT)
		hr = VariantChangeType(&varDest, &varSrc, 0, VT_NULL);
	
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :DisplayMessage
   Synopsis	         :Displays localized string 
   Type	             :Global Function 
   Input parameter(s):
			lszpMsg		- string  
			uCP		- codepage value
			bIsError	- Boolean type specifying error message or not.
			bIsLog		- Boolean type specifying message to be logged or not .
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayMessage(lpszMsg, uCP, TRUE, TRUE)
   Notes             :bIsError = FALSE, bIsLog = FALSE by default.	
----------------------------------------------------------------------------*/
void DisplayMessage ( LPTSTR lpszMsg, UINT uCP, BOOL bIsError, BOOL bIsLog, BOOL bIsStream )
{
	LPSTR	lpszDisp = NULL;
	try
	{
		// Convert the widechar to MBCS string
		if ( lpszMsg && lpszMsg[0] )
		{
			OUTPUTSPEC opsOutOpt = g_wmiCmd.GetParsedInfoObject().
								GetGlblSwitchesObject().
								GetOutputOrAppendOption(TRUE);

			if ( bIsError || ( STDOUT == opsOutOpt ) )
			{
				if ( ! ConvertWCToMBCS ( lpszMsg, (LPVOID*) &lpszDisp, uCP ) )
				{
					_com_issue_error(WBEM_E_OUT_OF_MEMORY);
				}
			}

			if (bIsLog)
			{
				// Append to the output string
				g_wmiCmd.GetFormatObject().AppendtoOutputString ( lpszMsg ) ;
			}

			if ( bIsError == TRUE )
			{
				fprintf(stderr, "%s", lpszDisp);
				fflush(stderr);
			}
			else
			{
				// OUT for getting append file pointer.
				FILE* fpOutFile = g_wmiCmd.GetParsedInfoObject().
											GetGlblSwitchesObject().
											GetOutputOrAppendFilePointer(TRUE);

				if ( opsOutOpt == CLIPBOARD )
				{
					g_wmiCmd.AddToClipBoardBuffer ( lpszMsg ) ;
				}
				else if ( opsOutOpt == FILEOUTPUT )
				{
					if (fpOutFile != NULL)
					{
						fwprintf( fpOutFile, L"%s", lpszMsg ) ;
					}
				}
				else
				{
					if ( FALSE == bIsStream )
					{
						fprintf(stdout, "%s", lpszDisp);
						fflush(stdout);
					}
				}

				// FALSE for getting append file pointer.
				FILE* fpAppendFile = g_wmiCmd.GetParsedInfoObject().
											GetGlblSwitchesObject().
											GetOutputOrAppendFilePointer(FALSE);
											
				if ( fpAppendFile != NULL )
				{
					FILETYPE eftOpt =  g_wmiCmd.GetParsedInfoObject().
												GetGlblSwitchesObject().
												GetFileType () ;

					if ( ANSI_FILE == eftOpt )
					{
						fprintf ( fpAppendFile, "%S", lpszMsg ) ;
					}
					else
					{
						fwprintf( fpAppendFile, L"%s", lpszMsg ) ;
					}
				}
			}

			SAFEDELETE(lpszDisp);
		}
	}
	catch(_com_error& e)
	{
		SAFEDELETE(lpszDisp);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		SAFEDELETE(lpszDisp);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	
}

/*----------------------------------------------------------------------------
   Name				 :CleanUpCharVector
   Synopsis	         :Clears the character vector
   Type	             :Global Function 
   Input parameter(s):
			cvCharVector - reference to character vector.
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :CleanUpCharVector(cvCharVector)
   Notes             :None
----------------------------------------------------------------------------*/
void CleanUpCharVector(CHARVECTOR& cvCharVector)
{
	if ( !cvCharVector.empty() )
	{
		CHARVECTOR::iterator theIterator;
		for (	theIterator = cvCharVector.begin();	
				theIterator < cvCharVector.end(); theIterator++  )
		{
			SAFEDELETE( *theIterator );
		}
		cvCharVector.clear();
	}
}

/*----------------------------------------------------------------------------
   Name				 :FindAndReplaceAll
   Synopsis	         :Search and replace all the occurences of pszFromStr 
					  with pszToStr in the given string strString
   Type	             :Global Function 
   Input parameter   :
			strString  - string buffer
			pszFromStr - string to searched and replaced
			pszToStr   - string to be replaced by
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :CleanUpCharVector(cvCharVector)
   Notes             :None
----------------------------------------------------------------------------*/
void FindAndReplaceAll(STRING& strString, _TCHAR* pszFromStr,_TCHAR* pszToStr)
{
	if ( pszFromStr != NULL && pszToStr != NULL )
	{
		STRING::size_type stPos = 0;
		STRING::size_type stFromPos = 0;
		STRING::size_type stFromStrLen = lstrlen(pszFromStr);
		STRING::size_type stToStrLen = lstrlen(pszToStr);
		while( TRUE )
		{
			stPos = strString.find(pszFromStr, stFromPos, stFromStrLen); 
			if ( stPos == STRING::npos )
				break;
			strString.replace(stPos, stFromStrLen, pszToStr);
			stFromPos = stPos + stToStrLen;
		}
	}
}

/*----------------------------------------------------------------------------
   Name				 :IsSysProp
   Synopsis	         :Returns true if the input property is a WMI system 
					  property
   Type	             :Global Function 
   Input parameter   :
			pszProp    - property name
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Notes             :IsSysProp(pszProp)
----------------------------------------------------------------------------*/
BOOL IsSysProp(_TCHAR* pszProp)
{
	BOOL bRet = FALSE;
	if (CompareTokens(pszProp, WMISYSTEM_CLASS) ||
		CompareTokens(pszProp, WMISYSTEM_DERIVATION) ||
		CompareTokens(pszProp, WMISYSTEM_DYNASTY) ||
		CompareTokens(pszProp, WMISYSTEM_GENUS) ||
		CompareTokens(pszProp, WMISYSTEM_NAMESPACE) ||
		CompareTokens(pszProp, WMISYSTEM_PATH) ||
		CompareTokens(pszProp, WMISYSTEM_PROPERTYCOUNT) ||
		CompareTokens(pszProp, WMISYSTEM_REPLATH) ||
		CompareTokens(pszProp, WMISYSTEM_SERVER) ||
		CompareTokens(pszProp, WMISYSTEM_SUPERCLASS))
	{
		bRet = TRUE;
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :EraseConsoleString
   Synopsis	         :Displays white spaces at the current cursor position 
					  and sets the cursor column to zero
   Type	             :Global Function 
   Input parameter   :String ID wich has to be wiped out, Console information prior to 
                       writing the string.
   Output parameters :None
   Return Type       :None
   Global Variables  :None
----------------------------------------------------------------------------*/

void EraseConsoleString(CONSOLE_SCREEN_BUFFER_INFO* csbiInfo)
{
	COORD						coord; 
	HANDLE						hStdOut		= NULL;
	WMICLIINT					nHeight		= 0;
	DWORD dWritten = 0;	
	CONSOLE_SCREEN_BUFFER_INFO lcsbiInfo;
	DWORD						XCordW = 0;
	DWORD						YCordW = 0;
	
	LPTSTR	lpszMsg = new _TCHAR [BUFFER1024];
    
	if( NULL == lpszMsg ) return; // NO MEMORY

	// Obtain the standard output handle
	hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

	GetConsoleScreenBufferInfo(hStdOut, &lcsbiInfo);

	XCordW = lcsbiInfo.dwCursorPosition.X - csbiInfo->dwCursorPosition.X;
	YCordW = lcsbiInfo.dwCursorPosition.Y - csbiInfo->dwCursorPosition.Y;

	dWritten =  XCordW + ( YCordW  * lcsbiInfo.dwMaximumWindowSize.X);

	if( dWritten > BUFFER1024 ) dWritten = BUFFER1024;

	FillMemory(lpszMsg, dWritten * sizeof(_TCHAR), '\0');

	// Get the screen buffer size. 
	if (hStdOut != INVALID_HANDLE_VALUE )
		nHeight = csbiInfo->srWindow.Bottom - csbiInfo->srWindow.Top;
	else
		nHeight = 0;

	// if console size is positive (to address redirection)
	if (nHeight > 0)
	{
		coord.X = 0;
		coord.Y = csbiInfo->dwCursorPosition.Y;
		SetConsoleCursorPosition(hStdOut, coord);
		WriteConsole(hStdOut,lpszMsg,dWritten,&dWritten,NULL);
		SetConsoleCursorPosition(hStdOut, coord);
	}
	SAFEDELETE(lpszMsg);
}

/*----------------------------------------------------------------------------
   Name				 :IsRedirection
   Synopsis	         :Returns true if the the output is being redirected 
   Type	             :Global Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Notes             :IsRedirection()
----------------------------------------------------------------------------*/
BOOL IsRedirection()
{
	HANDLE						hStdOut		= NULL;
	CONSOLE_SCREEN_BUFFER_INFO	csbiInfo; 
	WMICLIINT					nHeight		= 0;
	BOOL						bRet		= FALSE;

	// Obtain the standard output handle
	hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

	if (hStdOut != INVALID_HANDLE_VALUE)
	{
		// Get the screen buffer size. 
		if ( GetConsoleScreenBufferInfo(hStdOut, &csbiInfo) == TRUE )
			nHeight = csbiInfo.srWindow.Bottom - csbiInfo.srWindow.Top;
		else
			nHeight = 0;

		if (nHeight <= 0)
			bRet = TRUE;
	}
	else
		bRet = TRUE;
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :WMITRACEORERRORLOG
   Synopsis	         :To display the trace of COM methods invoked
   Type	             :Global Function 
   Input parameter   :
			hr		- HRESULT value
			nLine	- the line number of the file.
			pszFile	- the file name
			pszMsg  - message to be displayed.
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax	 :WMITRACEORERRORLOG(hr, nLine, pszFile, (LPCWSTR)chsMsg, 
										 eloErrLgOpt, bTrace)
   Note				 : Default values dwError = 0, pszResult = NULL. 	
----------------------------------------------------------------------------*/
void WMITRACEORERRORLOG(HRESULT hr, INT nLine, char* pszFile, _bstr_t bstrMsg, 
						DWORD dwThreadId, CParsedInfo& rParsedInfo, 
						BOOL bTrace, DWORD dwError, _TCHAR* pszResult)
{
	_TCHAR* pszMsg = bstrMsg;

	if ( pszMsg )
	{
		try
		{
			if ( bTrace == TRUE )
			{
				if (_tcsnicmp(pszMsg,_T("COMMAND:"),8) != 0)
				{
					CHString chsMessage;
					CHString chsSInfo;
					if (FAILED (hr))
						chsMessage.Format(L"FAIL: %s\n", pszMsg?pszMsg:L"NULL");
					else
						chsMessage.Format(L"SUCCESS: %s\n",pszMsg?pszMsg:L"NULL");			
						
					_fputts((_TCHAR*)_bstr_t((LPCWSTR)chsMessage), stderr);
					fflush(stderr);
					chsSInfo.Format(L"Line: %6d File: %s\n", nLine, 
													  (LPCWSTR)CHString(pszFile));
					_fputts((_TCHAR*)_bstr_t((LPCWSTR)chsSInfo), stderr);
					fflush(stderr);

					if ( pszResult != NULL )
					{
						chsMessage.Format(L"Result:  %s\n\n", pszResult);			
						_fputts((_TCHAR*)_bstr_t((LPCWSTR)chsMessage), stderr);
						fflush(stderr);
					}
					else
					{
						_fputts(_T("\n"), stderr);
						fflush(stderr);
					}
				}
			}
		}
		catch(_com_error& e)
		{
			_com_issue_error(e.Error());
		}
		catch(CHeap_Exception)
		{
			_com_issue_error(WBEM_E_OUT_OF_MEMORY);
		}

		if ( rParsedInfo.GetErrorLogObject().GetErrLogOption() != NO_LOGGING )
		{
			try
			{
				rParsedInfo.GetErrorLogObject().
					LogErrorOrOperation(hr, pszFile, nLine, pszMsg, 
								dwThreadId, dwError); 
			}
			catch(DWORD dwError)
			{
				::SetLastError(dwError);
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);
			}
		}
	}
}
	
/*----------------------------------------------------------------------------
   Name				 :DisplayWin32Error
   Synopsis	         :Displays the formatted error message for the Win32
					  function calls failure
   Type	             :Global Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax	 :DisplayWin32Error()
   Notes			 :None
----------------------------------------------------------------------------*/
void DisplayWin32Error()
{
	LPVOID	lpMessage	= NULL;
	DWORD	dwError		= ::GetLastError();

	try
	{
		// If there was an error, create a text message for it
		DWORD dwRet = FormatMessage	(	FORMAT_MESSAGE_ALLOCATE_BUFFER |
										FORMAT_MESSAGE_FROM_SYSTEM |
										FORMAT_MESSAGE_IGNORE_INSERTS,
										NULL,
										dwError,
										0, 
										(LPTSTR) &lpMessage,
										0,
										NULL
									);

		if ( 0 != dwRet )
		{
			_bstr_t bstrMsg;
			WMIFormatMessage(IDS_I_ERROR_WIN32, 1, bstrMsg, (LPWSTR) lpMessage);
			
			// Free the memory used up the error message
			// and then exit
			if ( NULL != lpMessage )
			{
				LocalFree(lpMessage);
				lpMessage = NULL ;
			}

			// Display the error message
			DisplayMessage((LPWSTR)bstrMsg, CP_OEMCP, TRUE, TRUE);
		}

		// Used for returning the error level
		::SetLastError(dwError);
	}
	catch(_com_error& e)
	{
		if ( lpMessage != NULL )
		{
			LocalFree(lpMessage);
			lpMessage = NULL ;
		}

		_com_issue_error(e.Error());
	}
}

/*----------------------------------------------------------------------------
   Name				 :AcceptPassword
   Synopsis	         :Prompts for the password when user name alone is 
					  specified with the command
   Type	             :Global Function 
   Input parameter   :None
   Output parameters :
			pszPassword  - password string
   Return Type       :void
   Global Variables  :None
   Calling Syntax	 :AcceptPassword(pszPassword)
   Notes             :None
----------------------------------------------------------------------------*/
void AcceptPassword(_TCHAR* pszPassword)
{
	// local variables
	TCHAR	ch;
	DWORD	dwIndex				= 0;
	DWORD	dwCharsRead			= 0;
	DWORD	dwCharsWritten		= 0;
	DWORD	dwPrevConsoleMode	= 0;
	HANDLE	hStdIn				= NULL;
	_TCHAR	szBuffer[BUFFER32]	= NULL_STRING;		

	// Get the handle for the standard input
	hStdIn = GetStdHandle( STD_INPUT_HANDLE );

	// Get the current input mode of the input buffer
	GetConsoleMode( hStdIn, &dwPrevConsoleMode );
	
	// Set the mode such that the control keys are processed by the system
	SetConsoleMode( hStdIn, ENABLE_PROCESSED_INPUT );
	
	//	Read the characters until a carriage return is hit
	while( TRUE )
	{
		if ( !ReadConsole( hStdIn, &ch, 1, &dwCharsRead, NULL ))
		{
			// Set the original console settings
			SetConsoleMode( hStdIn, dwPrevConsoleMode );
			return;
		}
		
		// Check for carraige return
		if ( ch == CARRIAGE_RETURN )
		{
			// break from the loop
			break;
		}

		// Check id back space is hit
		if ( ch == BACK_SPACE )
		{
			if ( dwIndex != 0 )
			{
				//
				// Remove a asterik from the console

				// move the cursor one character back
				FORMAT_STRING( szBuffer, _T( "%c" ), BACK_SPACE );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );
				
				// replace the existing character with space
				FORMAT_STRING( szBuffer, _T( "%c" ), BLANK_CHAR );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );

				// now set the cursor at back position
				FORMAT_STRING( szBuffer, _T( "%c" ), BACK_SPACE );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );

				// decrement the index 
				dwIndex--;
			}
			
			// process the next character
			continue;
		}

		// if the max password length has been reached then sound a beep
		if ( dwIndex == ( MAXPASSWORDSIZE - 1 ) )
		{
			WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), BEEP_SOUND, 1, 
				&dwCharsWritten, NULL );
		}
		else
		{
			// store the input character
			*( pszPassword + dwIndex ) = ch;
			dwIndex++;

			// display asterix onto the console
			WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), ASTERIX, 1, 
				&dwCharsWritten, NULL );
		}
	}

	// Add the NULL terminator
	*( pszPassword + dwIndex ) = NULL_CHAR;

	//Set the original console settings
	SetConsoleMode( hStdIn, dwPrevConsoleMode );

	// display the character ( new line character )
	FORMAT_STRING( szBuffer, _T( "%s" ), _T( "\n\n" ) );
	WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 2, 
		&dwCharsWritten, NULL );
}

/*----------------------------------------------------------------------------
   Name				 :IsValueSet
   Synopsis	         :Checks string passed in pszFromValue, Is a value set
					  or not.	
   Type	             :Global Function 
   Input parameter   :
			pszFromValue - string to be checked.
   Output parameters :
			cValue1		 - <value1> of value set.
			cValue2		 - <value2> of value set.
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax	 :IsValueSet(pszFromValue,cValue1,cValue2)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL IsValueSet(_TCHAR* pszFromValue, _TCHAR& cValue1, _TCHAR& cValue2)
{
	BOOL bValueSet = FALSE;
	
	if ( pszFromValue != NULL )
	{
		_TCHAR cV1 = _T('\0'), cV2 = _T('\0');

		if ( lstrlen(pszFromValue) == 3 && pszFromValue[1] == _T('-') )
		{
			bValueSet = TRUE;
			cV1 = pszFromValue[0];
			cV2 = pszFromValue[2];
			cValue1 = ( cV1 < cV2 ) ? cV1 : cV2 ;
			cValue2 = ( cV1 > cV2 ) ? cV1 : cV2 ;
		}
	}
	else
		cValue1 = cValue2 = _T('\0');

	return bValueSet;
}

/*----------------------------------------------------------------------------
   Name				 :DisplayString
   Synopsis	         :Displays localized string
   Type	             :Global Function
   Input parameter(s):
			uID		  - string table identifier
			uCP		  - codepage value
			lpszParam - String to be used as parameter in resource string.
			bIsError  - Boolean type specifying error message or not.
			bIsLog    - Boolean type specifying message to be logged or not.
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DisplayString(uID, CP_OEMCP, NULL, TRUE, TRUE)
   Notes             :lpszParam = NULL, bIsError = FALSE, and bIsLog = FALSE
					  by default.	
----------------------------------------------------------------------------*/
void DisplayString(UINT uID, UINT uCP, LPTSTR lpszParam,
				   BOOL bIsError, BOOL bIsLog) throw(WMICLIINT)
{
	LPVOID lpMsgBuf = NULL;
	LPTSTR	lpszMsg		= NULL;
	lpszMsg = new _TCHAR [BUFFER1024];
	try
	{
		if (lpszMsg)
		{
			LoadString(NULL, uID, lpszMsg, BUFFER1024);
			if (lpszParam)
			{
				char* pvaInsertStrs[1];
				pvaInsertStrs[0] = (char*)	lpszParam;

				DWORD dwRet = FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER | 
						FORMAT_MESSAGE_FROM_STRING | 
						FORMAT_MESSAGE_ARGUMENT_ARRAY,
						lpszMsg,
						0, 
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
						(LPTSTR) &lpMsgBuf,
						0,
						pvaInsertStrs);

				if (dwRet == 0)
				{
					SAFEDELETE(lpszMsg);
					throw (::GetLastError());
				}
			}

			DisplayMessage	(
								( lpMsgBuf ) ? ( LPTSTR ) lpMsgBuf : lpszMsg,
								uCP,
								bIsError,
								bIsLog
							) ;

			SAFEDELETE(lpszMsg);

			// Free the memory used up the error message
			// and then exit
			if ( lpMsgBuf != NULL )
			{
				LocalFree(lpMsgBuf);
				lpMsgBuf = NULL ;
			}
		}
		else
			throw OUT_OF_MEMORY;
	}
	catch(_com_error& e)
	{
		if ( lpMsgBuf != NULL )
		{
			LocalFree(lpMsgBuf);
			lpMsgBuf = NULL ;
		}

		SAFEDELETE(lpszMsg);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		if ( lpMsgBuf != NULL )
		{
			LocalFree(lpMsgBuf);
			lpMsgBuf = NULL ;
		}

		SAFEDELETE(lpszMsg);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	
}

/*----------------------------------------------------------------------------
   Name				 :SubstituteEscapeChars
   Synopsis	         :Substitue escape character i.e '\' before the 
					  specified substring
   Type	             :Global Function
   Input parameter   :
			sSource	- source string
			lpszSub	- substring to be searched for
   Output parameters :
			sSource	- source string
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SubstituteEscapeChars(sTemp, lpszSub)
   Notes             :None
----------------------------------------------------------------------------*/
void SubstituteEscapeChars(CHString& sTemp, LPCWSTR lpszSub)
{
	try
	{
		CHString str(sTemp);
		sTemp.Empty();
		while ( str.GetLength() > 0 )
		{
			//LONG lPos = str.Find( L"\"" );
			LONG lPos = str.Find(lpszSub);
			if ( lPos != -1 )
			{
				sTemp += str.Left( lPos ) + L"\\\"";
				str = str.Mid( lPos + 1 );
			}
			else 
			{
				sTemp += str;
				str.Empty();
			}
		}
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*----------------------------------------------------------------------------
   Name				 :RemoveEscapeChars
   Synopsis	         :Remove escape character i.e '\' before any of the 
					  following characters 
					  	
   Type	             :Global Function
   Input parameter(s):
			sSource	- source string
   Output parameter(s):
			sSource	- source string
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :RemoveEscapeChars(sTemp)
   Notes             :None
----------------------------------------------------------------------------*/
void RemoveEscapeChars(CHString& sTemp)
{
	try
	{
		CHString str(sTemp);
		sTemp.Empty();
		while ( str.GetLength() > 0 )
		{
			LONG lPos = str.Find(L"\\");
			if ( lPos != -1 )
			{
				if (str.GetAt(lPos+1) == L'"') 
				{
					sTemp += str.Left( lPos );				
				}
				else
				{
					sTemp += str.Left( lPos ) + L"\\";
				}
				str = str.Mid( lPos + 1 );
			}
			else 
			{
				sTemp += str;
				str.Empty();
			}
		}
	}
	catch(CHeap_Exception)
	{
		throw OUT_OF_MEMORY;
	}
}

/*----------------------------------------------------------------------------
   Name				 :FrameNamespace
   Synopsis	         :Frame the new namespace 
   Type	             :Global Function
   Input parameter(s):
		pszRoleOrNS			- old namespace
		pszRoleOrNSToUpdate	- string to be appended/replaced
   Output parameter(s):
		pszRoleOrNSToUpdate	- new namespace
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameNamespace(pszRoleOrNS, pszRoleOrNSToUpdate)
   Notes             :None
----------------------------------------------------------------------------*/
void FrameNamespace(_TCHAR* pszRoleOrNS, _TCHAR* pszRoleOrNSToUpdate)
{
	if ( pszRoleOrNS != NULL && pszRoleOrNSToUpdate != NULL )
	{
		LONG lRoleOrNSLen = lstrlen(pszRoleOrNS);
		LONG lRoleOrNSToUpdate = lstrlen(pszRoleOrNSToUpdate);

		_TCHAR *pszTemp = new _TCHAR[lRoleOrNSLen + lRoleOrNSToUpdate +
									 MAX_BUFFER]; 
		if ( pszTemp != NULL )
		{
			if (!CompareTokens(pszRoleOrNS, CLI_TOKEN_NULL))
			{
				//if the role does not begin with a '\\' it should be assumed
				//to be relative to the current role

				if ( _tcsncmp(pszRoleOrNS, CLI_TOKEN_2BSLASH, 2) == 0 )
					lstrcpy(pszTemp, pszRoleOrNS+2);
				else if (_tcsncmp(pszRoleOrNS, CLI_TOKEN_2DOT, 2) == 0 )
				{
					_TCHAR *lp = NULL;
					for (lp = &pszRoleOrNSToUpdate[lstrlen(pszRoleOrNSToUpdate) - 1]; 
						lp > pszRoleOrNSToUpdate; lp--)
					{
						if (_tcsncmp(lp,CLI_TOKEN_2BSLASH,1) == 0)
						{	lstrcpy(lp,NULL_STRING);
							break;
						}
					}
					lstrcpy(pszTemp, pszRoleOrNSToUpdate);
					if (_tcsncmp(pszRoleOrNS + 2, NULL_STRING, 1))
					{
						lstrcat(pszTemp, pszRoleOrNS + 2);
					}
				}
				else
				{			
					lstrcpy(pszTemp, pszRoleOrNSToUpdate);
					lstrcat(pszTemp, CLI_TOKEN_BSLASH);
					lstrcat(pszTemp, pszRoleOrNS);
				}
				//if the last character in the string pszRoleOrNS terminates 
				//with '\' terminate the string.
				//this case occurs when namespace is specified as "xyz\"
				if(CompareTokens(pszTemp + (WMICLIINT)lstrlen(pszTemp)-1, 
					CLI_TOKEN_BSLASH ) && 
						!CompareTokens(pszTemp, CLI_TOKEN_2BSLASH))
				{
					pszTemp[lstrlen(pszTemp) - 1] = _T('\0');
				}
			}
			else
				lstrcpy(pszTemp, CLI_TOKEN_NULL);

			lstrcpy(pszRoleOrNSToUpdate, pszTemp);
			SAFEDELETE(pszTemp);
		}
		else
			throw OUT_OF_MEMORY;
	}
	else
		throw OUT_OF_MEMORY;
}

/*----------------------------------------------------------------------------
   Name				 :SetScreenBuffer
   Synopsis	         :Set the buffer size of the command line to the 
					  following:
					  1) Width	- 500
					  2) Height - 3000	
   Type	             :Global Function
   Input parameter(s):
			nHeight	 - height of the console buffer
			nWidth	 - width of the console buffer
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetScreenBuffer(nHeight, nWidth)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL SetScreenBuffer(SHORT nHeight, SHORT nWidth)
{
	BOOL bResult = FALSE;

	COORD	coord;
	coord.X = nWidth;
	coord.Y = nHeight;
    HANDLE	hStdOut = GetStdHandle(STD_OUTPUT_HANDLE); 
	if ( hStdOut != INVALID_HANDLE_VALUE &&
		 hStdOut != (HANDLE)0x00000013 ) // For telnet
	{
		// Set the console screen buffer info
		bResult = SetConsoleScreenBufferSize(hStdOut, coord);
	}

	return bResult;
}

/*----------------------------------------------------------------------------
   Name				 :GetScreenBuffer
   Synopsis	         :Get the buffer size of the command line
   Type	             :Global Function
   Input parameter(s):None
   Output parameter(s):
			nHeight	 - height of the console buffer
			nWidth	 - width of the console buffer
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetScreenBuffer(nHeight, nWidth)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL GetScreenBuffer(SHORT& nHeight, SHORT& nWidth)
{
	BOOL bResult = FALSE;

	HANDLE	hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if ( hStdOut != INVALID_HANDLE_VALUE &&
		 hStdOut != (HANDLE)0x00000013 ) // For telnet
	{
		CONSOLE_SCREEN_BUFFER_INFO csbConsoleScreenBufferInfo;
		// Set the console screen buffer info
		if ( GetConsoleScreenBufferInfo(hStdOut, &csbConsoleScreenBufferInfo) == TRUE )
		{
			nHeight = csbConsoleScreenBufferInfo.dwSize.Y;
			nWidth = csbConsoleScreenBufferInfo.dwSize.X;

			bResult = TRUE;
		}
		else
		{
			nHeight = 0;
			nWidth = 0;
		}
	}

	return bResult;
}

/*----------------------------------------------------------------------------
   Name				 :WMIFormatMessage
   Synopsis	         :This function loads the resource string using the 
					  ID of the string and does parameter substituion using
					  the FormatMessage() function.	
   Type	             :Global Function
   Input parameter(s):
			uID			- resource ID
			nParamCount - no. of. parameter(s) to be substituted.
			lpszParam	- first parameter. (%1)
			...			- variable number of arguments (%2, %3, ...)
   Output parameter(s):
			bstrMSG		- formatted message
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :WMIFormatMessage(uID, nParamCount, bstrMsg, 
							lpszParam,)
   Notes             :None
----------------------------------------------------------------------------*/
void WMIFormatMessage(UINT uID, WMICLIINT nParamCount, _bstr_t& bstrMsg, 
					  LPTSTR lpszParam, ...)
{
	// Load the resource string 
	_TCHAR	pszMsg[BUFFER1024];
	LoadString(NULL, uID, pszMsg, BUFFER1024);

	// If parameters are specified.
	if (lpszParam)
	{
		LPTSTR lpszTemp				= lpszParam;
		INT		nLoop				= 0;
		char*	pvaInsertStrs[5];

		va_list marker;
		va_start(marker, lpszParam);
	
		while (TRUE)
		{
			pvaInsertStrs[nLoop++] = (char*) lpszTemp;
			lpszTemp = va_arg(marker, LPTSTR);

			if (nLoop == nParamCount)
				break;
		}
		va_end(marker);
			
		LPVOID lpMsgBuf = NULL;
		DWORD dwRet = FormatMessage	(
										FORMAT_MESSAGE_ALLOCATE_BUFFER | 
										FORMAT_MESSAGE_FROM_STRING | 
										FORMAT_MESSAGE_ARGUMENT_ARRAY,
										pszMsg,
										0, 
										MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
										(LPTSTR) &lpMsgBuf,
										0,
										pvaInsertStrs
									);

		if ( 0 != dwRet )
		{
			if ( lpMsgBuf )
			{
				bstrMsg = (WCHAR*)lpMsgBuf;

				// Free the memory used for the message and then exit
				LocalFree(lpMsgBuf);
				lpMsgBuf = NULL ;
			}
		}
		else
		{
			bstrMsg = pszMsg;
		}
	}
	else
	{
		bstrMsg = pszMsg;
	}
}

/*----------------------------------------------------------------------------
   Name				 :InitWinsock
   Synopsis	         :This function initiates the windows sockets interface.
   Type	             :Global Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :InitWinsock ()
   Notes             :None
----------------------------------------------------------------------------*/
BOOL InitWinsock ()
{
	BOOL	bSuccess	= TRUE;
	WMICLIINT nRes;
	WSADATA wsaData;
	WORD wVerRequested = 0x0101; // ver 1.1

	//	The Windows Sockets WSAStartup function initiates use of Ws2_32.dll 
	//  by a process.
	// Init the sockets interface
	nRes = WSAStartup (wVerRequested, &wsaData);
	if (nRes)
		bSuccess = FALSE;

	return bSuccess;
}

/*----------------------------------------------------------------------------
   Name				 :TermWinsock
   Synopsis	         :This function uninitializes the windows sockets 
					  interface.
   Type	             :Global Function
   Input parameter   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :TermWinsock ()
   Notes             :None
----------------------------------------------------------------------------*/
BOOL TermWinsock ()
{
	// Uninitailize windows socket interface.
	BOOL	bSuccess = TRUE;
	if (SOCKET_ERROR == WSACleanup ())
		bSuccess = FALSE;

	return bSuccess;
}

/*----------------------------------------------------------------------------
   Name				 :PingNode
   Synopsis	         :Pings a node to validate availibility of node using
					  windows socket functions.	 
   Type	             :Global Function
   Input parameter   :
			pszNode  - Pointer to a string specifing node name.
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :PingNode(pszNode)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL PingNode(_TCHAR* pszNode)
{
	BOOL	bRet				= TRUE;
	HOSTENT	*pNodeEnt			= NULL;
	HANDLE	hIcmpHandle			= NULL;
    char    *pszSendBuffer		= NULL;
	char    *pszRcvBuffer		= NULL;
    UINT    nSendSize			= DEFAULT_SEND_SIZE;
    UINT    nRcvSize			= DEFAULT_BUFFER_SIZE;
	ULONG	nTimeout			= PING_TIMEOUT;
    UCHAR   *pszOpt				= NULL;
    UINT    nOptLength			= 0;
	ULONG	ulINAddr			= INADDR_NONE;
    UCHAR   uFlags				= 0;
	DWORD	dwNumOfReplies		= 1; // Set 1 for finding error
    IP_OPTION_INFORMATION ioiSendOpts;

	try
	{
		if ( pszNode )
		{
			// pszNode can be IPAddress of node or node name itself. 
			_bstr_t	bstrNodeNameOrIPAddr(pszNode);

			// Initialize windows socket interface.
			if ( g_wmiCmd.GetInitWinSock() == FALSE )
			{
				bRet = InitWinsock();
				g_wmiCmd.SetInitWinSock(bRet);
			}
			
			if ( bRet == TRUE )
			{
				// Get IPAddress. 
				ulINAddr = inet_addr((char*)bstrNodeNameOrIPAddr);
				// If not an IP address. then it may be computername.
				if ( ulINAddr == INADDR_NONE )
				{
					pNodeEnt = gethostbyname((char*)bstrNodeNameOrIPAddr);
					if ( pNodeEnt == NULL)
					{
						bRet = FALSE; // "computername" is not found.
					}
					else
					{
						ulINAddr  = *(DWORD *)pNodeEnt->h_addr ; 
					}
				}
			}

			if ( bRet == TRUE )
			{
				// Create IcmpFile
				hIcmpHandle	= IcmpCreateFile();
				if ( hIcmpHandle == INVALID_HANDLE_VALUE )
					throw GetLastError();

				// Alloc memory to send buffer
				pszSendBuffer = (char*)LocalAlloc(LMEM_FIXED, nSendSize);
				if ( pszSendBuffer == NULL )
					throw GetLastError();

				// Fill Some data in send buffer
				for (WMICLIINT i = 0; i < nSendSize; i++) 
				{
					pszSendBuffer[i] = 'a' + (i % 23);
				}

				// Initialize the send options
				ioiSendOpts.OptionsData = pszOpt;
				ioiSendOpts.OptionsSize = (UCHAR)nOptLength;
				ioiSendOpts.Ttl = DEFAULT_TTL;
				ioiSendOpts.Tos = DEFAULT_TOS;
				ioiSendOpts.Flags = uFlags;

				// Alloc memory to receive buffer
				pszRcvBuffer = (char*)LocalAlloc(LMEM_FIXED, nRcvSize);
				if ( pszRcvBuffer == NULL )
					throw GetLastError();

				dwNumOfReplies = IcmpSendEcho(hIcmpHandle,
											  (IPAddr)ulINAddr,
											  pszSendBuffer,
											  (unsigned short) nSendSize,
											  &ioiSendOpts,
											  pszRcvBuffer,
											  nRcvSize,
											  nTimeout);
				if ( dwNumOfReplies == 0 )
					throw GetLastError();

				// Free memory
				LocalFree(pszSendBuffer);
				LocalFree(pszRcvBuffer);
				IcmpCloseHandle(hIcmpHandle);
			}
		}
		else
			bRet = FALSE; // Null nodename pointer.
	}
	catch(_com_error& e)
	{
		// Free memory
		if ( hIcmpHandle != NULL )
			IcmpCloseHandle(hIcmpHandle);
		if ( pszSendBuffer != NULL )
			LocalFree(pszSendBuffer);
		if ( pszRcvBuffer != NULL )
			LocalFree(pszRcvBuffer);
		bRet = FALSE;
		_com_issue_error(e.Error());
	}
	catch (DWORD dwError)
	{
		// if ping failed then don't display win32 error
		if ( dwNumOfReplies != 0 )
		{
			::SetLastError(dwError);
			DisplayWin32Error();
			::SetLastError(dwError);
		}
		bRet = FALSE;
		// Free memory
		if ( hIcmpHandle != NULL )
			IcmpCloseHandle(hIcmpHandle);
		if ( pszSendBuffer != NULL )
			LocalFree(pszSendBuffer);
		if ( pszRcvBuffer != NULL )
			LocalFree(pszRcvBuffer);
	}
	catch (CHeap_Exception)
	{
		// Free memory
		if ( pszSendBuffer != NULL )
			LocalFree(pszSendBuffer);
		if ( hIcmpHandle != NULL )
			IcmpCloseHandle(hIcmpHandle);
		if ( pszRcvBuffer != NULL )
			LocalFree(pszRcvBuffer);
		bRet = FALSE;
	}

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :IsFailFastAndNodeExist
   Synopsis	         :Validates node if FailFast is on, If pszNodeName == NULL
					  then check for GetNode() else pszNodeName itself. 
   Type	             :Global Function
   Input parameter(s):
		rParsedInfo  - reference to object of CParsedInfo.
		pszNode		 - Pointer to a string specifing node name.
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsFailFastAndNodeExist(rParsedInfo, pszNode)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL IsFailFastAndNodeExist(CParsedInfo& rParsedInfo, _TCHAR* pszNode)
{
	BOOL	bRet	= TRUE;
	
	// If FailFast is on.
	if ( rParsedInfo.GetGlblSwitchesObject().GetFailFast() == TRUE )
	{
		// Form the appropriate node name. If pszNodeName != NULL pszNode 
		// should be validated. Else Node stored should be validated.
		_TCHAR*		pszNodeName = NULL;
		if (pszNode == NULL)
			pszNodeName = rParsedInfo.GetGlblSwitchesObject().GetNode();
		else
			pszNodeName = pszNode;

		// "." node name specifies local machine and need not to be validated.
		if ( CompareTokens(pszNodeName, CLI_TOKEN_DOT) == FALSE )
		{
			// If pinging node fails then node is unavialable. 
			if ( PingNode(pszNodeName) == FALSE )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_RPC_SERVER_NOT_AVAILABLE);
				bRet = FALSE;
			}
		}
	}

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :GetBstrTFromVariant
   Synopsis	         :Get _bstr_t object equivalent to Varaint passed.
   Type	             :Global Function
   Input parameter(s):
			vtVar	 - variant object
			pszType	 - Pointer to string specifying type of the object passed.
   Output parameter(s):
			bstrObj	- BSTR object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetBstrTFromVariant(vtVar, bstrObj)
   Notes             :None
----------------------------------------------------------------------------*/
void GetBstrTFromVariant(VARIANT& vtVar, _bstr_t& bstrObj,
						 _TCHAR* pszType)
{
	VARTYPE	vType;
	VARIANT vtDest;
	VariantInit(&vtDest);

	try
	{
		if ( vtVar.vt != VT_NULL && vtVar.vt != VT_EMPTY )
		{
			if ( VariantChangeType(&vtDest, &vtVar,0 , VT_BSTR) == S_OK )
            {
                bstrObj = _bstr_t(vtDest);
            }
            else
            {
                // The following line assures that
                // if an exception is thrown (say
                // in the bstr_t allocation below)
                // VariantClear in the catch statement
                // won't try to clear anything.
                V_VT(&vtDest) = VT_EMPTY;

			    if ( vtVar.vt == VT_UNKNOWN )
			    {
				    if ( pszType != NULL )
                    {
					    bstrObj = _bstr_t(pszType);
                    }
				    else
                    {
					    bstrObj = _bstr_t("<Embeded Object>");
                    }
			    }
			    else if ( SafeArrayGetVartype(vtVar.parray, &vType) == S_OK )
			    {
				    if ( pszType != NULL )
                    {
					    bstrObj = _bstr_t("<Array of ") + _bstr_t(pszType) + 
							      _bstr_t(">");
                    }
				    else
                    {
					    bstrObj = _bstr_t("<Array>");
                    }
			    }
			    else
                {
				    bstrObj = _bstr_t("UNKNOWN");
                }
            }
		}
		else
        {
			bstrObj = _bstr_t(_T("<null>"));
        }

		VARIANTCLEAR(vtDest);
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(vtDest);
		_com_issue_error(e.Error());
	}
}
/*----------------------------------------------------------------------------
   Name				 :IsValidFile
   Synopsis	         :This functions checks if a given file name is
					  Valid.
   Type	             :Global Function
   Input parameter(s):
		pszFileName  - String type, Name of the file to be validated
   Output parameter(s):None
   Return Type       :RETCODE
   Global Variables  :None
   Calling Syntax    :IsValidFile(pszFileName)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE IsValidFile(_TCHAR* pszFileName)
{
	RETCODE bRet = PARSER_ERROR;
	BOOL	bValidFileName	= TRUE;

	LONG lFileNameLen	= lstrlen(pszFileName);
	LONG lCount			= lFileNameLen;
	while( lCount >= 0 )
	{
		if (pszFileName[lCount] == _T('\\'))
			break;

		lCount--;
	}

	if(lCount != 0)
		lCount++;

	while( lCount <= lFileNameLen )
	{
		if( pszFileName[lCount] == _T('/') ||
			pszFileName[lCount] == _T('\\') ||
			pszFileName[lCount] == _T(':') ||
			pszFileName[lCount] == _T('*') ||
			pszFileName[lCount] == _T('?') ||
			pszFileName[lCount] == _T('\"') ||
			pszFileName[lCount] == _T('<') ||
			pszFileName[lCount] == _T('>') ||
			pszFileName[lCount] == _T('|') )
		{
			bValidFileName = FALSE;
			break;
		}

		lCount++;
	}

	if ( pszFileName != NULL && bValidFileName == TRUE)
	{
		FILE *fpFile = _tfopen(pszFileName, _T("a"));

		if ( fpFile != NULL )
		{
			LONG lFileHandle = _fileno(fpFile);
			if ( _filelength(lFileHandle) == 0)
			{
				if ( fclose(fpFile) == 0 )
				{
					if ( _tremove(pszFileName) == 0 )
						bRet = PARSER_CONTINUE;
					else
					{
						DisplayWin32Error();
						bRet = PARSER_ERRMSG;
					}
				}
			}
			else if ( fclose(fpFile) == 0 )
					bRet = PARSER_CONTINUE;
		}

	}

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :FindAndReplaceEntityReferences
   Synopsis	         :Search and replace all the occurences of entity 
					  references.
   Type	             :Global Function 
   Input parameter(s):
			strString  - string buffer
   Output parameter(s):None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FindAndReplaceEntityReferences(strString);
   Notes             :None
----------------------------------------------------------------------------*/
void FindAndReplaceEntityReferences(_bstr_t& bstrString)
{
	STRING strString((_TCHAR*)bstrString);

	FindAndReplaceAll(strString, _T("&"), _T("&amp;"));
	FindAndReplaceAll(strString, _T("<"), _T("&lt;"));
	FindAndReplaceAll(strString, _T(">"), _T("&gt;"));
	FindAndReplaceAll(strString, _T("\'"), _T("&apos;"));
	FindAndReplaceAll(strString, _T("\""), _T("&quot;"));
	try
	{
		bstrString = _bstr_t((LPTSTR)strString.data());
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*----------------------------------------------------------------------------
   Name				 :IsOption
   Synopsis	         :It checks whether the current token indicates option. An
					  option can start with '/' or '-'
   Type	             :Global Function
   Input Parameter(s):
		pszToken	 - pointer to token.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsOption(pszToken)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL IsOption(_TCHAR* pszToken)
{
	BOOL bRet = TRUE;
	if ( pszToken != NULL )
	{
		bRet = (CompareTokens(pszToken, CLI_TOKEN_FSLASH) 
				|| CompareTokens(pszToken, CLI_TOKEN_HYPHEN))
				? TRUE : FALSE;
	}
	else
		bRet = FALSE;
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :IsClassOperation
   Synopsis	         :It checks whether the current operation is class 
						level operation or instance level operation
   Type	             :Global Function
   Input Parameter(s):
	    rParsedInfo		 - reference to CParsedInfo class object
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsClassOperation(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL IsClassOperation(CParsedInfo& rParsedInfo)
{
	BOOL bClass = FALSE;
	if ( rParsedInfo.GetCmdSwitchesObject().GetAliasName() == NULL 
		&& (rParsedInfo.GetCmdSwitchesObject().
									GetWhereExpression() == NULL)
		&& (rParsedInfo.GetCmdSwitchesObject().
									GetPathExpression() == NULL))
	{
		bClass = TRUE;
	}

	return bClass;
}

/*-------------------------------------------------------------------------
   Name				 :ModifyPrivileges
   Synopsis	         :This function enables/disables all the token privileges
					  for current process token.
   Type	             :Global Function
   Input Parameter(s):
			bEnable	 -  Enable|Disable privileges flag
   Output Parameter(s):None
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :ModifyPrivileges(bEnable)
   Notes             :none
-------------------------------------------------------------------------*/
HRESULT ModifyPrivileges(BOOL bEnable)
{
	HANDLE		hToken		= NULL;
	DWORD		dwError		= ERROR_SUCCESS, 
				dwLen		= 0;	
	BOOL		bRes		= TRUE;
	TOKEN_USER	tu;
	HRESULT		hr			= WBEM_S_NO_ERROR;
	BYTE		*pBuffer	= NULL;

	// Open the access token associated with the current process. 
    bRes = OpenProcessToken(GetCurrentProcess(), 
							TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, 
							&hToken);

	if (bRes) 
	{
		// If disable privilges
		if (!bEnable)
		{
			// Store the information back into the token,after disabling all 
			// the privileges
			bRes = AdjustTokenPrivileges(hToken, TRUE, NULL, 0, NULL, NULL);
			if (!bRes)
				hr = WBEM_E_ACCESS_DENIED;
		}
		else // If enable privileges
		{
			// Get the privileges
			memset(&tu,0,sizeof(TOKEN_USER));
			bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, 
					sizeof(TOKEN_USER), &dwLen); 
			pBuffer = new BYTE[dwLen];
			if(pBuffer != NULL)
			{
				bRes = GetTokenInformation(hToken, TokenPrivileges, 
									pBuffer, dwLen, &dwLen);
				if (bRes)
				{
					// Iterate through all the privileges and enable them all
					TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
					for (DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
					{
						pPrivs->Privileges[i].Attributes 
											|= SE_PRIVILEGE_ENABLED;
					}
					// Store the information back into the token
					bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, 
													NULL, NULL);
					if (!bRes)
						hr = WBEM_E_ACCESS_DENIED;				
				}
				else
					hr = WBEM_E_ACCESS_DENIED;
				SAFEDELETE(pBuffer);
			}
			else
				hr = WBEM_E_OUT_OF_MEMORY;
		}
		CloseHandle(hToken); 
	}
	else
		hr = WBEM_E_ACCESS_DENIED;
	return hr;
}

/*-------------------------------------------------------------------------
   Name				 :RemoveParanthesis
   Synopsis	         :This function removes the opening and closing
					  paranthesis in the given string.
   Type	             :Global Function
   Input Parameter(s):
			pszString	 -  String which has paranthesis.
   Output Parameter(s):None
   Return Type       :void 
   Global Variables  :None
   Calling Syntax    :RemoveParanthesis(pszString)
   Notes             :none
-------------------------------------------------------------------------*/
void RemoveParanthesis(_TCHAR*& pszString)
{
	if ((lstrlen(pszString) - 1) > 0)
	{
		// Check if the string is enclosed within quotes
		if ((pszString[0] == _T('(')) 
				&& (pszString[lstrlen(pszString)-1] == _T(')')))
		{
			WMICLIINT nLoop = 1, nLen = lstrlen(pszString)-1; 
			while (nLoop < nLen)
			{
				pszString[nLoop-1] = pszString[nLoop];
				nLoop++;
			}
			pszString[nLen-1] = _T('\0');
		}
	}
}

/*-------------------------------------------------------------------------
   Name				 :TrimBlankSpaces
   Synopsis	         :This function removes the leading and trailing blank
					  spaces in the given string.
   Type	             :Global Function
   Input Parameter(s):
			pszString	 -  String in which leading and trailing spaces to be
							removed..
   Output Parameter(s):None
   Return Type       :void 
   Global Variables  :None
   Calling Syntax    :TrimBlankSpaces(pszString)
   Notes             :none
-------------------------------------------------------------------------*/
void TrimBlankSpaces(_TCHAR	*pszString)
{
	if ((lstrlen(pszString) - 1) > 0)
	{
		WMICLIINT		nLengthOfString = lstrlen(pszString);
		WMICLIINT		nNoOfBlanksAtBegin = 0;
		WMICLIINT		nNoOfBlanksAtEnd = 0;

		// find the noof blank chars at begining
		for(WMICLIINT i=0; i<nLengthOfString; ++i)
		{
			if( pszString[i] != _T(' ') ) 
				break;
			else
				nNoOfBlanksAtBegin++;
		}

		// find the noof blank chars at end
		for(WMICLIINT i=nLengthOfString - 1; i>=0; --i)
		{
			if( pszString[i] != _T(' ') ) 
				break;
			else
				nNoOfBlanksAtEnd++;
		}

		// Remove the blanks at begining
		if( nNoOfBlanksAtBegin > 0 )
		{
			// Shift the chars front
			WMICLIINT nLoop = nNoOfBlanksAtBegin;

			while ( nLoop < nLengthOfString )
			{
				pszString[nLoop - nNoOfBlanksAtBegin] = pszString[nLoop];
				nLoop++;
			}
			pszString[nLengthOfString-nNoOfBlanksAtBegin] = _T('\0');
		}

		// Remove the blanks at end
		if ( nNoOfBlanksAtEnd > 0)
			pszString[lstrlen(pszString) - nNoOfBlanksAtEnd] = _T('\0');

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\helpinfo.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: HelpInfo.h 
Project Name				: WMI Command Line
Author Name					: C. V. Nandi
Date of Creation (dd/mm/yy) : 29th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CHelpInfo
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 16th-January-2001
****************************************************************************/ 
// HelpInfo.h : header file
//
/*--------------------------------------------------------------------------
 Class Name			: CHelpInfo
 Class Type			: Concrete 
 Brief Description	: The CHelpInfo class encapsulates the functionality 
					  needed for storing and retrieving help Flag for 
					  displaying help.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
/////////////////////////////////////////////////////////////////////////////
// CHelpInfo
class CHelpInfo
{
public:
//	Construction
	CHelpInfo();

//	Destruction
	~CHelpInfo();

//	Restrict Assignment
	CHelpInfo& operator=(CHelpInfo& rHelpInfo);

//	Attributes
private:
	// Global Switches Help
	BOOL	m_bGlblAllInfoHelp;
	BOOL	m_bNameSpaceHelp;
	BOOL	m_bRoleHelp;
	BOOL	m_bNodeHelp;
	BOOL	m_bUserHelp;
	BOOL	m_bPasswordHelp;
	BOOL	m_bLocaleHelp;
	BOOL	m_bRecordPathHelp;
	BOOL	m_bPrivilegesHelp;
	BOOL	m_bLevelHelp;
	BOOL	m_bAuthLevelHelp;
	BOOL	m_bInteractiveHelp;
	BOOL	m_bTraceHelp;
	BOOL	m_bAggregateHelp;
	BOOL	m_bAuthorityHelp;

	// Command Switches Help
	BOOL m_bCmdAllInfoHelp;

	BOOL	m_bGetVerbHelp;
	BOOL	m_bSetVerbHelp;
	BOOL	m_bListVerbHelp;
	BOOL	m_bCallVerbHelp;
	BOOL	m_bDumpVerbHelp;
	BOOL	m_bAssocVerbHelp;
	BOOL	m_bCreateVerbHelp;
	BOOL	m_bDeleteVerbHelp;
	BOOL	m_bAliasVerbHelp;
	BOOL	m_bPATHHelp;
	BOOL	m_bWHEREHelp;
	BOOL	m_bCLASSHelp;
	BOOL	m_bEXITHelp;
	BOOL	m_bPWhereHelp;
	BOOL	m_bTRANSLATEHelp;
	BOOL	m_bEVERYHelp;
	BOOL	m_bFORMATHelp;
	BOOL	m_bVERBSWITCHESHelp;
	BOOL	m_bDESCRIPTIONHelp;
	BOOL	m_bGETSwitchesOnlyHelp;
	BOOL	m_bLISTSwitchesOnlyHelp;
	BOOL	m_bContextHelp;
	BOOL	m_bGlblSwitchValuesHelp;
	BOOL    m_bRESULTCLASSHelp;
	BOOL    m_bRESULTROLE;
	BOOL    m_bASSOCCLASS;
	BOOL    m_bASSOCSwitchesOnlyHelp;
	BOOL    m_bFAILFASTHelp;
	BOOL    m_bREPEATHelp;
	BOOL    m_bOUTPUTHelp;
	BOOL    m_bAPPENDHelp;
//	Operations
public :
	//Initializes the member variables
	void Initialize();
	
	//sets the help flag for the item specified by htHelp argument
	void SetHelp( HELPTYPE htHelp, BOOL bFlag );
	
	//Gets the help flag for the item specified by htHelp argument
	BOOL GetHelp( HELPTYPE htHelp );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\helpinfo.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: HelpInfo.cpp 
Project Name				: WMI Command Line
Author Name					: C. V. Nandi
Date of Creation (dd/mm/yy) : 29th-September-2000
Version Number				: 1.0 
Brief Description			: The CHelpInfo class encapsulates the 
							  functionality needed for storing and retrieving 
							  help Flag for displaying help..
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy	
		Last Modified Date	: 16th-January-2001
****************************************************************************/ 
// HelpInfo.cpp : implementation file
//
#include "Precomp.h"
#include "HelpInfo.h"

/*------------------------------------------------------------------------
   Name				 :CHelpInfo
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CHelpInfo::CHelpInfo()
{
	Initialize();
}

/*------------------------------------------------------------------------
   Name				 :~CHelpInfo
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CHelpInfo::~CHelpInfo()
{
}

/*------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function initializes the member variables 
   Type	             :Member function 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Initialize()
   Notes             :None
------------------------------------------------------------------------*/
void CHelpInfo::Initialize()
{
	m_bNameSpaceHelp		= FALSE;
	m_bRoleHelp				= FALSE;
	m_bNodeHelp				= FALSE;
	m_bUserHelp				= FALSE;
	m_bPasswordHelp			= FALSE;
	m_bLocaleHelp			= FALSE;
	m_bRecordPathHelp		= FALSE;
	m_bPrivilegesHelp		= FALSE;
	m_bLevelHelp			= FALSE;
	m_bAuthLevelHelp		= FALSE;
	m_bInteractiveHelp		= FALSE;
	m_bTraceHelp			= FALSE;
	m_bAuthorityHelp		= FALSE;
	m_bGlblAllInfoHelp		= FALSE;
	m_bCmdAllInfoHelp		= FALSE;
	m_bGetVerbHelp			= FALSE;
	m_bSetVerbHelp			= FALSE;
	m_bListVerbHelp			= FALSE;
	m_bCallVerbHelp			= FALSE;
	m_bDumpVerbHelp			= FALSE;
	m_bAssocVerbHelp		= FALSE;
	m_bCreateVerbHelp		= FALSE;
	m_bDeleteVerbHelp		= FALSE;
	m_bAliasVerbHelp		= FALSE;
	m_bPATHHelp				= FALSE;
	m_bWHEREHelp			= FALSE;
	m_bCLASSHelp			= FALSE;
	m_bEXITHelp				= FALSE;
	m_bPWhereHelp			= FALSE;
	m_bTRANSLATEHelp		= FALSE;
	m_bEVERYHelp			= FALSE;
	m_bFORMATHelp			= FALSE;
	m_bVERBSWITCHESHelp		= FALSE;
	m_bDESCRIPTIONHelp		= FALSE;
	m_bGETSwitchesOnlyHelp	= FALSE;
	m_bLISTSwitchesOnlyHelp	= FALSE;
	m_bContextHelp			= FALSE;
	m_bGlblSwitchValuesHelp = FALSE;
	m_bRESULTCLASSHelp		= FALSE;
	m_bRESULTROLE			= FALSE;
	m_bASSOCCLASS			= FALSE;
	m_bASSOCSwitchesOnlyHelp = FALSE;
	m_bFAILFASTHelp			= FALSE;
	m_bREPEATHelp			= FALSE;
	m_bOUTPUTHelp			= FALSE;
	m_bAPPENDHelp			= FALSE;
	m_bAggregateHelp		= FALSE;
}

/*------------------------------------------------------------------------
   Name				 :SetHelp
   Synopsis	         :This function sets a HelpFlag member variable
					  specified by input arguments.
   Type	             :Member function 
   Input parameter   :
		htHelp		 :Help type
		bFlag		 :Flag value
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetHelp(htHelp, bFlag )
   Notes             :None
------------------------------------------------------------------------*/
void CHelpInfo::SetHelp( HELPTYPE htHelp, BOOL bFlag )
{
	switch ( htHelp )
	{
	case Namespace:
		m_bNameSpaceHelp		= bFlag;
		break;
	case Role:
		m_bRoleHelp				= bFlag;
		break;
	case Node:
		m_bNodeHelp				= bFlag;
		break;
	case User:
		m_bUserHelp				= bFlag;
		break;
	case Aggregate:
		m_bAggregateHelp		= bFlag;
		break;
	case Password:
		m_bPasswordHelp			= bFlag;
		break;
	case Locale:
		m_bLocaleHelp			= bFlag;
		break;
	case RecordPath:
		m_bRecordPathHelp		= bFlag;
		break;
	case Privileges:
		m_bPrivilegesHelp		= bFlag;
		break;
	case Level:
		m_bLevelHelp			= bFlag;
		break;
	case AuthLevel:
		m_bAuthLevelHelp		= bFlag;
		break;
	case Interactive:
		m_bInteractiveHelp		= bFlag;
		break;
	case Trace:
		m_bTraceHelp			= bFlag;
		break;
	case Authority:
		m_bAuthorityHelp		= bFlag;
		break;
	case GlblAllInfo:
		m_bGlblAllInfoHelp		= bFlag;
		break;
	case CmdAllInfo:
		m_bCmdAllInfoHelp		= bFlag;
		break;
	case GETVerb:
		m_bGetVerbHelp			= bFlag;
		break;
	case SETVerb:
		m_bSetVerbHelp			= bFlag;
		break;
	case LISTVerb:
		m_bListVerbHelp			= bFlag;
		break;
	case CALLVerb:
		m_bCallVerbHelp			= bFlag;
		break;
	case DUMPVerb:
		m_bDumpVerbHelp			= bFlag;
		break;
	case ASSOCVerb:
		m_bAssocVerbHelp		= bFlag;
		break;
	case DELETEVerb:
		m_bDeleteVerbHelp		= bFlag;
		break;
	case CREATEVerb:
		m_bCreateVerbHelp		= bFlag;
		break;
	case AliasVerb:
		m_bAliasVerbHelp		= bFlag;
		break;
	case PATH:
		m_bPATHHelp				= bFlag;
		break;
	case WHERE:
		m_bWHEREHelp			= bFlag;
		break;
	case CLASS:
		m_bCLASSHelp			= bFlag;
		break;
	case EXIT:
		m_bEXITHelp				= bFlag;
		break;
	case PWhere:
		m_bPWhereHelp			= bFlag;
		break;
	case TRANSLATE:
		m_bTRANSLATEHelp		= bFlag;
		break;
	case EVERY:
		m_bEVERYHelp			= bFlag;
		break;
	case FORMAT:
		m_bFORMATHelp			= bFlag;
		break;
	case VERBSWITCHES:
		m_bVERBSWITCHESHelp		= bFlag;
		break;
	case DESCRIPTION:
		m_bDESCRIPTIONHelp		= bFlag;
		break;
	case GETSwitchesOnly:
		m_bGETSwitchesOnlyHelp	= bFlag;
		break;
	case LISTSwitchesOnly:
		m_bLISTSwitchesOnlyHelp	= bFlag;
		break;
	case CONTEXTHELP:
		m_bContextHelp			= bFlag;
		break;
	case GLBLCONTEXT:
		m_bGlblSwitchValuesHelp = bFlag;
		break;
	case RESULTCLASShelp:
		m_bRESULTCLASSHelp = bFlag;
		break;
	case RESULTROLEhelp:
		m_bRESULTROLE = bFlag;
		break;
	case ASSOCCLASShelp:
		m_bASSOCCLASS = bFlag;
		break;
	case ASSOCSwitchesOnly:
		m_bASSOCSwitchesOnlyHelp = bFlag;
		break;
	case FAILFAST:
		m_bFAILFASTHelp = bFlag;
		break;
	case REPEAT:
		m_bREPEATHelp = bFlag;
		break;
	case OUTPUT:
		m_bOUTPUTHelp = bFlag;
		break;
	case APPEND:
		m_bAPPENDHelp = bFlag;
		break;
	}
}

/*------------------------------------------------------------------------
   Name				 :GetHelp
   Synopsis	         :his function returns a HelpFlag member variable
						specified by input argument
   Type	             :Member function 
   Input parameter   :
		htHelp		 :Help type
   Output parameters :None
   Return Type       :Bool
   Global Variables  :None
   Calling Syntax    :GetHelp(htHelp)
   Calls             :None
   Called by         :CFormatEngine::DisplayGlobalSwitchesAndOtherDesc,
						CFormatEngine::DisplayAliasVerbDescriptions,
						CFormatEngine::DisplayStdVerbDescriptions,
						CFormatEngine::DisplayHelp,
						CFormatEngine::DisplayMethodDetails
   Notes             :None
------------------------------------------------------------------------*/
BOOL CHelpInfo::GetHelp(HELPTYPE htHelp)
{
	BOOL bResult = FALSE;
	
	switch ( htHelp )
	{
	case Namespace:
		bResult		= m_bNameSpaceHelp;
		break;
	case Role:
		bResult		= m_bRoleHelp;
		break;
	case Node:
		bResult		= m_bNodeHelp;
		break;
	case User:
		bResult		= m_bUserHelp;
		break;
	case Aggregate:
		bResult		= m_bAggregateHelp;
		break;
	case Password:
		bResult		= m_bPasswordHelp;
		break;
	case Locale:
		bResult		= m_bLocaleHelp;
		break;
	case RecordPath:
		bResult		= m_bRecordPathHelp;
		break;
	case Privileges:
		bResult		= m_bPrivilegesHelp;
		break;
	case Level:
		bResult		= m_bLevelHelp;
		break;
	case AuthLevel:
		bResult		= m_bAuthLevelHelp;
		break;
	case Interactive:
		bResult		= m_bInteractiveHelp;
		break;
	case Trace:
		bResult		= m_bTraceHelp;
		break;
	case Authority:
		bResult		= m_bAuthorityHelp;
		break;
	case GlblAllInfo:
		bResult		= m_bGlblAllInfoHelp;
		break;
	case CmdAllInfo:
		bResult		= m_bCmdAllInfoHelp;
		break;
	case GETVerb:
		bResult		= m_bGetVerbHelp;
		break;
	case SETVerb:
		bResult		= m_bSetVerbHelp;
		break;
	case LISTVerb:
		bResult		= m_bListVerbHelp;
		break;
	case CALLVerb:
		bResult		= m_bCallVerbHelp;
		break;
	case DELETEVerb:
		bResult		= m_bDeleteVerbHelp;
		break;
	case CREATEVerb:
		bResult		= m_bCreateVerbHelp;
		break;
	case DUMPVerb:
		bResult		= m_bDumpVerbHelp;
		break;
	case ASSOCVerb:
		bResult		= m_bAssocVerbHelp;
		break;
	case AliasVerb:
		bResult		= m_bAliasVerbHelp;
		break;
	case PATH:
		bResult		= m_bPATHHelp;
		break;
	case WHERE:
		bResult		= m_bWHEREHelp;
		break;
	case CLASS:
		bResult		= m_bCLASSHelp;
		break;
	case EXIT:
		bResult		= m_bEXITHelp;
		break;
	case PWhere:
		bResult		= m_bPWhereHelp;
		break;
	case TRANSLATE:
		bResult		= m_bTRANSLATEHelp;
		break;
	case EVERY:
		bResult		= m_bEVERYHelp;
		break;
	case FORMAT:
		bResult		= m_bFORMATHelp;
		break;
	case VERBSWITCHES:
		bResult		= m_bVERBSWITCHESHelp;
		break;
	case DESCRIPTION:
		bResult		= m_bDESCRIPTIONHelp;
		break;
	case GETSwitchesOnly:
		bResult		= m_bGETSwitchesOnlyHelp;
		break;
	case LISTSwitchesOnly:
		bResult		= m_bLISTSwitchesOnlyHelp;
		break;
	case CONTEXTHELP:
		bResult		= m_bContextHelp;
		break;
	case GLBLCONTEXT:
		bResult		= m_bGlblSwitchValuesHelp;
		break;
	case RESULTCLASShelp:
		bResult		= m_bRESULTCLASSHelp ;
		break;
	case RESULTROLEhelp:
		bResult		= m_bRESULTROLE ;
		break;
	case ASSOCCLASShelp:
		bResult		= m_bASSOCCLASS ;
		break;
	case ASSOCSwitchesOnly:
		bResult		= m_bASSOCSwitchesOnlyHelp ;
		break;
	case FAILFAST:
		bResult		= m_bFAILFASTHelp ;
		break;
	case REPEAT:
		bResult		= m_bREPEATHelp ;
		break;
	case OUTPUT:
		bResult		= m_bOUTPUTHelp ;
		break;
	case APPEND:
		bResult		= m_bAPPENDHelp ;
		break;
	}
	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\outputstream.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: OutputStream.cpp 
Project Name				: WMI Command Line
Author Name					: C V Nandi
Date of Creation (dd/mm/yy) : 9th-July-2001
Version Number				: 1.0 
Brief Description			: This file consist of class implementation of
							  class CFileOutputStream and CStackUnknown
Revision History			: 
		Last Modified By	: C V Nandi
		Last Modified Date	: 10th-July-2001
******************************************************************************/ 

#include "Precomp.h"
#include "OutputStream.h"

/*------------------------------------------------------------------------
   Name				 :Init
   Synopsis	         :This function initializes the handle to stream.
   Type	             :Member Function
   Input parameter   :
			h		 - HANDLE, HANDLE to the stream.
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :Init(hOutSteram)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CFileOutputStream::Init(HANDLE h)
{
	m_hOutStream = h; 
	m_bClose = false; 

	return S_OK;
}

/*------------------------------------------------------------------------
   Name				 :Init
   Synopsis	         :Open local file named pwszFileName for writing.
   Type	             :Member Function
   Input parameter   :
		pszFileName	 - Pointer to a string containing file name.
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :Init(szFileName)
   Notes             :Overloaded function.
------------------------------------------------------------------------*/
    
HRESULT
CFileOutputStream::Init(const _TCHAR * pszFileName)
{
    HRESULT hr = S_OK;

    m_hOutStream =::CreateFile(
            pszFileName,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);

	if ( m_hOutStream == INVALID_HANDLE_VALUE )
		hr = S_FALSE;
	else
		m_bClose = TRUE;

    return hr;
}

/*------------------------------------------------------------------------
   Name				 :Close
   Synopsis	         :This function closes the handle to stream.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :Close();
   Notes             :None
------------------------------------------------------------------------*/
void CFileOutputStream::Close()
{
	if (m_bClose) 
	{
		::CloseHandle(m_hOutStream); 
		m_bClose = FALSE;
	}
}

/*------------------------------------------------------------------------
   Name				 :Write
   Synopsis	         :Implement ISequentialStream::Write by forwarding 
					  calls to WriteFile.
   Type	             :Member Function
   Input parameter   :
				pv	 - Pointer to buffer containing data.
				cb	 - Number of bytes to be written
   Output parameters :
				pcbWritten	 - Number of bytes written.
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :Called by transform() function of IXSLProcessor.
   Notes             :None
------------------------------------------------------------------------*/

HRESULT STDMETHODCALLTYPE
CFileOutputStream::Write(void const * pv, ULONG cb, ULONG * pcbWritten)
{
    HRESULT hr = S_OK;

	void* p = const_cast < void* > ( pv );
	ULONG sizep = cb;

	LPWSTR	psz = reinterpret_cast < LPWSTR > ( p );
	BOOL bSkip = FALSE;

	if ( psz )
	{
		if ( FILE_TYPE_DISK == GetFileType ( m_hOutStream ) )
		{
			if(SetFilePointer(m_hOutStream, 0, NULL, FILE_CURRENT))
			{
				// skip unicode signature 0xfffe
				BYTE *signature = NULL;
				signature = reinterpret_cast < BYTE* > ( psz );

				if ( signature [ 0 ] == 0xff && signature [ 1 ] == 0xfe )
				{
					psz++;
					bSkip = TRUE;
				}

				if ( bSkip )
				{
					p = reinterpret_cast < void* > ( psz );
					sizep = sizep - 2;
				}
			}
		}
	}

	if ( ::WriteFile(m_hOutStream,
				p,
				sizep,
				pcbWritten,
				NULL) == FALSE )
	{
		hr = S_FALSE;
	}

	// need to fake as we wrote multibytes here
	if ( bSkip )
	{
		* pcbWritten = ( * pcbWritten ) + 2;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\parsedinfo.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ParsedInfo.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified Date		: 11th-April-2001
****************************************************************************/ 
#include "Precomp.h"
#include "CommandSwitches.h"
#include "GlobalSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"


/*------------------------------------------------------------------------
   Name				 :CParsedInfo
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CParsedInfo::CParsedInfo()
{
	lstrcpy( m_pszPwd, NULL_STRING );
}

/*------------------------------------------------------------------------
   Name				 :~CParsedInfo
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CParsedInfo::~CParsedInfo()
{
	m_GlblSwitches.Uninitialize();
	m_CmdSwitches.Uninitialize();
}

/*------------------------------------------------------------------------
   Name				 :GetCmdSwitchesObject
   Synopsis	         :This function returns CCommandSwitches object data
					  member m_CmdSwitches
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CCommandSwitches&
   Global Variables  :None
   Calling Syntax    :GetCmdSwitchesObject()
   Notes             :None
------------------------------------------------------------------------*/
CCommandSwitches& CParsedInfo::GetCmdSwitchesObject()
{
	return m_CmdSwitches;
}
/*------------------------------------------------------------------------
   Name				 :GetGlblSwitchesObject
   Synopsis	         :This function returns CGlblSwitches object data
					  member m_GlblSwitches
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CGlobalSwitches&
   Calling Syntax    :GetGlblSwitchesObject()
   Notes             :None
------------------------------------------------------------------------*/
CGlobalSwitches& CParsedInfo::GetGlblSwitchesObject()
{
	return m_GlblSwitches;
}

/*------------------------------------------------------------------------
   Name				 :GetHelpInfoObject
   Synopsis	         :This function returns CHelpInfo object data
					  member m_HelpInfo
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHelpInfo&
   Calling Syntax    :GetHelpInfoObject()
   Notes             :None
------------------------------------------------------------------------*/
CHelpInfo& CParsedInfo::GetHelpInfoObject()
{
	return m_HelpInfo;
}

/*------------------------------------------------------------------------
   Name				 :GetErrorLogObject
   Synopsis	         :This function returns CErrorLog object data
					  member m_ErrorLog
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CErrorLog&
   Calling Syntax    :GetHelpInfoObject()
   Notes             :None
------------------------------------------------------------------------*/
CErrorLog& CParsedInfo::GetErrorLogObject()
{
	return m_ErrorLog;
}

/*------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function Initializes the CParedInfo object.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :Void
   Calling Syntax    :Initialize()
   Notes             :None
------------------------------------------------------------------------*/
void CParsedInfo::Initialize()
{
	m_bNewCmd	= TRUE;
	m_bNewCycle	= TRUE;
	m_CmdSwitches.Initialize();
	m_GlblSwitches.Initialize();
	m_HelpInfo.Initialize();
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the CGlobalSwitches and
					  CCommandSwitches object
   Type	             :Member Function
   Input parameter   :bBoth - boolean value
   Output parameters :None
   Return Type       :
   Calling Syntax    :Uninitialize(bBoth)
   Notes             :None
------------------------------------------------------------------------*/
void CParsedInfo::Uninitialize(BOOL bBoth)
{
	// If session termination
	if (bBoth)
	{
		m_GlblSwitches.Uninitialize();
		m_CmdSwitches.Uninitialize();
	}
	// if new command
	else 
	{
		m_CmdSwitches.Uninitialize();
	}
	m_bNewCmd = TRUE;
	m_bNewCycle = TRUE;
}

/*------------------------------------------------------------------------
   Name				 :GetUser
   Synopsis	         :Returns the user name
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetUser()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetUser()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /USER global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & USER))
		{
			// Check if alias user is not NULL, if so 
			// return the alias user name
			if (m_CmdSwitches.GetAliasUser())   
			{
				return m_CmdSwitches.GetAliasUser();
			}
		}		
	}
	return m_GlblSwitches.GetUser();
}

/*------------------------------------------------------------------------
   Name				 :GetNode
   Synopsis	         :Returns the node name
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetNode()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetNode()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /NODE global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & NODE))
		{
			// Check if alias node name is not NULL, if so 
			// return the alias node name
			if (m_CmdSwitches.GetAliasNode())   
			{
				return m_CmdSwitches.GetAliasNode();
			}
		}
	}
	return m_GlblSwitches.GetNode();		
}

/*------------------------------------------------------------------------
   Name				 :GetLocale
   Synopsis	         :Returns the locale value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetLocale()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetLocale()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /LOCALE global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & LOCALE))
		{
			// Check if alias locale value is not NULL, if so 
			// return the alias locale value
			if (m_CmdSwitches.GetAliasLocale())   
			{
				return m_CmdSwitches.GetAliasLocale();
			}
		}
	}
	// return the locale specified with global switches
	return m_GlblSwitches.GetLocale();	
}

/*------------------------------------------------------------------------
   Name				 :GetPassword
   Synopsis	         :Returns the password
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetPassword()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetPassword()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /PASSWORD global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & PASSWORD))
		{
			// Check if alias password value is not NULL, if so 
			// return the alias password value
			if (m_CmdSwitches.GetAliasPassword())   
			{
				return m_CmdSwitches.GetAliasPassword();
			}
		}
	}
	// If Credflag is set to FALSE means actual value
	// of the password should be passed.
	if (!m_CmdSwitches.GetCredentialsFlagStatus())
	{
		return m_GlblSwitches.GetPassword();
	}
	else
	{
		// treat password as BLANK
		return m_pszPwd;
	}
}

/*------------------------------------------------------------------------
   Name				 :GetNamespace
   Synopsis	         :Returns the namespace value
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetNamespace()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetNamespace()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if alias namespace value is not NULL, if so 
		// return the alias namespace value (else fallback to 
		// namespace available with global switch)
		if (m_CmdSwitches.GetAliasNamespace())   
			return m_CmdSwitches.GetAliasNamespace();
	}
	// return the namespace specified with global switches
	return m_GlblSwitches.GetNameSpace();	
}

/*------------------------------------------------------------------------
   Name				 :GetUserDesc
   Synopsis	         :Returns the user name, if no user is available returns
					  "N/A"  - used only with CONTEXT (displaying environment
					  variables)
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
			bstrUser - user name string
   Return Type       :void
   Calling Syntax    :GetUserDesc()
   Notes             :None
------------------------------------------------------------------------*/
void	CParsedInfo::GetUserDesc(_bstr_t& bstrUser)
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /USER global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & USER))
		{
			// Check if alias user is not NULL, if so 
			// return the alias user name
			if (m_CmdSwitches.GetAliasUser())   
			{
				bstrUser = m_CmdSwitches.GetAliasUser();
			}
		}		
	}
	if (m_GlblSwitches.GetUser()) 
		bstrUser = m_GlblSwitches.GetUser();
	else
		bstrUser = TOKEN_NA;
}
/*------------------------------------------------------------------------
   Name				 :GetNewCommandStatus
   Synopsis	         :Checks if a command is new or not (used for 
					  logging into xml file)
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None			
   Return Type       :BOOL
   Calling Syntax    :GetNewCommandStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL	CParsedInfo::GetNewCommandStatus()
{
	return m_bNewCmd;
}

/*------------------------------------------------------------------------
   Name				 :SetNewCommandStatus
   Synopsis	         :Sets the status of a new command
   Type	             :Member Function
   Input parameter   :
		bStatus		 - BOOL type,status of the command
   Output parameters :None			
   Return Type       :void
   Calling Syntax    :SetNewCommandStatus(bStatus)
   Notes             :None
------------------------------------------------------------------------*/
void CParsedInfo::SetNewCommandStatus(BOOL bStatus)
{
	m_bNewCmd = bStatus;
}

/*------------------------------------------------------------------------
   Name				 :GetNewCycleStatus
   Synopsis	         :Returns the status of the new cycle flag
   Type	             :Member Function
   Input parameter   :None		
   Output parameters :None			
   Return Type       :BOOL
   Calling Syntax    :GetNewCycleStatus()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CParsedInfo::GetNewCycleStatus()
{
	return m_bNewCycle;
}

/*------------------------------------------------------------------------
   Name				 :SetNewCycleStatus
   Synopsis	         :Sets the status of a new node
   Type	             :Member Function
   Input parameter   :
		bStatus		 - BOOL type, status of the new cycle
   Output parameters :None			
   Return Type       :void
   Calling Syntax    :SetNewCycleStatus(bStatus)
   Notes             :None
------------------------------------------------------------------------*/
void CParsedInfo::SetNewCycleStatus(BOOL bStatus)
{
	m_bNewCycle = bStatus;
}

/*------------------------------------------------------------------------
   Name				 :GetAuthorityDesc
   Synopsis	         :Returns the <authority principle>, if no <authority principle>
					  is available returns "N/A"  - used only with CONTEXT
					  (displaying environment variables)
   Type	             :Member Function
   Input parameter   :None
   Output parameters :
			bstrAuthorityPrinciple - <authority principle> string
   Return Type       :void
   Calling Syntax    :GetAuthorityDesc()
   Notes             :None
------------------------------------------------------------------------*/
void	CParsedInfo::GetAuthorityDesc(_bstr_t& bstrAuthorityPrinciple)
{
	if (m_GlblSwitches.GetAuthorityPrinciple()) 
		bstrAuthorityPrinciple = m_GlblSwitches.GetAuthorityPrinciple();
	else
		bstrAuthorityPrinciple = TOKEN_NA;
}

/*------------------------------------------------------------------------
   Name				 :GetAuthorityPrinciple
   Synopsis	         :Returns the authority type.
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :_TCHAR* 
   Calling Syntax    :GetAuthorityPrinciple()
   Notes             :None
------------------------------------------------------------------------*/
_TCHAR* CParsedInfo::GetAuthorityPrinciple()
{
	// Check if alias name is available
	if (m_CmdSwitches.GetAliasName())
	{
		// Check if /AUTHORITY global switch is not explicitly
		// specified.
		if (!(m_GlblSwitches.GetConnInfoFlag() & AUTHORITY))
		{
			// Check if alias user is not NULL, if so 
			// return the alias user name
			if (m_CmdSwitches.GetAliasAuthorityPrinciple())   
			{
				return m_CmdSwitches.GetAliasAuthorityPrinciple();
			}
		}		
	}
	return m_GlblSwitches.GetAuthorityPrinciple();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\outputstream.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: OutputStream.h
Project Name				: WMI Command Line
Author Name					: C V Nandi 
Date of Creation (dd/mm/yy) : 9th-July-2001
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CFileOutputStream and CStackUnknown
Revision History			: 
		Last Modified By	: C V Nandi
		Last Modified Date	: 10th-July-2001
****************************************************************************/ 
/*-------------------------------------------------------------------
 Class Name			: CStackUnknown
 Class Type			: Concrete 
 Brief Description	: Implementation of IUnknown for objects that are 
					  meant to be created on the stack.  Because of this,
					  all external references to this object must be
					  released before this object is destructed.
 Super Classes		: Base
 Sub Classes		: CFileOutputStream
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/

template <class Base>
class __declspec(novtable) CStackUnknown : public Base
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppv);
    virtual ULONG STDMETHODCALLTYPE AddRef() {return 1;}
    virtual ULONG STDMETHODCALLTYPE Release() {return 1;}
};

/*------------------------------------------------------------------------
   Name				 :QueryInterface
   Synopsis	         :This function overides the implemention of IUnknown
					  interface.	
   Type	             :Member Function
   Input parameter   :
			riid	 - REFIID, reference ID.
   Output parameters :
			ppv		 - Pointer to object.
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :Called by interface
   Notes             :None
------------------------------------------------------------------------*/
template <class Base>
HRESULT STDMETHODCALLTYPE
CStackUnknown<Base>::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid == __uuidof(Base) || riid == __uuidof(IUnknown))
    {
        // No need to AddRef since this class will only be created on the stack
        *ppv = this;
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

/*-------------------------------------------------------------------
 Class Name			: CFileOutputStream
 Class Type			: Concrete 
 Brief Description	: Implements Write method of ISequentialStream on 
					  top of output stream HANDLE.
 Super Classes		: CStackUnknown
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/

class CFileOutputStream : public CStackUnknown<ISequentialStream>
{
private:
    HANDLE  m_hOutStream;
    bool    m_bClose;    // Close handle only if this class opened it

public:
    CFileOutputStream() {m_bClose = FALSE;}
    ~CFileOutputStream() {Close();}

    HRESULT Init(HANDLE h);
    HRESULT Init(const _TCHAR * pwszFileName);

    void Close();

    //////////////////////////////////////////////////////////////////////////
    // ISequentialStream
    //
    virtual HRESULT STDMETHODCALLTYPE Read(void * pv, 
										   ULONG cb, 
										   ULONG * pcbRead){return E_NOTIMPL;}
    virtual HRESULT STDMETHODCALLTYPE Write(void const * pv,
											ULONG cb, 
											ULONG * pcbWritten);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\globalswitches.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: CommandSwitches.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class GlobalSwitches
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy 
	Last Modified on		: 17th-November-2000
****************************************************************************/ 

/*-------------------------------------------------------------------
 Class Name			: CGlobalSwitches
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for accessing and storing the global switches 
					  information, which will be used by Parsing, 
					  Execution and Format Engines depending upon the 
					  applicablity.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/

#pragma once

class CGlobalSwitches
{
public:
// Construction
	CGlobalSwitches();

// Destruction
	~CGlobalSwitches();

// Restrict Assignment
	CGlobalSwitches& operator=(CGlobalSwitches& rGlblSwitches);

// Attributes
private:
	// Mapping b/w allowed strings for implevel and
	// the corresponding integer values.
	CHARINTMAP  m_cimImpLevel;

	// Mapping b/w allowed strings for authlevel and
	// the corresponding integer values.
	CHARINTMAP	m_cimAuthLevel;

	//String type, It stores Namespace specified in the command.
	_TCHAR*		m_pszNameSpace;

    //String type, It stores Role specified in the command.
	_TCHAR*		m_pszRole;

    //String type, It stores Node specified in the command.
	_TCHAR*		m_pszNode;

    //CHARVECTOR type, It stores the Nodes specified in the command.
	CHARVECTOR	m_cvNodesList;

    //String type, It stores User specified in the command.
	_TCHAR*		m_pszUser;

    //String type, It stores Password specified in the command.
	_TCHAR*		m_pszPassword;

	//String type, It stores Authority string specified in the command.
	_TCHAR*		m_pszAuthorityPrinciple;

    //String type, It stores Locale value specified
	//in the command
 	_TCHAR*		m_pszLocale;

    //String type, It stores the Record  specified in the command.
	_TCHAR*		m_pszRecordPath;

    //Boolean type, It stores the value of the Privileges option specified
	//in the conmmand
    BOOL		m_bPrivileges;

	//Boolean type, It stores the value of the Aggregate option specified
	//in the conmmand
	BOOL		m_bAggregateFlag;

    //enumerated data type, It stores the value of the ImpersonationLevel 
	//specified in the command.
	IMPLEVEL	m_ImpLevel;

    //enumerated data type, It stores the value of the Authentication Level
	//specified in the command.
	AUTHLEVEL	m_AuthLevel;

    // Boolean type, It specifies presence of the Interactive option  
    //in the command
	BOOL		m_bInteractive;

    //Boolean type, It specifies presence of the trace option  in
    //the command
	BOOL		m_bTrace;

	//Boolean type, It specifies Help(/?) option in the command
	BOOL		m_bHelp;

    //HELPOPTION type, to specify type of help needed ( help option ).
	HELPOPTION	m_HelpOption;

	//CONNECTION information flag
	UINT		m_uConnInfoFlag;

	// role change flag
	BOOL		m_bRoleFlag;

	// namespace change flag
	BOOL		m_bNSFlag;

	// locale change flag
	BOOL		m_bLocaleFlag;

	// prompt for password flag
	BOOL		m_bAskForPassFlag;

	// change of recordpath flag
	BOOL		m_bRPChange;
	
	// FailFast flag.
	BOOL		m_bFailFast;

	// Output option.
	OUTPUTSPEC	m_opsOutputOpt;

	// Append option.
	OUTPUTSPEC	m_opsAppendOpt;

	// Output file name.
	_TCHAR*		m_pszOutputFileName;

	// File pointer to output file stream..
	FILE*		m_fpOutFile;

	// Append file name.
	_TCHAR*		m_pszAppendFileName;

	// File pointer to append file stream..
	FILE*		m_fpAppendFile;

	// type of file we append to
	FILETYPE	m_eftFileType;

	WMICLIINT	m_nSeqNum;

	_TCHAR*		m_pszLoggedOnUser;
	
	_TCHAR*		m_pszNodeName;
	
	_TCHAR*		m_pszStartTime;
// Operations
public:

	//Sets the namespace passed in parameter to m_pszNameSpace.
	BOOL		SetNameSpace(_TCHAR* pszNameSpace);

    //Sets the role passed in parameter to m_pszRole.
	BOOL		SetRole(_TCHAR* pszRole);

    //Assigns the locale passed in parameter to m_pszLocale.
	BOOL		SetLocale(_TCHAR* pszLocale);

    //Assigns the node passed in parameter to m_pszNode
	BOOL		SetNode(_TCHAR* pszNode);

    //Adds the node passed in parameter to m_cvNodesList vector.
	BOOL		AddToNodesList(_TCHAR* pszNode);

    //Assigns the user passed in parameter to m_pszUser
	BOOL		SetUser(_TCHAR* pszUser);

    //Assigns the password passed in parameter to m_pszPassword
	BOOL		SetPassword(_TCHAR* pszPassword);

	//Assigns the <authority principle> passed in parameter to m_pszAuthorityPrinciple
	BOOL		SetAuthorityPrinciple(_TCHAR* pszAuthorityPrinciple);

    //Assigns the record file passed in parameter to m_pszRecordPath
	BOOL		SetRecordPath(_TCHAR* pszRecordPath);

    //Assigns the bool value passed in parameter to m_bPrivileges
	void		SetPrivileges(BOOL bEnable);
	
    //Assigns the impersonation level passed in parameter to
    //m_ImpLevel.
 	BOOL		SetImpersonationLevel(_TCHAR* const pszImpLevel);

    //Assigns the authentication level passed in parameter to
    //m_AuthLevel.
	BOOL		SetAuthenticationLevel(_TCHAR* const pszAuthLevel);

    //This function sets the m_bTrace to TRUE,If Trace mode
    //is specified in the command 
	void		SetTraceMode(BOOL bTrace);

    //This function sets the m_bInteractive to TRUE,If 
    //interactive mode is specified in the command          
	void		SetInteractiveMode(BOOL bInteractive);

    //sets the m_bHelp to TRUE, If /? is specified in the
    //command 
	void		SetHelpFlag(BOOL bHelp);

	// Sets the namespace change status flag with bNSFlag value
	void		SetNameSpaceFlag(BOOL bNSFlag);

	// Sets the role change status flag with bRoleFlag value
	void		SetRoleFlag(BOOL bRoleFlag);

	// Sets the locale change status flag with bLocaleFlag value
	void		SetLocaleFlag(BOOL bLocaleFlag);

	// Sets the recordpath change status flag with bRPChange value
	void		SetRPChangeStatus(BOOL bRPChange);

    //This function specifies whether the help should
    //be brief or full 
	void		SetHelpOption(HELPOPTION helpOption);

	//This function sets the Connection Info flag
	void		SetConnInfoFlag(UINT uFlag);

	// Set AskForPass flag.
	void		SetAskForPassFlag(BOOL bFlag);

	// Set m_bFailFast
	void		SetFailFast(BOOL bFlag);

	//This function returns the Connection Info flag
	UINT		GetConnInfoFlag();

	//Returns the string held in m_pszNameSpace	
	_TCHAR*		GetNameSpace();

    //Returns the string held in m_pszRole
	_TCHAR*		GetRole();

    //Returns the string held in m_pszLocale
	_TCHAR*		GetLocale();

    //Returns the string held in m_pszNode
	_TCHAR*		GetNode();

    //Returns the referrence to m_cvNodesList.
	CHARVECTOR& GetNodesList();

    //Returns the string held in m_pszUser
	_TCHAR*		GetUser();

    //Returns the string held in m_pszPassword
	_TCHAR*		GetPassword();

	//Returns the string held in m_pszAuthority
	_TCHAR*		GetAuthorityPrinciple();

    //Returns the string held in m_pszRecordPath
	_TCHAR*		GetRecordPath();

    //Returns the m_bPrivileges value
	BOOL		GetPrivileges();

	// Return the string equivalent of the boolean value
	// contained in m_bPrivilges flag
	void		GetPrivilegesTextDesc(_bstr_t& bstrPriv);

	// Return the string equivalent of the boolean value
	// contained in m_bFailFast flag
	void		GetFailFastTextDesc(_bstr_t& bstrFailFast);

	// Return the string equivalent of the OUTPUTSPEC value
	// contained in m_opsOutputOpt member.
	void		GetOutputOrAppendTextDesc(_bstr_t& bstrOutputOpt, 
										  BOOL bIsOutput);

	// Return the string equivalent of the boolean value
	// contained in m_bTrace flag
	void		GetTraceTextDesc(_bstr_t& bstrTrace);

	// Return the string equivalent of the boolean value
	// contained in m_bInteractive flag
	void		GetInteractiveTextDesc(_bstr_t& bstrInteractive);

	// Returns the string equivalent of the implevel value
	// contained in m_ImpLevel
	void		GetImpLevelTextDesc(_bstr_t& bstrImpLevel);

	// Returns the string equivalent of the authlevel value
	// contained in m_AuthLevel
	void		GetAuthLevelTextDesc(_bstr_t& bstrAuthLevel);

	// Returns the ',' separated node string of the available
	// nodes
	void		GetNodeString(_bstr_t& bstrNString);

	// Returns the content of the m_pszRecordPath
	// if NULL returns "N/A"
	void		GetRecordPathDesc(_bstr_t& bstrRP);

    //Returns impersonation level held in m_ImpLevel
	LONG		GetImpersonationLevel();

    //Returns authentication level held in m_AuthLevel
	LONG		GetAuthenticationLevel();

    //Returns Trace status held in m_bTrace	
	BOOL		GetTraceStatus();

    //Returns Interactive status held in m_bInteractive
	BOOL		GetInteractiveStatus();

    //Returns helpflag held in m_bHelp
	BOOL		GetHelpFlag();

	// Returns the change of role status
	BOOL		GetRoleFlag();

	// Returns the change of namespace status
	BOOL		GetNameSpaceFlag();

	// Returns TRUE if message for password 
	// needs to be prompted.
	BOOL		GetAskForPassFlag();

	// Returns the change of locale status flag
	BOOL		GetLocaleFlag();

	// Returns the change of recordpath status flag
	BOOL		GetRPChangeStatus();

    //Returns helpflagOption held in m_bHelpOption
	HELPOPTION	GetHelpOption();

	// Returns the m_bFailFast flag.
	BOOL		GetFailFast();

	// Initialize the necessary member varialbes
	void		Initialize();

	// General functions
	void		Uninitialize();
	
	// Clears the Nodes List
	BOOL		ClearNodesList();

	// Set file type
	void		SetFileType ( FILETYPE aftOpt ) ;

	// Get file type
	FILETYPE	GetFileType ( ) ;

	// Set Output option.
	void		SetOutputOrAppendOption(OUTPUTSPEC opsOpt,
										BOOL bIsOutput);

	// Get Output option.
	OUTPUTSPEC	GetOutputOrAppendOption(BOOL bIsOutput);

	// Set Output or append File Name, bOutput == TRUE for Output FALSE 
	// for Append.
	BOOL		SetOutputOrAppendFileName(const _TCHAR* pszFileName, 
										  BOOL	bOutput);

	// Get Output or append file name, bOutput == TRUE for Output FALSE for
	// Append.
	_TCHAR*		GetOutputOrAppendFileName(BOOL	bOutput);

	// Set output or append file pointer, bOutput == TRUE for Output FALSE 
	// for Append.
	void		SetOutputOrAppendFilePointer(FILE* fpOutFile, BOOL	bOutput);

	// Get output file pointer, bOutput == TRUE for Output FALSE for Append.
	FILE*		GetOutputOrAppendFilePointer(BOOL	bOutput);


	WMICLIINT	GetSequenceNumber();
	_TCHAR*		GetLoggedonUser();
	_TCHAR*		GetMgmtStationName();
	_TCHAR*		GetStartTime();

	BOOL		SetStartTime();

	//Assigns the Aggregate flag passed in parameter to m_bAggregateFlag
	void		SetAggregateFlag(BOOL bAggregateFlag);

	//Gets the agregate flag contained in m_bAggregateFlag
	BOOL		GetAggregateFlag();

	// This function checks and Returns the string equivalent of the 
	// boolean value contained in m_bAggregateFlag flag
	void GetAggregateTextDesc(_bstr_t& bstrAggregate);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\precomp.h ===
#if !defined __PCH_H
#define __PCH_H

#define SECURITY_WIN32 1

// The debugger can't handle symbols more than 255 characters long.
// STL often creates symbols longer than that.
// When symbols are longer than 255 characters, the warning is issued.
#pragma warning(disable:4786)
//////////////////////////////////////////////////////////////////////
//						HEADER INCLUDES								//
//////////////////////////////////////////////////////////////////////
#include "resource.h"
#include <windows.h>
#include <vector>
#include <map>
#include <tchar.h>
#include <comdef.h>	
#include <wbemidl.h>
#include <iostream>
#include <msxml2.h>
#include <lmcons.h>
#include <conio.h>
#include <math.h>
#include <chstring.h>
#include <shlwapi.h>
#include <winsock2.h>
#include <security.h>
#include <Provexce.h>
#include <io.h>
#include <ipexport.h>
#include <icmpapi.h>

using namespace std;

class CParsedInfo;
class CWMICommandLine;
extern CWMICommandLine g_wmiCmd;


#ifdef _WIN64
	typedef __int64 WMICLIINT;
#else
	typedef int WMICLIINT;
#endif

#ifdef _WIN64
	typedef UINT_PTR WMICLIUINT;
#else
	typedef UINT WMICLIUINT;
#endif

#ifdef _WIN64
	typedef DWORD_PTR WMICLIULONG;
#else
	typedef ULONG WMICLIULONG;
#endif


//////////////////////////////////////////////////////////////////////
//						USER DEFINED CONSTANTS						//
//////////////////////////////////////////////////////////////////////
#define MAX_BUFFER				4095
#define BUFFER32				32				
#define BUFFER64				64				
#define	BUFFER512				512
#define BUFFER255				255
#define BUFFER1024				1024

#define	CLI_ROLE_DEFAULT		_T("root\\cli")
#define CLI_NAMESPACE_DEFAULT	_T("root\\cimv2")
#define CLI_LOCALE_DEFAULT		_T("ms_409")

#define	CLI_TOKEN_W				_T("W")
#define CLI_TOKEN_CLASS			_T("CLASS")
#define CLI_TOKEN_PATH			_T("PATH")
#define CLI_TOKEN_WHERE			_T("WHERE")
#define CLI_TOKEN_EXIT			_T("EXIT")
#define CLI_TOKEN_RESTORE		_T("RESTORE")
#define CLI_TOKEN_QUIT			_T("QUIT")
#define	CLI_TOKEN_CONTEXT		_T("CONTEXT")

#define CLI_TOKEN_GET			_T("GET")
#define CLI_TOKEN_LIST			_T("LIST")
#define CLI_TOKEN_SET			_T("SET")
#define CLI_TOKEN_DUMP			_T("DUMP")
#define CLI_TOKEN_CALL			_T("CALL")
#define CLI_TOKEN_ASSOC			_T("ASSOC")
#define CLI_TOKEN_CREATE		_T("CREATE")
#define CLI_TOKEN_DELETE		_T("DELETE")

#define CLI_TOKEN_HELP			_T("?")
#define CLI_TOKEN_NAMESPACE		_T("NAMESPACE")
#define CLI_TOKEN_ROLE			_T("ROLE")
#define CLI_TOKEN_NODE			_T("NODE")
#define CLI_TOKEN_IMPLEVEL		_T("IMPLEVEL")
#define CLI_TOKEN_AUTHLEVEL		_T("AUTHLEVEL")
#define CLI_TOKEN_LOCALE		_T("LOCALE")
#define CLI_TOKEN_PRIVILEGES	_T("PRIVILEGES")
#define CLI_TOKEN_TRACE			_T("TRACE")
#define CLI_TOKEN_RECORD		_T("RECORD")
#define CLI_TOKEN_INTERACTIVE   _T("INTERACTIVE")
#define CLI_TOKEN_FAILFAST	    _T("FAILFAST")
#define CLI_TOKEN_USER			_T("USER")
#define CLI_TOKEN_PASSWORD	    _T("PASSWORD")
#define CLI_TOKEN_OUTPUT	    _T("OUTPUT")
#define CLI_TOKEN_APPEND	    _T("APPEND")
#define CLI_TOKEN_AGGREGATE		_T("AGGREGATE")
#define CLI_TOKEN_AUTHORITY		_T("AUTHORITY")

#define CLI_TOKEN_COLON			_T(":")
#define CLI_TOKEN_COMMA			_T(",")
#define CLI_TOKEN_FSLASH        _T("/")
#define CLI_TOKEN_HYPHEN	    _T("-")
#define CLI_TOKEN_HASH			_T("#")
#define CLI_TOKEN_SPACE         _T(" ")
#define CLI_TOKEN_DOT			_T(".")
#define CLI_TOKEN_2DOT			_T("..")
#define CLI_TOKEN_EQUALTO		_T("=")
#define CLI_TOKEN_NULL			_T("")
#define CLI_TOKEN_BSLASH		_T("\\")
#define CLI_TOKEN_2BSLASH		_T("\\\\")
#define CLI_TOKEN_LEFT_PARAN	_T("(")
#define CLI_TOKEN_RIGHT_PARAN	_T(")")
#define CLI_TOKEN_ONE			_T("1")
#define CLI_TOKEN_TWO			_T("2")
#define CLI_TOKEN_SINGLE_QUOTE	_T("\'")
#define CLI_TOKEN_DOUBLE_QUOTE	_T("\"")
#define CLI_TOKEN_TAB			_T("\t")
#define CLI_TOKEN_SEMICOLON		_T(";")
#define CLI_TOKEN_NEWLINE		_T("\n")

#define CLI_TOKEN_TABLE			_T("TABLE")
#define CLI_TOKEN_MOF			_T("MOF")
#define CLI_TOKEN_TEXTVALUE		_T("TEXTVALUE")

#define CLI_TOKEN_ENABLE	    _T("ENABLE")
#define CLI_TOKEN_DISABLE		_T("DISABLE")
#define CLI_TOKEN_ON			_T("ON")
#define CLI_TOKEN_OFF			_T("OFF")

#define CLI_TOKEN_BRIEF			_T("BRIEF")
#define CLI_TOKEN_FULL			_T("FULL")

#define CLI_TOKEN_STDOUT		_T("STDOUT")
#define CLI_TOKEN_CLIPBOARD		_T("CLIPBOARD")

#define CLI_TOKEN_VALUE			_T("VALUE")
#define CLI_TOKEN_ALL			_T("ALL")
#define CLI_TOKEN_FORMAT        _T("FORMAT")
#define CLI_TOKEN_EVERY			_T("EVERY")
#define CLI_TOKEN_REPEAT		_T("REPEAT")
#define CLI_TOKEN_TRANSLATE		_T("TRANSLATE")

#define CLI_TOKEN_NONINTERACT   _T("NOINTERACTIVE")
#define CLI_TOKEN_DUMP			_T("DUMP")

#define CLI_TOKEN_FROM			_T("FROM")
#define CLI_TOKEN_WHERE			_T("WHERE")

#define XSL_FORMAT_TABLE	_T("texttable.xsl")
#define XSL_FORMAT_MOF		_T("mof.xsl")
#define XSL_FORMAT_TEXTVALUE	_T("TextValueList.xsl")

#define TEMP_BATCH_FILE			_T("TempWmicBatchFile.bat")
#define CLI_XSLMAPPINGS_FILE	_T("XSL-Mappings.xml")
#define CLI_XSLSECTION_NAME		_T("XSLMAPPINGS")

#define WBEM_LOCATION			_T("\\wbem\\")

#define RESPONSE_YES			_T("Y")
#define RESPONSE_NO				_T("N")
#define RESPONSE_HELP			_T("?")

#define EXEC_NAME				_T("wmic")

#define CLI_TOKEN_AND			_T(" AND ")
#define CLI_TOKEN_WRITE			_T("Write")

#define WMISYSTEM_CLASS			_T("__CLASS")
#define WMISYSTEM_DERIVATION	_T("__DERIVATION")
#define WMISYSTEM_DYNASTY		_T("__DYNASTY")
#define WMISYSTEM_GENUS			_T("__GENUS")
#define WMISYSTEM_NAMESPACE		_T("__NAMESPACE")
#define WMISYSTEM_PATH			_T("__PATH")
#define WMISYSTEM_PROPERTYCOUNT	_T("__PROPERTYCOUNT")
#define WMISYSTEM_REPLATH		_T("__RELPATH")
#define WMISYSTEM_SERVER		_T("__SERVER")
#define WMISYSTEM_SUPERCLASS	_T("__SUPERCLASS")

#define MULTINODE_XMLSTARTTAG	_T("<CIM>")
#define MULTINODE_XMLENDTAG		_T("</CIM>")

#define MULTINODE_XMLASSOCSTAG1		_T("<ASSOC.OBJECTARRAY>")
#define MULTINODE_XMLASSOCETAG1		_T("</ASSOC.OBJECTARRAY>")
#define MULTINODE_XMLASSOCSTAG2		_T("<VALUE.OBJECT>")
#define MULTINODE_XMLASSOCETAG2		_T("</VALUE.OBJECT>")

#define CLI_TOKEN_RESULTCLASS   _T("RESULTCLASS")
#define CLI_TOKEN_RESULTROLE    _T("RESULTROLE")
#define CLI_TOKEN_ASSOCCLASS    _T("ASSOCCLASS")

#define CLI_TOKEN_LOCALHOST		_T("LOCALHOST")

#define	NULL_STRING				_T("\0")
#define NULL_CSTRING			"\0"

#define	BACK_SPACE				0x08
#define	BLANK_CHAR				0x00
#define CARRIAGE_RETURN			0x0D
#define	ASTERIX 				_T( "*" )
#define	BEEP_SOUND				_T( "\a" )
#define	NULL_CHAR				_T( '\0' )
#define TOKEN_NA				_T("N/A")
#define MAXPASSWORDSIZE			BUFFER64
#define FORMAT_STRING( buffer, format, value ) \
							wsprintf( buffer, format, value )

#define EXCLUDESYSPROP			_T("ExcludeSystemProperties")
#define NODESCAVLBL				_T("<<Descripiton - Not Available>>")

#define UNICODE_SIGNATURE			"\xFF\xFE"
#define UNICODE_BIGEND_SIGNATURE	"\xFE\xFF"
#define UTF8_SIGNATURE				"\xEF\xBB"

#define PING_TIMEOUT			5000 // 5 Seconds
#define DEFAULT_SEND_SIZE       32
#define DEFAULT_TTL             128
#define DEFAULT_TOS             0
#define DEFAULT_BUFFER_SIZE     (0x2000 - 8)

//////////////////////////////////////////////////////////////////////
//						NUMERIC CONSTANTS							//
//////////////////////////////////////////////////////////////////////
const WMICLIINT OUT_OF_MEMORY			= 48111;
const WMICLIINT UNKNOWN_ERROR			= 44520;
const WMICLIINT MOFCOMP_ERROR			= 49999;
const WMICLIINT SET_CONHNDLR_ROUTN_FAIL	= 48112;
const WMICLIINT NOINTERACTIVE			= 0;
const WMICLIINT INTERACTIVE				= 1;
const WMICLIINT DEFAULTMODE				= 2;
const WMICLIINT DEFAULT_SCR_BUF_HEIGHT	= 300;
const WMICLIINT DEFAULT_SCR_BUF_WIDTH	= 1500;
const WMICLIINT MULTIPLENODE_ERROR		= 79999;

//////////////////////////////////////////////////////////////////////
//						ENUMERATED DATA TYPES						//
//////////////////////////////////////////////////////////////////////
// IMPERSONATION LEVEL
typedef enum tag_IMPERSONATIONLEVEL
{
	IMPDEFAULT		= 0, 
	IMPANONYMOUS	= 1, 
	IMPIDENTIFY		= 2, 
	IMPERSONATE		= 3, 
	IMPDELEGATE		= 4 
}IMPLEVEL;

// AUTHENTICATION LEVEL
typedef enum tag_AUTHENTICATIONLEVEL
{	
	AUTHDEFAULT			= 0, 
	AUTHNONE			= 1, 
	AUTHCONNECT			= 2,
	AUTHCALL			= 3, 
	AUTHPKT				= 4, 
	AUTHPKTINTEGRITY	= 5, 
	AUTHPKTPRIVACY		= 6 
}AUTHLEVEL;

// HELP OPTION
typedef enum tag_HELPOPTION
{
	HELPBRIEF	= 0,
	HELPFULL	= 1
}HELPOPTION;

// ENUMERATED RETURN CODES for PARSER ENGINE
typedef enum tag_RETCODE
{
	PARSER_ERROR				= 0,
	PARSER_DISPHELP				= 1,
	PARSER_EXECCOMMAND			= 2,
	PARSER_MESSAGE				= 3,
	PARSER_CONTINUE				= 4,
	PARSER_ERRMSG				= 5,
	PARSER_OUTOFMEMORY			= 6
} RETCODE;

// ENUMERATED HELP OPTION POSSIBILITES
typedef enum tag_HELPTYPE	
{
	GlblAllInfo, 
	Namespace, 
	Role,
	Node, 
	User, 
	Password,
	Authority,
	Locale,
	RecordPath, 
	Privileges, 
	Level,
	AuthLevel, 
	Interactive, 
	Trace,
	CmdAllInfo, 
	GETVerb, 
	SETVerb, 
	LISTVerb, 
	CALLVerb, 
	DUMPVerb,
	ASSOCVerb, 
	CREATEVerb,
	DELETEVerb,
	AliasVerb, 
	PATH,
	WHERE, 
	CLASS,
	PWhere,
	EXIT,
	TRANSLATE,
	EVERY,
	FORMAT,
	VERBSWITCHES,
	DESCRIPTION,
	GETSwitchesOnly,
	LISTSwitchesOnly,
	CONTEXTHELP,
	GLBLCONTEXT,
	ASSOCSwitchesOnly,
	RESULTCLASShelp,
	RESULTROLEhelp,
	ASSOCCLASShelp,
	FAILFAST,
	REPEAT,
	OUTPUT,
	APPEND,
	Aggregate
} HELPTYPE;

// ENUMERATED TOKEN LEVELS
typedef enum tag_TOKENLEVEL
{
	LEVEL_ONE = 1,
	LEVEL_TWO = 2

} TOKENLEVEL;

// ENUMERATED SESSION RETURN CODES.
typedef enum tag_SESSIONRETCODE
{
	SESSION_ERROR			= 0,
	SESSION_SUCCESS			= 1,
	SESSION_QUIT			= 2,
} SESSIONRETCODE;

// Property In or Out type for parameters
typedef enum tag_INOROUT
{
	INP		= 0,
	OUTP	= 1,
	UNKNOWN	= 2
} INOROUT;

typedef enum tag_GLBLSWITCHFLAG
{
	NAMESPACE	=	1,
	NODE		=	2,
	USER		=	4,
	PASSWORD	=	8,
	LOCALE		=	16,
	AUTHORITY   =   32
} GLBLSWITCHFLAG;

typedef enum tag_VERBTYPE
{
	CLASSMETHOD	=	0,
	STDVERB		=	1,
	CMDLINE		=	2,
	NONALIAS	=	3
} VERBTYPE;

typedef enum tag_ERRLOGOPT
{
	NO_LOGGING		=	0,
	ERRORS_ONLY		=	1,
	EVERY_OPERATION	=	2
} ERRLOGOPT;

// ENUMERATED Assoc Switches POSSIBILITES
typedef enum tag_ASSOCSwitch	
{
	RESULTCLASS	= 0,
	RESULTROLE	= 1,
	ASSOCCLASS	= 2
} ASSOCSwitch;

// ENUMERATED Output or Append option
typedef enum tag_OUTPUTSPEC	
{
	STDOUT		= 0,
	CLIPBOARD	= 1,
	FILEOUTPUT	= 2
} OUTPUTSPEC;

// ENUMERATED Interactive Option POSSIBILITES
typedef enum tag_INTEROPTION
{
	NO	= 0,
	YES	= 1,
	HELP= 2
} INTEROPTION;

// ENUMERATED values for File types
typedef enum tag_FILETYPE
{
	ANSI_FILE				= 0,
	UNICODE_FILE			= 1,
	UNICODE_BIGENDIAN_FILE	= 2,
	UTF8_FILE				= 3
} FILETYPE;

//////////////////////////////////////////////////////////////////////
//						TYPE DEFINITIONS							//
//////////////////////////////////////////////////////////////////////
typedef vector<_TCHAR*> CHARVECTOR;
typedef vector<LPSTR> LPSTRVECTOR;
typedef map<_bstr_t, _bstr_t, less<_bstr_t> > BSTRMAP;
typedef map<_TCHAR*, _TCHAR*, less<_TCHAR*> > CHARMAP;
typedef basic_string<_TCHAR> STRING;
typedef map<_bstr_t, WMICLIINT> CHARINTMAP;  
typedef vector<_bstr_t> BSTRVECTOR;

typedef map<_bstr_t, BSTRVECTOR, less<_bstr_t> > QUALDETMAP;

typedef struct tag_PROPERTYDETAILS
{
	_bstr_t		Derivation;		// Derivation - actual property name.
	_bstr_t		Description;	// Description about the property.
	_bstr_t		Type;			// Type of property CIMTYPE.
	_bstr_t		Operation;		// Read or Write flag for the property.
	_bstr_t		Default;		// Default values in case of method parameters
	INOROUT		InOrOut;		// Specifies Input or Output parameter in case
								// of method arguments. 
	QUALDETMAP	QualDetMap;		// Qualifiers associated with the property.
} PROPERTYDETAILS;
typedef map<_bstr_t, PROPERTYDETAILS, less<_bstr_t> > PROPDETMAP;

typedef struct tag_METHODDETAILS // or VERBDETAILS 
{
	_bstr_t Description;	// Desription.
	_bstr_t Status;			// Implemented or Not.
	PROPDETMAP	Params;		// In and Out parameters and types of the method.
} METHODDETAILS;
typedef map<_bstr_t, METHODDETAILS, less<_bstr_t> > METHDETMAP;
typedef map<_bstr_t, BSTRVECTOR, less<_bstr_t> >	ALSFMTDETMAP;

// For cascading transforms.
typedef struct tag_XSLTDET
{
	_bstr_t		FileName;
	BSTRMAP		ParamMap;
} XSLTDET;

typedef vector<XSLTDET> XSLTDETVECTOR; 

//////////////////////////////////////////////////////////////////////
//						USER DEFINED MACROS							//
//////////////////////////////////////////////////////////////////////
// SAFEIRELEASE(pIObj)
#define SAFEIRELEASE(pIObj) \
	if (pIObj) \
	{ \
		pIObj->Release(); \
		pIObj = NULL; \
	}

// SAFEBSTRFREE(bstrVal)
#define SAFEBSTRFREE(bstrVal) \
	if(bstrVal) \
	{	\
		SysFreeString(bstrVal); \
		bstrVal = NULL;	\
	}

// SAFEADESTROY(psaNames)
#define SAFEADESTROY(psaNames) \
	if(psaNames) \
	{	\
		SafeArrayDestroy(psaNames); \
		psaNames= NULL;	\
	}

// SAFEDELETE(pszVal)
#define SAFEDELETE(pszVal) \
	if(pszVal) \
	{	\
		delete [] pszVal; \
		pszVal = NULL; \
	} 

// VARIANTCLEAR(v)
#define VARIANTCLEAR(v)	\
		VariantClear(&v); \

// ONFAILTHROWERROR(hr)
#define ONFAILTHROWERROR(hr) \
	if (FAILED(hr)) \
		_com_issue_error(hr); 

//////////////////////////////////////////////////////////////////////
//						SMART POINTERS								//
//////////////////////////////////////////////////////////////////////

template < class T, T VALUE, typename FUNC = BOOL (*) ( T ), FUNC F = NULL >
class SmartHandle
{

private:
	T m_h;

	public:
	SmartHandle():m_h(VALUE)
	{
	}

	SmartHandle(T h):m_h(h)
	{
	}

	~SmartHandle()
	{
	   if (m_h!=VALUE)
	   {
		   F(m_h);
	   }
	}

	T operator =(T h)
	{
		if (m_h!=VALUE)
		{
			F(m_h);
		}

		m_h=h;
		return h;
	}

	operator T() const
	{
		return m_h;
	}
};

typedef SmartHandle <HANDLE, INVALID_HANDLE_VALUE, BOOL ( * ) ( HANDLE ),CloseHandle> SmartCloseHandle;	

//////////////////////////////////////////////////////////////////////
//						GLOBAL FUNCTIONS							//
//////////////////////////////////////////////////////////////////////

// Compare two strings (ignore case) and returns TRUE if 
// they are equal 
BOOL CompareTokens(_TCHAR* pszToken1, _TCHAR* pszToken2);
BOOL CompareTokensChars(_TCHAR* pszToken1, _TCHAR* pszToken2, DWORD cchToken);

// Connect to the WMI on the specified machine with input
// user credentials.

HRESULT Connect(IWbemLocator* pILocator, IWbemServices** pISvc,
				BSTR bstrNS, BSTR bstrUser, BSTR bstrPwd,
				BSTR bstrLocale, CParsedInfo& rParsedInfo);

// Set the security privileges at the interface level
HRESULT SetSecurity(IUnknown* pIUnknown, _TCHAR* pszAuthority,
					_TCHAR* pszDomain, _TCHAR* pszUser, 
					_TCHAR* pszPassword, UINT uAuthLevel, 
					UINT uImpLevel);

// Parse Authority string into user and domain info.
SCODE ParseAuthorityUserArgs(BSTR& bstrAuthArg, BSTR& bstrUserArg,
								BSTR& bstrAuthority, BSTR& bstrUser);

// Converts the	UNICODE string to MBCS string
BOOL ConvertWCToMBCS(LPTSTR lpszMsg, LPVOID* lpszDisp, UINT uCP);

// Converts the	MBCS string to UNICODE string
BOOL ConvertMBCSToWC(LPSTR lpszMsg, LPVOID* lpszDisp, UINT uCP);

// revert 'damage' caused by mbtowc
BOOL Revert_mbtowc ( LPCWSTR wszBuffer, LPSTR* szBuffer ) ;

// Finds a string in the CHARVECTOR.
BOOL Find(CHARVECTOR& cvVector, 
		  _TCHAR* pszStrToFind,
		  CHARVECTOR::iterator& theIterator);

// Finds a property in the PROPDETMAP.
BOOL Find(PROPDETMAP& pdmPropDetMap, 
		  _TCHAR* pszPropToFind,
		  PROPDETMAP::iterator& theIterator,
		  BOOL bExcludeNumbers = FALSE);

// Finds a property in the BSTRMAP.
BOOL Find(BSTRMAP& bmBstrMap, 
		  _TCHAR* pszStrToFind,
		  BSTRMAP::iterator& theIterator);

// Frames the XSL File path and updates the rParsedInfo object on behalf of file/keyword.
BOOL FrameFileAndAddToXSLTDetVector(LPCWSTR stylesheet,
									LPCWSTR keyword,
									CParsedInfo& rParsedInfo);

// Frames the XSL File path and updates the rParsedInfo object.
BOOL FrameFileAndAddToXSLTDetVector(XSLTDET& xdXSLTDet,
									CParsedInfo& rParsedInfo);


// Unquotes the string enclosed in double quotes.
void UnQuoteString(_TCHAR*& pszString);

// Display contents of a VARIANT type data object.
void DisplayVARIANTContent(VARIANT vtObject);

// Get Attributes of property
HRESULT GetPropertyAttributes(IWbemClassObject* pIObj, 
							  BSTR bstrProp,
							  PROPERTYDETAILS& pdPropDet,
							  BOOL bTrace);

// returns number from string
WMICLIINT GetNumber ( WCHAR* wsz );

// returns VariantType
VARTYPE ReturnVarType( _TCHAR* bstrCIMType );

// return file type
FILETYPE ReturnFileType ( FILE* file ) ;

// Convert CIMTYPE to VariantType
HRESULT ConvertCIMTYPEToVarType( VARIANT& varDest, VARIANT& varSrc,
							 _TCHAR* bstrCIMType );

// Displays the localized string
void DisplayMessage	(
						LPTSTR lpszMsg,
						UINT uCP = CP_OEMCP, 
						BOOL bIsError = FALSE,
						BOOL bIsLog = FALSE,
						BOOL bIsStream = FALSE
					);

// Free memory held by 
void CleanUpCharVector(CHARVECTOR& cvCharVector);

void FindAndReplaceAll(STRING& strString, _TCHAR* pszFromStr, 
														_TCHAR* pszToStr);

// Search and replace all the occurences of entity references.
void FindAndReplaceEntityReferences(_bstr_t& bstrString);

BOOL IsSysProp(_TCHAR* pszProp);


//To display the trace of COM methods invoked
void WMITRACEORERRORLOG(HRESULT hr, INT nLine, char* pszFile, _bstr_t bstrMsg,
						DWORD dwThreadId, CParsedInfo& rParsedInfo, BOOL bTrace,
						DWORD dwError = 0, _TCHAR* pszResult = NULL);

// Displays wi32 error. 
void DisplayWin32Error();

// Accepts password in invisible mode.
void AcceptPassword(_TCHAR* pszPassword);

// Checks for output redirection.
BOOL IsRedirection();

// Checks for value set or not.
BOOL IsValueSet(_TCHAR* pszFromValue, _TCHAR& cValue1, _TCHAR& cValue2);

// Handler routine to handle CTRL + C so as free
// the memory allocated during the program execution.
BOOL CtrlHandler(DWORD fdwCtrlType);

void DisplayString(UINT uID, UINT uCP, LPTSTR lpszParam = NULL, 
				   BOOL bIsError = FALSE, BOOL bIsLog = FALSE);

void EraseConsoleString(CONSOLE_SCREEN_BUFFER_INFO* csbiInfo);

void SubstituteEscapeChars(CHString& sTemp, LPCWSTR lpszSub);

void RemoveEscapeChars(CHString& sTemp);

//Frames the Namespace 
void FrameNamespace(_TCHAR* pszRoleOrNS, _TCHAR* pszRoleOrNSToUpdate);

// Set the buffer size of the command line
BOOL SetScreenBuffer(SHORT nHeight = DEFAULT_SCR_BUF_HEIGHT,
					 SHORT nWidth = DEFAULT_SCR_BUF_WIDTH);

// Get the buffer size of the command line
BOOL GetScreenBuffer(SHORT& nHeight, SHORT& nWidth);

// Formats the resource string with parameter substitution.
void WMIFormatMessage(UINT uID, WMICLIINT nParamCount, _bstr_t& bstrMsg, 
					  LPTSTR lpszParam, ...);

// Validates a node by using socket functions.
BOOL PingNode(_TCHAR* pszNode);

// If pszNodeName == NULL then check for GetNode() else pszNodeName itself.
BOOL IsFailFastAndNodeExist(CParsedInfo& rParsedInfo, _TCHAR* pszNodeName = NULL);

// Initilaizes windows socket interface.
BOOL InitWinsock ();

// Uninitializes windows socket interface.
BOOL TermWinsock ();

// Get _bstr_t object equivalent to	Varaint passed.
void GetBstrTFromVariant(VARIANT& vtVar, _bstr_t& bstrObj, 
						 _TCHAR* pszType = NULL);

// Close the output file.
BOOL CloseOutputFile();

// Close the append file.
BOOL CloseAppendFile();

// Checks if the next token indicates the presence
// of '/' or '-'
BOOL  IsOption(_TCHAR* pszToken);

// Copy string to global memory.
HGLOBAL CopyStringToHGlobal(LPCWSTR psz);

// Copy data to clip board.
void CopyToClipBoard(CHString& chsClipBoardBuffer);

// Checks file is valid or not.
RETCODE IsValidFile(_TCHAR* pszFileName);

// It checks whether the current operation is class 
// level operation or instance level operation
BOOL IsClassOperation(CParsedInfo& rParsedInfo);

// Enable or Disable all privileges
HRESULT	ModifyPrivileges(BOOL bEnable);

// Removes the paranthesis
void RemoveParanthesis(_TCHAR*& pszString);

// Removes the leading and trailing blank spaces
void TrimBlankSpaces(_TCHAR	*pszString);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\parsedinfo.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ParsedInfo.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Revision History			: 
	Last Modified by		: Ch. Sriramachandramurthy
	Last Modified Date		: 16th-January-2001
****************************************************************************/ 
/*-------------------------------------------------------------------
 Class Name			: CParsedInfo
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for accessing the storing the parsed command line
					  information. 
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: CGlobalSwitches
					  CCommandSwitches	
					  CHelpInfo
 Interfaces Used    : None
 --------------------------------------------------------------------*/
class CGlobalSwitches;
class CCommandSwitches;
class CHelpInfo;
class CErrorLog;

/////////////////////////////////////////////////////////////////////////////
class CParsedInfo
{
// Construction
public:
	CParsedInfo();

// Destruction
public:
	~CParsedInfo();

// Restrict Assignment
	CParsedInfo& operator=(CParsedInfo& rParsedInfo);

// Attributes
private:
	//member variable for storing Command switches
	CCommandSwitches	m_CmdSwitches;
	
	//member variable for storing Global switches
	CGlobalSwitches		m_GlblSwitches;
	
	//member variable for Help support
	CHelpInfo			m_HelpInfo;

	CErrorLog			m_ErrorLog;

	_TCHAR				m_pszPwd[2];
	
	WMICLIINT			m_bNewCmd;

	BOOL				m_bNewCycle;

// Operations
public:
	//Returns the member object "m_CmdSwitches"
	CCommandSwitches&	GetCmdSwitchesObject();
	
	//Returns the member object "m_GLblSwitches"
	CGlobalSwitches&	GetGlblSwitchesObject();
	
	//Returns the member object "m_HelpInfo"
	CHelpInfo&			GetHelpInfoObject();

	//Returns the member object m_ErrorLog;
	CErrorLog&			GetErrorLogObject();
	
	//Member function for initializing member variables
	void				Initialize();
	
	//Member function for uninitializing member variables
	void				Uninitialize(BOOL bBoth);
	
	// Returns user name
	_TCHAR*				GetUser();
	
	// Returns node name
	_TCHAR*				GetNode();

	// Returns locale value
	_TCHAR*				GetLocale();

	// Returns password 
	_TCHAR*				GetPassword();

	// Returns namespace value
	_TCHAR*				GetNamespace();

	// Returns the authority type.
	_TCHAR*				GetAuthorityPrinciple();

	// Returns the user. if NULL returns "N/A"
	void				GetUserDesc(_bstr_t& bstrUser);

	BOOL				GetNewCommandStatus();

	void				SetNewCommandStatus(BOOL bStatus);

	BOOL				GetNewCycleStatus();

	void				SetNewCycleStatus(BOOL bStatus);

	void				GetAuthorityDesc(_bstr_t& bstrAuthorityPrinciple);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\parserengine.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ParserEngine.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
							  for parsing the command string entered as input
							  and validating the same.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 18th-December-2000
*****************************************************************************/ 

// include files
#include "Precomp.h"
#include "GlobalSwitches.h"
#include "CommandSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "WMICliXMLLog.h"
#include "ErrorInfo.h"
#include "FormatEngine.h"
#include "ExecEngine.h"
#include "WmiCmdLn.h"
#include "resource.h"
/*----------------------------------------------------------------------------
   Name				 :CParserEngine
   Synopsis	         :This function initializes the member variables when an 
					  object of the class type is instantiated.
   Type	             :Constructor 
   Input Parameter(s):None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
----------------------------------------------------------------------------*/
CParserEngine::CParserEngine()
{
	m_pIWbemLocator = NULL;
	m_pITargetNS	= NULL;
	m_bAliasName	= FALSE;
}

/*----------------------------------------------------------------------------
   Name				 :~CParserEngine
   Synopsis	         :This function uninitializes the member variables when an
					  object of the class type goes out of scope.
   Type	             :Destructor
   Input Parameter(s):None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
----------------------------------------------------------------------------*/
CParserEngine::~CParserEngine()
{
	SAFEIRELEASE(m_pITargetNS);
	SAFEIRELEASE(m_pIWbemLocator);
}

/*----------------------------------------------------------------------------
   Name				 :GetCmdTokenizer
   Synopsis	         :This function returns a reference to the CCmdTokenizer 
					  object, a data member of this class.
   Type	             :Member Function
   Input Parameter(s):None
   Output parameters :None
   Return Type       :CCmdTokenizer&
   Global Variables  :None
   Calling Syntax    :GetCmdTokenizer()
   Notes             :None
----------------------------------------------------------------------------*/
CCmdTokenizer& CParserEngine::GetCmdTokenizer()
{
	return m_CmdTknzr;
}

/*----------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function initializes the neeeded data members of 
					  this class.
   Type	             :Member Function
   Input Parameter(s):None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :Initialize()
   Notes             :None
----------------------------------------------------------------------------*/
void CParserEngine::Initialize()
{
	m_bAliasName	= FALSE;
}

/*----------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables when 
					  the execution of a command string issued on the command 
					  line is completed and then the parser engine variables 
					  are also uninitialized.
   Type	             :Member Function
   Input Parameter(s):
			bFinal	- boolean value which when set indicates that the program
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
----------------------------------------------------------------------------*/
void CParserEngine::Uninitialize(BOOL bFinal)
{
	m_bAliasName = FALSE;
	m_CmdTknzr.Uninitialize();
	m_CmdAlias.Uninitialize();
	if (bFinal)
	{
		m_CmdAlias.Uninitialize(TRUE);
		SAFEIRELEASE(m_pITargetNS);
		SAFEIRELEASE(m_pIWbemLocator);
	}
}

/*----------------------------------------------------------------------------
   Name				 :SetLocatorObject
   Synopsis	         :This function sets the WMI Locator Object to the 
					  m_pIWbemLocator.
   Type	             :Member Function
   Input Parameter(s):
		pIWbemLocator - pointer to IWbemLocator interface .
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :SetLocatorObject(pIWbemLocator)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::SetLocatorObject(IWbemLocator* pIWbemLocator)
{
	static BOOL bFirst = TRUE;
	BOOL   bRet = TRUE;
	if (bFirst)
	{
		if (pIWbemLocator != NULL)
		{
			SAFEIRELEASE(m_pIWbemLocator);
			m_pIWbemLocator = pIWbemLocator;
			m_pIWbemLocator->AddRef();
		}
		else
			bRet = FALSE;
		bFirst = FALSE;
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ProcessTokens
   Synopsis	         :This function does the processing of the tokens. It 
					  checks for the presence of switches and calls the 
					  appropriate Parsing function and updates the CParsedInfo
					  object passed to it.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ProcessTokens(rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ProcessTokens(CParsedInfo& rParsedInfo)
{
	BOOL	bContinue			= TRUE;
	RETCODE retCode				= PARSER_EXECCOMMAND;
	
	// Obtain the token vector.
	CHARVECTOR cvTokens			= m_CmdTknzr.GetTokenVector();

	//the iterator to span throuh the vector variable 
	CHARVECTOR::iterator theIterator = NULL;

	// Check for the presence of tokens. Absence of tokens indicates
	// no command string is fed as input.
	if (!cvTokens.empty())
	{
		// Obtain the pointer to the beginning of the token vector.
	    theIterator = cvTokens.begin(); 

		// Check for the presence of the global switches and 
		// store the values specified with them (if any) in the 
		// CGlobalSwitches object. Global switches are followed
		// '/' character.
		if (IsOption(*theIterator))
		{
			retCode = ParseGlobalSwitches(cvTokens, 
									theIterator, rParsedInfo);
			if (retCode == PARSER_CONTINUE)
			{
				// If no more tokens are present
				if (theIterator >= cvTokens.end())
				{
					retCode = PARSER_MESSAGE;
					bContinue = FALSE;
				}
			}
			else
				bContinue = FALSE;
		}

		if (bContinue)
		{
			// Suppress Information Msg before Executing command.
			rParsedInfo.GetCmdSwitchesObject().SetInformationCode(0);

			// Check for the presence of the CLASS keyword
			if (CompareTokens(*theIterator, CLI_TOKEN_CLASS))
			{
				// Move to next token, and check its validity
				retCode = GetNextToken(cvTokens, theIterator,
										rParsedInfo, CLASS,
										IDS_E_INVALID_CLASS_SYNTAX);

				if (retCode == PARSER_CONTINUE)
				{
					// NOTE: Indicates direct escaping to WMI schema
					// Parse and interpret the remaining tokens following 
					// the CLASS keyword
					retCode = ParseClassInfo(cvTokens, theIterator, 
															rParsedInfo);
				}
			}
			// Check for the presence of the PATH keyword
			else if (CompareTokens(*theIterator, CLI_TOKEN_PATH))
			{
				//NOTE: Indicates PATH clause without an alias name
				// Move to next token
				retCode = GetNextToken(cvTokens, theIterator, 
									   rParsedInfo, PATH, 
									   IDS_E_INVALID_PATH_SYNTAX);
				if (retCode == PARSER_CONTINUE)
					// Parse and interpret the remaining tokens 
					// following the PATH clause
					retCode = ParsePathInfo(cvTokens, theIterator,
														rParsedInfo);
			}
			// Check for the presence of the CONTEXT keyword
			else if (CompareTokens(*theIterator, CLI_TOKEN_CONTEXT)) 
			{
				if (GetNextToken(cvTokens, theIterator))
				{
					retCode = ParseContextInfo(cvTokens, 
										theIterator, rParsedInfo);
				}
				else
				{
					rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(TRUE);
					rParsedInfo.GetHelpInfoObject().SetHelp(GLBLCONTEXT, TRUE);
					retCode = PARSER_DISPHELP;
				}
			}
			// If the token value does not match against the 
			// pre-defiend keywords, it is considered as an alias.
			else 
			{
				// Validate the alias name and parse the remaining 
				// tokens following the <alias> name.
				retCode = ParseAliasInfo(cvTokens, 
										theIterator, rParsedInfo);

				if (retCode == PARSER_EXECCOMMAND)
				{
					try
					{
						_bstr_t bstrTrgtClass;
						_TCHAR	*pszClass		= NULL;

						// Check the validity of the path expression w.r.t the 
						// alias specified using the following steps: 
						// (i.e to check for alias - path conflict)
						// step1: Obtain the alias target class.
						rParsedInfo.GetCmdSwitchesObject().
								GetClassOfAliasTarget(bstrTrgtClass);

						// step2: Obtain the explicitly specified class.
						pszClass = rParsedInfo.GetCmdSwitchesObject().
								GetClassPath();
						if (!(!bstrTrgtClass) && (pszClass != NULL))
						{
							// If both are not same, set the errata code
							if(!CompareTokens((_TCHAR*)bstrTrgtClass,pszClass))
							{
								// Set the error code
								rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(IDS_I_ALIAS_PATH_CONFLICT);
								retCode = PARSER_ERROR;
							}
						}
					}
					catch(_com_error& e)
					{
						_com_issue_error(e.Error());
					}
				}
			}
		}
	}
	else
	{
		// Indicates NULL string specified as input on the WMI Command Line.
		rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_BLANK_COMMAND_MESSAGE);
		retCode = PARSER_ERROR;
	}

	// Get the Property qualifiers information from the alias - SET and CREATE.
	if ((retCode == PARSER_EXECCOMMAND) && 
		((CompareTokens(rParsedInfo.GetCmdSwitchesObject().GetVerbName(), 
			CLI_TOKEN_SET)) || 
		 (CompareTokens(rParsedInfo.GetCmdSwitchesObject().GetVerbName(),
			CLI_TOKEN_CREATE))))
	{
		if (m_bAliasName)
		{
			if (FAILED(m_CmdAlias.ObtainAliasPropDetails(rParsedInfo)))
				retCode = PARSER_ERRMSG;
		}
	}

	if ( retCode == PARSER_DISPHELP )
	{
		if ( m_bAliasName ||
			 rParsedInfo.GetCmdSwitchesObject().GetClassPath() != NULL )
		{
			ObtainMethodsAvailableFlag(rParsedInfo);
			ObtainWriteablePropsAvailailableFlag(rParsedInfo);
		}

		if ( m_bAliasName == TRUE )
		{
			rParsedInfo.GetCmdSwitchesObject().
						SetLISTFormatsAvailable(
							m_CmdAlias.ObtainAliasFormat(rParsedInfo, TRUE));
		}
	}

	if ( retCode == PARSER_EXECCOMMAND || retCode == PARSER_DISPHELP )
	{
		retCode = ProcessOutputAndAppendFiles(rParsedInfo, retCode, FALSE);
	}
	else if (rParsedInfo.GetCmdSwitchesObject().GetOutputSwitchFlag() == TRUE
		    && retCode == PARSER_MESSAGE)
		rParsedInfo.GetCmdSwitchesObject().SetOutputSwitchFlag(FALSE);

	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseClassInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has CLASS keyword specified in it. It parses the 
					  remaining tokens following and updates the same in
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input Parameter(s)   :
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseClassInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseClassInfo(CHARVECTOR& cvTokens,
									  CHARVECTOR::iterator& theIterator,
									  CParsedInfo& rParsedInfo )
{
	// BNF: CLASS <class path expression> [<verb clause>]
	BOOL	bContinue = TRUE;
	RETCODE retCode   = PARSER_EXECCOMMAND;

	// If option
	if (IsOption(*theIterator))
	{
		// Check for help
		retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, CLASS,
								 IDS_E_INVALID_HELP_SYNTAX, LEVEL_ONE);
		if (retCode != PARSER_CONTINUE)
			bContinue = FALSE;
	}
	else 
	{
		// Store the class path in the CCommandSwitches object.
		if(!rParsedInfo.GetCmdSwitchesObject().SetClassPath(*theIterator))
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
			bContinue = FALSE;
			retCode = PARSER_OUTOFMEMORY;
		}

		if(bContinue)
		{
			// Move to next token
			if (!GetNextToken(cvTokens, theIterator))
			{
				// i.e. <verb clause> is not specified.
				bContinue = FALSE;
				retCode = PARSER_EXECCOMMAND;
			}
		}
	}
	
	if (bContinue)
	{
		// Check for the presence of /?
		if (IsOption(*theIterator))
		{
			// Check for help
			retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, CLASS, 
								   IDS_E_INVALID_HELP_SYNTAX, LEVEL_ONE);
		}
		else
		{
			// Parse and interpret the verb tokens that follow
			retCode = ParseVerbInfo(cvTokens,theIterator,rParsedInfo);
			if (retCode == PARSER_EXECCOMMAND)
			{
				// Check for verb switches
				if (GetNextToken(cvTokens, theIterator))
					retCode = ParseVerbSwitches(cvTokens, theIterator,
														rParsedInfo);
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseAliasInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has <alias> name in it.It Validate the alias name and 
					  parses the remaining tokens following the <alias> name.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseAliasInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseAliasInfo(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator, 
										CParsedInfo& rParsedInfo)
{
	//BNF: (<alias> | [<WMI object>] | [<alias>] <path where>) [<verb clause>]
	RETCODE		retCode		= PARSER_EXECCOMMAND;
	HRESULT		hr			= S_OK;
	BOOL		bContinue	= TRUE;
	RETCODE     tRetCode	= PARSER_ERROR;

	// Store the AliasName in the CommandSwitches object.
	if(!rParsedInfo.GetCmdSwitchesObject().SetAliasName(*theIterator))
	{	
		rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
		retCode = PARSER_OUTOFMEMORY;
	}
	else
	{
		m_bAliasName	= TRUE;

		// Move to next token
		retCode = GetNextToken(cvTokens, theIterator, 
								rParsedInfo, CmdAllInfo, IDS_E_INVALID_COMMAND);
		if (retCode == PARSER_ERROR)
			tRetCode = PARSER_EXECCOMMAND;

		else if(retCode == PARSER_DISPHELP && 
			rParsedInfo.GetGlblSwitchesObject().GetInteractiveStatus() == TRUE)
		{
			tRetCode = PARSER_EXECCOMMAND;
			rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(FALSE);
			rParsedInfo.GetHelpInfoObject().SetHelp(CmdAllInfo, FALSE);
		}
	
		// Connect to alias and retrieve the alias information
		try
		{
			// Connect to the AliasNamespace.
			hr = m_CmdAlias.ConnectToAlias(rParsedInfo, m_pIWbemLocator);
			ONFAILTHROWERROR(hr);

			// Obtain the alias information ( Target, Namespace,...)
			retCode = m_CmdAlias.ObtainAliasInfo(rParsedInfo);
			if((retCode == PARSER_OUTOFMEMORY) || (retCode == PARSER_ERRMSG))
			{
				if (retCode == PARSER_OUTOFMEMORY)
				{
					rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
				}
				bContinue = FALSE;
			}
		}
		catch(_com_error& e)
		{
			retCode = PARSER_ERRMSG;
			bContinue = FALSE;
			_com_issue_error(e.Error());
		}

		if (bContinue && tRetCode != PARSER_EXECCOMMAND)
		{
			// Check for the presence of the PATH keyword
			if (CompareTokens(*theIterator, CLI_TOKEN_PATH))
			{
				// NOTE: Indicates PATH clause preceded by an alias name
				// Move to next token
				retCode = GetNextToken(cvTokens, theIterator, 
							rParsedInfo, PATH, IDS_E_INVALID_PATH);
				if (retCode == PARSER_CONTINUE)
					// Parse and interpret the remaining tokens following
					// the PATH clause
					retCode = ParsePathInfo(cvTokens, theIterator, 
															 rParsedInfo);
			}
			// Check for the presence of the WHERE keyword
			else if (CompareTokens(*theIterator, CLI_TOKEN_WHERE))
			{
				// NOTE: Indicates WHERE clause preceded by an alias name
				// Move to next token
				retCode = GetNextToken(cvTokens, theIterator, rParsedInfo,
										WHERE, IDS_E_INVALID_QUERY);
				if (retCode == PARSER_CONTINUE)
					// Parse and interpret the remaining tokens following
					// the WHERE clause
					retCode = ParseWhereInfo(cvTokens, theIterator, 
															rParsedInfo);
			}
			// Check for the presence of the '('
			else if (CompareTokens(*theIterator, CLI_TOKEN_LEFT_PARAN))
			{
				// Frame the parameterized WHERE expression 
				if (!ParsePWhereExpr(cvTokens, theIterator, rParsedInfo,
																	TRUE))
				{
					retCode = PARSER_ERROR;
				}
				else
				{
					// Move to next token
					if (theIterator >= cvTokens.end())
					{
						// PARSER_ERROR if no more tokens are present
						rParsedInfo.GetCmdSwitchesObject().
								 SetErrataCode(IDS_E_INVALID_COMMAND);
						retCode = PARSER_ERROR;
					}
					else
					{
						if (CompareTokens(*theIterator, CLI_TOKEN_RIGHT_PARAN))
						{
							// Move to next token
							if (!GetNextToken(cvTokens, theIterator))
							{
								// if no more tokens are present.
								retCode = PARSER_EXECCOMMAND;
							}
							else
							{
								if (IsOption(*theIterator))
								{
									retCode = IsHelp(cvTokens, 
													 theIterator,
													 rParsedInfo,
													 PWhere,
													 IDS_E_INVALID_HELP_SYNTAX,
													 LEVEL_ONE);
									if ( retCode == PARSER_DISPHELP )
									{
										if (FAILED(m_CmdAlias.
										ObtainAliasVerbDetails(rParsedInfo)))
											retCode = PARSER_ERRMSG;			
									}
								}
								else
								{
									retCode = ParseVerbInfo(cvTokens, 
												theIterator, rParsedInfo);
									// Parse and interpret the verb tokens 
									// that follow
									if (retCode == PARSER_EXECCOMMAND)
									{
										if(GetNextToken(cvTokens,
														theIterator))
											// check for the common verb
											// switches /INTERACTIVE,
											// /NOINTERACTIVE
											retCode = ParseVerbSwitches(
															cvTokens, 
															theIterator,
															rParsedInfo);
									}
								}
							}
						}
						else
						{
							// PARSER_ERROR if no more tokens are present
							rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_COMMAND);
							retCode = PARSER_ERROR;
						}
					}
				}
			}
			else 
			{
				if (IsOption(*theIterator))
				{
					// Check for help
					retCode = IsHelp(cvTokens, theIterator, rParsedInfo, 
									CmdAllInfo, IDS_E_INVALID_HELP_SYNTAX,
									LEVEL_ONE);
					
					if (retCode == PARSER_DISPHELP)
					{
						rParsedInfo.GetCmdSwitchesObject().
								AddToAlsFrnNmsOrTrnsTblMap(
								CharUpper(rParsedInfo.GetCmdSwitchesObject().
										  GetAliasName()),
							rParsedInfo.GetCmdSwitchesObject().GetAliasDesc());
					}
				}
				else
				{
					if (bContinue)
					{
						// Frame the parameterized WHERE expression 
						if (!ParsePWhereExpr(cvTokens, theIterator, 
											 rParsedInfo, FALSE))
						{
							retCode = PARSER_ERROR;
						}
						else
						{
							if ( theIterator >= cvTokens.end() )
								retCode = PARSER_EXECCOMMAND;
							else
							{
								// Parse the verb.
								if (IsOption(*theIterator))
								{
									retCode = IsHelp(cvTokens, 
													 theIterator,
													 rParsedInfo,
													 PWhere,
													 IDS_E_INVALID_HELP_SYNTAX,
													 LEVEL_ONE);

									if ( retCode == PARSER_DISPHELP )
									{
										if (FAILED(m_CmdAlias.
										ObtainAliasVerbDetails(rParsedInfo)))
											retCode = PARSER_ERRMSG;			
									}
								}
								else
								{
									retCode = ParseVerbInfo(cvTokens, 
											theIterator, rParsedInfo);
									if (retCode == PARSER_EXECCOMMAND)
									{
										if (GetNextToken(cvTokens, theIterator))
											// check for the common verb switches 
											// /INTERACTIVE, /NOINTERACTIVE
											retCode = ParseVerbSwitches(cvTokens, 
														theIterator,
														rParsedInfo);
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if(tRetCode == PARSER_EXECCOMMAND) 
	{
		if ((retCode != PARSER_ERRMSG) && (retCode != PARSER_OUTOFMEMORY))
		{
			retCode = tRetCode;
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(0);
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseWhereInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has alias, with where clause also specified it.It parses
					  the remaining tokens following and updates the same in 
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input Parameter(s)   :
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output parameter(s) :
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseWhereInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseWhereInfo(CHARVECTOR& cvTokens,
									  CHARVECTOR::iterator& theIterator,
									  CParsedInfo& rParsedInfo)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;

	rParsedInfo.GetCmdSwitchesObject().SetExplicitWhereExprFlag(TRUE);

	if (IsOption(*theIterator))
	{
		// Check for help
		retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, 
				WHERE, IDS_E_INVALID_WHERE_SYNTAX, LEVEL_ONE); 
		if (retCode != PARSER_CONTINUE)
			bContinue = FALSE;
	}
	
	if (bContinue)
	{
		if ( !m_bAliasName && rParsedInfo.GetCmdSwitchesObject().
								GetClassPath() == NULL )
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_ALIAS_OR_PATH_SHOULD_PRECEED_WHERE);
			retCode = PARSER_ERROR;
		}
		// Store the WHERE expression in the CCommandSwitches object.
		else if(!rParsedInfo.GetCmdSwitchesObject().SetWhereExpression(
																*theIterator))
		{
			rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
			retCode = PARSER_OUTOFMEMORY;

		}
		else
		{
			// Move to next token
			if (!GetNextToken(cvTokens, theIterator))	
			{
				// If no more tokens are present. i.e no verb clause is present
				retCode = PARSER_EXECCOMMAND;
			}
			else
			{
				if (IsOption(*theIterator))
				{
					retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, WHERE, 
										IDS_E_INVALID_HELP_SYNTAX, LEVEL_ONE);
				}
				else
				{
					// Parse and interpret the verb tokens that follow
					// Handled for /verb to verb
					retCode = ParseVerbInfo(cvTokens, theIterator, 
																rParsedInfo);
					if (retCode == PARSER_EXECCOMMAND)
					{
						if (GetNextToken(cvTokens, theIterator))
							//check for the common verb switches /INTERACTIVE,
							// /NOINTERACTIVE
							retCode = ParseVerbSwitches(cvTokens, theIterator,
														rParsedInfo);
					}
				}
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParsePathInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has alias with path clause also specified it.It parses 
					  the remaining tokens following and updates the same in 
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s) :
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParsePathInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParsePathInfo(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;

	if (IsOption(*theIterator))
	{
		retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, 
				PATH, IDS_E_INVALID_PATH_SYNTAX, LEVEL_ONE); 
		if (retCode != PARSER_CONTINUE)
			bContinue = FALSE;
	}

	if (bContinue)
	{
		// Store the object PATH expression in the CCommandSwitches object.
		if(!rParsedInfo.GetCmdSwitchesObject().SetPathExpression(*theIterator))
		{
			rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(OUT_OF_MEMORY);
			retCode = PARSER_OUTOFMEMORY;
		}
		else
		{
			//Extract the classname and where expression given path expression
			_TCHAR pszPathExpr[MAX_BUFFER] = NULL_STRING;
			lstrcpy(pszPathExpr,CLI_TOKEN_NULL);
			lstrcpy(pszPathExpr, rParsedInfo.GetCmdSwitchesObject().
												GetPathExpression());
			if (!ExtractClassNameandWhereExpr(pszPathExpr, rParsedInfo))
				retCode = PARSER_ERROR;
				// Move to next token
			else if (!GetNextToken(cvTokens, theIterator))	
				// If no more tokens are present. i.e no verb clause is present
				retCode = PARSER_EXECCOMMAND;
			else
			{
				if ( CompareTokens(*theIterator, CLI_TOKEN_WHERE) )
				{
					if ( rParsedInfo.GetCmdSwitchesObject().
						 GetWhereExpression() != NULL )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_KEY_CLASS_NOT_ALLOWED_WITH_PATHWHERE);
						retCode = PARSER_ERROR;
					}
					else
					{
						retCode = GetNextToken(cvTokens, theIterator, 
											   rParsedInfo, WHERE,
											   IDS_E_INVALID_WHERE_SYNTAX);
						if (retCode == PARSER_CONTINUE)
							// Parse and interpret the remaining tokens 
							// following the WHERE clause
							retCode = ParseWhereInfo(cvTokens, theIterator, 
																rParsedInfo);
					}
				}
				else
				{
					if (IsOption(*theIterator))
					{
						retCode = IsHelp(cvTokens, theIterator,	rParsedInfo,
										PATH, IDS_E_INVALID_HELP_SYNTAX, 
										LEVEL_ONE);
					}
					else
					{
						// Parse and interpret the verb tokens that follow
						// Handled for /verb => verb.
						retCode = ParseVerbInfo(cvTokens,theIterator,rParsedInfo);
						if (retCode == PARSER_EXECCOMMAND)
						{
							if (GetNextToken(cvTokens, theIterator))
								//check for the common verb switches /INTERACTIVE, 
								///NOINTERACTIVE
								retCode = ParseVerbSwitches(cvTokens, theIterator,
															rParsedInfo);
						}
					}
				}
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseVerbInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has verb clause specified  in it.It parses the remaining
					  tokens following the verb and updates the same in 
					  CParsedInfo object passed to it.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseVerbInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseVerbInfo(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;

	// STORE the verb name in the CCommandSwitches object
	if ( rParsedInfo.GetCmdSwitchesObject().SetVerbName(*theIterator) 
															    == FALSE )
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(IDS_E_MEMALLOC_FAIL);
		retCode = PARSER_ERROR;
	}
	// Check for the presence of the following standard verbs:
	// 1.GET 2.SHOW 3.SET 4.CALL 5.ASSOC 6. CREATE 7. DELETE	
	// GET verb specified
	else if (CompareTokens(*theIterator, CLI_TOKEN_GET))
	{
		retCode = ParseGETVerb(cvTokens, theIterator, rParsedInfo);
	}
	// LIST verb specified
	else if (CompareTokens(*theIterator, CLI_TOKEN_LIST))
	{
		if (m_bAliasName == FALSE)
		{
			rParsedInfo.GetCmdSwitchesObject().
				SetErrataCode(IDS_E_INVALID_LIST_USAGE);
			retCode = PARSER_ERROR;
		}
		else
			retCode =  ParseLISTVerb(cvTokens, theIterator, rParsedInfo);
	}
	// SET | CREATE verb specified
	else if (CompareTokens(*theIterator, CLI_TOKEN_SET) ||
		CompareTokens(*theIterator, CLI_TOKEN_CREATE))
	{
		// <path expression> and <where expression> cannot be specified with
		// CREATE verb. Only <class expression> should be specified.
		if (CompareTokens(*theIterator, CLI_TOKEN_CREATE)
				&& rParsedInfo.GetCmdSwitchesObject().
					GetExplicitWhereExprFlag())
		{
			rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_CREATE_EXPRESSION);
			retCode = PARSER_ERROR;
		}
		else
		{
			HELPTYPE helpType = 
				CompareTokens(*theIterator, CLI_TOKEN_CREATE)
				? CREATEVerb : SETVerb;
			retCode = ParseSETorCREATEVerb(cvTokens, theIterator, 
					rParsedInfo, helpType);
		}
	}
	// CALL verb specified
	else if (CompareTokens(*theIterator, CLI_TOKEN_CALL))
	{
		retCode = ParseCALLVerb(cvTokens, theIterator, rParsedInfo);
	}
	// ASSOC verb specified
	else if (CompareTokens(*theIterator, CLI_TOKEN_ASSOC))
	{
		retCode = ParseASSOCVerb(cvTokens, theIterator, rParsedInfo);
	}
	// DELETE verb specified.
	else if (CompareTokens(*theIterator, CLI_TOKEN_DELETE))
	{
		retCode = PARSER_EXECCOMMAND;
		//ParseDELETEVerb(cvTokens, theIterator, rParsedInfo);
	}
	// User defined verb
	else if (m_bAliasName)
	{
		// User defined verbs can only be associated with alias
		retCode = ParseMethodInfo(cvTokens, theIterator, rParsedInfo);
		if (retCode == PARSER_CONTINUE)
			retCode = PARSER_EXECCOMMAND;
	}
	else
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(IDS_E_INVALID_VERB);
		retCode = PARSER_ERROR;
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseMethodInfo
   Synopsis	         :This function parses the tokens following  the user 
					  defined verb and updates the info in CParsedInfo object 
					  passed to it.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseMethodInfo(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseMethodInfo(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator,
										CParsedInfo& rParsedInfo)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;

	// Store the method name
	if(!rParsedInfo.GetCmdSwitchesObject().SetMethodName(*theIterator))
	{
		rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(OUT_OF_MEMORY);
		retCode = PARSER_OUTOFMEMORY;
	}
	else
	{
		if(m_bAliasName)
		{
			if (FAILED(m_CmdAlias.ObtainAliasVerbDetails(rParsedInfo)))
			{
				retCode = PARSER_ERRMSG;	
				bContinue =FALSE;
			}
			else
			{
				VERBTYPE vtVerbType =
							rParsedInfo.GetCmdSwitchesObject().GetVerbType();
				_TCHAR* pszVerbDerivation =
					rParsedInfo.GetCmdSwitchesObject().GetVerbDerivation();

				if ( rParsedInfo.GetCmdSwitchesObject().GetMethDetMap().empty())
				{
					DisplayMessage(*theIterator, CP_OEMCP, TRUE, TRUE);
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_ALIAS_VERB);
					retCode = PARSER_ERROR;
					bContinue = FALSE;
				}
				else if ( pszVerbDerivation == NULL )
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_VERB_DERV_NOT_AVAIL_IN_ALIAS);
					retCode = PARSER_ERROR;
					bContinue = FALSE;
				}
				else if ( vtVerbType == CLASSMETHOD )
				{
					if (!rParsedInfo.GetCmdSwitchesObject().SetMethodName(
														   pszVerbDerivation))
					{
						rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(OUT_OF_MEMORY);
						retCode = PARSER_OUTOFMEMORY;
						bContinue = FALSE;
					}
				}
				else if ( vtVerbType == STDVERB )
				{
					(*theIterator) = pszVerbDerivation;
					// Parse and interpret the verb tokens that follow
					// Handled for /verb => verb.
					retCode = ParseVerbInfo(cvTokens,theIterator,rParsedInfo);
					if (retCode == PARSER_EXECCOMMAND)
					{
						if (GetNextToken(cvTokens, theIterator))
							retCode = ParseVerbSwitches(cvTokens, theIterator,
												rParsedInfo);
					}
					bContinue =FALSE;
				}
			}
		}
		else 
		{
			if (!ObtainClassMethods(rParsedInfo))
			{
			}
			else if (rParsedInfo.GetCmdSwitchesObject().GetMethDetMap().empty())
			{
				DisplayMessage(*theIterator, CP_OEMCP, TRUE, TRUE);
				rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_CLASS_METHOD);
				retCode = PARSER_ERROR;
				bContinue =FALSE;
			}
		}

		// Move to next token
		if ( bContinue == TRUE && !GetNextToken(cvTokens, theIterator) )
		{
			// indicates method with no parameters
			retCode = PARSER_EXECCOMMAND;
			bContinue =FALSE;
		}

		if (bContinue)
		{
			if (IsOption(*theIterator)) 
			{
				retCode = IsHelp(cvTokens, theIterator, rParsedInfo, AliasVerb, 
								IDS_E_INVALID_EXPRESSION, LEVEL_TWO); 

				if (retCode == PARSER_CONTINUE)
					// To facilitate ParseVerbSwitches to continue
					theIterator = theIterator - 2;
				else if (retCode == PARSER_DISPHELP)
				{
					rParsedInfo.GetCmdSwitchesObject().GetMethDetMap().
																	clear();
					if(m_bAliasName)
					{
						if (FAILED(m_CmdAlias.ObtainAliasVerbDetails(
																rParsedInfo)))
							retCode = PARSER_ERRMSG;			
					}
					else ObtainClassMethods(rParsedInfo);
				}
			}
			else
			{
				BOOL bNamedParamList;
				// Check for NamedParamList or UnnamedParamList.
				if ( (theIterator + 1) < cvTokens.end() &&
					 CompareTokens(*(theIterator + 1), CLI_TOKEN_EQUALTO ) )
				{
					retCode = ParseSETorCREATEOrNamedParamInfo(cvTokens,
															   theIterator,
															   rParsedInfo,
															   CALLVerb);
					if ( retCode == PARSER_EXECCOMMAND )
						retCode = ValidateVerbOrMethodParams(rParsedInfo);

					bNamedParamList = TRUE;
				}
				else
				{
					retCode = ParseUnnamedParamList(cvTokens, theIterator,
													rParsedInfo);
					bNamedParamList = FALSE;
				}
				
				rParsedInfo.GetCmdSwitchesObject().SetNamedParamListFlag(
															 bNamedParamList);
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseSETorCREATEVerb
   Synopsis	         :This function parses the tokens following SET|CREATE verb
					  and updates the info in CParsedInfo object passed to it.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
		HELPTYPE	 - helpType
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseSETorCREATEVerb(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseSETorCREATEVerb(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo,
									HELPTYPE helpType)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;
	
	try
	{
		retCode = GetNextToken(cvTokens, theIterator, rParsedInfo, 
								helpType, IDS_E_INCOMPLETE_COMMAND);

		if (retCode == PARSER_CONTINUE)
		{
			if (IsOption(*theIterator)) 
			{
				retCode = IsHelp(cvTokens, theIterator, rParsedInfo, helpType,
											IDS_E_INVALID_COMMAND, LEVEL_ONE);

				if (retCode == PARSER_DISPHELP)
				{
					if (m_bAliasName)
					{
						if (FAILED(m_CmdAlias.
								ObtainAliasPropDetails(rParsedInfo)))
									retCode = PARSER_ERRMSG;
					}
					else
					{
						ObtainClassProperties(rParsedInfo);
					}
				}
			}
			else
				retCode = ParseSETorCREATEOrNamedParamInfo(cvTokens, 
							theIterator, rParsedInfo, helpType);
		}
		
	}
	catch(_com_error& e)
	{
		retCode = PARSER_ERROR;
		_com_issue_error(e.Error());
	}

	return retCode;
}


/*----------------------------------------------------------------------------
   Name				 :ParseGETVerb
   Synopsis	         :This function parses the tokens following the GET verb
					  and updates the info in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseGETVerb(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseGETVerb(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo)
{
	BOOL		bPropList		= FALSE;
	RETCODE		retCode			= PARSER_EXECCOMMAND;
	BOOL		bContinue		= TRUE;
	_TCHAR		*pszNewEntry	= NULL;

	// Move to next token
	if (!GetNextToken(cvTokens, theIterator))
	{
		// GET format | switches not specified.
		retCode = PARSER_EXECCOMMAND;
	}
	else
	{
		BOOL bClass = FALSE;
		if(IsClassOperation(rParsedInfo))
		{
			bClass = TRUE;
		}

		if(!bClass)
		{
			// Process the property list specified
			if (!IsOption(*theIterator)) 
			{
				bPropList = TRUE;
				// Obtain the list of properties specified.
				while (TRUE) 
				{
					// Add the property to the property vector of the
					// CCommandSwitches object
					if(!rParsedInfo.GetCmdSwitchesObject().
									AddToPropertyList(*theIterator))
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_ADD_TO_PROP_LIST_FAILURE);
						bPropList = FALSE;
						bContinue = FALSE;
						retCode = PARSER_ERROR;
						break;
					}

					// Move to next token
					if (!GetNextToken(cvTokens, theIterator))
					{
						// set the return code as PARSER_EXECCOMMAND 
						// if no more tokens are present 
						retCode = PARSER_EXECCOMMAND;
						bContinue = FALSE;
						break;
					}

					// Check for the presence of ',' token
					if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
					{
						if (!GetNextToken(cvTokens, theIterator))
						{
							rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_EXPRESSION);
							retCode = PARSER_ERROR;
							bContinue = FALSE;
							break;
						}
					}
					else
						break;
				}
			}
		}

		if (bContinue)
		{
			// alias|class get param1,param2... /getswitches
			if (IsOption(*theIterator))
			{
				retCode = IsHelp(cvTokens, theIterator, rParsedInfo, GETVerb,
									IDS_E_INVALID_EXPRESSION, LEVEL_TWO); 

				if (retCode != PARSER_CONTINUE)
				{
					if (retCode == PARSER_DISPHELP)
					{
						if (m_bAliasName)
						{
							if (FAILED(m_CmdAlias.
									ObtainAliasPropDetails(rParsedInfo)))
										retCode = PARSER_ERRMSG;
						}
						else
						{
							ObtainClassProperties(rParsedInfo);
						}
					}
					bContinue = FALSE;
				}

				if (bContinue)
					retCode = ParseGETSwitches(cvTokens, theIterator, 
																rParsedInfo);
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(IDS_E_INVALID_GET_EXPRESSION);
				retCode = PARSER_ERROR;
			}
		}

		// If property names are specified then replace them with their 
		// derivations. 
		if ( retCode == PARSER_EXECCOMMAND )
		{
			if (m_bAliasName)
			{
				if (FAILED(m_CmdAlias.
						ObtainAliasPropDetails(rParsedInfo)))
							retCode = PARSER_ERRMSG;
			}
			else
			{
				ObtainClassProperties(rParsedInfo);
			}

			PROPDETMAP pdmPropDet = rParsedInfo.GetCmdSwitchesObject().
									  GetPropDetMap(); 	
			PROPDETMAP::iterator itrPropDet = NULL;
			CHARVECTOR cvPropsSpecified = rParsedInfo.
										  GetCmdSwitchesObject().
										  GetPropertyList();
			CHARVECTOR::iterator theIterator = NULL;
			CHARVECTOR cvPropDerivations;
			for ( theIterator = cvPropsSpecified.begin();
				  theIterator != cvPropsSpecified.end();
				  theIterator++ )
			{
				try
				{
					BOOL bFind = Find(pdmPropDet, *theIterator, itrPropDet);
					_bstr_t bstrPropDerivation;
					if ( bFind )
						bstrPropDerivation = _bstr_t(
											 (*itrPropDet).second.Derivation);
					else
						bstrPropDerivation = _bstr_t(*theIterator);
					_TCHAR* pszNewEntry = 
									new _TCHAR[bstrPropDerivation.length()+1];

					if (pszNewEntry == NULL)
						_com_issue_error(WBEM_E_OUT_OF_MEMORY);

					lstrcpy(pszNewEntry, bstrPropDerivation);
					cvPropDerivations.push_back(pszNewEntry);
				}
				catch(_com_error& e)
				{
					SAFEDELETE(pszNewEntry);
					retCode = PARSER_ERROR;
					CleanUpCharVector(cvPropDerivations);					
					_com_issue_error(e.Error());
				}
			}

			rParsedInfo.GetCmdSwitchesObject().ClearPropertyList();
			for ( theIterator = cvPropDerivations.begin();
					  theIterator != cvPropDerivations.end();
					  theIterator++ )
			{
				rParsedInfo.GetCmdSwitchesObject().
									AddToPropertyList(*theIterator);
			}
			CleanUpCharVector(cvPropDerivations);
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseLISTVerb
   Synopsis	         :This function parses the tokens following the LIST verb
					  and updates the info in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s) :
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseLISTVerb(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseLISTVerb(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo)
{
	RETCODE	 retCode	= PARSER_EXECCOMMAND;
	BOOL	 bContinue	= TRUE;
	HRESULT  hr			= S_OK;
	BOOL	 bSetDefaultFormat = TRUE;

	// Set the default LIST format
 	if(!rParsedInfo.GetCmdSwitchesObject().SetListFormat(CLI_TOKEN_FULL))
	{
		rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
		retCode = PARSER_OUTOFMEMORY;
	}
	
	if (bContinue)
	{
		// If <list format> <list switches> specified.
		if (GetNextToken(cvTokens, theIterator))
		{
			// Check for LIST formats (LIST formats are not preceded by '/')
			if (!IsOption(*theIterator)) 
			{
				// If token is not followed by "/" or "-" then it is LIST format.
				if(!rParsedInfo.GetCmdSwitchesObject().
											SetListFormat(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					bContinue = FALSE;
				}

				// If list format explicitly specified then do not set 
				// default format.
				bSetDefaultFormat = FALSE;

				// Get all the properties from alias definition for the format 
				// specified
				if (bContinue)
				{
					// no more tokens are present.
					if (!GetNextToken(cvTokens, theIterator))
					{
						bContinue = FALSE;
						retCode = PARSER_EXECCOMMAND;
					}
					else
						rParsedInfo.GetHelpInfoObject().SetHelp(
												  LISTSwitchesOnly, TRUE);
				}
			}
			
			if (bContinue == TRUE )
			{
				if ( IsOption(*theIterator) )
				{
					retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, LISTVerb,
									IDS_E_INVALID_EXPRESSION, LEVEL_TWO);

					// If more tokens are present.
					if (retCode == PARSER_CONTINUE)
					{
						BOOL bFormatSwitchSpecified; 
						// Parse for LIST switches.
						retCode = ParseLISTSwitches(cvTokens, theIterator, 
													rParsedInfo, 
													bFormatSwitchSpecified);
						// If /format is specified in list switches then 
						// do not set default format.
						if ( bFormatSwitchSpecified == TRUE )
							bSetDefaultFormat = FALSE;
					}
					else if ( retCode == PARSER_DISPHELP )
					{
						if ( rParsedInfo.GetHelpInfoObject().
									GetHelp(LISTSwitchesOnly) == FALSE )
						{
							hr = m_CmdAlias.PopulateAliasFormatMap(
																 rParsedInfo);
							ONFAILTHROWERROR(hr);
						}
					}
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_LIST_EXPRESSION);
					retCode = PARSER_ERROR;
				}
			}
		}
	}

	if (retCode == PARSER_EXECCOMMAND)
	{
		// Obtain all properties from alias definition
		if (!m_CmdAlias.ObtainAliasFormat(rParsedInfo))
		{
			// If failed to obtain the alias properties return PARSER_ERROR
			if (rParsedInfo.GetCmdSwitchesObject().GetErrataCode() == 0)
			{
				rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_LIST_FORMAT);
			}
			retCode = PARSER_ERROR;
		}

		if ( bSetDefaultFormat == TRUE )
		{
			rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();
			if ( FALSE == FrameFileAndAddToXSLTDetVector	(
																XSL_FORMAT_TABLE,
																CLI_TOKEN_TABLE,
																rParsedInfo
															)
			   )
			{
				retCode = PARSER_ERRMSG;
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseASSOCVerb
   Synopsis	         :This function parses the tokens following the ASSOC verb
					  and updates the info in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseASSOCVerb(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseASSOCVerb(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	BOOL	bContinue	= TRUE;
	
	// Move to next token
	if (!GetNextToken(cvTokens, theIterator))
	{
		retCode = PARSER_EXECCOMMAND;
	}
	// If it is followed by a ":" <assoc format specifier is given
	// Move to next token
	else
	{
		if (CompareTokens(*theIterator, CLI_TOKEN_COLON))
		{
			// Move to next token
			if (!GetNextToken(cvTokens, theIterator))
			{
				// PARSER_ERROR if <format specifier> is missing
				rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_ASSOC_FORMATSPECIFIER);
				retCode = PARSER_ERROR;
			}
			else if (IsOption(*theIterator))
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_ASSOC_FORMATSPECIFIER);
				retCode = PARSER_ERROR;
			}
			else 
			{
				rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();
				
				BOOL	bFrameXSLFile = TRUE;
				XSLTDET xdXSLTDet;
				xdXSLTDet.FileName = *theIterator;
				if(!g_wmiCmd.GetFileFromKey(*theIterator, xdXSLTDet.FileName))
					bFrameXSLFile	= FALSE;
				
				if ( bFrameXSLFile == TRUE )
				{
					if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
															 rParsedInfo))
						retCode = PARSER_ERRMSG;
				}
				else
					rParsedInfo.GetCmdSwitchesObject().
									AddToXSLTDetailsVector(xdXSLTDet);
			}

			GetNextToken(cvTokens, theIterator);
			rParsedInfo.GetHelpInfoObject().SetHelp(ASSOCSwitchesOnly, TRUE);

		}///END for check of ":"
		
		if ( retCode == PARSER_EXECCOMMAND && 
			 theIterator < cvTokens.end() )
		{
			if (IsOption(*theIterator)) 
			{
				retCode = IsHelp(cvTokens, theIterator, rParsedInfo, ASSOCVerb,
					IDS_E_INVALID_COMMAND,LEVEL_TWO);
				
				// If more tokens are present.
				if (retCode == PARSER_CONTINUE)
				{
					//Parse for Assoc switches.
					retCode = ParseAssocSwitches(cvTokens, theIterator, 
						rParsedInfo);
				}
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_ASSOC_SYNTAX);
				retCode = PARSER_ERROR;
			}
		}
	}

	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseCALLVerb
   Synopsis	         :This function parses the tokens following the CALL verb
					  and updates the info in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseCALLVerb(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseCALLVerb(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator, 
									CParsedInfo& rParsedInfo)
{
	RETCODE		retCode		= PARSER_EXECCOMMAND;
	BOOL		bContinue	= TRUE;
	
	// Move to next token
	retCode = GetNextToken(cvTokens, theIterator, rParsedInfo,
						CALLVerb, IDS_E_INCOMPLETE_COMMAND);

	if (retCode == PARSER_CONTINUE)
	{
		if (IsOption(*theIterator)) 
		{
			retCode = IsHelp(cvTokens, theIterator, rParsedInfo, CALLVerb, 
										IDS_E_INVALID_EXPRESSION, LEVEL_TWO);
			if (retCode != PARSER_CONTINUE)
			{
				if (retCode == PARSER_DISPHELP)
				{
					if(m_bAliasName)
					{
						if (FAILED(m_CmdAlias.ObtainAliasVerbDetails(rParsedInfo)))
							retCode = PARSER_ERRMSG;			
					}
					else 
					{
						ObtainClassMethods(rParsedInfo);
					}
				}
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										  IDS_E_VERB_OR_METHOD_NOT_SPECIFIED);
				retCode = PARSER_ERROR;
/*				theIterator = theIterator-2;
				retCode = PARSER_EXECCOMMAND;
*/			}
		}
		else
		{
			retCode = ParseMethodInfo(cvTokens, theIterator, rParsedInfo);
			if (retCode == PARSER_CONTINUE)
				retCode = PARSER_EXECCOMMAND;
		}
	}
	else if (retCode == PARSER_DISPHELP)
	{
		if(m_bAliasName)
		{
			if (FAILED(m_CmdAlias.ObtainAliasVerbDetails(rParsedInfo)))
				retCode = PARSER_ERRMSG;			
		}
		else 
		{
			if (!ObtainClassMethods(rParsedInfo))
				retCode = PARSER_ERRMSG;
		}
	}

	return retCode;
}


/*----------------------------------------------------------------------------
   Name				 :ParseGlobalSwitches
   Synopsis	         :This function does the parsing and interprets if command
					  has global switches specified  in it. It parses the 
					  remaining tokens following and updates the same in 
					  CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseGlobalSwitches(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseGlobalSwitches(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo &rParsedInfo)
{
	RETCODE retCode					= PARSER_CONTINUE;
	BOOL	bContinue				= TRUE;
	BOOL	bPassFlag				= FALSE;
	BOOL	bUserFlag				= FALSE;
	BOOL	bOpenOutFileInWriteMode	= FALSE;
	
	while (TRUE)
	{
		// Move to next token
		retCode = GetNextToken(cvTokens, theIterator, rParsedInfo,
											IDS_E_INVALID_GLOBAL_SWITCH);
		if (retCode != PARSER_CONTINUE)
			break;
			
		// Check for the presence of NAMESPACE global switch
		if (CompareTokens(*theIterator, CLI_TOKEN_NAMESPACE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INCORRECT_NAMESPACE,
											rParsedInfo,
											IDS_E_INVALID_NAMESPACE_SYNTAX,
											Namespace);
			if (retCode == PARSER_CONTINUE)
			{
				LONG lPresNamespaceLen = 
				  lstrlen(rParsedInfo.GetGlblSwitchesObject().GetNameSpace());
				LONG lUserInputNamespaceLen = lstrlen(*theIterator);
				_TCHAR *pszNamespaceToBeUpdated = new _TCHAR[
						// +2 for '\' and '\0' 
						lUserInputNamespaceLen + lPresNamespaceLen + 2];
				if (pszNamespaceToBeUpdated == NULL)
					throw OUT_OF_MEMORY;

				lstrcpy(pszNamespaceToBeUpdated,
					    rParsedInfo.GetGlblSwitchesObject().GetNameSpace());

				FrameNamespace(*theIterator, pszNamespaceToBeUpdated);

				if(!rParsedInfo.GetGlblSwitchesObject().
					SetNameSpace(pszNamespaceToBeUpdated))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					break;
				}

				SAFEDELETE(pszNamespaceToBeUpdated);
			}
			else
				break;
		}
		// Check for the presence of ROLE global switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_ROLE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_ROLE,
											rParsedInfo,
											IDS_E_INVALID_ROLE_SYNTAX,
											Role);
			if (retCode == PARSER_CONTINUE)
			{
				LONG lPresRoleLen = 
				  lstrlen(rParsedInfo.GetGlblSwitchesObject().GetRole());
				LONG lUserInputRoleLen = lstrlen(*theIterator);
				_TCHAR *pszRoleToBeUpdated = new _TCHAR[ 
										// +2 one for '\' and one for '\0'
										lPresRoleLen + lUserInputRoleLen + 2];
				if (pszRoleToBeUpdated == NULL)
					throw OUT_OF_MEMORY;

				lstrcpy(pszRoleToBeUpdated,
					    rParsedInfo.GetGlblSwitchesObject().GetRole());

				FrameNamespace(*theIterator, pszRoleToBeUpdated);

				if (!CompareTokens(pszRoleToBeUpdated, CLI_TOKEN_NULL) &&
					rParsedInfo.GetGlblSwitchesObject().
						GetInteractiveStatus() == TRUE)
				{
					if (!ValidateNodeOrNS(pszRoleToBeUpdated, FALSE))
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_ROLE);
						retCode = PARSER_ERROR;
						break;
					}
				}

				if(!rParsedInfo.GetGlblSwitchesObject().
						SetRole(pszRoleToBeUpdated))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					break;
				}
				SAFEDELETE(pszRoleToBeUpdated);
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_NODE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_MACHINE_NAME,
											rParsedInfo,
											IDS_E_INVALID_NODE_SYNTAX,
											Node);

			if (retCode == PARSER_CONTINUE)
			{
				BOOL bBreakOuterLoop = FALSE;
				BOOL bGetValidNode = FALSE;
				BOOL bNodeListCleared = FALSE;

				while ( TRUE )
				{
					try
					{
						CHString chsNodeName(*theIterator);
						chsNodeName.TrimLeft();
						chsNodeName.TrimRight();

						lstrcpy(*theIterator, (LPCWSTR) chsNodeName);
					}
					catch(CHeap_Exception)
					{
						_com_issue_error(WBEM_E_OUT_OF_MEMORY);
					}

					if ( *theIterator[0] == _T('@') )
					{
						retCode = ParseNodeListFile(cvTokens, theIterator, 
													rParsedInfo);
						if ( retCode != PARSER_CONTINUE )
						{
							bBreakOuterLoop = TRUE;
							break;
						}
					}

					// If interactive mode then check for the validity of 
					// nodes
					if(rParsedInfo.GetGlblSwitchesObject().
									GetInteractiveStatus())
					{
						BOOL bNodeExist		= TRUE;
						if ( rParsedInfo.GetGlblSwitchesObject().
													   GetFailFast() == TRUE )
						{
							bNodeExist = 
							IsFailFastAndNodeExist(rParsedInfo, *theIterator);
						}
						else
							bNodeExist = ValidateNodeOrNS(*theIterator, TRUE);

						if( bNodeExist == FALSE)
						{
							// Display error message for invalid node
							DisplayString(IDS_E_INVALID_NODE, CP_OEMCP, *theIterator, TRUE);
							if ( !GetNextToken(cvTokens, theIterator))
							{
								// If no more tokens are present then stop
								// further processing
								bBreakOuterLoop = TRUE;
								break;
							}
							else
							{
								// If multiple nodes are defined then check 
								// tokens
								if (CompareTokens(*theIterator, 
											CLI_TOKEN_COMMA))
								{
									// If invalid node syntax given then report
									// error
									if ( !GetNextToken(cvTokens, theIterator) )
									{
										rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(IDS_E_INVALID_NODE_SYNTAX);
										retCode=PARSER_ERROR;
										bBreakOuterLoop = TRUE;
										break;
									}
									else if ( IsOption (*theIterator) )
									{
										rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(IDS_E_INVALID_NODE_SYNTAX);
										retCode=PARSER_ERROR;
										bBreakOuterLoop = TRUE;
										break;
									}

									//Skip adding this invalid node to node list
									continue;
								}
								else
								{
									// If no more node present
									theIterator--;
									break;
								}
							}
						}
						else
							// Set flag for valid node
							bGetValidNode = TRUE;

						// If valid node(s) are present and list is not 
						// already cleared then clear it
						if(bGetValidNode && !bNodeListCleared)
						{
							if (!rParsedInfo.GetGlblSwitchesObject().
									ClearNodesList())
							{
								rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(OUT_OF_MEMORY);
								retCode = PARSER_OUTOFMEMORY;
								break;
							}
							bNodeListCleared = TRUE;
						}
					}
					else if( bNodeListCleared == FALSE )
					{
						// If not in interactive mode then clear
						// previous node list
						if (!rParsedInfo.GetGlblSwitchesObject().
								ClearNodesList())
						{
							rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(OUT_OF_MEMORY);
							retCode = PARSER_OUTOFMEMORY;
							break;
						}
						bNodeListCleared = TRUE;
					}
					
					if (rParsedInfo.GetGlblSwitchesObject().
										AddToNodesList(*theIterator))
					{
						if ( GetNextToken(cvTokens, theIterator) )
						{
							if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
							{
								if ( !GetNextToken(cvTokens, theIterator) )
								{
									rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(IDS_E_INVALID_NODE_SYNTAX);
									retCode=PARSER_ERROR;
									bBreakOuterLoop = TRUE;
								}
								else if ( IsOption (*theIterator) )
								{
									rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(IDS_E_INVALID_NODE_SYNTAX);
									retCode=PARSER_ERROR;
									bBreakOuterLoop = TRUE;
								}
							}
							else
							{
								theIterator--;
								break;
							}
						}
						else
							bBreakOuterLoop = TRUE;
					}
					else
					{
						rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(OUT_OF_MEMORY);
						retCode = PARSER_OUTOFMEMORY;
						bBreakOuterLoop = FALSE;
					}

					if ( bBreakOuterLoop == TRUE )
						break;
				}

				if ( bBreakOuterLoop == TRUE )
					break;
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_IMPLEVEL)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_IMP_LEVEL,
											rParsedInfo,
											IDS_E_INVALID_IMP_LEVEL_SYNTAX,
											Level);
			if (retCode == PARSER_CONTINUE)
			{
				if (!rParsedInfo.GetGlblSwitchesObject().
								SetImpersonationLevel(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_IMP_LEVEL);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_AUTHLEVEL)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_AUTH_LEVEL,
											rParsedInfo,
											IDS_E_INVALID_AUTH_LEVEL_SYNTAX,
											AuthLevel);

			if (retCode == PARSER_CONTINUE)
			{
				if (!rParsedInfo.GetGlblSwitchesObject().
							SetAuthenticationLevel(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_AUTH_LEVEL);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_LOCALE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
										IDS_E_INVALID_LOCALE,
										rParsedInfo,
										IDS_E_INVALID_LOCALE_SYNTAX,
										Locale);
			if (retCode == PARSER_CONTINUE)
			{
				if(!rParsedInfo.GetGlblSwitchesObject().SetLocale(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_PRIVILEGES))
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
										IDS_E_INVALID_PRIVILEGES_OPTION,
										rParsedInfo,
										IDS_E_INVALID_PRIVILEGES_SYNTAX,
										Privileges);
			if (retCode == PARSER_CONTINUE)
			{
				if (CompareTokens(*theIterator, CLI_TOKEN_ENABLE))
					 rParsedInfo.GetGlblSwitchesObject().SetPrivileges(TRUE);
				else if (CompareTokens(*theIterator, CLI_TOKEN_DISABLE))
					 rParsedInfo.GetGlblSwitchesObject().SetPrivileges(FALSE);
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_PRIVILEGES_OPTION);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_TRACE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_TRACE_OPTION,
											rParsedInfo,
											IDS_E_INVALID_TRACE_SYNTAX,
											Trace);
			if (retCode == PARSER_CONTINUE)
			{
				if (CompareTokens(*theIterator, CLI_TOKEN_ON)) 
					rParsedInfo.GetGlblSwitchesObject().SetTraceMode(TRUE);
				else if (CompareTokens(*theIterator, CLI_TOKEN_OFF)) 
					rParsedInfo.GetGlblSwitchesObject().SetTraceMode(FALSE);
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_TRACE_OPTION);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_RECORD)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
												IDS_E_INVALID_RECORD_PATH,
												rParsedInfo,
												IDS_E_INVALID_RECORD_SYNTAX,
												RecordPath);
			if (retCode == PARSER_CONTINUE)
			{
				// TRUE for getting output file name.
				_TCHAR* pszOutputFileName = rParsedInfo.
									GetGlblSwitchesObject().
									GetOutputOrAppendFileName(TRUE);

				if ( pszOutputFileName != NULL &&
					 CompareTokens(*theIterator, pszOutputFileName) )
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_RECORD_FILE_ALREADY_OPEN_FOR_OUTPUT);
					retCode = PARSER_ERROR;
					break;
				}

				// FALSE for getting append file name.
				_TCHAR* pszAppendFileName = rParsedInfo.
									GetGlblSwitchesObject().
									GetOutputOrAppendFileName(FALSE);

				if ( pszAppendFileName != NULL &&
					 CompareTokens(*theIterator, pszAppendFileName) )
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_RECORD_FILE_ALREADY_OPEN_FOR_APPEND);
					retCode = PARSER_ERROR;
					break;
				}

				// /record:"" indicates stop logging.
				if (!CompareTokens(*theIterator, CLI_TOKEN_NULL))
				{
					if ( IsValidFile(*theIterator) == FALSE )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
													  IDS_E_INVALID_FILENAME);
						retCode = PARSER_ERROR;
						break;
					}
				}

				if(!rParsedInfo.GetGlblSwitchesObject().
									SetRecordPath(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_INTERACTIVE)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_INTERACTIVE_OPTION,
											rParsedInfo,
											IDS_E_INVALID_INTERACTIVE_SYNTAX,
											Interactive);
			if (retCode == PARSER_CONTINUE)
			{
				if (CompareTokens(*theIterator, CLI_TOKEN_ON))
				{
					if (rParsedInfo.GetGlblSwitchesObject().GetInteractiveStatus())
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_INTERACTIVE_ALREADY_SET);
						
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_INTERACTIVE_SET);
					rParsedInfo.GetGlblSwitchesObject().SetInteractiveMode(TRUE);
						
				}
				else if (CompareTokens(*theIterator, CLI_TOKEN_OFF)) 
				{
					if (!rParsedInfo.GetGlblSwitchesObject().GetInteractiveStatus())
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_INTERACTIVE_ALREADY_RESET);
						
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_INTERACTIVE_RESET);
					rParsedInfo.GetGlblSwitchesObject().SetInteractiveMode(FALSE);
				
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
						IDS_E_INVALID_INTERACTIVE_OPTION);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_FAILFAST))
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
											IDS_E_INVALID_FAILFAST_OPTION,
											rParsedInfo,
											IDS_E_INVALID_FAILFAST_SYNTAX,
											FAILFAST);
			if (retCode == PARSER_CONTINUE)
			{
				if (CompareTokens(*theIterator, CLI_TOKEN_ON))
				{
					if (rParsedInfo.GetGlblSwitchesObject().GetFailFast())
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_FAILFAST_ALREADY_SET);
						
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_FAILFAST_SET);
					rParsedInfo.GetGlblSwitchesObject().SetFailFast(TRUE);
						
				}
				else if (CompareTokens(*theIterator, CLI_TOKEN_OFF)) 
				{
					if (!rParsedInfo.GetGlblSwitchesObject().GetFailFast())
					{
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_FAILFAST_ALREADY_RESET);
						
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
							SetInformationCode(IDS_I_FAILFAST_RESET);
					rParsedInfo.GetGlblSwitchesObject().SetFailFast(FALSE);
				
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
						IDS_E_INVALID_FAILFAST_OPTION);
					retCode = PARSER_ERROR;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_USER)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator, 
												IDS_E_INVALID_USER_ID,
												rParsedInfo,
												IDS_E_INVALID_USER_SYNTAX,
												User);
			if (retCode == PARSER_CONTINUE)
			{
				if(!rParsedInfo.GetGlblSwitchesObject().SetUser(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode = PARSER_OUTOFMEMORY;
					break;
				}

				bUserFlag = TRUE;
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_PASSWORD)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
												IDS_E_INVALID_PASSWORD,
												rParsedInfo,
												IDS_E_INVALID_PASSWORD_SYNTAX,
												Password);
			if (retCode == PARSER_CONTINUE)
			{
				if(!rParsedInfo.GetGlblSwitchesObject().SetPassword(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode=PARSER_OUTOFMEMORY;
					break;
				}

				bPassFlag = TRUE;
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_AUTHORITY)) 
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
												IDS_E_INVALID_AUTHORITY,
												rParsedInfo,
												IDS_E_INVALID_AUTHORITY_SYNTAX,
												Authority);

			if (retCode == PARSER_CONTINUE)
			{
				if(!rParsedInfo.GetGlblSwitchesObject().
									SetAuthorityPrinciple(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
					retCode=PARSER_OUTOFMEMORY;
					break;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_OUTPUT))
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
										IDS_E_INVALID_OUTPUT_OPTION,
										rParsedInfo,
										IDS_E_INVALID_OUTPUT_SYNTAX,
										OUTPUT);
			if (retCode == PARSER_CONTINUE)
			{
				rParsedInfo.GetCmdSwitchesObject().SetOutputSwitchFlag(TRUE);

				if (CompareTokens(*theIterator, CLI_TOKEN_STDOUT))
				{

					// TRUE for setting output file.
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(
																   STDOUT, TRUE);
					rParsedInfo.GetGlblSwitchesObject().
										SetOutputOrAppendFileName(NULL, TRUE);
				}
				else if (CompareTokens(*theIterator, CLI_TOKEN_CLIPBOARD))
				{
					// TRUE for setting output file.
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(
																   CLIPBOARD, TRUE);
					rParsedInfo.GetGlblSwitchesObject().
										SetOutputOrAppendFileName(NULL, TRUE);
				}
				else if ( CompareTokens(*theIterator, CLI_TOKEN_NULL))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												  IDS_E_INVALID_FILENAME);
					retCode = PARSER_ERROR;
					break;
				}
				else
				{
					// FALSE for getting append file name.
					_TCHAR* pszAppendFileName = rParsedInfo.
										GetGlblSwitchesObject().
										GetOutputOrAppendFileName(FALSE);

					if ( pszAppendFileName != NULL &&
						 CompareTokens(*theIterator, pszAppendFileName) )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_OUTPUT_FILE_ALREADY_OPEN_FOR_APPEND);
						retCode = PARSER_ERROR;
						break;
					}

					_TCHAR* pszRecordFileName = rParsedInfo.
										GetGlblSwitchesObject().
										GetRecordPath();

					if ( pszRecordFileName != NULL &&
						 CompareTokens(*theIterator, pszRecordFileName) )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_OUTPUT_FILE_ALREADY_OPEN_FOR_RECORD);
						retCode = PARSER_ERROR;
						break;
					}

					if ( CloseOutputFile() == TRUE ) 
					{
						// TRUE for getting output file name.
						_TCHAR* pszOutputFileName = rParsedInfo.
											GetGlblSwitchesObject().
											GetOutputOrAppendFileName(TRUE);

						if ( pszOutputFileName == NULL ||
							 ( pszOutputFileName != NULL &&
							   !CompareTokens(*theIterator, pszOutputFileName)))
						{
							retCode = IsValidFile(*theIterator);
							if ( retCode == PARSER_ERROR )
							{
								rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
															  IDS_E_INVALID_FILENAME);
								break;
							}
							else if ( retCode == PARSER_ERRMSG )
								break;
						}
					}
					else
					{
						retCode = PARSER_ERRMSG;
						break;
					}
										 
					// TRUE for setting output file.
					if(!rParsedInfo.GetGlblSwitchesObject().
									SetOutputOrAppendFileName(*theIterator, TRUE))
					{
						rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(OUT_OF_MEMORY);
						retCode=PARSER_OUTOFMEMORY;
						break;
					}
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(FILEOUTPUT,
																				TRUE);
					bOpenOutFileInWriteMode = TRUE;
				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_APPEND))
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
										IDS_E_INVALID_APPEND_OPTION,
										rParsedInfo,
										IDS_E_INVALID_APPEND_SYNTAX,
										APPEND);
			if (retCode == PARSER_CONTINUE)
			{
				if ( CompareTokens(*theIterator, CLI_TOKEN_STDOUT) )
				{
					// FALSE for setting append file.
					 rParsedInfo.GetGlblSwitchesObject().
									 SetOutputOrAppendFileName(NULL, FALSE);
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(STDOUT,
																				FALSE);

				}
				else if ( CompareTokens(*theIterator, CLI_TOKEN_CLIPBOARD) )
				{
					// FALSE for setting append file.
					 rParsedInfo.GetGlblSwitchesObject().
									 SetOutputOrAppendFileName(NULL, FALSE);
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(CLIPBOARD,
																				FALSE);
				}
				else if ( CompareTokens(*theIterator, CLI_TOKEN_NULL))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												  IDS_E_INVALID_FILENAME);
					retCode = PARSER_ERROR;
					break;
				}
				else
				{
					// TRUE for getting output file name.
					_TCHAR* pszOutputFileName = rParsedInfo.
										GetGlblSwitchesObject().
										GetOutputOrAppendFileName(TRUE);
					if ( pszOutputFileName != NULL &&
						 CompareTokens(*theIterator, pszOutputFileName) )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_APPEND_FILE_ALREADY_OPEN_FOR_OUTPUT);
						retCode = PARSER_ERROR;
						break;
					}
					
					_TCHAR* pszRecordFileName = rParsedInfo.
										GetGlblSwitchesObject().
										GetRecordPath();

					if ( pszRecordFileName != NULL &&
						 CompareTokens(*theIterator, pszRecordFileName) )
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								   IDS_E_APPEND_FILE_ALREADY_OPEN_FOR_RECORD);
						retCode = PARSER_ERROR;
						break;
					}

					if ( CloseAppendFile() == TRUE )
					{
						// FALSE for getting append file name.
						_TCHAR* pszAppendFileName = rParsedInfo.
											GetGlblSwitchesObject().
											GetOutputOrAppendFileName(FALSE);

						if ( pszAppendFileName == NULL ||
							 ( pszAppendFileName != NULL &&
							   !CompareTokens(*theIterator, pszAppendFileName)))
						{
							retCode = IsValidFile(*theIterator);
							if ( retCode == PARSER_ERROR )
							{
								rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
															  IDS_E_INVALID_FILENAME);
								break;
							}
							else if ( retCode == PARSER_ERRMSG )
								break;
						}
					}
					else
					{
						retCode = PARSER_ERRMSG;
						break;
					}

					// FALSE for setting append file.
					 if (!rParsedInfo.GetGlblSwitchesObject().
							   SetOutputOrAppendFileName(*theIterator, FALSE))
					{
						rParsedInfo.GetCmdSwitchesObject().
												 SetErrataCode(OUT_OF_MEMORY);
						retCode = PARSER_OUTOFMEMORY;
						break;
					}
					rParsedInfo.GetGlblSwitchesObject().SetOutputOrAppendOption(FILEOUTPUT,
																				FALSE);

				}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator,CLI_TOKEN_AGGREGATE))
		{
			retCode = ValidateGlobalSwitchValue(cvTokens, theIterator,
										IDS_E_INVALID_AGGREGATE_OPTION,
										rParsedInfo,
										IDS_E_INVALID_AGGREGATE_SYNTAX,
										Aggregate);
			if(retCode == PARSER_CONTINUE)
			{
				if(CompareTokens(*theIterator, CLI_TOKEN_ON))
					rParsedInfo.GetGlblSwitchesObject().SetAggregateFlag(TRUE);
				else if(CompareTokens(*theIterator, CLI_TOKEN_OFF))
					rParsedInfo.GetGlblSwitchesObject().SetAggregateFlag(FALSE);
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_AGGREGATE_OPTION);
					retCode = PARSER_ERROR;
					break;
					}
			}
			else
				break;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
		{
			retCode = ParseHelp(cvTokens, theIterator, rParsedInfo, TRUE);
			break;
		}
		else 
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												IDS_E_INVALID_GLOBAL_SWITCH);
			retCode = PARSER_ERROR;
			break;
		}

		// Move to next token
		if (!GetNextToken(cvTokens, theIterator))
			// Break the loop if no more tokens are present
			break;
		// Break the loop if no more global switches are present
		if (!IsOption(*theIterator)) 
			break;
	} 

	if ( bUserFlag == TRUE && bPassFlag == FALSE )
		rParsedInfo.GetGlblSwitchesObject().SetAskForPassFlag(TRUE);

	if ( rParsedInfo.GetGlblSwitchesObject().GetPassword() != NULL &&
		 rParsedInfo.GetGlblSwitchesObject().GetUser() == NULL )
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
									IDS_E_PASSWORD_WITHOUT_USER);
		rParsedInfo.GetGlblSwitchesObject().SetPassword(CLI_TOKEN_NULL);
		retCode = PARSER_ERROR;
	}
	
	if ( retCode == PARSER_CONTINUE &&
		 bOpenOutFileInWriteMode == TRUE )
		retCode = ProcessOutputAndAppendFiles(rParsedInfo, retCode, TRUE);

	return retCode;
}
/*----------------------------------------------------------------------------
   Name				 :ParseGETSwitches
   Synopsis	         :This function does the parsing and interprets if command
					  has GET as the verb. It parses the remaining tokens 
					  following and updates the same in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseGETSwitches(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseGETSwitches(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator,
										CParsedInfo& rParsedInfo)
{
	RETCODE		retCode		= PARSER_EXECCOMMAND;
	BOOL		bContinue	= TRUE;

	while ( retCode == PARSER_EXECCOMMAND )
	{
		// Check for the presence of VALUE switch
		if (CompareTokens(*theIterator, CLI_TOKEN_VALUE)) 
		{
			rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();
			if ( FALSE == FrameFileAndAddToXSLTDetVector	(
																XSL_FORMAT_TEXTVALUE,
																CLI_TOKEN_VALUE,
																rParsedInfo
															)
			   )
			{
				retCode = PARSER_ERRMSG;
			}
		}
		// Check for the presence of ALL switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_ALL)) 
		{	
			rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();
			if ( FALSE == FrameFileAndAddToXSLTDetVector	(
																XSL_FORMAT_TABLE,
																CLI_TOKEN_TABLE,
																rParsedInfo
															)
			   )
			{
				retCode = PARSER_ERRMSG;
			}
		}
		// Check for the presence of FORMAT switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_FORMAT)) 
		{
			rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();
			retCode = ParseFORMATSwitch(cvTokens, theIterator, rParsedInfo);
		}
		// Check for the presence of EVERY switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_EVERY)) 
		{
			retCode = ParseEVERYSwitch(cvTokens, theIterator, rParsedInfo);
		}
		// Check for the presence of TRANSLATE switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_TRANSLATE)) 
		{
			retCode = ParseTRANSLATESwitch(cvTokens, theIterator, rParsedInfo);
		}
		// Check whether /REPEAT follows /EVERY
		else if (CompareTokens(*theIterator, CLI_TOKEN_REPEAT))
		{
			if (!CompareTokens(*(theIterator-4), CLI_TOKEN_EVERY))
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_I_REPEAT_EVERY_RELATED);
				retCode = PARSER_ERROR;
				break;
			}
		} 
		// Check for the presence of HELP switch
		else if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
		{
			rParsedInfo.GetHelpInfoObject().SetHelp(GETSwitchesOnly, TRUE);
			retCode = ParseHelp(cvTokens, theIterator, GETVerb, rParsedInfo);
			if ( retCode == PARSER_DISPHELP )
			{
				if (m_bAliasName)
				{
					if (FAILED(m_CmdAlias.
							ObtainAliasPropDetails(rParsedInfo)))
								retCode = PARSER_ERRMSG;
				}
				else
				{
					ObtainClassProperties(rParsedInfo);
				}
			}
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_INVALID_GET_SWITCH);
			retCode = PARSER_ERROR;
			break;
		}

		if ( retCode == PARSER_EXECCOMMAND )
		{
			if ( !GetNextToken(cvTokens, theIterator) )
				break;
			
			if ( !IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
													IDS_E_INVALID_COMMAND);
				retCode = PARSER_ERROR;
				break;
			}

			if ( !GetNextToken(cvTokens, theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_GET_SWITCH);
				retCode = PARSER_ERROR;
				break;
			}
		}
	}

	return retCode;
}
/*----------------------------------------------------------------------------
   Name				 :ParseLISTSwitches
   Synopsis	         :This function does the parsing and interprets if command
					  has LIST as the verb. It parses the remaining tokens 
					  following and updates the same in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseLISTSwitches(cvTokens,theIterator,rParsedInfo,
										bFormatSwitchSpecified)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseLISTSwitches(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator,
										CParsedInfo& rParsedInfo,
										BOOL& bFormatSwitchSpecified)
{
	RETCODE retCode = PARSER_EXECCOMMAND;
	bFormatSwitchSpecified = FALSE;

	while ( retCode == PARSER_EXECCOMMAND )
	{
		if (CompareTokens(*theIterator, CLI_TOKEN_TRANSLATE)) 
		{
			retCode = ParseTRANSLATESwitch(cvTokens, theIterator, rParsedInfo);
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_EVERY)) 
		{
			retCode = ParseEVERYSwitch(cvTokens, theIterator, rParsedInfo);
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_FORMAT)) 
		{
			retCode = ParseFORMATSwitch(cvTokens, theIterator, rParsedInfo);
			bFormatSwitchSpecified = TRUE;
		}
		// Check whether /REPEAT follows /EVERY
		else if (CompareTokens(*theIterator, CLI_TOKEN_REPEAT))
		{
			if (!CompareTokens(*(theIterator-4), CLI_TOKEN_EVERY))
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_I_REPEAT_EVERY_RELATED);
				retCode = PARSER_ERROR;
				break;
			}
		} 
		else if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
		{
			rParsedInfo.GetHelpInfoObject().SetHelp(LISTSwitchesOnly, TRUE);
			retCode = ParseHelp(cvTokens, theIterator, LISTVerb, rParsedInfo);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_INVALID_LIST_SWITCH);
			retCode = PARSER_ERROR;
			break;
		}

		if ( retCode == PARSER_EXECCOMMAND )
		{
			if ( !GetNextToken(cvTokens, theIterator) )
				break;
			
			if ( !IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
													IDS_E_INVALID_COMMAND);
				retCode = PARSER_ERROR;
				break;
			}

			if ( !GetNextToken(cvTokens, theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_LIST_SWITCH);
				retCode = PARSER_ERROR;
				break;
			}
		}
	}

	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseSETorCREATEOrNamedParamInfo
   Synopsis	         :This function does the parsing and interprets if command
					  has SET as the verb. It parses the remaining tokens 
					  following and updates the same in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output parameters :
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseSETorCREATEOrNamedParamInfo(cvTokens,theIterator,rParsedInfo, helpType)
   Notes             :None
-------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseSETorCREATEOrNamedParamInfo(CHARVECTOR& cvTokens,
										  CHARVECTOR::iterator& theIterator,
										  CParsedInfo& rParsedInfo, 
										  HELPTYPE helpType)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	_TCHAR *pszProp,*pszVal;

	try
	{
		// Process the SET|CREATE verb related info i.e properties with new values.
		while (TRUE) 
		{
			pszProp = NULL;
			pszVal	= NULL;

			// Tokenize the expression checking for '='
			pszProp = *theIterator;
			if ( GetNextToken(cvTokens, theIterator) &&
				 CompareTokens(*theIterator, CLI_TOKEN_EQUALTO) &&
				 GetNextToken(cvTokens, theIterator))
				 pszVal	= *theIterator;

			if ((pszProp == NULL) || (pszVal == NULL))
			{
				if ( helpType != CALLVerb &&
					 IsOption(*(theIterator+1)) &&
					 theIterator + 2 < cvTokens.end() &&
					 CompareTokens(*(theIterator+2), CLI_TOKEN_HELP) )
				{
					theIterator++;
					theIterator++;
					retCode = ParseHelp(cvTokens, theIterator, helpType, rParsedInfo);

					if (retCode == PARSER_DISPHELP)
					{
						// Adding to PropertyList only for use in displaying help of 
						// properties
						if(!rParsedInfo.GetCmdSwitchesObject().
												AddToPropertyList(pszProp))
						{
							rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_ADD_TO_PROP_LIST_FAILURE);
							retCode = PARSER_ERROR;
							break;
						}

						if (m_bAliasName)
						{
							if (FAILED(m_CmdAlias.
									ObtainAliasPropDetails(rParsedInfo)))
										retCode = PARSER_ERRMSG;
						}
						else
						{
							ObtainClassProperties(rParsedInfo);
						}
					}
				}
				else
				{
					UINT nErrID;
					if ( helpType == CALLVerb )
						nErrID = IDS_E_INVALID_NAMED_PARAM_LIST;
					else
						nErrID = IDS_E_INVALID_ASSIGNLIST;
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(nErrID);
					retCode = PARSER_ERROR;
				}

				break;
			}

			// Unquote the strings
			UnQuoteString(pszProp);
			UnQuoteString(pszVal);
			
			// Add to the list of parameters
			if(!rParsedInfo.GetCmdSwitchesObject().
					AddToParameterMap(_bstr_t(pszProp), _bstr_t(pszVal)))
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
									IDS_E_ADD_TO_PARAM_MAP_FAILURE);
				retCode = PARSER_ERROR;
				break;
			}

			// Adding to PropertyList only for use in displaying help of 
			// properties
			if(!rParsedInfo.GetCmdSwitchesObject().
									AddToPropertyList(pszProp))
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
							IDS_E_ADD_TO_PROP_LIST_FAILURE);
				retCode = PARSER_ERROR;
				break;
			}

			// Get the next token
			if (GetNextToken(cvTokens, theIterator))
			{
				// If option (i.e either '/' or '-') specified.
				if (IsOption(*theIterator))
				{
					theIterator--;
					break;
				}
				else
				{
					if ( helpType != CALLVerb )
					{
						// check for the presence of ','
						if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
						{
							if (!GetNextToken(cvTokens, theIterator))
							{
								rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_INVALID_ASSIGNLIST);
								retCode = PARSER_ERROR;
								break;
							}
						}
						else
						{
							rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_INVALID_ASSIGNLIST);
							retCode = PARSER_ERROR;
							break;
						}
					}
				}
			}
			else
			{
				retCode = PARSER_EXECCOMMAND;
				break;
			}
		}
	}
	catch(_com_error& e)
	{
		retCode = PARSER_ERROR;
		_com_issue_error(e.Error());
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseVerbSwitches
   Synopsis	         :This function does the parsing and interprets if command
					  has verb switches specified. It parses the remaining 
					  tokens following and updates the same in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseVerbSwitches(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseVerbSwitches(CHARVECTOR& cvTokens, 
										CHARVECTOR::iterator& theIterator,
										CParsedInfo& rParsedInfo)
{
	RETCODE retCode			= PARSER_EXECCOMMAND;
	BOOL bInvalidVerbSwitch = FALSE;

	// Check for the '/' | '-' token
	if (IsOption(*theIterator))
	{
		// Move to next token
		if (!GetNextToken(cvTokens, theIterator))	
			bInvalidVerbSwitch = TRUE;
		else if (CompareTokens(*theIterator, CLI_TOKEN_INTERACTIVE)) 
		{

			rParsedInfo.GetCmdSwitchesObject().
							SetInteractiveMode(INTERACTIVE);

			_TCHAR *pszVerbName = rParsedInfo.GetCmdSwitchesObject().
																GetVerbName(); 
			BOOL bInstanceLevel = TRUE;

			if(CompareTokens(pszVerbName, CLI_TOKEN_CALL) 
				|| CompareTokens(pszVerbName, CLI_TOKEN_SET)
				|| CompareTokens(pszVerbName, CLI_TOKEN_DELETE))
			{
				if(IsClassOperation(rParsedInfo))
				{
					bInstanceLevel = FALSE;
				}
				else
				{
					if(CompareTokens(pszVerbName, CLI_TOKEN_CALL))
					{
						if ( rParsedInfo.GetCmdSwitchesObject().
											GetAliasName() != NULL )
						{
							if (rParsedInfo.GetCmdSwitchesObject().
											GetWhereExpression() == NULL)
							{
								bInstanceLevel = FALSE;
							}
							else
								bInstanceLevel = TRUE;
						}
						else
						{
							if ((rParsedInfo.GetCmdSwitchesObject().
											GetPathExpression() != NULL)
								&& (rParsedInfo.GetCmdSwitchesObject().
											GetWhereExpression() == NULL))
							{
								bInstanceLevel = FALSE;
							}
							else
								bInstanceLevel = TRUE;
						}
					}
					else
						bInstanceLevel = TRUE;
				}
			}
			else
				retCode = PARSER_EXECCOMMAND;

			if(bInstanceLevel)
			{
				retCode = ParseVerbInteractive(	cvTokens, theIterator, 
												rParsedInfo, bInvalidVerbSwitch);
			}
			else
				retCode = PARSER_EXECCOMMAND;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_NONINTERACT)) 
		{
			rParsedInfo.GetCmdSwitchesObject().
							SetInteractiveMode(NOINTERACTIVE);
			retCode = PARSER_EXECCOMMAND;
		}
		else if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
		{
			retCode = ParseHelp(cvTokens, theIterator, VERBSWITCHES, 
								rParsedInfo);
		}
		else
			bInvalidVerbSwitch = TRUE;

		if ( GetNextToken(cvTokens, theIterator ) )
		{
			rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(IDS_E_INVALID_COMMAND);
			retCode = PARSER_ERROR;
		}

	}
	else
		bInvalidVerbSwitch = TRUE;

	if ( bInvalidVerbSwitch == TRUE )
	{
		// no valid <verb switch> type is specified.
		rParsedInfo.GetCmdSwitchesObject().
				SetErrataCode(IDS_E_INVALID_VERB_SWITCH);
		retCode = PARSER_ERROR;
	}

	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :GetNextToken
   Synopsis	         :This function retrieves the next token from the token 
					  vector list, returns FALSE if no more tokens are present
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetNextToken(cvTokens,theIterator)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::GetNextToken(CHARVECTOR& cvTokens, 
								 CHARVECTOR::iterator& theIterator)
{
	theIterator++;
	return (theIterator >= cvTokens.end()) ? FALSE : TRUE;
}

/*----------------------------------------------------------------------------
   Name				 :ParsePWhereExpr
   Synopsis	         :This function does the parsing and interprets if command
					  has Path and Where expression It parses the remaining
					  tokens following and updates the same in CParsedInfo.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ParsePWhereExpr(cvTokens,theIterator,rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::ParsePWhereExpr(CHARVECTOR& cvTokens,
								   CHARVECTOR::iterator& theIterator,
								   CParsedInfo& rParsedInfo,
								   BOOL bIsParan)
{
	BOOL bRet = TRUE, bContinue = FALSE;

	try
	{		
		while (TRUE)
		{
			if ( bIsParan == TRUE &&
				CompareTokens(*theIterator, CLI_TOKEN_RIGHT_PARAN) )
				break;

			if ( bIsParan == FALSE && 
				 IsStdVerbOrUserDefVerb(*theIterator, rParsedInfo) )
				 break;

			if ( bIsParan == FALSE ||
				 !CompareTokens(*theIterator, CLI_TOKEN_LEFT_PARAN))
			{
				if(!rParsedInfo.GetCmdSwitchesObject().
					AddToPWhereParamsList(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_ADD_TO_PARAMS_LIST_FAILURE);
					bRet = FALSE;
					break;
				}
				bContinue = TRUE;
			}

			if (!GetNextToken(cvTokens, theIterator))
				break;

			if ( IsOption(*theIterator) )
			{
				bContinue = FALSE;
				break;
			}
		}

		if(bRet != FALSE && bContinue == TRUE)
		{

			CHARVECTOR theParam = rParsedInfo.GetCmdSwitchesObject().
																GetPWhereParamsList();
			CHARVECTOR::iterator theItr		= theParam.begin();
			_TCHAR pszPWhere[MAX_BUFFER]	= NULL_STRING;
			lstrcpy(pszPWhere, CLI_TOKEN_NULL);
			_TCHAR* pszToken				= NULL;;
			CHString sTemp;
			
			if ((rParsedInfo.GetCmdSwitchesObject().GetPWhereExpr() != NULL)) 
			{
				sTemp.Format(rParsedInfo.GetCmdSwitchesObject().
												GetPWhereExpr());
				sTemp.TrimLeft();
				if(!sTemp.IsEmpty())
				{

					_bstr_t bstrPWhere = _bstr_t(rParsedInfo.
												GetCmdSwitchesObject().
												GetPWhereExpr());
					pszToken = _tcstok((WCHAR*)bstrPWhere, 
										CLI_TOKEN_HASH);
					lstrcpy(pszPWhere, CLI_TOKEN_NULL);

					while (pszToken != NULL)
					{
						lstrcat(pszPWhere, pszToken);
						if (theItr != theParam.end())
						{
						   lstrcat(pszPWhere, *theItr);
						   theItr++;
						}
						pszToken = _tcstok(NULL, CLI_TOKEN_HASH);
					}

					if(bRet != FALSE)
					{
						// Set the classpath and where expression
						pszToken = NULL;
						pszToken = _tcstok(pszPWhere, CLI_TOKEN_SPACE);
						if (pszToken != NULL)
						{
							if (CompareTokens(CLI_TOKEN_FROM, pszToken)) 
							{
								pszToken = _tcstok(NULL, CLI_TOKEN_SPACE);
								if (pszToken != NULL)
								{
									if(!rParsedInfo.GetCmdSwitchesObject().
													SetClassPath(pszToken))
									{
										rParsedInfo.GetCmdSwitchesObject().
												SetErrataCode(OUT_OF_MEMORY);
										bRet = FALSE;
									}

								}
								if(bRet != FALSE)
									pszToken = _tcstok(NULL, CLI_TOKEN_SPACE);
							}
							
							if (CompareTokens(CLI_TOKEN_WHERE, pszToken)) 
							{
								pszToken = _tcstok(NULL, CLI_TOKEN_NULL);
								if (pszToken != NULL)
								{
									if(!rParsedInfo.GetCmdSwitchesObject().
											SetWhereExpression(pszToken))
									{
										rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(OUT_OF_MEMORY);
										bRet = FALSE;
									}
								}
							}
						}
					}
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(IDS_E_PWHERE_UNDEF);
					bRet = FALSE;
				}
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(IDS_E_PWHERE_UNDEF);
				bRet = FALSE;
			}
		}
		if (!bContinue && bIsParan)
		{
			rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_PWHERE_EXPR);
			bRet = FALSE;
		}
	}
	catch(_com_error& e)
	{
		bRet = FALSE;
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		bRet = FALSE;
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ExtractClassNameandWhereExpr
   Synopsis	         :This function takes the input as a path expression and 
					  extracts the Class and Where expression part from the 
					  path expression.
   Type	             :Member Function
   Input Parameter(s):
		pszPathExpr  - the path expression
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ParsePWhereExpr(cvTokens,theIterator)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::ExtractClassNameandWhereExpr(_TCHAR* pszPathExpr, 
												 CParsedInfo& rParsedInfo)
{
	// Frame the class name and where expression based on the object path
	BOOL	bRet					= TRUE;
	_TCHAR* pszToken				= NULL;
	BOOL	bFirst					= TRUE;
	_TCHAR  pszWhere[MAX_BUFFER]	= NULL_STRING;	
	lstrcpy(pszWhere, CLI_TOKEN_NULL);

	if (pszPathExpr == NULL)
		bRet = FALSE;

	try
	{
		if ( bRet == TRUE )
		{
			lstrcpy(pszWhere, CLI_TOKEN_NULL);
			pszToken = _tcstok(pszPathExpr, CLI_TOKEN_DOT);
			if (pszToken != NULL)
			{
				if(!rParsedInfo.GetCmdSwitchesObject().SetClassPath(pszToken))
				{
					rParsedInfo.GetCmdSwitchesObject().
									SetErrataCode(OUT_OF_MEMORY);
					bRet = FALSE;
				}
			}

			if(bRet != FALSE)
			{
				while (pszToken != NULL)
				{
					pszToken = _tcstok(NULL, CLI_TOKEN_COMMA); 
					if (pszToken != NULL)
					{
						if (!bFirst)
							lstrcat(pszWhere, CLI_TOKEN_AND);
						lstrcat(pszWhere, pszToken);
						bFirst = FALSE;
					}
					else
						break;
				}
				if (lstrlen(pszWhere))
				{
					if(!rParsedInfo.GetCmdSwitchesObject().SetWhereExpression(pszWhere))
					{
						rParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(OUT_OF_MEMORY);
						bRet = FALSE;
					}
				}
			}
		}
	}
	catch(...)
	{
		rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_PATH);
		bRet = FALSE;
	}
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :GetNextToken
   Synopsis	         :This function retrieves the next token from the token 
					  vector list, returns enumerated return code depending 
					  upon the context.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
		helpType     - enumerated help type 
		uErrataCode  - error string ID.
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :GetNextToken(cvTokens, theIterator,
								 rParsedInfo, helpType, uErrataCode)
   Notes             :overloaded function
----------------------------------------------------------------------------*/
RETCODE CParserEngine::GetNextToken(CHARVECTOR& cvTokens, 
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo,
									HELPTYPE helpType,
									UINT uErrataCode)
{
	RETCODE retCode = PARSER_CONTINUE;

	// Move to next token
	theIterator++;

	// If no more tokens are present
	if (theIterator >= cvTokens.end()) 
	{
		// If interactive mode is set
		if (rParsedInfo.GetGlblSwitchesObject().GetInteractiveStatus())
		{
			rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(TRUE);
			rParsedInfo.GetHelpInfoObject().SetHelp(helpType, TRUE);
			retCode = PARSER_DISPHELP;
		}
		else
		{
			// PARSER_ERROR if no more tokens are present. 
			rParsedInfo.GetCmdSwitchesObject().
				SetErrataCode(uErrataCode);
			retCode = PARSER_ERROR;
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :GetNextToken
   Synopsis	         :This function retrieves the next token from the token 
					  vector list, returns enumerated return code depending 
					  upon the context.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
		uErrataCode  - error string ID.
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :GetNextToken(cvTokens, theIterator,
								   rParsedInfo, uErrataCode)
   Notes             :overloaded function
----------------------------------------------------------------------------*/
RETCODE CParserEngine::GetNextToken(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo, 
									UINT uErrataCode)
{
	RETCODE retCode = PARSER_CONTINUE;
	
	// Move to next token
	theIterator++;

	// If no more tokens are present
	if (theIterator >= cvTokens.end()) 
	{
		// PARSER_ERROR if no more tokens are present 
		rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(uErrataCode);
		retCode = PARSER_ERROR;
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :IsHelp
   Synopsis	         :This function retrieves the next token from the token 
					  vector list, checks if it is '?' and returns enumerated 
					  return code depending upon the context.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
		helpType	 - enumerated help type
		uErrataCode  - error string ID.
		tokenLevel	 - token level 
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :IsHelp(cvTokens, theIterator, rParsedInfo,
			  		    helpType, uErrataCode, tokenLevel)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::IsHelp(CHARVECTOR& cvTokens, 
							CHARVECTOR::iterator& theIterator,
							CParsedInfo& rParsedInfo,
			  				HELPTYPE helpType,
							UINT uErrataCode,
							TOKENLEVEL tokenLevel)
{
	BOOL	bContinue	= TRUE;
	RETCODE retCode		= PARSER_CONTINUE;
	// Move to next token
	if (!GetNextToken(cvTokens, theIterator))	
	{
		// Set the retCode as PARSER_ERROR if no more tokens are present. 
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(uErrataCode);
		retCode = PARSER_ERROR;
	}
	else
	{
		// Is '?' 
		if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
			retCode = ParseHelp(cvTokens, theIterator, helpType, rParsedInfo);
		else
		{
			// If LEVEL_ONE token then only allowed is /?, other
			// switches are invalid.
			if (tokenLevel == LEVEL_ONE)
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(uErrataCode);
				retCode =  PARSER_ERROR;
			}
			else
				retCode = PARSER_CONTINUE;
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseHelp
   Synopsis	         :This function takes care of identifying the appropriate
					  help informtion to be displayed using the HELPTYPE 
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object
		bGlobalHelp	 - global help flag
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE 
   Global Variables  :None
   Calling Syntax    :ParseHelp(cvTokens, theIterator, rParsedInfo)
   Notes             :overloaded fucntion
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseHelp(CHARVECTOR& cvTokens, 
								CHARVECTOR::iterator& theIterator,
								CParsedInfo& rParsedInfo,
								BOOL bGlobalHelp)
{
	BOOL	bContinue	= TRUE;
	RETCODE retCode		= PARSER_CONTINUE;

	// Move to next token (if no more tokens are present)
	if (!GetNextToken(cvTokens, theIterator))
	{
		retCode = PARSER_DISPHELP;
		rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(TRUE);
		// Check for "/?" 
		if (((theIterator - 2) == cvTokens.begin()) || bGlobalHelp) 
		{
			rParsedInfo.GetHelpInfoObject().SetHelp(GlblAllInfo, TRUE);
			if(SUCCEEDED(m_CmdAlias.ConnectToAlias(rParsedInfo,m_pIWbemLocator)))
			{
				if(FAILED(m_CmdAlias.ObtainAliasFriendlyNames(rParsedInfo)))
					retCode = PARSER_ERRMSG;
			}
			else
				rParsedInfo.GetCmdSwitchesObject().FreeCOMError();

		}
	}
	// Check for the presence of the ':"
	else if (CompareTokens(*theIterator, CLI_TOKEN_COLON)) 
	{
		// Move to next token
		if (!GetNextToken(cvTokens, theIterator, rParsedInfo,
					IDS_E_INVALID_HELP_OPTION))
		// Set the retCode to PARSER_ERROR if no more tokens are specified.
		{
			retCode = PARSER_ERROR;
		}
		else
		{
			if (CompareTokens(*theIterator, CLI_TOKEN_BRIEF)) 
				rParsedInfo.GetGlblSwitchesObject().SetHelpOption(HELPBRIEF);
			else if (CompareTokens(*theIterator, CLI_TOKEN_FULL)) 
				rParsedInfo.GetGlblSwitchesObject().SetHelpOption(HELPFULL);
			else
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												 IDS_E_INVALID_HELP_OPTION);
				retCode = PARSER_ERROR;
			}

			if ( retCode != PARSER_ERROR )
			{
				if ( GetNextToken(cvTokens, theIterator) )
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												 IDS_E_INVALID_COMMAND);
					retCode = PARSER_ERROR;
				}
				else
				{
					retCode = PARSER_DISPHELP;
					rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(TRUE);
					// Check for "/?:(BRIEF|FULL)
					if (((theIterator - 3) == cvTokens.begin()) || bGlobalHelp) 
					{
						rParsedInfo.GetHelpInfoObject().
											SetHelp(GlblAllInfo, TRUE);
						if(SUCCEEDED(m_CmdAlias.ConnectToAlias
									(rParsedInfo,m_pIWbemLocator)))
						{
							if(FAILED(m_CmdAlias.ObtainAliasFriendlyNames
									(rParsedInfo)))
							{
								retCode = PARSER_ERRMSG;
							}
						}
						else
							rParsedInfo.GetCmdSwitchesObject().FreeCOMError();
					}
				}
			}	
		}
	}
	else
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												   IDS_E_INVALID_COMMAND);
		retCode = PARSER_ERROR;
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseHelp
   Synopsis	         :This function takes care of identifying the appropriate
					  help informtion to be displayed using the HELPTYPE 
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
		htHelp		 - help type
		rParsedInfo  - reference to CParsedInfo class object
		bGlobalHelp	 - global help flag
   Output Parameter(s):
		rParsedInfo  - ref. to CParsedInfo object
   Return Type       :RETCODE 
   Global Variables  :None
   Calling Syntax    :ParseHelp(cvTokens, theIterator, htHelp,
									rParsedInfo)
   Notes             :overloaded fucntion
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseHelp(CHARVECTOR& cvTokens, 
								CHARVECTOR::iterator& theIterator,
								HELPTYPE htHelp,
								CParsedInfo& rParsedInfo,
								BOOL bGlobalHelp)
{
	rParsedInfo.GetHelpInfoObject().SetHelp(htHelp, TRUE);
	return ParseHelp(cvTokens, theIterator, rParsedInfo, bGlobalHelp);
}

/*----------------------------------------------------------------------------
   Name				 :ObtainClassProperties
   Synopsis	         :This function obtains the information about the 
					   available properties for a given WMI class
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ObtainClassProperties(rParsedInfo)
   Notes             :If bCheckWritePropsAvail == TRUE then functions checks for 
					  availibilty of properties.
----------------------------------------------------------------------------*/
BOOL CParserEngine::ObtainClassProperties(CParsedInfo& rParsedInfo,
										  BOOL bCheckWritePropsAvail)
{
	HRESULT				hr					= S_OK;
	IWbemClassObject*	pIObject			= NULL;
    SAFEARRAY*			psaNames			= NULL;
	BSTR				bstrPropName		= NULL;
	BOOL				bRet				= TRUE;
	BOOL				bTrace				= FALSE;
	CHString			chsMsg;
	ERRLOGOPT			eloErrLogOpt		= NO_LOGGING;
	DWORD				dwThreadId			= GetCurrentThreadId();
	BOOL				bSetVerb			= FALSE;
	BOOL				bPropsAvail			= FALSE;

	if (rParsedInfo.GetCmdSwitchesObject().GetVerbName() != NULL)
	{
		if (CompareTokens(rParsedInfo.GetCmdSwitchesObject().GetVerbName(), 
						CLI_TOKEN_SET))
		{
			bSetVerb = TRUE;
		}
	}
	
	// Obtain the trace flag status
	bTrace = rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

	eloErrLogOpt = rParsedInfo.GetErrorLogObject().GetErrLogOption();

    hr = ConnectToNamespace(rParsedInfo);

	if (SUCCEEDED(hr))
	{
		
		CHARVECTOR cvPropList;  
		BOOL bPropList = FALSE;
		
		try
		{
			cvPropList = rParsedInfo.GetCmdSwitchesObject().GetPropertyList();
			if ( cvPropList.size() != 0 )
				bPropList = TRUE;

			hr = m_pITargetNS->GetObject(_bstr_t(rParsedInfo.
								GetCmdSwitchesObject().GetClassPath()),
								WBEM_FLAG_USE_AMENDED_QUALIFIERS,	
								NULL,   &pIObject, NULL);
			if (bTrace || eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", "
						L"WBEM_FLAG_USE_AMENDED_QUALIFIERS, 0, NULL, -, -)", 
						(rParsedInfo.GetCmdSwitchesObject().GetClassPath())?
							rParsedInfo.GetCmdSwitchesObject().GetClassPath():L"<NULL>");		
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId,
						rParsedInfo, bTrace);
			}
			ONFAILTHROWERROR(hr);

			hr = pIObject->GetNames(NULL, WBEM_FLAG_ALWAYS | 
							WBEM_FLAG_NONSYSTEM_ONLY, NULL, &psaNames);
			if (bTrace || eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::GetNames(NULL, "
							L"WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, "
							L"NULL, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
						rParsedInfo, bTrace);
			}	
			ONFAILTHROWERROR(hr);

			// Get the number of properties.
			LONG lLower = 0, lUpper = 0; 
			hr = SafeArrayGetLBound(psaNames, 1, &lLower);
			if ( eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
					rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(psaNames, 1, &lUpper);
			if ( eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
					rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);


			// For each property obtain the information of our interest
			for (LONG lVar = lLower; lVar <= lUpper; lVar++) 
			{
				// Get the property.
				hr = SafeArrayGetElement(psaNames, &lVar, &bstrPropName);
				if ( eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				CHARVECTOR::iterator tempIterator;
				if ( bPropList == TRUE && !Find(cvPropList, 
										_bstr_t(bstrPropName),
										tempIterator))
				{
					SAFEBSTRFREE(bstrPropName);
					continue;
				}

				PROPERTYDETAILS pdPropDet;
				hr = GetPropertyAttributes(pIObject, bstrPropName, 
					pdPropDet, 
					rParsedInfo.GetGlblSwitchesObject().GetTraceStatus());
				ONFAILTHROWERROR(hr);

				if (bSetVerb == TRUE || bCheckWritePropsAvail == TRUE)
				{
					if ( !_tcsstr((_TCHAR*)pdPropDet.Operation, CLI_TOKEN_WRITE) )
					{
						SAFEBSTRFREE(bstrPropName);
						continue;
					}
				}
				
				if ( bCheckWritePropsAvail == TRUE )
				{
					bPropsAvail = TRUE;
					SAFEBSTRFREE(bstrPropName);
					break;
				}

				pdPropDet.Derivation = bstrPropName;
				if(!rParsedInfo.GetCmdSwitchesObject().AddToPropDetMap(
													bstrPropName, pdPropDet))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_ADD_TO_PROP_DET_MAP_FAILURE);
					bRet = FALSE;
				}
				SAFEBSTRFREE(bstrPropName);
			}
			SAFEIRELEASE(pIObject);
			SAFEADESTROY(psaNames);
			SAFEBSTRFREE(bstrPropName);
		}
		catch(_com_error& e)
		{
			bRet = FALSE;
			SAFEIRELEASE(pIObject);
			SAFEADESTROY(psaNames);
			SAFEBSTRFREE(bstrPropName);
			_com_issue_error(e.Error());
		}
		catch(CHeap_Exception)
		{
			bRet = FALSE;
			SAFEIRELEASE(pIObject);
			SAFEADESTROY(psaNames);
			SAFEBSTRFREE(bstrPropName);
			_com_issue_error(WBEM_E_OUT_OF_MEMORY);
		}
	}
	else
		bRet = FALSE;

	if ( bCheckWritePropsAvail == TRUE )
    {
        if(FAILED(hr)) throw MULTIPLENODE_ERROR;
		bRet = bPropsAvail;
    }

	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainClassMethods
   Synopsis	         :This function obtains the information about the 
					  available methods for a given WMI class
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - ref. to CParsedInfo object
   Output Parameter(s):
		rParsedInfo  - ref. to CParsedInfo object
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ObtainClassMethods(rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
BOOL CParserEngine::ObtainClassMethods(CParsedInfo& rParsedInfo, 
									   BOOL bCheckForExists)
{
	BOOL			bRet				= TRUE;
	BOOL			bTrace				= FALSE;
	CHString		chsMsg;
	ERRLOGOPT		eloErrLogOpt		= NO_LOGGING;
	DWORD			dwThreadId			= GetCurrentThreadId();
	BOOL			bMethAvail			= FALSE;
	_TCHAR*			pMethodName			= NULL;
    HRESULT         hr                  = S_OK;
	
	bTrace	= rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();
	eloErrLogOpt = rParsedInfo.GetErrorLogObject().GetErrLogOption();

    hr = ConnectToNamespace(rParsedInfo);

	if (SUCCEEDED(hr))
	{
		HRESULT				hr				= S_OK;
		IWbemClassObject *pIObject = NULL,*pIInSign = NULL,*pIOutSign = NULL;
		BSTR				bstrMethodName	= NULL;

		try
		{
			hr = m_pITargetNS->GetObject(_bstr_t(rParsedInfo.
								GetCmdSwitchesObject().GetClassPath()),
								WBEM_FLAG_USE_AMENDED_QUALIFIERS,	
								NULL,   &pIObject, NULL);

			if ( eloErrLogOpt )
			{
				chsMsg.Format(L"IWbemServices::GetObject(L\"%s\", "
						L"WBEM_FLAG_USE_AMENDED_QUALIFIERS, 0, NULL, -, -)", 
						rParsedInfo.GetCmdSwitchesObject().GetClassPath());		
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
					rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			// Begin an enumeration of the methods available for the object.
			hr = pIObject->BeginMethodEnumeration(0);
			if ( eloErrLogOpt )
			{
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
					_T("BeginMethodEnumeration(0)"),
					dwThreadId, rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);


			//To get info about only method if method is specified
			pMethodName = rParsedInfo.GetCmdSwitchesObject().
															  GetMethodName();
			// Retrieve the next method in the method enumeration 
			// sequence 
			while ((pIObject->NextMethod(0, &bstrMethodName, &pIInSign, 
										 &pIOutSign)) != WBEM_S_NO_MORE_DATA)
			{
				if ( bCheckForExists == TRUE )
				{
					bMethAvail	= TRUE;
					SAFEBSTRFREE(bstrMethodName);
					SAFEIRELEASE(pIInSign);
					SAFEIRELEASE(pIOutSign);
					break;
				}

				if(pMethodName != NULL && 
					!CompareTokens(pMethodName, (_TCHAR*)bstrMethodName))
				{
					SAFEBSTRFREE(bstrMethodName);
					SAFEIRELEASE(pIInSign);
					SAFEIRELEASE(pIOutSign);
					continue;
				}
				METHODDETAILS mdMethDet;
				if (pIInSign)
					hr = ObtainMethodParamInfo(pIInSign, mdMethDet, INP,
						rParsedInfo.GetGlblSwitchesObject().GetTraceStatus(), 
						rParsedInfo);
				ONFAILTHROWERROR(hr);

				if (pIOutSign)
					hr = ObtainMethodParamInfo(pIOutSign, mdMethDet, OUTP,
						rParsedInfo.GetGlblSwitchesObject().GetTraceStatus(),
						rParsedInfo);
				ONFAILTHROWERROR(hr);

				_bstr_t bstrStatus, bstrDesc;
				hr = GetMethodStatusAndDesc(pIObject, 
						bstrMethodName, bstrStatus, bstrDesc,
						rParsedInfo.GetGlblSwitchesObject().GetTraceStatus());
					mdMethDet.Status = _bstr_t(bstrStatus);
					mdMethDet.Description = _bstr_t(bstrDesc);
				ONFAILTHROWERROR(hr);

				
				if(!rParsedInfo.GetCmdSwitchesObject().AddToMethDetMap(
									 _bstr_t(bstrMethodName),mdMethDet))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
									IDS_E_ADD_TO_METH_DET_MAP_FAILURE);
					SAFEBSTRFREE(bstrMethodName);
					SAFEIRELEASE(pIInSign);
					SAFEIRELEASE(pIOutSign);
					bRet = FALSE;
					break;
				}

				SAFEBSTRFREE(bstrMethodName);
				SAFEIRELEASE(pIInSign);
				SAFEIRELEASE(pIOutSign);
			}
			SAFEIRELEASE(pIObject);
		}
		catch(_com_error& e)
		{
			SAFEBSTRFREE(bstrMethodName);
			SAFEIRELEASE(pIInSign);
			SAFEIRELEASE(pIOutSign);
			SAFEIRELEASE(pIObject);
			_com_issue_error(e.Error());
			bRet = FALSE;
		}
		catch(CHeap_Exception)
		{
			bRet = FALSE;
			SAFEBSTRFREE(bstrMethodName);
			SAFEIRELEASE(pIInSign);
			SAFEIRELEASE(pIOutSign);
			SAFEIRELEASE(pIObject);
			_com_issue_error(WBEM_E_OUT_OF_MEMORY);
		}
	}
	else
		bRet = FALSE;

	if ( bCheckForExists == TRUE )
    {
        if(FAILED(hr)) throw MULTIPLENODE_ERROR;
		bRet = bMethAvail;
    }
	
	return bRet;
}

/*----------------------------------------------------------------------------
   Name				 :ConnectToNamespace
   Synopsis	         :This function connects to the WMI namespace on the 
					  target machine using the supplied user credentials.
   Type	             :Member Function
   Input Parameter(s):
		rParsedInfo  - reference to CParsedInfo class object
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :ConnectToNamespace(rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
HRESULT CParserEngine::ConnectToNamespace(CParsedInfo& rParsedInfo)
{
	HRESULT		hr		= S_OK;
	DWORD dwThreadId = GetCurrentThreadId();
    _bstr_t bstrNameSpace;
	//if (rParsedInfo.GetGlblSwitchesObject().GetNameSpaceFlag())
	{
		BOOL		bTrace				= FALSE;
		CHString	chsMsg;
		ERRLOGOPT	eloErrLogOpt		= NO_LOGGING;
        BOOL        Node                = FALSE;

		// Obtain the trace status
        bTrace = rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();
        eloErrLogOpt = rParsedInfo.GetErrorLogObject().GetErrLogOption();

        CHARVECTOR cvNodesList = rParsedInfo.GetGlblSwitchesObject().GetNodesList();

        if(cvNodesList.size() == 2){                      // Note : Size 2 means only one node is present.
            CHARVECTOR::iterator iNodesIterator = cvNodesList.begin();
            iNodesIterator++;
            rParsedInfo.GetGlblSwitchesObject().SetNode(*iNodesIterator);
            Node = TRUE;
        } else if(cvNodesList.size() > 2){
            return WBEM_E_NOT_SUPPORTED;
        }

        if(Node) {
            bstrNameSpace = _bstr_t(L"\\\\") 
					            + _bstr_t(rParsedInfo.GetNode()) 
					            + _bstr_t(L"\\") 
					            + _bstr_t(rParsedInfo.GetNamespace());
        } else {
            bstrNameSpace = _bstr_t(rParsedInfo.GetNamespace());
        }

		SAFEIRELEASE(m_pITargetNS);
		try
		{
			// Connect to the WMI namespace on the target machine 
			// using the supplied user credentials.
			hr = Connect(m_pIWbemLocator, &m_pITargetNS, 
					bstrNameSpace,
					NULL,
					NULL,
					_bstr_t(rParsedInfo.GetLocale()),
					rParsedInfo);

			if (bTrace || eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemLocator::ConnectServer(L\"%s\", NULL, "
						L"NULL, L\"%s\", 0L, L\"%s\", NULL, -)",
						rParsedInfo.GetNamespace(),
						rParsedInfo.GetLocale(),
						(rParsedInfo.GetAuthorityPrinciple()) ?
							rParsedInfo.GetAuthorityPrinciple() : L"<null>");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
					rParsedInfo, bTrace);
			}
			ONFAILTHROWERROR(hr);

			// set the security privileges at the interface level
			hr = SetSecurity(m_pITargetNS, NULL, NULL,	NULL, NULL,
					rParsedInfo.GetGlblSwitchesObject().
								GetAuthenticationLevel(),
					rParsedInfo.GetGlblSwitchesObject().
								GetImpersonationLevel());
			if (bTrace || eloErrLogOpt)
			{
				chsMsg.Format(L"CoSetProxyBlanket(-, RPC_C_AUTHN_WINNT, "
						L"RPC_C_AUTHZ_NONE, NULL, %d,   %d, -, EOAC_NONE)",
						rParsedInfo.GetGlblSwitchesObject().
									GetAuthenticationLevel(),
						rParsedInfo.GetGlblSwitchesObject().
									GetImpersonationLevel());
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId,
						rParsedInfo, bTrace);
			}
			ONFAILTHROWERROR(hr);

			rParsedInfo.GetGlblSwitchesObject().SetNameSpaceFlag(FALSE);
		}
		catch(_com_error& e)
		{
			// execption handling
			_com_issue_error(e.Error());
		}
		catch(CHeap_Exception)
		{
			_com_issue_error(WBEM_E_OUT_OF_MEMORY);
		}

	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :ObtainMethodParamInfo
   Synopsis	         :This function obtains the information about the method
					  arguments (both input and output arguments)
   Type	             :Member Function
   Input Parameter(s):
		pIObj	     - pointer to IWbemClassObject object
		bTrace	     - trace flag
		ioInOrOut    - INOROUT type specifies in or out parameter type.
   Output Parameter(s):
   		mdMethDet    - method details structure
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    :ObtainMethodParamInfo(pIObj, mdMethDet, IN, bTrace, rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
HRESULT CParserEngine::ObtainMethodParamInfo(IWbemClassObject* pIObj, 
											 METHODDETAILS& mdMethDet,
											 INOROUT ioInOrOut,
											 BOOL bTrace, CParsedInfo& rParsedInfo)
{
	HRESULT		hr					= S_OK;
    SAFEARRAY*	psaNames			= NULL;
	BSTR		bstrPropName		= NULL;
	CHString	chsMsg;
	_TCHAR		szNumber[BUFFER512] = NULL_STRING; 
	ERRLOGOPT	eloErrLogOpt		= NO_LOGGING;
	DWORD		dwThreadId			= GetCurrentThreadId();

    // Get the property names 
	try
	{
		if ( pIObj != NULL )
		{
			hr = pIObj->GetNames(NULL, 
							WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, 
			   				NULL, &psaNames);
			if (bTrace || eloErrLogOpt)
			{
				chsMsg.Format(L"IWbemClassObject::GetNames(NULL, "
							L"WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY, "
							L"NULL, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId,
							rParsedInfo, bTrace);
			}	
			ONFAILTHROWERROR(hr);

			// Get the number of properties.
			LONG lLower = 0, lUpper = 0; 
			hr = SafeArrayGetLBound(psaNames, 1, &lLower);
			if ( eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetLBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId,
						rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			hr = SafeArrayGetUBound(psaNames, 1, &lUpper);
			if ( eloErrLogOpt )
			{
				chsMsg.Format(L"SafeArrayGetUBound(-, -, -)"); 
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, dwThreadId, 
					rParsedInfo, FALSE);
			}
			ONFAILTHROWERROR(hr);

			// For each property obtian the information of our interest
			for (LONG lVar = lLower; lVar <= lUpper; lVar++) 
			{
				// Get the property.
				hr = SafeArrayGetElement(psaNames, &lVar, &bstrPropName);
				if ( eloErrLogOpt )
				{
					chsMsg.Format(L"SafeArrayGetElement(-, -, -)"); 
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
						dwThreadId, rParsedInfo, FALSE);
				}
				ONFAILTHROWERROR(hr);

				PROPERTYDETAILS pdPropDet;
				hr = GetPropertyAttributes(pIObj,
					bstrPropName, pdPropDet, bTrace);
				ONFAILTHROWERROR(hr);

				// 'ReturnValue' is not a property of our interest as per
				// the expected output given in the sample, hence omitting
				// the same.
				if ( bstrPropName != NULL )
				{
					PROPERTYDETAILS pdIPropDet;
					pdIPropDet.Type = pdPropDet.Type;
					pdIPropDet.InOrOut = ioInOrOut;

					// Making bstrPropName begin with numbers to maintain
					// the order of method arguments in map.
					// while displaying remove numbers and display the 
					// parameters in case of help only.
					_bstr_t bstrNumberedPropName; 
					if ( rParsedInfo.GetGlblSwitchesObject().GetHelpFlag() )
					{
						if ( ioInOrOut == INP )
							_ltot(lVar, szNumber, 10);
						else
							_ltot(lVar + 500, szNumber, 10);

						chsMsg.Format(L"%-5s", szNumber);
						bstrNumberedPropName = _bstr_t(chsMsg) +
											   _bstr_t(bstrPropName);
					}
					else
						bstrNumberedPropName = _bstr_t(bstrPropName);

					mdMethDet.Params.insert(PROPDETMAP::value_type(
											bstrNumberedPropName,pdIPropDet));
				}

				// Free the memory allocated using SysAllocString for 
				// bstrPropName
				SAFEBSTRFREE(bstrPropName);
			}
			// Destroy array descriptor and all of the data in the array
			SAFEADESTROY(psaNames);
		}
    }
	catch(_com_error& e)
	{
		SAFEBSTRFREE(bstrPropName);
		SAFEADESTROY(psaNames);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEBSTRFREE(bstrPropName);
		SAFEADESTROY(psaNames);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :GetMethodStatusAndDesc
   Synopsis	         :This function obtains the implementation status and 
					  description of the verbs available
   Type	             :Member Function
   Input Parameter(s):
		pIObj	     - pointer to IWbemClassObject object
		bstrMethod   - method name
		bTrace	     - trace flag
   Output Parameter(s):
   		bstrStatus   - implementation status
		bstrDesc     - Method description
   Return Type       :HRESULT 
   Global Variables  :None
   Calling Syntax    : GetMethodStatusAndDesc(pIObj, bstrMethod,
						bstrStatus, bstrDesc, bTrace)
   Notes             :none
----------------------------------------------------------------------------*/
HRESULT CParserEngine::GetMethodStatusAndDesc(IWbemClassObject* pIObj, 
											  BSTR bstrMethod,
											  _bstr_t& bstrStatus,
											  _bstr_t& bstrDesc,
											  BOOL bTrace)
{
	HRESULT				hr			= S_OK;
	IWbemQualifierSet*	pIQualSet	= NULL;
	VARIANT				vtStatus, vtDesc;
	VariantInit(&vtStatus);
	VariantInit(&vtDesc);
	
	try
	{
		if ( pIObj != NULL )
		{
			// Obtain the method qualifier set.
   			hr = pIObj->GetMethodQualifierSet(bstrMethod, &pIQualSet);
			if ( pIQualSet != NULL )
			{
				// Retrieve the 'Implemented' qualifier status value
				hr = pIQualSet->Get(_bstr_t(L"Implemented"), 
								0L, &vtStatus, NULL);
				
				if (SUCCEEDED(hr))
				{
					if (vtStatus.vt != VT_EMPTY && vtStatus.vt != VT_NULL )
					{
						if ( vtStatus.boolVal ) 
							bstrStatus = L"Implemented";
						else
							bstrStatus = L"Not Implemented";
					}
					else
						bstrStatus = L"Not Found";
				}	
				else
					bstrStatus = L"Not Found";
				VARIANTCLEAR(vtStatus);
				// Should not break here, hence the HRESULT should be set to S_OK
				hr = S_OK;
				
				// Retrieve the 'Description' qualifier text
				hr = pIQualSet->Get(_bstr_t(L"Description"), 0L , 
									&vtDesc, NULL);
				if (SUCCEEDED(hr))
				{
					if (vtDesc.vt == VT_BSTR) 
						bstrDesc = _bstr_t(vtDesc.bstrVal);
					else
						bstrDesc = L"Not available";
				}
				else
					bstrDesc = L"Not available";
				VARIANTCLEAR(vtDesc);
				// Should not break here, hence the HRESULT should be set to S_OK
				hr = S_OK;
				SAFEIRELEASE(pIQualSet);
			}
			else
				hr = S_OK;
		}
	}
	catch(_com_error& e)
	{
		VARIANTCLEAR(vtStatus);
		VARIANTCLEAR(vtDesc);
		SAFEIRELEASE(pIQualSet);
		hr = e.Error();
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :CheckforHelp
   Synopsis	         :This function looks ahead one token to see if the next 
					  token is '?'
   Type	             :Member Function
   Input Parameter(s):
		cvTokens	 - the tokens vector 
		theIterator	 - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object.
		uErrataCode  - error string ID
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object

   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :CheckforHelp(cvtokens,theIterator,rParsedInfo,uErrataCode)
   Notes             :none
----------------------------------------------------------------------------*/
RETCODE CParserEngine::CheckForHelp(CHARVECTOR& cvTokens, 
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo,
									UINT uErrataCode)
{
	RETCODE retCode = PARSER_DISPHELP;
	// Set the retCode as PARSER_ERROR if no more tokens 
	// are present.
	if(!GetNextToken(cvTokens, theIterator))
	{
		retCode = PARSER_ERROR;
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(uErrataCode);
	}
	else if(!CompareTokens(*theIterator, CLI_TOKEN_HELP))
	{
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
							uErrataCode);
		retCode = PARSER_ERROR;
	}
	else
	{
		retCode = ParseHelp(cvTokens, theIterator, rParsedInfo, FALSE);
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ValidateGlobalSwitchValue
   Synopsis	         :This function checks whether global switches are 
					  specified in the expected format or not.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator	 - the Iterator to the cvTokens vector.
		uErrataCode	 - error string
		rParsedInfo  - reference to CParsedInfo class object.
		uErrataCode2 - error string2 ID
		htHelp		 - help type
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :ValidateGlobalSwitchValue(cvTokens, theIterator, 
								uErrataCode, rParsedInfo,
								uErrataCode2, htHelp)
   Notes             :none
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ValidateGlobalSwitchValue(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											UINT uErrataCode,
											CParsedInfo& rParsedInfo,
											UINT uErrataCode2,
											HELPTYPE htHelp)
{
	RETCODE retCode = PARSER_CONTINUE;
	retCode = GetNextToken(cvTokens, theIterator, rParsedInfo,
						 htHelp, uErrataCode2);

	if (retCode == PARSER_CONTINUE)
	{		
 		// Check for the presence of the ':'
		if (CompareTokens(*theIterator, CLI_TOKEN_COLON)) 
		{
			// Move to next token
			if (GetNextToken(cvTokens, theIterator, rParsedInfo,
						uErrataCode))
			{
				if (IsOption(*theIterator))
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
																uErrataCode);
					retCode = PARSER_ERROR;
				}
				else
					retCode = PARSER_CONTINUE;
			}
			else
				retCode = PARSER_ERROR;
		}
		else if (IsOption(*theIterator))
		{
			retCode = CheckForHelp(cvTokens, theIterator,
						rParsedInfo, uErrataCode2);
			if (retCode == PARSER_DISPHELP)
			{
				rParsedInfo.GetGlblSwitchesObject().SetHelpFlag(TRUE);
				rParsedInfo.GetHelpInfoObject().SetHelp(htHelp, TRUE);
			}
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(uErrataCode2);
			retCode = PARSER_ERROR;
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseEVERYSwitch
   Synopsis	         :This function checks whether the value specified for the
					  /EVERY swith is valid or not.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator	 - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object.
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :ParseEVERYSwitch(cvTokens, theIterator, rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseEVERYSwitch(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator,
										CParsedInfo& rParsedInfo)
{
	RETCODE	retCode	= PARSER_EXECCOMMAND;	
	
	retCode = ParseNumberedSwitch(cvTokens, theIterator, rParsedInfo,
								EVERY, IDS_E_INVALID_EVERY_SWITCH,
								IDS_E_INVALID_INTERVAL);

	if ( retCode == PARSER_EXECCOMMAND )
	{
		 if (GetNextToken(cvTokens, theIterator) == TRUE )
		 {
			 if ( CompareTokens(*theIterator, CLI_TOKEN_FSLASH) == TRUE )
			 {
				 if ( GetNextToken(cvTokens, theIterator) == TRUE )
				 {
					 if (CompareTokens(*theIterator, CLI_TOKEN_REPEAT) == TRUE)
					 {
						 retCode = ParseNumberedSwitch(cvTokens, 
													theIterator,
													rParsedInfo,
													REPEAT, 
													IDS_E_INVALID_REPEAT_SWITCH,
													IDS_E_INVALID_REPEATCOUNT);
					 }
					 else
						 theIterator = theIterator - 2;
				 }
				 else
					 theIterator = theIterator - 2;
			 }
			 else
				 theIterator = theIterator - 1;
		 }
	}

	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseFORMATSwitch
   Synopsis	         :This function checks whether the value specified for the 
					  /FORMAT swith is valid or not.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator	 - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object.
   Output Parameter(s):
   		rParsedInfo  - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type.
   Global Variables  :None
   Calling Syntax    :ParseFORMATSwitch(cvTokens, theIterator, rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseFORMATSwitch(CHARVECTOR& cvTokens,
										 CHARVECTOR::iterator& theIterator,
										 CParsedInfo& rParsedInfo)
{
	RETCODE retCode = PARSER_EXECCOMMAND;
	// Reset the XSL file path.
	rParsedInfo.GetCmdSwitchesObject().ClearXSLTDetailsVector();

	// Move to next token
	if (!GetNextToken(cvTokens, theIterator))
	{
		retCode = PARSER_EXECCOMMAND;

		// If Translate table name is given then set the flag
		if( rParsedInfo.GetCmdSwitchesObject().
									GetTranslateTableName() != NULL ) 
		{
			rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(TRUE);
		}
		else
			rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(FALSE);
	}
	else if ( IsOption(*theIterator) &&
			  (theIterator + 1) < cvTokens.end() &&
			  CompareTokens(*(theIterator+1), CLI_TOKEN_HELP) )
	{
		theIterator++;
		retCode = ParseHelp(cvTokens, theIterator, FORMAT, rParsedInfo);
	}
	else if (CompareTokens(*theIterator, CLI_TOKEN_COLON)) 
	{
		while ( retCode == PARSER_EXECCOMMAND && 
				theIterator < cvTokens.end() )
		{
			XSLTDET xdXSLTDet;
			BOOL	bFrameXSLFile = TRUE;
			// Move to next token
			if (!GetNextToken(cvTokens, theIterator))
			{
				// PARSER_ERROR if <format specifier> is missing
				rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_FORMAT);
				retCode = PARSER_ERROR;
			}
			else if ( IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(IDS_E_INVALID_FORMAT);
				retCode = PARSER_ERROR;
			}
			else 
			{
				xdXSLTDet.FileName = *theIterator;
				if(!g_wmiCmd.GetFileFromKey(*theIterator, xdXSLTDet.FileName))
					bFrameXSLFile	= FALSE;
			}

			if ( retCode == PARSER_EXECCOMMAND )
			{
				if ( !GetNextToken(cvTokens, theIterator) )
				{
					if ( bFrameXSLFile == TRUE )
					{
						if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
																 rParsedInfo))
							retCode = PARSER_ERRMSG;
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
										AddToXSLTDetailsVector(xdXSLTDet);
					break;
				}
				else if ( IsOption(*theIterator) )
				{
					theIterator--;
					if ( bFrameXSLFile == TRUE )
					{
						if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
																 rParsedInfo))
							retCode = PARSER_ERRMSG;
					}
					else
						rParsedInfo.GetCmdSwitchesObject().
										AddToXSLTDetailsVector(xdXSLTDet);
					break;
				}
				else if ( CompareTokens(*theIterator, CLI_TOKEN_COLON ) )
				{
					retCode = ParseParamsString(cvTokens, theIterator,
											   rParsedInfo, xdXSLTDet);
					
					if ( retCode == PARSER_EXECCOMMAND &&
					 (theIterator != cvTokens.end()) && IsOption(*theIterator) )
					{
						theIterator--;
						
						if ( bFrameXSLFile == TRUE )
						{
							if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, 
																rParsedInfo))
								retCode = PARSER_ERRMSG;
						}
						else
							rParsedInfo.GetCmdSwitchesObject().
											AddToXSLTDetailsVector(xdXSLTDet);
						break;
					}
				}
				else if ( !CompareTokens(*theIterator, CLI_TOKEN_COMMA ) )
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_FORMAT);
					retCode = PARSER_ERROR;
				}
			}

			if ( retCode == PARSER_EXECCOMMAND )
			{
				if ( bFrameXSLFile == TRUE )
				{
					if (!FrameFileAndAddToXSLTDetVector(xdXSLTDet, rParsedInfo))
						retCode = PARSER_ERRMSG;
				}
				else
					rParsedInfo.GetCmdSwitchesObject().
											AddToXSLTDetailsVector(xdXSLTDet);
			}
		}

		// If Translate table name is given then set the flag
		if( rParsedInfo.GetCmdSwitchesObject().
									GetTranslateTableName() != NULL ) 
		{
			rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(TRUE);
		}
		else
			rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(FALSE);
	}
	else
	{
		theIterator--;
	}

	return retCode;
}
/*----------------------------------------------------------------------------
   Name				 :IsStdVerbOrUserDefVerb
   Synopsis	         :This function checks whether the verb is standard verb 
					  or user defined verb for alias.
   Type	             :Member Function
   Input Parameter(s):
		pszToken     - the verb name string
		rParsedInfo  - reference to CParsedInfo class object
		
   Output Parameter(s): None
   		
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsStdVerbOrUserDefVerb( pszToken,rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
BOOL CParserEngine::IsStdVerbOrUserDefVerb(_bstr_t bstrToken,
										   CParsedInfo& rParsedInfo)
{
	BOOL bStdVerbOrUserDefVerb = FALSE;
	
	try
	{
		if ( CompareTokens(bstrToken, CLI_TOKEN_GET)	||
			 CompareTokens(bstrToken, CLI_TOKEN_LIST)	||
			 CompareTokens(bstrToken, CLI_TOKEN_SET)	||
			 CompareTokens(bstrToken, CLI_TOKEN_CREATE)	||
			 CompareTokens(bstrToken, CLI_TOKEN_CALL)	||
			 CompareTokens(bstrToken, CLI_TOKEN_ASSOC)	||
			 CompareTokens(bstrToken, CLI_TOKEN_DELETE) )
			 bStdVerbOrUserDefVerb = TRUE;
		else
		{
			if ( m_bAliasName )
			{
				METHDETMAP mdmMethDetMap =  rParsedInfo.GetCmdSwitchesObject()
																.GetMethDetMap();
				if ( mdmMethDetMap.empty() )
				{
					m_CmdAlias.ObtainAliasVerbDetails(rParsedInfo);
					mdmMethDetMap =  rParsedInfo.GetCmdSwitchesObject()
																.GetMethDetMap();
				}

				METHDETMAP::iterator theMethIterator = NULL;
				for ( theMethIterator = mdmMethDetMap.begin();
					  theMethIterator != mdmMethDetMap.end(); theMethIterator++ )	
				{
					if ( CompareTokens((*theMethIterator).first,bstrToken) )
					{
						bStdVerbOrUserDefVerb = TRUE;
						break;
					}
				}
			}
		}
	}
	catch(_com_error& e)
	{
		bStdVerbOrUserDefVerb = FALSE;
		_com_issue_error(e.Error());		
	}
	return bStdVerbOrUserDefVerb;
}

/*----------------------------------------------------------------------------
   Name				 :ParseTRANSLATESwitch
   Synopsis	         :This function parses for translate switch in the command.
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator	 - the Iterator to the cvTokens vector.
		rParsedInfo  - reference to CParsedInfo class object.
   Output Parameter(s) :
   		rParsedInfo  - reference to CParsedInfo class object
   		
   Return Type       :RETCODE-enumerated type
   Global Variables  :None
   Calling Syntax    :ParseTRANSLATESwitch(cvTokens,theIterator,rParsedInfo)
   Notes             :none
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseTRANSLATESwitch(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo& rParsedInfo)
{
	RETCODE retCode = PARSER_EXECCOMMAND;

	if ( GetNextToken(cvTokens, theIterator, rParsedInfo, TRANSLATE,
					 IDS_E_INVALID_TRANSLATE_SWITCH) == PARSER_CONTINUE )
	{
		if ( IsOption(*theIterator) &&
		     (theIterator + 1) < cvTokens.end() &&
		     CompareTokens(*(theIterator+1), CLI_TOKEN_HELP) )
		{
			theIterator++;
			retCode = ParseHelp(cvTokens, theIterator, TRANSLATE, 
																rParsedInfo);
			if ( retCode == PARSER_DISPHELP )
			{
				if( FAILED(m_CmdAlias.ConnectToAlias(rParsedInfo,
														m_pIWbemLocator)))
					retCode = PARSER_ERRMSG;
				if ( FAILED(m_CmdAlias.ObtainTranslateTables(rParsedInfo)))
					retCode = PARSER_ERRMSG;
			}
		}
		else if ( CompareTokens( *theIterator, CLI_TOKEN_COLON ) &&
			 GetNextToken(cvTokens, theIterator, rParsedInfo, TRANSLATE,
						 IDS_E_INVALID_TRANSLATE_SWITCH) == PARSER_CONTINUE )
		{
			rParsedInfo.GetCmdSwitchesObject().SetTranslateTableName(*theIterator);

			if ( IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_INVALID_TRANSLATE_SWITCH);
				retCode = PARSER_ERROR;
			}
			else if(FAILED(m_CmdAlias.ConnectToAlias(rParsedInfo,
														m_pIWbemLocator)))
				retCode = PARSER_ERRMSG;
			else if ( m_CmdAlias.ObtainTranslateTableEntries(rParsedInfo) == TRUE )
				retCode = PARSER_EXECCOMMAND;
			else
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_TRANSLATE_TABLE_NOT_EXIST);
				retCode = PARSER_ERROR;
			}

			// If Format switch is specified after translate switch then
			// set the flag else reset it
			if(rParsedInfo.GetCmdSwitchesObject().GetXSLTDetailsVector().
																	  empty())
			{
				rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(TRUE);
			}
			else
				rParsedInfo.GetCmdSwitchesObject().SetTranslateFirstFlag(FALSE);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
									IDS_E_INVALID_TRANSLATE_SWITCH);
			retCode = PARSER_ERROR;
		}

	}
	else
		retCode = PARSER_ERROR;
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ParseContextInfo
   Synopsis	         :This function does the parsing of the help on context 
					  information
   Type	             :Member Function
   Input Parameter(s):
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object
   Output parameter(s):
		rParsedInfo   - reference to CParsedInfo class object
   Return Type       :RETCODE - enumerated data type
   Global Variables  :None
   Calling Syntax    :ParseContextInfo(cvTokens, theIterator, rParsedInfo)
   Notes             :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseContextInfo(CHARVECTOR& cvTokens,
										CHARVECTOR::iterator& theIterator, 
										CParsedInfo& rParsedInfo)
{
	//BNF: CONTEXT /?[:<FULL|BRIEF>]
	BOOL		bContinue = TRUE;
	RETCODE		retCode   = PARSER_MESSAGE;

	// If option
	if (IsOption(*theIterator))
	{
		// Check for help
		retCode = IsHelp(cvTokens, theIterator,	rParsedInfo, CONTEXTHELP,
								 IDS_E_INVALID_CONTEXT_SYNTAX, LEVEL_ONE);

		// If more tokens are present.
		if (retCode == PARSER_CONTINUE)
		{
			rParsedInfo.GetCmdSwitchesObject().
				SetErrataCode(IDS_E_INVALID_CONTEXT_SYNTAX);
			retCode = PARSER_ERROR;
		}
			
	}
	else 
	{
		rParsedInfo.GetCmdSwitchesObject().
				SetErrataCode(IDS_E_INVALID_CONTEXT_SYNTAX);
		retCode = PARSER_ERROR;
	}
	return retCode;
}

/*----------------------------------------------------------------------------
   Name				 :ValidateNodeOrNS
   Synopsis	         :This function validates the node or namespace
   Type	             :Member Function
   Input Parameter(s):
		pszInput	  - node/namesapce to be validated
		bNode		  - TRUE  - pszInput refers to NODE
						FALSE - pszInput refers to NAMESPACE
   Output parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ValidateNodeOrNS(pszInput, bNode)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::ValidateNodeOrNS(_TCHAR* pszInput, BOOL bNode)
{
	IWbemServices*	pISvc	=	NULL;
	BOOL			bRet	=	TRUE;	
	HRESULT			hr		=	S_OK;

	try
	{	
		if(pszInput == NULL)
			bRet = FALSE;
		
		if(bRet)
		{
			
			if (m_pIWbemLocator != NULL)
			{	
				// Check for the presence of the following invalid
				// characters for NODE.
				if (bNode)
				{
					CHString str(pszInput);
					if (str.FindOneOf(L"\"\\,/[]:<>+=;?$#{}~`^@!'()*") != -1)
					{
						bRet = FALSE;
					};
				}

				if (bRet)
				{

					// Try to connect to root namespace
					_bstr_t bstrNS;
					if (bNode)
						bstrNS = _bstr_t(L"\\\\") + _bstr_t(pszInput) + _bstr_t(L"\\root");
					else
						bstrNS = _bstr_t(L"\\\\.\\") + _bstr_t(pszInput); 

					// Call the ConnectServer method of the IWbemLocator
					hr = m_pIWbemLocator->ConnectServer(bstrNS, NULL, NULL, NULL, 0L,
														NULL, NULL, &pISvc);
					if (FAILED(hr))
					{
						// If invalid machine name
						// 0x800706ba - RPC_SERVER_UNAVAILABLE
						if (bNode && (hr == 0x800706ba))
						{
							bRet = FALSE;
						}

						// If invalid namespace
						// 0x8004100E - WBEM_E_INVALID_NAMESPACE
						if (!bNode 
							&& ((hr == WBEM_E_INVALID_NAMESPACE) || 
								(hr == WBEM_E_INVALID_PARAMETER)))
						{
							bRet = FALSE;
						}
					}
					SAFEIRELEASE(pISvc);
				}
			}
		}
	}
	catch(_com_error& e)
	{
		bRet = FALSE;
		SAFEIRELEASE(pISvc);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		bRet = FALSE;
		SAFEIRELEASE(pISvc);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	return bRet;
}

/*----------------------------------------------------------------------------
Name				 :ParseAssocSwitches
Synopsis	         :This function does the parsing and interprets if command
					  has ASSOC as the verb. It parses the remaining tokens 
					  following and updates the same in CParsedInfo.
Type	             :Member Function
Input Parameter(s)   :cvTokens     - the tokens vector 
					  theIterator  - the Iterator to the cvTokens vector.
					  rParsedInfo  - reference to CParsedInfo class object
Output Parameter(s)  :rParsedInfo  - reference to CParsedInfo class object
Return Type          :RETCODE - enumerated data type
Global Variables     :None
Calling Syntax       :ParseAssocSwitch(cvTokens,theIterator,rParsedInfo)
Notes                :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseAssocSwitches(CHARVECTOR& cvTokens,
		CHARVECTOR::iterator& theIterator,
		CParsedInfo& rParsedInfo)
{
	RETCODE retCode = PARSER_EXECCOMMAND;
	
	while ( retCode == PARSER_EXECCOMMAND )
	{
		// Check for the presence of RESULT CLASS switch
		if (CompareTokens(*theIterator, CLI_TOKEN_RESULTCLASS)) 
		{
			retCode = ParseAssocSwitchEx(cvTokens, theIterator, rParsedInfo ,RESULTCLASS );
		}
		// Check for the presence of RESULT ROLE switch
		else if (CompareTokens(*theIterator,CLI_TOKEN_RESULTROLE )) 
		{
			retCode = ParseAssocSwitchEx(cvTokens, theIterator, rParsedInfo ,RESULTROLE );
		}
		// Check for the presence of ASSOC CLASS switch
		else if (CompareTokens(*theIterator,CLI_TOKEN_ASSOCCLASS )) 
		{
			retCode = ParseAssocSwitchEx(cvTokens, theIterator, rParsedInfo , ASSOCCLASS);
		}
		// Check for the presence of help
		else if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
		{
			rParsedInfo.GetHelpInfoObject().SetHelp(ASSOCSwitchesOnly, TRUE);
			retCode = ParseHelp(cvTokens, theIterator, ASSOCVerb, rParsedInfo);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
				IDS_E_INVALID_ASSOC_SWITCH);
			retCode = PARSER_ERROR;
			break;
		}
		
		//Checking the next tokens 		
		if ( retCode == PARSER_EXECCOMMAND )
		{
			if ( !GetNextToken(cvTokens, theIterator) )
				break;
			
			if ( !IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
					IDS_E_INVALID_COMMAND);
				retCode = PARSER_ERROR;
				break;
			}
			
			if ( !GetNextToken(cvTokens, theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
					IDS_E_INVALID_ASSOC_SWITCH);
				retCode = PARSER_ERROR;
				break;
			}
		}
	}
	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ParseAssocSwitchEx
Synopsis	         :This function does the parsing of tokens for the assoc 
					  switches It parses the remaining tokens following and 
					  updates the same in CParsedInfo.
Type	             :Member Function
Input Parameter(s)   :cvTokens     - the tokens vector 
					  theIterator  - the Iterator to the cvTokens vector.
					  rParsedInfo  - reference to CParsedInfo class object
					  assocSwitch  - the type of assoc switch
Output Parameter(s)  :rParsedInfo  - reference to CParsedInfo class object
Return Type          :RETCODE - enumerated data type
Global Variables     :None
Calling Syntax       :ParseAssocSwitchEx(cvTokens,theIterator,
						rParsedInfo,assocSwitch)
Notes                :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseAssocSwitchEx(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo& rParsedInfo ,
											ASSOCSwitch assocSwitch)
{
	RETCODE retCode		= PARSER_EXECCOMMAND;
	
	//Checking the next token to continue parsing 
	if ( GetNextToken(cvTokens, theIterator, rParsedInfo, ASSOCVerb,
		IDS_E_INVALID_ASSOC_SWITCH) == PARSER_CONTINUE )
	{
		//Checking for help option 
		if ( IsOption(*theIterator) &&
			(theIterator + 1) < cvTokens.end() &&
			CompareTokens(*(theIterator+1), CLI_TOKEN_HELP) )
		{
			theIterator++;
			//Help on RESULTCLASS
			if (assocSwitch == RESULTCLASS)
			{
				retCode = ParseHelp(cvTokens, theIterator, RESULTCLASShelp, 
					rParsedInfo);
				
			}	
			//Help on RESULTROLE
			if (assocSwitch == RESULTROLE)
			{
				retCode = ParseHelp(cvTokens, theIterator, RESULTROLEhelp, 
					rParsedInfo);
			}
			//Help on ASSOCCLASS
			if (assocSwitch == ASSOCCLASS)
			{
				retCode = ParseHelp(cvTokens, theIterator, ASSOCCLASShelp, 
					rParsedInfo);						
			}			
		}
		
		//If the command has ":" , then the corresponding data 
		//has to be set in Command object
		else if ( CompareTokens( *theIterator, CLI_TOKEN_COLON ) &&
			GetNextToken(cvTokens, theIterator, rParsedInfo, ASSOCVerb,
			IDS_E_INVALID_ASSOC_SWITCH) == PARSER_CONTINUE )
		{
			if ( IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_ASSOC_SWITCH);
				retCode = PARSER_ERROR;
			}
			
			else
			{
				//Setting the ResultClassName
				if (assocSwitch == RESULTCLASS)
				{
					if(rParsedInfo.GetCmdSwitchesObject().
						SetResultClassName(*theIterator))
					{
						retCode = PARSER_EXECCOMMAND;
					}
					else
					{
						retCode = PARSER_ERROR;
					}
				}
				//Setting the Result Role Name
				if (assocSwitch == RESULTROLE)
				{
					if(rParsedInfo.GetCmdSwitchesObject().
						SetResultRoleName(*theIterator))
					{
						retCode = PARSER_EXECCOMMAND;
					}
					else
					{
						retCode = PARSER_ERROR;
					}
				}
				//Setting the Assoc Class Name
				if (assocSwitch == ASSOCCLASS)
				{
					if(rParsedInfo.GetCmdSwitchesObject().
						SetAssocClassName(*theIterator))
					{
						retCode = PARSER_EXECCOMMAND;
					}
					else
					{
						retCode = PARSER_ERROR;
					}
				}
			}
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
				IDS_E_INVALID_ASSOC_SWITCH);
			retCode = PARSER_ERROR;
		}
	}
	else
		retCode = PARSER_ERROR;
	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ParseNumberedSwitch
Synopsis	         :This function does the parsing of tokens for the every 
					  and repeat switches. It parses the remaining tokens 
					  following and updates the same in CParsedInfo.
Type	             :Member Function
Input Parameter(s)   :cvTokens			- the tokens vector 
					  theIterator		- the Iterator to the cvTokens vector.
					  rParsedInfo		- reference to CParsedInfo class object
					  htHelp			- enumerated help type 
					  uSwitchErrCode	- error string ID.
					  uNumberErrCode	- error string ID.
					  
Output Parameter(s)  :rParsedInfo  - reference to CParsedInfo class object
Return Type          :RETCODE - enumerated data type
Global Variables     :None
Calling Syntax       :ParseNumberedSwitch(cvTokens, theIterator, rParsedInfo,
								EVERYorREPEAT, uSwitchErrCode,
								uNumberErrCode);

Notes                :None
----------------------------------------------------------------------------*/
RETCODE		CParserEngine::ParseNumberedSwitch(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo& rParsedInfo,
											HELPTYPE htHelp,
											UINT uSwitchErrCode,
											UINT uNumberErrCode)
{
	RETCODE retCode				= PARSER_EXECCOMMAND;
	BOOL	bInvalidSwitch		= FALSE;

	// Move to next token
	if (!GetNextToken(cvTokens, theIterator, rParsedInfo, htHelp,
					  uSwitchErrCode))	
		bInvalidSwitch = TRUE;
	else if ( IsOption(*theIterator) &&
			  (theIterator + 1) < cvTokens.end() &&
			  CompareTokens(*(theIterator+1), CLI_TOKEN_HELP) )
	{
		theIterator++;
		retCode = ParseHelp(cvTokens, theIterator, htHelp, rParsedInfo);
	}
	else if (CompareTokens(*theIterator, CLI_TOKEN_COLON)) 
	{
		BOOL bSuccess = FALSE;
		// Move to next token
		if (GetNextToken(cvTokens, theIterator))	
		{
			if ( IsOption(*theIterator) )
			{
				rParsedInfo.GetCmdSwitchesObject().
											SetErrataCode(uSwitchErrCode);
				retCode = PARSER_ERROR;
			}
			else
			{
				_TCHAR* pszEndPtr = NULL;
				ULONG	ulNumber = _tcstoul(*theIterator, &pszEndPtr, 10);
				if (!lstrlen(pszEndPtr))
				{
					BOOL bSetValue = TRUE;
					if ( htHelp == EVERY )
					{
						bSetValue = rParsedInfo.GetCmdSwitchesObject().
												SetRetrievalInterval(ulNumber);
					}
					else if ( htHelp == REPEAT )
					{
						if ( ulNumber == 0)
						{
							rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(
								IDS_E_INVALID_REPEATCOUNT);
							retCode = PARSER_ERROR;
							bSetValue = FALSE;
						}
						else
						{
							bSetValue = rParsedInfo.GetCmdSwitchesObject().
								SetRepeatCount(ulNumber);
						}
					}
					
					if ( bSetValue == TRUE)
					{
						bSuccess = TRUE;
						rParsedInfo.GetCmdSwitchesObject().SetEverySwitchFlag(TRUE);
						retCode = PARSER_EXECCOMMAND;
					}
					else
					{
						bSuccess = FALSE;
						retCode = PARSER_ERROR;
					}
				}
			}
		}
		if ( bSuccess == FALSE )
		{
			// PARSER_ERROR if no more tokens are present. i.e <interval>
			// is not specified.
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(uNumberErrCode);
			retCode = PARSER_ERROR;
		}
	}
	else
		bInvalidSwitch = TRUE;

	if ( bInvalidSwitch == TRUE )
	{
		// PARSER_ERROR if no more tokens are present. i.e <interval>
		// is not specified.
		rParsedInfo.GetCmdSwitchesObject().SetErrataCode(uSwitchErrCode);
		retCode = PARSER_ERROR;
	}
	return retCode;
}
									
/*----------------------------------------------------------------------------
Name				 :ObtainMethodsAvailableFlag
Synopsis	         :This function Checks whether methods are available with
					  alias in case of alias specified.and with class in case 
					  of class speicified.
Type	             :Member Function
Input Parameter(s)   :
		rParsedInfo  - reference to CParsedInfo class object					  			  
Output Parameter(s)  :None
Return Type          :void
Global Variables     :None
Calling Syntax       :ObtainMethodsAvailableFlag(rParsedInfo)
Notes                :None
----------------------------------------------------------------------------*/
void	CParserEngine::ObtainMethodsAvailableFlag(CParsedInfo& rParsedInfo)
{
	BOOL		bMethAvail	= TRUE;

	if ( m_bAliasName == TRUE )
		bMethAvail = m_CmdAlias.AreMethodsAvailable(rParsedInfo);
	else
		bMethAvail = ObtainClassMethods(rParsedInfo, TRUE);

	rParsedInfo.GetCmdSwitchesObject().SetMethodsAvailable(bMethAvail);
}

/*----------------------------------------------------------------------------
Name				 :ObtainWriteablePropsAvailailableFlag
Synopsis	         :Checks whether writable props are available with alias in 
					  case of alias specified. and with class in case of class 
					  speicified.
Type	             :Member Function
Input Parameter(s)   :
		rParsedInfo  - reference to CParsedInfo class object					  			  
Output Parameter(s)  :None
Return Type          :void
Global Variables     :None
Calling Syntax       :ObtainWriteablePropsAvailailableFlag(rParsedInfo)
Notes                :None
----------------------------------------------------------------------------*/
void	CParserEngine::ObtainWriteablePropsAvailailableFlag(
													CParsedInfo& rParsedInfo)
{
	BOOL		bWritePropsAvail	= TRUE;
	HRESULT     hr = S_OK;
	
	try
	{

		if ( m_bAliasName == TRUE )
		{
			hr = m_CmdAlias.ObtainAliasPropDetails(rParsedInfo, &bWritePropsAvail);
			ONFAILTHROWERROR(hr);
		}

		else
			bWritePropsAvail = ObtainClassProperties(rParsedInfo, TRUE);

		rParsedInfo.GetCmdSwitchesObject().SetWriteablePropsAvailable(
																bWritePropsAvail);
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
}

/*----------------------------------------------------------------------------
Name				 :ParseVerbInteractive
Synopsis	         :This function parses the verb interactive option
Type	             :Member Function
Input Parameter(s)   :
		cvTokens      - the tokens vector 
		theIterator   - the Iterator to the cvTokens vector.
		rParsedInfo   - reference to CParsedInfo class object					  			  
Output Parameter(s)  :
		rParsedInfo		- reference to CParsedInfo class object
		bInvalidOption  - Invalid syntax for interactive
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ParseVerbInteractive(rParsedInfo)
Notes                :None
----------------------------------------------------------------------------*/
RETCODE	CParserEngine::ParseVerbInteractive(CHARVECTOR& cvTokens,
							CHARVECTOR::iterator& theIterator, 
							CParsedInfo& rParsedInfo, BOOL& bInvalidOption)
{
	RETCODE	retCode = PARSER_EXECCOMMAND;

	if (GetNextToken(cvTokens, theIterator))
	{
		// check for the presence of ':'
		if (CompareTokens(*theIterator, CLI_TOKEN_COLON))
		{			
			if (GetNextToken(cvTokens, theIterator))
			{
				if (IsOption(*theIterator))
				{
					if (GetNextToken(cvTokens, theIterator))
					{
						if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
						{
							retCode = ParseHelp(cvTokens, theIterator, VERBSWITCHES, 
												rParsedInfo);
						}
						else
						{
							bInvalidOption = TRUE;
						}
					}
					else
					{
						bInvalidOption = TRUE;
					}
				}
				else
				{
					while (TRUE)
					{
						if(!rParsedInfo.GetCmdSwitchesObject().
												AddToInteractivePropertyList(*theIterator))
						{
							rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
										IDS_E_ADD_TO_PROP_LIST_FAILURE);
							retCode = PARSER_ERROR;
						}
						if (GetNextToken(cvTokens, theIterator))
						{
							// check for the presence of ','
							if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
							{
								if (!GetNextToken(cvTokens, theIterator))
								{
									rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_PARAMLIST);
									retCode = PARSER_ERROR;
									break;
								}
							}
							else
							{
								rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											IDS_E_INVALID_PARAMLIST);
								retCode = PARSER_ERROR;
								break;
							}
						}
						else
						{
							retCode = PARSER_EXECCOMMAND;
							break;
						}
					}
				}
			}
			else
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
							IDS_E_INVALID_PARAMLIST);
				retCode = PARSER_ERROR;
			}
		}
		else if (IsOption(*theIterator))
		{
			if (GetNextToken(cvTokens, theIterator))
			{
				if (CompareTokens(*theIterator, CLI_TOKEN_HELP)) 
				{
					retCode = ParseHelp(cvTokens, theIterator, VERBSWITCHES, 
										rParsedInfo);
				}
				else
				{
					bInvalidOption = TRUE;
				}
			}
			else
			{
				bInvalidOption = TRUE;
			}
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
						IDS_E_INVALID_PARAMLIST);
			retCode = PARSER_ERROR;
		}
	}

	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ProcessOutputAndAppendFiles
Synopsis	         :Prepares the output and append files for output 
					  redirection.
Type	             :Member Function
Input Parameter(s)   :
	rParsedInfo		 - reference to CParsedInfo class object.
	retOCode		 - RETCODE type, specifies the initial RETCODE before 
					   calling the function.	 
	bOpenOutInWriteMode - boolean type, to specify flag of OpenOutInWriteMode. 
Output Parameter(s)  :
		rParsedInfo		- reference to CParsedInfo class object
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ProcessOutputAndAppendFiles(rParsedInfo, retCode, FALSE)
Notes                :None
----------------------------------------------------------------------------*/
RETCODE	CParserEngine::ProcessOutputAndAppendFiles(CParsedInfo& rParsedInfo, 
												   RETCODE retOCode,
												   BOOL bOpenOutInWriteMode)
{
	RETCODE retCode = retOCode;

	// TRUE for getting output file name.
	_TCHAR* pszOutputFileName =
		rParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendFileName(
																	TRUE);
	if ( pszOutputFileName != NULL )
	{
		// redirect the output to file.
		if ( CloseOutputFile() == TRUE )
		{
			FILE *fpOutFile;
			fpOutFile = _tfopen(pszOutputFileName, _T("wb"));
			if ( fpOutFile != NULL)
			{
				char	szUnicodeString[2];
				szUnicodeString[0] = (char) 0xFF;
				szUnicodeString[1] = (char) 0xFE;
				fwrite(szUnicodeString, 2, 1, fpOutFile);
				// close the opened file(because u opened in write mode)
				fclose(fpOutFile);
			}
			
			// again open the file in append mode
			fpOutFile = _tfopen(pszOutputFileName, _T("ab"));

			if ( fpOutFile == NULL )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
											  IDS_E_OPEN_OUTPUT_FILE_FAILURE);
				retCode = PARSER_ERROR;
			}
			else // TRUE for setting output file pointer.
				rParsedInfo.GetGlblSwitchesObject().
						SetOutputOrAppendFilePointer(fpOutFile, TRUE);
		}
	}

	// Processing for append file.

	if ( retCode == retOCode && bOpenOutInWriteMode == FALSE)
	{
		// FALSE for getting append file name.
		_TCHAR* pszAppendFileName =
			rParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendFileName(
																	   FALSE);
		if ( pszAppendFileName != NULL )
		{
			if ( CloseAppendFile() == TRUE )
			{
				FILE* fpOpenAppendFile = _tfopen(pszAppendFileName, _T("r"));

				if ( fpOpenAppendFile != NULL )
				{
					//
					// set type of file (ansi/unicode)
					//
					rParsedInfo.GetGlblSwitchesObject().SetFileType ( ReturnFileType ( fpOpenAppendFile ) ) ;

					// close the file which is opened in read mode
					fclose(fpOpenAppendFile);

					fpOpenAppendFile = _tfopen(pszAppendFileName, _T("ab"));
				}
				else
				{	
					fpOpenAppendFile = _tfopen(pszAppendFileName, _T("wb"));

					if ( fpOpenAppendFile != NULL)
					{
						char	szUnicodeString[2];
						szUnicodeString[0] = (char) 0xFF;
						szUnicodeString[1] = (char) 0xFE;
						fwrite(szUnicodeString, 2, 1, fpOpenAppendFile);

						//
						// set type of file (unicode)
						//
						rParsedInfo.GetGlblSwitchesObject().SetFileType ( UNICODE_FILE ) ;

						// close the opened file(because u opened in binary mode)
						fclose(fpOpenAppendFile);
					}

					// again open the file in append mode
					fpOpenAppendFile = _tfopen(pszAppendFileName, _T("ab"));
				}

				if ( fpOpenAppendFile == NULL )
				{
					 rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_OPEN_APPEND_FILE_FAILURE);
					 retCode = PARSER_ERROR;
				}
				else
				{
					// FALSE for setting append file pointer. 
					rParsedInfo.GetGlblSwitchesObject().
								SetOutputOrAppendFilePointer(fpOpenAppendFile,
															 FALSE);
				}
			}
		}
	}

	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ParseUnnamedParamList
Synopsis	         :Parses Unnamed Parameter list.
Type	             :Member Function
Input Parameter(s)   :
	rParsedInfo		 - reference to CParsedInfo class object.
	cvTokens		 - the tokens vector 
	theIterator		 - the Iterator to the cvTokens vector.
Output Parameter(s)  :
	rParsedInfo		 - reference to CParsedInfo class object
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ParseUnnamedParamList(cvTokens, theIterator,rParsedInfo);
Notes                :None
----------------------------------------------------------------------------*/
RETCODE CParserEngine::ParseUnnamedParamList(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo& rParsedInfo)
{
	RETCODE	retCode		= PARSER_EXECCOMMAND;
	
	while (TRUE)
	{
		if(!rParsedInfo.GetCmdSwitchesObject().
								AddToPropertyList(*theIterator))
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
						IDS_E_ADD_TO_PROP_LIST_FAILURE);
			retCode = PARSER_ERROR;
		}
		if (GetNextToken(cvTokens, theIterator))
		{
			if (IsOption(*theIterator))
			{
				// To facilitate ParseVerbSwitches to continue
				theIterator--;
				break;
			}
			else
			{
				// check for the presence of ','
				if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
				{
					if (!GetNextToken(cvTokens, theIterator))
					{
						rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_INVALID_PARAMLIST);
						retCode = PARSER_ERROR;
						break;
					}
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
								IDS_E_INVALID_PARAMLIST);
					retCode = PARSER_ERROR;
					break;
				}
			}
		}
		else
			break;
	}

	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ValidateVerbOrMethodParams
Synopsis	         :Validates the named params with verb or method parameters.
Type	             :Member Function
Input Parameter(s)   :
	rParsedInfo		 - reference to CParsedInfo class object.	
Output Parameter(s)  :
	rParsedInfo		 - reference to CParsedInfo class object
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ValidateVerbOrMethodParams(rParsedInfo);
Notes                :None
----------------------------------------------------------------------------*/
RETCODE		CParserEngine::ValidateVerbOrMethodParams(CParsedInfo& rParsedInfo)
{
	RETCODE retCode	= PARSER_EXECCOMMAND;
	BSTRMAP::iterator theIterator;
	PROPDETMAP::iterator propIterator;
	// Info about verb or method params.
	PROPDETMAP pdmVerbOrMethParams = (*(rParsedInfo.GetCmdSwitchesObject().
									  GetMethDetMap().begin())).second.Params;

	BSTRMAP	   bmNamedParams = rParsedInfo.GetCmdSwitchesObject().
															GetParameterMap();

	for ( theIterator = bmNamedParams.begin();
		  theIterator != bmNamedParams.end(); theIterator++ )
	{
		BOOL bFind;
		if ( rParsedInfo.GetCmdSwitchesObject().GetVerbType() == CMDLINE )
			bFind = Find(pdmVerbOrMethParams,(*theIterator).first, 
														propIterator, TRUE);
		else
			bFind = Find(pdmVerbOrMethParams,(*theIterator).first, 
														propIterator);

		if ( bFind == FALSE )
		{
			DisplayMessage((*theIterator).first, CP_OEMCP, TRUE, TRUE);
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												IDS_E_NOT_A_VERBORMETH_PARAM);
			retCode = PARSER_ERROR;
			break;
		}
		else if ( (*propIterator).second.InOrOut != INP )
		{
			DisplayMessage((*theIterator).first, CP_OEMCP, TRUE, TRUE);
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												IDS_E_NOT_A_INPUT_PARAM);
			retCode = PARSER_ERROR;
			break;
		}
	}
	
	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ParseParamsString
Synopsis	         :Parses the parameter string 
Type	             :Member Function
Input Parameter(s)   :
	rParsedInfo		 - reference to CParsedInfo class object.	
	cvTokens		 - the tokens vector 
	theIterator		 - the Iterator to the cvTokens vector.
	xdXSLTDet		 - reference to the XSLdetails vector
Output Parameter(s)  :
	rParsedInfo		 - reference to CParsedInfo class object
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ParseParamsString(cvTokens, theIterator, rParsedInfo, 
										xdXSLTDet);
Notes                :None
----------------------------------------------------------------------------*/
RETCODE		CParserEngine::ParseParamsString(CHARVECTOR& cvTokens,
											CHARVECTOR::iterator& theIterator,
											CParsedInfo& rParsedInfo,
											XSLTDET& xdXSLTDet)
{
	RETCODE retCode = PARSER_EXECCOMMAND ;

	try
	{
		if ( !GetNextToken(cvTokens, theIterator) )
		{
			rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_FORMAT);
			retCode = PARSER_ERROR;
		}
		else if ( IsOption(*theIterator) )
		{
			rParsedInfo.GetCmdSwitchesObject().
					SetErrataCode(IDS_E_INVALID_FORMAT);
			retCode = PARSER_ERROR;
		}
		else
		{
			while ( retCode == PARSER_EXECCOMMAND )
			{
		
				_TCHAR*		pszParam		= NULL;
				_TCHAR*		pszParamValue	= NULL;

				pszParam = _tcstok(*theIterator,CLI_TOKEN_EQUALTO);

				if(pszParam != NULL)
				{
					pszParamValue = _tcstok(NULL,CLI_TOKEN_EQUALTO);
					if(pszParamValue != NULL)
					{
						_bstr_t bstrParam = pszParam;
						_bstr_t bstrParamValue = pszParamValue;
						if(IsOption(pszParamValue))
						{
							rParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(IDS_E_INVALID_FORMAT);
							retCode = PARSER_ERROR;
						}
						else
							xdXSLTDet.ParamMap.insert(BSTRMAP::value_type(
												  bstrParam, bstrParamValue));

					}
					else
					{	rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_COMMAND);
						retCode = PARSER_ERROR;
					}
				}
				else
				{
					rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_FORMAT);
					retCode = PARSER_ERROR;
				}

				if ( retCode == PARSER_EXECCOMMAND )
				{
					if ( !GetNextToken(cvTokens, theIterator) )
						break;
					else if ( IsOption(*theIterator) )
					{
						break;
					}
					else if (CompareTokens(*theIterator, CLI_TOKEN_COMMA))
					{
						break;
					}
					else if(CompareTokens(*theIterator, CLI_TOKEN_COLON))
					{	
						if ( !GetNextToken(cvTokens, theIterator) )
							break;
					}
					// if invalid token is there that is other 
					// than ':' '/' or ','
					else 
					{	rParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(IDS_E_INVALID_COMMAND);
						retCode = PARSER_ERROR;
					}
				}
			}
		}
	}
	catch(_com_error& e)
	{
		retCode = PARSER_ERROR;
		_com_issue_error(e.Error());
	}
	return retCode;
}

/*----------------------------------------------------------------------------
Name				 :ParseNodeListFile
Synopsis	         :Parses the node list file.
Type	             :Member Function
Input Parameter(s)   :
	rParsedInfo		 - reference to CParsedInfo class object.	
	cvTokens		 - the tokens vector 
	theIterator		 - the Iterator to the cvTokens vector.	
Output Parameter(s)  :
	rParsedInfo		 - reference to CParsedInfo class object
Return Type          :RETCODE
Global Variables     :None
Calling Syntax       :ParseNodeListFile(cvTokens, theIterator,rParsedInfo);
Notes                :None
----------------------------------------------------------------------------*/
RETCODE	CParserEngine::ParseNodeListFile(CHARVECTOR& cvTokens,
								   	     CHARVECTOR::iterator& theIterator,
										 CParsedInfo& rParsedInfo)
{
	RETCODE				retCode					= PARSER_CONTINUE;
	_TCHAR				*pszTempFileName		= (*theIterator+1);
	_TCHAR				*szNodeListFileName		= new _TCHAR [BUFFER512];
	if (szNodeListFileName == NULL)
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);

	lstrcpy(szNodeListFileName, pszTempFileName);
	UnQuoteString(szNodeListFileName);
	FILE				*fpNodeListFile			= 
										_tfopen(szNodeListFileName, _T("rb"));
	LONG				lNumberOfInserts		= 0;
	CHARVECTOR::iterator itrVectorInCmdTkzr		= NULL;
	_TCHAR				*pszComma				= NULL;
	_TCHAR				*pszNode				= NULL;
	FILETYPE			eftNodeFileType			= ANSI_FILE;
	char				*pszFirstTwoBytes		= NULL;
	
	try
	{
		if ( fpNodeListFile != NULL )
		{
			Find(m_CmdTknzr.GetTokenVector(), *theIterator, itrVectorInCmdTkzr);
			SAFEDELETE(*itrVectorInCmdTkzr);
			itrVectorInCmdTkzr = m_CmdTknzr.GetTokenVector().erase(itrVectorInCmdTkzr);

			// Remove @nodelistfile token from token vector.
			theIterator = cvTokens.erase(theIterator);

			// get type of file
			eftNodeFileType = ReturnFileType ( fpNodeListFile ) ;

			_TCHAR	szNodeName[BUFFER512] = NULL_STRING;

			if ( GetNodeFromNodeFile(fpNodeListFile, eftNodeFileType,
														szNodeName) == FALSE )
			{
				rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
														IDS_E_NODELISTFILE_EMPTY);
				retCode = PARSER_ERROR;
			}
			else
			{
				BOOL	bFirstTime = TRUE;
				do
				{
					LONG lNodeStrLen = lstrlen(szNodeName); 
					if ( szNodeName[lNodeStrLen-1] == _T('\n') )
						szNodeName[lNodeStrLen-1] = _T('\0');

					CHString strRawNodeName(szNodeName);
					strRawNodeName.TrimLeft();
					strRawNodeName.TrimRight();

					lstrcpy(szNodeName, strRawNodeName.GetBuffer(BUFFER512));

					if ( szNodeName[0] != _T('#') &&
						 strRawNodeName.IsEmpty() == FALSE )
					{
						if ( bFirstTime == FALSE )
						{
							pszComma = new _TCHAR[lstrlen(
														CLI_TOKEN_COMMA) + 1];
							if (pszComma == NULL)
								_com_issue_error(WBEM_E_OUT_OF_MEMORY);

							lstrcpy(pszComma, CLI_TOKEN_COMMA);
							theIterator = cvTokens.insert(theIterator, pszComma);
							theIterator++;
							itrVectorInCmdTkzr = m_CmdTknzr.GetTokenVector().
													insert(itrVectorInCmdTkzr,
														   pszComma);
							itrVectorInCmdTkzr++;
							lNumberOfInserts++;
						}
						else
							bFirstTime = FALSE;

						lNodeStrLen = lstrlen(szNodeName);

						pszNode = new _TCHAR[lNodeStrLen + 1];
						if (pszNode == NULL)
							_com_issue_error(WBEM_E_OUT_OF_MEMORY);

						lstrcpy(pszNode, szNodeName);

						theIterator = cvTokens.insert(theIterator, pszNode);
						theIterator++;
						itrVectorInCmdTkzr = m_CmdTknzr.GetTokenVector().insert(
													 itrVectorInCmdTkzr, pszNode);
						itrVectorInCmdTkzr++;
						lNumberOfInserts++;
					}
				}
				while ( GetNodeFromNodeFile(fpNodeListFile, eftNodeFileType,
														szNodeName) == TRUE );

				if ( lNumberOfInserts == 0 )
				{
					rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
													IDS_E_NO_NODES_FOR_INSERTION);
					retCode = PARSER_ERROR;
				}

				theIterator = theIterator - lNumberOfInserts;
			}

			fclose(fpNodeListFile);
		}
		else
		{
			rParsedInfo.GetCmdSwitchesObject().SetErrataCode(
												 IDS_E_NODELISTFILE_OPEN_FAILURE);
			retCode = PARSER_ERROR;
		}
		SAFEDELETE(szNodeListFileName);
	}
	catch(CHeap_Exception)
	{
		retCode = PARSER_ERROR;
		SAFEDELETE(szNodeListFileName);
		SAFEDELETE(pszFirstTwoBytes);
		retCode = PARSER_ERROR;
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
	catch(_com_error& e)
	{
		retCode = PARSER_ERROR;
		SAFEDELETE(szNodeListFileName);
		SAFEDELETE(pszComma);
		SAFEDELETE(pszNode);
		SAFEDELETE(pszFirstTwoBytes);
		_com_issue_error(e.Error());
	}
	return retCode;
}


/*----------------------------------------------------------------------------
Name				 :GetNodeFromNodeFile
Synopsis	         :Retrieves the node list file.
Type	             :Member Function
Input Parameter(s)   :
	fpNodeListFile	 - pointer to File containing node list.
	eftNodeFileType  - Enum value specifing unicode or ANSI ....
Output Parameter(s)  :
	szNodeName		 - pointer to string specifing node to be returned.	
Return Type          :BOOL
Global Variables     :None
Calling Syntax       :GetNodeFromNodeFile(fpNodeListFile, eftNodeFileType,
																  szNodeName);
Notes                :None
----------------------------------------------------------------------------*/
BOOL CParserEngine::GetNodeFromNodeFile(FILE*	 fpNodeListFile, 
										FILETYPE eftNodeFileType,
										_TCHAR*	 szNodeName)
{
	WCHAR		wszNodeName[2]			= L"";
	char		cszNodeName[2]			= "";
	_TCHAR		szTemp[2]				= NULL_STRING; 

	try
	{
		lstrcpy(szNodeName, NULL_STRING);

		while( TRUE )
		{
			lstrcpy(szTemp, NULL_STRING);
			
			if ( eftNodeFileType == UNICODE_FILE )
			{
				if ( fgetws(wszNodeName, 2, fpNodeListFile) != NULL )
				{
					lstrcpy(szTemp, (_TCHAR*)_bstr_t(wszNodeName));
				}
				else
					break;
			}
			else if ( eftNodeFileType == UNICODE_BIGENDIAN_FILE )
			{
				if ( fgetws(wszNodeName, 2, fpNodeListFile) != NULL )
				{
					BYTE HiByte = HIBYTE(wszNodeName[0]);
					BYTE LowByte = LOBYTE(wszNodeName[0]);
					wszNodeName[0] = MAKEWORD(HiByte, LowByte);
					lstrcpy(szTemp, (_TCHAR*)_bstr_t(wszNodeName));
				}
				else
					break;
			}
			else if ( eftNodeFileType == UTF8_FILE )
			{
				if ( fgets(cszNodeName, 2, fpNodeListFile) != NULL )
				{
					MultiByteToWideChar(
					  CP_UTF8,         // code page
					  0,         // character-type options
					  cszNodeName, // string to map
					  2,       // number of bytes in string
					  wszNodeName,  // wide-character buffer
					  2        // size of buffer
						);
					lstrcpy(szTemp, (_TCHAR*)_bstr_t(wszNodeName));
				}
				else
					break;
			}
			else
			{
				if ( fgets(cszNodeName, 2, fpNodeListFile) != NULL )
				{
					lstrcpy(szTemp, (_TCHAR*)_bstr_t(cszNodeName));
				}
				else
					break;
			}

			if ( _tcscmp(szTemp, CLI_TOKEN_SPACE)		== 0	||
				 _tcscmp(szTemp, CLI_TOKEN_TAB)			== 0	||
				 _tcscmp(szTemp, CLI_TOKEN_SEMICOLON)	== 0	||
				 _tcscmp(szTemp, CLI_TOKEN_COMMA)		== 0	||
				 _tcscmp(szTemp, CLI_TOKEN_DOUBLE_QUOTE)== 0	||
				 _tcscmp(szTemp, CLI_TOKEN_NEWLINE)		== 0 )
			{
				break;
			}
			else
			{
				lstrcat(szNodeName, szTemp);
			}
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}

	return (!feof(fpNodeListFile) || _tcscmp(szNodeName, NULL_STRING));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\wcmain.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: wcmain.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: The _tmain function is the entry point of the
							  WMICli program.  
Revision History			: 
	Last Modified by		:Biplab Mistry
	Last Modified date		:4/11/00
****************************************************************************/ 

// wcmain.cpp :main function implementation file
#include "Precomp.h"
	
#include "CommandSwitches.h"
#include "GlobalSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "ErrorInfo.h"
#include "WmiCliXMLLog.h"
#include "FormatEngine.h"
#include "WmiCmdLn.h"


#include <string>
#include <ScopeGuard.h>

CWMICommandLine g_wmiCmd;
wstring g_pszBuffer;

//
// COM initialization
//
class COMInitializator
{
	protected:

	BOOL m_bIsInitialized ;

	public :

	COMInitializator ( ) : m_bIsInitialized ( FALSE )
	{
		// Initialize the COM library
		if ( SUCCEEDED ( CoInitializeEx(NULL, COINIT_MULTITHREADED) ) )
		{
			m_bIsInitialized = TRUE ;
		}
	}

	~COMInitializator ()
	{
		if ( TRUE == m_bIsInitialized )
		{
			CoUninitialize () ;
		}
	}

	BOOL IsInitialized () const
	{
		return m_bIsInitialized ;
	}
};


/*------------------------------------------------------------------------
   Name				 :_tmain
   Synopsis	         :This function takes the error code as input and return
						an error string
   Type	             :Member Function
   Input parameters   :
      argc			 :argument count
	  argv			 :Pointer to string array storing command line arguments
   Output parameters :None
   Return Type       :Integer
   Global Variables  :None
   Calling Syntax    :
   Calls             :CWMICommandLine::Initialize,
					  CWMICommandLine::UnInitialize,
					  CFormatEngine::DisplayResults,
					  CWMICommandLine::ProcessCommandAndDisplayResults
					  
   Called by         :None
   Notes             :None
------------------------------------------------------------------------*/
__cdecl _tmain(WMICLIINT argc, _TCHAR **argv)
{
	SESSIONRETCODE	ssnRetCode			= SESSION_SUCCESS;
	BOOL			bFileEmpty			= FALSE;
	bool			bIndirectionInput	= false;
	FILE			*fpInputFile		= NULL;
	WMICLIUINT		uErrLevel			= 0;

	try
	{
		//
		// initialization
		//
		COMInitializator InitCOM;
		if ( InitCOM.IsInitialized () )
		{
			_bstr_t bstrBuf;
			
			if (g_wmiCmd.GetCtrlHandlerError())
			{
				g_wmiCmd.SetCtrlHandlerError(FALSE);

				//Set the sucess flag to FALSE 
				g_wmiCmd.GetParsedInfoObject().GetCmdSwitchesObject().
											   SetSuccessFlag(FALSE);
		
				ssnRetCode	= SESSION_ERROR;
				g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
				uErrLevel = g_wmiCmd.GetSessionErrorLevel();
			}
			else if ( g_wmiCmd.Initialize () )
			{
				ON_BLOCK_EXIT_OBJ ( g_wmiCmd, CWMICommandLine::Uninitialize ) ;

				HANDLE hStd=GetStdHandle(STD_INPUT_HANDLE);
				
				if(hStd != (HANDLE)0x00000003 && hStd != INVALID_HANDLE_VALUE && hStd != (HANDLE)0x0000000f)
				{
					if (!(g_wmiCmd.ReadXMLOrBatchFile(hStd)) || (fpInputFile = _tfopen(TEMP_BATCH_FILE, _T("r"))) == NULL)
					{  
						g_wmiCmd.SetSessionErrorLevel(SESSION_ERROR);
						uErrLevel = g_wmiCmd.GetSessionErrorLevel();
						return uErrLevel;
					}
					bIndirectionInput = true;
				}

				ON_BLOCK_EXIT_IF ( bIndirectionInput, fclose, fpInputFile ) ;
				ON_BLOCK_EXIT_IF ( bIndirectionInput, DeleteFile, TEMP_BATCH_FILE ) ;

				// If no command line arguments are specified.
				if (argc == 1)
				{
					BOOL bSuccessScreen = TRUE;
					if ( hStd != (HANDLE)0x00000013 )
					{
						// avoid setting screen buffer for telnet
						bSuccessScreen = g_wmiCmd.ScreenBuffer ();
					}

					while (TRUE)
					{
						OUTPUTSPEC opsOutOpt = g_wmiCmd.GetParsedInfoObject().
														GetGlblSwitchesObject().
														GetOutputOrAppendOption(TRUE);

						OUTPUTSPEC opsSavedOutOpt = opsOutOpt;
						CHString chsSavedOutFileName;
						if ( opsSavedOutOpt == FILEOUTPUT )
							chsSavedOutFileName = 
												g_wmiCmd.GetParsedInfoObject().
														GetGlblSwitchesObject().
														GetOutputOrAppendFileName(TRUE);

						// Make propmt to be diplayed to stdout.
						if ( opsOutOpt != STDOUT )
						{
							g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									SetOutputOrAppendOption(STDOUT, TRUE);
						}
						
						// Preserve append file pointer.
						FILE* fpAppend = 
							g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									GetOutputOrAppendFilePointer(FALSE);

						// Set append file pointer = null.
						g_wmiCmd.GetParsedInfoObject().
								GetGlblSwitchesObject().
								SetOutputOrAppendFilePointer(NULL, FALSE);

						//Set Interactive Mode ON

						g_wmiCmd.GetParsedInfoObject().
								GetGlblSwitchesObject().
								SetInteractiveMode(TRUE);

						// Display the prompt;
						bstrBuf = _bstr_t(EXEC_NAME);
						bstrBuf += _bstr_t(":");
						bstrBuf += _bstr_t(g_wmiCmd.GetParsedInfoObject().
													GetGlblSwitchesObject().GetRole());
						bstrBuf += _bstr_t(">");
						DisplayMessage(bstrBuf, CP_OEMCP, FALSE, FALSE);

						// To handle Ctrl+C at propmt, Start accepting command
						g_wmiCmd.SetAcceptCommand(TRUE);

						// To handle batch input from file.
						_TCHAR *pBuf = NULL;
						while(TRUE)
						{
							WCHAR* buffer = NULL ;
							if ( NULL != ( buffer = new WCHAR [ MAX_BUFFER ] ) )
							{
								ScopeGuard bufferAuto = MakeGuard ( deleteArray < WCHAR >, ByRef ( buffer ) ) ;

								if ( bIndirectionInput == true )
								{
									pBuf = _fgetts(buffer, MAX_BUFFER-1, fpInputFile);
								}
								else
								{
									pBuf = _fgetts(buffer, MAX_BUFFER-1, stdin);
								}

								if(pBuf != NULL)
								{
									//
									// fgetws applies mbtowc to each byte
									// prior to returning wide string
									//

									//
									// wmic must revert and provide correct conversion
									//

									LPSTR pszBuffer = NULL ;
									if ( Revert_mbtowc ( buffer, &pszBuffer ) )
									{
										ScopeGuard pszBufferAuto = MakeGuard ( deleteArray < CHAR >, pszBuffer ) ;

										LPWSTR wszBuffer = NULL ;
										ScopeGuard wszBufferAuto = MakeGuard ( deleteArray < WCHAR >, ByRef ( wszBuffer ) ) ;

										if ( ConvertMBCSToWC ( pszBuffer, (LPVOID*) &wszBuffer, CP_OEMCP ) )
										{
											g_pszBuffer = wszBuffer ;
										}
										else
										{
											// Set the bFileEmpty flag to TRUE to break main loop
											bFileEmpty = TRUE;

											ssnRetCode = SESSION_ERROR;
											g_wmiCmd.GetParsedInfoObject().GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
											g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
											uErrLevel = g_wmiCmd.GetSessionErrorLevel();

											break ;
										}
									}
									else
									{
										// Set the bFileEmpty flag to TRUE to break main loop
										bFileEmpty = TRUE;

										ssnRetCode = SESSION_ERROR;
										g_wmiCmd.GetParsedInfoObject().GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
										g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
										uErrLevel = g_wmiCmd.GetSessionErrorLevel();

										break ;
									}

									if ( bIndirectionInput == true )
									{
										DisplayMessage ( g_pszBuffer.begin (), CP_OEMCP, FALSE, FALSE ) ;
									}

									LONG lInStrLen = g_pszBuffer.size();
									if(g_pszBuffer[lInStrLen - 1] == _T('\n'))
										g_pszBuffer[lInStrLen - 1] = _T('\0');
									break;
								}
								else
								{
									// Set the bFileEmpty flag to TRUE
									bFileEmpty = TRUE;
									break;
								}
							}
							else
							{
								// Set the bFileEmpty flag to TRUE to break main loop
								bFileEmpty = TRUE;

								ssnRetCode = SESSION_ERROR;
								g_wmiCmd.GetParsedInfoObject().GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
								g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
								uErrLevel = g_wmiCmd.GetSessionErrorLevel();

								break ;
							}
						}	

						// To handle Ctrl+C at propmt, End accepting command
						// and start of executing command
						g_wmiCmd.SetAcceptCommand(FALSE);

						// Set append file pointer = saved.
						g_wmiCmd.GetParsedInfoObject().
								GetGlblSwitchesObject().
								SetOutputOrAppendFilePointer(fpAppend, FALSE);

						// Redirect the output back to file specified.
						if ( opsOutOpt != STDOUT )
						{
							g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									SetOutputOrAppendOption(opsOutOpt, TRUE);
						}

						// Set the error level to success.
						g_wmiCmd.SetSessionErrorLevel(SESSION_SUCCESS);

						// If all the commands in the batch file got executed.
						if (bFileEmpty)
						{
							break;
						}

						// Set Break Event to False
						g_wmiCmd.SetBreakEvent(FALSE);

						// Clear the clipboard.
						g_wmiCmd.EmptyClipBoardBuffer();
						
						// Process the command and display results.
						ssnRetCode = g_wmiCmd.ProcessCommandAndDisplayResults ( g_pszBuffer.begin () );
						uErrLevel = g_wmiCmd.GetSessionErrorLevel();

						// Break the loop if "QUIT" keyword is keyed-in.
						if(ssnRetCode == SESSION_QUIT)
						{
							break;
						}

						opsOutOpt = g_wmiCmd.GetParsedInfoObject().
											GetGlblSwitchesObject().
											GetOutputOrAppendOption(TRUE);

						if ( opsOutOpt == CLIPBOARD )
							CopyToClipBoard(g_wmiCmd.GetClipBoardBuffer());

						if ( ( opsOutOpt != FILEOUTPUT && 
							CloseOutputFile() == FALSE ) ||
							CloseAppendFile() == FALSE )
						{
							break;
						}

						if ( g_wmiCmd.GetParsedInfoObject().
									GetCmdSwitchesObject().
									GetOutputSwitchFlag() == TRUE )
						{
							if ( opsOutOpt	== FILEOUTPUT &&
								CloseOutputFile() == FALSE )
							{
								break;
							}

							g_wmiCmd.GetParsedInfoObject().
									GetCmdSwitchesObject().
									SetOutputSwitchFlag(FALSE);

							if ( opsOutOpt	== FILEOUTPUT )
								g_wmiCmd.GetParsedInfoObject().
										GetGlblSwitchesObject().
										SetOutputOrAppendFileName(NULL, TRUE);

							g_wmiCmd.GetParsedInfoObject().
									GetGlblSwitchesObject().
									SetOutputOrAppendOption(opsSavedOutOpt, TRUE);

							if ( opsSavedOutOpt	== FILEOUTPUT )
								g_wmiCmd.GetParsedInfoObject().
											GetGlblSwitchesObject().
											SetOutputOrAppendFileName(
																	_bstr_t((LPCWSTR)chsSavedOutFileName),
																	TRUE);
						}
					}

					if ( hStd != (HANDLE)0x00000013 )
					{
						// avoid re-setting screen buffer for telnet
						bSuccessScreen = g_wmiCmd.ScreenBuffer ( FALSE );
					}
				}
				// If command line arguments are specified.
				else 
				{
					// Obtain the command line string
					g_pszBuffer = GetCommandLine();
					if ( FALSE == g_pszBuffer.empty() )
					{
						// Set the error level to success.
						g_wmiCmd.SetSessionErrorLevel(SESSION_SUCCESS);

						// Process the command and display results.
						wstring::iterator BufferIter = g_pszBuffer.begin () ;
						while( BufferIter != g_pszBuffer.end() )
						{
							if ( *BufferIter == L' ' )
							{
								break ;
							}

							BufferIter++ ;
						}

						if ( BufferIter != g_pszBuffer.end () )
						{
							ssnRetCode = g_wmiCmd.ProcessCommandAndDisplayResults ( BufferIter ) ;
							uErrLevel = g_wmiCmd.GetSessionErrorLevel();
							OUTPUTSPEC opsOutOpt;
							opsOutOpt = g_wmiCmd.GetParsedInfoObject().
												GetGlblSwitchesObject().
												GetOutputOrAppendOption(TRUE);
							if ( opsOutOpt == CLIPBOARD )
									CopyToClipBoard(g_wmiCmd.GetClipBoardBuffer());
						}
					}
				}
			}
		}
		else
		{
			// If COM error.
			if (g_wmiCmd.GetParsedInfoObject().GetCmdSwitchesObject().GetCOMError())
			{
				g_wmiCmd.GetFormatObject().DisplayResults(g_wmiCmd.GetParsedInfoObject());
			}

			g_wmiCmd.SetSessionErrorLevel ( SESSION_ERROR ) ;
			uErrLevel = g_wmiCmd.GetSessionErrorLevel();
		}
	}
	catch(...)
	{
		g_wmiCmd.GetParsedInfoObject().GetCmdSwitchesObject().SetErrataCode(UNKNOWN_ERROR);
		g_wmiCmd.SetSessionErrorLevel(SESSION_ERROR);
		DisplayString(IDS_E_WMIC_UNKNOWN_ERROR, CP_OEMCP, NULL, TRUE, TRUE);
		uErrLevel = g_wmiCmd.GetSessionErrorLevel();
	}

	return uErrLevel;
}

/*------------------------------------------------------------------------
   Name				 :CtrlHandler
   Synopsis	         :Handler routine to handle CTRL + C so as free
					  the memory allocated during the program execution.   
   Type	             :Global Function
   Input parameters  :
		fdwCtrlType	 - control handler type
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :
			g_wmiCmd    - wmi command line object
   Notes             :None
------------------------------------------------------------------------*/
BOOL CtrlHandler(DWORD fdwCtrlType) 
{
	BOOL bRet = FALSE;

	COMInitializator InitCOM ;
	if ( InitCOM.IsInitialized () )
	{
		switch (fdwCtrlType) 
		{
			case CTRL_C_EVENT:
				// if at command propmt
				if ( g_wmiCmd.GetAcceptCommand() == TRUE )
				{
					g_wmiCmd.Uninitialize();
					bRet = FALSE; 
				}
				else // executing command
				{
					g_wmiCmd.SetBreakEvent(TRUE);
					bRet = TRUE;
				}
			break;

			case CTRL_CLOSE_EVENT: 
			default: 
				g_wmiCmd.Uninitialize();
				bRet = FALSE; 
			break;
		} 
	}

	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CloseOutputFile
   Synopsis	         :Close the output file.
   Type	             :Global Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :
			g_wmiCmd    - wmi command line object
   Calling Syntax	 :CloseOutputFile()	
   Notes             :None
------------------------------------------------------------------------*/
BOOL CloseOutputFile()
{
	BOOL bRet = TRUE;

	// TRUE for getting output file pointer.
	FILE* fpOutputFile = 
	   g_wmiCmd.GetParsedInfoObject().GetGlblSwitchesObject().
									  GetOutputOrAppendFilePointer(TRUE);

	// If currently output is going to file close the file.
	if ( fpOutputFile != NULL )
	{
		if ( fclose(fpOutputFile) == EOF )
		{
			DisplayString(IDS_E_CLOSE_OUT_FILE_ERROR, CP_OEMCP, 
						NULL, TRUE, TRUE);
			bRet = FALSE;
		}
		else // TRUE for setting output file pointer.
			g_wmiCmd.GetParsedInfoObject().GetGlblSwitchesObject().
										   SetOutputOrAppendFilePointer(NULL, TRUE);
	}

	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CloseAppendFile
   Synopsis	         :Close the append file.
   Type	             :Global Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :
			g_wmiCmd    - wmi command line object
   Calling Syntax	 :CloseAppendFile()	
   Notes             :None
------------------------------------------------------------------------*/
BOOL CloseAppendFile()
{
	BOOL bRet = TRUE;

	// FALSE for getting append file pointer.
	FILE* fpAppendFile = 
	   g_wmiCmd.GetParsedInfoObject().GetGlblSwitchesObject().
									  GetOutputOrAppendFilePointer(FALSE);

	if ( fpAppendFile != NULL )
	{
		if ( fclose(fpAppendFile) == EOF )
		{
			DisplayString(IDS_E_CLOSE_APPEND_FILE_ERROR, CP_OEMCP, 
						NULL, TRUE, TRUE);
			bRet = FALSE;
		}
		else // FASLE for setting output file pointer.
			g_wmiCmd.GetParsedInfoObject().GetGlblSwitchesObject().
										   SetOutputOrAppendFilePointer(NULL, FALSE);
	}

	return bRet;
}

/*------------------------------------------------------------------------
   Name				 :CopyToClipBoard
   Synopsis	         :Copy data to clip board.
   Type	             :Global Function
   Input parameters  :
		chsClipBoardBuffer - reference to object of type CHString.
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax	 :CopyToClipBoard(chsClipBoardBuffer)	
   Notes             :None
------------------------------------------------------------------------*/
void CopyToClipBoard(CHString& chsClipBoardBuffer)
{
	HGLOBAL	hMem = CopyStringToHGlobal((LPCWSTR)chsClipBoardBuffer);
	if (hMem != NULL)
	{    
		if (OpenClipboard(NULL))        
		{        
			EmptyClipboard();
			SetClipboardData(CF_UNICODETEXT, hMem);        
			CloseClipboard();        
		}    
		else        
			GlobalFree(hMem);  //We must clean up.
	}
}

/*------------------------------------------------------------------------
   Name				 :CopyStringToHGlobal
   Synopsis	         :Copy string to global memory.
   Type	             :Global Function
   Input parameters  :
			psz		 - LPCWSTR type, specifying string to get memory allocated.
   Output parameters :None
   Return Type       :HGLOBAL
   Global Variables  :None
   Calling Syntax	 :CopyStringToHGlobal(psz)	
   Notes             :None
------------------------------------------------------------------------*/
HGLOBAL CopyStringToHGlobal(LPCWSTR psz)    
{    
	HGLOBAL    hMem;
	LPTSTR     pszDst;
	hMem = GlobalAlloc(GHND, (DWORD) (lstrlen(psz)+1) * sizeof(TCHAR));
	
	if (hMem != NULL)
	{        
		pszDst = (LPTSTR) GlobalLock(hMem);        
		lstrcpy(pszDst, psz);
        GlobalUnlock(hMem);        
	}
	
	return hMem;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WmiCli.rc
//
#define IDS_E_BLANK_COMMAND_MESSAGE     44001
#define IDS_E_INCOMPLETE_COMMAND        44002
#define IDS_E_RPC_SERVER_NOT_AVAILABLE  44003
#define IDS_E_0_REPEAT_NOT_WITH_0_EVERY 44004
#define IDS_E_INVALID_COMMAND           44005
#define IDS_E_INVALID_REPEAT_SWITCH     44006
#define IDS_E_INVALID_LIST_USAGE        44007
#define IDS_E_INVALID_REPEATCOUNT       44008
#define IDS_E_0_EVERY_NOT_WITH_0_REPEAT 44009
#define IDS_E_PWHERE_UNDEF              44010
#define IDS_E_CLOSE_OUT_FILE_ERROR      44011
#define IDS_E_INVALID_TRANSLATE_SWITCH  44012
#define IDS_E_TRANSLATE_TABLE_NOT_EXIST 44013
#define IDS_I_NOEXECUTE                 44014
#define IDS_E_VERBS_NOT_AVAIL           44015
#define IDS_E_CLASSMETHS_NOT_AVAIL      44016
#define IDS_E_STDOUT_REDIR_FAIL         44017
#define IDS_E_FILE_ALREADY_OPEN_FOR_APPEND 44018
#define IDS_E_OUTPUT_FILE_ALREADY_OPEN_FOR_APPEND 44018
#define IDS_E_FILE_ALREADY_OPEN_FOR_OUTPUT 44019
#define IDS_E_APPEND_FILE_ALREADY_OPEN_FOR_OUTPUT 44019
#define IDS_E_CLOSE_APPEND_FILE_ERROR   44020
#define INVALID_E_FILE_NAME_OPENS_WITH_NAME 44021
#define IDS_E_VERB_DERV_NOT_AVAIL_IN_ALIAS 44022
#define IDS_E_INVALID_FILENAME          44023
#define IDS_E_REDIRECTION_FAIL          44024
#define IDS_E_FILE_ALREADY_OPEN_FOR_RECORD 44025
#define IDS_E_OUTPUT_FILE_ALREADY_OPEN_FOR_RECORD 44025
#define IDS_E_RECORD_FILE_ALREADY_OPEN_FOR_OUTPUT 44026
#define IDS_E_RECORD_FILE_ALREADY_OPEN_FOR_APPEND 44027
#define IDS_E_INVALID_CLASS_METHOD      44028
#define IDS_E_INVALID_ALIAS_VERB        44029
#define IDS_E_NODELISTFILE_OPEN_FAILURE 44030
#define IDS_E_NODELISTFILE_EMPTY        44031
#define IDS_E_NO_NODES_FOR_INSERTION    44032
#define IDS_E_APPEND_FILE_ALREADY_OPEN_FOR_RECORD 44033
#define IDS_E_INVALID_NAMESPACE_SYNTAX  44102
#define IDS_E_INVALID_MACHINE_NAME      44103
#define IDS_E_INVALID_IMP_LEVEL         44104
#define IDS_E_INVALID_AUTH_LEVEL        44105
#define IDS_E_INVALID_LOCALE            44106
#define IDS_E_INCORRECT_NAMESPACE       44107
#define IDS_E_INVALID_NODE_SYNTAX       44108
#define IDS_E_INVALID_IMP_LEVEL_SYNTAX  44109
#define IDS_E_INVALID_ROLE_SYNTAX       44110
#define IDS_E_INVALID_AUTH_LEVEL_SYNTAX 44111
#define IDS_E_INVALID_LOCALE_SYNTAX     44112
#define IDS_E_INVALID_PRIVILEGES_SYNTAX 44113
#define IDS_E_INVALID_PRIVILEGES        44114
#define IDS_E_INVALID_TRACE_SYNTAX      44115
#define IDS_E_INVALID_TRACE_OPTION      44116
#define IDS_E_INVALID_RECORD_SYNTAX     44117
#define IDS_E_INVALID_RECORD_PATH       44118
#define IDS_E_INVALID_USER_SYNTAX       44119
#define IDS_E_INVALID_USER_ID           44120
#define IDS_E_INVALID_PASSWORD_SYNTAX   44121
#define IDS_E_INVALID_PASSWORD          44122
#define IDS_E_INVALID_HELP_OPTION       44123
#define IDS_E_INVALID_HELP_SYNTAX       44124
#define IDS_E_INVALID_GLOBAL_SWITCH     44125
#define IDS_E_INVALID_PRIVILEGES_OPTION 44126
#define IDS_E_INVALID_CODEPAGE          44127
#define IDS_E_INVALID_CODEPAGE_SYNTAX   44128
#define IDS_E_INVALID_ROLE              44129
#define IDS_E_INVALID_LIST_SWITCH       44130
#define IDS_E_PASSWORD_WITHOUT_USER     44131
#define IDS_E_INVALID_NAMESPACE         44132
#define IDS_E_INVALID_NODE              44133
#define IDS_E_INVALID_INTERACTIVE_OPTION 44134
#define IDS_E_ALIAS_NOT_FOUND           44135
#define IDS_E_INVALID_FAILFAST_OPTION   44136
#define IDS_E_INVALID_OUTPUT_OPTION     44137
#define IDS_E_INVALID_OUTPUT_SYNTAX     44138
#define IDS_E_INVALID_APPEND_OPTION     44139
#define IDS_E_INVALID_APPEND_SYNTAX     44140
#define IDS_E_OPEN_APPEND_FILE_FAILURE  44141
#define IDS_E_OPEN_OUTPUT_FILE_FAILURE  44142
#define IDS_E_INVALID_AGGREGATE_OPTION  44143
#define IDS_E_INVALID_AGGREGATE_SYNTAX  44144
#define IDS_E_INVALID_PATH              44201
#define IDS_E_INVALID_QUERY             44202
#define IDS_E_INVALID_EXPRESSION        44204
#define IDS_E_INVALID_VERB              44205
#define IDS_E_INVALID_INTERVAL          44206
#define IDS_E_INVALID_PATH_SYNTAX       44207
#define IDS_E_INVALID_WHERE_SYNTAX      44208
#define IDS_E_INVALID_CLASS_SYNTAX      44209
#define IDS_E_INVALID_FORMAT            44210
#define IDS_E_INVALID_LIST_FORMAT       44211
#define IDS_E_INVALID_GET_SWITCH        44212
#define IDS_E_INVALID_XML_CONTENT       44213
#define IDS_E_INVALID_LIST_EXPRESSION   44214
#define IDS_E_INVALID_CLASS             44215
#define IDS_E_INVALID_INTERIM_XML_CONTENT 44216
#define IDS_E_REGMOF_FAILED             44217
#define IDS_E_ERRLOG_WRITEFAIL          44218
#define IDS_E_ERRLOG_OPENFAIL           44219
#define IDS_E_INVALID_GET_EXPRESSION    44220
#define IDS_E_INVALID_ALIAS_COMMAND     44503
#define IDS_E_MEMALLOC_FAIL             44504
#define IDS_E_INVALID_EVERY_SWITCH      44505
#define IDS_E_INVALID_VERB_SWITCH       44506
#define IDS_E_INVALID_NO_OF_PARAMS      44507
#define IDS_E_INVALID_NAMED_PARAM_LIST  44508
#define IDS_E_CMD_INTERPTR_NOT_FOUND    44509
#define IDS_E_CMD_INTPTR_INVALID_FORMAT 44510
#define IDS_E_NOT_ENOUGH_MEM_AVLBL      44511
#define IDS_E_ALIAS_OR_PATH_SHOULD_PRECEED_WHERE 44512
#define IDS_E_INVALID_PWHERE_EXPR       44513
#define IDS_E_INVALID_INTERACTIVE_SYNTAX 44514
#define IDS_E_INVALID_FAILFAST_SYNTAX   44515
#define IDS_E_WRITELOG_FAILED           44516
#define IDS_E_NOT_A_INPUT_PARAM         44517
#define IDS_E_METHOD_HAS_NO_IN_PARAMS   44518
#define IDS_E_INAVALID_PROP_LIST        44519
#define IDS_E_WMIC_UNKNOWN_ERROR        44520
#define IDS_I_USAGE                     45001
#define IDS_I_GET_DESC                  45002
#define IDS_I_GET_USAGE                 45003
#define IDS_I_GET_SWITCH_HEAD           45004
#define IDS_I_GET_SWITCH_VALUE          45005
#define IDS_I_GET_SWITCH_ALL            45006
#define IDS_I_SWITCH_TRANSLATE          45007
#define IDS_I_SWITCH_EVERY              45008
#define IDS_I_SWITCH_FORMAT             45009
#define IDS_I_NEWLINE                   45010
#define IDS_I_LIST_DESC                 45011
#define IDS_I_LIST_USAGE                45012
#define IDS_I_LIST_NOFORMATS            45013
#define IDS_I_LIST_FMT_HEAD             45014
#define IDS_I_LIST_SWITCH_HEAD          45015
#define IDS_I_CALL_DESC                 45016
#define IDS_I_CALL_USAGE                45017
#define IDS_I_CALL_PARAM_NOTE           45018
#define IDS_I_SET_DESC                  45019
#define IDS_I_SET_USAGE                 45020
#define IDS_I_ASSIGNLIST_NOTE1          45021
#define IDS_I_ASSIGNLIST_NOTE2          45022
#define IDS_I_CREATE_DESC               45023
#define IDS_I_PROPERTYLIST_NOTE1        45024
#define IDS_I_CREATE_NOTE               45025
#define IDS_I_CREATE_USAGE              45026
#define IDS_I_DELETE_DESC               45027
#define IDS_I_DELETE_NOTE               45028
#define IDS_I_DELETE_USAGE              45029
#define IDS_I_ASSOC_DESC                45030
#define IDS_I_ASSOC_USAGE               45031
#define IDS_I_ASSOC_FMT_NOTE            45032
#define IDS_I_ALIASCMD_HEAD             45033
#define IDS_I_CMD_MORE                  45034
#define IDS_I_ALIASCMD_NOT_AVLBL        45035
#define IDS_I_NAMESPACE_DESC1           45036
#define IDS_I_NAMESPACE_DESC2           45037
#define IDS_I_NAMESPACE_DESC3           45038
#define IDS_I_NAMESPACE_DESC4           45039
#define IDS_I_NAMESPACE_USAGE           45040
#define IDS_I_REPEAT_NOTE               45041
#define IDS_I_ROLE_DESC1                45042
#define IDS_I_ROLE_DESC2                45043
#define IDS_I_ROLE_USAGE                45044
#define IDS_I_ROLE_NOTE1                45045
#define IDS_I_ROLE_NOTE2                45046
#define IDS_I_ROLE_NOTE3                45047
#define IDS_I_NODE_DESC                 45048
#define IDS_I_NODE_USAGE                45049
#define IDS_I_NODE_NOTE                 45050
#define IDS_I_IMPLEVEL_DESC1            45051
#define IDS_I_IMPLEVEL_DESC2            45052
#define IDS_I_IMPLEVEL_USAGE            45053
#define IDS_I_IMPLEVEL_HEAD             45054
#define IDS_I_IMPLEVEL_HEAD1            45055
#define IDS_I_IMPLEVEL_HEAD2            45056
#define IDS_I_IMPLEVEL_ANON             45057
#define IDS_I_IMPLEVEL_IDENTIFY         45058
#define IDS_I_IMPLEVEL_IMPERSONATE      45059
#define IDS_I_IMPLEVEL_DELEGATE         45060
#define IDS_I_AUTHLEVEL_DESC1           45061
#define IDS_I_AUTHLEVEL_DESC2           45062
#define IDS_I_AUTHLEVEL_HEAD            45063
#define IDS_I_AUTHLEVEL_HEAD1           45064
#define IDS_I_AUTHLEVEL_HEAD2           45065
#define IDS_I_AUTHLEVEL_DEFAULT         45066
#define IDS_I_AUTHLEVEL_NONE            45067
#define IDS_I_AUTHLEVEL_CONNECT         45068
#define IDS_I_AUTHLEVEL_CALL            45069
#define IDS_I_AUTHLEVEL_PKT             45070
#define IDS_I_AUTHLEVEL_PKTINTGRTY      45071
#define IDS_I_AUTHLEVEL_PKTPRVCY        45072
#define IDS_I_AUTHLEVEL_USAGE           45073
#define IDS_I_LOCALE_DESC               45074
#define IDS_I_LOCALE_USAGE              45075
#define IDS_I_LOCALE_NOTE1              45076
#define IDS_I_LOCALE_NOTE2              45077
#define IDS_I_PRIVILEGES_DESC           45078
#define IDS_I_PRIVILEGES_USAGE          45079
#define IDS_I_PRIVILEGES_NOTE           45080
#define IDS_I_TRACE_DESC1               45081
#define IDS_I_TRACE_DESC2               45082
#define IDS_I_TRACE_USAGE               45083
#define IDS_I_TRACE_NOTE                45084
#define IDS_I_RECORD_DESC               45085
#define IDS_I_RECORD_USAGE              45086
#define IDS_I_INTERACTIVE_DESC          45087
#define IDS_I_INTERACTIVE_USAGE         45088
#define IDS_I_USER_DESC                 45089
#define IDS_I_USER_USAGE                45090
#define IDS_I_USER_NOTE                 45091
#define IDS_I_PASSWORD_DESC             45092
#define IDS_I_PASSWORD_USAGE            45093
#define IDS_I_HELP_DESC                 45094
#define IDS_I_HELP_USAGE                45095
#define IDS_I_HELP_NOTE                 45096
#define IDS_I_ALIASVERB_HEAD            45097
#define IDS_I_VERB_HEAD                 45098
#define IDS_I_ALIASVERB_NOT_AVLBL       45099
#define IDS_I_VERB_NOT_AVLBL            45100
#define IDS_I_PROP_WRITEABLE_HEAD       45101
#define IDS_I_PROP_HEAD                 45102
#define IDS_I_PROP_WRITEABLE_NOT_AVLBL  45103
#define IDS_I_STDVERB_HEAD              45104
#define IDS_I_GLBLCMD                   45105
#define IDS_I_GLBL_SWITCH_HEAD          45106
#define IDS_I_CLASSPATH_MORE            45107
#define IDS_I_PATH_DESC                 45108
#define IDS_I_PATH_USAGE                45109
#define IDS_I_WHERE_DESC1               45110
#define IDS_I_WHERE_DESC2               45111
#define IDS_I_WHERE_USAGE               45112
#define IDS_I_CLASS_DESC                45113
#define IDS_I_CLASS_USAGE               45114
#define IDS_I_PWHERE_DESC1              45115
#define IDS_I_PWHERE_DESC2              45116
#define IDS_I_PWHERE_USAGE              45117
#define IDS_I_PAKTC                     45118
#define IDS_I_SWITCH_TRANSLATE_FULL_DESC 45120
#define IDS_I_SWITCH_TRANSLATE_USAGE    45121
#define IDS_I_TRANSLATE_HEAD            45122
#define IDS_I_TRANSLATE_NOTABLES        45123
#define IDS_I_SWITCH_EVERY_DESC_FULL    45124
#define IDS_I_SWITCH_EVERY_USAGE        45125
#define IDS_I_EVERY_NOTE                45126
#define IDS_I_SWITCH_FORMAT_DESC_FULL   45127
#define IDS_I_SWITCH_FORMAT_USAGE       45128
#define IDS_I_FORMAT_NOTE               45129
#define IDS_I_VERB_SWITCH_INTERACTIVE_DESC 45130
#define IDS_I_VERB_SWITCH_NOINTERACTIVE_DESC 45131
#define IDS_I_NAMESPACE_BRIEF           45132
#define IDS_I_ROLE_BRIEF                45133
#define IDS_I_NODE_BRIEF                45134
#define IDS_I_IMPLEVEL_BRIEF            45135
#define IDS_I_AUTHLEVEL_BRIEF           45136
#define IDS_I_LOCALE_BRIEF              45137
#define IDS_I_PRIVILEGES_BRIEF          45138
#define IDS_I_TRACE_BRIEF               45139
#define IDS_I_RECORD_BRIEF              45140
#define IDS_I_INTERACTIVE_BRIEF         45141
#define IDS_I_USER_BRIEF                45142
#define IDS_I_PASSWORD_BRIEF            45143
#define IDS_I_HELPBRIEF                 45144
#define IDS_I_GLBL_MORE                 45145
#define IDS_I_HAKTBTC                   45146
#define IDS_I_INPUT                     45148
#define IDS_I_COLON                     45149
#define IDS_I_OUTPUT                    45150
#define IDS_I_CONTEXT_DESC              45151
#define IDS_I_CONTEXT_USAGE             45152
#define IDS_I_NAMESPACE_VALUE           45153
#define IDS_I_ROLE_VALUE                45154
#define IDS_I_AUTHLEVEL_VALUE           45155
#define IDS_I_IMPLEVEL_VALUE            45156
#define IDS_I_PRIVILEGES_VALUE          45157
#define IDS_I_LOCALE_VALUE              45158
#define IDS_I_INTERACTIVE_VALUE         45159
#define IDS_I_RECORDPATH_VALUE          45160
#define IDS_I_TRACE_VALUE               45161
#define IDS_I_USER_VALUE                45162
#define IDS_I_NODELIST_VALUE            45163
#define IDS_I_CLASS_DESCFULL            45164
#define IDS_I_PATH_DESCFULL             45165
#define IDS_I_CONTEXT_DESCFULL          45166
#define IDS_I_STDVERB_ASSOC             45167
#define IDS_I_STDVERB_CALL              45168
#define IDS_I_STDVERB_CREATE            45169
#define IDS_I_STDVERB_GET               45170
#define IDS_I_STDVERB_SET               45171
#define IDS_I_STDVERB_DELETE            45172
#define IDS_I_STDVERB_LIST              45173
#define IDS_I_INVALID_PROS              45174
#define IDS_I_INVALID_NOWRITE_PROS      45175
#define IDS_I_INTERACTIVE_SET           45176
#define IDS_I_INTERACTIVE_ALREADY_SET   45177
#define IDS_I_QUITEXIT                  45178
#define IDS_I_WMIC_INST                 45179
#define IDS_I_ASSOC_SWITCH_HEAD         45181
#define IDS_I_ASSOC_RESULTCLASS         45182
#define IDS_I_ASSOC_RESULTROLE          45183
#define IDS_I_ASSOC_ASSOCCLASS          45184
#define IDS_I_SWITCH_RESULTCLASS_DESC_FULL 45185
#define IDS_I_SWITCH_RESULTCLASS_USAGE  45186
#define IDS_I_SWITCH_RESULTROLE_DESC_FULL 45187
#define IDS_I_SWITCH_RESULTROLE_USAGE   45188
#define IDS_I_SWITCH_ASSOCCLASS_DESC_FULL 45189
#define IDS_I_SWITCH_ASSOCCLASS_USAGE   45190
#define IDS_E_INVALID_ASSOC_FORMATSPECIFIER 45191
#define IDS_E_INVALID_ASSOC_SWITCH      45192
#define IDS_I_FAILFAST_ALREADY_SET      45193
#define IDS_I_FAILFAST_SET              45194
#define IDS_I_FAILFAST_BRIEF            45195
#define IDS_I_FAILFAST_DESC             45196
#define IDS_I_FAILFAST_USAGE            45197
#define IDS_I_FAILFAST_VALUE            45198
#define IDS_I_SWITCH_REPEAT_DESC_FULL   45199
#define IDS_I_SWITCH_REPEAT_USAGE       45200
#define IDS_I_ALIAS_USAGE1              45201
#define IDS_I_ALIAS_USAGE2              45202
#define IDS_I_PATHHELP_SUBST            45203
#define IDS_I_WHEREHELP_SUBST           45204
#define IDS_I_CLASSHELP_SUBST           45205
#define IDS_I_PWHEREHELP_SUBST          45206
#define IDS_I_OUTPUT_DESC               45207
#define IDS_I_OUTPUT_USAGE              45208
#define IDS_I_OUTPUT_NOTE               45209
#define IDS_I_OUTPUT_BRIEF              45210
#define IDS_I_OUTPUT_VALUE              45211
#define IDS_I_DELETING_INSTANCE         45212
#define IDS_I_INSTANCE_DELETE_FAIL      45213
#define IDS_I_INSTANCE_DELETE_SUCCESS   45214
#define IDS_I_VERB_INTERACTIVE_DESC1    45215
#define IDS_I_APPEND_DESC               45216
#define IDS_I_VERB_INTERACTIVE_DESC2    45217
#define IDS_I_APPEND_USAGE              45218
#define IDS_I_APPEND_NOTE               45219
#define IDS_I_APPEND_BRIEF              45220
#define IDS_I_APPEND_VALUE              45221
#define IDS_I_REPEAT_EVERY_RELATED      45222
#define IDS_I_STDOUT_NOTE               45223
#define IDS_I_CLIPBOARD_NOTE            45224
#define IDS_I_OUTPUT_FILE_NOTE          45225
#define IDS_I_APPEND_FILE_NOTE          45226
#define IDS_E_NOT_A_VERBORMETH_PARAM    45227
#define IDS_I_AGGREGATE_DESC            45228
#define IDS_I_AGGREGATE_USAGE           45229
#define IDS_I_AGGREGATE_VALUE           45230
#define IDS_I_AGGREGATE_BRIEF           45231
#define IDS_I_AGGREGATE_NOTE            45232
#define IDS_E_VERB_OR_METHOD_NOT_SPECIFIED 45233
#define IDS_I_CLASS_STDVERB_GET         45234
#define IDS_I_CLASS_GET_USAGE           45235
#define IDS_I_CLASS_GET_DESC            45236
#define IDS_I_CLASS_DELETE_DESC         45237
#define IDS_I_CLASS_ASSOC_DESC          45238
#define IDS_E_NO_DESC                   45239
#define IDS_I_WMIC_UPDATE               45240
#define IDS_I_CALL_SUCCESS              46003
#define IDS_I_CALL_FAIL                 46004
#define IDS_I_SET_SUCCESS               46005
#define IDS_I_SET_FAIL                  46006
#define IDS_I_MEMORY_ALLOC_FAIL         46007
#define IDS_I_LOCATE_SYSTEMDIR_FAIL     46008
#define IDS_I_ALIAS_PATH_CONFLICT       46009
#define IDS_NOT_IMPLEMENTED             46010
#define IDS_I_SET_NOCHANGE              46011
#define IDS_I_NO_INSTANCES              46012
#define IDS_I_DELETE_SUCCESS            46013
#define IDS_I_DELETE_FAIL               46014
#define IDS_I_NODELETE                  46015
#define IDS_I_NOCREATE                  46016
#define IDS_I_CREATE_SUCCESS            46017
#define IDS_E_KEY_CLASS_NOT_ALLOWED_WITH_PATHWHERE 46018
#define IDS_E_INVALID_ASSOC_SYNTAX      46019
#define IDS_I_INTERACTIVE_ALREADY_RESET 46020
#define IDS_I_INTERACTIVE_RESET         46021
#define IDS_I_NO_ASSOCIATIONS           46022
#define IDS_I_FAILFAST_ALREADY_RESET    46023
#define IDS_I_FAILFAST_RESET            46024
#define IDS_I_NO_ASSOC                  46025
#define IDS_E_SET_COMMAND_INPUT_FAILURE 47025
#define IDS_E_SET_ALIAS_NAME_FAILURE    47026
#define IDS_E_SET_NAMESPACE_FAILURE     47027
#define IDS_E_SET_ROLE_FAILURE          47028
#define IDS_E_SET_LOCALE_FAILURE        47029
#define IDS_E_SET_NODE_FAILURE          47030
#define IDS_E_SET_USER_FAILURE          47031
#define IDS_E_SET_PASSWORD_FAILURE      47032
#define IDS_E_SET_RECORDPATH_FAILURE    47033
#define IDS_I_INVOCATION_SUCCESS        47034
#define IDS_I_INVOCATION_FAIL           47035
#define IDS_E_SET_PATH_EXP_FAILURE      47036
#define IDS_E_SET_WHERE_EXP_FAILURE     47037
#define IDS_E_SET_METHOD_NAME_FAILURE   47038
#define IDS_I_ASSOC_INST_MSG            47039
#define IDS_E_ADD_TO_PARAM_MAP_FAILURE  47041
#define IDS_E_ADD_TO_PROP_DET_MAP_FAILURE 47042
#define IDS_E_ADD_TO_PROP_LIST_FAILURE  47043
#define IDS_E_METH_DET_ADD_TO_MAP_FAILURE 47044
#define IDS_E_SET_LIST_FORMAT_FAILURE   47045
#define IDS_E_ADD_TO_PARAMS_LIST_FAILURE 47046
#define IDS_E_SET_PWHERE_EXP_FAILURE    47047
#define IDS_E_ADD_TO_METH_DET_MAP_FAILURE 47048
#define IDS_E_SET_CLASS_PATH_FAILURE    47049
#define IDS_E_SET_ALIASSTRGT_FAILURE    47050
#define IDS_E_VALUE_EXCEEDS_MAXLEN      47051
#define IDS_E_VALUE_NOTFOUND            47052
#define IDS_E_INVALID_ASSIGNLIST        47053
#define IDS_E_INVALID_PARAMLIST         47054
#define IDS_E_SET_AUTHORITY_FAILURE     47058
#define IDS_E_INVALID_CREATE_EXPRESSION 47059
#define IDS_I_METH_EXEC_SUCCESS         47060
#define IDS_I_METH_EXEC_FAILED          47061
#define IDS_I_UPDATE_PROMPT             47062
#define IDS_I_DELETE_INST_PROMPT        47063
#define IDS_I_DELETE_CLASS_PROMPT       47064
#define IDS_I_CREATE_INST_PROMPT        47065
#define IDS_I_INVOKE_PROMPT             47066
#define IDS_I_METH_EXEC_PROMPT          47067
#define IDS_I_ASSOC_INSTANCE            47069
#define IDS_I_PWD_PROMPT                47070
#define IDS_I_MOF_PARSE_ERROR           47071
#define IDS_I_ERROR_MSG                 47072
#define IDS_I_METH_RETCODE              47073
#define IDS_I_METH_INVOKE_PROMPT1       47074
#define IDS_I_METH_INVOKE_PROMPT2       47075
#define IDS_I_METH_INVOKE_PROMPT3       47076
#define IDS_I_METH_INVOKE_PROMPT4       47077
#define IDS_I_PARAM_HEAD                47078
#define IDS_I_PARAM_BORDER              47079
#define IDS_I_PROPS_HEAD                47080
#define IDS_I_PROPS_BORDER              47081
#define IDS_I_METH_EXEC_STATUS          47082
#define IDS_I_DESCRIPTION               47083
#define IDS_I_TRANSFORMAT_NOTE1         47084
#define IDS_I_TRANSFORMAT_NOTE2         47085
#define IDS_I_TRANSFORMAT_NOTE3         47086
#define IDS_I_METH_EXEC_PROMPT2         47087
#define IDS_I_UPDATE_PROMPT2            47088
#define IDS_I_DELETE_CLASS_PROMPT2      47089
#define IDS_I_PROMPT_UPDATING           47090
#define IDS_I_ERROR_MSG_NOTRACE         47091
#define IDS_I_ERROR_WIN32               47092
#define IDS_I_NODENAME_MSG              47093
#define IDS_I_SPECIAL_NOTE              47094
#define IDS_I_OUT_PARAMS                47095
#define IDS_I_WBEM_NO_ERROR             48000
#define IDS_E_WBEM_E_ACCESS_DENIED      48001
#define IDS_E_WBEM_E_ALREADY_EXISTS     48002
#define IDS_E_WBEM_E_CANNOT_BE_KEY      48003
#define IDS_E_WBEM_E_CANNOT_BE_SINGLETON 48004
#define IDS_E_WBEM_E_CLASS_HAS_CHILDREN 48005
#define IDS_E_WBEM_E_CLASS_HAS_INSTANCES 48006
#define IDS_E_WBEM_E_CRITICAL_ERROR     48007
#define IDS_E_WBEM_E_FAILED             48008
#define IDS_E_WBEM_E_ILLEGAL_NULL       48009
#define IDS_E_WBEM_E_ILLEGAL_OPERATION  48010
#define IDS_E_WBEM_E_INCOMPLETE_CLASS   48011
#define IDS_E_WBEM_E_INITIALIZATION_FAILURE 48012
#define IDS_E_WBEM_E_INVALID_CIM_TYPE   48013
#define IDS_E_WBEM_E_INVALID_CLASS      48014
#define IDS_E_WBEM_E_INVALID_CONTEXT    48015
#define IDS_E_WBEM_E_INVALID_METHOD     48016
#define IDS_E_WBEM_E_INVALID_METHOD_PARAMETERS 48017
#define IDS_E_WBEM_E_INVALID_NAMESPACE  48018
#define IDS_E_WBEM_E_INVALID_OBJECT     48019
#define IDS_E_WBEM_E_INVALID_OPERATION  48020
#define IDS_E_WBEM_E_INVALID_PARAMETER  48021
#define IDS_E_WBEM_E_INVALID_PROPERTY_TYPE 48022
#define IDS_E_WBEM_E_INVALID_PROVIDER_REGISTRATION 48023
#define IDS_E_WBEM_E_INVALID_QUALIFIER_TYPE 48024
#define IDS_E_WBEM_E_INVALID_QUERY      48025
#define IDS_E_WBEM_E_INVALID_QUERY_TYPE 48026
#define IDS_E_WBEM_E_INVALID_STREAM     48027
#define IDS_E_WBEM_E_INVALID_SUPERCLASS 48028
#define IDS_E_WBEM_E_INVALID_SYNTAX     48029
#define IDS_E_WBEM_E_NONDECORATED_OBJECT 48030
#define IDS_E_WBEM_E_NOT_AVAILABLE      48031
#define IDS_E_WBEM_E_NOT_FOUND          48032
#define IDS_E_WBEM_E_NOT_SUPPORTED      48033
#define IDS_E_WBEM_E_OUT_OF_MEMORY      48034
#define IDS_E_WBEM_E_OVERRIDE_NOT_ALLOWED 48035
#define IDS_E_WBEM_E_PROPAGATED_PROPERTY 48036
#define IDS_E_WBEM_E_PROPAGATED_QUALIFIER 48037
#define IDS_E_WBEM_E_PROVIDER_FAILURE   48038
#define IDS_E_WBEM_E_PROVIDER_LOAD_FAILURE 48039
#define IDS_E_WBEM_E_PROVIDER_NOT_CAPABLE 48040
#define IDS_E_WBEM_E_PROVIDER_NOT_FOUND 48041
#define IDS_E_WBEM_E_QUERY_NOT_IMPLEMENTED 48042
#define IDS_E_WBEM_E_READ_ONLY          48043
#define IDS_E_WBEM_E_TRANSPORT_FAILURE  48044
#define IDS_E_WBEM_E_TYPE_MISMATCH      48045
#define IDS_E_WBEM_E_UNEXPECTED         48046
#define IDS_E_WBEM_E_VALUE_OUT_OF_RANGE 48047
#define IDS_S_WBEM_S_ALREADY_EXISTS     48048
#define IDS_S_WBEM_S_DIFFERENT          48049
#define IDS_S_WBEM_S_FALSE              48050
#define IDS_S_WBEM_S_NO_MORE_DATA       48051
#define IDS_S_WBEM_S_PENDING            48052
#define IDS_S_WBEM_S_RESET_TO_DEFAULT   48053
#define IDS_S_WBEM_S_TIMEDOUT           48054
#define IDS_E_WBEMESS_E_REGISTRATION_TOO_BROAD 48055
#define IDS_S_WBEMESS_E_REGISTRATION_TOO_PRECISE 48056
#define IDS_S_WBEM_S_OPERATION_CANCELLED 48057
#define IDS_S_WBEM_S_DUPLICATE_OBJECTS  48058
#define IDS_S_WBEM_S_ACCESS_DENIED      48059
#define IDS_S_WBEM_S_PARTIAL_RESULTS    48060
#define IDS_E_WBEM_E_SYSTEM_PROPERTY    48061
#define IDS_E_WBEM_E_INVALID_PROPERTY   48062
#define IDS_E_WBEM_E_CALL_CANCELLED     48063
#define IDS_E_WBEM_E_SHUTTING_DOWN      48064
#define IDS_E_WBEM_E_PROPAGATED_METHOD  48065
#define IDS_E_WBEM_E_UNSUPPORTED_PARAMETER 48066
#define IDS_E_WBEM_E_MISSING_PARAMETER_ID 48067
#define IDS_E_WBEM_E_INVALID_PARAMETER_ID 48068
#define IDS_E_WBEM_E_NONCONSECUTIVE_PARAMETER_IDS 48069
#define IDS_E_WBEM_E_PARAMETER_ID_ON_RETVAL 48070
#define IDS_E_WBEM_E_INVALID_OBJECT_PATH 48071
#define IDS_E_WBEM_E_OUT_OF_DISK_SPACE  48072
#define IDS_E_WBEM_E_BUFFER_TOO_SMALL   48073
#define IDS_E_WBEM_E_UNSUPPORTED_PUT_EXTENSION 48074
#define IDS_E_WBEM_E_UNKNOWN_OBJECT_TYPE 48075
#define IDS_E_WBEM_E_UNKNOWN_PACKET_TYPE 48076
#define IDS_E_WBEM_E_MARSHAL_VERSION_MISMATCH 48077
#define IDS_E_WBEM_E_MARSHAL_INVALID_SIGNATURE 48078
#define IDS_E_WBEM_E_INVALID_QUALIFIER  48079
#define IDS_E_WBEM_E_INVALID_DUPLICATE_PARAMETER 48080
#define IDS_E_WBEM_E_TOO_MUCH_DATA      48081
#define IDS_E_WBEM_E_SERVER_TOO_BUSY    48082
#define IDS_E_WBEM_E_INVALID_FLAVOR     48083
#define IDS_E_WBEM_E_CIRCULAR_REFERENCE 48084
#define IDS_E_WBEM_E_UNSUPPORTED_CLASS_UPDATE 48085
#define IDS_E_WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE 48086
#define IDS_E_WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE 48087
#define IDS_E_WBEM_E_TOO_MANY_PROPERTIES 48088
#define IDS_E_WBEM_E_UPDATE_TYPE_MISMATCH 48089
#define IDS_E_WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED 48090
#define IDS_E_WBEM_E_UPDATE_PROPAGATED_METHOD 48091
#define IDS_E_WBEM_E_METHOD_NOT_IMPLEMENTED 48092
#define IDS_E_WBEM_E_METHOD_DISABLED    48093
#define IDS_E_WBEM_E_REFRESHER_BUSY     48094
#define IDS_E_WBEM_E_UNPARSABLE_QUERY   48095
#define IDS_E_WBEM_E_NOT_EVENT_CLASS    48096
#define IDS_E_WBEM_E_MISSING_GROUP_WITHIN 48097
#define IDS_E_WBEM_E_MISSING_AGGREGATION_LIST 48098
#define IDS_E_WBEM_E_PROPERTY_NOT_AN_OBJECT 48099
#define IDS_E_WBEM_E_AGGREGATING_BY_OBJECT 48100
#define IDS_E_WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY 48101
#define IDS_E_WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING 48102
#define IDS_E_WBEM_E_QUEUE_OVERFLOW     48103
#define IDS_E_WBEM_E_PRIVILEGE_NOT_HELD 48104
#define IDS_E_WBEM_E_INVALID_OPERATOR   48105
#define IDS_E_WBEM_E_LOCAL_CREDENTIALS  48106
#define IDS_E_WBEM_E_CANNOT_BE_ABSTRACT 48107
#define IDS_E_WBEM_E_AMENDED_OBJECT     48108
#define IDS_E_WBEM_E_CLIENT_TOO_SLOW    48109
#define IDS_E_WBEMESS_E_REGISTRATION_TOO_PRECISE 48110
#define IDS_E_MEMALLOCFAILED            48111
#define IDS_E_CONCTRL_HNDLRSET          48112
#define IDS_E_INVALID_CONTEXT_SYNTAX    48113
#define IDS_E_UNKNOWN_WBEM_ERROR        48114
#define IDS_E_INVALID_AUTHORITY_SYNTAX  48115
#define IDS_E_INVALID_AUTHORITY         48116
#define IDS_I_AUTHORITY_VALUE           48117
#define IDS_I_AUTHORITY_BRIEF           48118
#define IDS_I_AUTHORITY_USAGE           48119
#define IDS_I_AUTHORITY_DESC            48120
#define IDS_I_IMPLEVEL_NOTE             48121
#define IDS_I_FORMAT_KEYWORD            48122
#define IDS_I_FORMAT_XSLFILE            48123

#define	IDS_I_FORMAT_KEYWORDS			48122

#define IDS_E_MULTIPLENODE_ERROR        48124

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\parserengine.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: ParserEngine.h 
Project Name				: WMI Command Line
Author Name					: Ch.Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of class
							  CParserEngine.
Revision History			: 		
		Last Modified By	: Sashank P
		Last Modified Date	: 10th-April-2001
*****************************************************************************/ 

/*----------------------------------------------------------------------------
 Class Name			: CParserEngine
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed for 
					  parsing the command string entered as input and 
					  validating the same.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: CParsedInfo
					  CCmdTokenizer
					  CCmdAlias
 Interfaces Used    : WMI COM Interfaces
----------------------------------------------------------------------------*/
// forward declaration of classes
class CParsedInfo;
class CCmdTokenizer;
class CCmdAlias;

class CParserEngine
{
public:
// Construction
	CParserEngine();

// Destruction
	~CParserEngine();

// Restrict Assignment
	CParserEngine& operator=(CParserEngine& rParserEngine);

// Attributes
private:
	// IWbemLocator interface to obtain the initial namespace pointer to the 
	//Windows Management on a particular host computer
	IWbemLocator*	m_pIWbemLocator;

	//IWbemServices interface is used by clients and providers to access WMI
	//services.This interface provides management services to client processes 
	
	IWbemServices*	m_pITargetNS;
	
	// Tokenizer object used for tokenize the command string
	CCmdTokenizer	m_CmdTknzr;
	
	// Alias object used for accessing the alias information from the WMI.
	CCmdAlias		m_CmdAlias;

	// flag to indicate whether <alias> name
	// is specified.
	BOOL			m_bAliasName;

// Operations
private:

	// Parses the global switches.
	RETCODE		ParseGlobalSwitches(CHARVECTOR& cvTokens,
								CHARVECTOR::iterator& theIterator, 
								CParsedInfo& rParsedInfo);

	// Parses the <alias> information.
	RETCODE		ParseAliasInfo(CHARVECTOR& cvTokens,
						   CHARVECTOR::iterator& theIterator,
						   CParsedInfo& rParsedInfo);

	// Parses the CLASS information.
	RETCODE		ParseClassInfo(CHARVECTOR& cvTokens,
						   CHARVECTOR::iterator& theIterator,
						   CParsedInfo& rParsedInfo);

	// Parses the Verb information 	
	RETCODE		ParseVerbInfo(CHARVECTOR& cvTokens,
						  CHARVECTOR::iterator& theIterator, 
						  CParsedInfo& rParsedInfo);
	
	// Parse the GET verb information
	RETCODE		ParseGETVerb(CHARVECTOR& cvTokens,
						 CHARVECTOR::iterator& theIterator, 
						 CParsedInfo& rParsedInfo);


	// Parse the LIST verb information
	RETCODE		ParseLISTVerb(CHARVECTOR& cvTokens,
						  CHARVECTOR::iterator& theIterator, 
						  CParsedInfo& rParsedInfo);

	// Parse the SET | CREATE verb information
	RETCODE		ParseSETorCREATEVerb(CHARVECTOR& cvTokens,
						 CHARVECTOR::iterator& theIterator, 
						 CParsedInfo& rParsedInfo,
						 HELPTYPE helpType);

	// Parse the ASSOC verb information
	RETCODE		ParseASSOCVerb(CHARVECTOR& cvTokens,
						   CHARVECTOR::iterator& theIterator, 
						   CParsedInfo& rParsedInfo);

	// Parse the CALL verb information
	RETCODE		ParseCALLVerb(CHARVECTOR& cvTokens,
						  CHARVECTOR::iterator& theIterator, 
						  CParsedInfo& rParsedInfo);

	// Parse the method information
	RETCODE		ParseMethodInfo(CHARVECTOR& cvTokens,
							CHARVECTOR::iterator& theIterator, 
							CParsedInfo& rParsedInfo);

	// Parses the GET verb switches information
	RETCODE		ParseGETSwitches(CHARVECTOR& cvTokens,
							 CHARVECTOR::iterator& theIterator,
							 CParsedInfo& rParsedInfo);
	
	//Checks for help option in advance.
	RETCODE		CheckForHelp(CHARVECTOR& cvTokens, 
						 CHARVECTOR::iterator& theIterator,
						 CParsedInfo& rParsedInfo,
						 UINT uErrataCode);

	// Parses the PATH expression.
	RETCODE		ParsePathInfo(CHARVECTOR& cvTokens,
						  CHARVECTOR::iterator& theIterator,
						  CParsedInfo& rParsedInfo);

	// Parses the WHERE expression.
	RETCODE		ParseWhereInfo(CHARVECTOR& cvTokens,
						   CHARVECTOR::iterator& theIterator,
						   CParsedInfo& rParsedInfo);
	
	// Parses the SET | CREATE | NamedParams verb argument list
	RETCODE		ParseSETorCREATEOrNamedParamInfo(CHARVECTOR& cvTokens,
							 CHARVECTOR::iterator& theIterator,
							 CParsedInfo& rParsedInfo,
							 HELPTYPE helpType);

	// Parses the LIST switches information 
	RETCODE		ParseLISTSwitches(CHARVECTOR& cvTokens,
							  CHARVECTOR::iterator& theIterator,
							  CParsedInfo& rParsedInfo,
							  BOOL& bFormatSwitchSpecified);
	
	// Parses the Verb switches information 
	RETCODE		ParseVerbSwitches(CHARVECTOR& cvTokens, 
							  CHARVECTOR::iterator& theIterator,
							  CParsedInfo& rParsedInfo);

	// Gets the next token from the Tokens vector - overload 1.
	BOOL		GetNextToken(CHARVECTOR& cvTokens, 
					  CHARVECTOR::iterator& theIterator);

	// Gets the next token from the Tokens vector - overload 2.
	RETCODE		GetNextToken(CHARVECTOR& cvTokens, 
						 CHARVECTOR::iterator& theIterator,
						 CParsedInfo& rParsedInfo,
						 HELPTYPE helpType,
						 UINT uErrataCode);

	// Gets the next token from the Tokens vector - overload 3.
	RETCODE		GetNextToken(CHARVECTOR& cvTokens,
  						 CHARVECTOR::iterator& theIterator,
						 CParsedInfo& rParsedInfo, 
						 UINT uErrataCode);

	// Check whether the next token is '?' 
	RETCODE		IsHelp(CHARVECTOR& cvTokens, 
					CHARVECTOR::iterator& theIterator,
					CParsedInfo& rParsedInfo,
					HELPTYPE helpType,
					UINT uErrataCode,
					TOKENLEVEL tokenLevel = LEVEL_ONE);

	// Parse for help information - overload 1
	RETCODE		ParseHelp(CHARVECTOR& cvTokens, 
					  CHARVECTOR::iterator& theIterator,
					  CParsedInfo& rParsedInfo,
					  BOOL bGlobalHelp = FALSE);

	// Parse for help information - overload 2
	RETCODE		ParseHelp(CHARVECTOR& cvTokens, 
					  CHARVECTOR::iterator& theIterator,
					  HELPTYPE htHelp,
					  CParsedInfo& rParsedInfo,
					  BOOL bGlobalHelp = FALSE);

	// Parse and form a PWhere expression 
	BOOL		ParsePWhereExpr(CHARVECTOR& cvTokens,    
						 CHARVECTOR::iterator& theIterator,
						 CParsedInfo& rParsedInfo,
						 BOOL bIsParan);

	// Extracts the Classname and the where expression 
	// out of the given path expression
	BOOL		ExtractClassNameandWhereExpr(_TCHAR* pszPathExpr, 
							  		  CParsedInfo& rParsedInfo);

	// Obtains properties associated with the class for /get help
	// If bCheckWritePropsAvail == TRUE then functions checks for availibilty 
	// of properties.
	BOOL		ObtainClassProperties(CParsedInfo& rParsedInfo, 
									  BOOL bCheckWritePropsAvail = FALSE);

	// Obtains parameters of the method
	HRESULT		ObtainMethodParamInfo(IWbemClassObject* pIObj, 
								  METHODDETAILS& mdMethDet,
								  INOROUT ioInOrOut,
								  BOOL bTrace, CParsedInfo& rParsedInfo);

	// Get the status of method ( implemented or not ).
	HRESULT		GetMethodStatusAndDesc(IWbemClassObject* pIObj, 
								   BSTR bstrMethod,
								   _bstr_t& bstrStatus,
								   _bstr_t& bstrDesc,
								   BOOL bTrace);

	// Obtain class methods. if bCheckForExists == TRUE then it 
	// checks for availibility of methods with class.
	BOOL		ObtainClassMethods(CParsedInfo& rParsedInfo, 
								   BOOL bCheckForExists = FALSE);

	// Connects to Target Namespace. 
	HRESULT		ConnectToNamespace(CParsedInfo& rParsedInfo);

	// Parses EVERY switch.
	RETCODE		ParseEVERYSwitch(CHARVECTOR& cvTokens,
			    			 CHARVECTOR::iterator& theIterator,
							 CParsedInfo& rParsedInfo);

	// Parses FORMAT switch.
	RETCODE		ParseFORMATSwitch(CHARVECTOR& cvTokens,
			 				  CHARVECTOR::iterator& theIterator,
							  CParsedInfo& rParsedInfo);

	// Validates the value passed with global switches.
	RETCODE		ValidateGlobalSwitchValue(CHARVECTOR& cvTokens,
									  CHARVECTOR::iterator& theIterator, 
									  UINT uErrataCode,
									  CParsedInfo& rParsedInfo,
									  UINT uErrataCode2,
									  HELPTYPE htHelp);

	// Is pszToken is Std verb or User defined verb.
	BOOL		IsStdVerbOrUserDefVerb( _bstr_t pszToken,
		  					     CParsedInfo& rParsedInfo );

	// Parses the TRANSLATE switch.
	RETCODE		ParseTRANSLATESwitch(CHARVECTOR& cvTokens,
			  					 CHARVECTOR::iterator& theIterator,
								 CParsedInfo& rParsedInfo);

	// Parsed the CONTEXT switch.
	RETCODE		ParseContextInfo(CHARVECTOR& cvTokens,
								CHARVECTOR::iterator& theIterator, 
								CParsedInfo& rParsedInfo);

	// Validates the node name/namespace
	BOOL		ValidateNodeOrNS(_TCHAR* pszInput, BOOL bNode);

	// Parses the ASSOC switches information 
	RETCODE		ParseAssocSwitches(CHARVECTOR& cvTokens,
								CHARVECTOR::iterator& theIterator,
								CParsedInfo& rParsedInfo);

	// Parses the ASSOC switches - RESULTCLASSS,RESULTROLE ,ASSOCCLASSS  
	RETCODE		ParseAssocSwitchEx(CHARVECTOR& cvTokens,
								CHARVECTOR::iterator& theIterator,
								CParsedInfo& rParsedInfo, 
								ASSOCSwitch assocSwitch);

	// Parsing Switch:Count ( /EVERY:N and /REPEAT:N )
	RETCODE		ParseNumberedSwitch(CHARVECTOR& cvTokens,
									CHARVECTOR::iterator& theIterator,
									CParsedInfo& rParsedInfo,
									HELPTYPE htHelp,
									UINT uSwitchErrCode,
									UINT uNumberErrCode);

	// Validates a class;
	BOOL	IsValidClass(CParsedInfo& rParsedInfo);

	// Checks whether methods are available with alias in case of alias specified.
	// and with class in case of class speicified.
	void	ObtainMethodsAvailableFlag(CParsedInfo& rParsedInfo);

	// Checks whether Writeable Props are available with alias in case of alias 
	//	specified. and with class in case of class speicified.
	void	ObtainWriteablePropsAvailailableFlag(CParsedInfo& rParsedInfo);

	// Checks whether FULL Props are available with alias in case of alias 
	//	specified. and with class in case of class speicified.
	void	ObtainFULLPropsAvailailableFlag(CParsedInfo& rParsedInfo);

	// This function parses the verb interactive option
	RETCODE	ParseVerbInteractive(CHARVECTOR& cvTokens,
							CHARVECTOR::iterator& theIterator, 
							CParsedInfo& rParsedInfo, BOOL& bInvalidOption);

	// Prepares the output and append files for output redirection.
	RETCODE	ProcessOutputAndAppendFiles(CParsedInfo& rParsedInfo, RETCODE retCode,
										BOOL bOpenOutInWriteMode);

	// Parse Unnamed Parameter list.
	RETCODE ParseUnnamedParamList(CHARVECTOR& cvTokens,
								  CHARVECTOR::iterator& theIterator,
								  CParsedInfo& rParsedInfo);

	// Validates the named params with verb or method parameters.
	RETCODE	ValidateVerbOrMethodParams(CParsedInfo& rParsedInfo);

	// Parses paramName = paramValue strings.
	RETCODE	ParseParamsString(CHARVECTOR& cvTokens,
							  CHARVECTOR::iterator& theIterator,
							  CParsedInfo& rParsedInfo,
							  XSLTDET& xdXSLTDet);

	// Parses the node list file.
	RETCODE	ParseNodeListFile(CHARVECTOR& cvTokens,
							  CHARVECTOR::iterator& theIterator,
							  CParsedInfo& rParsedInfo);

	// Retrieve Node by Node from Node list file
	BOOL GetNodeFromNodeFile(FILE*		fpNodeListFile, 
							 FILETYPE   eftNodeFileType,
							 _TCHAR*	szNodeName);
public:
	// Gets the command tokenizer 
	CCmdTokenizer& GetCmdTokenizer();
	
	// It does the Processing the token .
	RETCODE ProcessTokens(CParsedInfo& rParsedInfo);
	
	// Initializes the member variables 
	void Initialize();
	
	// Uninitializes the member variables 
	void Uninitialize(BOOL bFinal = FALSE);
	
	// Sets the locator object .
	BOOL SetLocatorObject(IWbemLocator* pIWbemLocator);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\wmiclilog.cpp ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICliLog.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 4th-October-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
							  for logging the input and output.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 28th-December-2000
*****************************************************************************/ 
// WMICliLog.cpp : implementation file
#include "Precomp.h"
#include "WmiCliLog.h"


/*------------------------------------------------------------------------
   Name				 :CWMICliLog
   Synopsis	         :Constructor 
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICliLog::CWMICliLog()
{
	m_pszLogFile	= NULL;
	m_bCreate		= FALSE;
}

/*------------------------------------------------------------------------
   Name				 :~CWMICliLog
   Synopsis	         :Destructor
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICliLog::~CWMICliLog()
{
	//Close the File handle
	if (m_bCreate)
		CloseHandle(m_hFile);

	//Delete the file
	SAFEDELETE(m_pszLogFile);
}

/*------------------------------------------------------------------------
   Name				 :WriteToLog
   Synopsis	         :Log the input to the logfile created
   Type	             :Member Function 
   Input parameter   :
		pszMsg	 - string, contents to be written to the log file
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :WriteToLog(pszInput)
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliLog::WriteToLog(LPSTR pszMsg) throw (WMICLIINT)
{
    int j = 0;
    if(pszMsg && ((j = strlen(pszMsg)) > 0))
    {
        //if the file has not been created 
	    if (!m_bCreate)
	    {
		    try
		    {
			    //creates the log file 
			    CreateLogFile();
		    }
		    catch(WMICLIINT nErr)
		    {
			    if (nErr == WIN32_FUNC_ERROR)
				    throw(WIN32_FUNC_ERROR);
		    }
		    m_bCreate = TRUE;
	    }

	    //No of bytes written into the file .
	    DWORD	dwNumberOfBytes = 0;
	    
	    //writes data to a file 
	    if (!WriteFile(m_hFile, pszMsg, j, 
					    &dwNumberOfBytes, NULL))
	    {
		    DisplayWin32Error();
		    throw(WIN32_FUNC_ERROR);
	    }
    }
}

/*------------------------------------------------------------------------
   Name				 :CreateLogFile
   Synopsis	         :Create the log file 
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :CreateLogFile()
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliLog::CreateLogFile() throw(WMICLIINT)
{
	//Create a file and returns the handle 
	m_hFile = CreateFile(m_pszLogFile, GENERIC_WRITE, 0, 
		NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 
		NULL);
	
	if (m_hFile == INVALID_HANDLE_VALUE)
	{
		DisplayWin32Error();
		throw(WIN32_FUNC_ERROR);
	}
}

/*------------------------------------------------------------------------
   Name				 :SetLogFilePath
   Synopsis	         :This function sets the m_pszLogFile name with the 
					  input
   Type	             :Member Function
   Input parameter   :
     pszLogFile  -  String type,Contains the log file name
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetLogFilePath(pszLogFile)
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliLog::SetLogFilePath(_TCHAR* pszLogFile) throw (WMICLIINT)
{
	SAFEDELETE(m_pszLogFile);
	m_pszLogFile = new _TCHAR [lstrlen(pszLogFile) + 1];
	if (m_pszLogFile)
	{
		//Copy the input argument into the log file name
		lstrcpy(m_pszLogFile, pszLogFile);
	}
	else
		throw(OUT_OF_MEMORY);
}

/*------------------------------------------------------------------------
   Name				 :CloseLogFile
   Synopsis	         :Closes the the log file 
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :CloseLogFile()
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliLog::CloseLogFile()
{
	//Close the File handle
	if (m_bCreate)
	{
		CloseHandle(m_hFile);
		m_bCreate = FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\wmiclilog.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICliLog.h 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 4th-October-2000
Version Number				: 1.0 
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 18th-November-2000
****************************************************************************/ 
// WMICliLog.h : header file
//
/*-------------------------------------------------------------------
 Class Name			: CWMICliLog
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for logging the input and output
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CWMICliLog
class CWMICliLog
{
public:
	// Construction
	CWMICliLog();
	
	// Destruction
	~CWMICliLog();
	
	// Restrict Assignment
	CWMICliLog& operator=(CWMICliLog& rWmiCliLog);
	
// Attributes
private:
	//the log file 
	_TCHAR* m_pszLogFile;

	//handle to the log file
	HANDLE  m_hFile;
	
	//status of whether the file has to created or not
	BOOL	m_bCreate;

// Operations
private:
	//Creates the Log File
	void CreateLogFile();

public:
	//write in to the log file
	void WriteToLog(LPSTR pszInput);
	
	//sets the Log File Path
	void SetLogFilePath(_TCHAR*);

	//Close the Log File
	void CloseLogFile();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adapelem.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPELEM.CPP

Abstract:

    Implementation File

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "adapelem.h"

CAdapElement::CAdapElement( void )
: m_lRefCount(1)
{
}

CAdapElement::~CAdapElement( void )
{
}

long CAdapElement::AddRef( void )
{
    return InterlockedIncrement( &m_lRefCount );
}

long CAdapElement::Release( void )
{
    long    lRef = InterlockedDecrement( &m_lRefCount );
    if ( 0 == lRef ) delete this;
    return lRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\wmiclixmllog.cpp ===
///////////////////////////////////////////////////////////////////////
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICliLog.cpp 
Project Name				: WMI Command Line
Author Name					: Biplab Mistry
Date of Creation (dd/mm/yy) : 02-March-2001
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
							  for logging the input and output.
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 27-March-2001
*****************************************************************************/ 
// WMICliXMLLog.cpp : implementation file
#include "Precomp.h"
#include "helpinfo.h"
#include "ErrorLog.h"
#include "GlobalSwitches.h"
#include "CommandSwitches.h"
#include "ParsedInfo.h"
#include "ErrorInfo.h"
#include "WMICliXMLLog.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "FormatEngine.h"
#include "WmiCmdLn.h"

/*------------------------------------------------------------------------
   Name				 :CWMICliXMLLog
   Synopsis	         :Constructor 
   Type	             :Constructor 
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICliXMLLog::CWMICliXMLLog()
{
	m_pIXMLDoc		= NULL;
	m_pszLogFile	= NULL;
	m_bCreate		= FALSE;
	m_nItrNum		= 0;
	m_bTrace		= FALSE;
	m_eloErrLogOpt	= NO_LOGGING;
}	

/*------------------------------------------------------------------------
   Name				 :~CWMICliXMLLog
   Synopsis	         :Destructor
   Type	             :Destructor
   Input parameter   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICliXMLLog::~CWMICliXMLLog()
{
	SAFEDELETE(m_pszLogFile);
	SAFEIRELEASE(m_pIXMLDoc);
}

/*----------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables when 
					  the execution of a command string issued on the command 
					  line is completed.
   Type	             :Member Function
   Input Parameter(s):
			bFinal	- boolean value which when set indicates that the program
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize(bFinal)
   Notes             :None
----------------------------------------------------------------------------*/
void CWMICliXMLLog::Uninitialize(BOOL bFinal)
{
	if (bFinal)
	{
		SAFEDELETE(m_pszLogFile);
		SAFEIRELEASE(m_pIXMLDoc);
	}
	m_bTrace		= FALSE;
	m_eloErrLogOpt	= NO_LOGGING;
}

/*------------------------------------------------------------------------
   Name				 :WriteToXMLLog
   Synopsis	         :Logs the input & output to the xml log file
   Type	             :Member Function 
   Input parameter   :
				rParsedInfo - reference to CParsedInfo object
				bstrOutput  - output that goes into CDATA section.
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :WriteToXMLLog(rParsedInfo, bstrOutput)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT	CWMICliXMLLog::WriteToXMLLog(CParsedInfo& rParsedInfo, BSTR bstrOutput)
{
	HRESULT				hr					= S_OK;
	_variant_t			varValue;
	DWORD				dwThreadId			= GetCurrentThreadId();
	BSTR				bstrUser			= NULL,
						bstrStart			= NULL,
						bstrInput			= NULL,
						bstrTarget			= NULL,
						bstrNode			= NULL;
	WMICLIINT			nSeqNum				= 0;
	BOOL				bNewCmd				= FALSE;
	BOOL				bNewCycle			= FALSE;

	// Initialize the TRACE and ERRORLOG variables.
	m_bTrace		= rParsedInfo.GetGlblSwitchesObject().GetTraceStatus();
	m_eloErrLogOpt	= rParsedInfo.GetErrorLogObject().GetErrLogOption();
	bNewCmd			= rParsedInfo.GetNewCommandStatus();
	bNewCycle		= rParsedInfo.GetNewCycleStatus();
	CHString		chsMsg;
	try
	{
		bstrUser  = ::SysAllocString(rParsedInfo.GetGlblSwitchesObject().
								GetLoggedonUser());
		if (bstrUser == NULL)
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

		bstrStart = ::SysAllocString(rParsedInfo.GetGlblSwitchesObject().
								GetStartTime());
		if (bstrStart == NULL)
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

		_TCHAR	*pszCommandInput = rParsedInfo.GetCmdSwitchesObject().
													GetCommandInput();
		STRING strCommand(pszCommandInput);
		
		// Delete /RECORD entries
		FindAndDeleteRecord(strCommand);
		bstrInput = ::SysAllocString((LPTSTR)strCommand.data());

		if (bstrInput == NULL)
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

		if (!rParsedInfo.GetGlblSwitchesObject().GetAggregateFlag())
		{
			bstrTarget = ::SysAllocString(rParsedInfo.GetGlblSwitchesObject().
								GetNode());
			if (bstrTarget == NULL)
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
		else
		{
			_bstr_t bstrTemp;
			_TCHAR* pszVerb = rParsedInfo.GetCmdSwitchesObject().GetVerbName();
			if (pszVerb)
			{
				if ( CompareTokens(pszVerb, CLI_TOKEN_LIST) || 
				CompareTokens(pszVerb, CLI_TOKEN_ASSOC) || 
				CompareTokens(pszVerb, CLI_TOKEN_GET))
				{
					rParsedInfo.GetGlblSwitchesObject().GetNodeString(bstrTemp);
					bstrTarget = ::SysAllocString((LPWSTR)bstrTemp);
					if (bstrTarget == NULL)
						throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
				}
				// CALL, SET, CREATE, DELETE and, user defined verbs
				else 
				{
					bstrTarget= ::SysAllocString(rParsedInfo.GetGlblSwitchesObject().
								GetNode());
					if (bstrTarget == NULL)
						throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
				}
			}
			else
			{
				rParsedInfo.GetGlblSwitchesObject().GetNodeString(bstrTemp);
				bstrTarget = ::SysAllocString((LPWSTR)bstrTemp);
				if (bstrTarget == NULL)
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
			
		}

		bstrNode  = ::SysAllocString(rParsedInfo.GetGlblSwitchesObject().
								GetMgmtStationName());
		if (bstrNode == NULL)
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

		nSeqNum	  = rParsedInfo.GetGlblSwitchesObject().GetSequenceNumber();
		// If first time.
		if(!m_bCreate)
		{
			// Create the XML root node
			hr = CreateXMLLogRoot(rParsedInfo, bstrUser);
			ONFAILTHROWERROR(hr);
		}

		if (bNewCmd == TRUE)
		{
			m_nItrNum = 1;
			// Create the node fragment and append it
			hr = CreateNodeFragment(nSeqNum, bstrNode, bstrStart, 
								bstrInput, bstrOutput, bstrTarget,
								rParsedInfo);
			ONFAILTHROWERROR(hr);
		}
		else
		{
			if (bNewCycle)
				m_nItrNum++;
			hr = AppendOutputNode(bstrOutput, bstrTarget, rParsedInfo);
			ONFAILTHROWERROR(hr);
		}

		// Save the result to the XML file specified.
		varValue = (WCHAR*) m_pszLogFile;
		hr = m_pIXMLDoc->save(varValue);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::save(L\"%s\")", 
						(LPWSTR) varValue.bstrVal);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);
		::SysFreeString(bstrUser);
		::SysFreeString(bstrStart);
		::SysFreeString(bstrInput);
		::SysFreeString(bstrTarget);
		::SysFreeString(bstrNode);
	}
	catch(_com_error& e)
	{
		::SysFreeString(bstrUser);
		::SysFreeString(bstrStart);
		::SysFreeString(bstrInput);
		::SysFreeString(bstrTarget);
		::SysFreeString(bstrNode);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		::SysFreeString(bstrUser);
		::SysFreeString(bstrStart);
		::SysFreeString(bstrInput);
		::SysFreeString(bstrTarget);
		::SysFreeString(bstrNode);
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :SetLogFilePath
   Synopsis	         :This function sets the m_pszLogFile name with the 
					  input
   Type	             :Member Function
   Input parameter   :
     pszLogFile  -  String type,Contains the log file name
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SetLogFilePath(pszLogFile)
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliXMLLog::SetLogFilePath(_TCHAR* pszLogFile) throw (WMICLIINT)
{
	SAFEDELETE(m_pszLogFile);
	m_pszLogFile = new _TCHAR [lstrlen(pszLogFile) + 1];
	if (m_pszLogFile)
	{
		//Copy the input argument into the log file name
		lstrcpy(m_pszLogFile, pszLogFile);
	}
	else
		throw(OUT_OF_MEMORY);
}

/*------------------------------------------------------------------------
   Name				 :CreateXMLLogRoot
   Synopsis	         :Creates the root node of the xml log file
   Type	             :Member Function 
   Input parameter   :
		rParsedInfo	- reference to CParsedInfo object
		bstrUser	- current user name
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateXMLLogRoot(rParsedInfo, bstrUser)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::CreateXMLLogRoot(CParsedInfo& rParsedInfo, BSTR bstrUser)
{
	HRESULT			hr					= S_OK;
	IXMLDOMNode		*pINode				= NULL;
	DWORD			dwThreadId			= GetCurrentThreadId();
	CHString		chsMsg;

	try
	{
		// Create single instance of the IXMLDOMDocument2 interface
		hr = CoCreateInstance(CLSID_FreeThreadedDOMDocument, NULL, 
									CLSCTX_INPROC_SERVER,
									IID_IXMLDOMDocument2, 
									(LPVOID*)&m_pIXMLDoc);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"CoCreateInstance(CLSID_FreeThreadedDOMDocument, NULL,"
				L"CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Create the XML root node <WMICRECORD USER=XXX>
		_variant_t			varType((short)NODE_ELEMENT);
		_bstr_t				bstrName(L"WMIRECORD");
		_variant_t			varValue;

		// Create a new node 
		hr = CreateNodeAndSetContent(&pINode, varType, bstrName, NULL,
									rParsedInfo); 
		ONFAILTHROWERROR(hr);

		// Append the attribute "USER"
		bstrName = L"USER";
		varValue = (WCHAR*)bstrUser;
		
		hr = AppendAttribute(pINode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		hr = m_pIXMLDoc->appendChild(pINode, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		SAFEIRELEASE(pINode);

		// set the m_bCreate flag to TRUE
		m_bCreate=TRUE;
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pINode);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pINode);
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :StopLogging
   Synopsis	         :Stops logging and closes the xml DOM document object
   Type	             :Member Function 
   Input parameter   :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :StopLogging()
   Notes             :None
------------------------------------------------------------------------*/
void CWMICliXMLLog::StopLogging()
{
	SAFEDELETE(m_pszLogFile);
	SAFEIRELEASE(m_pIXMLDoc);
	m_bCreate = FALSE;
}

/*------------------------------------------------------------------------
   Name				 :CreateNodeAndSetContent
   Synopsis	         :Creates the new node and sets the content
   Type	             :Member Function 
   Input parameter   :
		pINode		- pointer to node object
		varType		- node type
		bstrName	- Node name
		bstrValue	- node content
		rParsedInfo - reference to CParsedInfo object
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateNodeAndSetContent(&pINode, varType, 
									bstrName, bstrValue, rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::CreateNodeAndSetContent(IXMLDOMNode** pINode, 
								VARIANT varType,
								BSTR bstrName,	BSTR bstrValue,
								CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHString				chsMsg;
	try
	{
		hr = m_pIXMLDoc->createNode(varType, bstrName, L"", pINode);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::createNode(%d, \"%s\", L\"\","
								L" -)", varType.lVal, (LPWSTR) bstrName);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		if (bstrValue)
		{
			hr = (*pINode)->put_text(bstrValue);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXMLDOMNode::put_text(L\"%s\")",	(LPWSTR) bstrValue);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
										   dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);
		}
	}
	catch(_com_error& e)
	{
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :AppendAttribute
   Synopsis	         :Append attribute with the given value to the node 
					  specified.
   Type	             :Member Function 
   Input parameter   :
		pINode			- node object
		bstrAttribName	- Attribute name
		varValue		- attribute value
		rParsedInfo		- reference to CParsedInfo object
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :AppendAttribute(pINode, bstrAttribName, varValue, 
						rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::AppendAttribute(IXMLDOMNode* pINode, BSTR bstrAttribName, 
						VARIANT varValue, CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	IXMLDOMNamedNodeMap		*pINodeMap			= NULL;
	IXMLDOMAttribute		*pIAttrib			= NULL;
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHString				chsMsg;

	try
	{
		// Get the attributes map
		hr = pINode->get_attributes(&pINodeMap);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::get_attributes(-)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		if (pINodeMap)
		{
			// Create the attribute with the given name.
			hr = m_pIXMLDoc->createAttribute(bstrAttribName, &pIAttrib);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXMLDOMDocument2::createAttribute(L\"%s\", -)",
									(LPWSTR) bstrAttribName);
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace);
			}
			ONFAILTHROWERROR(hr);

			// Set the attribute value
			if (pIAttrib)
			{
				hr = pIAttrib->put_nodeValue(varValue);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IXMLDOMAttribute::put_nodeValue(L\"%s\")",
							(LPWSTR) _bstr_t(varValue));
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);

				hr = pINodeMap->setNamedItem(pIAttrib, NULL);
				if (m_bTrace || m_eloErrLogOpt)
				{
					chsMsg.Format(L"IXMLDOMNamedNodeMap::setNamedItem(-, NULL)");
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
									   dwThreadId, rParsedInfo, m_bTrace);
				}
				ONFAILTHROWERROR(hr);
				SAFEIRELEASE(pIAttrib);
			}
			SAFEIRELEASE(pINodeMap);
		}
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIAttrib);
		SAFEIRELEASE(pINodeMap);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIAttrib);
		SAFEIRELEASE(pINodeMap);
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :CreateNodeFragment
   Synopsis	         :Creates a new node fragment with the predefined format
					  and appends it to the document object
   Type	             :Member Function 
   Input parameter   :
		nSeqNum			- sequence # of the command.
		bstrNode		- management workstation name
		bstrStart		- command issued time
		bstrInput		- commandline input
		bstrOutput		- commandline output
		bstrTarget		- target node
		rParsedInfo		- reference to CParsedInfo object
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CreateNodeFragment(nSeqNum, bstrNode, bstrStart, 
						bstrInput, bstrOutput, bstrTarget, rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::CreateNodeFragment(WMICLIINT nSeqNum, BSTR bstrNode, 
										  BSTR bstrStart, BSTR bstrInput,
										  BSTR bstrOutput, BSTR bstrTarget,
										  CParsedInfo& rParsedInfo)
		
{
	HRESULT					hr					= S_OK;
	IXMLDOMNode				*pINode				= NULL,
							*pISNode			= NULL,
							*pITNode			= NULL;
	IXMLDOMDocumentFragment	*pIFrag				= NULL;
	IXMLDOMElement			*pIElement			= NULL;

	_variant_t				varType;
	_bstr_t					bstrName;
	_variant_t				varValue;
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHString				chsMsg;
	
	try
	{
		// The nodetype is NODE_ELEMENT
		varType = ((short)NODE_ELEMENT);

		bstrName = _T("RECORD");
		// Create a new node
		hr = CreateNodeAndSetContent(&pINode, varType, 
							bstrName, NULL, rParsedInfo); 
		ONFAILTHROWERROR(hr);

		// Append the attribute "SEQUENCENUM"
		bstrName = L"SEQUENCENUM";
		varValue = (long) nSeqNum;
		hr = AppendAttribute(pINode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		// Append the attribute "ISSUEDFROM"
		bstrName = L"ISSUEDFROM";
		varValue = (WCHAR*)bstrNode;
		hr = AppendAttribute(pINode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		// Append the attribute "STARTTIME"
		bstrName = L"STARTTIME";
		varValue = (WCHAR*) bstrStart;
		hr = AppendAttribute(pINode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		// Create a document fragment and associate the new node with it.
		hr = m_pIXMLDoc->createDocumentFragment(&pIFrag);	
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::createDocumentFragment(-)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);
		
		hr = pIFrag->appendChild(pINode, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocumentFragment::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);
		}
		ONFAILTHROWERROR(hr);

		// Append the REQUEST node together with the input command.
		bstrName = _T("REQUEST");
		hr = CreateNodeAndSetContent(&pISNode, varType, 
							bstrName, NULL, rParsedInfo); 
		ONFAILTHROWERROR(hr);

		hr = pINode->appendChild(pISNode, &pITNode);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);			
		}
		ONFAILTHROWERROR(hr);
		SAFEIRELEASE(pISNode);

		bstrName  = _T("COMMANDLINE");
		hr = CreateNodeAndSetContent(&pISNode, varType, 
							bstrName, bstrInput, rParsedInfo); 
		ONFAILTHROWERROR(hr);

		hr = pITNode->appendChild(pISNode, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);						
		}
		ONFAILTHROWERROR(hr);
		SAFEIRELEASE(pISNode);
		SAFEIRELEASE(pITNode);

		hr = FrameOutputNode(&pINode, bstrOutput, bstrTarget, rParsedInfo);

		// Get the document element of the XML log file
		hr = m_pIXMLDoc->get_documentElement(&pIElement);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::get_documentElement(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);				
		}
		ONFAILTHROWERROR(hr);

		// Append the newly create fragment to the document element
		hr = pIElement->appendChild(pIFrag,	NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMElement::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);							
		}
		ONFAILTHROWERROR(hr);

		SAFEIRELEASE(pINode);
		SAFEIRELEASE(pIFrag);
		SAFEIRELEASE(pIElement);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pISNode);
		SAFEIRELEASE(pITNode);
		SAFEIRELEASE(pINode);
		SAFEIRELEASE(pIFrag);
		SAFEIRELEASE(pIElement);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pISNode);
		SAFEIRELEASE(pITNode);
		SAFEIRELEASE(pINode);
		SAFEIRELEASE(pIFrag);
		SAFEIRELEASE(pIElement);
		hr = WBEM_E_OUT_OF_MEMORY;
	}

	return hr;
}

/*------------------------------------------------------------------------
   Name				 :FrameOutputNode
   Synopsis	         :Frames a new output node 
   Type	             :Member Function 
   Input parameter   :
		pINode			- pointer to pointer to IXMLDOMNode object
		bstrOutput		- commandline output
		bstrTarget		- target node
		rParsedInfo		- reference to CParsedInfo object
   Output parameters :
		pINode			- pointer to pointer to IXMLDOMNode object
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :FrameOutputNode(&pINode, bstrOutput, bstrTarget,
								rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::FrameOutputNode(IXMLDOMNode	**pINode, BSTR bstrOutput, 
										BSTR bstrTarget, 
										CParsedInfo& rParsedInfo)
{
	HRESULT					hr					= S_OK;
	IXMLDOMNode				*pISNode			= NULL;
	IXMLDOMCDATASection		*pICDATASec			= NULL;
	_bstr_t					bstrName;
	_variant_t				varType,
							varValue;		
	DWORD					dwThreadId			= GetCurrentThreadId();
	CHString				chsMsg;
	try
	{
		// The nodetype is NODE_ELEMENT
		varType = ((short)NODE_ELEMENT);

		// Append the OUTPUT node together with the output generated.
		bstrName = _T("OUTPUT");
		hr = CreateNodeAndSetContent(&pISNode, varType, 
							bstrName, NULL, rParsedInfo); 
		ONFAILTHROWERROR(hr);

		// Append the attribute "TARGETNODE"
		bstrName = L"TARGETNODE";
		varValue = (WCHAR*) bstrTarget;
		hr = AppendAttribute(pISNode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		// Append the attribute "ITERATION"
		bstrName = L"ITERATION";
		varValue = (long)m_nItrNum;
		hr = AppendAttribute(pISNode, bstrName, varValue, rParsedInfo);
		ONFAILTHROWERROR(hr);

		// Create the CDATASection 
		hr = m_pIXMLDoc->createCDATASection(bstrOutput, &pICDATASec);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::createCDATASection(-, -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);										
		}
		ONFAILTHROWERROR(hr);

		// Append the CDATASection node to the OUTPUT node.
		hr = pISNode->appendChild(pICDATASec, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);		
		}
		ONFAILTHROWERROR(hr);
		SAFEIRELEASE(pICDATASec);

		hr = (*pINode)->appendChild(pISNode, NULL);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNode::appendChild(-, NULL)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);			
		}
		ONFAILTHROWERROR(hr);
		
		SAFEIRELEASE(pISNode);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pICDATASec);
		SAFEIRELEASE(pISNode);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pICDATASec);
		SAFEIRELEASE(pISNode);
		hr = WBEM_E_OUT_OF_MEMORY;

	}
	return hr;
}

/*------------------------------------------------------------------------
   Name				 :AppendOutputNode
   Synopsis	         :appends the newoutput node element to the exisitng
					  and that too last RECORD node
   Type	             :Member Function 
   Input parameter   :
		bstrOutput		- commandline output
		bstrTarget		- target node
		rParsedInfo		- reference to CParsedInfo object
   Output parameters : None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :AppendOutputNode(bstrOutput, bstrTarget,
								rParsedInfo)
   Notes             :None
------------------------------------------------------------------------*/
HRESULT CWMICliXMLLog::AppendOutputNode(BSTR bstrOutput, BSTR bstrTarget,
										CParsedInfo& rParsedInfo)
{
	IXMLDOMNodeList		*pINodeList			= NULL;
	HRESULT				hr					= S_OK;
	LONG				lValue				= 0;	
	IXMLDOMNode			*pINode				= NULL;
	IXMLDOMNode			*pIParent			= NULL,
						*pIClone			= NULL;	
	DWORD				dwThreadId			= GetCurrentThreadId();
	CHString			chsMsg;

	try
	{
		hr = m_pIXMLDoc->getElementsByTagName(_T("RECORD"), &pINodeList);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMDocument2::getElementsByTagName(L\"RECORD\", -)");
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);			
		}
		ONFAILTHROWERROR(hr);

		hr = pINodeList->get_length(&lValue);
		ONFAILTHROWERROR(hr);

		hr = pINodeList->get_item(lValue-1, &pINode);
		if (m_bTrace || m_eloErrLogOpt)
		{
			chsMsg.Format(L"IXMLDOMNodeList::get_item(%d, -)", lValue-1);
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);				
		}
		ONFAILTHROWERROR(hr);

		if (pINode)
		{
			hr = pINode->cloneNode(VARIANT_TRUE, &pIClone);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXMLDOMNode::cloneNode(VARIANT_TRUE, -)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);					
			}
			ONFAILTHROWERROR(hr);

			hr = pINode->get_parentNode(&pIParent);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXMLDOMNode::get_ParentNode(-)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);				
			}
			ONFAILTHROWERROR(hr);

			hr = FrameOutputNode(&pIClone, bstrOutput, bstrTarget, rParsedInfo);
			ONFAILTHROWERROR(hr);

			hr = pIParent->replaceChild(pIClone, pINode, NULL);
			if (m_bTrace || m_eloErrLogOpt)
			{
				chsMsg.Format(L"IXMLDOMNode::replaceChild(-, -, NULL)");
				WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg, 
								   dwThreadId, rParsedInfo, m_bTrace);				
			}
			ONFAILTHROWERROR(hr);
		}
		SAFEIRELEASE(pINodeList);
		SAFEIRELEASE(pIClone);
		SAFEIRELEASE(pIParent);
		SAFEIRELEASE(pINode);
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pINodeList);
		SAFEIRELEASE(pIClone);
		SAFEIRELEASE(pIParent);
		SAFEIRELEASE(pINode);
		hr = e.Error();
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pINodeList);
		SAFEIRELEASE(pIClone);
		SAFEIRELEASE(pIParent);
		SAFEIRELEASE(pINode);
		hr = WBEM_E_OUT_OF_MEMORY;
	}
	return hr;
}

/*----------------------------------------------------------------------------
   Name				 :FindAndDeleteRecord
   Synopsis	         :Search and deletes all the occurences of /RECORD entries 
					  in the given string strString
   Type	             :Member Function 
   Input parameter   :
			strString  - string buffer
   Output parameters :None
   Return Type       :void
   Global Variables  :g_wmiCmd
   Calling Syntax    :FindAndDeleteRecord(strString) 
   Notes             :None
----------------------------------------------------------------------------*/
void CWMICliXMLLog::FindAndDeleteRecord(STRING& strString) 
{
	CHARVECTOR cvTokens = g_wmiCmd.GetTokenVector();
	
	//the iterator to span throuh the vector variable 
	CHARVECTOR::iterator theIterator;

	// Check for the presence of tokens. Absence of tokens indicates
	// no command string is fed as input.
	if (cvTokens.size())
	{
		// Obtain the pointer to the beginning of the token vector.
	    theIterator = cvTokens.begin(); 

		// If first token is forward slash then check for /RECORD entry
		if (CompareTokens(*theIterator, CLI_TOKEN_FSLASH)) 
		{
			DeleteRecord(strString, cvTokens, theIterator);
		}

		while (GetNextToken(cvTokens, theIterator))
		{
			// If token is forward slash then check for /RECORD entry
			// and delete it
			if (CompareTokens(*theIterator, CLI_TOKEN_FSLASH)) 
			{
				DeleteRecord(strString, cvTokens, theIterator);
			}
		}
	}
}


/*----------------------------------------------------------------------------
   Name				 :DeleteRecord
   Synopsis	         :Search and deletes the /RECORD entry at current position 
					  in the given string strString
   Type	             :Member Function 
   Input parameter   :
			strString	- string buffer
			cvTokens    - the tokens vector 
			theIterator - the Iterator to the cvTokens vector.
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :DeleteRecord(strString) 
   Notes             :None
----------------------------------------------------------------------------*/
void CWMICliXMLLog::DeleteRecord(STRING& strString, CHARVECTOR& cvTokens, 
								 CHARVECTOR::iterator& theIterator)
{
	if (GetNextToken(cvTokens, theIterator))
	{
		// if current token is RECORD the delete the complete entry
		if (CompareTokens(*theIterator, CLI_TOKEN_RECORD))
		{
			_TCHAR* pszFromStr = *theIterator;
			_TCHAR* pszToStr = _T("");
			STRING::size_type stFromStrLen = lstrlen(pszFromStr);
			STRING::size_type stToStrLen = lstrlen(pszToStr);

			STRING::size_type stStartPos = 0;
			STRING::size_type stPos = 0;
			stPos = strString.find(pszFromStr, stStartPos, stFromStrLen); 
			strString.replace(stPos, stFromStrLen, pszToStr);
			stStartPos = stPos; 

			// Search and delete forward slash just before RECORD
			pszFromStr = CLI_TOKEN_FSLASH;
			stFromStrLen = lstrlen(pszFromStr);
			
			stPos = strString.rfind(pszFromStr, stStartPos, stFromStrLen); 
			strString.replace(stPos, stFromStrLen, pszToStr);
			stStartPos = stPos; 

			WMICLIINT nCount = 0;

			// Delete the /RECORD value that is /RECORD:<record file name>
			while (GetNextToken(cvTokens, theIterator))
			{
				if (nCount == 0 &&
					!CompareTokens(*theIterator, CLI_TOKEN_COLON))
				{
					// if after /RECORD, next token is not ":" then break
					break;
				}

				// Delete the record file name from command line string
				// which will be recorded in the recorded file
				nCount++;
				pszFromStr = *theIterator;
				stFromStrLen = lstrlen(pszFromStr);

				stPos = strString.find(pszFromStr, stStartPos, stFromStrLen); 
				strString.replace(stPos, stFromStrLen, pszToStr);
				stStartPos = stPos; 

				// Delete only 2 tokens that is ":" and record file name
				if(nCount == 2)
				{
					// Search and delete double quotes that may be 
					// used with record file name 
					pszFromStr = _T("\"\"");
					stFromStrLen = lstrlen(pszFromStr);
					
					stStartPos--;
					stPos = strString.find(pszFromStr, stStartPos, stFromStrLen); 
					if(stPos != strString.npos)
						strString.replace(stPos, stFromStrLen, pszToStr);
					break;
				}
			}
		}
	}

	return;
}


/*----------------------------------------------------------------------------
   Name				 :GetNextToken
   Synopsis	         :This function retrieves the next token from the token 
					  vector list, returns FALSE if no more tokens are present
   Type	             :Member Function
   Input Parameter(s):
		cvTokens     - the tokens vector 
		theIterator  - the Iterator to the cvTokens vector.
   Output Parameter(s):None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetNextToken(cvTokens,theIterator)
   Notes             :None
----------------------------------------------------------------------------*/
BOOL CWMICliXMLLog::GetNextToken(CHARVECTOR& cvTokens, 
								 CHARVECTOR::iterator& theIterator)
{
	theIterator++;
	return (theIterator >= cvTokens.end()) ? FALSE : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\wmicmdln.cpp ===
/***************************************************************************
Copyright information		: Copyright (c) 1998-2002 Microsoft Corporation 
File Name					: WMICommandLine.cpp 
Project Name				: WMI Command Line
Author Name					: Ch. Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This class encapsulates the functionality needed
							  for synchronization the funtionality of three 
							  functional components identified for the 
							  wmic.exe.Object of this class is created in
							  the main program and used to handle 
							  functionality of Parsing Engine, Execution 
							  Engine,and Format Engine thorough class members.
Global Functions			: CompareTokens(_TCHAR* pszTok1, _TCHAR* pszTok2)
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 11th-April-2001	  	
*****************************************************************************/ 
// WmiCmdLn.cpp : implementation file
#include "Precomp.h"
#include "CommandSwitches.h"
#include "GlobalSwitches.h"
#include "HelpInfo.h"
#include "ErrorLog.h"
#include "ParsedInfo.h"
#include "CmdTokenizer.h"
#include "CmdAlias.h"
#include "ParserEngine.h"
#include "ExecEngine.h"
#include "ErrorInfo.h"
#include "WmiCliXMLLog.h"
#include "FormatEngine.h"
#include "wmicmdln.h"
#include "conio.h"

/////////////////////////////////////////////////////////////////////////////
// CWMICommandLine
/*------------------------------------------------------------------------
   Name				 :CWMICommandLine
   Synopsis	         :This function initializes the member variables when
                      an object of the class type is instantiated
   Type	             :Constructor 
   Input parameters   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICommandLine::CWMICommandLine()
{
	m_uErrLevel		= 0;
	m_pIWbemLocator = NULL;
	m_hKey			= NULL;
	m_bBreakEvent	= FALSE;
	m_bAccCmd		= TRUE; //To come out of the program when registering mofs
	m_bDispRes		= TRUE;
	m_bInitWinSock	= FALSE;
	m_bCtrlHandlerError = FALSE;
	EmptyClipBoardBuffer();

	// Set the console control handler
	if (!SetConsoleCtrlHandler((PHANDLER_ROUTINE) CtrlHandler, TRUE))
	{
		m_bCtrlHandlerError = TRUE;

		m_ParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(SET_CONHNDLR_ROUTN_FAIL);
	}
}

/*------------------------------------------------------------------------
   Name				 :~CWMICommandLine
   Synopsis	         :This function uninitializes the member variables 
					  when an object of the class type goes out of scope.
   Type	             :Destructor
   Input parameters   :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :None
   Notes             :None
------------------------------------------------------------------------*/
CWMICommandLine::~CWMICommandLine()
{
	SAFEIRELEASE(m_pIWbemLocator);
}

/*------------------------------------------------------------------------
   Name				 :ScreenBuffer
   Synopsis	         :This function sets/resets screen buffer
   Type	             :Member Function
   Input parameters  :BOOL bSet

						TRUE -> set buffer
						FALSE -> revert to previous

   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
------------------------------------------------------------------------*/
BOOL CWMICommandLine::ScreenBuffer( BOOL bSet )
{
	BOOL bResult = FALSE;
	if ( bSet )
	{
		if ( GetScreenBuffer(m_nHeight, m_nWidth) )
		{
			// Set the console scree buffer size.
			bResult = SetScreenBuffer();
		}
	}
	else
	{
		if ( m_nHeight && m_nWidth )
		{
			bResult = SetScreenBuffer(m_nHeight, m_nWidth);
		}
	}

	return bResult;
}

/*------------------------------------------------------------------------
   Name				 :Uninitialize
   Synopsis	         :This function uninitializes the member variables 
					  when the execution of a command string issued on the
					  command line is completed.It internally calls 
					  uninitialize for CParsedInfo,CExecEngine,ParserEngine
					  and CFormatEngine .
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :Uninitialize()
   Notes             :None
------------------------------------------------------------------------*/
void CWMICommandLine::Uninitialize()
{
	m_ParsedInfo.Uninitialize(TRUE);
	m_ExecEngine.Uninitialize(TRUE);
	m_ParserEngine.Uninitialize(TRUE);
	m_FormatEngine.Uninitialize(TRUE);
	SAFEIRELEASE(m_pIWbemLocator);

	if (m_hKey != NULL)
	{
		RegCloseKey(m_hKey);
		m_hKey = NULL;
	}

	// Uninitialize windows socket interface.
	if ( m_bInitWinSock == TRUE )
		TermWinsock();
	
	m_bmKeyWordtoFileName.clear();
}

/*------------------------------------------------------------------------
   Name				 :Initialize
   Synopsis	         :This function returns initializes the COM library and
					  sets the process security, also it creates an instance
					  of the IWbemLocator object
   Type	             :Member Function
   Input parameters   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :Initialize()
   Notes             :None
------------------------------------------------------------------------*/
BOOL CWMICommandLine::Initialize()
{
	HRESULT hr		= S_OK;
	BOOL	bRet	= TRUE;
	m_bBreakEvent	= FALSE;
	m_bAccCmd		= TRUE; //To come out of the program when registering mofs
	try
	{
		// Initialize the security 
		hr = CoInitializeSecurity(NULL, -1, NULL, NULL, 
								   RPC_C_AUTHN_LEVEL_NONE,
								   RPC_C_IMP_LEVEL_IMPERSONATE,
								   NULL, EOAC_NONE, 0);

		ONFAILTHROWERROR(hr);

		// Create an instance of the IWbemLocator interface.
		hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
							  IID_IWbemLocator, (LPVOID *) &m_pIWbemLocator);
		ONFAILTHROWERROR(hr);

		// Enable the security privileges
		hr = ModifyPrivileges(TRUE);
		ONFAILTHROWERROR(hr);

		try
		{
			hr = RegisterMofs();
			ONFAILTHROWERROR(hr);

			// Initialize the Globalswitches and Commandswitches. 
			m_ParsedInfo.GetGlblSwitchesObject().Initialize();
			m_ParsedInfo.GetCmdSwitchesObject().Initialize();
		}
		catch(WMICLIINT nVal)
		{
			if (nVal == OUT_OF_MEMORY)
			{
				m_ParsedInfo.GetCmdSwitchesObject().
							SetErrataCode(OUT_OF_MEMORY);
			}
	
			// If mofcomp error
			if (nVal == MOFCOMP_ERROR)
			{
				m_ParsedInfo.GetCmdSwitchesObject().
						SetErrataCode(MOFCOMP_ERROR);
			}

			SAFEIRELEASE(m_pIWbemLocator);
			bRet = FALSE;
		}
		catch(DWORD dwError)
		{
			// If Win32 Error
			DisplayString(IDS_E_REGMOF_FAILED, CP_OEMCP, 
							NULL, TRUE, TRUE);
			::SetLastError(dwError);
			DisplayWin32Error();
			m_ParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);

			SAFEIRELEASE(m_pIWbemLocator);
			bRet = FALSE;
		}

		if ( TRUE == bRet )
		{
			GetFileNameMap();
		}
   	}
	catch (_com_error& e)
	{
		SAFEIRELEASE(m_pIWbemLocator);
		m_ParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRet = FALSE;
	}
	return bRet;
}

/*-------------------------------------------------------------------------
   Name				 :GetFormatObject
   Synopsis	         :This function returns a reference to the 
					  CFormatEngine Object
   Type	             :Member Function
   Input parameters   :None
   Output parameters :None
   Return Type       :CFormatEngine &
   Global Variables  :None
   Calling Syntax    :GetFormatObject()
   Notes             :None
-------------------------------------------------------------------------*/
CFormatEngine& CWMICommandLine::GetFormatObject()
{
	return m_FormatEngine;
}
	
/*-------------------------------------------------------------------------
   Name				 :GetParsedInfoObject
   Synopsis	         :This function returns a reference to the 
					  CParsedInfo Object
   Type	             :Member Function
   Input parameters   :None
   Output parameters :None
   Return Type       :CParsedInfo &
   Global Variables  :None
   Calling Syntax    :GetParsedInfoObject()
   Notes             :None
-------------------------------------------------------------------------*/
CParsedInfo& CWMICommandLine::GetParsedInfoObject()
{
	return m_ParsedInfo;
}
	
/*-------------------------------------------------------------------------
   Name				 :ProcessCommandAndDisplayResults
   Synopsis	         :It processes the given command string by giving the  
					  the command to CParsedInfo as input, initializing the 
					  CParserEngine,CExecEngine and CFormatEngine and 
					  synchronizes the operation between all the modules.
   Type	             :Member Function
   Input parameters   :
			pszBuffer - input command string
   Output parameters :None
   Return Type       :SESSIONRETCODE
   Global Variables  :None
   Calling Syntax    :ProcessCommandAndDisplayResults(pszBuffer)
   Notes             :None
-------------------------------------------------------------------------*/
SESSIONRETCODE CWMICommandLine::ProcessCommandAndDisplayResults(
												_TCHAR* pszBuffer)
{
	SESSIONRETCODE  ssnRetCode	= SESSION_SUCCESS;
	try
	{
		// Initialize the local variables.
		ULONG			ulRetTime	= 0;
		RETCODE			retCode		= PARSER_EXECCOMMAND;
		BOOL			bExecute	= FALSE;
		BOOL			bFirst		= TRUE;
		_bstr_t			bstrXML		= L"";		
		_bstr_t			bstrAggregateXML = L"";
		_bstr_t			bstrTempXML = L"";
		_bstr_t			bstrHeader	= L"";
		_bstr_t			bstrRequest;

		// Reset the erratacode
		m_ParsedInfo.GetCmdSwitchesObject().SetErrataCode(0);
		m_ParsedInfo.SetNewCycleStatus(FALSE);
		m_ParsedInfo.SetNewCommandStatus(TRUE);

		//Store the starttime and increment the commandsequence
		// number to one.
		if (!m_ParsedInfo.GetGlblSwitchesObject().SetStartTime())
		{
			m_ParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
			ssnRetCode = SESSION_ERROR;
		}

		//Initialize the command input in CParsedInfo
		if(!m_ParsedInfo.GetCmdSwitchesObject().SetCommandInput(pszBuffer))
		{
			m_ParsedInfo.GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
			ssnRetCode = SESSION_ERROR;
		}
		
		if(ssnRetCode != SESSION_ERROR)
		{
			//Tokenize the command string as per the pre-defined delimiters
			if (m_ParserEngine.GetCmdTokenizer().TokenizeCommand(pszBuffer))
			{
				// Check whether the input indicates end of session.
				// i.e either QUIT or EXIT 
				if(!IsSessionEnd())
				{
					//Setting the IWbemLocator object .
					m_ParserEngine.SetLocatorObject(m_pIWbemLocator);

					// Initilaize ParsedInfo Object to release earlier messages
					m_ParsedInfo.Initialize();

					//Call CParserEngine ProcessTokens to process the 
					//tokenized commands .	
					retCode = m_ParserEngine.ProcessTokens(m_ParsedInfo);

					//Checking if the return code indicates Command execution
					if (retCode == PARSER_EXECCOMMAND)
					{
						// Check whether user should be prompted for password
						CheckForPassword();

						// Obtain the /EVERY interval value
						ulRetTime = m_ParsedInfo.GetCmdSwitchesObject()
									.GetRetrievalInterval();

						// Set the execute flag to TRUE.
						bExecute = TRUE;

						CHARVECTOR cvNodesList = 
								m_ParsedInfo.GetGlblSwitchesObject().
								GetNodesList();
						CHARVECTOR::iterator iNodesIterator;
						m_ParsedInfo.SetNewCommandStatus(TRUE);
						
						BOOL bXMLEncoding = FALSE;
						_TCHAR *pszVerbName = m_ParsedInfo.
												GetCmdSwitchesObject().
												GetVerbName(); 
						if(CompareTokens(pszVerbName, CLI_TOKEN_GET)
							|| CompareTokens(pszVerbName, CLI_TOKEN_LIST)
							|| CompareTokens(pszVerbName, CLI_TOKEN_ASSOC)
							|| pszVerbName == NULL)
						{
							bXMLEncoding = TRUE;
						}
						
						BOOL bBreak		= TRUE;
						BOOL bMsgFlag	= FALSE;
						LONG lLoopCount = 0;
						ULONG ulRepeatCount = 
							m_ParsedInfo.GetCmdSwitchesObject().
															 GetRepeatCount();
						BOOL			bFirstEvery = TRUE;
						OUTPUTSPEC		opsOutOpt	= 
							m_ParsedInfo.GetGlblSwitchesObject().
												GetOutputOrAppendOption(TRUE);
						while (TRUE)
						{
							m_ParsedInfo.SetNewCycleStatus(TRUE);
							if(bXMLEncoding)
							{
								bstrHeader = L"";
							}

							// Iterate thru the list of nodes
							for ( iNodesIterator = cvNodesList.begin(); 
								  iNodesIterator <
								  cvNodesList.end(); iNodesIterator++ )
							{
								if(bXMLEncoding)
								{
									bstrTempXML = L"";
								}
								
								// Reset the error and information code(s).
								m_ParsedInfo.GetCmdSwitchesObject().
										SetInformationCode(0);
								m_ParsedInfo.GetCmdSwitchesObject().
										SetErrataCode(0);
									
								if ( iNodesIterator == cvNodesList.begin() && 
									 cvNodesList.size() > 1 )
									 continue;

								if(!bXMLEncoding)
								{
									if ( cvNodesList.size() > 2 )
									{
										_bstr_t bstrNode;
										WMIFormatMessage(IDS_I_NODENAME_MSG, 1,
											bstrNode, (LPWSTR)*iNodesIterator);
										DisplayMessage((LPWSTR)bstrNode, 
														CP_OEMCP, 
														FALSE, FALSE);
									}
								}
								else
								{
									CHString		sBuffer;
									_bstr_t bstrRessultsNode = 
															(*iNodesIterator);
									FindAndReplaceEntityReferences(
															bstrRessultsNode);
									sBuffer.Format(L"<RESULTS NODE=\"%s\">", 
													(LPWSTR)bstrRessultsNode);
									bstrTempXML += _bstr_t(sBuffer);
								}

								// Setting the locator object .
								m_ExecEngine.SetLocatorObject(m_pIWbemLocator);

								m_ParsedInfo.GetGlblSwitchesObject().
													SetNode(*iNodesIterator);

								//Call ExecEngine ExecuteCommand to execute the
								// tokenized command
								if (m_ExecEngine.ExecuteCommand(m_ParsedInfo))
								{ 
									// Set the successflag to TRUE
									m_ParsedInfo.GetCmdSwitchesObject().
												SetSuccessFlag(TRUE);

									if(bXMLEncoding)
									{
										// Append the XML result set obtained 
										// to the aggregated output 
										if (m_ParsedInfo.GetCmdSwitchesObject().
														GetXMLResultSet())
										{
											bstrTempXML	+= _bstr_t(m_ParsedInfo.
														GetCmdSwitchesObject().
														GetXMLResultSet());
										}
																
										// Free the XML result set.
										m_ParsedInfo.GetCmdSwitchesObject().
													SetXMLResultSet(NULL);
									}
									else
									{
										bBreak = TRUE;
										if (!m_FormatEngine.
												DisplayResults(m_ParsedInfo))
										{
											ssnRetCode = SESSION_ERROR;
											SetSessionErrorLevel(ssnRetCode);
											break;
										}
										m_ParsedInfo.SetNewCommandStatus(FALSE);
										m_ParsedInfo.SetNewCycleStatus(FALSE);
									}
								}
								else
								{
									//Set the sucess flag to FALSE 
									m_ParsedInfo.GetCmdSwitchesObject().
														SetSuccessFlag(FALSE);
									ssnRetCode	= SESSION_ERROR;

									if(bXMLEncoding)
									{
										_bstr_t bstrNode, bstrError;
										UINT uErrorCode = 0;

										WMIFormatMessage(IDS_I_NODENAME_MSG, 1,
											bstrNode, (LPWSTR)*iNodesIterator);
										DisplayMessage((LPWSTR)bstrNode, 
														CP_OEMCP, 
														TRUE, FALSE);
								
										// Retrieve the error code
										uErrorCode = m_ParsedInfo.
													GetCmdSwitchesObject().
													 GetErrataCode() ;
										if ( uErrorCode != 0 )
										{
											_bstr_t	bstrTemp;
											CHString		sBuffer;
											WMIFormatMessage(uErrorCode, 
													0, bstrTemp, NULL);

											sBuffer.Format(L"<ERROR><DESCRIPTION>"
															 L"%s</DESCRIPTION>"
															 L"</ERROR>",
															(LPWSTR)(bstrTemp));
											bstrError = _bstr_t(sBuffer);
											// Write the error to stderr
											DisplayMessage((LPWSTR)bstrTemp, 
														CP_OEMCP, TRUE, FALSE);
										}
										else
										{
											m_FormatEngine.
												GetErrorInfoObject().
													GetErrorFragment(
													m_ParsedInfo.
													GetCmdSwitchesObject().
													GetCOMError()->Error(), 
													bstrError);

											// Write the error to stderr
											m_FormatEngine.DisplayCOMError(m_ParsedInfo);
										}
										bstrTempXML += bstrError;
									}
									else
									{
										bBreak = TRUE;
										if (!m_FormatEngine.
											DisplayResults(m_ParsedInfo))
										{
											// Set the session error level 
											SetSessionErrorLevel(ssnRetCode);
											break;
										}
										m_ParsedInfo.SetNewCommandStatus(FALSE);
									}
									
									// Set the session error level 
									SetSessionErrorLevel(ssnRetCode);
								}

								if(bXMLEncoding)
									bstrTempXML += L"</RESULTS>";
								
								if(bXMLEncoding && bFirst)
								{
									bFirst = FALSE;
									FrameXMLHeader(bstrHeader, lLoopCount);
									
									if(lLoopCount == 0)
										FrameRequestNode(bstrRequest);
									bstrXML += bstrHeader;
									bstrXML += bstrRequest;
								}

								m_ExecEngine.Uninitialize();
								m_FormatEngine.Uninitialize();
								m_ParsedInfo.GetCmdSwitchesObject().
												SetCredentialsFlag(FALSE);
								m_ParsedInfo.GetCmdSwitchesObject().
												FreeCOMError();
								m_ParsedInfo.GetCmdSwitchesObject().
												SetSuccessFlag(TRUE);

								if(bXMLEncoding)
								{
									if(!m_ParsedInfo.GetGlblSwitchesObject().
												GetAggregateFlag())
									{
										_bstr_t bstrNodeResult = L"";
										bstrNodeResult += bstrXML;
										bstrNodeResult += bstrTempXML;
										bstrNodeResult += L"</COMMAND>";
										m_ParsedInfo.GetCmdSwitchesObject().
												SetXMLResultSet((LPWSTR) 
													bstrNodeResult);

										if (!m_FormatEngine.
												DisplayResults(m_ParsedInfo))
										{
											bBreak = TRUE;
											ssnRetCode = SESSION_ERROR;
											SetSessionErrorLevel(ssnRetCode);
											m_FormatEngine.Uninitialize();
											break;
										}
										m_ParsedInfo.SetNewCommandStatus(FALSE);
										m_ParsedInfo.SetNewCycleStatus(FALSE);
										m_FormatEngine.Uninitialize();
									}
									else
									{
										bstrAggregateXML += bstrTempXML;
									}
								}

								if (_kbhit()) 
								{
									_getch();
									bBreak = TRUE;
									break;
								}

								if (GetBreakEvent() == TRUE)
								{
									bBreak = TRUE;
									break;
								}
							}
							
							if(m_ParsedInfo.GetGlblSwitchesObject().
									GetAggregateFlag() && bXMLEncoding)
							{
								bstrXML += bstrAggregateXML;
								bstrXML += L"</COMMAND>";
								bFirst	= TRUE;
								m_ParsedInfo.GetCmdSwitchesObject().
										SetXMLResultSet((LPWSTR) bstrXML);
								if (!m_FormatEngine.
										DisplayResults(m_ParsedInfo))
								{
									bBreak = TRUE;
									ssnRetCode = SESSION_ERROR;
									SetSessionErrorLevel(ssnRetCode);
									m_FormatEngine.Uninitialize();
									break;
								}
								m_FormatEngine.Uninitialize();
								bstrAggregateXML = L"";
								bstrXML = L"";
								m_ParsedInfo.SetNewCommandStatus(FALSE);
							}

							//Checking the Sucess flag and the retrievel time .
							if (m_ParsedInfo.GetCmdSwitchesObject().
								GetSuccessFlag() == TRUE && 
								m_ParsedInfo.GetCmdSwitchesObject().
								GetEverySwitchFlag() == TRUE )
							{
								CONSOLE_SCREEN_BUFFER_INFO	csbiInfo;
								HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

								if( INVALID_HANDLE_VALUE != hStdOut)
								{
									GetConsoleScreenBufferInfo(hStdOut, &csbiInfo);
								}

								bBreak = FALSE;
								lLoopCount++;

								if (!IsRedirection() && 
											GetBreakEvent() == FALSE)
								{
									if ( opsOutOpt == STDOUT || 
										 bFirstEvery == TRUE)
									{
										DisplayString(IDS_I_HAKTBTC, CP_OEMCP, 
													NULL, TRUE, TRUE);
										bMsgFlag = TRUE;
										bFirstEvery = FALSE;
									}
								}
								
								if ( ulRepeatCount != 0 )
								{
									if ( lLoopCount >= ulRepeatCount )
									{
										if (bMsgFlag && !IsRedirection())
											EraseConsoleString(&csbiInfo);
										bBreak = TRUE;
									}
								}

								//No action till time out is no over 
								// Or no key is hit.
								if(!bBreak)
								{
									SleepTillTimeoutOrKBhit(ulRetTime * 1000);
								
									if (bMsgFlag && !IsRedirection())
									{
										if ( opsOutOpt == STDOUT )
										{
											bMsgFlag = FALSE;
											EraseConsoleString(&csbiInfo);
										}
									}
								}

								if (_kbhit()) 
								{
									_getch();
									if (bMsgFlag && !IsRedirection())
										EraseConsoleString(&csbiInfo);
									bBreak = TRUE;
								}

								if (GetBreakEvent() == TRUE)
									bBreak = TRUE;
							}
							else
								bBreak = TRUE;

							if (bBreak)
								break;
						}
					}
					else if ((retCode == PARSER_ERRMSG) || 
							(retCode == PARSER_ERROR))
					{
						// Set the success flag to FALSE
						m_ParsedInfo.GetCmdSwitchesObject().
										SetSuccessFlag(FALSE);
						ssnRetCode	= SESSION_ERROR;

						// Display the error message 
						if (!m_FormatEngine.DisplayResults(m_ParsedInfo))
							ssnRetCode = SESSION_ERROR;
					}
					else if (retCode == PARSER_OUTOFMEMORY)
					{
						ssnRetCode = SESSION_ERROR;
					}
					else 
					{
						CheckForPassword();

						// Set the success flag to TRUE
						m_ParsedInfo.GetCmdSwitchesObject().
									SetSuccessFlag(TRUE);
						ssnRetCode	= SESSION_SUCCESS;

						// Display the information
						if (!m_FormatEngine.DisplayResults(m_ParsedInfo))
							ssnRetCode = SESSION_ERROR;
					}
				}
				else
				{
					ssnRetCode = SESSION_QUIT;
				}
			}
			else
			{
				m_ParsedInfo.GetCmdSwitchesObject().
								SetErrataCode(OUT_OF_MEMORY);
				ssnRetCode = SESSION_ERROR;
			}
		}

		// Set the session error level to be returned.
		if (!bExecute)
			SetSessionErrorLevel(ssnRetCode);		
	}
	catch(_com_error& e)
	{
		m_ParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		m_FormatEngine.DisplayResults(m_ParsedInfo);
		ssnRetCode = SESSION_ERROR;
		SetSessionErrorLevel(ssnRetCode);
	}
	catch(CHeap_Exception)
	{
		_com_error e(WBEM_E_OUT_OF_MEMORY);
		m_ParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		m_FormatEngine.DisplayResults(m_ParsedInfo);
		ssnRetCode = SESSION_ERROR;
		g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
	}
	catch(DWORD dwError)
	{
		::SetLastError(dwError);
		DisplayWin32Error();
		::SetLastError(dwError);
		ssnRetCode = SESSION_ERROR;
		g_wmiCmd.SetSessionErrorLevel(ssnRetCode);
	}
	catch(WMICLIINT nVal)
	{
        if (nVal == OUT_OF_MEMORY)
        {
            GetParsedInfoObject().GetCmdSwitchesObject().SetErrataCode(OUT_OF_MEMORY);
            GetParsedInfoObject().GetCmdSwitchesObject().SetSuccessFlag(FALSE);
            m_FormatEngine.DisplayResults(m_ParsedInfo);
            ssnRetCode = SESSION_ERROR;
            SetSessionErrorLevel(ssnRetCode);
        }
        else if (nVal == MULTIPLENODE_ERROR)
        {
            GetParsedInfoObject().GetCmdSwitchesObject().SetErrataCode(IDS_E_MULTIPLENODE_ERROR);
            GetParsedInfoObject().GetCmdSwitchesObject().SetSuccessFlag(FALSE);
            m_FormatEngine.DisplayResults(m_ParsedInfo);
            ssnRetCode = SESSION_ERROR;
            SetSessionErrorLevel(ssnRetCode);
        }
	}	
	catch(...)
	{	
		ssnRetCode = SESSION_ERROR;
		GetParsedInfoObject().GetCmdSwitchesObject().
						SetErrataCode(UNKNOWN_ERROR);
		SetSessionErrorLevel(ssnRetCode);
		DisplayString(IDS_E_WMIC_UNKNOWN_ERROR, CP_OEMCP, 
							NULL, TRUE, TRUE);
	}

	if(ssnRetCode != SESSION_QUIT)
	{
		//sets the help flag
		m_ParsedInfo.GetGlblSwitchesObject().SetHelpFlag(FALSE);
		m_ParsedInfo.GetGlblSwitchesObject().SetAskForPassFlag(FALSE);
		
		//Call Uninitialize on Parse Info 
		m_ParsedInfo.Uninitialize(FALSE);
		
		//Call Uninitialize on Execution Engine
		m_ExecEngine.Uninitialize();

		//Call Uninitialize on Format Engine
		m_FormatEngine.Uninitialize();
		
		//Call Uninitialize Parser Engine
		m_ParserEngine.Uninitialize();
	}
	m_ParsedInfo.SetNewCommandStatus(FALSE);
	
	return ssnRetCode;
}

/*-------------------------------------------------------------------------
   Name				 :PollForKBhit
   Synopsis	         :Polls for keyboard input
   Type	             :Member Function (Thread procedure)
   Input parameters   :LPVOID lpParam
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :PollForKBhit(lpParam)
   Notes             :None
-------------------------------------------------------------------------*/
DWORD WINAPI CWMICommandLine::PollForKBhit(LPVOID lpParam)
{
	HANDLE hEvent = NULL;
	hEvent = *((HANDLE*) lpParam );
	//Checks the console for keyboard input
	while (1 )
	{
		if ( _kbhit() )
			break;
		else if ( WaitForSingleObject(hEvent, 500) != WAIT_TIMEOUT )
			break;
	}
	return(0);
}

/*-------------------------------------------------------------------------
   Name				 :SleepTillTimeoutOrKBhit
   Synopsis	         :It causes the process to enter a wait state  
				      by WaitForSingleObject .
					  It creates a thread and executed PollForKBhit.					  
   Type	             :Member Function
   Input parameters   :
			dwMilliSeconds - time-out interval in milliseconds				
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :SleepTillTimeoutOrKBhit( dwMilliSeconds)
   Notes             :None
-------------------------------------------------------------------------*/
void CWMICommandLine::SleepTillTimeoutOrKBhit(DWORD dwMilliSeconds)
{
	DWORD dwThreadId = 0;
	HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	//Create thread and execute PollForKBhit.					  	
	HANDLE hPollForKBhit = CreateThread(0, 0, 
				(LPTHREAD_START_ROUTINE)PollForKBhit, &hEvent, 0, &dwThreadId);
		
	//waits for the hPollForKBhit state or the time-out interval to elapse.
	
	DWORD dwWait = WaitForSingleObject(hPollForKBhit, dwMilliSeconds); 
	if ( dwWait == WAIT_TIMEOUT )
	{
		SetEvent( hEvent );
		WaitForSingleObject(hPollForKBhit, INFINITE); 
	}
	CloseHandle(hEvent);
	CloseHandle(hPollForKBhit);
}

/*-------------------------------------------------------------------------
   Name				 :IsSessionEnd
   Synopsis	         :It checks whether the keyed-in input indicates end of
					  the session. i.e "quit" has been specified as the 1st
					  token.
   Type	             :Member Function
   Input parameters   :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :IsSessionEnd()
   Notes             :None
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::IsSessionEnd()
{
	// Obtain the token vector.
	CHARVECTOR cvTokens = m_ParserEngine.GetCmdTokenizer().GetTokenVector();
	//the iterator to span throuh the vector variable 
	CHARVECTOR::iterator theIterator;
	BOOL bRet=FALSE;
	// Check for the presence of tokens. Absence of tokens indicates
	// no command string is fed as input.
	if (cvTokens.size())
	{
		// Obtain the pointer to the beginning of the token vector.
	    theIterator = cvTokens.begin(); 

		// Check for the presence of the keyword 'quit'
		if (CompareTokens(*theIterator, CLI_TOKEN_QUIT) 
			|| CompareTokens(*theIterator, CLI_TOKEN_EXIT))
		{
			bRet=TRUE;
		}
	}
	return bRet;
}

/*-------------------------------------------------------------------------
   Name				 :SetSessionErrorLevel
   Synopsis	         :Set the session error level value
   Type	             :Member Function
   Input parameters  :
		ssnRetCode	 - session return code
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetSessionErrorLevel()
-------------------------------------------------------------------------*/
//Set the session error value
void CWMICommandLine::SetSessionErrorLevel(SESSIONRETCODE ssnRetCode)
{
	try
	{
		if (ssnRetCode == SESSION_ERROR)
		{
			// If the COM error is not NULL , then display the error
			if (m_ParsedInfo.GetCmdSwitchesObject().GetCOMError())
			{
				// Getting the _com_error data.
				_com_error*	pComError = m_ParsedInfo.GetCmdSwitchesObject().
								GetCOMError();
				m_uErrLevel = pComError->Error();
			}
	
			CHString	chsMsg(_T("command: "));
			chsMsg += m_ParsedInfo.GetCmdSwitchesObject().GetCommandInput();
			DWORD dwThreadId = GetCurrentThreadId();
			
			if (m_ParsedInfo.GetCmdSwitchesObject().GetErrataCode())
			{
				m_uErrLevel = m_ParsedInfo.GetCmdSwitchesObject().GetErrataCode();
				if (m_uErrLevel == OUT_OF_MEMORY)
				{
					DisplayString(IDS_E_MEMALLOCFAILED, CP_OEMCP, 
								NULL, TRUE, TRUE);
				}
				if (m_uErrLevel == SET_CONHNDLR_ROUTN_FAIL)
				{
					DisplayString(IDS_E_CONCTRL_HNDLRSET, CP_OEMCP, 
								NULL, TRUE, TRUE);
				}
				if ( m_uErrLevel == OUT_OF_MEMORY || 
					 m_uErrLevel == SET_CONHNDLR_ROUTN_FAIL )
				{
					if (m_ParsedInfo.GetErrorLogObject().GetErrLogOption())	
					{
						chsMsg += _T(", Utility returned error ID.");
						// explicit error -1 to specify errata code. 
						WMITRACEORERRORLOG(-1, __LINE__, __FILE__, 
									(LPCWSTR)chsMsg, 
									dwThreadId, m_ParsedInfo, FALSE, 
									m_ParsedInfo.GetCmdSwitchesObject()
												.GetErrataCode());
					}
				}
					 
				if ( m_uErrLevel == ::GetLastError() )
				{
					if (m_ParsedInfo.GetErrorLogObject().GetErrLogOption())	
					{
						WMITRACEORERRORLOG(-1,	__LINE__, __FILE__, 
											_T("Win32Error"), dwThreadId, 
											m_ParsedInfo, FALSE,
											m_uErrLevel);
					}
				}

				if (m_uErrLevel == MOFCOMP_ERROR)
				{
					if (m_ParsedInfo.GetErrorLogObject().GetErrLogOption())	
					{
						WMITRACEORERRORLOG(-1,	__LINE__, __FILE__, 
										_T("MOF Compilation Error (the errorlevel "
										   L"is utility specific)"), dwThreadId,
										m_ParsedInfo, FALSE, m_uErrLevel);
					}
				}
			}
		}
		else
		{
			// Set the error level to 0
			m_uErrLevel = 0; 
		}
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*-------------------------------------------------------------------------
   Name				 :GetSessionErrorLevel
   Synopsis	         :Get the session error value
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :WMICLIUINT
   Global Variables  :None
   Calling Syntax    :GetSessionErrorLevel()
-------------------------------------------------------------------------*/
WMICLIUINT CWMICommandLine::GetSessionErrorLevel()
{
	return m_uErrLevel;
}

/*-------------------------------------------------------------------------
   Name				 :CheckForPassword
   Synopsis	         :Prompt for user password, in case user is specified 
					  without password.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :CheckForPassword()
-------------------------------------------------------------------------*/
void CWMICommandLine::CheckForPassword()
{
	if ( m_ParsedInfo.GetGlblSwitchesObject().GetAskForPassFlag() == TRUE &&
		 m_ParsedInfo.GetGlblSwitchesObject().GetUser() != NULL )
	{
		_TCHAR szPassword[BUFFER64] = NULL_STRING;
		DisplayString(IDS_I_PWD_PROMPT, CP_OEMCP, NULL, TRUE);
		AcceptPassword(szPassword);
		m_ParsedInfo.GetGlblSwitchesObject().SetPassword(
												szPassword);
	}
}

/*-------------------------------------------------------------------------
   Name				 :RegisterMofs
   Synopsis	         :Register the mof file(s) if not registered earlier.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :RegisterMofs()
-------------------------------------------------------------------------*/
HRESULT CWMICommandLine::RegisterMofs() 
{
	HRESULT						hr						= S_OK;
	IMofCompiler				*pIMofCompiler			= NULL;
	BOOL						bCompile				= FALSE;
	BOOL						bFirst					= FALSE;
	DWORD						dwBufSize				= BUFFER32;
	_TCHAR						pszLocale[BUFFER32]		= NULL_STRING;
	_TCHAR						szKeyValue[BUFFER32]	= NULL_STRING;
	_TCHAR*						pszBuffer				= NULL;
	WMICLIINT					nError					= 0;
	HRESULT						hRes					= S_OK;
	LONG						lRetVal					= 0;
	CONSOLE_SCREEN_BUFFER_INFO	csbiInfo;

	// this structures check timestamps
	const WMICLIINT iMofCount = 3;

	LPCWSTR pMofTable [iMofCount] =
	{
		L"Cli.mof",
		L"CliEgAliases.mof",
		L"CliEgAliases.mfl"
	};

	__int64 pFileTime [ iMofCount ] = { 0 } ;

	try
	{
		_bstr_t bstrMofPath, bstrNS;

		// Check|Create the registry entry.
		bFirst = IsFirstTime();

		// Check whether the "mofcompstatus" key value is 0
		if (!bFirst)
		{
			// Query the "mofcompstatus" mode
			lRetVal = RegQueryValueEx(m_hKey, L"mofcompstatus", NULL, NULL,
			                 (LPBYTE)szKeyValue, &dwBufSize);
			if (lRetVal == ERROR_SUCCESS)

			{
				// If the value is not "1", then set the bFirst to TRUE
				if (!CompareTokens(szKeyValue, CLI_TOKEN_ONE))
				{
					bCompile = TRUE;
				}
			}
			else
			{
				::SetLastError(lRetVal);
				throw (::GetLastError());
			}
		}

		// If the WMIC is being used for the first time.
		if (bFirst)
		{
			HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
			if( INVALID_HANDLE_VALUE == hStdOut || false == GetConsoleScreenBufferInfo(hStdOut, &csbiInfo))
			{
				csbiInfo.srWindow.Bottom = csbiInfo.srWindow.Top = 0;
			}
			DisplayString(IDS_I_WMIC_INST, CP_OEMCP);
		}

		UINT nSize  = 0;
		pszBuffer = new _TCHAR [MAX_PATH+1];

		if(pszBuffer == NULL)
			throw OUT_OF_MEMORY;

		// Obtain the system directory path
		nSize = GetSystemDirectory(pszBuffer, MAX_PATH+1);

		if(nSize)
		{
			if (nSize > MAX_PATH)
			{
				SAFEDELETE(pszBuffer);
				pszBuffer =	new _TCHAR [nSize + 1];
				if(pszBuffer == NULL)
				{
					throw OUT_OF_MEMORY;
				}

				if (!GetSystemDirectory(pszBuffer, nSize+1))
				{
					SAFEDELETE(pszBuffer);
					throw (::GetLastError());
				}
			}
		}
		else
		{
			throw(::GetLastError());
		}

		/* Frame the location of the mof file(s) %systemdir%\\wbem\\ */
		bstrMofPath = _bstr_t(pszBuffer) + _bstr_t(L"\\wbem\\");
		SAFEDELETE(pszBuffer);

		// Check whether file timestamps are equal
		if (!EqualTimeStamps(bstrMofPath, pMofTable, pFileTime, sizeof ( pMofTable ) / sizeof ( LPCWSTR )))
		{
			if (!bFirst)
			{
				bCompile = TRUE;
			}
		}

		// If the WMIC is being updated !!!
		if ( bCompile )
		{
			HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
			if( INVALID_HANDLE_VALUE == hStdOut || false == GetConsoleScreenBufferInfo(hStdOut, &csbiInfo))
			{
				csbiInfo.srWindow.Bottom = csbiInfo.srWindow.Top = 0;
			}
			DisplayString(IDS_I_WMIC_UPDATE, CP_OEMCP);
		}

		if (bFirst || bCompile)
		{
			// Create an instance of the IMofCompiler interface.
			hr = CoCreateInstance(CLSID_MofCompiler,	
									 NULL,				
									 CLSCTX_INPROC_SERVER,
									 IID_IMofCompiler,
									 (LPVOID *) &pIMofCompiler);
			ONFAILTHROWERROR(hr);

			for ( WMICLIINT iMofIndex = 0; iMofIndex < ( sizeof ( pMofTable ) / sizeof ( LPCWSTR ) ); iMofIndex++ )
			{
				// Register the xxxxx.mof
				hr = CompileMOFFile(pIMofCompiler, 
									bstrMofPath + _bstr_t(pMofTable[iMofIndex]),
									nError);

				if ( FAILED ( hr ) || nError )
				{
					MofCompFailureCleanUp ( pMofTable, sizeof ( pMofTable ) / sizeof ( LPCWSTR ) );
				}

				ONFAILTHROWERROR(hr);
				if (nError)
					throw MOFCOMP_ERROR;
			}

			SAFEIRELEASE(pIMofCompiler);

			// Set the filestamps
			SetTimeStamps ( pMofTable, pFileTime, sizeof ( pMofTable ) / sizeof ( LPCWSTR ) );

			// Set the default value.
			lRetVal = RegSetValueEx(m_hKey, L"mofcompstatus", 0, 
								REG_SZ, (LPBYTE) CLI_TOKEN_ONE,
								lstrlen(CLI_TOKEN_ONE) + 1);
								
			if (lRetVal != ERROR_SUCCESS)
			{
				::SetLastError(lRetVal);
				// failed to set the default value
				throw (::GetLastError());
			}
		}

		if (m_hKey != NULL)
		{
			RegCloseKey(m_hKey);
			m_hKey = NULL;
		}
	}
	catch(WMICLIINT nErr)
	{
		SAFEIRELEASE(pIMofCompiler);
		SAFEDELETE(pszBuffer);
		if (m_hKey != NULL)
		{
			RegCloseKey(m_hKey);
			m_hKey = NULL;
		}
		throw nErr;
	}
	catch(_com_error& e)
	{
		SAFEIRELEASE(pIMofCompiler);
		SAFEDELETE(pszBuffer);
		hr = e.Error();
		if (m_hKey != NULL)
		{
			RegCloseKey(m_hKey);
			m_hKey = NULL;
		}
	}
	catch (DWORD dwError)
	{
		SAFEIRELEASE(pIMofCompiler);
		SAFEDELETE(pszBuffer);
		if (m_hKey != NULL)
		{
			RegCloseKey(m_hKey);
			m_hKey = NULL;
		}
		throw dwError;
	}

	if ( bFirst || bCompile )
	{
		EraseConsoleString(&csbiInfo);
	}

	return hr;
}

void CWMICommandLine::MofCompFailureCleanUp( LPCWSTR mofs[], DWORD dw_mofs )
{
	// delete registry values for timestamps if it exists
	if ( m_hKey )
	{
		DWORD	dwSize	= dw_mofs;

		for ( DWORD dwIndex = 0; dwIndex < dwSize; dwIndex++ )
		{
			RegDeleteValueW ( m_hKey, mofs [ dwIndex ] );
		}
	}

	// delete namespace to avoid inconsistency
	IWbemServices	*pISvc		= NULL;
	_bstr_t bstrNSRoot			= L"\\\\.\\root";

	HRESULT hr = m_pIWbemLocator->ConnectServer(bstrNSRoot, NULL, NULL, NULL, 0, NULL, NULL, &pISvc);

	// If the namespace does not exist.
	if (SUCCEEDED(hr))
	{
		_bstr_t bstrNSPath = L"__Namespace.Name=\"cli\"";
		hr = pISvc->DeleteInstance(bstrNSPath, 0, NULL, NULL);
	}

	SAFEIRELEASE(pISvc);
}

BOOL CWMICommandLine::EqualTimeStamps( const _bstr_t& path, LPCWSTR mofs[], __int64* filestamps, DWORD dw_mofs )
{
	BOOL	bRetVal = TRUE;

	DWORD dwSize = dw_mofs;
	HANDLE hFile = INVALID_HANDLE_VALUE;

	try
	{
		DWORD	dwDataSize		= 128 * sizeof ( WCHAR );
		WCHAR	pData[128]		= NULL_STRING;

		FILETIME ftCreate;
		FILETIME ftAccess;
		FILETIME ftWrite;
		LARGE_INTEGER liMofcompTime;
		liMofcompTime.QuadPart = 0;

		FILETIME ft;

		for ( DWORD dwIndex = 0; dwIndex < dwSize; dwIndex++ )
		{
			hFile = CreateFileW	(	_bstr_t ( path + _bstr_t ( mofs [ dwIndex ] ) ),
									GENERIC_READ,
									FILE_SHARE_READ,
									NULL,
									OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL,
									NULL
								);

			if ( hFile && hFile != INVALID_HANDLE_VALUE )
			{
				if ( GetFileTime ( hFile, &ftCreate, &ftAccess, &ftWrite ) )
				{
					dwDataSize		= 128 * sizeof ( WCHAR );

					if (bRetVal && RegQueryValueExW ( m_hKey, mofs [ dwIndex ], NULL, NULL, reinterpret_cast < LPBYTE > ( pData ), &dwDataSize ) == ERROR_SUCCESS )
					{
						liMofcompTime.QuadPart = _wtoi64 ( pData );

						ft.dwLowDateTime = liMofcompTime.LowPart;
						ft.dwHighDateTime = liMofcompTime.HighPart;

						if ( CompareFileTime ( &ftWrite, &ft ) != 0 )
						{
							bRetVal = FALSE;
						}
					}
					else
					{
						bRetVal = FALSE;
					}

					liMofcompTime.LowPart = ftWrite.dwLowDateTime;
					liMofcompTime.HighPart = ftWrite.dwHighDateTime;
					filestamps[dwIndex] = liMofcompTime.QuadPart;
				}
				else
				{
					bRetVal = FALSE;
				}

				::CloseHandle ( hFile );
				hFile = INVALID_HANDLE_VALUE;
			}
			else
			{
				bRetVal = FALSE;
			}
		}
	}
	catch(WMICLIINT nErr)
	{
		if ( hFile != INVALID_HANDLE_VALUE )
		{
			::CloseHandle ( hFile );
			hFile = INVALID_HANDLE_VALUE;
		}

		throw nErr;
	}
	catch (DWORD dwError)
	{
		if ( hFile != INVALID_HANDLE_VALUE )
		{
			::CloseHandle ( hFile );
			hFile = INVALID_HANDLE_VALUE;
		}

		throw dwError;
	}

	return	bRetVal;
}

BOOL CWMICommandLine::SetTimeStamps( LPCWSTR mofs[], const __int64* filestamps, DWORD dw_mofs )
{
	BOOL	bRetVal = TRUE;
	DWORD	dwSize	= dw_mofs;

	try
	{
		WCHAR	pData[128]		= NULL_STRING;

		for ( DWORD dwIndex = 0; dwIndex < dwSize && bRetVal; dwIndex++ )
		{
			_i64tow(filestamps[dwIndex], pData, 10);

			if ( RegSetValueExW ( m_hKey, mofs [ dwIndex ], NULL, REG_SZ, reinterpret_cast < LPBYTE > ( pData ), ( wcslen ( pData ) + 1 ) * sizeof ( WCHAR ) ) != ERROR_SUCCESS )
			{
				bRetVal = FALSE;
			}
		}
	}
	catch(WMICLIINT nErr)
	{
		throw nErr;
	}
	catch (DWORD dwError)
	{
		throw dwError;
	}

	return	bRetVal;
}

/*-------------------------------------------------------------------------
   Name				 :IsFirstTime
   Synopsis	         :Checks for the availability of the registry location 
					 "HKLM\SOFTWARE\Microsoft\Wbem\WMIC", creates one if does
					  not exist. 
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
   Return Type       :
		BOOL: TRUE	- registry entry created 
			  FALSE - registry entry already available.
   Global Variables  :None
   Calling Syntax    :IsFirstTime()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::IsFirstTime()
{
	BOOL	bFirst					= FALSE;
	DWORD	dwDisposition			= 0;
	TCHAR	szKeyValue[BUFFER32]	= NULL_STRING;
	LONG	lRetVal					= 0;
	
	// Open|Create the registry key
    lRetVal = RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
						L"SOFTWARE\\\\Microsoft\\\\Wbem\\\\WMIC", 
						0, NULL_STRING, REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS, NULL, &m_hKey, &dwDisposition);

	if (lRetVal == ERROR_SUCCESS)
	{
		// If the registry entry is not available
		if (dwDisposition == REG_CREATED_NEW_KEY)
		{
			bFirst = TRUE;
			lstrcpy(szKeyValue, _T("0"));
			// Set the default value i.e '0'.
			lRetVal = RegSetValueEx(m_hKey, L"mofcompstatus", 0, 
								REG_SZ, (LPBYTE) szKeyValue,
								lstrlen(szKeyValue) + 1);
			
			if (lRetVal != ERROR_SUCCESS)
			{
				// failed to set the default value
				::SetLastError(lRetVal);
				throw (::GetLastError());
			}
		}
	}
	else
	{
		::SetLastError(lRetVal);
		throw (::GetLastError());
	}
	return bFirst;
}

/*-------------------------------------------------------------------------
   Name				 :IsNSAvailable
   Synopsis	         :Checks whether the namespace specified exists
   Type	             :Member Function
   Input parameters  :
			bstrNS	- namespace
   Output parameters :None
   Return Type       :
		BOOL: TRUE	- namespace exists
			  FALSE - namespace does not exist
   Global Variables  :None
   Calling Syntax    :IsNSAvailable()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::IsNSAvailable(const _bstr_t& bstrNS)
{
	HRESULT			hr			= S_OK;
	IWbemServices	*pISvc		= NULL;
	BOOL			bNSExist	= TRUE;
	hr = m_pIWbemLocator->ConnectServer(bstrNS, NULL, NULL, NULL, 0,
							NULL, NULL, &pISvc);

	// If the namespace does not exist.
	if (FAILED(hr) && (hr == WBEM_E_INVALID_PARAMETER 
					|| hr == WBEM_E_INVALID_NAMESPACE))
	{
		bNSExist = FALSE;
	}
	SAFEIRELEASE(pISvc);
	return bNSExist;
}

/*-------------------------------------------------------------------------
   Name				 :CompileMOFFile
   Synopsis	         :mofcomp's the file specified as input parameter thru
					  bstrFile
   Type	             :Member Function
   Input parameters  :
			pIMofComp	- IMofCompiler interface pointer.
			bstrFile	- filename.
			nError		- parsing phase error.
   Output parameters :None
   Return Type       :HRESULT
   Global Variables  :None
   Calling Syntax    :CompileMOFFile()
-------------------------------------------------------------------------*/
HRESULT CWMICommandLine::CompileMOFFile(IMofCompiler* pIMofComp, 
										const _bstr_t& bstrFile,
										WMICLIINT& nError)
{
	HRESULT						hr			= S_OK;
	WBEM_COMPILE_STATUS_INFO	wcsInfo;
	
	try
	{
		// Register the moffile
		hr = pIMofComp->CompileFile	(	bstrFile,
										NULL,
										NULL,
										NULL, 
										NULL,
										0,
										WBEM_FLAG_UPDATE_FORCE_MODE,
										0,
										&wcsInfo
									);

		// If the compilation is not successful
		if (hr == WBEM_S_FALSE)
		{
			_TCHAR	szPhaseErr[BUFFER32] = NULL_STRING,
					szComplErr[BUFFER32] = NULL_STRING;
			_bstr_t	bstrMsg;

			_stprintf(szPhaseErr, _T("%d"), wcsInfo.lPhaseError);
			_stprintf(szComplErr, _T("0x%x"), wcsInfo.hRes);
			WMIFormatMessage(IDS_I_MOF_PARSE_ERROR, 3, bstrMsg, 
							(WCHAR*) bstrFile, szPhaseErr, 
							szComplErr);
			DisplayMessage((WCHAR*) bstrMsg, CP_OEMCP, TRUE, FALSE);
			nError	= wcsInfo.lPhaseError;
		}
	}
	catch(_com_error& e)
	{
		hr = e.Error();		
	}
	return hr;
}

/*-------------------------------------------------------------------------
   Name				 :SetBreakEvent
   Synopsis	         :This function sets the CTRC+C (break) event flag
   Type	             :Member Function
   Input parameters  :
				bFlag - TRUE or FALSE
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetBreakEvent()
-------------------------------------------------------------------------*/
void CWMICommandLine::SetBreakEvent(BOOL bFlag)
{
	m_bBreakEvent = bFlag;
}

/*-------------------------------------------------------------------------
   Name				 :GetBreakEvent
   Synopsis	         :This function returns the break event status.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetBreakEvent()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::GetBreakEvent() 
{	
	return m_bBreakEvent;
}

/*-------------------------------------------------------------------------
   Name				 :SetAcceptCommand
   Synopsis	         :This function sets the accept command flag 
   Type	             :Member Function
   Input parameters  :
				bFlag - TRUE or FALSE
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetAcceptComamnd()
-------------------------------------------------------------------------*/
void CWMICommandLine::SetAcceptCommand(BOOL bFlag)
{
	m_bAccCmd = bFlag;
}

/*-------------------------------------------------------------------------
   Name				 :GetAcceptCommand
   Synopsis	         :This function returns accept command flag status.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetAcceptCommand()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::GetAcceptCommand()
{
	return m_bAccCmd;
}

/*-------------------------------------------------------------------------
   Name				 :GetDisplayResultsFlag
   Synopsis	         :This function returns Display Results flag status.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetDisplayResultsFlag()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::GetDisplayResultsFlag()
{
	return m_bDispRes;
}

/*-------------------------------------------------------------------------
   Name				 :SetDisplayResultsFlag
   Synopsis	         :This function sets the display results flag status
   Type	             :Member Function
   Input parameters  :
				bFlag - TRUE or FALSE
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetDisplayResultsFlag()
-------------------------------------------------------------------------*/
void CWMICommandLine::SetDisplayResultsFlag(BOOL bFlag)
{
	m_bDispRes = bFlag;
}

/*-------------------------------------------------------------------------
   Name				 :SetInitWinSock
   Synopsis	         :This function sets the windows socket library 
					  initialization status
   Type	             :Member Function
   Input parameters  :
				bFlag - TRUE or FALSE
   Output parameters :None
   Return Type       :None
   Global Variables  :None
   Calling Syntax    :SetInitWinSock()
-------------------------------------------------------------------------*/
void CWMICommandLine::SetInitWinSock(BOOL bFlag)
{
	m_bInitWinSock = bFlag;
}

/*-------------------------------------------------------------------------
   Name				 :GetInitWinSock
   Synopsis	         :This function returns the socket library initialization
					  status
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetInitWinSock()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::GetInitWinSock()
{
	return m_bInitWinSock;
}

/*-------------------------------------------------------------------------
   Name				 :AddToClipBoardBuffer
   Synopsis	         :This function buffers the data to be added to the clip
					  board.
   Type	             :Member Function
   Input parameters  :pszOutput - string to be buffered
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :AddToClipBoardBuffer(pszOutput)
-------------------------------------------------------------------------*/
void CWMICommandLine::AddToClipBoardBuffer(LPCWSTR pszOutput)
{
	try
	{
		if ( pszOutput != NULL )
		{
			m_chsClipBoardBuffer += pszOutput;
		}
	}
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*-------------------------------------------------------------------------
   Name				 :GetClipBoardBuffer
   Synopsis	         :This function return the buffered data for the
					  clipboard
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :_bstr_t&
   Global Variables  :None
   Calling Syntax    :GetClipBoardBuffer()
-------------------------------------------------------------------------*/
CHString& CWMICommandLine::GetClipBoardBuffer()
{
	return m_chsClipBoardBuffer;
}

// Clear Clip Board Buffer.
/*-------------------------------------------------------------------------
   Name				 :EmptyClipBoardBuffer
   Synopsis	         :This function clears the clipboard buffer.
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :EmptyClipBoardBuffer()
-------------------------------------------------------------------------*/
void CWMICommandLine::EmptyClipBoardBuffer()
{
	m_chsClipBoardBuffer.Empty();
}

/*-------------------------------------------------------------------------
   Name				 :ReadXMLOrBatchFile
   Synopsis	         :Check if the file is xml or batch file. If it is batch file
						then parse it, get commands and write the commands into
						batch file.
   Type	             :Member Function
   Input parameters  :
			hInFile  - Handle to XML or Batch file
   Output parameters :None
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :ReadXMLOrBatchFile()
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::ReadXMLOrBatchFile(HANDLE hInFile)
{
	// Check if the file is xml, if yes store its contents in buffer, parse
	// it and then store parsed info in another file, if not then copy all 
	// contents in another file as it is.
	HRESULT				hr					= 0;
	BOOL				bRetValue			= TRUE;
	HANDLE				hOutFile			= NULL;
	IXMLDOMDocument		*pIXMLDOMDocument	= NULL;
	IXMLDOMElement		*pIXMLDOMElement	= NULL;
	IXMLDOMNode			*pIXMLDOMNode		= NULL;
	IXMLDOMNodeList		*pIXMLDOMNodeList	= NULL;
	BSTR				bstrItemText		= NULL;
	DWORD				dwThreadId			= GetCurrentThreadId();

	// Get the TRACE status 
	BOOL bTrace = m_ParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

	// Get the Logging mode (VERBOSE | ERRORONLY | NOLOGGING)
	ERRLOGOPT eloErrLogOpt = m_ParsedInfo.GetErrorLogObject().GetErrLogOption();

	try
	{
		//Read all input bytes 
		DWORD dwNumberOfBytes = 0;
		_bstr_t bstrInput;
		_TCHAR* pszBuffer = NULL;
		while(TRUE)
		{
			pszBuffer = new _TCHAR[MAX_BUFFER];
			if (pszBuffer)
			{
				TCHAR *pBuf = NULL;
				pBuf = _fgetts(pszBuffer, MAX_BUFFER-1, stdin);
			
				// Indicates end of file
				if (pBuf == NULL)
				{
					SAFEDELETE(pszBuffer);
					break;
				}

				bstrInput += _bstr_t(pszBuffer) + _bstr_t("\n");
			}
			else 
				break;

			SAFEDELETE(pszBuffer);
		}	

		//Create a file and returns the handle 
		hOutFile = CreateFile(TEMP_BATCH_FILE, GENERIC_WRITE, 0, 
			NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 
			NULL);
		if (hOutFile == INVALID_HANDLE_VALUE)
		{
			throw (::GetLastError());;
		}

		hr=CoCreateInstance(CLSID_FreeThreadedDOMDocument, NULL, 
									CLSCTX_INPROC_SERVER,
									IID_IXMLDOMDocument2, 
									(LPVOID*)&pIXMLDOMDocument);
		if (bTrace || eloErrLogOpt)
		{
			CHString	chsMsg;
			chsMsg.Format(L"CoCreateInstance(CLSID_FreeThreadedDOMDocument, "
				  L"NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2,"
				  L" -)"); 
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
						dwThreadId, m_ParsedInfo, bTrace);
		}
		ONFAILTHROWERROR(hr);

		VARIANT_BOOL bSuccess =	VARIANT_FALSE;
		hr = pIXMLDOMDocument->loadXML(bstrInput,&bSuccess);
		if(FAILED(hr) || bSuccess == VARIANT_FALSE)
		{
			//writes data to a file 
			if (!WriteFile(hOutFile, (LPSTR)bstrInput, bstrInput.length(), 
							&dwNumberOfBytes, NULL))
			{
				throw(::GetLastError());
			}
		}
		else
		{
			// Traverse the XML node and get the  content of COMMANDLINE nodes
			// Get the document element.
			hr = pIXMLDOMDocument->get_documentElement(&pIXMLDOMElement);
			if (bTrace || eloErrLogOpt)
			{
				WMITRACEORERRORLOG(hr, __LINE__, 
					__FILE__, _T("IXMLDOMDocument::get_documentElement(-)"), 
					dwThreadId, m_ParsedInfo, bTrace);
			}
			ONFAILTHROWERROR(hr);

			if (pIXMLDOMElement != NULL)
			{
				hr = pIXMLDOMElement->getElementsByTagName(
							_bstr_t(L"COMMANDLINE"), &pIXMLDOMNodeList);
				if (bTrace || eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
					_T("IXMLDOMElement::getElementsByTagName"
					L"(L\"COMMANDLINE\", -)"),dwThreadId,m_ParsedInfo, bTrace);
				}
				ONFAILTHROWERROR(hr);

				LONG value = 0;
				hr = pIXMLDOMNodeList->get_length(&value);
				if (bTrace || eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, 
						__FILE__, _T("IXMLDOMNodeList::get_length(-)"), 
						dwThreadId, m_ParsedInfo, bTrace);
				}
				ONFAILTHROWERROR(hr);

				for(WMICLIINT i = 0; i < value; i++)
				{
					hr = pIXMLDOMNodeList->get_item(i, &pIXMLDOMNode);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNodeList::get_item(-,-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);
		
					if (pIXMLDOMNode == NULL)
						continue;

					hr = pIXMLDOMNode->get_text(&bstrItemText);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNode::get_text(-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);

					//write in the file
					_bstr_t bstrItem = _bstr_t(bstrItemText);
					BOOL bRetCode = WriteFile(hOutFile, (LPSTR)bstrItem, 
											bstrItem.length(),
											&dwNumberOfBytes, NULL);
					if(bRetCode == 0)
					{
						throw (::GetLastError());
					}
					
					bRetCode = WriteFile(hOutFile, "\n", 1, 
													&dwNumberOfBytes, NULL);
					if(bRetCode == 0)
					{
						throw (::GetLastError());
					}
		
					SAFEBSTRFREE(bstrItemText);
					SAFEIRELEASE(pIXMLDOMNode);
				}
				SAFEIRELEASE(pIXMLDOMNodeList);
				SAFEIRELEASE(pIXMLDOMElement);
			}
			SAFEIRELEASE(pIXMLDOMDocument);
		}

		if(hInFile)
			CloseHandle(hInFile);
		if(hOutFile)
			CloseHandle(hOutFile);

		_tfreopen(_T("CONIN$"),_T("r"),stdin);
		bRetValue=TRUE;
	}
	catch(_com_error& e) 
	{
		SAFEIRELEASE(pIXMLDOMDocument);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEIRELEASE(pIXMLDOMNode);
		SAFEIRELEASE(pIXMLDOMNodeList);
		SAFEBSTRFREE(bstrItemText);

		if(hInFile)
			CloseHandle(hInFile);
		if(hOutFile)
			CloseHandle(hOutFile);

		m_ParsedInfo.GetCmdSwitchesObject().SetCOMError(e);
		bRetValue = FALSE;
		GetFormatObject().DisplayResults(m_ParsedInfo, CP_OEMCP);
	}
	catch(DWORD dwError)
	{
		SAFEIRELEASE(pIXMLDOMDocument);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEIRELEASE(pIXMLDOMNode);
		SAFEIRELEASE(pIXMLDOMNodeList);
		SAFEBSTRFREE(bstrItemText);

		if(hInFile)
			CloseHandle(hInFile);
		if(hOutFile)
			CloseHandle(hOutFile);

		::SetLastError(dwError);
		DisplayWin32Error();
		m_ParsedInfo.GetCmdSwitchesObject().SetErrataCode(dwError);
		::SetLastError(dwError);

		bRetValue=FALSE;
		GetFormatObject().DisplayResults(m_ParsedInfo, CP_OEMCP);
	}
	catch(CHeap_Exception)
	{
		SAFEIRELEASE(pIXMLDOMDocument);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEIRELEASE(pIXMLDOMNode);
		SAFEIRELEASE(pIXMLDOMNodeList);
		SAFEBSTRFREE(bstrItemText);

		if(hInFile)
			CloseHandle(hInFile);
		if(hOutFile)
			CloseHandle(hOutFile);

		bRetValue=FALSE;
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}

	return bRetValue;
}


/*-------------------------------------------------------------------------
   Name				 :FrameXMLHeader
   Synopsis	         :Frames the XML header info
   Type	             :Member Function
   Input parameters  :
		nIter		- Every count
   Output parameters :
		bstrHeader	- String to containg XML header info
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameXMLHeader()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameXMLHeader(_bstr_t& bstrHeader, WMICLIINT nIter)
{
	try
	{
		CHString				strTemp;
		_bstr_t bstrString = m_ParsedInfo.GetGlblSwitchesObject().
												GetMgmtStationName();
		FindAndReplaceEntityReferences(bstrString);

		strTemp.Format(L"<COMMAND SEQUENCENUM=\"%d\" ISSUEDFROM=\"%s\" "
			L"STARTTIME=\"%s\" EVERYCOUNT=\"%d\">", 
			m_ParsedInfo.GetGlblSwitchesObject().GetSequenceNumber(),
			(TCHAR*)bstrString,
			m_ParsedInfo.GetGlblSwitchesObject().GetStartTime(),
			nIter);
		bstrHeader = _bstr_t(strTemp);	
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}


/*-------------------------------------------------------------------------
   Name				 :FrameRequestNode
   Synopsis	         :Frames the XML string for Request info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrRequest	- String to containg Request info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameRequestNode()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameRequestNode(_bstr_t& bstrRequest)
{
	try
	{
		CHString	strTemp;
		_bstr_t		bstrContext;
		_bstr_t		bstrCommandComponent;

		bstrRequest = L"<REQUEST>";
		_bstr_t bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetCommandInput();
		FindAndReplaceEntityReferences(bstrString);
		strTemp.Format(L"<COMMANDLINE>%s</COMMANDLINE>",
									(TCHAR*)bstrString);
		bstrRequest += _bstr_t(strTemp);
		
		FrameCommandLineComponents(bstrCommandComponent);
		bstrRequest += bstrCommandComponent;
		FrameContextInfoFragment(bstrContext);
		bstrRequest += bstrContext;
		bstrRequest += L"</REQUEST>";
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}


/*-------------------------------------------------------------------------
   Name				 :FrameContextInfoFragment
   Synopsis	         :Frames the XML string for context info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrContext	- String to containg context info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameContextInfoFragment()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameContextInfoFragment(_bstr_t& bstrContext)
{
	try
	{
		_bstr_t		bstrAuthLevel,	bstrImpLevel,	bstrPrivileges,
					bstrTrace,		bstrRecordPath,	bstrInteractive,
					bstrFailFast,	bstrAppend,		bstrOutput,
					bstrUser,		bstrAggregate,	bstrNamespace,
					bstrRole,		bstrLocale;
		CHString	strTemp;
		
		m_ParsedInfo.GetGlblSwitchesObject().GetImpLevelTextDesc(bstrImpLevel);
		m_ParsedInfo.GetGlblSwitchesObject().GetAuthLevelTextDesc(bstrAuthLevel);
		m_ParsedInfo.GetGlblSwitchesObject().GetPrivilegesTextDesc(bstrPrivileges);
		m_ParsedInfo.GetGlblSwitchesObject().GetTraceTextDesc(bstrTrace);
		m_ParsedInfo.GetGlblSwitchesObject().GetInteractiveTextDesc(bstrInteractive);
		m_ParsedInfo.GetGlblSwitchesObject().GetFailFastTextDesc(bstrFailFast);
		m_ParsedInfo.GetGlblSwitchesObject().GetAggregateTextDesc(bstrAggregate);

		m_ParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendTextDesc(bstrOutput,
																	  TRUE);
		FindAndReplaceEntityReferences(bstrOutput);
		
		m_ParsedInfo.GetGlblSwitchesObject().GetOutputOrAppendTextDesc(bstrAppend,
																	  FALSE);
		FindAndReplaceEntityReferences(bstrAppend);

		m_ParsedInfo.GetGlblSwitchesObject().GetRecordPathDesc(bstrRecordPath);
		FindAndReplaceEntityReferences(bstrRecordPath);

		m_ParsedInfo.GetUserDesc(bstrUser);
		FindAndReplaceEntityReferences(bstrUser);

		bstrNamespace = m_ParsedInfo.GetGlblSwitchesObject().GetNameSpace();
		FindAndReplaceEntityReferences(bstrNamespace);

		bstrRole = m_ParsedInfo.GetGlblSwitchesObject().GetRole();
		FindAndReplaceEntityReferences(bstrRole);

		bstrLocale = m_ParsedInfo.GetGlblSwitchesObject().GetLocale();
		FindAndReplaceEntityReferences(bstrLocale);

		strTemp.Format(L"<CONTEXT><NAMESPACE>%s</NAMESPACE><ROLE>%s</ROLE>"
					L"<IMPLEVEL>%s</IMPLEVEL><AUTHLEVEL>%s</AUTHLEVEL>"
					L"<LOCALE>%s</LOCALE><PRIVILEGES>%s</PRIVILEGES>"
					L"<TRACE>%s</TRACE><RECORD>%s</RECORD>"
					L"<INTERACTIVE>%s</INTERACTIVE>"
					L"<FAILFAST>%s</FAILFAST><OUTPUT>%s</OUTPUT>"
					L"<APPEND>%s</APPEND><USER>%s</USER>"
					L"<AGGREGATE>%s</AGGREGATE></CONTEXT>",
					(LPWSTR)bstrNamespace, (LPWSTR)bstrRole,
					(LPWSTR)bstrImpLevel, (LPWSTR) bstrAuthLevel,
					(LPWSTR)bstrLocale,
					(LPWSTR)bstrPrivileges, (LPWSTR)bstrTrace,  	
					(LPWSTR)bstrRecordPath, (LPWSTR) bstrInteractive,
					(LPWSTR)bstrFailFast, (LPWSTR) bstrOutput,	
					(LPWSTR)bstrAppend, (LPWSTR) bstrUser,
					(LPWSTR)bstrAggregate);
		bstrContext = strTemp;
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}


/*-------------------------------------------------------------------------
   Name				 :FrameCommandLineComponents
   Synopsis	         :Frames the XML string for commandline info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrContext	- String to containg commandline info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameCommandLineComponents()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameCommandLineComponents(_bstr_t& bstrCommandComponent)
{
	try
	{
		CHString	strTemp;
		_bstr_t		bstrNodeList;

		bstrCommandComponent = L"<COMMANDLINECOMPONENTS>";
		FrameNodeListFragment(bstrNodeList);
		bstrCommandComponent += bstrNodeList;

		_TCHAR *pszVerbName = m_ParsedInfo.GetCmdSwitchesObject().
															GetVerbName(); 
		if(CompareTokens(pszVerbName, CLI_TOKEN_LIST))
		{
			_bstr_t bstrString = m_ParsedInfo.GetCmdSwitchesObject().
														GetAliasName();

			if (!bstrString) 
				bstrString = L"N/A";
			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<FRIENDLYNAME>%s</FRIENDLYNAME>",
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);
			 
			bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetAliasTarget();
			if (!bstrString) 
				bstrString = L"N/A";

			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<TARGET>%s</TARGET>",
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);

			_bstr_t bstrClassName;
			m_ParsedInfo.GetCmdSwitchesObject().GetClassOfAliasTarget(bstrClassName);

			if (!bstrClassName) 
				bstrClassName = L"N/A";

			bstrCommandComponent += L"<ALIASTARGET>";
			bstrCommandComponent += bstrClassName;
			bstrCommandComponent += L"</ALIASTARGET>";

			bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetPWhereExpr();

			if (!bstrString) 
				bstrString = L"N/A";

			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<PWHERE>%s</PWHERE>", 
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);

			bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetAliasNamespace();
			if (!bstrString) 
				bstrString = L"N/A";
			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<NAMESPACE>%s</NAMESPACE>",
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);

			bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetAliasDesc();
			if (!bstrString) 
				bstrString = L"N/A";
			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<DESCRIPTION>%s</DESCRIPTION>",
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);

			bstrString = m_ParsedInfo.GetCmdSwitchesObject().GetFormedQuery();
			if (!bstrString) 
				bstrString = L"N/A";
			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<RESULTANTQUERY>%s</RESULTANTQUERY>",
										(TCHAR*)bstrString);
			bstrCommandComponent += _bstr_t(strTemp);

			_bstr_t		bstrFormats;
			FrameFormats(bstrFormats);
			bstrCommandComponent += bstrFormats;

			_bstr_t		bstrProperties;
			FramePropertiesInfo(bstrProperties);
			bstrCommandComponent += bstrProperties;
		}

		bstrCommandComponent += L"</COMMANDLINECOMPONENTS>";
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}


/*-------------------------------------------------------------------------
   Name				 :FrameNodeListFragment
   Synopsis	         :Frames the XML string for NodeList info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrContext	- String to containg NodeList info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameNodeListFragment()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameNodeListFragment(_bstr_t& bstrNodeList)
{
	try
	{
		CHString				strTemp;
		CHARVECTOR::iterator	itrStart,
								itrEnd;
		CHARVECTOR				cvNodes;
		_bstr_t					bstrString ;

		bstrNodeList = L"<NODELIST>";

		cvNodes = m_ParsedInfo.GetGlblSwitchesObject().GetNodesList();

		if (cvNodes.size() > 1)
		{
			itrStart = cvNodes.begin();
			itrEnd	 = cvNodes.end();
			// Move to next node
			itrStart++;
			while (itrStart != itrEnd)
			{
				bstrString = _bstr_t(*itrStart);
				if (!bstrString) 
					bstrString = L"N/A";
				FindAndReplaceEntityReferences(bstrString);
				strTemp.Format(L"<NODE>%s</NODE>", (LPWSTR)bstrString);
				bstrNodeList += _bstr_t(strTemp);
				itrStart++;
			}
		}
		else
		{
			bstrString = _bstr_t(m_ParsedInfo.GetGlblSwitchesObject().
															GetNode());
			if (!bstrString) 
				bstrString = L"N/A";
			FindAndReplaceEntityReferences(bstrString);
			strTemp.Format(L"<NODE>%s</NODE>", (LPWSTR)bstrString);
			bstrNodeList += _bstr_t(strTemp);
		}
		bstrNodeList += L"</NODELIST>";
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}

}


/*-------------------------------------------------------------------------
   Name				 :FrameFormats
   Synopsis	         :Frames the XML string for formats info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrContext	- String to containg formats info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FrameFormats()
-------------------------------------------------------------------------*/
void CWMICommandLine::FrameFormats(_bstr_t& bstrFormats)
{
	try
	{
		CHString	strTemp;
		XSLTDETVECTOR::iterator	theIterator		= NULL, 
								theEndIterator	= NULL;
		BSTRMAP::iterator		theMapIterator	= NULL, 
								theMapEndIterator	= NULL;
		_bstr_t					bstrString;

		if(!m_ParsedInfo.GetCmdSwitchesObject().GetXSLTDetailsVector().empty())
		{
			bstrFormats = L"<FORMATS>";
			bstrFormats += L"<FORMAT>";

			theIterator = m_ParsedInfo.GetCmdSwitchesObject().
										GetXSLTDetailsVector().begin();
			theEndIterator = m_ParsedInfo.GetCmdSwitchesObject().
										GetXSLTDetailsVector().end();
			while (theIterator != theEndIterator)
			{
				bstrString = _bstr_t((*theIterator).FileName);
				FindAndReplaceEntityReferences(bstrString);
				strTemp.Format(L"<NAME>%s</NAME>",
										(_TCHAR*)bstrString);
				bstrFormats	+= _bstr_t(strTemp);

				theMapIterator = (*theIterator).ParamMap.begin();
				theMapEndIterator = (*theIterator).ParamMap.end();

				while (theMapIterator != theMapEndIterator)
				{
					bstrString = _bstr_t((*theMapIterator).first);
					FindAndReplaceEntityReferences(bstrString);
					strTemp.Format(L"<PARAM><NAME>%s</NAME>",
											(_TCHAR*)bstrString);
					bstrFormats	+= _bstr_t(strTemp);

					bstrString = _bstr_t((*theMapIterator).second);
					FindAndReplaceEntityReferences(bstrString);
					strTemp.Format(L"<VALUE>%s</VALUE>",
											(_TCHAR*)bstrString);
					bstrFormats	+= _bstr_t(strTemp);
				
					bstrFormats += L"</PARAM>";
					
					theMapIterator++;
				}
				theIterator++;
			}		
			bstrFormats += L"</FORMAT>";
			bstrFormats += L"</FORMATS>";
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}


/*-------------------------------------------------------------------------
   Name				 :FramePropertiesInfo
   Synopsis	         :Frames the XML string for properties info
   Type	             :Member Function
   Input parameters  :None
   Output parameters :
		bstrContext	- String to containg properties info in XML form
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :FramePropertiesInfo()
-------------------------------------------------------------------------*/
void CWMICommandLine::FramePropertiesInfo(_bstr_t& bstrProperties)
{
	try
	{
		CHString	strTemp;
		PROPDETMAP::iterator	theIterator		= NULL, 
								theEndIterator	= NULL;

		if(!m_ParsedInfo.GetCmdSwitchesObject().GetPropDetMap().empty())
		{
			bstrProperties = L"<PROPERTIES>";

			theIterator = m_ParsedInfo.GetCmdSwitchesObject().
										GetPropDetMap().begin();
			theEndIterator = m_ParsedInfo.GetCmdSwitchesObject().
											GetPropDetMap().end();
			while (theIterator != theEndIterator)
			{
				bstrProperties += L"<PROPERTY>";
				strTemp.Format(L"<NAME>%s</NAME>",
							(_TCHAR*)(*theIterator).first);
				bstrProperties	+= _bstr_t(strTemp);

				strTemp.Format(L"<DERIVATION>%s</DERIVATION>",
							(_TCHAR*)(*theIterator).second.Derivation);
				bstrProperties	+= _bstr_t(strTemp);
				bstrProperties += L"</PROPERTY>";
	
				theIterator++;
			}		
			bstrProperties += L"</PROPERTIES>";
		}
	}
	catch(_com_error& e)
	{
		_com_issue_error(e.Error());
	}
	//trap to catch CHeap_Exception
	catch(CHeap_Exception)
	{
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*-------------------------------------------------------------------------
   Name				 :GetFileNameMap
   Synopsis	         :Frames the BSTR Map contains the key words and
					  corresponding files from the XSL mapping file
   Type	             :Member Function
   Input parameters  :None
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetFileNameMap()
-------------------------------------------------------------------------*/
void CWMICommandLine::GetFileNameMap()
{
	_TCHAR*  pszFilePath = new _TCHAR[MAX_PATH+1];
	BSTRMAP::iterator theMapIterator = NULL;
	UINT	nSize	= 0;

	try
	{
		_bstr_t bstrFilePath;

		if(pszFilePath == NULL)
			throw OUT_OF_MEMORY;
				
		nSize = GetSystemDirectory(pszFilePath, MAX_PATH+1);

		if(nSize)
		{
			if(nSize > MAX_PATH)
			{
				SAFEDELETE(pszFilePath);
				pszFilePath = new _TCHAR[nSize + 1];
				if(pszFilePath == NULL)
				{
					throw OUT_OF_MEMORY;
				}

				if(!GetSystemDirectory(pszFilePath, nSize+1))
				{
					SAFEDELETE(pszFilePath);
					throw (::GetLastError());
				}
			}

			bstrFilePath = _bstr_t(pszFilePath);
			bstrFilePath += _bstr_t(WBEM_LOCATION) + _bstr_t(CLI_XSLMAPPINGS_FILE);
			SAFEDELETE(pszFilePath);
		}
		else
		{
			SAFEDELETE(pszFilePath);
			throw (::GetLastError());
		}


		GetXSLMappings(bstrFilePath);
	}
	catch(_com_error &e)
	{
		 SAFEDELETE(pszFilePath);
		_com_issue_error(e.Error());
	}
	catch(CHeap_Exception)
	{
		 SAFEDELETE(pszFilePath);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*-------------------------------------------------------------------------
   Name				 :GetFileFromKey
   Synopsis	         :Gets the xslfile name corrsponding to the keyword passed
					  from the BSTRMAP  
   Type	             :Member Function
   Input parameters  :bstrkeyName - key word
   Output parameters :bstrFileName - the xsl filename 
   Return Type       :BOOL
   Global Variables  :None
   Calling Syntax    :GetFileFromKey(bstrkeyName, bstrFileName)
-------------------------------------------------------------------------*/
BOOL CWMICommandLine::GetFileFromKey(_bstr_t bstrkeyName, _bstr_t& bstrFileName)
{
	BOOL bFound = TRUE;
	BSTRMAP::iterator theMapIterator = NULL;
	
	if (Find(m_bmKeyWordtoFileName,bstrkeyName,theMapIterator) == TRUE)
		bstrFileName = (*theMapIterator).second;
	else
		bFound = FALSE; 

	return bFound;
}

/*-------------------------------------------------------------------------
   Name				 :GetXSLMappings
   Synopsis	         :Get the XSL file names for keywords
   Type	             :Member Function
   Input parameters  :
			pszFilePath  - XSL mappings file path
   Output parameters :None
   Return Type       :void
   Global Variables  :None
   Calling Syntax    :GetXSLMappings(pszFilePath)
-------------------------------------------------------------------------*/
void CWMICommandLine::GetXSLMappings(_TCHAR *pszFilePath)
{
	HRESULT				hr						= 0;
	BOOL				bContinue				= TRUE;
	IXMLDOMDocument		*pIXMLDOMDocument		= NULL;
	IXMLDOMElement		*pIXMLDOMElement		= NULL;
	IXMLDOMNode			*pIXMLDOMNode			= NULL;
	IXMLDOMNodeList		*pIXMLDOMNodeList		= NULL;
	IXMLDOMNamedNodeMap	*pIXMLDOMNamedNodeMap	= NULL;
    IXMLDOMNode			*pIXMLDOMNodeKeyName	= NULL;
	DWORD				dwThreadId				= GetCurrentThreadId();
	BSTR				bstrItemText			= NULL;
	VARIANT				varValue, varObject;

	VariantInit(&varValue);
	VariantInit(&varObject);

	// Get the TRACE status 
	BOOL bTrace = m_ParsedInfo.GetGlblSwitchesObject().GetTraceStatus();

	// Get the Logging mode (VERBOSE | ERRORONLY | NOLOGGING) 
	ERRLOGOPT eloErrLogOpt = m_ParsedInfo.GetErrorLogObject().GetErrLogOption();

	try
	{
		hr=CoCreateInstance(CLSID_FreeThreadedDOMDocument, NULL, 
									CLSCTX_INPROC_SERVER,
									IID_IXMLDOMDocument2, 
									(LPVOID*)&pIXMLDOMDocument);
		if (bTrace || eloErrLogOpt)
		{
			CHString	chsMsg;
			chsMsg.Format(L"CoCreateInstance(CLSID_FreeThreadedDOMDocument, "
				  L"NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument2,"
				  L" -)"); 
			WMITRACEORERRORLOG(hr, __LINE__, __FILE__, (LPCWSTR)chsMsg,
						dwThreadId, m_ParsedInfo, bTrace);
		}
		ONFAILTHROWERROR(hr);

		VARIANT_BOOL bSuccess =	VARIANT_FALSE;
		VariantInit(&varObject);
		varObject.vt = VT_BSTR;
		varObject.bstrVal = SysAllocString(pszFilePath);

		if (varObject.bstrVal == NULL)
		{
			//Reset the variant, it will be cleaned up by the catch...
			VariantInit(&varObject);
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		hr = pIXMLDOMDocument->load(varObject,&bSuccess);
		if(FAILED(hr) || bSuccess == VARIANT_FALSE)
		{
			bContinue = FALSE;
		}
		
		if (bContinue)
		{
			// Traverse the XML node and get the text of nodes named XSLFORMAT
			// Get the document element.
			hr = pIXMLDOMDocument->get_documentElement(&pIXMLDOMElement);
			if (bTrace || eloErrLogOpt)
			{
				WMITRACEORERRORLOG(hr, __LINE__, 
					__FILE__, _T("IXMLDOMDocument::get_documentElement(-)"), 
					dwThreadId, m_ParsedInfo, bTrace);
			}
			ONFAILTHROWERROR(hr);

			if (pIXMLDOMElement != NULL)
			{
				hr = pIXMLDOMElement->getElementsByTagName(
							_bstr_t(L"XSLFORMAT"), &pIXMLDOMNodeList);
				if (bTrace || eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
					_T("IXMLDOMElement::getElementsByTagName"
					L"(L\"XSLFORMAT\", -)"), dwThreadId, m_ParsedInfo, bTrace);
				}
				ONFAILTHROWERROR(hr);

				LONG value = 0;
				hr = pIXMLDOMNodeList->get_length(&value);
				if (bTrace || eloErrLogOpt)
				{
					WMITRACEORERRORLOG(hr, __LINE__, 
						__FILE__, _T("IXMLDOMNodeList::get_length(-)"), 
						dwThreadId, m_ParsedInfo, bTrace);
				}
				ONFAILTHROWERROR(hr);

				for(WMICLIINT i = 0; i < value; i++)
				{
					hr = pIXMLDOMNodeList->get_item(i, &pIXMLDOMNode);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNodeList::get_item(-,-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);
		
					if(pIXMLDOMNode == NULL)
						continue;

					hr = pIXMLDOMNode->get_text(&bstrItemText);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNode::get_text(-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);

					hr = pIXMLDOMNode->get_attributes(&pIXMLDOMNamedNodeMap);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNode::get_attributes(-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);

					if(pIXMLDOMNamedNodeMap == NULL)
					{
						SAFEBSTRFREE(bstrItemText);
						SAFEIRELEASE(pIXMLDOMNode);
						continue;
					}

					hr = pIXMLDOMNamedNodeMap->getNamedItem(
						_bstr_t(L"KEYWORD"), &pIXMLDOMNodeKeyName);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, __FILE__, 
						_T("IXMLDOMNamedNodeMap::getNamedItem(L\"KEYWORD\", -)"),
						dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);

					if(pIXMLDOMNodeKeyName == NULL)
					{
						SAFEBSTRFREE(bstrItemText);
						SAFEIRELEASE(pIXMLDOMNode);
						SAFEIRELEASE(pIXMLDOMNamedNodeMap);
						continue;
					}

					VariantInit(&varValue);
					hr = pIXMLDOMNodeKeyName->get_nodeValue(&varValue);
					if (bTrace || eloErrLogOpt)
					{
						WMITRACEORERRORLOG(hr, __LINE__, 
							__FILE__, _T("IXMLDOMNode::get_nodeValue(-)"), 
							dwThreadId, m_ParsedInfo, bTrace);
					}
					ONFAILTHROWERROR(hr);

					if(varValue.vt == VT_NULL || varValue.vt == VT_EMPTY)
					{
						VARIANTCLEAR(varValue);
						SAFEBSTRFREE(bstrItemText);
						SAFEIRELEASE(pIXMLDOMNode);
						SAFEIRELEASE(pIXMLDOMNamedNodeMap);
						SAFEIRELEASE(pIXMLDOMNodeKeyName);
						continue;
					}

					//forming the BSTRMAP containing key words and filenames
					m_bmKeyWordtoFileName.insert(BSTRMAP::value_type(
											varValue.bstrVal, bstrItemText));
			
					VARIANTCLEAR(varValue);
					SAFEBSTRFREE(bstrItemText);
					SAFEIRELEASE(pIXMLDOMNode);
					SAFEIRELEASE(pIXMLDOMNamedNodeMap);
					SAFEIRELEASE(pIXMLDOMNodeKeyName);
				}
				VARIANTCLEAR(varValue);
				SAFEIRELEASE(pIXMLDOMNodeList);
				SAFEIRELEASE(pIXMLDOMElement);
			}
			SAFEIRELEASE(pIXMLDOMDocument);
		}
		VARIANTCLEAR(varObject);
	}
	catch(_com_error) 
	{
		VARIANTCLEAR(varValue);
		VARIANTCLEAR(varObject);
		SAFEIRELEASE(pIXMLDOMDocument);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEIRELEASE(pIXMLDOMNode);
		SAFEIRELEASE(pIXMLDOMNodeList);
		SAFEIRELEASE(pIXMLDOMNamedNodeMap);
		SAFEIRELEASE(pIXMLDOMNodeKeyName);
		SAFEBSTRFREE(bstrItemText);
	}
	catch(CHeap_Exception)
	{
		VARIANTCLEAR(varValue);
		VARIANTCLEAR(varObject);
		SAFEIRELEASE(pIXMLDOMDocument);
		SAFEIRELEASE(pIXMLDOMElement);
		SAFEIRELEASE(pIXMLDOMNode);
		SAFEIRELEASE(pIXMLDOMNodeList);
		SAFEIRELEASE(pIXMLDOMNamedNodeMap);
		SAFEIRELEASE(pIXMLDOMNodeKeyName);
		SAFEBSTRFREE(bstrItemText);
		_com_issue_error(WBEM_E_OUT_OF_MEMORY);
	}
}

/*------------------------------------------------------------------------
   Name				 :GetTokenVector
   Synopsis	         :This function returns a reference to the token 
					  vector
   Type	             :Member Function
   Input parameter   :None
   Output parameters :None
   Return Type       :CHARVECTOR&
   Global Variables  :None
   Calling Syntax    :GetTokenVector()
   Notes             :None
------------------------------------------------------------------------*/
CHARVECTOR& CWMICommandLine::GetTokenVector()
{
	return m_ParserEngine.GetCmdTokenizer().GetTokenVector();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adapcls.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPCLS.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemcli.h>
#include <throttle.h>
#include <cominit.h>
#include <winmgmtr.h>
#include "perfndb.h"
#include "adaputil.h"
#include "adapreg.h"
#include "ntreg.h"
#include "WMIBroker.h"
#include "ClassBroker.h"
#include "adapcls.h"

#include <comdef.h>

extern HANDLE g_hAbort;

WCHAR * g_aBaseClass[] =
{
    ADAP_PERF_RAW_BASE_CLASS,
    ADAP_PERF_COOKED_BASE_CLASS
};

CLocaleDefn::CLocaleDefn( WCHAR* pwcsLangId, 
                          HKEY hKey ) 
: m_wstrLangId( pwcsLangId ), 
  m_LangId( 0 ),
  m_LocaleId( 0 ),
  m_pNamespace( NULL ), 
  m_pNameDb( NULL ),
  m_bOK( FALSE ),
  m_hRes(WBEM_E_FAILED)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Initialize the base class array
    // ===============================

    memset( m_apBaseClass, NULL, WMI_ADAP_NUM_TYPES * sizeof( IWbemClassObject* ) );

    // A NULL means it is the default locale
    // =====================================

    if ( NULL != pwcsLangId )
    {
        hr = InitializeLID();
    }

    // Initialize the namespace and base class and verify their schema
    // ===============================================================

    if ( SUCCEEDED( hr ) )
    {
        hr = InitializeWMI();
    }

    // Create the names' database for the locale
    // =========================================

    if ( SUCCEEDED( hr ) )
    {
        m_pNameDb = new CPerfNameDb( hKey );

        if ( ( NULL == m_pNameDb ) || ( !m_pNameDb->IsOk() ) )
        {
            if ( NULL != m_pNameDb )
            {
                m_pNameDb->Release();
                m_pNameDb = NULL;
            }
            
            ERRORTRACE((LOG_WMIADAP,"failure in loading HKEY %p for locale %S err: %d\n",hKey,(LPCWSTR)pwcsLangId,GetLastError()));
            
            hr = WBEM_E_FAILED;
        }
    }

    // If every thing work out, then set the initialization flag
    // =========================================================

    if ( SUCCEEDED( hr ) )
    {
        m_bOK = TRUE;
    }
    else
    {
        m_hRes = hr;
    }
}

CLocaleDefn::~CLocaleDefn()
{
    if ( m_pNamespace )
        m_pNamespace->Release();

    for ( DWORD dw = 0; dw < WMI_ADAP_NUM_TYPES; dw++ )
    {
        if ( m_apBaseClass[dw] )
            m_apBaseClass[dw]->Release();
    }

    if ( m_pNameDb )
        m_pNameDb->Release();
}

HRESULT CLocaleDefn::InitializeLID()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    LPCWSTR pwstrLangId = (LPWSTR) m_wstrLangId;

    // Get the length of the text LID
    // ==============================

    DWORD   dwLangIdLen = m_wstrLangId.Length();

    // Ensure that all characters are numeric
    // ======================================

    for ( DWORD dwCtr = 0; dwCtr < dwLangIdLen && iswxdigit( pwstrLangId[dwCtr] ); dwCtr++ );

    if ( dwCtr >= dwLangIdLen )
    {
        // Now look for the first non-zero character
        // =========================================

        LPCWSTR pwcsNumStart = pwstrLangId;

        for ( dwCtr = 0; dwCtr < dwLangIdLen && *pwcsNumStart == L'0'; dwCtr++, pwcsNumStart++ );

        // As long as the LID was not all zeros and the LID is 
        // 3 digits or less convert the LID to a number
        // ===================================================

        if ( dwCtr < dwLangIdLen && wcslen( pwcsNumStart ) <= 3 )
        {
            // Convert the LID to a hex value
            // ==============================

            WORD    wPrimaryLangId = (WORD) wcstoul( pwcsNumStart, NULL, 16 );

            // If we are reading the default system id, ensure that we have
            // the proper sublanguage and then convert to the member types
            // ============================================================

            LANGID wSysLID = GetSystemDefaultUILanguage();

            if ( ( wSysLID & 0x03FF ) == wPrimaryLangId )
            {
                m_LangId = wSysLID;
            }
            else
            {
                m_LangId = MAKELANGID( wPrimaryLangId, SUBLANG_DEFAULT );
            }

            m_LocaleId = MAKELCID( m_LangId, SORT_DEFAULT );

            WCHAR   wcsTemp[32];
            StringCchPrintfW(wcsTemp,32, L"0x%.4X", m_LangId );
            m_wstrLocaleId = wcsTemp;

            StringCchPrintfW( wcsTemp,32, L"MS_%hX", m_LangId );
            m_wstrSubNameSpace = wcsTemp;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CLocaleDefn::InitializeWMI()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Initialize the namespace name
    // =============================

    WString wstrNamespace;

    hr = GetNamespaceName(wstrNamespace);

    // Initialize the localization namespace
    // =====================================

    if ( SUCCEEDED( hr ) )
    {
        hr = CWMIBroker::GetNamespace( wstrNamespace, &m_pNamespace );       
    }

    // Initialize the base classes
    // ===========================

     for ( DWORD dwBase = 0; ( dwBase < WMI_ADAP_NUM_TYPES ) && SUCCEEDED( hr ); dwBase++ )
    {
        BSTR        bstrBaseClass = SysAllocString( g_aBaseClass[dwBase]);
        if (NULL == bstrBaseClass) { hr = WBEM_E_OUT_OF_MEMORY; continue; };
        CSysFreeMe  sfmBaseClass( bstrBaseClass );

        hr = m_pNamespace->GetObject( bstrBaseClass, 0L, NULL, (IWbemClassObject**)&m_apBaseClass[dwBase], NULL );
    }

    return hr;
}

HRESULT CLocaleDefn::GetLID( int & nLID )
{
    nLID = m_LangId;
    return WBEM_S_NO_ERROR;
}

HRESULT CLocaleDefn::GetNamespaceName( WString & wstrNamespaceName )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        wstrNamespaceName = ADAP_ROOT_NAMESPACE;

        if ( 0 != m_LangId )
        {
            wstrNamespaceName += L"\\";
            wstrNamespaceName += m_wstrSubNameSpace;
        }
     }
    catch(CX_MemoryException)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CLocaleDefn::GetNamespace( IWbemServices** ppNamespace )
{
    if (NULL == ppNamespace) return WBEM_E_INVALID_PARAMETER;

    *ppNamespace = m_pNamespace;

    if ( NULL != *ppNamespace )
    {
        (*ppNamespace)->AddRef();
    }
    else
    {
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CLocaleDefn::GetNameDb( CPerfNameDb** ppNameDb )
{
    if (NULL == ppNameDb) return WBEM_E_INVALID_PARAMETER;

    HRESULT hr = WBEM_S_NO_ERROR;

    *ppNameDb = m_pNameDb;

    if ( NULL != *ppNameDb )
    {
        (*ppNameDb)->AddRef();
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CLocaleDefn::GetBaseClass( DWORD dwType, IWbemClassObject** ppObject )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( dwType < WMI_ADAP_NUM_TYPES && ppObject)
    {
        if ( m_apBaseClass[dwType] )
        {
            *ppObject = m_apBaseClass[dwType];
            (*ppObject)->AddRef();
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    } else 
              return WBEM_E_INVALID_PARAMETER;

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CLocaleCache
//
////////////////////////////////////////////////////////////////////////////////

CLocaleCache::CLocaleCache( )
: m_nEnumIndex( -1 )
{
}

CLocaleCache::~CLocaleCache()
{
}

HRESULT CLocaleCache::Reset()
{
    HRESULT hr = WBEM_NO_ERROR;

    m_apLocaleDefn.RemoveAll();
    Initialize();

    return hr;
}

#define ENGLISH_DEFAULT_LANGID MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)
//#define ENGLISH_DEFAULT_LOCID MAKELCID( MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT )

HRESULT CLocaleCache::Initialize()
{
    CLocaleDefn*    pDefn = NULL;
    DWORD           dwIndex = 0;
    long            lError = 0;

    // Setup the default defn
    // ======================

    pDefn = new CLocaleDefn( NULL, HKEY_PERFORMANCE_TEXT );
    CAdapReleaseMe  arm( pDefn );
    if ( NULL == pDefn  || !pDefn->IsOK() )
    {
        ERRORTRACE((LOG_WMIADAP,"CLocaleDefn failed hr = %08x\n",(pDefn)?pDefn->GetHRESULT():WBEM_E_OUT_OF_MEMORY));
        return WBEM_E_FAILED;
    }
    
    if (-1 == m_apLocaleDefn.Add( pDefn )) return WBEM_E_OUT_OF_MEMORY;

    LANGID wSysLID = GetSystemDefaultUILanguage();

    //
    // on non english box, always add the classes to the MS_409 namespace
    //
    if (ENGLISH_DEFAULT_LANGID != wSysLID)
    {
        WCHAR pLangEng[8];
        StringCchPrintfW(pLangEng,8,L"%03x",0x3FF & ENGLISH_DEFAULT_LANGID );
        
        CLocaleDefn* pDefnEng = new CLocaleDefn( pLangEng, HKEY_PERFORMANCE_TEXT );
        CAdapReleaseMe  armDefnEng( pDefnEng );

        if ( NULL == pDefnEng || !pDefnEng->IsOK() )
        {
            ERRORTRACE((LOG_WMIADAP,"CLocaleDefn(%S) failed hr = %08x\n", pLangEng,pDefn->GetHRESULT()));
            return WBEM_E_FAILED;            
        }
        if (-1 == m_apLocaleDefn.Add( pDefnEng ))return WBEM_E_OUT_OF_MEMORY;;
    }

    WCHAR pLang[8];    
    StringCchPrintfW(pLang,8,L"%03x",0x3FF & wSysLID);
    
    pDefn = new CLocaleDefn( pLang, HKEY_PERFORMANCE_NLSTEXT );
    CAdapReleaseMe  armDefn( pDefn );

    if ( ( NULL != pDefn ) && ( pDefn->IsOK() ) )
    {
        if (-1 == m_apLocaleDefn.Add( pDefn )) return WBEM_E_OUT_OF_MEMORY;
    }
    else // sometimes NLSTEXT is not found
    {
        CLocaleDefn* pDefn2 = new CLocaleDefn( pLang, HKEY_PERFORMANCE_TEXT );
        CAdapReleaseMe  armDefn2( pDefn2 );

        if ( NULL == pDefn2 || !pDefn2->IsOK() )
        {
            ERRORTRACE((LOG_WMIADAP,"CLocaleDefn(%S) failed hr = %08x\n", pLang,pDefn2->GetHRESULT()));
            return WBEM_E_FAILED;            
        }
        if (-1 == m_apLocaleDefn.Add( pDefn2 )) return WBEM_E_OUT_OF_MEMORY;
    }
        
    return WBEM_S_NO_ERROR;
}

HRESULT CLocaleCache::GetDefaultDefn( CLocaleDefn** ppDefn )
{
    HRESULT hr = WBEM_E_FAILED;

    // Get the definition at location 0
    // ================================

    int nLID = -1;

    if ( 0 < m_apLocaleDefn.GetSize() )
    {
        CLocaleDefn*    pDefn = m_apLocaleDefn[0];

        // And verify that it has a locale of 0
        // ====================================

        if ( NULL != pDefn )
        {
            hr = pDefn->GetLID( nLID );
        }

        if ( SUCCEEDED( hr ) && ( 0 == nLID ) )
        {
            *ppDefn = pDefn;
            (*ppDefn)->AddRef();
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }

    return hr;
}

HRESULT CLocaleCache::BeginEnum( )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // 1 is the first localized defnintion
    // ===================================

    m_nEnumIndex = 1;

    return hr;
}

HRESULT CLocaleCache::Next( CLocaleDefn** ppDefn )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*    pDefn = NULL;
    int             nSize = m_apLocaleDefn.GetSize();

    if ( ( -1 < m_nEnumIndex ) && ( nSize > m_nEnumIndex ) )
    {
        pDefn = m_apLocaleDefn[m_nEnumIndex++];
    }
    else
    {
        m_nEnumIndex = -1;
        hr = WBEM_E_FAILED;
    }

    if ( SUCCEEDED( hr ) )
    {
        *ppDefn = pDefn;

        if ( NULL != *ppDefn )
            (*ppDefn)->AddRef();
        else
            hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CLocaleCache::EndEnum()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_nEnumIndex = -1;

    return hr;
}

//
//
//   Known Service
//
///////////////////////////////////////////////////////////

//
//
//

bool
WCmp::operator()(WString pFirst,WString pSec) const
{

    int res = wbem_wcsicmp(pFirst,pSec);

    return (res<0);
}



CKnownSvcs::CKnownSvcs(WCHAR * pMultiSzName):
    m_cRef(1),
    m_MultiSzName(pMultiSzName)
{
}

CKnownSvcs::~CKnownSvcs()
{
}

DWORD 
CKnownSvcs::Add(WCHAR * pService)
{
    if (pService)
    {
        MapSvc::iterator it = m_SetServices.find(pService);
        if (it == m_SetServices.end())
        {
            try 
            {    
                m_SetServices.insert(MapSvc::value_type(pService,ServiceRec(true)));
            } 
            catch (CX_MemoryException) 
            {
                return ERROR_OUTOFMEMORY;
            }
        }
        return 0;
    }
    else
        return ERROR_INVALID_PARAMETER;
}

DWORD
CKnownSvcs::Get(WCHAR * pService, ServiceRec ** ppServiceRec)
{
    if (pService && ppServiceRec)
    {
        MapSvc::iterator it = m_SetServices.find(pService);
        if (it == m_SetServices.end())
        {
            *ppServiceRec = NULL;
            return ERROR_OBJECT_NOT_FOUND;
        }
        else
        {
            *ppServiceRec = &(it->second);
            return 0;
        }
    }
    else
        return ERROR_INVALID_PARAMETER;
}


DWORD 
CKnownSvcs::Remove(WCHAR * pService)
{
    if (pService)
    {
        MapSvc::iterator it = m_SetServices.find(pService);
        if (it != m_SetServices.end())
        {
            try {
                m_SetServices.erase(it);
            } catch (CX_MemoryException) {
                return ERROR_OUTOFMEMORY;
            }
        }
        return 0;
    }
    else
        return ERROR_INVALID_PARAMETER;
}

DWORD 
CKnownSvcs::Load()
{
    // get the MULTI_SZ key
    LONG lRet;
    HKEY hKey;
    
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        WBEM_REG_WINMGMT,
                        NULL,
                        KEY_READ,
                        &hKey);
                        
    if (ERROR_SUCCESS == lRet)
    {
        DWORD dwSize = 0;
        DWORD dwType = REG_MULTI_SZ;

        lRet = RegQueryValueEx(hKey,
                               m_MultiSzName,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize);
                               
        if (ERROR_SUCCESS == lRet && (dwSize > 0))
        {
            BYTE * pStrBYTE = new BYTE[dwSize];

            if (pStrBYTE)
            {
                CVectorDeleteMe<BYTE>  vdm(pStrBYTE);
                lRet = RegQueryValueEx(hKey,
                                   m_MultiSzName,
                                   NULL,
                                   &dwType,
                                   (BYTE *)pStrBYTE,
                                   &dwSize);
                if (ERROR_SUCCESS == lRet && REG_MULTI_SZ == dwType)
                {
                    TCHAR * pStr = (TCHAR *)pStrBYTE;
                    DWORD dwLen = 0;
                    while(dwLen = lstrlen(pStr))
                    {
                        try 
                        {
                            m_SetServices.insert(MapSvc::value_type(pStr,ServiceRec(true)));
                            pStr += (dwLen+1);
                        } 
                        catch (CX_MemoryException) 
                        {
                            lRet = ERROR_OUTOFMEMORY;
                            break;
                        }
                    }
                }
            }
            else
            {
                lRet = ERROR_OUTOFMEMORY;
            }
        }

        RegCloseKey(hKey);
    }

    return lRet;
}

DWORD 
CKnownSvcs::Save()
{
    // Write the MULTI_SZ key
    
    MapSvc::iterator it;
    DWORD dwAllocSize = 1; // the trailing \0
    
    for (it = m_SetServices.begin();it != m_SetServices.end();++it)
    {
        dwAllocSize += (1+lstrlenW( (*it).first ));
    }

    WCHAR * pMultiSz = new WCHAR[dwAllocSize];

    if (!pMultiSz)
        return ERROR_NOT_ENOUGH_MEMORY;
        
    WCHAR * pTmp = pMultiSz;
    for (it = m_SetServices.begin();it != m_SetServices.end();++it)
    {
        const WCHAR * pSrc = (const wchar_t *)it->first;
        DWORD i;
        for (i=0;pSrc[i];i++){
            *pTmp = pSrc[i];
             pTmp++;
        };
        *pTmp = L'\0';
        pTmp++;
    };
    // last char
    *pTmp = L'\0';
    
    DWORD dwSize;
    LONG lRet;
    HKEY hKey;
    
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        WBEM_REG_WINMGMT,
                        NULL,
                        KEY_WRITE,
                        &hKey);
                        
    if (ERROR_SUCCESS == lRet)
    {
        lRet = RegSetValueEx(hKey,
                             m_MultiSzName,
                             NULL,
                             REG_MULTI_SZ,
                             (BYTE*)pMultiSz,
                             dwAllocSize * sizeof(WCHAR));
        
        RegCloseKey(hKey);    
    }

    if (pMultiSz)
        delete [] pMultiSz;

    return lRet;

}

////////////////////////////////////////////////////////////////////////////////
//
//  CClassElem
//
////////////////////////////////////////////////////////////////////////////////

CClassElem::CClassElem( IWbemClassObject* pObj, 
                        CLocaleCache* pLocaleCache, 
                        CKnownSvcs * pKnownSvcs) 
: m_pLocaleCache( pLocaleCache ), 
  m_pDefaultObject( pObj ), 
  m_dwIndex( 0 ), 
  m_bCostly( FALSE ),
  m_dwStatus( 0 ),
  m_bOk( FALSE ),
  m_pKnownSvcs(pKnownSvcs),
  m_bReportEventCalled(FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (m_pKnownSvcs) m_pKnownSvcs->AddRef();
    if (m_pLocaleCache ) m_pLocaleCache->AddRef();

    if (m_pDefaultObject )
    {
        m_pDefaultObject->AddRef();
        hr = InitializeMembers();
    }

    if ( SUCCEEDED( hr )  && 
       ( NULL != m_pLocaleCache ) && 
       ( NULL != m_pDefaultObject ) )
    {
        m_bOk = TRUE;
    }    
}

CClassElem::CClassElem( PERF_OBJECT_TYPE* pPerfObj, 
                        DWORD dwType,
                        BOOL bCostly, 
                        WString wstrServiceName, 
                        CLocaleCache* pLocaleCache,
                        CKnownSvcs * pKnownSvcs)
: m_pLocaleCache( pLocaleCache ), 
  m_pDefaultObject( NULL ), 
  m_dwIndex( 0 ), 
  m_bCostly( bCostly ),
  m_dwStatus( 0 ),
  m_bOk( FALSE ),
  m_wstrServiceName( wstrServiceName ),
  m_pKnownSvcs(pKnownSvcs),
  m_bReportEventCalled(FALSE)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*        pDefn = NULL;
    IWbemClassObject*   pBaseClass = NULL;
    CPerfNameDb*        pNameDb = NULL;

    if ( m_pKnownSvcs) m_pKnownSvcs->AddRef();

    if ( m_pLocaleCache )
    {
        m_pLocaleCache->AddRef();

        // Get the default locale record
        // =============================
        hr = m_pLocaleCache->GetDefaultDefn( &pDefn );
        CAdapReleaseMe  rmDefn( pDefn );

        // Get the names' database
        // =======================
        if ( FAILED( hr ) || NULL == pDefn ) return;

        hr = pDefn->GetNameDb( &pNameDb );
        CAdapReleaseMe  rmNameDb( pNameDb );

        // Create the requested class
        // ==========================
        if ( SUCCEEDED( hr ) )
        {
            hr = pDefn->GetBaseClass( dwType, &pBaseClass );
        }
        CReleaseMe  rmBaseClass( pBaseClass );

        if ( SUCCEEDED( hr ) )
        {
            hr = CDefaultClassBroker::GenPerfClass( pPerfObj, 
                                                    dwType,
                                                    m_bCostly, 
                                                    pBaseClass, 
                                                    pNameDb, 
                                                    m_wstrServiceName, 
                                                    &m_pDefaultObject );
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    // Initialize the class members
    // ============================

    if ( SUCCEEDED( hr ) )
    {
        hr = InitializeMembers();
    }

    if ( SUCCEEDED( hr ) )
    {
        m_bOk = TRUE;
    }
}

VOID
CClassElem::SetKnownSvcs(CKnownSvcs * pKnownSvcs)
{
    if (m_pKnownSvcs)
        return;
        
    m_pKnownSvcs = pKnownSvcs;
    
    if (m_pKnownSvcs)
        m_pKnownSvcs->AddRef();
}

CClassElem::~CClassElem()
{
    if ( m_pLocaleCache ) m_pLocaleCache->Release();
    if ( m_pDefaultObject ) m_pDefaultObject->Release();
    if ( m_pKnownSvcs) m_pKnownSvcs->Release();
}

HRESULT CClassElem::InitializeMembers()
// If the class name is unavaiable, then the initialization fails.  It is not a fatal error if a qualifier is unavailable
{
    HRESULT hr = WBEM_NO_ERROR;
    VARIANT var;

    try
    {
        // Get the object's name
        // =====================
        if ( SUCCEEDED( hr ) )
        {
            hr = m_pDefaultObject->Get(L"__CLASS", 0L, &var, NULL, NULL );

            if ( SUCCEEDED( hr ) )
            {
                m_wstrClassName = var.bstrVal;
                VariantClear( &var );
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            IWbemQualifierSet* pQualSet = NULL;
            hr = m_pDefaultObject->GetQualifierSet( &pQualSet );
            CReleaseMe    rmQualSet( pQualSet );

            // Get the service name
            // ====================
            if ( SUCCEEDED( hr ) )
            {
                hr =  pQualSet->Get( L"registrykey", 0L, &var, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    m_wstrServiceName = var.bstrVal;
                    VariantClear( &var );
                }
                else
                {
                    m_wstrServiceName.Empty();
                    hr = WBEM_S_FALSE;
                }
            }

            // Get the perf index
            // ==================

            if ( SUCCEEDED( hr ) )
            {
                hr = pQualSet->Get( L"perfindex", 0L, &var, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    m_dwIndex = var.lVal;
                    VariantClear( &var );
                }   
                else
                {
                    m_dwIndex = 0;
                    hr = WBEM_S_FALSE;
                }
            }

            // Get the costly qualifier
            // ========================

            if ( SUCCEEDED( hr ) )
            {
                hr = pQualSet->Get( L"costly", 0L, &var, NULL );

                if ( SUCCEEDED( hr ) )
                {
                    m_bCostly = ( var.boolVal == VARIANT_TRUE );
                    VariantClear( &var );
                }
                else
                {
                    VariantClear( &var );
                    m_bCostly = FALSE;
                    hr = WBEM_NO_ERROR;
                }
            }
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CClassElem::UpdateObj( CClassElem* pEl )
// Replaces the WMI object in this element.  The commit will do a CompareTo to compare the 
// original object (if it exists) and replace it with the updated version
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject* pObj = NULL;

    hr = pEl->GetObject( &pObj );

    if ( SUCCEEDED( hr ) )
    {
        if ( NULL != pObj )
        {
            // Release the old object
            // ======================

            m_pDefaultObject->Release();

            // Initialize the new object - already addref'd by GetObject
            // =========================================================

            m_pDefaultObject = pObj;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }

    return hr;
}

HRESULT CClassElem::Remove(BOOL CleanRegistry)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemServices* pNamespace = NULL;
    BSTR        bstrClassName = SysAllocString( m_wstrClassName );
    if (NULL == bstrClassName) return  WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe  sfmClassName( bstrClassName );

    // Delete the localized objects
    // ============================

    CLocaleDefn* pDefn = NULL;

    m_pLocaleCache->BeginEnum();

    while ( ( SUCCEEDED( hr ) ) && ( WBEM_S_NO_ERROR == m_pLocaleCache->Next( &pDefn ) ) ) 
    {
        CAdapReleaseMe  rmDefn( pDefn );

        // Get the localization namespace
        // ==============================

        hr = pDefn->GetNamespace( &pNamespace );

        CReleaseMe  rmNamespace( pNamespace );

        // And delete it
        // =============

        if ( SUCCEEDED( hr ) )
        {
            IWbemClassObject * pObj = NULL;
            
            hr = pNamespace->GetObject(bstrClassName,WBEM_FLAG_RETURN_WBEM_COMPLETE,NULL,&pObj,NULL);

           // release the object before deleting
            if(pObj)  pObj->Release();
                
            if (SUCCEEDED(hr))
            {
            
                hr = pNamespace->DeleteClass( bstrClassName, 0, NULL, NULL );

                if ( FAILED( hr ) )
                {
                    try
                    {
                        // Write on the trace
                        WString wstrNamespaceName;
                        if (SUCCEEDED(hr = pDefn->GetNamespaceName( wstrNamespaceName )))
                        {
                            LPSTR pClass = m_wstrClassName.GetLPSTR();
                            LPSTR pNames = wstrNamespaceName.GetLPSTR();

                            CDeleteMe<CHAR> a(pClass);
                            CDeleteMe<CHAR> b(pNames);

                            ERRORTRACE( ( LOG_WMIADAP,"DeleteClass %s from %s 0x%08x",pClass,pNames,hr));
                        }

                    }
                    catch(...)
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }

            } else {
                // class not found
                // nothing to delete
            }
        
        }
    }

    m_pLocaleCache->EndEnum();

    // Delete the default object
    // =========================

    if ( SUCCEEDED( hr ) )
    {
        hr = m_pLocaleCache->GetDefaultDefn( &pDefn );

        CAdapReleaseMe  rmDefn( pDefn );
        
        if ( SUCCEEDED( hr ) && pDefn )
        {
            hr = pDefn->GetNamespace( &pNamespace );

            CReleaseMe  rmNamespace( pNamespace );

            if ( SUCCEEDED( hr ) )
            {
                hr = pNamespace->DeleteClass( bstrClassName, 0, NULL, NULL );

                if ( FAILED( hr ) )
                {
                    // Log an event
                    // ============

                    ServiceRec * pSvcRec = NULL;
                    if (0 == m_pKnownSvcs->Get(m_wstrServiceName,&pSvcRec))
                    {
                        if (!pSvcRec->IsELCalled() && !m_bReportEventCalled)
                        {
                            try
                            {
                                WString wstrNamespaceName;
            
                                if (SUCCEEDED(hr = pDefn->GetNamespaceName( wstrNamespaceName )))
                                {
                                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                                          WBEM_MC_ADAP_PERFLIB_REMOVECLASS_FAILURE,
                                                          (LPCWSTR) m_wstrClassName,
                                                          (LPCWSTR) wstrNamespaceName,
                                                          CHex( hr ) );
                                    pSvcRec->SetELCalled();
                                    m_bReportEventCalled = TRUE;
                                }
                            }
                            catch(...)
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }
                        }
                    }
                    else
                    {
                        if (!m_bReportEventCalled)
                        {
                            try
                            {
                                WString wstrNamespaceName;
            
                                if (SUCCEEDED(hr = pDefn->GetNamespaceName( wstrNamespaceName )))
                                {
                                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                                          WBEM_MC_ADAP_PERFLIB_REMOVECLASS_FAILURE,
                                                          (LPCWSTR) m_wstrClassName,
                                                          (LPCWSTR) wstrNamespaceName,
                                                          CHex( hr ) );
                                    m_bReportEventCalled = TRUE;
                                }
                            }
                            catch(...)
                            {
                                hr = WBEM_E_OUT_OF_MEMORY;
                            }                        
                        }
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (m_pKnownSvcs)
            m_pKnownSvcs->Remove((WCHAR *)m_wstrServiceName);
    }

    if (CleanRegistry && SUCCEEDED(hr))
    {
    WString wszRegPath = L"SYSTEM\\CurrentControlSet\\Services\\";
        wszRegPath += m_wstrServiceName;
    wszRegPath += L"\\Performance";

    CNTRegistry reg;
        int         nRet = 0;
                
    nRet = reg.Open( HKEY_LOCAL_MACHINE, wszRegPath );

        switch( nRet )
        {
        case CNTRegistry::no_error:
            {
                reg.DeleteValue(ADAP_PERFLIB_STATUS_KEY);
                reg.DeleteValue(ADAP_PERFLIB_SIGNATURE);
                reg.DeleteValue(ADAP_PERFLIB_SIZE);
                reg.DeleteValue(ADAP_PERFLIB_TIME);
            } 
            break;
        case CNTRegistry::not_found:
            {
                hr = WBEM_E_FAILED;
            }
            break;
        case CNTRegistry::access_denied:
            {
                ServiceRec * pSvcRec = NULL;
                if (0 == m_pKnownSvcs->Get(m_wstrServiceName,&pSvcRec))
                {
                    if (!pSvcRec->IsELCalled() && !m_bReportEventCalled)
                    {
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                               WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                              (LPWSTR)wszRegPath, nRet );
                        pSvcRec->SetELCalled();
                        m_bReportEventCalled = TRUE;
                    }
                }
                else
                {
                    if (!m_bReportEventCalled)
                    {
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                               WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                              (LPWSTR)wszRegPath, nRet );
                        m_bReportEventCalled = TRUE;
                    }                
                }
            }
            break;
        }
        
    }

    return hr;
}

HRESULT CClassElem::Insert()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*    pDefaultDefn = NULL;
    IWbemServices*  pNamespace = NULL;

    // perform object validation
    _IWmiObject * pInternal = NULL;
    hr = m_pDefaultObject->QueryInterface(IID__IWmiObject,(void **)&pInternal);
    if (SUCCEEDED(hr))
    {
        CReleaseMe rmi(pInternal);
        hr = pInternal->ValidateObject(WMIOBJECT_VALIDATEOBJECT_FLAG_FORCE);        
        if (FAILED(hr))
        {
#ifdef DBG
            DebugBreak();
#endif
            ERRORTRACE((LOG_WMIADAP,"ValidateObject(%S) %08x\n",(LPWSTR)m_wstrClassName,hr));
            return hr;
        }
    }

    // Add the object to the default namespace
    // =======================================

    hr = m_pLocaleCache->GetDefaultDefn( &pDefaultDefn );
    if (FAILED(hr) || NULL == pDefaultDefn) return (FAILED(hr)?hr:WBEM_E_FAILED);
    CAdapReleaseMe  rmDefaultDefn( pDefaultDefn );
        
    hr = pDefaultDefn->GetNamespace( &pNamespace );
    CReleaseMe  rmNamespace( pNamespace );

    if ( SUCCEEDED( hr ) )
    {
        hr = pNamespace->PutClass( m_pDefaultObject, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

        if ( FAILED( hr ) )
        {
            ServiceRec * pSvcRec = NULL;
            if (0 == m_pKnownSvcs->Get(m_wstrServiceName,&pSvcRec))
            {
                if (!pSvcRec->IsELCalled() && !m_bReportEventCalled)
                {
                    try
                    {
                        WString wstrNamespace; 

                        if (SUCCEEDED(hr = pDefaultDefn->GetNamespaceName( wstrNamespace )))
                            {

                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                                  WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
                                                  (LPCWSTR)m_wstrClassName, 
                                                  (LPCWSTR) wstrNamespace, 
                                                  CHex( hr ) );                                                      
                        m_bReportEventCalled = TRUE;
                        pSvcRec->SetELCalled();
                            }
                    }
                    catch(...)
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
            
            }
            else
            {
                if (!m_bReportEventCalled)
                {
                    try
                    {
                        WString wstrNamespace; 

                        if (SUCCEEDED(hr = pDefaultDefn->GetNamespaceName( wstrNamespace )))
                            {

                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                                  WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
                                                  (LPCWSTR)m_wstrClassName, 
                                                  (LPCWSTR) wstrNamespace, 
                                                  CHex( hr ) );
                        m_bReportEventCalled = TRUE;
                            }
                    }
                    catch(...)
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
            }
        }
    }


    if ( SUCCEEDED( hr ) )
    {
        //
        //   Add the servicename to the MultiSz Key
        //

        if (m_pKnownSvcs)
            m_pKnownSvcs->Add((WCHAR *)m_wstrServiceName);            
        
        hr = VerifyLocales();
    }

    if ( SUCCEEDED( hr ) )
    {
        SetStatus( ADAP_OBJECT_IS_REGISTERED );
    }

    return hr;
}

HRESULT CClassElem::GetClassName( WString& wstr )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try
    {
        wstr = m_wstrClassName;
    }
    catch(CX_MemoryException)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CClassElem::GetClassName( BSTR* pbStr )
{
    if (NULL == pbStr) return WBEM_E_INVALID_PARAMETER;
    
    if (NULL ==   (*pbStr = SysAllocString( (LPCWSTR) m_wstrClassName )))
      return WBEM_E_OUT_OF_MEMORY;
 
    return WBEM_S_NO_ERROR;
}

HRESULT CClassElem::GetObject( IWbemClassObject** ppObj )
{ 
    if (NULL == ppObj) return WBEM_E_INVALID_PARAMETER;

    HRESULT hr = WBEM_S_NO_ERROR;

    if ( NULL != m_pDefaultObject ) 
    {
        *ppObj = m_pDefaultObject; 
        (*ppObj)->AddRef();
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CClassElem::GetServiceName( WString& wstrServiceName )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try 
    {
        wstrServiceName = m_wstrServiceName;
    }
    catch(CX_MemoryException)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

BOOL CClassElem::SameName( CClassElem* pEl )
{
    WString wstrOtherName;

    try
    {
        if ( FAILED ( pEl->GetClassName( wstrOtherName ) ) )
            return FALSE;
    }
    catch(...)
    {
        return FALSE;
    }

    return m_wstrClassName.Equal( wstrOtherName );
}

BOOL CClassElem::SameObject( CClassElem* pEl )
{
    BOOL    bRes = FALSE;

    IWbemClassObject*    pObj = NULL;

    if (FAILED(pEl->GetObject( &pObj ))) return FALSE;

    CReleaseMe  rmObj( pObj );

    bRes = ( m_pDefaultObject->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE, pObj ) == WBEM_S_SAME );

    return bRes;
}

HRESULT CClassElem::Commit()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Ensure that object is in default namespace
    // ==========================================

    if ( CheckStatus( ADAP_OBJECT_IS_DELETED ) )
    {
        hr = Remove( CheckStatus(ADAP_OBJECT_IS_TO_BE_CLEARED) );
    }
    else if ( CheckStatus( ADAP_OBJECT_IS_REGISTERED | ADAP_OBJECT_IS_NOT_IN_PERFLIB ) && !CheckStatus( ADAP_OBJECT_IS_INACTIVE ) )
    {
        if ( IsPerfLibUnloaded() )
        {
            hr = Remove( TRUE );
        }
        else // the object is there 
        {
            if (m_pKnownSvcs)
                m_pKnownSvcs->Add((WCHAR *)m_wstrServiceName);
        }
    }
    else if ( !CheckStatus( ADAP_OBJECT_IS_REGISTERED ) )
    {
        hr = Insert();
    }
    else
    {
        if (m_pKnownSvcs)
            m_pKnownSvcs->Add((WCHAR *)m_wstrServiceName);

        // non localized classes do not cause an error
        VerifyLocales();
    }

    return hr;
}


BOOL CClassElem::IsPerfLibUnloaded()
{
    // Unless we can specifically prove that the perflib has been unloaded, then we assume that it is still loaded
    BOOL bLoaded = TRUE;

    HRESULT hr = WBEM_S_FALSE;

    WCHAR       wszRegPath[256];
    DWORD       dwFirstCtr = 0, 
                dwLastCtr = 0;
    WCHAR*      wszObjList = NULL;
    CNTRegistry reg;

    int nRet = 0;

    if ( 0 == m_wstrServiceName.Length() )
    {
        bLoaded = FALSE;
    }
    else if ( m_wstrServiceName.EqualNoCase( L"PERFOS" ) ||
              m_wstrServiceName.EqualNoCase( L"TCPIP" ) || 
              m_wstrServiceName.EqualNoCase( L"PERFPROC" ) ||
              m_wstrServiceName.EqualNoCase( L"PERFDISK" ) ||
              m_wstrServiceName.EqualNoCase( L"PERFNET" ) ||
              m_wstrServiceName.EqualNoCase( L"TAPISRV" ) ||
              m_wstrServiceName.EqualNoCase( L"SPOOLER" ) ||
              m_wstrServiceName.EqualNoCase( L"MSFTPSvc" ) ||
              m_wstrServiceName.EqualNoCase( L"RemoteAccess" ) ||
              m_wstrServiceName.EqualNoCase( L"WINS" ) ||
              m_wstrServiceName.EqualNoCase( L"MacSrv" ) ||
              m_wstrServiceName.EqualNoCase( L"AppleTalk" ) ||
              m_wstrServiceName.EqualNoCase( L"NM" ) ||
              m_wstrServiceName.EqualNoCase( L"RSVP" ))
    {
        // This is the list of the hardcoded perflibs - according 
        // to BobW, they are always considered to be loaded
        // ======================================================

        bLoaded = TRUE;
    }
    else
    {
        // Try to open the service's registry key and read the object list or the first/last counter values
        // ================================================================================================
        StringCchPrintfW( wszRegPath,256, L"SYSTEM\\CurrentControlSet\\Services\\%s\\Performance", (WCHAR *)m_wstrServiceName );
        nRet = reg.Open( HKEY_LOCAL_MACHINE, wszRegPath );

        switch( nRet )
        {
        case CNTRegistry::not_found:
            {
                bLoaded = FALSE;
            }break;

        case CNTRegistry::no_error:
            {
                bLoaded =   ( reg.GetStr( L"Object List", &wszObjList ) == CNTRegistry::no_error ) ||
                            ( ( reg.GetDWORD( L"First Counter", &dwFirstCtr ) == CNTRegistry::no_error ) &&
                            ( reg.GetDWORD( L"Last Counter", &dwLastCtr ) == CNTRegistry::no_error ) 
                            );
            }break;

        case CNTRegistry::access_denied:
            {

                ServiceRec * pSvcRec = NULL;
                if (0 == m_pKnownSvcs->Get(m_wstrServiceName,&pSvcRec))
                {
                    if (!pSvcRec->IsELCalled() && !m_bReportEventCalled)
                    {
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                                  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                                  wszRegPath, nRet );                    
                         m_bReportEventCalled = TRUE;
                         pSvcRec->SetELCalled();
                    }
                }
                else 
                {
                    if (!m_bReportEventCalled)
                    {
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                                  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                                  wszRegPath, nRet );
                        m_bReportEventCalled = TRUE;
                    }
                }
            }break;
        }
    }

    return !bLoaded;
}

HRESULT CClassElem::CompareLocale( CLocaleDefn* pLocaleDefn, IWbemClassObject* pObj )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*        pDefaultDefn = NULL;
    IWbemClassObject*    pLocaleObj = NULL;

    hr = m_pLocaleCache->GetDefaultDefn( &pDefaultDefn );
    if (FAILED(hr) || NULL == pDefaultDefn) return (FAILED(hr)?hr:WBEM_E_FAILED);
    CAdapReleaseMe  armDefaultDefn( pDefaultDefn );

    hr = CLocaleClassBroker::ConvertToLocale( m_pDefaultObject, pLocaleDefn, pDefaultDefn, &pLocaleObj);

    CReleaseMe  rmLocaleObj( pLocaleObj );

    if ( SUCCEEDED( hr ) )
    {
        hr = pObj->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE, pLocaleObj );
    }

    return hr;
}

HRESULT CClassElem::InsertLocale( CLocaleDefn* pLocaleDefn )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*        pDefaultDefn = NULL;
    IWbemClassObject*    pLocaleObj = NULL;
    IWbemServices*        pNamespace = NULL;

    hr = m_pLocaleCache->GetDefaultDefn( &pDefaultDefn );
    if (FAILED(hr) || NULL == pDefaultDefn) return (FAILED(hr)?hr:WBEM_E_FAILED);    
    CAdapReleaseMe  armDefaultDefn( pDefaultDefn );

    hr = CLocaleClassBroker::ConvertToLocale( m_pDefaultObject, pLocaleDefn, pDefaultDefn, &pLocaleObj);
    CReleaseMe  rmLocaleObj( pLocaleObj );

    if (SUCCEEDED(hr))
    {
        // perform object validation
        _IWmiObject * pInternal = NULL;
        hr = pLocaleObj->QueryInterface(IID__IWmiObject,(void **)&pInternal);
        if (SUCCEEDED(hr))
        {        
            CReleaseMe rmi(pInternal);
            hr = pInternal->ValidateObject(WMIOBJECT_VALIDATEOBJECT_FLAG_FORCE);
            if (FAILED(hr))
            {
#ifdef DBG
                    DebugBreak();
#endif
                ERRORTRACE((LOG_WMIADAP,"ValidateObject(%S) %08x\n",(LPWSTR)m_wstrClassName,hr));
                return hr;
            }
        }
    }
    
    // And add it to the localized namespace
    // =====================================

    if ( SUCCEEDED( hr ) )
    {
        hr = pLocaleDefn->GetNamespace( &pNamespace );

        CReleaseMe  rmNamespace( pNamespace );

        if ( SUCCEEDED( hr ) )
        {
            hr = pNamespace->PutClass( pLocaleObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

            if ( FAILED( hr ) )
            {
                ServiceRec * pSvcRec = NULL;
                if (0 == m_pKnownSvcs->Get(m_wstrServiceName,&pSvcRec))
                {
                    if (!pSvcRec->IsELCalled() && !m_bReportEventCalled)
                    {
                        try
                        {
                            WString wstrNamespace; 

                            if (SUCCEEDED(hr = pLocaleDefn->GetNamespaceName( wstrNamespace )))
                                {

                            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                                      WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
                                                      (LPCWSTR)m_wstrClassName, (LPCWSTR) wstrNamespace, CHex( hr ) ); 
                            m_bReportEventCalled = TRUE;
                             pSvcRec->SetELCalled();        
                                }
                        }
                        catch(...)
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                }
                else 
                {
                    if (!m_bReportEventCalled)
                    {
                        try
                        {
                            WString wstrNamespace; 

                            if (SUCCEEDED(hr = pLocaleDefn->GetNamespaceName( wstrNamespace )))
                                {

                            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                                      WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
                                                      (LPCWSTR)m_wstrClassName, (LPCWSTR) wstrNamespace, CHex( hr ) ); 
                            m_bReportEventCalled = TRUE;
                                }
                        }
                        catch(...)
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }
                    }
                }                
            }
        }
    }
    else 
    {
        // no localized class
        ERRORTRACE( ( LOG_WMIADAP, "InsertLocale PutClass(%S) %08x\n",(LPWSTR)m_wstrClassName,hr) );
    }

    return hr;
}

HRESULT CClassElem::VerifyLocales()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*        pLocaleDefn = NULL;
    IWbemClassObject*    pLocaleObj = NULL;
    IWbemServices*        pNamespace = NULL;

    // Get the localized objects
    // =========================

    hr = m_pLocaleCache->BeginEnum();

    while ( ( SUCCEEDED( hr ) ) && ( WBEM_S_NO_ERROR == m_pLocaleCache->Next( &pLocaleDefn ) ) )
    {
        CAdapReleaseMe  rmLocaleDefn( pLocaleDefn );

        // Get the localization namespace
        // ==============================

        hr = pLocaleDefn->GetNamespace( &pNamespace );
        CReleaseMe  rmNamespace( pNamespace );

        // Get the localized object
        // ========================

        if ( SUCCEEDED( hr ) )
        {
            BSTR        bstrClassName = SysAllocString( m_wstrClassName );
            if (NULL == bstrClassName) { hr = WBEM_E_OUT_OF_MEMORY; continue; }
            CSysFreeMe  sfmClassName( bstrClassName );

            hr = pNamespace->GetObject( bstrClassName, 0L, NULL, &pLocaleObj, NULL );

            CReleaseMe  rmLocaleObj( pLocaleObj );

            if ( SUCCEEDED( hr ) )
            {
                if ( CompareLocale( pLocaleDefn, pLocaleObj ) != WBEM_S_SAME )
                {
                    hr = InsertLocale( pLocaleDefn );
                }
            }
            else
            {
                hr = InsertLocale( pLocaleDefn );
            }
        }

        pLocaleObj = NULL;
    }

    m_pLocaleCache->EndEnum();

    return hr;
}

HRESULT CClassElem::SetStatus( DWORD dwStatus )
{
    m_dwStatus |= dwStatus;

    return WBEM_NO_ERROR;
}

HRESULT CClassElem::ClearStatus( DWORD dwStatus )
{
    m_dwStatus &= ~dwStatus;

    return WBEM_NO_ERROR;
}

BOOL CClassElem::CheckStatus( DWORD dwStatus )
{
    return ( ( m_dwStatus & dwStatus ) == dwStatus );
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CClassList
//
////////////////////////////////////////////////////////////////////////////////////////////


CClassList::CClassList( CLocaleCache* pLocaleCache )
: m_pLocaleCache( pLocaleCache ),
  m_nEnumIndex( -1 ),
  m_fOK( FALSE )
{
    if ( m_pLocaleCache )
        m_pLocaleCache->AddRef();
}

CClassList::~CClassList( void )
{
    if ( m_pLocaleCache )
        m_pLocaleCache->Release();
}

HRESULT CClassList::BeginEnum()
{
    m_nEnumIndex = 0;
    return  WBEM_S_NO_ERROR;
}

HRESULT CClassList::Next( CClassElem** ppEl )
{
    if (NULL == ppEl) return WBEM_E_INVALID_PARAMETER;
        
    HRESULT hr = WBEM_S_NO_ERROR;

    int nSize = m_array.GetSize();
    CClassElem* pEl = NULL;

    do 
    {
        if ( ( -1 < m_nEnumIndex ) && ( nSize > m_nEnumIndex ) )
        {
            pEl = m_array[m_nEnumIndex++];
        }
        else
        {
            m_nEnumIndex = -1;
            hr = WBEM_E_FAILED;
        }
    }
    while ( ( SUCCEEDED( hr ) ) && ( pEl->CheckStatus( ADAP_OBJECT_IS_DELETED ) ) );

    if ( SUCCEEDED( hr ) )
    {
        *ppEl = pEl; 
        
        if ( NULL != *ppEl )
        {
            (*ppEl)->AddRef();
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }

    return hr;
}

HRESULT CClassList::EndEnum()
{
    m_nEnumIndex = -1;
    return WBEM_S_NO_ERROR;
}

HRESULT CClassList::AddElement( CClassElem* pElem )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( ( NULL != pElem ) &&  ( pElem->IsOk() ) )
    {
        if ( -1 == m_array.Add( pElem ) )
            {
            // Add failed
            // ==========
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// Removes the object at the index
HRESULT CClassList::RemoveAt( int nIndex )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Should auto release the object

    m_array.RemoveAt( nIndex );

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CPerfClassList
//
////////////////////////////////////////////////////////////////////////////////

CPerfClassList::CPerfClassList( CLocaleCache* pLocaleCache, WCHAR* pwcsServiceName )
: CClassList( pLocaleCache ), 
  m_wstrServiceName( pwcsServiceName )
{
}

HRESULT CPerfClassList::AddPerfObject( PERF_OBJECT_TYPE* pObj, DWORD dwType, BOOL bCostly )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Create the WMI object
    // =====================

    CClassElem* pElem = new CClassElem( pObj, dwType, bCostly, m_wstrServiceName, m_pLocaleCache );
    CAdapReleaseMe  armElem( pElem );

    if ( ( NULL != pElem ) && ( pElem->IsOk() ) )
    {
        hr = AddElement( pElem );
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CPerfClassList::AddElement( CClassElem *pEl )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CClassElem* pCurrEl = NULL;
    BOOL bFound = FALSE;

    hr = BeginEnum();

    while ( ( WBEM_S_NO_ERROR == Next( &pCurrEl ) ) && ( SUCCEEDED( hr ) ) )
    {
        CAdapReleaseMe rmCurEl( pCurrEl );

        if ( pCurrEl->SameName( pEl ) )
        {
            bFound = TRUE;
            break;
        }
    }

    EndEnum();

    if ( bFound )
    {
        WString wstrClassName;
        WString wstrServiceName;

        if(FAILED(hr = pEl->GetClassName( wstrClassName ))) return hr;
        if(FAILED(hr = pEl->GetServiceName( wstrServiceName ))) return hr;

        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                  WBEM_MC_ADAP_DUPLICATE_CLASS, 
                                  (LPCWSTR)wstrClassName, (LPCWSTR)wstrServiceName );
    }
    else
    {
        if (-1 == m_array.Add( pEl )) hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CMasterClassList
//
////////////////////////////////////////////////////////////////////////////////

CMasterClassList::CMasterClassList( CLocaleCache* pLocaleCache,
                                    CKnownSvcs * pCKnownSvcs)
: CClassList( pLocaleCache ),
 m_pKnownSvcs(pCKnownSvcs)
{
    if (m_pKnownSvcs)
        m_pKnownSvcs->AddRef();
}

CMasterClassList::~CMasterClassList()
{
    if (m_pKnownSvcs)
        m_pKnownSvcs->Release();
}

// Adds an element to the classlist
HRESULT CMasterClassList::AddClassObject( IWbemClassObject* pObj, BOOL bSourceWMI, BOOL bDelta )
{
    HRESULT hr = WBEM_NO_ERROR;

    // Create a new class list element
    // ===============================

    CClassElem* pElem = new CClassElem( pObj, m_pLocaleCache );
    CAdapReleaseMe  armElem( pElem );

    if ( ( NULL != pElem ) &&  ( pElem->IsOk() ) )
    {
        if ( bSourceWMI )
        {
            pElem->SetStatus( ADAP_OBJECT_IS_REGISTERED | ADAP_OBJECT_IS_NOT_IN_PERFLIB );
        }

        if ( -1 == m_array.Add( pElem ) )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        } 
        else
        {
            pElem->SetKnownSvcs(m_pKnownSvcs);
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// Builds a list of class objects that can be located by name
HRESULT CMasterClassList::BuildList( WCHAR* wszBaseClass, 
                                     BOOL bDelta, 
                                     BOOL bThrottle )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CLocaleDefn*    pDefn = NULL;
    IWbemServices*  pNamespace = NULL;

    // Create the class enumerator
    // ===========================

    hr = m_pLocaleCache->GetDefaultDefn( &pDefn );
    if (FAILED(hr) || NULL == pDefn) return (FAILED(hr)?hr:WBEM_E_FAILED);
    CAdapReleaseMe  rmDefn( pDefn );

    hr = pDefn->GetNamespace( &pNamespace );

    CReleaseMe  rmNamespace( pNamespace );

    if ( SUCCEEDED( hr ) )
    {
        BSTR        bstrClass = SysAllocString( wszBaseClass );        
        CSysFreeMe  sfmClass(bstrClass);

        if ( NULL != bstrClass )
        {
            IEnumWbemClassObject*   pEnum = NULL;
            hr = pNamespace->CreateClassEnum( bstrClass,
                                              WBEM_FLAG_SHALLOW,
                                              NULL,
                                              &pEnum );
            // Walk the enumerator
            // ===================

            if ( SUCCEEDED( hr ) )
            {
                // Set Interface security
                // ======================

                hr = WbemSetProxyBlanket( pEnum, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                    RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

                // Walk the object list in blocks of 100
                // =====================================

                while ( SUCCEEDED( hr ) && WBEM_S_FALSE != hr)
                {
                    ULONG   ulNumReturned = 0;

                    IWbemClassObject*   apObjectArray[100];

                    ZeroMemory( apObjectArray, sizeof(apObjectArray) );

                    // Fetch the objects from the enumerator in blocks of 100
                    // ======================================================

                    hr = pEnum->Next( WBEM_INFINITE,
                                    100,
                                    apObjectArray,
                                    &ulNumReturned );

                    // For each object, add it to the class list array
                    // ===============================================

                    if ( SUCCEEDED( hr ) && ulNumReturned > 0 )
                    {
                        // Add the objects
                        // ===============

                        for ( int x = 0; SUCCEEDED( hr ) && x < ulNumReturned; x++ )
                        {
                            if (bThrottle )
                            {
                                HRESULT hrThr = Throttle(THROTTLE_USER|THROTTLE_IO,
                                         ADAP_IDLE_USER,
                                         ADAP_IDLE_IO,
                                         ADAP_LOOP_SLEEP,
                                         ADAP_MAX_WAIT);
                                if (THROTTLE_FORCE_EXIT == hrThr)
                                {
                                    //OutputDebugStringA("(ADAP) Unthrottle command received\n");
                                    bThrottle = FALSE;
                                    UNICODE_STRING BaseUnicodeCommandLine = NtCurrentPeb()->ProcessParameters->CommandLine;
                                    WCHAR * pT = wcschr(BaseUnicodeCommandLine.Buffer,L't');
                                    if (0 == pT)
                                        pT = wcschr(BaseUnicodeCommandLine.Buffer,L'T');
                                    if (pT)
                                    {
                                        *pT = L' ';
                                        pT--;
                                        *pT = L' ';                                       
                                    }
                                }                                
                            }
                        
                            HRESULT temphr = WBEM_S_NO_ERROR;
                            _variant_t    var;
                            IWbemClassObject* pObject = apObjectArray[x];

                            // Only add generic perf counter objects
                            // =====================================

                            IWbemQualifierSet*    pQualSet = NULL;
                            hr = pObject->GetQualifierSet( &pQualSet );
                            CReleaseMe    rmQualSet( pQualSet );
                            
                            if ( SUCCEEDED( hr ) )
                            {
                                var = bool(true);                                
                                temphr = pQualSet->Get( L"genericperfctr", 0L, &var, NULL );

                                if ( SUCCEEDED( temphr ) && 
                                     ( V_VT(&var) == VT_BOOL ) &&
                                     ( V_BOOL(&var) == VARIANT_TRUE ) )
                                {
                                    hr = AddClassObject( pObject, TRUE, bDelta );
                                }
                            }

                            pObject->Release();
                        }

                        // If an add operation failed, release the rest of the pointers
                        // ============================================================

                        if ( FAILED( hr ) )
                        {
                            for ( ; x < ulNumReturned; x++ )
                            {
                                apObjectArray[x]->Release();
                            }

                        }   // IF FAILED( hr ) )

                    }   // IF Next

                }   // WHILE enuming

                if ( WBEM_S_FALSE == hr )
                {
                    hr = WBEM_S_NO_ERROR;
                }

                pEnum->Release();

            }   // IF CreateClassEnum
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

HRESULT CMasterClassList::Merge( CClassList* pClassList, BOOL bDelta )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CClassElem* pEl = NULL;

    hr = pClassList->BeginEnum();

    // Does not return objects marked for deletion

    while ( ( WBEM_S_NO_ERROR == pClassList->Next( &pEl ) ) && ( SUCCEEDED( hr ) ) )
    {    
        CAdapReleaseMe  rmEl( pEl );

        hr = AddElement( pEl, bDelta ); 
    }

    pClassList->EndEnum();

    return hr;
}


// Cycle through all of the objects and set the inactive status for any object
// with an index between the library's counter index range


HRESULT CMasterClassList::Commit(BOOL bThrottle)
{
    HRESULT hr = WBEM_NO_ERROR;

    int nEl,
        nNumEl = m_array.GetSize();

    DWORD   dwWait;

    dwWait = WaitForSingleObject( g_hAbort, 0 );

    if ( WAIT_OBJECT_0 != dwWait )
    {
        // Validate object's uniqueness in list
        // ====================================

        for ( nEl = 0; SUCCEEDED( hr ) && nEl < nNumEl; nEl++ )
        {

            if (bThrottle)
            {
                HRESULT hrThr = Throttle(THROTTLE_USER|THROTTLE_IO,
                             ADAP_IDLE_USER,
                             ADAP_IDLE_IO,
                             ADAP_LOOP_SLEEP,
                             ADAP_MAX_WAIT);
                if (THROTTLE_FORCE_EXIT == hrThr)
                {
                    //OutputDebugStringA("(ADAP) Unthrottle command received\n");
                    bThrottle = FALSE;
                    UNICODE_STRING BaseUnicodeCommandLine = NtCurrentPeb()->ProcessParameters->CommandLine;
                    WCHAR * pT = wcschr(BaseUnicodeCommandLine.Buffer,L't');
                    if (0 == pT)
                        pT = wcschr(BaseUnicodeCommandLine.Buffer,L'T');
                    if (pT)
                    {
                        *pT = L' ';
                        pT--;
                        *pT = L' ';                                       
                    }                    
                }
            }
            
            CClassElem* pCurrElem = (CClassElem*)m_array[nEl];
            
            pCurrElem->Commit();
        }
    }
    else
    {
        hr = WBEM_E_CRITICAL_ERROR;
    }

    return hr;
}



HRESULT CMasterClassList::AddElement( CClassElem *pEl, BOOL bDelta )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CClassElem* pCurrEl = NULL;
    BOOL bFound = FALSE;

    hr = BeginEnum();

    while ( ( WBEM_S_NO_ERROR == Next( &pCurrEl ) ) && ( SUCCEEDED( hr ) ) )
    {
        CAdapReleaseMe rmCurrEl( pCurrEl );

        if ( pCurrEl->SameName( pEl ) )
        {
            bFound = TRUE;

            if ( pCurrEl->SameObject( pEl ) )
            {
                // Set the satus as found
                // ======================
                pCurrEl->ClearStatus( ADAP_OBJECT_IS_NOT_IN_PERFLIB );                
            }
            else
            {
                // Replace the current perflib
                // ===========================
                pCurrEl->UpdateObj( pEl );
                pCurrEl->ClearStatus( ADAP_OBJECT_IS_NOT_IN_PERFLIB | ADAP_OBJECT_IS_REGISTERED );
            }

            break;
        }
    }

    EndEnum();

    if ( !bFound )
    {
        pEl->SetKnownSvcs(m_pKnownSvcs);
        if (-1 == m_array.Add( pEl )) hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT 
CMasterClassList::ForceStatus(WCHAR* pServiceName,BOOL bSet,DWORD dwStatus)
{
    if (NULL == pServiceName)  return WBEM_E_INVALID_PARAMETER;
    

    HRESULT hr = WBEM_S_NO_ERROR;
    CClassElem* pCurrEl = NULL;
    BOOL bFound = FALSE;

    hr = BeginEnum();

    while ( ( WBEM_S_NO_ERROR == Next( &pCurrEl ) ) && ( SUCCEEDED( hr ) ) )
    {
        CAdapReleaseMe rmCurrEl( pCurrEl );
        WString wstr;
        if(FAILED(hr = pCurrEl->GetServiceName(wstr))) break;

        if (0 == wbem_wcsicmp((LPWSTR)wstr,pServiceName))
        {
            DEBUGTRACE((LOG_WMIADAP,"ForeceStatus %S %08x\n",(LPWSTR)wstr,pCurrEl->GetStatus()));
            
            if (bSet){
                pCurrEl->SetStatus(dwStatus);
            } else {
                pCurrEl->ClearStatus(dwStatus);
            }
        }
    }

    EndEnum();

    return hr;

}

#ifdef _DUMP_LIST

HRESULT 
CMasterClassList::Dump()
{

    HRESULT hr = WBEM_S_NO_ERROR;
    CClassElem* pCurrEl = NULL;
    BOOL bFound = FALSE;

    hr = BeginEnum();

    while ( ( WBEM_S_NO_ERROR == Next( &pCurrEl ) ) && ( SUCCEEDED( hr ) ) )
    {
        CAdapReleaseMe rmCurrEl( pCurrEl );
        WString wstr;
        hr = pCurrEl->GetServiceName(wstr);
        if(FAILED(hr))
            return hr;

        WString wstr2;
        hr = pCurrEl->GetClassName(wstr2);
        if(FAILED(hr))
            return hr;

        DEBUGTRACE((LOG_WMIADAP,"_DUMP_LIST %S %S\n",(LPWSTR)wstr,(LPWSTR)wstr2));
    }

    EndEnum();

    return hr;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adapcls.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPCLS.H

Abstract:

History:

--*/


#ifndef __ADAPCLS_H__
#define __ADAPCLS_H__

#include <windows.h>
#include <wbemcomn.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <winperf.h>
#include <wstlallc.h>
#include "adapelem.h"
#include "perfndb.h"

#include <comdef.h>
#include <map>

// Global constants
// ================

#define ADAP_DEFAULT_OBJECT				238L
#define ADAP_DEFAULT_NDB				L"009"
#define ADAP_DEFAULT_LANGID				0x0409L
#define ADAP_ROOT_NAMESPACE				L"\\\\.\\root\\cimv2"

#define ADAP_PERF_CIM_STAT_INFO			L"CIM_StatisticalInformation"
#define ADAP_PERF_BASE_CLASS			L"Win32_Perf"
#define ADAP_PERF_RAW_BASE_CLASS		L"Win32_PerfRawData"
#define ADAP_PERF_COOKED_BASE_CLASS		L"Win32_PerfFormattedData"

enum ClassTypes
{
	WMI_ADAP_RAW_CLASS,
	WMI_ADAP_COOKED_CLASS,
	WMI_ADAP_NUM_TYPES
};

// Class list element states
// =========================

#define ADAP_OBJECT_IS_REGISTERED		0x0001L		// Object is in WMI
#define ADAP_OBJECT_IS_DELETED			0x0002L		// Object is marked for deletion
#define ADAP_OBJECT_IS_INACTIVE			0x0004L		// Perflib did not respond
#define ADAP_OBJECT_IS_NOT_IN_PERFLIB	0x0008L		// Object is from an unloaded perflib
#define ADAP_OBJECT_IS_TO_BE_CLEARED	0x0010L		// Need to clear registry


class CLocaleDefn : public CAdapElement
///////////////////////////////////////////////////////////////////////////////
//
//	Contains all of the locale information
//
///////////////////////////////////////////////////////////////////////////////
{
protected:

// Localization values
// ===================

	WString				m_wstrLangId;		// "009"
	WString				m_wstrLocaleId;		// "0x0409"
	WString				m_wstrSubNameSpace;	// "MS_409"
	LANGID				m_LangId;			// 0x0409
	LCID				m_LocaleId;			// 0x0409

// WMI Locale data members
// =======================

	IWbemServices*		m_pNamespace;
	IWbemClassObject*	m_apBaseClass[WMI_ADAP_NUM_TYPES];


// Localized Names' Database
// =========================

	CPerfNameDb*		m_pNameDb;

// Operational members
// ===================

	BOOL			m_bOK;
	HRESULT         m_hRes;

// Protected Methods
// =================

	HRESULT Initialize();
	HRESULT InitializeWMI();
	HRESULT InitializeLID();

public:
	CLocaleDefn( WCHAR* pwcsLangId, 
	             HKEY hKey );
	virtual ~CLocaleDefn();

	HRESULT GetLID( int & nLID );
	HRESULT GetNamespaceName( WString & wstrNamespaceName );
	HRESULT GetNamespace( IWbemServices** ppNamespace );
	HRESULT GetNameDb( CPerfNameDb** ppNameDb );
	HRESULT GetBaseClass( DWORD dwType, IWbemClassObject** pObject );
	HRESULT GetCookedBaseClass( IWbemClassObject** pObject );

	BOOL	IsOK(){ return m_bOK; }
	HRESULT GetHRESULT(){ return m_hRes; };
};


class CLocaleCache : public CAdapElement 
///////////////////////////////////////////////////////////////////////////////
//
//	The cache used to manage locale definitions
//
///////////////////////////////////////////////////////////////////////////////
{
protected:

	// The enumeration index
	// =====================
	int		m_nEnumIndex;

	// The array of locale definition structures
	// =========================================
	CRefedPointerArray<CLocaleDefn>	m_apLocaleDefn;

public:
	CLocaleCache( );
	virtual ~CLocaleCache();

	HRESULT Initialize();
	HRESULT Reset();

	HRESULT GetDefaultDefn( CLocaleDefn** ppDefn );

	HRESULT BeginEnum();
	HRESULT Next( CLocaleDefn** ppLocaleDefn );
	HRESULT EndEnum();
};

// forward
class CKnownSvcs;

class CClassElem : public CAdapElement
////////////////////////////////////////////////////////////////////////////////
//
//	CClassElem
//
////////////////////////////////////////////////////////////////////////////////
{
protected:

// Class properties
// ================

	WString				m_wstrClassName;		// The class name

	DWORD				m_dwIndex;				// The class perf index
	WString				m_wstrServiceName;		// The service name for which the class is a member
	BOOL				m_bCostly;				// The performance type
	BOOL                m_bReportEventCalled;    // did we log something about this in the past

// WMI related
// ===========

	IWbemClassObject*	m_pDefaultObject;		// The WMI class definition

// Operational members
// ===================

	CLocaleCache*		m_pLocaleCache;			// Pointer to the list of locales

	DWORD				m_dwStatus;				// The state of the element
	BOOL				m_bOk;					// The initialization state of this object
	CKnownSvcs *        m_pKnownSvcs;

// Methods 
// =======

	HRESULT VerifyLocales();

	HRESULT InitializeMembers();
	BOOL IsPerfLibUnloaded();

	HRESULT Remove(BOOL CleanRegistry);
	HRESULT Insert();
	HRESULT InsertLocale( CLocaleDefn* pLocaleDefn );
	HRESULT CompareLocale( CLocaleDefn* pLocaleDefn, IWbemClassObject* pObj );
	
public:
	CClassElem(IWbemClassObject* pObj, 
	           CLocaleCache* pLocaleCache, 
	           CKnownSvcs * pKnownSvcs = NULL );
	           
	CClassElem(PERF_OBJECT_TYPE* pPerfObj, 
	           DWORD dwType, BOOL bCostly, 
	           WString wstrServiceName, 
	           CLocaleCache* pLocaleCache, 
	           CKnownSvcs * pKnownSvcs = NULL );
	           
	virtual ~CClassElem();

	HRESULT UpdateObj( CClassElem* pEl );

	HRESULT Commit();

	HRESULT GetClassName( WString& wstr );
	HRESULT GetClassName( BSTR* pbStr );
	HRESULT GetObject( IWbemClassObject** ppObj );
	HRESULT GetServiceName( WString & wstrServiceName );

	BOOL SameName( CClassElem* pEl );
	BOOL SameObject( CClassElem* pEl );

    DWORD   GetStatus(void){ return m_dwStatus; };
	HRESULT SetStatus( DWORD dwStatus );
	HRESULT ClearStatus( DWORD dwStatus );
	BOOL	CheckStatus( DWORD dwStatus );

	BOOL IsOk( void ) {	return m_bOk; }
	VOID SetKnownSvcs(CKnownSvcs * pKnownSvcs);
};

class CClassList : public CAdapElement
///////////////////////////////////////////////////////////////////////////////
//
//	The base class for caches which manage either the Master class list 
//	currently in WMI, or the classes found within a given perflib.  The 
//	classes are managed as class information elements.
//
///////////////////////////////////////////////////////////////////////////////
{
protected:

	// The array of class elements
	// ===========================

	CRefedPointerArray<CClassElem>	m_array;

	// Pointer to the list of locales
	// ==============================

	CLocaleCache*	m_pLocaleCache;

	// Operational members
	// ===================

	int				m_nEnumIndex;
	BOOL			m_fOK;

	HRESULT AddElement( CClassElem* pEl );
	HRESULT	RemoveAt( int nIndex );

	long GetSize( void ) { return m_array.GetSize(); }

public:
	CClassList( CLocaleCache* pLocaleCache );
	virtual ~CClassList();

	BOOL	IsOK(){ return m_fOK; }

	HRESULT BeginEnum();
	HRESULT Next( CClassElem** ppEl );
	HRESULT EndEnum();
};


class CPerfClassList : public CClassList
///////////////////////////////////////////////////////////////////////////////
//
//	The class cache for classes found in performance libraries
//
///////////////////////////////////////////////////////////////////////////////
{
protected:

	// The service name for which this list belongs
	// ============================================

	WString			m_wstrServiceName;

	HRESULT AddElement( CClassElem *pEl );

public:
	CPerfClassList( CLocaleCache* pLocaleCache, WCHAR* pwcsServiceName );
	HRESULT AddPerfObject( PERF_OBJECT_TYPE* pObj, DWORD dwType, BOOL bCostly );
};


class ServiceRec
{
friend class CKnownSvcs;
    
private:
    bool    m_IsServiceThere;
    bool    m_bReportEventCalled;
public:
    ServiceRec(bool IsThere = false,bool EventCalled = false):m_IsServiceThere(IsThere),m_bReportEventCalled(false){};
    bool IsThere(){ return m_IsServiceThere; };
    bool IsELCalled(){ return m_bReportEventCalled; };
    void SetELCalled(){ m_bReportEventCalled = true;};
};    

typedef wbem_allocator<bool> BoolAlloc;

class WCmp{
public:
	bool operator()(WString pFirst,WString pSec) const;
};

typedef std::map<WString,ServiceRec,WCmp, BoolAlloc > MapSvc;

class CKnownSvcs
{
public:
    CKnownSvcs(WCHAR * pMultiSz);
    ~CKnownSvcs();
    DWORD Load();
    DWORD Save();
    DWORD Add(WCHAR * pService);
    DWORD Remove(WCHAR * pService);
    DWORD Get(WCHAR * pService,ServiceRec ** ppServiceRec);
    MapSvc & GetMap(){ return m_SetServices; };
    LONG AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    };
    LONG Release()
    {
        LONG lRet = InterlockedDecrement(&m_cRef);
        if (0 == lRet) delete this;
        return lRet;
    }
private:
    LONG m_cRef;
    WString m_MultiSzName;
    MapSvc m_SetServices; 
};


class CMasterClassList : public CClassList
///////////////////////////////////////////////////////////////////////////////
//
//	The class cache for classes found in the WMI repository
//
///////////////////////////////////////////////////////////////////////////////
{
protected:

    CKnownSvcs * m_pKnownSvcs;

	HRESULT AddElement( CClassElem *pEl, BOOL bDelta );
	HRESULT AddClassObject( IWbemClassObject* pObj, BOOL bSourceWMI, BOOL bDelta );

public:
	CMasterClassList( CLocaleCache* pLocaleCache, CKnownSvcs * pCKnownSvcs );
	~CMasterClassList();

	HRESULT	BuildList( WCHAR* wszBaseClass, BOOL bDelta, BOOL bThrottle );
	HRESULT Merge( CClassList* pClassList, BOOL bDelta );
	HRESULT Commit(BOOL bThrottle);
	HRESULT ForceStatus(WCHAR* pServiceName,BOOL bSet,DWORD dwStatus);
	
#ifdef _DUMP_LIST	
	HRESULT Dump();
#endif	

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\wmiclixmllog.h ===
//////////////////////////////////////////////////////////////////////
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICliXMLLog.h 
Project Name				: WMI Command Line
Author Name					: Biplab Mistry
Date of Creation (dd/mm/yy) : 02-March-2001
Version Number				: 1.0 
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy
		Last Modified Date	: 09-March-2001
****************************************************************************/ 
// WMICliXMLLog.h : header file
//
/*-------------------------------------------------------------------
 Class Name			: CWMICliXMLLog
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for logging the input and output in XML format
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: None
 Interfaces Used    : None
 --------------------------------------------------------------------*/
class CWMICliXMLLog  
{
public:
	CWMICliXMLLog();
	virtual ~CWMICliXMLLog();
	
	// Restrict Assignment
	CWMICliXMLLog& operator=(CWMICliXMLLog& rWmiCliXMLLog);
	
	// Attributes
private:
	
	// Pointer to object of type IXMLDOMDocument, 
	IXMLDOMDocument2	*m_pIXMLDoc;

	//the xml log file name
	_TCHAR				*m_pszLogFile;
	
	//status of whether the new xml document has to be created or not
	BOOL				m_bCreate;

	WMICLIINT			m_nItrNum;

	BOOL				m_bTrace;

	ERRLOGOPT			m_eloErrLogOpt;


// Operations
private:
	HRESULT CreateXMLLogRoot(CParsedInfo& rParsedInfo, BSTR bstrUser);
	
	HRESULT CreateNodeAndSetContent(IXMLDOMNode** pINode, VARIANT varType,
								BSTR bstrName,	BSTR bstrValue,
								CParsedInfo& rParsedInfo);

	HRESULT AppendAttribute(IXMLDOMNode* pINode, BSTR bstrAttribName, 
						VARIANT varValue, CParsedInfo& rParsedInfo);

	HRESULT CreateNodeFragment(WMICLIINT nSeqNum, BSTR bstrNode, BSTR bstrStart, 
							BSTR bstrInput, BSTR bstrOutput, BSTR bstrTarget,
							CParsedInfo& rParsedInfo);

	HRESULT	FrameOutputNode(IXMLDOMNode **pINode, BSTR bstrOutput, 
							BSTR bstrTarget, CParsedInfo& rParsedInfo);

	HRESULT AppendOutputNode(BSTR bstrOutput, BSTR bstrTarget, 
							CParsedInfo& rParsedInfo);

	// Search and deletes all the occurences of /RECORD entries 
	// in the given string strString
	void FindAndDeleteRecord(STRING& strString);

	// This function retrieves the next token from the token vector list
	BOOL GetNextToken(CHARVECTOR& cvTokens, 
								 CHARVECTOR::iterator& theIterator);

	// Search and deletes the /RECORD entry at current position 
	// in the given string strString
	void DeleteRecord(STRING& strString, CHARVECTOR& cvTokens, 
								 CHARVECTOR::iterator& theIterator);
public:
	// write in to the log file
	HRESULT	WriteToXMLLog(CParsedInfo& rParsedInfo, BSTR bstrOutput);

	// Set the Log File Path
	void SetLogFilePath(_TCHAR* pszFile);

	// Stops the logging
	void StopLogging();

	void Uninitialize(BOOL bFinal = FALSE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adapelem.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPELEM.H

Abstract:

History:

--*/

#ifndef __ADAPELEM_H__
#define __ADAPELEM_H__

class CAdapElement
////////////////////////////////////////////////////////////////////////////////
//
//	The base class for all addref'd AMI ADAP objects
//
////////////////////////////////////////////////////////////////////////////////
{
private:
	long	m_lRefCount;

public:
	CAdapElement( void );
	virtual ~CAdapElement(void);

	long AddRef( void );
	long Release( void );
};

class CAdapReleaseMe
{
protected:
    CAdapElement* m_pEl;

public:
    CAdapReleaseMe(CAdapElement* pEl) : m_pEl(pEl){}
    ~CAdapReleaseMe() {if(m_pEl) m_pEl->Release();}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\tools\wmic\wmicmdln.h ===
/****************************************************************************
Copyright information		: Copyright (c) 1998-1999 Microsoft Corporation 
File Name					: WMICommandLn.h 
Project Name				: WMI Command Line
Author Name					: Ch.Sriramachandramurthy 
Date of Creation (dd/mm/yy) : 27th-September-2000
Version Number				: 1.0 
Brief Description			: This file consist of class declaration of
							  class CWMICommandLine
Revision History			: 
		Last Modified By	: Ch. Sriramachandramurthy 
		Last Modified Date	: 16th-January-2001
****************************************************************************/ 

// WMICommandLine.h : header file
//
/*-------------------------------------------------------------------
 Class Name			: CWMICommandLine
 Class Type			: Concrete 
 Brief Description	: This class encapsulates the functionality needed
					  for synchronization the funtionality of three 
					  functional components identified for the WmiCli.exe.
 Super Classes		: None
 Sub Classes		: None
 Classes Used		: CParsedInfo
					  CExecEngine
					  CFormatEngine
					  CParserEngine
 Interfaces Used    : WMI COM Interfaces
 --------------------------------------------------------------------*/

// forward declaration of classes
class CParserEngine;
class CExecEngine;
class CFormatEngine;
class CParsedInfo;

/////////////////////////////////////////////////////////////////////////////
// CWMICommandLine
class CWMICommandLine
{
public:
//	Construction
	CWMICommandLine();

//	Destruction
	~CWMICommandLine();

//	Restrict Assignment
	CWMICommandLine& operator=(CWMICommandLine& rWmiCmdLn);

// Attributes
private:
	//Pointer to the locator object .
	IWbemLocator	*m_pIWbemLocator;
	
	//CParserEngine object 
	CParserEngine	m_ParserEngine;
	
	//CExecEngine object 
	CExecEngine		m_ExecEngine;
	
	//CFormatEngine object 
	CFormatEngine	m_FormatEngine;
	
	//CParsedInfo object 
	CParsedInfo		m_ParsedInfo;

	// error level
	WMICLIUINT		m_uErrLevel;

	// handle to registry key
	HKEY			m_hKey;

	// handle Ctrl+ events
	BOOL			m_bBreakEvent;

	// specifies accepting input (==TRUE) or executing command (==FALSE)
	BOOL			m_bAccCmd;

	// << description to be added >>
	BOOL			m_bDispRes;

	// Flag to specify windows socket interface initialization.
	BOOL			m_bInitWinSock;

	// Buffer to hold data to be send to clipboard.
	CHString		m_chsClipBoardBuffer;

	// added by (Nag)
	BSTRMAP			m_bmKeyWordtoFileName;

	// Height of console buffer before starting utility.
	SHORT			m_nHeight;

	// Width of console buffer before starting utility.
	SHORT			m_nWidth;

	BOOL			m_bCtrlHandlerError;

	// Checks whether mof files timestamps are the same as those which were mofcompiled.
	BOOL EqualTimeStamps( const _bstr_t& path, LPCWSTR mofs[], __int64* filestamps, DWORD dw_mofs );

	// Set mof files timestamps to registry when mofcompiled.
	BOOL SetTimeStamps( LPCWSTR mofs[], const __int64* filestamps, DWORD dw_mofs );

	// clean registry and namespace when update fails
	void MofCompFailureCleanUp ( LPCWSTR mofs[], DWORD dw_mofs );

// Operations
public:

	// Does the initialization ofthe COM library and the security
	// at the process level
	BOOL			Initialize();

	//Gets the Format Engine Object
	CFormatEngine&	GetFormatObject();

	//Gets the Parse Information Object
	CParsedInfo&	GetParsedInfoObject();

	//Uninitializes the the member variables when the execution of a
	//command string issued on the command line is completed.
	void			Uninitialize();

	//processes the given command string 
	SESSIONRETCODE	ProcessCommandAndDisplayResults(_TCHAR* pszBuffer);
	
	//Puts the process to a wait state, launches a worker thread 
	//that keeps track of kbhit()
	void			SleepTillTimeoutOrKBhit(DWORD dwMilliSeconds);

	//Thread procedure polling for keyboard hit
	static DWORD	WINAPI PollForKBhit(LPVOID lpParam);

	//Function to check whether the input string's first token
	//is 'quit'|'exit', if so return true else return false.
	BOOL			IsSessionEnd();

	//Set the session error value
	void			SetSessionErrorLevel(SESSIONRETCODE ssnRetCode);

	//Get the session error value
	WMICLIUINT		GetSessionErrorLevel();

	// This function check whether the /USER global switch
	// has been specified without /PASSWORD, if so prompts
	// for the password
	void			CheckForPassword();

	// Checks whether the given namespace is available or not.
	BOOL IsNSAvailable(const _bstr_t& bstrNS);

	// Checks whether the wmic.exe is being launched for the first time.
	BOOL IsFirstTime();

	// Register the aliases info / localized descriptions
	HRESULT RegisterMofs();

	// Compile the MOF file.
	HRESULT CompileMOFFile(IMofCompiler* pIMofComp, 
						   const _bstr_t& bstrFile,
						   WMICLIINT& nErr);

	// Set break event falg
	void SetBreakEvent(BOOL bFlag);

	// Get break event flag
	BOOL GetBreakEvent();

	// Set Accept Command flag
	void SetAcceptCommand(BOOL bFlag);

	// Get Accept Command flag
	BOOL GetAcceptCommand();

	// Set displayresults flag status
	void SetDisplayResultsFlag(BOOL bFlag);

	// Get DisplayResults flag status
	BOOL GetDisplayResultsFlag();

	// Set Windows sockect interface flag
	void SetInitWinSock(BOOL bFlag);

	// Get Windows sockect interface flag
	BOOL GetInitWinSock();

	// Buffer data to send clipboard. 
	void AddToClipBoardBuffer(LPCWSTR pszOutput);

	// Get Buffered output in clip board buffer.
	CHString& GetClipBoardBuffer();

	// Clear Clip Board Buffer.
	void EmptyClipBoardBuffer();

	// Check if the file is xml or batch file. If it is batch file
	// then parse it, get commands and write the commands into
	// batch file and redirect the stdin to that file.
	BOOL ReadXMLOrBatchFile(HANDLE hInFile);

	// Frames the XML string for context info
	void FrameContextInfoFragment(_bstr_t& bstrContext);
	
	// Frames the XML header info
	void FrameNodeListFragment(_bstr_t& bstrNodeList);

	// Frames the XML string for Request info
	void FrameXMLHeader(_bstr_t& bstrHeader, WMICLIINT nIter);

	// Frames the XML string for NodeList info
	void FrameRequestNode(_bstr_t& bstrRequest);

	// Frames the XML string for commandline info
	void FrameCommandLineComponents(_bstr_t& bstrCommandComponent);

	// Frames the XML string for formats info
	void FrameFormats(_bstr_t& bstrFormats);

	// Frames the XML string for properties info
	void FramePropertiesInfo(_bstr_t& bstrProperties);

	// Gets the xslfile name corrsponding to the keyword passed
	// from the BSTRMAP  
	BOOL GetFileFromKey(_bstr_t bstrkeyName, _bstr_t& bstrFileName);
	
	// Frames the BSTR Map contains the key words and
	// corresponding files from the XSL mapping file
	void GetFileNameMap();

	// Get the XSL file names for keywords
	void GetXSLMappings(_TCHAR *pszFilePath);

	// This function returns a reference to the token vector
	CHARVECTOR& GetTokenVector();

	inline BOOL GetCtrlHandlerError() { return m_bCtrlHandlerError; };

	inline void SetCtrlHandlerError(BOOL bFlag) { m_bCtrlHandlerError = bFlag; };

	// sets/resets screen buffer
	BOOL ScreenBuffer ( BOOL bSet = TRUE );

	// return mappings
	const BSTRMAP* GetMappingsMap () const
	{
		return &m_bmKeyWordtoFileName;
	};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adapthrd.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPTHRD.H

Abstract:

History:

--*/


#ifndef __ADAPTHRD_H__
#define __ADAPTHRD_H__

#include <wbemcomn.h>
#include <sync.h>
#include <execq.h>
#include <wbemint.h>
#include "adapelem.h"

///////////////////////////////////////////////////////////////////////////
//
//	Forward Declarations
//
///////////////////////////////////////////////////////////////////////////

class CAdapPerfLib;

///////////////////////////////////////////////////////////////////////////
//
//	CAdapThreadRequest
//
///////////////////////////////////////////////////////////////////////////

class CAdapThreadRequest : public CAdapElement
{
protected:
	HANDLE	m_hWhenDone;
	HRESULT	m_hrReturn;

public:
    CAdapThreadRequest();
    virtual ~CAdapThreadRequest();

    void SetWhenDoneHandle(HANDLE h) 
	{
		m_hWhenDone = h;
	}
    
	HANDLE GetWhenDoneHandle()
	{
		return m_hWhenDone;
	}

	HRESULT GetHRESULT( void )
	{
		return m_hrReturn;
	}

    virtual HRESULT Execute( CAdapPerfLib* pPerfLib ) = 0;
	virtual HRESULT EventLogError();
};

///////////////////////////////////////////////////////////////////////////
//
//	CAdapThread
//
///////////////////////////////////////////////////////////////////////////

class CAdapThread
{
private:

	CAdapPerfLib*	m_pPerfLib;		// The perflib being processed
	HANDLE			m_hThreadReady;	// The event to signal that the thread is ready

	HANDLE		m_hThread;			// The thread handle	
	DWORD		m_dwThreadId;		// The thread ID
	HANDLE		m_hEventQuit;		// Thread termination event

	CFlexArray	m_RequestQueue;		// The queue
	HANDLE		m_hSemReqPending;	// The queue counter

	BOOL		m_fOk;				// Initialization flag
	CCritSec	m_cs;

	static unsigned __stdcall ThreadProc( void * pVoid );

	unsigned RealEntry( void );

protected:

	BOOL Init( void );
	virtual BOOL Clear( BOOL fClose = TRUE );

	HRESULT Begin( void );
	HRESULT Reset( void );

public:
	CAdapThread( CAdapPerfLib* pPerfLib );
	virtual ~CAdapThread();


	// Assigns us work to do.
	HRESULT Enqueue( CAdapThreadRequest* pRequest );

	// Gently closes the thread
	HRESULT Shutdown( DWORD dwTimeout = 60000 );

	BOOL IsOk( void )
	{
		return m_fOk;
	}
};

#include "adapperf.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adapreg.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPREG.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wtypes.h>
#include <oleauto.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <process.h>
#include <arrtempl.h>
#include <cominit.h>
#include <winmgmtr.h>
#include <wbemcli.h>
#include <throttle.h>
#include <psapi.h>
#include "adapreg.h"
#include "perflibschema.h"
#include "WMIBroker.h"
#include "adaputil.h"
#include "adapperf.h"
#include "ntreg.h"
#include "winuser.h"

// globals

DWORD CAdapPerfLib::s_MaxSizeCollect = 64*1024*1024;


// Performance library processing list
// ===================================

CPerfLibList    g_PerfLibList;
HANDLE g_hAbort = NULL;


/////////////////////////////////////////////////////////////////////////////
//
//    returns the PID (the first found if many are there) if success
//    returns ZERO if fails 
//
/////////////////////////////////////////////////////////////////////////////


#define MAX_ITERATION 8
#define MAX_MODULE  (1024)

DWORD GetExecPid()
{
    DWORD ThisProc = 0;
    LONG lRet = 0;
    HKEY hKey;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        L"Software\\Microsoft\\WBEM\\CIMOM",
                        NULL,
                        KEY_READ,
                        &hKey);
    if (ERROR_SUCCESS == lRet)
    {    
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);
        RegQueryValueEx(hKey,
                      L"ProcessID",
                      NULL,
                      &dwType,
                      (BYTE*)&ThisProc,
                      &dwSize);
        RegCloseKey(hKey);
    }

    return ThisProc;

}


void DoResyncPerf( BOOL bDelta, BOOL bThrottle )
{
    DEBUGTRACE((LOG_WINMGMT,"ADAP Resync has started\n"));

    g_hAbort = CreateEventW( NULL, TRUE, FALSE, L"ADAP_ABORT");
    CCloseMe cmAbort( g_hAbort );

    if ( NULL != g_hAbort )
    {
        HRESULT hr = WBEM_S_NO_ERROR;

        CAdapRegPerf    regPerf(!bDelta);

        // Process each perflib that is registered on the system
        // =====================================================

        hr = regPerf.Initialize( bDelta, bThrottle );

        if ( SUCCEEDED( hr ) )
        {
            hr = regPerf.Dredge( bDelta, bThrottle );
        }

        if ( FAILED( hr ) )
        {
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_PROCESSING_FAILURE, CHex( hr ) );
        }
    }   

    DEBUGTRACE((LOG_WINMGMT,"ADAP Resync has completed\n"));

    return;
}

void DoClearADAP()
{
    DEBUGTRACE((LOG_WINMGMT,"ADAP registry reset has started\n"));

    CAdapRegPerf  regPerf(FALSE);

    regPerf.Clean();

    DEBUGTRACE((LOG_WINMGMT,"ADAP registry reset has completed\n"));
    
    return;
}


HRESULT DoReverseAdapterMaintenance( BOOL bThrottle );
/*
{
    ERRORTRACE((LOG_WMIADAP,"DoReverseAdapterDredge called"));
    return WBEM_NO_ERROR;
};
*/

/*
->Revision: 0x1
->Sbz1    : 0x0
->Control : 0x8004
            SE_DACL_PRESENT
            SE_SELF_RELATIVE
->Owner   : S-1-5-32-544
->Group   : S-1-5-18
->Dacl    :
->Dacl    : ->AclRevision: 0x2
->Dacl    : ->Sbz1       : 0x0
->Dacl    : ->AclSize    : 0x44
->Dacl    : ->AceCount   : 0x2
->Dacl    : ->Sbz2       : 0x0
->Dacl    : ->Ace[0]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[0]: ->AceFlags: 0x0
->Dacl    : ->Ace[0]: ->AceSize: 0x14
->Dacl    : ->Ace[0]: ->Mask : 0x001f0003
->Dacl    : ->Ace[0]: ->SID: S-1-5-18

->Dacl    : ->Ace[1]: ->AceType: ACCESS_ALLOWED_ACE_TYPE
->Dacl    : ->Ace[1]: ->AceFlags: 0x0
->Dacl    : ->Ace[1]: ->AceSize: 0x18
->Dacl    : ->Ace[1]: ->Mask : 0x001f0003
->Dacl    : ->Ace[1]: ->SID: S-1-5-32-544
*/

DWORD g_PreCompSD[] = {
 0x80040001 , 0x00000058 , 0x00000068 , 0x00000000,
 0x00000014 , 0x00440002 , 0x00000002 , 0x00140000,
 0x001f0003 , 0x00000101 , 0x05000000 , 0x00000012,
 0x00180000 , 0x001f0003 , 0x00000201 , 0x05000000,
 0x00000020 , 0x00000220 , 0x00b70000 , 0x00000000,
 0x01190000 , 0x00010002 , 0x00000201 , 0x05000000,
 0x00000020 , 0x00000220 , 0x00000101 , 0x05000000,
 0x00000012 , 0x00000069 , 0x00000000 , 0x00000000
};

//
//  Build a SD with      owner == ProcessSid
//                  group == ProcessSid
//                  DACL
//                  ACE[0]  MUTEX_ALL_ACCESS System
//                  ACE[1]  MUTEX_ALL_ACCESS Administators
///////////////////////////////////////////////////////////////////

VOID * CreateSD(/* in */ DWORD AccessMask,
               /* out */ DWORD &SizeSd )
{
    SizeSd = 0;
    
    HANDLE hToken;   
    if (FALSE == OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&hToken)) return NULL;
    
    OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> CloseToken(hToken);
     
    DWORD dwSize = sizeof(TOKEN_USER)+sizeof(SID)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD));
    
    TOKEN_USER * pToken_User = (TOKEN_USER *)LocalAlloc(LPTR,dwSize);
    if (NULL == pToken_User) return NULL;
    OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> FreeMe1(pToken_User);
    
    if (FALSE == GetTokenInformation(hToken,TokenUser,pToken_User,dwSize,&dwSize)) return NULL;

    SID_IDENTIFIER_AUTHORITY ntifs = SECURITY_NT_AUTHORITY;

    PSID SystemSid = NULL;

    if (FALSE == AllocateAndInitializeSid( &ntifs ,
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,0,0,0,0,0,0,0,
                                    &SystemSid)) return NULL;
    OnDelete<PSID,PVOID(*)(PSID),FreeSid> FreeSid1(SystemSid);
    
    PSID AdministratorsSid = NULL;
    if (FALSE == AllocateAndInitializeSid(&ntifs,
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID,
                                    DOMAIN_ALIAS_RID_ADMINS,0,0,0,0,0,0,
                                    &AdministratorsSid)) return NULL;
    OnDelete<PSID,PVOID(*)(PSID),FreeSid> FreeSid2(AdministratorsSid);
    

    PSID pSIDUser = pToken_User->User.Sid;
    dwSize = GetLengthSid(pSIDUser);
    DWORD dwSids = 2; // System and Administrators
    DWORD ACLLength = (ULONG) sizeof(ACL) +
                      (dwSids * ((ULONG) sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG)))  + GetLengthSid(SystemSid) + GetLengthSid(AdministratorsSid);

    DWORD dwSizeSD = sizeof(SECURITY_DESCRIPTOR_RELATIVE) + dwSize + dwSize + ACLLength;
    
    SECURITY_DESCRIPTOR_RELATIVE * pLocalSD = (SECURITY_DESCRIPTOR_RELATIVE *)LocalAlloc(LPTR,dwSizeSD); 
    if (NULL == pLocalSD) return NULL;
    OnDeleteIf<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> FreeMeSD(pLocalSD);
    
    memset(pLocalSD,0,sizeof(SECURITY_DESCRIPTOR_RELATIVE));
    pLocalSD->Revision = SECURITY_DESCRIPTOR_REVISION;
    pLocalSD->Control = SE_DACL_PRESENT|SE_SELF_RELATIVE;
    
    //SetSecurityDescriptorOwner(pLocalSD,pSIDUser,FALSE);
    memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE),pSIDUser,dwSize);
    pLocalSD->Owner = (DWORD)sizeof(SECURITY_DESCRIPTOR_RELATIVE);
    
    //SetSecurityDescriptorGroup(pLocalSD,pSIDUser,FALSE);
    memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize,pSIDUser,dwSize);
    pLocalSD->Group = (DWORD)(sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize);


    PACL pDacl = (PACL)LocalAlloc(LPTR,ACLLength);
    if (NULL == pDacl) return NULL;
    OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> FreeMe3(pDacl);
    

    if (FALSE == InitializeAcl( pDacl,ACLLength,ACL_REVISION)) return NULL;

    if (FALSE == AddAccessAllowedAceEx (pDacl,ACL_REVISION,0,AccessMask,SystemSid)) return NULL;

    if (FALSE == AddAccessAllowedAceEx (pDacl,ACL_REVISION,0,AccessMask,AdministratorsSid)) return NULL;
            
    //bRet = SetSecurityDescriptorDacl(pLocalSD,TRUE,pDacl,FALSE);
    memcpy((BYTE*)pLocalSD+sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize+dwSize,pDacl,ACLLength);                    
    pLocalSD->Dacl = (DWORD)(sizeof(SECURITY_DESCRIPTOR_RELATIVE)+dwSize+dwSize);

    if (false == RtlValidRelativeSecurityDescriptor(pLocalSD,
                                       dwSizeSD,
                                       OWNER_SECURITY_INFORMATION|
                                       GROUP_SECURITY_INFORMATION|
                                       DACL_SECURITY_INFORMATION)) return NULL;

    FreeMeSD.dismiss();
    SizeSd = dwSizeSD;
    return pLocalSD;
};


///////////////////////////////////////////////////////////////////////////////
//
//    Entry Point
//    ===========
//
///////////////////////////////////////////////////////////////////////////////

int WINAPI WinMain( 
  HINSTANCE hInstance,      // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR szCmdLine,          // command line
  int nCmdShow              // show state
)
{

    try
    {
        if (CStaticCritSec::anyFailure()) return 0;
        
        // Ensure that we are NT5 or better
        // ================================
        OSVERSIONINFO   OSVer;

        OSVer.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

        if ( GetVersionEx( &OSVer ) )
        {
            if ( ! ( ( VER_PLATFORM_WIN32_NT == OSVer.dwPlatformId ) && ( 5 <= OSVer.dwMajorVersion ) ) )
                return 0;
        }
        else
        {
            return 0;
        }

        // To avoid messy dialog boxes...
        // ==============================

        SetErrorMode( SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );

        // Initialize COM.
        RETURN_ON_ERR(CoInitializeEx(NULL,COINIT_MULTITHREADED));
        OnDelete0<void(*)(void),CoUninitialize> CoUninit;    
                    
        RETURN_ON_ERR(CoInitializeSecurity( NULL, -1, NULL, NULL, 
                                        RPC_C_AUTHN_LEVEL_DEFAULT, 
                                        RPC_C_IMP_LEVEL_IDENTIFY, 
                                        NULL, 
                                        EOAC_NONE|EOAC_SECURE_REFS , NULL ));

        // get some value from registry

        CNTRegistry reg;
        if ( CNTRegistry::no_error == reg.Open( HKEY_LOCAL_MACHINE, WBEM_REG_WINMGMT) )
        {
            reg.GetDWORD( ADAP_KEY_MAX_COLLECT, &CAdapPerfLib::s_MaxSizeCollect);            
        }

        // Get the Winmgmt service PID
        // ===========================
        DWORD dwPID = GetExecPid();

        // The semaphore is used so that no more that two copies are running at any time.  
        // ==============================================================================

        WCHAR   wszObjName[256];
        HANDLE hSemaphore;

        DWORD SizeSd;
        void * pSecDesSem = CreateSD(SEMAPHORE_ALL_ACCESS,SizeSd);
        OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> FreeMeSem(pSecDesSem);
        SECURITY_ATTRIBUTES sa;            
        sa.nLength = (pSecDesSem) ? SizeSd : sizeof(g_PreCompSD);
        sa.lpSecurityDescriptor = (pSecDesSem) ? pSecDesSem : g_PreCompSD;
        sa.bInheritHandle = FALSE; 

        StringCchPrintfW(wszObjName, 256, L"Global\\WMI_SysEvent_Semaphore_%d", dwPID);

        hSemaphore = CreateSemaphoreW(&sa, 2, 2, wszObjName);
        if(hSemaphore == NULL)
        {
            DEBUGTRACE((LOG_WMIADAP,"WMI_SysEvent_Semaphore semaphore creation failed %d\n",GetLastError()));
            return 0;
        }

        CCloseMe cm1(hSemaphore);

        DWORD dwRet = WaitForSingleObject(hSemaphore, 0);
        if(dwRet != WAIT_OBJECT_0)
            return 0;

        // The mutex makes sure that multiple copies are sequential.
        // =========================================================

        void * pSecDesMut = CreateSD(MUTEX_ALL_ACCESS,SizeSd);
        OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> FreeMeMut(pSecDesMut);

        sa.nLength = (pSecDesMut) ? SizeSd : sizeof(g_PreCompSD);
        sa.lpSecurityDescriptor = (pSecDesMut) ? pSecDesSem : g_PreCompSD;
        sa.bInheritHandle = FALSE; 

        HANDLE hMutex;
        hMutex = CreateMutexW( &sa, FALSE, L"Global\\ADAP_WMI_ENTRY" );
        if(hMutex == NULL)
        {
            DEBUGTRACE((LOG_WMIADAP,"ADAP_WMI_ENTRY mutex creation failed %d\n",GetLastError()));        
            return 0;
        }

        CCloseMe cm2(hMutex);

        switch ( WaitForSingleObject( hMutex, 400000) )
        {
        case WAIT_ABANDONED:
        case WAIT_OBJECT_0:
            {
                BOOL bThrottle = FALSE;
                BOOL bFull     = FALSE;
                BOOL bDelta    = FALSE;
                BOOL bReverse  = FALSE;
                BOOL bClear    = FALSE;               
                
                if (szCmdLine)
                {
                    while (*szCmdLine)
                    {
                        while(*szCmdLine && isspace((UCHAR)*szCmdLine)){
                            szCmdLine++;
                        };        
                        if (*szCmdLine == '-' || *szCmdLine == '/')
                        {
                            szCmdLine++;
                            if (toupper((UCHAR)*szCmdLine) == 'T'){
                                bThrottle = TRUE;
                            } else if (toupper((UCHAR)*szCmdLine) == 'R') {
                                bReverse = TRUE;
                            } else if (toupper((UCHAR)*szCmdLine) == 'F') {
                                bFull = TRUE;
                               } else if (toupper((UCHAR)*szCmdLine) == 'D') {
                                bDelta = TRUE;
                            } else if (toupper((UCHAR)*szCmdLine) == 'C') {
                                bClear = TRUE;
                            }
                        }
                        // move to the next white space
                        while(*szCmdLine && !isspace(*szCmdLine)){
                            szCmdLine++;
                        }

                    }
                }
 
                if (bClear) // ClearADAP and/or ReverseAdap
                {
                    DoClearADAP();
                    if (bReverse)
                        DoReverseAdapterMaintenance( bThrottle );
                }
                else 
                {
                    if (!bFull && !bDelta && !bReverse)
                    {
                        // no options, use Delta NO-THROTTLE
                        DoResyncPerf(TRUE,FALSE);
                    } 
                    else 
                    {
                        if (bFull) {
                            DoResyncPerf(FALSE,bThrottle);
                        } 
                        if (bDelta && !bFull) {
                            DoResyncPerf(TRUE,bThrottle);
                        }
                        if (bReverse)
                            DoReverseAdapterMaintenance( bThrottle );
                    }
                }

                ReleaseMutex( hMutex );

            }break;
        }

        long l;
        ReleaseSemaphore(hSemaphore, 1, &l);
    }
    catch(...)
    {
        // <Gasp> We have been betrayed... try to write something to the error log
        // =======================================================================

        CriticalFailADAPTrace( "An unhandled exception has been thrown in the main thread." );
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CPerfLibList
//
////////////////////////////////////////////////////////////////////////////////

HRESULT CPerfLibList::AddPerfLib( WCHAR* wszPerfLib )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInCritSec ics( &m_csPerfLibList );

    try
    {
            // Compute the size of the new buffer
            // ==================================

            DWORD   dwListSize = 0;
            
            if ( NULL != m_wszPerfLibList )
            {
                dwListSize += wcslen( m_wszPerfLibList );
                dwListSize += wcslen( ADAP_EVENT_MESSAGE_DELIM );
            }
            
            if ( NULL != wszPerfLib )
            {
                dwListSize += wcslen( wszPerfLib );
            }
            
            // Create the new buffer, and initialize the content
            // =================================================

            size_t cchSizeTmp = dwListSize + 1;
            WCHAR*  wszNew = new WCHAR[cchSizeTmp];
            if (NULL == wszNew) return WBEM_E_OUT_OF_MEMORY;

            // Copy the old buffer if required
            // ===============================

            if ( NULL != m_wszPerfLibList )
            {
                StringCchPrintfW( wszNew, cchSizeTmp, L"%s%s%s", m_wszPerfLibList, ADAP_EVENT_MESSAGE_DELIM, wszPerfLib );
                delete [] m_wszPerfLibList;
            }
            else
            {
                StringCchCopyW(wszNew, cchSizeTmp, wszPerfLib);
            }

            // And assign it to the static member
            // ==================================

            m_wszPerfLibList = wszNew;      
    }
    catch(...)
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CPerfLibList::HandleFailure()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInCritSec ics( &m_csPerfLibList );

    try
    {
        char    szMessage[ADAP_EVENT_MESSAGE_LENGTH];
     
        DWORD dwMessageLen = strlen( ADAP_EVENT_MESSAGE_PREFIX );

        if ( NULL != m_wszPerfLibList )
        {
            dwMessageLen += wcslen( m_wszPerfLibList );
        }

        StringCchPrintfA(szMessage,ADAP_EVENT_MESSAGE_LENGTH,
                                   "%s%S\n", ADAP_EVENT_MESSAGE_PREFIX, (NULL != m_wszPerfLibList) ? m_wszPerfLibList : L"<NULL>" );

        CriticalFailADAPTrace( szMessage );
    }
    catch(...)
    {        
        hr = WBEM_E_FAILED;
    }

    return hr;
}
////////////////////////////////////////////////////////////////////////////////
//
//  Static Members
//
////////////////////////////////////////////////////////////////////////////////


LONG CAdapRegPerf::AdapUnhandledExceptionFilter( LPEXCEPTION_POINTERS lpexpExceptionInfo )
{
    g_PerfLibList.HandleFailure();  
    return EXCEPTION_CONTINUE_SEARCH;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CAdapRegPerf
//
////////////////////////////////////////////////////////////////////////////////

CAdapRegPerf::CAdapRegPerf(BOOL bFull)
: m_pLocaleCache( NULL ),
  m_fQuit( FALSE ),
  m_dwPID( 0 ),
  m_pADAPStatus( NULL ),
  m_pRootDefault( NULL ),
  m_hRegChangeEvent( NULL ),
  m_hPerflibKey( NULL ),
  m_pKnownSvcs(NULL),
  m_bFull(bFull)
{
    for ( DWORD dwType = 0; dwType < WMI_ADAP_NUM_TYPES; dwType++ )
        m_apMasterClassList[dwType] = NULL;
}


CAdapRegPerf::~CAdapRegPerf()
{
    // Status: COMPLETE
    // ================
    SetADAPStatus( eADAPStatusFinished);

    //
    // Add TimeStamp to registry if FULL
    //
    if (m_bFull)
    {
        FILETIME FileTime;
        GetSystemTimeAsFileTime(&FileTime);
        LONG lRet;
        HKEY hKey;

        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            L"Software\\Microsoft\\WBEM\\CIMOM",
                            NULL,
                            KEY_WRITE,
                            &hKey);
        if (ERROR_SUCCESS == lRet)
        {    
            RegSetValueEx(hKey,
                          ADAP_TIMESTAMP_FULL,
                          NULL,
                          REG_BINARY,
                          (BYTE*)&FileTime,
                          sizeof(FILETIME));
            RegCloseKey(hKey);
        }
    }

    if (m_pKnownSvcs)
    {
        m_pKnownSvcs->Save();
        m_pKnownSvcs->Release();
    }

    // Cleanup
    // =======
    for ( DWORD dwType = 0; dwType < WMI_ADAP_NUM_TYPES; dwType++ )
    {
        if ( NULL != m_apMasterClassList[dwType] )
        {
            m_apMasterClassList[dwType]->Release();
        }
    }

    if ( NULL != m_pLocaleCache )
    {
        m_pLocaleCache->Release();
    }

    if ( NULL != m_pRootDefault )
    {
        m_pRootDefault->Release();
    }

    if ( NULL != m_pADAPStatus )
    {
        m_pADAPStatus->Release();
    }

    if ( NULL != m_hPerflibKey ) 
    {
        RegCloseKey( m_hPerflibKey );
    }

    if ( NULL != m_hRegChangeEvent )
    {
        CloseHandle( m_hRegChangeEvent );
    }

    SetEvent( m_hTerminationEvent );

}

HRESULT CAdapRegPerf::Initialize(BOOL bDelta, BOOL bThrottle)
///////////////////////////////////////////////////////////////////////////////
//
//    Initialize is responsible for setting up the dredging environment.  The 
//    unhandled exception filter is set to handle any exceptions throw and not 
//    handled by perforance libraries.  The termination event is a signal used
//    to identify when the process is being abnormally terminated.  The 
//    GoGershwin thread is suitably named since it is something to watch over
//    over the main process.  The locale cache is a cache of all locales 
//    available in the performance domain (enumeration of the names' database
//    subkeys).  The master class lists for both the cooked and the raw classes
//    represent the state of the performance objects in WMI.
//
//    Parameters:
//        none
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    // Initialize the root\default pointer. This will be used to track our status
    // ==========================================================================
    GetADAPStatusObject();

    // Set the filter for handling unhandled exceptions thrown in threads generated by the perflibs
    // ============================================================================================
    SetUnhandledExceptionFilter( CAdapRegPerf::AdapUnhandledExceptionFilter );

    // ADAP termination event
    // ======================
    m_hTerminationEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( NULL == m_hTerminationEvent )
    {
        hr = WBEM_E_FAILED;
    }

    // Open the registry key to be monitored
    // =====================================
    if ( SUCCEEDED( hr ) )
    {
        if ( ERROR_SUCCESS != RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"), 0, KEY_NOTIFY, &m_hPerflibKey ) )
        {
            hr = WBEM_E_FAILED;
        }
    }

    // Create the registry change event
    // ================================
    if ( SUCCEEDED( hr ) )
    {
        m_hRegChangeEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        if ( NULL == m_hRegChangeEvent )
        {
            hr = WBEM_E_FAILED;
        }
    }

    // Create the names' database change notification
    // ==============================================
    // Note that we are only looking for subkeys being added or deleted.  We do
    // not want to monitor the registry values since the status and signature 
    // values may be changing throughout the course of the dredge, and we do 
    // not want to cause a re-cache unless a performance library is added 
    // (i.e. a performance subkey is added

    if ( SUCCEEDED( hr ) )
    {
        if ( ERROR_SUCCESS != RegNotifyChangeKeyValue( m_hPerflibKey, TRUE, REG_NOTIFY_CHANGE_LAST_SET, m_hRegChangeEvent, TRUE ) )
        {
            hr = WBEM_E_FAILED;
        }
    }

    // Get the WinMgmt Service PID
    // ===========================
    if ( SUCCEEDED( hr ) )
    {
        m_dwPID = GetExecPid();
    }
    // Create the "Someone to watch over me" thread 
    // ============================================
    if ( SUCCEEDED( hr ) )
    {
        UINT    nThreadID = 0;

        m_hSyncThread = ( HANDLE ) _beginthreadex( NULL, 0, CAdapRegPerf::GoGershwin, (void*) this, 0, &nThreadID );

        DEBUGTRACE ( ( LOG_WMIADAP, "The Monitor thread ID is 0x%x\n", nThreadID ) );
        
        if ( (HANDLE)-1 == m_hSyncThread )
        {
            hr = WBEM_E_FAILED;
        }
    }

    // Set up the locale cache
    // =======================
    if ( SUCCEEDED( hr ) )
    {
        m_pLocaleCache = new CLocaleCache( );

        if ( NULL == m_pLocaleCache )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            hr = m_pLocaleCache->Initialize();
        }
    }

    //
    //
    m_pKnownSvcs = new CKnownSvcs(KNOWN_SERVICES);
    if (m_pKnownSvcs)
        m_pKnownSvcs->Load();

    // Set up the master class lists for the raw classes
    // =================================================
    if ( SUCCEEDED( hr ) )
    {
        m_apMasterClassList[WMI_ADAP_RAW_CLASS] = new CMasterClassList( m_pLocaleCache, m_pKnownSvcs );

        if ( NULL != m_apMasterClassList[WMI_ADAP_RAW_CLASS] )
        {
            hr = m_apMasterClassList[WMI_ADAP_RAW_CLASS]->BuildList( ADAP_PERF_RAW_BASE_CLASS, bDelta, bThrottle );
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    // Set up the master class lists for the cooked classes
    // ====================================================
    if ( SUCCEEDED( hr ) )
    {
        m_apMasterClassList[WMI_ADAP_COOKED_CLASS] = new CMasterClassList( m_pLocaleCache, m_pKnownSvcs );

        if ( NULL != m_apMasterClassList[WMI_ADAP_COOKED_CLASS] )
        {
            m_apMasterClassList[WMI_ADAP_COOKED_CLASS]->BuildList( ADAP_PERF_COOKED_BASE_CLASS, bDelta, bThrottle );
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

#ifdef _DUMP_LIST
    m_apMasterClassList[WMI_ADAP_RAW_CLASS]->Dump();
    m_apMasterClassList[WMI_ADAP_COOKED_CLASS]->Dump();
#endif
    
    return hr;
}

HRESULT CAdapRegPerf::Dredge( BOOL bDelta, BOOL bThrottle )
///////////////////////////////////////////////////////////////////////////////
//
//    This is the entry point method which dredges the registry for performance 
//    counters and registers the classes in WMI.  This method enumerates all of 
//    the service keys looking for 'Performance' subkeys which indicate 
//    performance libraries.  If a library is discovered, then it is sent to
//    the ProcessLibrary method for, you guessed it, processing.
//
//    Parameters:
//        none
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    WString wstrServiceKey, 
            wstrPerformanceKey;

    if ( SUCCEEDED( hr ) )
    {
        // Status: PROCESSING
        // ==================
        SetADAPStatus( eADAPStatusProcessLibs);

        // Open the services key
        // =====================
        long    lError = Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" );

        if ( CNTRegistry::no_error == lError )
        {
            // Iterate through the services list
            // =================================
            DWORD   dwIndex = 0;
            DWORD   dwBuffSize = 0;
            wmilib::auto_buffer<WCHAR> pwcsServiceName;

            while ( ( CNTRegistry::no_error == lError ) && ( !m_fQuit ) )
            {
                // Reset the processing status
                // ===========================
                hr = WBEM_NO_ERROR;

                if ( WAIT_OBJECT_0 == WaitForSingleObject( m_hRegChangeEvent, 0 ) )
                {
                    m_pLocaleCache->Reset();
                    dwIndex = 0;

                    // Reset the event and reset the change notification
                    ResetEvent( m_hRegChangeEvent );
                    RegNotifyChangeKeyValue( m_hPerflibKey, TRUE, REG_NOTIFY_CHANGE_LAST_SET, m_hRegChangeEvent, TRUE );
                }

                // For each service name, we will check for a performance 
                // key and if it exists, we will process the library
                // ======================================================
                lError = Enum( dwIndex, pwcsServiceName , dwBuffSize );

                if (bThrottle)
                {
                    HRESULT hrThr = Throttle(THROTTLE_USER|THROTTLE_IO,
                                          ADAP_IDLE_USER,
                                          ADAP_IDLE_IO,
                                          ADAP_LOOP_SLEEP,
                                          ADAP_MAX_WAIT);
                    if (THROTTLE_FORCE_EXIT == hrThr)
                    {
                        //OutputDebugStringA("(ADAP) Unthrottle command received\n");
                        bThrottle = FALSE;
                        UNICODE_STRING BaseUnicodeCommandLine = NtCurrentPeb()->ProcessParameters->CommandLine;
                        WCHAR * pT = wcschr(BaseUnicodeCommandLine.Buffer,L't');
                        if (0 == pT)
                            pT = wcschr(BaseUnicodeCommandLine.Buffer,L'T');
                        if (pT)
                        {
                            *pT = L' ';
                            pT--;
                            *pT = L' ';                                       
                        }                        
                    }
                }

                if ( CNTRegistry::no_error == lError )
                {
                    try
                    {
                        // Create the perfomance key path
                        // ==============================
                        wstrServiceKey = L"SYSTEM\\CurrentControlSet\\Services\\";
                        wstrServiceKey += pwcsServiceName.get();

                        wstrPerformanceKey = wstrServiceKey;
                        wstrPerformanceKey += L"\\Performance";
                    }
                    catch( ... )
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }

                    if ( SUCCEEDED( hr ) )
                    {
                        CNTRegistry reg;

                        // Atempt to open the performance registry key for the service
                        // ===========================================================
                        long lPerfError = reg.Open( HKEY_LOCAL_MACHINE, wstrPerformanceKey );

                        if ( CNTRegistry::no_error == lPerfError )
                        {
                            // If we can open it, then we have found a perflib!  Process it 
                            // unless it is the reverse provider perflib
                            // =============================================================

                            if ( 0 != wbem_wcsicmp( pwcsServiceName.get(), WMI_ADAP_REVERSE_PERFLIB ) )
                            {
                                hr = ProcessLibrary( pwcsServiceName.get(), bDelta );
                            }
                        }
                        else if ( CNTRegistry::access_denied == lPerfError )
                        {
                            ServiceRec * pSvcRec = NULL;
                            if (0 == m_pKnownSvcs->Get(pwcsServiceName.get(),&pSvcRec))
                            {
                                if (!pSvcRec->IsELCalled())
                                {
                                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                                          WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                                          (LPCWSTR)wstrPerformanceKey, L"Access Denied" );
                                    pSvcRec->SetELCalled();
                                }
                            }
                        }
                        else
                        {
                            // Otherwise, it is not a perflib service
                            // ======================================
                        }
                    }   
                }   
                else if ( CNTRegistry::no_more_items != lError )
                {
                    if ( CNTRegistry::out_of_memory == lError )
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                    else
                    {
                        hr = WBEM_E_FAILED;
                    }
                }

                dwIndex++;
            }

        }
        else if ( CNTRegistry::access_denied == lError )
        {
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, L"SYSTEM\\CurrentControlSet\\Services\\", L"Access Denied" );
            hr = WBEM_E_FAILED;
        }
        else
        {
            hr = WBEM_E_FAILED;
        }

        // Now that we have a master class list that contains updated
        // data from all of the perflibs, commit any changes to WMI
        // ==========================================================
        if ( SUCCEEDED ( hr ) && ( !m_fQuit ) )
        {
            // Status: COMMIT
            // ==============
            SetADAPStatus( eADAPStatusCommit );

            for ( DWORD dwType = 0; dwType < WMI_ADAP_NUM_TYPES; dwType++ )
            {
                m_apMasterClassList[dwType]->Commit(bThrottle);
            }
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        DEBUGTRACE( ( LOG_WMIADAP, "CAdapRegPerf::Dredge() for %S succeeded.\n", (WCHAR *)wstrServiceKey ) );
    }
    else
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapRegPerf::Dredge() failed: %X.\n", hr ) );
    }

    return hr;
}


HRESULT CAdapRegPerf::Clean()
////////////////////////////////////////////////////////////////////////////////
//
//  This method enumerates all of the keys from the 
//  HLM\System\CurrentControlSet\Services and searches for a performance subkey.
//  If a performance subkey is discovered, then any information that was placed 
//  in the key by ADAP is deleted.
//
//  Parameters:
//      none
//
////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    WString wstrServiceKey,             // The path to the service key
            wstrPerformanceKey;         // The path to the performance subkey

    CNTRegistry regOuter;               // The registry object for the services enumeration

    // Open the services key
    // =====================
    long    lError = regOuter.Open( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services" );

    if ( CNTRegistry::no_error == lError )
    {
        // Iterate through the services list
        // =================================
        DWORD   dwIndex = 0;
        DWORD   dwBuffSize = 0;
        wmilib::auto_buffer<WCHAR>  pwcsServiceName;

        while ( CNTRegistry::no_error == lError ) 
        {
            // Reset the processing status
            // ===========================
            hr = WBEM_NO_ERROR;

            // For each service name, we will check for a performance 
            // key and if it exists, we will process the library
            // ======================================================

            lError = regOuter.Enum( dwIndex, pwcsServiceName , dwBuffSize );

            if ( CNTRegistry::no_error == lError )
            {
                try
                {
                    // Create the perfomance key path
                    // ==============================

                    wstrServiceKey = L"SYSTEM\\CurrentControlSet\\Services\\";
                    wstrServiceKey += pwcsServiceName.get();

                    wstrPerformanceKey = wstrServiceKey;
                    wstrPerformanceKey += L"\\Performance";
                }
                catch( ... )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

                if ( SUCCEEDED( hr ) )
                {
                    CNTRegistry regInner;       // The registry object for the performance subkey

                    // Atempt to open the performance registry key for the service
                    // ===========================================================
                    long lPerfError = regInner.Open( HKEY_LOCAL_MACHINE, wstrPerformanceKey );
    
                    if ( CNTRegistry::no_error == lPerfError )
                    {
                        // If we can open it, then we have found a perflib!  Clean it!
                        // =============================================================
                        regInner.DeleteValue( ADAP_PERFLIB_STATUS_KEY );
                        regInner.DeleteValue( ADAP_PERFLIB_SIGNATURE );
                        regInner.DeleteValue( ADAP_PERFLIB_SIZE );
                        regInner.DeleteValue( ADAP_PERFLIB_TIME );                        
                    }
                    else if ( CNTRegistry::access_denied == lPerfError )
                    {
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                                  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                                  (LPCWSTR)wstrPerformanceKey, L"Access Denied" );
                    }
                    else
                    {
                        // Otherwise, it is not a perflib service
                        // ======================================
                    }
                }   
            }   
            else if ( CNTRegistry::no_more_items != lError )
            {
                if ( CNTRegistry::out_of_memory == lError )
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                {
                    hr = WBEM_E_FAILED;
                }
            }

            dwIndex++;
        }

    }
    else if ( CNTRegistry::access_denied == lError )
    {
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, L"SYSTEM\\CurrentControlSet\\Services\\", L"Access Denied" );
        hr = WBEM_E_FAILED;
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    if ( SUCCEEDED( hr ) )
    {
        DEBUGTRACE( ( LOG_WMIADAP, "CAdapRegPerf::Clean() succeeded.\n" ) );
    }
    else
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapRegPerf::Clean() failed: %X.\n", hr ) );
    }

    return hr;
}

HRESULT CAdapRegPerf::ProcessLibrary( WCHAR* pwcsServiceName, BOOL bDelta )
///////////////////////////////////////////////////////////////////////////////
//
//    Once a performance library has been discovered, then it's schema must be 
//    retrieved and the performance library's class list compared to what is 
//    already in the WMI repository.  The comparison is achieved in the "Merge"
//    method of the master class list which extracts any classes from the perf 
//    lib's class list that are not already in the master class list.  The 
//    comparison occurs for both the raw and the cooked classes.
//
//    Parameters:
//        pwcsServiceName    - The name of the service to be processed
//
///////////////////////////////////////////////////////////////////////////////
{

    HRESULT hr = WBEM_NO_ERROR;

    try
    {
        // Add the name of the performance library to the perflib list
        // ===========================================================
        // The list is used for book keeping purposses to track processing
        // in the event of a perflib failure

        g_PerfLibList.AddPerfLib( pwcsServiceName );        

        // Construct and initialize the schema for the perflib
        // ===================================================
        DWORD LoadStatus = EX_STATUS_UNLOADED;
        CPerfLibSchema Schema( pwcsServiceName, m_pLocaleCache );
        hr = Schema.Initialize( bDelta, &LoadStatus);
        
        DEBUGTRACE(( LOG_WMIADAP,"CPerfLibSchema::Initialize for %S hr %08x\n",pwcsServiceName,hr));

        if ( !bDelta || ( bDelta && ( hr != WBEM_S_ALREADY_EXISTS ) ) )
        {
            // Update raw and cooked classes
            // =============================
            for ( DWORD dwType = 0; ( dwType < WMI_ADAP_NUM_TYPES ) && SUCCEEDED( hr ); dwType++ )
            {
                // Get the class list for classes from the perflib's schema
                // ========================================================
                CClassList* pClassList = NULL;

                hr = Schema.GetClassList( dwType, &pClassList );
                CAdapReleaseMe  rmClassList( pClassList );

                
                DEBUGTRACE(( LOG_WMIADAP,"GetClassList for %S hr %08x\n",pwcsServiceName,hr));
                
                if ( SUCCEEDED( hr ) )
                {
                    // Merge the raw classes obtained from the perflib into the master class list
                    // ==========================================================================
                    hr = m_apMasterClassList[dwType]->Merge( pClassList, bDelta );

                    DEBUGTRACE(( LOG_WMIADAP,"m_apMasterClassList[%d]->Merge for %S hr %08x\n",dwType,pwcsServiceName,hr));
                }

                //if (bDelta && FAILED(hr)){
                //    // the class was not in the repository if we are here
                //    LoadStatus = EX_STATUS_UNLOADED;
                //}
            }
        };

        if (FAILED(hr) && (LoadStatus != EX_STATUS_LOADABLE)) 
        {
            for ( DWORD dwType = 0; ( dwType < WMI_ADAP_NUM_TYPES ) ; dwType++ )
            {
                DEBUGTRACE((LOG_WMIADAP,"ProcessLibrary ForceStatus for %S hr = %08x\n",pwcsServiceName,hr));

                DWORD NewStatus = ADAP_OBJECT_IS_DELETED;
                
                if (LoadStatus == EX_STATUS_UNLOADED)
                {
                    NewStatus |= ADAP_OBJECT_IS_TO_BE_CLEARED;
                }                

                m_apMasterClassList[dwType]->ForceStatus(pwcsServiceName,TRUE,NewStatus);
            }
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

unsigned int CAdapRegPerf::GoGershwin( void* pParam )
///////////////////////////////////////////////////////////////////////////////
//
//    The monitoring thread entry point
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    try 
    {
        CAdapRegPerf*   pThis = (CAdapRegPerf*)pParam;

        HANDLE          ahHandles[2];

        // If we don't have an initialized PID, then find one from WMI
        // ===========================================================

        if ( 0 == pThis->m_dwPID )
        {
            pThis->m_dwPID = GetExecPid();
        }
        
        // Get the process handle and wait for a signal
        // ============================================

        if ( SUCCEEDED( hr ) && ( 0 != pThis->m_dwPID ) )
        {
            ahHandles[0] = OpenProcess( SYNCHRONIZE, FALSE, pThis->m_dwPID );
            CCloseMe    cmProcess( ahHandles[0] );

            ahHandles[1] = pThis->m_hTerminationEvent;

            DWORD dwRet = WaitForMultipleObjects( 2, ahHandles, FALSE, INFINITE );

            switch ( dwRet )
            {
            case WAIT_FAILED:               // Something is wierd
            case WAIT_OBJECT_0:             // The service process
                {
                    pThis->m_fQuit = TRUE;  // Set the termination flag
                } break;
            case ( WAIT_OBJECT_0 + 1 ):     // The completion event
                {
                    // continue
                }break;
            }
        }
    }
    catch(...)
    {
        // <Gasp> We have been betrayed... try to write something to the error log
        // =======================================================================

        CriticalFailADAPTrace( "An unhandled exception has been thrown in the WMI monitoring thread." );
    }

    return 0;
}

HRESULT CAdapRegPerf::GetADAPStatusObject( void )
{
    IWbemLocator*   pLocator = NULL;

    HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator,
                    (void**) &pLocator );
    CReleaseMe  rm( pLocator );

    if ( SUCCEEDED( hr ) )
    {
        BSTR    bstrNameSpace = SysAllocString( L"root\\default" );
        BSTR    bstrInstancePath = SysAllocString( L"__ADAPStatus=@" );

        CSysFreeMe  sfm1( bstrNameSpace );
        CSysFreeMe  sfm2( bstrInstancePath );

        if ( NULL != bstrNameSpace && NULL != bstrInstancePath )
        {
            // Connect to Root\default and get hold of the status object
            hr = pLocator->ConnectServer(   bstrNameSpace,  // NameSpace Name
                                            NULL,           // UserName
                                            NULL,           // Password
                                            NULL,           // Locale
                                            0L,             // Security Flags
                                            NULL,           // Authority
                                            NULL,           // Wbem Context
                                            &m_pRootDefault     // Namespace
                                            );

            if ( SUCCEEDED( hr ) )
            {

                // Set Interface security
                hr = WbemSetProxyBlanket( m_pRootDefault, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                    RPC_C_AUTHN_LEVEL_PKT,RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

                if ( SUCCEEDED( hr ) )
                {
                    hr = m_pRootDefault->GetObject( bstrInstancePath, 0L, NULL, &m_pADAPStatus, NULL );

                    if ( SUCCEEDED( hr ) )
                    {
                        SetADAPStatus( eADAPStatusRunning );
                    }
                }
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

    }   // IF got locator

    return hr;
}

// Gets the time in the popular DMTF format
void CAdapRegPerf::GetTime( LPWSTR Buff, size_t cchBuffSize )
{
    SYSTEMTIME st;
    int Bias=0;
    char cOffsetSign = '+';

    GetLocalTime( &st );

    TIME_ZONE_INFORMATION ZoneInformation;
    DWORD dwRet = GetTimeZoneInformation(&ZoneInformation);
    if(dwRet != TIME_ZONE_ID_UNKNOWN)
        Bias = -ZoneInformation.Bias;

    if(Bias < 0)
    {
        cOffsetSign = '-';
        Bias = -Bias;
    }


    StringCchPrintfW(Buff,cchBuffSize, L"%4d%02d%02d%02d%02d%02d.%06d%c%03d", 
                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, 
                st.wSecond, st.wMilliseconds*1000, cOffsetSign, Bias); 
}

// Sets the status back in WMI
void CAdapRegPerf::SetADAPStatus( eADAPStatus status )
{
    HRESULT hr = E_FAIL;
    // Make sure we've got both our pointers
    if ( NULL != m_pRootDefault && NULL != m_pADAPStatus )
    {
        // We only need 25 characters for this
        WCHAR   wcsTime[32];
        
        _variant_t    var;

        // legacy fastprox behavior
        WCHAR pNum[16];
        StringCchPrintfW(pNum,16,L"%u",status);
        var = pNum;

        hr = m_pADAPStatus->Put( L"Status", 0L, &var, 0 );//CIM_UINT32 );

        if ( SUCCEEDED( hr ) )
        {
            // Set the time property if necessary
            if ( status == eADAPStatusRunning || status == eADAPStatusFinished )
            {
                GetTime( wcsTime, 32 );

                // This can fail
                try
                {
                    var =  wcsTime;
                }
                catch(...)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

                if ( SUCCEEDED( hr ) )
                {
                    hr = ( status == eADAPStatusRunning ?
                        m_pADAPStatus->Put( L"LastStartTime", 0L, &var, CIM_DATETIME ) :
                        m_pADAPStatus->Put( L"LastStopTime", 0L, &var, CIM_DATETIME ) );
                }

            }

            if ( SUCCEEDED( hr ) )
            {
                hr = m_pRootDefault->PutInstance( m_pADAPStatus, 0L, NULL, NULL );
            }

        }   // Set the Status property

    }   // Make sure we've got both pointers
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adapreg.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPREG.H

Abstract:

History:

--*/

// Use this guy to build a list of class objects we can retrieve via
// class name.  At this time, it just brute forces a class and a flex
// array, but could be modified to use an STL map just as easily.

#ifndef __ADAPREG_H__
#define __ADAPREG_H__

#include <wbemcomn.h>
#include "ntreg.h"
#include "adapcls.h"
#include <statsync.h>

#define HKEY_PERFORMANCE_TEXT       (( HKEY ) (ULONG_PTR)((LONG)0x80000050) )
#define HKEY_PERFORMANCE_NLSTEXT    (( HKEY ) (ULONG_PTR)((LONG)0x80000060) )

//
// common THROTTLING PARAMS
//
#define ADAP_IDLE_USER  3000
#define ADAP_IDLE_IO    500000
#define ADAP_LOOP_SLEEP 200
#define ADAP_MAX_WAIT   (2*60*1000)



#define	ADAP_LOCALE_KEY				L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\PerfLib"
#define WMI_ADAP_REVERSE_PERFLIB	L"WMIAPRPL"

#define ADAP_EVENT_MESSAGE_LENGTH   2048
#define ADAP_EVENT_MESSAGE_PREFIX   "An unhandled exception occured.  The following performance libraries were processed: "
#define ADAP_EVENT_MESSAGE_DELIM    L", "

#define ADAP_KEY_MAX_COLLECT L"ADAPPerflibMaxSizeBlobCollect"

// These are the various statuses we can set while ADAP is running
typedef enum
{
	eADAPStatusPending,
	eADAPStatusRunning,
	eADAPStatusProcessLibs,
	eADAPStatusCommit,
	eADAPStatusFinished
}	eADAPStatus;

// HRESULT	GetServicePID( WCHAR* wszService, DWORD* pdwPID );

class CPerfLibList
{
	WCHAR*				m_wszPerfLibList;
	CStaticCritSec	m_csPerfLibList;

public:
	CPerfLibList() : m_wszPerfLibList( NULL )
	{		
	}

	~CPerfLibList()
	{
		delete m_wszPerfLibList;
	}

	HRESULT AddPerfLib( WCHAR* wszPerfLib );
	HRESULT	HandleFailure();
};

class CAdapRegPerf : public CNTRegistry
///////////////////////////////////////////////////////////////////////////////
//
//	This is the control mechanism which interfaces with the 
//
///////////////////////////////////////////////////////////////////////////////
{
private:	
	// The unified 'master' class lists for both the raw and the cooked classes
	// ========================================================================

	CMasterClassList*	m_apMasterClassList[WMI_ADAP_NUM_TYPES];

	// The repository containing all names databases
	// =============================================

	CLocaleCache*		m_pLocaleCache;

	// The winmgmt synchronization members
	// ===================================

	DWORD				m_dwPID;
	HANDLE				m_hSyncThread;
	HANDLE				m_hTerminationEvent;
	BOOL				m_fQuit;

	IWbemServices*		m_pRootDefault;
	IWbemClassObject*	m_pADAPStatus;

	// Registry change notification members 
	// ====================================

	HKEY				m_hPerflibKey;
	HANDLE				m_hRegChangeEvent;

	//
	//

	CKnownSvcs * m_pKnownSvcs;
	BOOL m_bFull;

	// Private methods
	// ===============

	HRESULT ProcessLibrary( WCHAR* pwcsServiceName, BOOL bDelta );

	static unsigned int __stdcall GoGershwin( void * pParam );
	static LONG	__stdcall AdapUnhandledExceptionFilter( LPEXCEPTION_POINTERS lpexpExceptionInfo );

	HRESULT GetADAPStatusObject( void );
	void SetADAPStatus( eADAPStatus status );
	void GetTime( LPWSTR Buff, size_t cchBuffSize );

public:
	CAdapRegPerf(BOOL bFull);
	~CAdapRegPerf();
	
	HRESULT Initialize(BOOL bDelta, BOOL bThrottle);

	HRESULT Dredge( BOOL bDelta, BOOL bThrottle ); 

	static HRESULT Clean();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adapperf.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPPERF.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include <WinMgmtR.h>
#include "ntreg.h"
#include "adapperf.h"
#include "adaputil.h"


#define PL_TIMEOUT  100000      // The timeout value for waiting on a function mutex
#define GUARD_BLOCK "WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP_WMIADAP"

BYTE CAdapSafeBuffer::s_pGuardBytes[] = GUARD_BLOCK;

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapSafeDataBlock
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapSafeBuffer::CAdapSafeBuffer(  WString wstrServiceName  )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
:   m_dwGuardSize       ( 0 ),
    m_hPerfLibHeap      ( NULL ),
    m_pRawBuffer        ( NULL ),
    m_pSafeBuffer       ( NULL ),
    m_dwSafeBufferSize  ( 0 ),
    m_pCurrentPtr       ( NULL ),
    m_dwNumObjects      ( 0 ),
    m_wstrServiceName   ( wstrServiceName )
{
    // Initialize the guard byte pattern
    // =================================

    m_dwGuardSize = sizeof( GUARD_BLOCK );

    // Create the private heap
    // =======================

    m_hPerfLibHeap = HeapCreate( 0, 0x100000, 0 );

    // If the private heap could not be created, then use the process heap
    // ===================================================================
    
    if ( NULL == m_hPerfLibHeap )
    {
        m_hPerfLibHeap = GetProcessHeap();
    }
}

CAdapSafeBuffer::~CAdapSafeBuffer()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    // Deallocate the raw buffer 
    // =========================

    if ( NULL != m_pRawBuffer )
    {
         HeapFree( m_hPerfLibHeap, 0, m_pRawBuffer );
    }

    // Destroy the private heap
    // ========================

    if ( ( NULL != m_hPerfLibHeap ) && ( GetProcessHeap() != m_hPerfLibHeap ) )
    {
        HeapDestroy( m_hPerfLibHeap );
    }
}

HRESULT CAdapSafeBuffer::SetSize( DWORD dwNumBytes )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Sets the size of the safe buffer.  Memory is actually allocated for the raw buffer, and
//  the safe buffer just sits in the raw buffer between the set of guard bytes
//
//  Parameters:
//      dwNumBytes  - the number of bytes requested for the safe buffer
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    DWORD   dwRawBufferSize = 0;

    // Check for roll-over
    // ===================

    if ( dwNumBytes > ( 0xFFFFFFFF - ( 2 * m_dwGuardSize ) ) )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( SUCCEEDED ( hr ) )
    {
        // Set the total size of the buffer
        // ================================

        m_dwSafeBufferSize = dwNumBytes;
        dwRawBufferSize = dwNumBytes + ( 2 * m_dwGuardSize );

        // Allocate the memory
        // ===================
        if ( NULL == m_pRawBuffer )
        {
            // First time allocation
            // =====================
            m_pRawBuffer = (BYTE*) HeapAlloc( m_hPerfLibHeap, 
                                              HEAP_ZERO_MEMORY, 
                                              dwRawBufferSize ); 
        }
        else
        {
            BYTE * pTmp = (BYTE *)HeapReAlloc( m_hPerfLibHeap, 
                                            HEAP_ZERO_MEMORY, 
                                            m_pRawBuffer, 
                                            dwRawBufferSize );
            if (pTmp)
            {
                m_pRawBuffer = pTmp;
            }
            else
            {
                HeapFree(m_hPerfLibHeap,0,m_pRawBuffer);
                m_pRawBuffer = NULL;
            }
        }

        if ( NULL != m_pRawBuffer )
        {
            // Set the safe buffer pointer
            // ===========================

            m_pSafeBuffer = m_pRawBuffer + m_dwGuardSize;

            // Set the prefix guard bytes
            // =========================

            memcpy( m_pRawBuffer, s_pGuardBytes, m_dwGuardSize );

            // Set the suffix guard bytes
            // ==========================

            memcpy( m_pSafeBuffer + m_dwSafeBufferSize, s_pGuardBytes, m_dwGuardSize );
        }
        else
        {
            m_pSafeBuffer = NULL;
            m_pCurrentPtr = NULL;
            m_dwSafeBufferSize = 0;
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

HRESULT CAdapSafeBuffer::Validate(BOOL * pSentToEventLog)
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Validate will compare the size of the pointer displacement matches the byte size 
//  returned from the collection, validates the guard bytes and walks the blob, verifying 
//  that all of the pointers are within the boundary of the blob
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    try 
    {
        PERF_OBJECT_TYPE* pObject = (PERF_OBJECT_TYPE*) m_pSafeBuffer;

        // Validate that if we have objects, then we have mass
        // ===================================================

        if ( ( 0 < m_dwNumObjects ) && ( 0 == m_dwDataBlobSize ) )
        {
            hr = WBEM_E_FAILED;
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                      WBEM_MC_ADAP_BLOB_HAS_NO_SIZE, 
                                      (LPCWSTR)m_wstrServiceName );
            if (pSentToEventLog) {
                *pSentToEventLog = TRUE;
            }
        }

        // Validate that that number of bytes returned is the same as the pointer displacement
        // ===================================================================================

        if ( SUCCEEDED( hr ) && ( ( m_pCurrentPtr - m_pSafeBuffer ) != m_dwDataBlobSize ) )
        {
            hr = WBEM_E_FAILED;
                        
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                      WBEM_MC_ADAP_BAD_PERFLIB_INVALID_DATA, 
                                      (LPCWSTR)m_wstrServiceName, CHex( hr ) );
            if (pSentToEventLog) {
                *pSentToEventLog = TRUE;
            }
        }

        if ( SUCCEEDED ( hr ) )
        {
            // Validate the guard bytes
            // ========================

            if ( 0 != memcmp( m_pRawBuffer, s_pGuardBytes, m_dwGuardSize) )
            {
                hr = WBEM_E_FAILED;
                
                CAdapUtility::NTLogEvent( EVENTLOG_ERROR_TYPE, 
                                          WBEM_MC_ADAP_BAD_PERFLIB_MEMORY, 
                                          (LPCWSTR)m_wstrServiceName, CHex( hr ) );
                if (pSentToEventLog) {
                    *pSentToEventLog = TRUE;
                }
            }
            else
            {
                if ( 0 != memcmp( m_pSafeBuffer + m_dwSafeBufferSize, s_pGuardBytes, m_dwGuardSize) )
                {
                    hr = WBEM_E_FAILED;
                    CAdapUtility::NTLogEvent( EVENTLOG_ERROR_TYPE, 
                                              WBEM_MC_ADAP_BAD_PERFLIB_MEMORY, 
                                              (LPCWSTR)m_wstrServiceName, CHex( hr ) );
                    if (pSentToEventLog) {
                        *pSentToEventLog = TRUE;
                    }
                }
            }
        }

        // Validate the blob
        // =================

        if ( SUCCEEDED( hr ) )
        {
            for ( int nObject = 0; SUCCEEDED( hr ) && nObject < m_dwNumObjects; nObject++ )
            {
                PERF_COUNTER_DEFINITION* pCtr = NULL;
                DWORD dwCtrBlockSize = 0;

                // Validate the object pointer
                // ===========================

                hr = ValidateSafePointer( (BYTE*) pObject );

                if ( SUCCEEDED( hr ) )
                {
                    // Validate the counter definitions
                    // ================================

                    if ( 0 == pObject->HeaderLength )
                    {
                        hr = WBEM_E_FAILED;
                    }
                    else
                    {
                        pCtr = ( PERF_COUNTER_DEFINITION* ) ( ( ( BYTE* ) pObject ) + pObject->HeaderLength );
                    }
                }

                for( int nCtr = 0; SUCCEEDED( hr ) && nCtr < pObject->NumCounters; nCtr++) 
                {
                    hr = ValidateSafePointer( ( BYTE* ) pCtr );

                    if ( SUCCEEDED( hr ) )
                    {
                        dwCtrBlockSize += pCtr->CounterSize;

                        if ( nCtr < ( pObject->NumCounters - 1 ) )
                        {
                            if ( 0 == pCtr->ByteLength )
                            {
                                hr = WBEM_E_FAILED;
                            }
                            else
                            {
                                pCtr = ( PERF_COUNTER_DEFINITION* ) ( ( ( BYTE* ) pCtr ) + pCtr->ByteLength );
                            }
                        }
                    }
                }

                // Validate the data
                // =================

                if ( pObject->NumInstances >= 0 )
                {
                    // Blob has instances
                    // ==================

                    PERF_INSTANCE_DEFINITION* pInstance = NULL;

                    if ( 0 == pObject->DefinitionLength )
                    {
                        hr = WBEM_E_FAILED;
                    }
                    else
                    {
                        pInstance = ( PERF_INSTANCE_DEFINITION* ) ( ( ( BYTE* ) pObject ) + pObject->DefinitionLength );
                    }
                    
                    // Validate the instances
                    // ======================


                    for ( int nInst = 0; SUCCEEDED( hr ) && nInst < pObject->NumInstances; nInst++ )
                    {
                        
                        hr = ValidateSafePointer( ( BYTE* ) pInstance );

                        if ( SUCCEEDED( hr ) )
                        {
                            PERF_COUNTER_BLOCK* pCounterBlock = NULL;

                            // Validate the counter blocks
                            // ===========================

                            if ( 0 == pInstance->ByteLength )
                            {
                                hr = WBEM_E_FAILED;
                            }
                            else
                            {
                                pCounterBlock = ( PERF_COUNTER_BLOCK* ) ( ( ( BYTE* ) pInstance ) + pInstance->ByteLength );

                                hr = ValidateSafePointer( ( BYTE* ) pCounterBlock );
                            }
                            
                            if ( SUCCEEDED( hr ) )
                            {
                                // Is the counter block the same size as the aggregation of the counter sizes?
                                // ===========================================================================

                                if ( ( nInst < pObject->NumInstances - 1 ) && SUCCEEDED( hr ) )
                                {
                                    pInstance = ( PERF_INSTANCE_DEFINITION* ) ( ( ( BYTE* ) pCounterBlock ) + pCounterBlock->ByteLength );
                                    hr = ValidateSafePointer( (BYTE*) pInstance );
                                }
                                //
                                // validate the size of the last object against
                                // the 'aperture' of the buffer
                                //
                                /*
                                if (SUCCEEDED(hr) && (nInst == (pObject->NumInstances - 1)))
                                {
                                    BYTE * pLast = ( ( ( BYTE* ) pCounterBlock ) + pCounterBlock->ByteLength );
                                    // now pLast is 1 byte over the "end" of the buffer
                                    if (pLast > m_pCurrentPtr)
                                    {
                                        hr = WBEM_E_FAILED;
                                    }
                                }
                                */
                            }
                        }
                    }
                }
                else
                {
                    // Blob is a singleton. Validate the counter blocks
                    // ================================================

                    if ( 0 == pObject->DefinitionLength )
                    {
                        hr = WBEM_E_FAILED;
                    }
                    else
                    {
                        PERF_COUNTER_BLOCK* pCounterBlock = ( PERF_COUNTER_BLOCK* ) ( ( ( BYTE* ) pObject ) + pObject->DefinitionLength );
                        hr = ValidateSafePointer( ( BYTE* ) pCounterBlock );
                    }
                }

                // Get the next object as long as one exists
                // =========================================

                if ( nObject < ( m_dwNumObjects - 1 ) )
                {
                    pObject = (PERF_OBJECT_TYPE*)((BYTE*)pObject + pObject->TotalByteLength);
                    hr = ValidateSafePointer( ( BYTE* ) pObject );
                }
            }
        }
    }
    catch(...)
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CAdapSafeBuffer::ValidateSafePointer( BYTE* pPtr )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Verifys that the pointer is within the blob.  The blob occupies the memory starting at 
//  the beginning of the safe buffer, and termintes at an offset equal to m_dwDataBlobSize
//
//  Parameters:
//      pPtr    - a pointer to be verified
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    //  NOTE: The upper limit of the safe buffer is 1 byte less the blob pointer plus the blob size since
    //  the first byte of the blob is also the first byte.  Imagine he case with a blob of size 1. 
    //  =================================================================================================

    if ( ( pPtr < m_pSafeBuffer ) || ( pPtr > ( m_pSafeBuffer + m_dwDataBlobSize - 1 ) ) )
    {
        hr = WBEM_E_FAILED;
    }

    if ( FAILED ( hr ) )
    {
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                  WBEM_MC_ADAP_BAD_PERFLIB_INVALID_DATA, 
                                  (LPCWSTR)m_wstrServiceName, CHex( hr ) );
    }

    return hr;
}

HRESULT CAdapSafeBuffer::CopyData( BYTE** ppData, DWORD* pdwNumBytes, DWORD* pdwNumObjects )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copies the blob data from the private heap into the process heap.  The method will 
//  allocate memory in the process heap.
//
//  Parameters:
//      ppData  - a pointer to an unallocated byte array
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    if (NULL == ppData || NULL == pdwNumBytes || NULL == pdwNumObjects) return WBEM_E_INVALID_PARAMETER;
    HRESULT hr = WBEM_NO_ERROR;

    *ppData = new BYTE[m_dwDataBlobSize];

    if ( NULL == *ppData )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        memcpy( *ppData, m_pSafeBuffer, m_dwDataBlobSize );
    }
    
    *pdwNumBytes = m_dwDataBlobSize;
    *pdwNumObjects = m_dwNumObjects;

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapPerfLib
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapPerfLib::CAdapPerfLib( LPCWSTR pwcsServiceName, DWORD * pLoadStatus )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
//  Initializes all member variables, sets the library and function names, opens the library, 
//  sets the entry point addresses, creates the perflib processing mutex, and opens the 
//  processing thread.
//
//  Parameters:
//      pwcsServiceName - A Unicode string specifying the name of the perflib service.
//
////////////////////////////////////////////////////////////////////////////////////////////
:   m_wstrServiceName( pwcsServiceName ),
    m_pfnOpenProc( NULL ),
    m_pfnCollectProc( NULL ),
    m_pfnCloseProc( NULL ),
    m_pwcsLibrary( NULL ),
    m_pwcsOpenProc( NULL ),
    m_pwcsCollectProc( NULL ),
    m_pwcsCloseProc( NULL ),
    m_hLib( NULL ),
    m_fOpen( FALSE ),
    m_dwStatus( 0 ),
    m_pPerfThread( NULL ), 
    m_hPLMutex( NULL ),
    m_fOK( FALSE ),
    m_EventLogCalled( FALSE ),
    m_CollectOK( TRUE ),
    m_dwFirstCtr(2),
	m_dwLastCtr(CPerfNameDb::GetSystemReservedHigh()) 
{
    DEBUGTRACE( ( LOG_WMIADAP, "Constructing the %S performance library wrapper.\n", pwcsServiceName ) );

    HRESULT hr = WBEM_NO_ERROR;

    // Verify that the perflib is loaded
    // Initialize the performance library name and entry point names
    // =============================================================

    hr = VerifyLoaded();

    if (FAILED(hr))
    {        
        ERRORTRACE( ( LOG_WMIADAP, "VerifyLoaded for %S hr = %08x.\n", pwcsServiceName, hr ) );
    }


    // Set the processing status information for this attempt
    // ======================================================

    if ( SUCCEEDED ( hr ) )
    {
        if (pLoadStatus)
        {
            (*pLoadStatus) |= EX_STATUS_LOADABLE;
        }
        
        hr = BeginProcessingStatus();

        if ( hr == WBEM_S_ALREADY_EXISTS )
        {
            SetStatus( ADAP_PERFLIB_PREVIOUSLY_PROCESSED );
        }
    }

    m_fOK = SUCCEEDED( hr );

    if ( !m_fOK )
    {
        ERRORTRACE( ( LOG_WMIADAP, "Construction of the %S perflib wrapper failed hr = %08x.\n", pwcsServiceName, hr ) );
    }
}

CAdapPerfLib::~CAdapPerfLib( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    DEBUGTRACE( ( LOG_WMIADAP, "Destructing the %S performance library wrapper.\n", (LPWSTR)m_wstrServiceName) );

 
    delete m_pPerfThread;
 

    // Delete the library and entry point names
    // ========================================
    delete [] m_pwcsLibrary;
    delete [] m_pwcsOpenProc;
    delete [] m_pwcsCollectProc;
    delete [] m_pwcsCloseProc;
 
    // Free the library
    // ================

    if ( NULL != m_hLib )
    {
        try 
        {
            FreeLibrary( m_hLib );
        } 
        catch (...)
        {
            ERRORTRACE(( LOG_WMIADAP,"FreeLibrary for Service %S threw an exception",(LPWSTR)m_wstrServiceName) );
        }
        DEBUGTRACE( ( LOG_WMIADAP, "Library for Service %S Freed.\n",(LPWSTR)m_wstrServiceName ) );
    }
}

HRESULT CAdapPerfLib::VerifyLoaded()
{
    HRESULT hr = WBEM_E_FAILED;

    WString wszRegPath = L"SYSTEM\\CurrentControlSet\\Services\\";
    wszRegPath += m_wstrServiceName;
    wszRegPath += L"\\Performance";

    CNTRegistry reg;
    int         nRet = 0;

    nRet = reg.Open( HKEY_LOCAL_MACHINE, wszRegPath );

    switch( nRet )
    {
    case CNTRegistry::no_error:
        {
            DWORD  dwFirstCtr = 0;
            DWORD  dwLastCtr = 0;
            WCHAR* wszObjList = NULL;

            if ( ( ( reg.GetDWORD( L"First Counter", &dwFirstCtr ) == CNTRegistry::no_error ) &&
                   ( reg.GetDWORD( L"Last Counter", &dwLastCtr ) == CNTRegistry::no_error )      ) ||
                ( reg.GetStr( L"Object List", &wszObjList ) == CNTRegistry::no_error ))
            {

                hr = InitializeEntryPoints(reg,wszRegPath);   

                if (wszObjList) 
                {
                    delete [] wszObjList;
                }
                if (dwFirstCtr && dwLastCtr)
                {
                    m_dwFirstCtr = dwFirstCtr;
                    m_dwLastCtr = dwLastCtr;
                }
            } 
            else // more special cases
            { 
                if ( m_wstrServiceName.EqualNoCase( L"TCPIP" ) || 
                     m_wstrServiceName.EqualNoCase( L"TAPISRV") || 
                     m_wstrServiceName.EqualNoCase( L"PERFOS" ) ||
                     m_wstrServiceName.EqualNoCase( L"PERFPROC" ) ||
                     m_wstrServiceName.EqualNoCase( L"PERFDISK" ) ||
                     m_wstrServiceName.EqualNoCase( L"PERFNET" ) ||
                     m_wstrServiceName.EqualNoCase( L"SPOOLER" ) ||
                     m_wstrServiceName.EqualNoCase( L"MSFTPSvc" ) ||
                     m_wstrServiceName.EqualNoCase( L"RemoteAccess" ) ||
                     m_wstrServiceName.EqualNoCase( L"WINS" ) ||
                     m_wstrServiceName.EqualNoCase( L"MacSrv" ) ||
                     m_wstrServiceName.EqualNoCase( L"AppleTalk" ) ||
                     m_wstrServiceName.EqualNoCase( L"NM" ) ||
                     m_wstrServiceName.EqualNoCase( L"RSVP" ) )
                {                     
                    hr = InitializeEntryPoints(reg,wszRegPath);                     
                } 
                else 
                {
                    hr = WBEM_E_FAILED; 
                }
            }                
        }break;
    case CNTRegistry::not_found:
        {
            // This shouldn't happen since this is how a perflib is defined
            hr = WBEM_E_FAILED;
        }break;
    case CNTRegistry::access_denied:
        {
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                       WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                      (LPWSTR)wszRegPath, nRet );
        }break;
    }

    return hr;
}

HRESULT CAdapPerfLib::InitializeEntryPoints(CNTRegistry & reg,WString & wszRegPath){

    HRESULT hr = WBEM_S_NO_ERROR;

    // see if someone disabled this library
    DWORD dwDisable = 0;
    if ( CNTRegistry::no_error == reg.GetDWORD( L"Disable Performance Counters", &dwDisable ) && 
         (dwDisable != 0) )
    {
        hr = WBEM_E_FAILED;
    } 
    else 
    {
        hr = WBEM_S_NO_ERROR;
    }
    // the perflib is OK for the world, see if it os OK for US
                
    if (SUCCEEDED(hr)){
            
        if (!(( reg.GetStr( L"Library", &m_pwcsLibrary ) == CNTRegistry::no_error ) &&
              ( reg.GetStr( L"Open", &m_pwcsOpenProc ) == CNTRegistry::no_error)&&
              ( reg.GetStr( L"Collect", &m_pwcsCollectProc ) == CNTRegistry::no_error) &&
              ( reg.GetStr( L"Close", &m_pwcsCloseProc ) == CNTRegistry::no_error ) )) 
        {

            WString wstrPath(wszRegPath);
            
            if (m_pwcsLibrary == NULL){
                wstrPath += L"\\Library";
            } else if (m_pwcsCollectProc == NULL) {
                wstrPath += L"\\Collect";
            }
            
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                                  WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                                  (LPWSTR)wstrPath, CHex( WBEM_E_NOT_AVAILABLE ) );
                         
            hr = WBEM_E_FAILED;
                        
        } else {

            hr = WBEM_S_NO_ERROR;
        }                    
    }

    return hr;

}


HRESULT CAdapPerfLib::Initialize() 
{   
    // Load the perflib and initialize the procedure addresses
    // =======================================================
    HRESULT hr = Load();

    // Initialize the named function mutex (see WbemPerf for syntax of Mutex name)
    // ===========================================================================

    if ( SUCCEEDED( hr ) )
    {
        size_t cchSizeTmp = m_wstrServiceName.Length() + 256;
        WCHAR* wcsMutexName = new WCHAR[cchSizeTmp];
        if (NULL == wcsMutexName) return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<WCHAR>    dmMutexName( wcsMutexName );

        StringCchPrintfW( wcsMutexName, cchSizeTmp, L"Global\\%s_Perf_Library_Lock_PID_%x", (WCHAR *)m_wstrServiceName, GetCurrentProcessId() );
        m_hPLMutex = CreateMutexW( 0, FALSE, wcsMutexName);

        if ( NULL == m_hPLMutex )
        {
            hr = WBEM_E_FAILED;
        }
    }

    // Create the worker thread
    // ========================

    if ( SUCCEEDED( hr ) )
    {
        m_pPerfThread = new CPerfThread( this );

        if ( ( NULL == m_pPerfThread) || ( !m_pPerfThread->IsOk() ) )
        {
            hr = WBEM_E_FAILED;
        }
        else
        {
                 hr = m_pPerfThread->Open( this ); 
        }
    }

    if ( FAILED( hr ) )
    {
        SetStatus( ADAP_PERFLIB_IS_INACTIVE );
    }

    return hr;
}


HRESULT CAdapPerfLib::GetFileSignature( CheckLibStruct * pCheckLib )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if (!pCheckLib){
        return WBEM_E_INVALID_PARAMETER;
    }

    // Get the current library's file time
    // ===================================

    HANDLE hFile = NULL;

    DWORD   dwRet = 0;
    WCHAR   wszFullPath[MAX_PATH];
    WCHAR*  pwcsTemp = NULL;

    if ( 0 != SearchPathW( NULL, m_pwcsLibrary, NULL, MAX_PATH, wszFullPath, &pwcsTemp ) )
    {
        // Use GetFileAttributes to validate the path.
        DWORD dwAttributes = GetFileAttributesW(wszFullPath);
        if (dwAttributes == 0xFFFFFFFF) return WBEM_E_FAILED;

        // create mask of the attributes that would make an existing file invalid for use
        DWORD dwMask =    FILE_ATTRIBUTE_DEVICE |
                            FILE_ATTRIBUTE_DIRECTORY |
                            FILE_ATTRIBUTE_OFFLINE |
                            FILE_ATTRIBUTE_READONLY |
                            FILE_ATTRIBUTE_REPARSE_POINT |
                            FILE_ATTRIBUTE_SPARSE_FILE |
                            FILE_ATTRIBUTE_SYSTEM |
                            FILE_ATTRIBUTE_TEMPORARY;

        if (dwAttributes & dwMask) return WBEM_E_FAILED;
        
        hFile = CreateFileW( wszFullPath, 
                         GENERIC_READ, 
                         FILE_SHARE_READ, 
                         NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

        if ( INVALID_HANDLE_VALUE != hFile )
        {
            OnDelete<HANDLE,BOOL(*)(HANDLE),CloseHandle> CloseMe(hFile);
            
            DWORD    dwFileSizeLow = 0;
            DWORD    dwFileSizeHigh = 0;
            __int32    nFileSize = 0;
            DWORD    dwNumRead = 0;
            BYTE*    aBuffer = NULL;

            dwFileSizeLow = GetFileSize( hFile, &dwFileSizeHigh );
            nFileSize = ( dwFileSizeHigh << 32 ) + dwFileSizeLow;

            FILETIME ft;
            if (GetFileTime(hFile,&ft,NULL,NULL))
            {
                aBuffer = new BYTE[nFileSize];
                CDeleteMe<BYTE> dmBuffer( aBuffer );

                if ( NULL != aBuffer )
                {
                    if ( ReadFile( hFile, aBuffer, nFileSize, &dwNumRead, FALSE ) )
                    {
                        MD5    md5;
                        BYTE aSignature[16];
                        md5.Transform( aBuffer, dwNumRead, aSignature );

                        // return our data
                        memcpy(pCheckLib->Signature,aSignature,sizeof(aSignature));
                        pCheckLib->FileTime = ft;
                        pCheckLib->FileSize = nFileSize;
                    }
                    else
                    {
                        hr = WBEM_E_TOO_MUCH_DATA;
                    }
                }
                else
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }            
            } 
            else 
            {
                hr = WBEM_E_FAILED;
            }

        }
        else
        {
            ERRORTRACE((LOG_WMIADAP,"GetFileSignature for %S err %d\n",wszFullPath,GetLastError()));
            hr = WBEM_E_FAILED;
        }        
    }
    else
    {
        hr = WBEM_E_NOT_FOUND;
    }

    return hr;
}


HRESULT CAdapPerfLib::SetFileSignature()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CNTRegistry reg;
    int         nRet = 0;
    CheckLibStruct CheckLib;

    // Clear the signature buffer
    // ==========================

    memset( &CheckLib, 0, sizeof(CheckLib) );

    // Get the current file time stamp
    // ===============================

    hr = GetFileSignature( &CheckLib );

    // And write it into the registry key
    // ==================================

    if ( SUCCEEDED( hr ) )
    {

        WString wstr;

        try
        {
            wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
            wstr += m_wstrServiceName;
            wstr += L"\\Performance";
        }
        catch(...)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        if ( SUCCEEDED( hr ) )
        {
            nRet = reg.Open( HKEY_LOCAL_MACHINE , wstr );

            switch ( nRet )
            {
            case CNTRegistry::no_error:
                {
                }break;
            case CNTRegistry::access_denied:
                {
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                              WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                              (LPCWSTR)wstr, nRet );
                }
            default:
                hr = WBEM_E_FAILED; 
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            int nRet1 = reg.SetBinary( ADAP_PERFLIB_SIGNATURE, (PBYTE)&CheckLib.Signature, sizeof( BYTE[16] ) );
            int nRet2 = reg.SetBinary( ADAP_PERFLIB_TIME, (PBYTE)&CheckLib.FileTime, sizeof( FILETIME ) );
            int nRet3 = reg.SetDWORD( ADAP_PERFLIB_SIZE, CheckLib.FileSize );

            if ( (CNTRegistry::no_error == nRet1) &&
                 (CNTRegistry::no_error == nRet2) &&
                 (CNTRegistry::no_error == nRet3))
            {
                // everything OK
            } 
            else if ((CNTRegistry::access_denied == nRet1) ||
                     (CNTRegistry::access_denied == nRet2) ||
                     (CNTRegistry::access_denied == nRet3))
            {                
                WString wstrPath = wstr;
                wstrPath += ADAP_PERFLIB_SIGNATURE;
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                           WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                          (LPCWSTR)wstrPath, CNTRegistry::access_denied );
            }
            else 
            {
                hr = WBEM_E_FAILED;
            }
        }
    }

    return hr;
}


HRESULT CAdapPerfLib::CheckFileSignature()
{
    HRESULT hr = WBEM_S_SAME;

    CNTRegistry reg;
    int         nRet = 0;
    BYTE    cCurrentMD5[16];
    BYTE*    cStoredMD5 = NULL;

    // Set the performance key path
    // ============================

    WString wstr;

    try
    {
        wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
        wstr += m_wstrServiceName;
        wstr += L"\\Performance";
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( SUCCEEDED( hr ) )
    {
        // Open the performance key
        // ========================

        nRet = reg.Open( HKEY_LOCAL_MACHINE , wstr );

        switch ( nRet )
        {
        case CNTRegistry::no_error:
            {
            }break;
        case CNTRegistry::access_denied:
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                          WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                          (LPCWSTR)wstr, nRet );
                hr = WBEM_E_FAILED;
            }break;
        default:
            {
                hr = WBEM_E_FAILED; 
            }break;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        // Get the stored file signature
        // =============================
        CheckLibStruct StoredLibStruct;
        int nRet1;
        int nRet2;
        int nRet3;

        DWORD dwSizeBlob;
        nRet1 = reg.GetBinary( ADAP_PERFLIB_SIGNATURE, (PBYTE*)&cStoredMD5,&dwSizeBlob);
        CDeleteMe<BYTE>    dmStoredMD5( cStoredMD5 );
        if (cStoredMD5)
        {
	        if ( sizeof(cCurrentMD5) == dwSizeBlob)
	        {
	            memcpy(&StoredLibStruct.Signature,cStoredMD5,sizeof(StoredLibStruct.Signature));
	        }
	        else
	        {
	            nRet1 = CNTRegistry::failed;
	        }
        }

        BYTE * pFileTime = NULL;
        nRet2 = reg.GetBinary( ADAP_PERFLIB_TIME, (PBYTE*)&pFileTime,&dwSizeBlob);
        CDeleteMe<BYTE>    dmFileTime( pFileTime );
        if (pFileTime)
        {
		    if (sizeof(FILETIME) == dwSizeBlob )
		    {
		        memcpy(&StoredLibStruct.FileTime,pFileTime,sizeof(FILETIME));
		    }
	        else
	        {
	            nRet2 = CNTRegistry::failed;
	        }		    
        }

        nRet3 = reg.GetDWORD(ADAP_PERFLIB_SIZE,&StoredLibStruct.FileSize);

        if ((CNTRegistry::access_denied == nRet1) ||
            (CNTRegistry::access_denied == nRet2) ||
            (CNTRegistry::access_denied == nRet3))
        {
            WString wstrPath = wstr;
            wstrPath += ADAP_PERFLIB_SIGNATURE;
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                      WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                      (LPCWSTR)wstrPath, nRet );
            hr = WBEM_E_FAILED;
        } 
        else if ((CNTRegistry::not_found == nRet1) ||
                   (CNTRegistry::not_found == nRet2) ||
                   (CNTRegistry::not_found == nRet3))
        {
            hr = WBEM_S_FALSE;   
        } 
        else if((CNTRegistry::out_of_memory == nRet1) ||
                   (CNTRegistry::out_of_memory == nRet2) ||
                   (CNTRegistry::out_of_memory == nRet3) ||
                   (CNTRegistry::failed == nRet1) ||
                   (CNTRegistry::failed == nRet2) ||
                   (CNTRegistry::failed == nRet3)) 
        {
            hr = WBEM_E_FAILED; 
        }

        if ( SUCCEEDED( hr ) && ( WBEM_S_FALSE != hr ) )
        {
            // Get the current library's signature
            // ===================================
            CheckLibStruct CurrentLibStruct;
            memset(&CurrentLibStruct,0,sizeof(CheckLibStruct));

            hr = GetFileSignature( &CurrentLibStruct );
        
            if ( SUCCEEDED( hr ) )
            {
                if ( (StoredLibStruct.FileSize == CurrentLibStruct.FileSize) &&
                     (0 == memcmp( &StoredLibStruct.Signature, &CurrentLibStruct.Signature, sizeof(CurrentLibStruct.Signature) )) &&
                     (0 == memcmp( &StoredLibStruct.FileTime, &CurrentLibStruct.FileTime, sizeof(FILETIME))) )
                {
                    hr = WBEM_S_ALREADY_EXISTS;
                }
                else
                {
                    hr = WBEM_S_FALSE;
                }
            }
        }
    }
    return hr;
}


HRESULT CAdapPerfLib::BeginProcessingStatus()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Opens the registry key, reads the ADAP_PERFLIB_STATUS_KEY, and processes the value as 
//  follows:
//
//      ADAP_PERFLIB_OK:            The perflib has been successfully accessed before. Set 
//                                  the status flag to ADAP_PERFLIB_PROCESSING
//
//      ADAP_PERFLIB_PROCESSING:    The perflib caused the process to fail.  It is corrupt,
//                                  set the status flag to ADAP_PERFLIB_CORRUPT.
//      
//      ADAP_PERFLIB_CORRUPT:       The perflib is known to be corrupt.  Status flag retains
//                                  its value.
//
//      No Value:                   The perflib has not been accessed before. Set the 
//                                  status flag to ADAP_PERFLIB_PROCESSING.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    DEBUGTRACE( ( LOG_WMIADAP, "CAdapPerfLib::BeginProcessingStatus()...\n") );

    HRESULT     hr = WBEM_S_NO_ERROR;
    CNTRegistry reg;

    // Set the registry path
    // =====================

    WString wstr;

    try
    {
        wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
        wstr += m_wstrServiceName;
        wstr += L"\\Performance";
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( SUCCEEDED( hr ) )
    {
        // Open the services key
        // =====================

        int nRet = reg.Open( HKEY_LOCAL_MACHINE, wstr );

        switch ( nRet )
        {
        case CNTRegistry::access_denied:
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                          WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                          (LPCWSTR)wstr, nRet );
            } break;
        case CNTRegistry::no_error:
            {
                DWORD dwVal;

                // Check perflib status
                // ====================

                hr = CheckFileSignature();

                if ( SUCCEEDED( hr ) )
                {
                    if ( WBEM_S_FALSE == hr )
                    {
                        // We've got a new perflib, reset the status
                        // =========================================

                        hr = SetFileSignature();

                        if ( SUCCEEDED( hr ) )
                        {
                            hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_PROCESSING );
                        }

                    }
                    else // WBEM_S_ALREADY_EXISTS
                    {
                        // It's the same perflib, check the status
                        // =======================================
                
                        nRet = reg.GetDWORD( ADAP_PERFLIB_STATUS_KEY, &dwVal );

                        if ( nRet == CNTRegistry::no_error )
                        {
                            switch ( dwVal )
                            {
                            case ADAP_PERFLIB_OK:           // 0
                            case ADAP_PERFLIB_PROCESSING:   // 1
                            case ADAP_PERFLIB_BOOBOO:       // 2                           
                                {
                                    // So far, perflib has behaved within reason. Set it to processing state
                                    // =====================================================================

                                    reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, dwVal + 1 );

                                    //ERRORTRACE( ( LOG_WMIADAP, "Performance library %S status %d\n",(LPWSTR)m_wstrServiceName,dwVal + 1));
                                    

                                }break;
                            case ADAP_PERFLIB_LASTCHANCE:   // 3                                 
                                {
                                    // Perflib failed in the last access attempt before processing ended. Set as bad perflib
                                    // =====================================================================================

                                    reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_CORRUPT );

                                    ERRORTRACE( ( LOG_WMIADAP, "Performance library %S status was left in the \"Processing\" state.\n",(LPWSTR)m_pwcsLibrary) );
                                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                                              WBEM_MC_ADAP_BAD_PERFLIB_BAD_LIBRARY, 
                                                              m_pwcsLibrary, CHex( (DWORD)-1 ) );
                                    hr = WBEM_E_FAILED;                                                              
                                }break;
                            case ADAP_PERFLIB_CORRUPT:      // -1
                                {
                                    // Sign of a bad perflib. Do not open
                                    // ==================================

                                    ERRORTRACE( ( LOG_WMIADAP, "Performance library for %S has previously been disabled.\n",(LPWSTR)m_wstrServiceName) );
                                    
                                    //CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_BAD_LIBRARY, m_pwcsLibrary, CHex( ADAP_PERFLIB_CORRUPT ) );

                                    hr = WBEM_E_FAILED;

                                }break;
                            }
                        }
                        else if ( nRet == CNTRegistry::not_found )
                        {
                            // The status does not exist
                            // =========================

                            hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_PROCESSING );
                        }
                    }
                } else {

                    DEBUGTRACE( ( LOG_WMIADAP, "CheckFileSignature for %S %08x\n",(LPWSTR)m_wstrServiceName,hr ) );

                }
            }break;
        default:
            {
                hr = WBEM_E_FAILED;
            }break;
        }
    }

    return hr;
}

HRESULT CAdapPerfLib::EndProcessingStatus()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Opens the service registry key, reads the ADAP_PERFLIB_STATUS_KEY, and processes the 
//  value as follows:
//
//      ADAP_PERFLIB_PROCESSING:    Valid state. Set status flag to ADAP_PERFLIB_OK.
//
//      ADAP_PERFLIB_CORRUPT:       Valid state (may have been set during processing). 
//                                  Leave status flag as is.
//
//      ADAP_PERFLIB_OK:            Invalid state. Return an error and log an event.
//
//      No Value:                   Invalid state. Return an error and log an event.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    DEBUGTRACE( ( LOG_WMIADAP, "CAdapPerfLib::EndProcessingStatus()...\n") );

    HRESULT     hr = WBEM_S_NO_ERROR;
    CNTRegistry reg;

    WString wstr;

    try
    {
        wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
        wstr += m_wstrServiceName;
        wstr += L"\\Performance";
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if (SUCCEEDED(hr)){
    // Open the services key
    // =====================

        int nRet = reg.Open( HKEY_LOCAL_MACHINE, wstr );

        if ( CNTRegistry::access_denied == nRet )
        {
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                      WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                      (LPCWSTR)wstr, nRet );
            hr = WBEM_E_FAILED;
        }
        else if ( CNTRegistry::no_error == nRet )
        {
            DWORD   dwVal = 0;

            // Check perflib status
            // ====================

            if ( CheckStatus( ADAP_PERFLIB_FAILED ) )
            {
                // If we have a failure, then immediately mark the perflib as corrupt
                // ==================================================================

                hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_CORRUPT );

                if (!m_EventLogCalled){
                    m_EventLogCalled = TRUE;
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_EXCEPTION, (LPCWSTR)m_wstrServiceName, CHex( hr ) );
                    
                }

            }
            else if ( reg.GetDWORD( ADAP_PERFLIB_STATUS_KEY, &dwVal) == CNTRegistry::no_error )
            {
                switch ( dwVal )
                {
                case ADAP_PERFLIB_PROCESSING:
                case ADAP_PERFLIB_BOOBOO:
                case ADAP_PERFLIB_LASTCHANCE:
                    {
                        // Perflib is in expected state, reset as long as nothing bad has happened
                        // =======================================================================

                        hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_OK );

                        //ERRORTRACE( ( LOG_WMIADAP, "Performance library %S EndProcessing\n",(LPWSTR)m_wstrServiceName) );


                    }break;

                case ADAP_PERFLIB_CORRUPT:
                    {
                        // Valid state.  Leave as is.
                        // ==========================

                        ERRORTRACE( ( LOG_WMIADAP, "Performance library for %S: status is corrupt.\n",(LPWSTR)m_wstrServiceName) );
                        hr = WBEM_E_FAILED;

                    }break;

                case ADAP_PERFLIB_OK:
                    {
                        if (CheckStatus(ADAP_PERFLIB_IS_INACTIVE))
                        {
                            hr = reg.SetDWORD( ADAP_PERFLIB_STATUS_KEY, ADAP_PERFLIB_OK );
                        } 
                        else 
                        {
                            // Invalid state
                            ERRORTRACE( ( LOG_WMIADAP, "Performance library %S: status is still ADAP_PERFLIB_OK.\n",(LPWSTR)m_wstrServiceName) );
                            hr = WBEM_E_FAILED;
                        }

                    }break;
                
                default:
                    {
                        // Really bad state
                        // ================

                        ERRORTRACE( ( LOG_WMIADAP, "Performance library %S: status is in an unknown state.\n",(LPWSTR)m_wstrServiceName) );
                        hr = WBEM_E_FAILED;
                    }
                }
            }
            else 
            {
                // There is no status key. Something wacky has happened
                // ====================================================

                hr = WBEM_E_FAILED;
            }
        }
    }

    return hr;
}

HRESULT CAdapPerfLib::Load()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Loads the library and resolves the addresses for the Open, Collect and Close entry 
//  points.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    // Redundant, but it's a failsafe in case some perflib shuts this off on us
    // during processing
    // ========================================================================

    SetErrorMode( SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );

    HRESULT hr = WBEM_S_NO_ERROR;

    // Free the library if it has been previously loaded
    // =================================================

    if ( NULL != m_hLib )
    {
        try 
        {
            FreeLibrary( m_hLib );
        } 
        catch (...)
        {
            hr = WBEM_E_CRITICAL_ERROR;            
        }        
    }

    // Load the predefined library
    // ===========================

    if ( SUCCEEDED( hr ) )
    {
        try
        {
            m_hLib = LoadLibraryExW( m_pwcsLibrary, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
        }
        catch(...)
        {
            hr = WBEM_E_CRITICAL_ERROR;
        }
    }

    if ( SUCCEEDED( hr ) && ( NULL != m_hLib ) )
    {
    
        DEBUGTRACE( ( LOG_WMIADAP, "** %S Library Loaded.\n", m_wstrServiceName ) );

        char    szName[256];
        DWORD Last1 = 0;
        DWORD Last2 = 0;
        DWORD Last3 = 0;


        // Get the entry point addresses. No Wide version of GetProcAddress?  sigh... 
        // ==========================================================================

        if ( NULL != m_pwcsOpenProc )
        {
            if (0 != WideCharToMultiByte( CP_ACP, 0L, m_pwcsOpenProc, lstrlenW( m_pwcsOpenProc ) + 1,
                szName, sizeof(szName), NULL, NULL ))
            {
                m_pfnOpenProc = (PM_OPEN_PROC*) GetProcAddress( m_hLib, szName );
            }
            Last1 = GetLastError();
        }

        if (0 != WideCharToMultiByte( CP_ACP, 0L, m_pwcsCollectProc, lstrlenW( m_pwcsCollectProc ) + 1,
            szName, sizeof(szName), NULL, NULL ))
        {
            m_pfnCollectProc = (PM_COLLECT_PROC*) GetProcAddress( m_hLib, szName );
        }
        Last2 = GetLastError();

        if ( NULL != m_pwcsCloseProc )
        {
            if (0 != WideCharToMultiByte( CP_ACP, 0L, m_pwcsCloseProc, lstrlenW( m_pwcsCloseProc ) + 1,
                szName, sizeof(szName), NULL, NULL ))
            {
                m_pfnCloseProc = (PM_CLOSE_PROC*) GetProcAddress( m_hLib, szName );
            }
            Last3 = GetLastError();
        }

        if ( ( ( ( NULL != m_pwcsOpenProc ) && ( NULL != m_pfnOpenProc) ) || ( NULL == m_pwcsOpenProc ) ) &&
                 ( NULL != m_pfnCollectProc ) &&
             ( ( ( NULL != m_pwcsCloseProc ) && ( NULL != m_pfnCloseProc ) ) || ( NULL == m_pwcsCloseProc ) ) )
        {
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            ERRORTRACE( ( LOG_WMIADAP, "A performance library function in %S failed to load.\n",(LPWSTR)m_wstrServiceName) );

            WString wstr;
            wstr += L"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\";
            wstr += m_wstrServiceName;
            
            if ( ( NULL != m_pwcsOpenProc ) && ( NULL == m_pfnOpenProc ) )
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                           WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                            (LPCWSTR)wstr, Last1 );
                
            }
            else if ( NULL == m_pfnCollectProc )
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                           WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                            (LPCWSTR)wstr, Last2 );
                
            }
            else if (( NULL != m_pwcsCloseProc ) && ( NULL == m_pfnCloseProc ))
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                           WBEM_MC_ADAP_PERFLIB_REG_VALUE_FAILURE, 
                                            (LPCWSTR)wstr, Last3 );
                
            }

            SetStatus( ADAP_PERFLIB_FAILED );

            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        // If the library fails to load, then send an event, but do not charge a strike
        // ============================================================================

        ERRORTRACE( ( LOG_WMIADAP, "The performance library for %S failed to load.\n",(LPWSTR)m_wstrServiceName ) );
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_BAD_LIBRARY, m_pwcsLibrary, CHex( hr ) );

        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CAdapPerfLib::GetBlob( PERF_OBJECT_TYPE** ppPerfBlock, DWORD* pdwNumBytes, DWORD* pdwNumObjects, BOOL fCostly )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( m_fOpen )
    {
        hr = m_pPerfThread->GetPerfBlock( this, ppPerfBlock, pdwNumBytes, pdwNumObjects, fCostly );
    }

    if ( FAILED( hr ) ) 
    {
        if (!m_EventLogCalled){
            //
            //
            //WBEM_MC_ADAP_BAD_PERFLIB_BAD_RETURN
            //
            m_EventLogCalled = TRUE;
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_BAD_RETURN , (LPCWSTR)m_wstrServiceName, CHex( hr ) );
            
        }

    }

    return hr;
}

HRESULT CAdapPerfLib::Close()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( m_fOpen )
    {
        m_pPerfThread->Close( this ); 
    }

    return hr;
}

HRESULT CAdapPerfLib::Cleanup()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Terminate the worker thread
    // ===========================

    if ( NULL != m_pPerfThread )
        m_pPerfThread->Shutdown();

    // Adjust the status
    // =================

    EndProcessingStatus();

    return hr;
}

HRESULT CAdapPerfLib::_Open( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Wraps a call to the perflib's open function.  Fetches and passes an exports parameter
//  to the open function if it exists.
//
//  Note: We should use the named mutex to guard around the calls to Open/Collect/Close
//  
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Check to ensure that the library has not yet been opened
    // ========================================================

    if ( ( !m_fOpen ) && SUCCEEDED ( hr ) )
    {
        CNTRegistry reg;    // The registry wrapper class

        // Build the service path
        // ======================

        WString     wstr = L"SYSTEM\\CurrentControlSet\\Services\\";
        wstr += m_wstrServiceName;

        // Open the registry
        // =================

        if ( reg.Open( HKEY_LOCAL_MACHINE, wstr ) == CNTRegistry::no_error )
        {
            WCHAR*  pwcsExports = NULL;

            // Get Exports if they are available. 
            // ==============================================================

            if ( reg.MoveToSubkey( L"Linkage" ) == CNTRegistry::no_error )
            {
                DWORD   dwNumBytes = 0;

                if (CNTRegistry::no_error != reg.GetMultiStr( L"Export", &pwcsExports, dwNumBytes ))
                {
                    if ( ERROR_FILE_NOT_FOUND == reg.GetLastError())
                    {
                        // Linkage with no Export, that is OK
                    }
                    else
                    {
                        ERRORTRACE((LOG_WMIADAP,"Serivce %S has a non MSDN compliant or invalid Linkage Key\n",(WCHAR *)m_wstrServiceName));
                        if (CNTRegistry::no_error != reg.GetStr( L"Export", &pwcsExports))
                        {
                            pwcsExports = new WCHAR[2];
                            if (pwcsExports)
                            {
                                pwcsExports[0] = 0;
                                pwcsExports[1] = 0;
                            }
                        }
                    }
                }
            }

            // Call the Open function for the perflib
            // ======================================

            switch ( WaitForSingleObject( m_hPLMutex, PL_TIMEOUT ) )
            {
            case WAIT_OBJECT_0:
                {
                    try 
                    {
                        if ( NULL != m_pfnOpenProc )
                        {
                            LONG lRes = m_pfnOpenProc( pwcsExports );
                            if (lRes == ERROR_SUCCESS )
                            {
                                hr = WBEM_S_NO_ERROR;
                                m_fOpen = TRUE;
                            }
                            else
                            {
                                SetStatus( ADAP_PERFLIB_IS_INACTIVE );
                                hr = WBEM_E_NOT_AVAILABLE;
                            }

                            DEBUGTRACE( ( LOG_WMIADAP, "Open called for %S returned %d\n", (LPCWSTR)m_wstrServiceName, lRes ) );
                        }
                        else
                        {
                            hr = WBEM_S_NO_ERROR;
                            m_fOpen = TRUE;
                        }
                    }
                    catch (...)
                    {
                        SetStatus( ADAP_PERFLIB_FAILED );
                        hr = WBEM_E_FAILED;
                        ERRORTRACE( ( LOG_WMIADAP, "Perflib Open function has thrown an exception in %S.\n",(LPWSTR)m_wstrServiceName) );
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_EXCEPTION, (LPCWSTR)m_wstrServiceName, CHex( hr ) );
                    }
                } break;
            case WAIT_TIMEOUT:
                {
                    hr = WBEM_E_NOT_AVAILABLE;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex timed out in %S.\n",(LPWSTR)m_wstrServiceName) );
                }break;
            case WAIT_ABANDONED:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex was abandoned in %S.\n",(LPWSTR)m_wstrServiceName) );
                }break;
            default:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Unknown error with perflib access mutex in %S.\n",(LPWSTR)m_wstrServiceName) );
                }
            } // switch

            ReleaseMutex( m_hPLMutex );

            if ( NULL != pwcsExports )
            {
                delete [] pwcsExports;
            }

        }   // IF reg.Open
        else
        {
            hr = WBEM_E_FAILED;
            ERRORTRACE( ( LOG_WMIADAP, "Could not open the %S registry key.\n", wstr ) );
        }
    }
    else
    {
        ERRORTRACE( ( LOG_WMIADAP, "Performance library %S has not been loaded.\n",(LPWSTR)m_wstrServiceName) );
    }

    return hr;
}

HRESULT CAdapPerfLib::_GetPerfBlock( PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Wraps a call to the perflib's collect function.  Will create progressively larger buffers
//  in a private heap to attempt to fetch the performance data block.
//
//  Parameters:
//      ppData          - a pointer to a buffer pointer for the data blob
//      pdwBytes        - a pointer to the byte-size of the data blob
//      pdwNumObjTypes  - a pointer to the number of objects in the data blob
//      fCostly         - a flag to determine what type of data to collect (costly or global)
//
//  NOTE: This should always return perf object type data, since we cannot specify a 
//  foreign computer, which would cause the collect function to return a PERF_DATA_BLOCK 
//  structure.
//  
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CAdapSafeBuffer SafeBuffer( m_wstrServiceName );    // The safe buffer
    DWORD   dwNumBytes = 0;                             // Byte counter for the buffer size
    DWORD   dwError = ERROR_MORE_DATA;                  // The return value for the collect function
    DWORD   Increment = 0x10000;

    // this is a workaround for perfproc.dll
    if (0 == wbem_wcsicmp(m_wstrServiceName,L"perfproc"))
    {
        Increment = 0x100000;    
    }



    // Verify provider status 
    // ======================

    if ( m_fOpen )
    {
        // Sets the data-to-fetch parameter
        // ================================

        WCHAR*  pwcsValue = ( fCostly ? L"Costly" : L"Global" );
        
        // Start buffer at 64k (the guarded (safe) buffer is 2 * GUARD_BLOCK bytes smaller) 
        // ==================================================================================

        dwNumBytes = Increment;

        // Repeatedly attempt to collect the data until successful (buffer is sufficiently 
        // large), or the attempt fails for a reason other than buffer size
        // ===============================================================================

        while  ( (ERROR_MORE_DATA == dwError ) && ( SUCCEEDED( hr ) ) )
        {
            // Allocate a raw buffer of size dwNumBytes
            // ========================================
            if (dwNumBytes > s_MaxSizeCollect)
            {
                ERRORTRACE((LOG_WMIADAP,"Library %S: Collect function requires more than 0x%08x bytes to complete",(WCHAR *)m_wstrServiceName,s_MaxSizeCollect));
                m_CollectOK = FALSE;
                hr = WBEM_E_QUOTA_VIOLATION;
                break;
            }
            hr = SafeBuffer.SetSize( dwNumBytes );
            if (FAILED(hr)) break;

            // Collect the data from the perflib
            // =================================

            switch ( WaitForSingleObject( m_hPLMutex, PL_TIMEOUT ) )
            {
            case WAIT_OBJECT_0:
                {
                    try 
                    {
                        dwError = m_pfnCollectProc( pwcsValue,                                  
                                    SafeBuffer.GetSafeBufferPtrPtr(), 
                                    SafeBuffer.GetDataBlobSizePtr(), 
                                    SafeBuffer.GetNumObjTypesPtr() );

                        DEBUGTRACE( ( LOG_WMIADAP, "Collect called for %S returned %d\n", (LPCWSTR)m_wstrServiceName, dwError ) );
                    }
                    catch (...) 
                    {
                        SetStatus( ADAP_PERFLIB_FAILED );
                        hr = WBEM_E_FAILED;
                        
                        ERRORTRACE( ( LOG_WMIADAP, "Perflib Collection function has thrown an exception in %S.\n",(LPCWSTR)m_wstrServiceName) );
                        if (!m_EventLogCalled){
                            m_EventLogCalled = TRUE;
                            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_EXCEPTION, (LPCWSTR)m_wstrServiceName, CHex( dwError ) );
                            
                        }
                    }
                }break;
            case WAIT_TIMEOUT:
                {
                    hr = WBEM_E_NOT_AVAILABLE;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex timed out in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }break;
            case WAIT_ABANDONED:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex was abandoned in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }break;
            default:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Unknown error with perflib access mutex in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }
            } // switch

            ReleaseMutex( m_hPLMutex );

            if ( SUCCEEDED( hr ) )
            {
                switch (dwError)
                {
                case ERROR_SUCCESS:
                    {
                        //
                        //  the Validate function can call ReportEvent 
                        //  by itself, and we don't want to bother user too much
                        //
                        hr = SafeBuffer.Validate(&m_EventLogCalled);

                        if ( SUCCEEDED( hr ) )
                        {
                            hr = SafeBuffer.CopyData( (BYTE**) ppData, pdwBytes, pdwNumObjTypes );
                        }
                        else
                        {
                            // Catastrophic error has occured
                            // ==============================

                            SetStatus( ADAP_PERFLIB_FAILED );

                            if (!m_EventLogCalled)
                            {
                                m_EventLogCalled = TRUE;
                                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                                          WBEM_MC_ADAP_BAD_PERFLIB_INVALID_DATA,
                                                          (LPCWSTR)m_wstrServiceName,
                                                          CHex(hr));
                                
                            }
                        }
                    } break;
                case ERROR_MORE_DATA:
                    {
                        dwNumBytes += Increment;
                    } break;
                default:
                    {
                        hr = WBEM_E_FAILED;
                        
                        m_CollectOK = FALSE;
                        
                        ERRORTRACE( ( LOG_WMIADAP, "Perflib Collection function has returned an unknown error(%d) in %S.\n", dwError,(LPCWSTR)m_wstrServiceName ) );
                        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_BAD_RETURN, (LPCWSTR)m_wstrServiceName, CHex( dwError ) );
                    }
                } // switch
            } // IF SUCCEEDED()
        } // WHILE

        // Clean up the buffer
        // ===================
    } // IF CheckStatus
    else
    {
        ERRORTRACE( ( LOG_WMIADAP, "Performance library %S has not been loaded.\n",(LPCWSTR)m_wstrServiceName) );
    }

    return hr;
}

HRESULT CAdapPerfLib::_Close( void )
////////////////////////////////////////////////////////////////////////////////////////////
// 
//  Wraps a call to the perflib's close function.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Verify that the perflib is actually open
    // ========================================

    if ( m_fOpen )
    {
        // Get the mutex
        // =============

        switch ( WaitForSingleObject( m_hPLMutex, PL_TIMEOUT ) )
        {
        case WAIT_OBJECT_0:
            {
                try
                {
                    // And call the function
                    // =====================

                    if ( NULL != m_pfnCloseProc )
                    {
                        LONG lRet = m_pfnCloseProc();

                        DEBUGTRACE( ( LOG_WMIADAP, "Close called for %S returned %d\n", (LPCWSTR)m_wstrServiceName, lRet ) );
                    }

                    m_fOpen = FALSE;
                }
                catch (...)
                {
                    // Ooops... something blew, return error code
                    // ==========================================

                    SetStatus( ADAP_PERFLIB_FAILED );
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib Close function has thrown an exception in %S.\n",(LPCWSTR)m_wstrServiceName) );
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_EXCEPTION, (LPCWSTR)m_wstrServiceName, CHex( hr ) );
                }
            }break;
            case WAIT_TIMEOUT:
                {
                    hr = WBEM_E_NOT_AVAILABLE;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex timed out in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }break;
            case WAIT_ABANDONED:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Perflib access mutex was abandoned in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }break;
            default:
                {
                    hr = WBEM_E_FAILED;
                    ERRORTRACE( ( LOG_WMIADAP, "Unknown error with perflib access mutex in %S.\n",(LPCWSTR)m_wstrServiceName) );
                }       }

        ReleaseMutex( m_hPLMutex );
    }

    return hr;
}

HRESULT CAdapPerfLib::SetStatus(DWORD dwStatus)
{
    HRESULT hr = WBEM_NO_ERROR;

    m_dwStatus |= dwStatus;

    return hr;
}

HRESULT CAdapPerfLib::ClearStatus(DWORD dwStatus)
{
    HRESULT hr = WBEM_NO_ERROR;

    m_dwStatus &= ~dwStatus;

    return hr;
}

BOOL CAdapPerfLib::CheckStatus(DWORD dwStatus)
{
    return ((m_dwStatus & dwStatus) == dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adapthrd.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPTHRD.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <process.h>
#include <wbemcli.h>
#include <cominit.h>
#include "ntreg.h"
#include "adapthrd.h"

//  IMPORTANT!!!!

//  This code MUST be revisited to do the following:
//  A>>>>>  Exception Handling around the outside calls
//  B>>>>>  Use a named mutex around the calls
//  C>>>>>  Make the calls on another thread
//  D>>>>>  Place and handle registry entries that indicate a bad DLL!

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapThreadRequest
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapThreadRequest::CAdapThreadRequest( void )
:   m_hWhenDone( NULL ),
    m_hrReturn( WBEM_S_NO_ERROR )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
}

CAdapThreadRequest::~CAdapThreadRequest( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    if (m_hWhenDone ) CloseHandle( m_hWhenDone );
}

HRESULT CAdapThreadRequest::EventLogError( void )
{
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CAdapThread
//
////////////////////////////////////////////////////////////////////////////////////////////

CAdapThread::CAdapThread( CAdapPerfLib* pPerfLib )
:   m_pPerfLib( pPerfLib ),
    m_hEventQuit( NULL ),
    m_hSemReqPending( NULL ),
    m_hThread( NULL ),
    m_fOk( FALSE )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    // Initialize the control members
    // ==============================

    Init();
}

CAdapThread::~CAdapThread()
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Destructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    if ( NULL != m_hThread )
    {
        Shutdown();
    }

    Clear();

    // Clean up the queue
    // ==================

    while ( m_RequestQueue.Size() > 0 )
    {
        CAdapThreadRequest* pRequest = (CAdapThreadRequest*) m_RequestQueue.GetAt( 0 );

        if ( NULL != pRequest )
        {
            pRequest->Release();
        }

        m_RequestQueue.RemoveAt( 0 );       
    }
}

BOOL CAdapThread::Init( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Initializes the control variables
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    if ( !m_fOk )
    {
        if ( ( m_hEventQuit = CreateEvent( NULL, TRUE, FALSE, NULL ) ) != NULL )
        {
            if ( ( m_hSemReqPending = CreateSemaphore( NULL, 0, 0x7FFFFFFF, NULL ) ) != NULL )
            {
                if ( ( m_hThreadReady = CreateEvent( NULL, TRUE, FALSE, NULL ) ) != NULL )
                {
                    m_fOk = TRUE;
                }
            }
        }
    }

    if ( !m_fOk )
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapThread::Init() failed.\n" ) );
    }

    return m_fOk;
}

BOOL CAdapThread::Clear( BOOL fClose )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Clears the control variables and thread variables
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    CInCritSec  ics(&m_cs);

    // Don't close the handles unless we've been told to.

    m_fOk = FALSE;
    
    if ( NULL != m_hEventQuit )
    {
        if ( fClose )
        {
            CloseHandle( m_hEventQuit );
        }

        m_hEventQuit = NULL;
    }

    if ( NULL != m_hSemReqPending )
    {
        if ( fClose )
        {
            CloseHandle( m_hSemReqPending );
        }

        m_hSemReqPending = NULL;
    }

    if ( NULL != m_hThread )
    {
        if ( fClose )
        {
            CloseHandle( m_hThread );
        }

        m_hThread = NULL;
    }

    m_dwThreadId = 0;

    return TRUE;
}

HRESULT CAdapThread::Enqueue( CAdapThreadRequest* pRequest )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Add a request to the request queue
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;
    
    // Ensure that the thread has started
    // ==================================

    hr = Begin();
    
    if ( SUCCEEDED( hr ) )
    {
        // We will use a new one for EVERY operation
        HANDLE  hEventDone = CreateEvent( NULL, TRUE, FALSE, NULL );

        if ( NULL != hEventDone )
        {
            // Let the request know about the new event handle
            // ===========================================

            pRequest->SetWhenDoneHandle( hEventDone );

            // Auto-lock the queue
            // ===================

            CInCritSec  ics( &m_cs );

            try
            {
                // Add the request to the queue 
                // ============================
        
                if (CFlexArray::no_error == m_RequestQueue.Add( (void*) pRequest ))
                    pRequest->AddRef();
                else
                    hr = WBEM_E_OUT_OF_MEMORY;
                
                ReleaseSemaphore( m_hSemReqPending, 1, NULL );
            }
            catch(...)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

HRESULT CAdapThread::Begin( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  If the thread has not already started, then intializes the control variables, and starts 
//  the thread.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Verify that the thread does not already exist
    // =============================================

    if ( NULL == m_hThread )
    {
        // Coping will enter and exit the critical section
        CInCritSec  ics( &m_cs );

        // Double check the thread handle here in case somebody fixed us up while we were
        // waiting on the critical section.

        if ( NULL == m_hThread )
        {

            // Initialize the control variables
            // ================================

            if ( Init() )
            {
                // Makes sure the pending event semaphore is signalled once for each entry in the queue
                // ====================================================================================

                if ( m_RequestQueue.Size() > 0 )
                {
                    ReleaseSemaphore( m_hSemReqPending, m_RequestQueue.Size(), NULL );
                }

                // Start the thread
                // ================

                m_hThread = (HANDLE) _beginthreadex( NULL, 0, CAdapThread::ThreadProc, (void*) this,
                                        0, (unsigned int *) &m_dwThreadId );

                if ( NULL == m_hThread )
                {
                    hr = WBEM_E_FAILED;
                }
                else
                {
                    if ( WAIT_OBJECT_0 != WaitForSingleObject( m_hThreadReady, 60000 ) )
                    {
                        hr = WBEM_E_FAILED;
                        ERRORTRACE( ( LOG_WMIADAP, "Worker thread for %S could not be verified.\n", (LPCWSTR)m_pPerfLib->GetServiceName() ) );          
                        SetEvent( m_hEventQuit );
                    }
                    else
                    {
                        DEBUGTRACE( ( LOG_WMIADAP, "Worker thread for %S is 0x%x\n", (LPCWSTR)m_pPerfLib->GetServiceName(), m_dwThreadId ) );
                    }
                }
            }   
            else
            {
                hr = WBEM_E_FAILED;
            }

        }   // IF NULL == m_hThread

    }

    if ( FAILED( hr ) )
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapThread::Begin() failed: %X.\n", hr ) );
    }

    return hr;
}

unsigned CAdapThread::ThreadProc( void * pVoid )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  This is the static entry point fo the worker thread.  It addref's the thread's perflib
//  (see comment below) and then calls the objects processing method.
//
////////////////////////////////////////////////////////////////////////////////////////////

{
    unsigned uRet;

    try
    {
        // The calling object
        // ==================

        CAdapThread* pThis = (CAdapThread*) pVoid;

        // The perflib to be processed
        // ===========================

        CAdapPerfLib* pPerfLib = pThis->m_pPerfLib;

        // In an attempt to avoid circular references, we are addrefing the performance library wrapper
        // instead of the thread object.  The thread object will be destructed by the perflib wrapper 
        // only after the final reference is released.  This thread is dependent on the perflib, but is 
        // by the thread wrapper.  As a result, when the thread has completed processing, if we indicate 
        // that we are finished with the perflib by releasing the perflib wrapper, then the thread wrapper 
        // may destroyed at the same time.  Note the use of auto-release.

        if ( NULL != pPerfLib )
            pPerfLib->AddRef();

        CAdapReleaseMe arm( pPerfLib );

        // Call the processing method
        // ==========================

        uRet = pThis->RealEntry();
    }
    catch(...)
    {
        // <Gasp> We have been betrayed... try to write something to the error log
        // =======================================================================

        CriticalFailADAPTrace( "An unhandled exception has been thrown in a worker thread." );
    
        uRet = ERROR_OUTOFMEMORY;
    }

    return uRet;
}

unsigned CAdapThread::RealEntry( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  This is the method that contains the loop that processes the requests.  While there
//  are requests in the queue and the thread has not been instructed to terminate, then
//  grab a request and execute it.  When the request has completed, then signal the completion
//  event to tell the originating thread that the request has been satisfied.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HANDLE  ahEvents[2];

    // Use local copies of these in case we have some timing issue in which we get destructed
    // on another thread, but for some reason this guy keeps going.

    HANDLE  hPending = m_hSemReqPending,
            hQuit = m_hEventQuit;

    ahEvents[0] = hPending;
    ahEvents[1] = hQuit;

    DWORD   dwWait = 0;
    DWORD   dwReturn = 0;

    // Signal that everything is OK and we are ready to rock!
    // ======================================================

    if ( SetEvent( m_hThreadReady ) )
    {
        // If the m_hEventQuit event is signaled, or if it runs into a bizarre error,
        // exit loop, otherwise continue as long as there is requests in the queue
        // ==========================================================================

        while ( ( dwWait = WaitForMultipleObjects( 2, ahEvents, FALSE,  INFINITE ) ) == WAIT_OBJECT_0 )
        {
            // Check for the quit event, since if both events are signalled, we'll let this
            // guy take precedence
            if ( WaitForSingleObject( hQuit, 0 ) == WAIT_OBJECT_0 )
            {
                break;
            }

            // Get the next request from of the FIFO queue
            // ===========================================

            m_cs.Enter();
            CAdapThreadRequest* pRequest = (CAdapThreadRequest*) m_RequestQueue.GetAt( 0 );
            CAdapReleaseMe  armRequest( pRequest );

            m_RequestQueue.RemoveAt( 0 );
            m_cs.Leave();

            // Execute it
            // ==========

            dwReturn = pRequest->Execute( m_pPerfLib );

            // Fire the completion event
            // ==========================

            if ( NULL != pRequest->GetWhenDoneHandle() )
            {
                SetEvent( pRequest->GetWhenDoneHandle() );
            }
        }

        DEBUGTRACE( ( LOG_WMIADAP, "Thread 0x%x for %S is terminating\n", m_dwThreadId, (LPCWSTR)m_pPerfLib->GetServiceName() ) );

        // If the exit condition is not due to a signaled m_hEventQuit, then evaluate error
        // ================================================================================

        if ( WAIT_FAILED == dwWait )
        {
            dwReturn = GetLastError();
        }
    }

    if ( ERROR_SUCCESS != dwReturn )
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapThread::RealEntry() for %S failed: %X.\n", (LPCWSTR)m_pPerfLib->GetServiceName(), dwReturn ) );
    }

    return dwReturn;
}

HRESULT CAdapThread::Shutdown( DWORD dwTimeout )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Performs a gentle shutdown of the thread by signaling the exit event.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    // Make sure that we are not killing ourself
    // =========================================

    if ( ( NULL != m_hThread ) && ( GetCurrentThreadId() != m_dwThreadId ) )
    {
        SetEvent( m_hEventQuit );
        DWORD   dwWait = WaitForSingleObject( m_hThread, dwTimeout );

        switch ( dwWait )
        {
        case WAIT_OBJECT_0:
            {
                m_hThread = NULL;
                hr = WBEM_S_NO_ERROR;
            }break;
        case WAIT_TIMEOUT:
            {
                hr = WBEM_E_FAILED;
            }break;
        default:
            {
                hr = WBEM_E_FAILED;
            }
        }

        if ( FAILED( hr ) )
        {
            ERRORTRACE( ( LOG_WMIADAP, "CAdapThread::Shutdown() failed.\n" ) );
        }
    }
    else
    {
        hr = WBEM_S_FALSE;
    }

    return hr;
}

HRESULT CAdapThread::Reset( void )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  This function will be called if a thread apparently got eaten, in which case, we're
//  not sure if it will come back or not.  So, we will clear our member data (not close anything)
//  and kick off a new processing thread.  Please note that this could leak handles, but then again,
//  it looks like somebody ate a thread, so there are other potential problems afoot here.
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Signal the quit event so if the thread that is executing ever returns it will know to drop
    // out.  Clear can then rid us of the appropriate handles so we can start all over again.
    SetEvent( m_hEventQuit );

    // Scoping will enter and exit the critical section, so if anyone tries to enqueue any requests
    // while we are executing, we don't step all over each other.

    CInCritSec  ics( &m_cs );

    // Clear shouldn't close the handles
    Clear( FALSE );

    if ( Init() )
    {
        hr = Begin();
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    if ( FAILED( hr ) )
    {
        ERRORTRACE( ( LOG_WMIADAP, "CAdapThread::Reset() failed: %X.\n", hr ) );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adapperf.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPPERF.H

Abstract:

History:

--*/

// Use this guy to build a map of index to display name from a localized
// Name Database  At this time, it just brute forces a class and a flex
// array, but could be modified to use an STL map just as easily.

#ifndef __ADAPPERF_H__
#define __ADAPPERF_H__

#include <wbemcomn.h>
#include "adapelem.h"
#include "ntreg.h"
#include "perfthrd.h"
#include "perflibschema.h"

// Registry definitions
// ====================

#define ADAP_PERFLIB_STATUS_KEY		L"WbemAdapStatus"
#define ADAP_PERFLIB_SIGNATURE		L"WbemAdapFileSignature"
#define ADAP_PERFLIB_SIZE           L"WbemAdapFileSize"
#define ADAP_PERFLIB_TIME           L"WbemAdapFileTime"

#define KNOWN_SERVICES              L"KnownSvcs"
#define ADAP_TIMESTAMP_FULL         L"LastFullDredgeTimestamp"

#define ADAP_PERFLIB_LASTCHANCE    3L
#define ADAP_PERFLIB_BOOBOO		   2L
#define ADAP_PERFLIB_PROCESSING	   1L
#define	ADAP_PERFLIB_OK			   0L
#define ADAP_PERFLIB_CORRUPT	  -1L

// Run time definitions
// ====================

#define ADAP_PERFLIB_IS_OK					0x0000L
#define ADAP_PERFLIB_IS_CORRUPT				0x0001L
#define ADAP_PERFLIB_IS_INACTIVE			0x0002L
#define ADAP_PERFLIB_FAILED					0x0004L
#define ADAP_PERFLIB_PREVIOUSLY_PROCESSED	0x0008L
#define ADAP_PERFLIB_IS_LOADED              0x0010L
#define ADAP_PERFLIB_IS_UNAVAILABLE	ADAP_PERFLIB_IS_CORRUPT | ADAP_PERFLIB_IS_INACTIVE // | ADAP_PERFLIB_IS_UNLOADED

// others
// the library has NO FirstCounter/LastCounter key
#define EX_STATUS_UNLOADED      0 
// the library has al least FirstCounter/LastCounter key
#define EX_STATUS_LOADABLE      1 
// the library has a Collect Function that fails
#define EX_STATUS_COLLECTFAIL   2 

typedef struct tagCheckLibStruct {
    BYTE Signature[16];
    FILETIME FileTime;
    DWORD FileSize;
} CheckLibStruct;

class CAdapSafeBuffer
{
	HANDLE	m_hPerfLibHeap;		// A handle to the private heap for the data block
	
	DWORD	m_dwGuardSize;

	BYTE*	m_pRawBuffer;

	BYTE*	m_pSafeBuffer;
	DWORD	m_dwSafeBufferSize;

	BYTE*	m_pCurrentPtr;
	DWORD	m_dwDataBlobSize;
	DWORD	m_dwNumObjects;

	HRESULT ValidateSafePointer( BYTE* pPtr );

	WString m_wstrServiceName;

	static BYTE s_pGuardBytes[];

public:
	CAdapSafeBuffer( WString wstrServiceName );
	virtual ~CAdapSafeBuffer();

	HRESULT SetSize( DWORD dwNumBytes );
	HRESULT Validate(BOOL * pSentToEventLog);
	HRESULT CopyData( BYTE** ppData, DWORD* pdwNumBytes, DWORD* pdwNumObjects );

	void** GetSafeBufferPtrPtr() { m_pCurrentPtr = m_pSafeBuffer; return (void**) &m_pCurrentPtr; }
	DWORD* GetDataBlobSizePtr() { m_dwDataBlobSize = m_dwSafeBufferSize; return &m_dwDataBlobSize; }
	DWORD* GetNumObjTypesPtr() {m_dwNumObjects = 0; return &m_dwNumObjects; }
};

class CPerfThread;
class CPerfLibSchema;

class CAdapPerfLib : public CAdapElement
{
private:

	CPerfThread*		m_pPerfThread;
	BOOL                m_EventLogCalled;
	BOOL                m_CollectOK;

	WString				m_wstrServiceName;	// The service name of the perflib
	WCHAR*				m_pwcsLibrary;		// The file name of the perflib
	WCHAR*				m_pwcsOpenProc;		// The name of the perflib's open function
	WCHAR*				m_pwcsCollectProc;	// The name of the perflib's collect function
	WCHAR*				m_pwcsCloseProc;	// The name of the perflib's close function

	PM_OPEN_PROC*		m_pfnOpenProc;		// The function pointer to the perflib's open function
	PM_COLLECT_PROC*	m_pfnCollectProc;	// The function pointer to the perflib's collect function
	PM_CLOSE_PROC*		m_pfnCloseProc;		// The function pointer to the perflib's close function
	HANDLE				m_hPLMutex;			// Used for serializing the calls to open/collect/close

	HRESULT				m_dwStatus;			// The status of the perflib
	BOOL				m_fOK;
	BOOL				m_fOpen;			// Flags whether the perflib's open function has been called

	HINSTANCE			m_hLib;				// The handle to the perflib

	DWORD               m_dwFirstCtr;
	DWORD               m_dwLastCtr;

	HRESULT	Load(void);

protected:
	HRESULT InitializeEntryPoints(CNTRegistry & reg,WString & wszRegPath);

	HRESULT BeginProcessingStatus();
	HRESULT EndProcessingStatus();

	HRESULT GetFileSignature( CheckLibStruct * pCheckLib );
	HRESULT SetFileSignature();
	HRESULT CheckFileSignature();


	HRESULT VerifyLoaded();

public:
	CAdapPerfLib( LPCWSTR pwcsServiceName, DWORD * pLoadStatus );
	~CAdapPerfLib();

    DWORD GetFirstCtr(){ return m_dwFirstCtr; };
	DWORD GetLastCtr(){  return m_dwLastCtr; }

	HRESULT _Open( void );
	HRESULT	_Close( void );
	HRESULT	_GetPerfBlock( PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly );

	HRESULT Initialize(); 
	HRESULT Close();
	HRESULT Cleanup();

	BOOL IsOK( void )
	{
		return m_fOK;
	}

	LPCWSTR GetServiceName( void )
	{
		return m_wstrServiceName;
	}

	LPCWSTR GetLibraryName( void )
	{
		return m_pwcsLibrary;
	}

	HRESULT GetBlob( PERF_OBJECT_TYPE** ppPerfBlock, DWORD* pdwNumBytes, DWORD* pdwNumObjects, BOOL fCostly );

	HRESULT SetStatus( DWORD dwStatus );
	HRESULT ClearStatus( DWORD dwStatus );
	BOOL CheckStatus( DWORD dwStatus );
	BOOL IsCollectOK( void ){ return m_CollectOK; };
	BOOL GetEventLogCalled(){ return m_EventLogCalled; };
	void SetEventLogCalled(BOOL bVal){ m_EventLogCalled = bVal; };

	static DWORD        s_MaxSizeCollect; 	
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adaputil.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPUTIL.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wtypes.h>
#include <oleauto.h>
#include <winmgmtr.h>
#include "AdapUtil.h"

HRESULT CAdapUtility::NTLogEvent( DWORD dwEventType,
                                  DWORD dwEventID, 
                                  CInsertionString c1,
                                  CInsertionString c2,
                                  CInsertionString c3,
                                  CInsertionString c4,
                                  CInsertionString c5,
                                  CInsertionString c6,
                                  CInsertionString c7,
                                  CInsertionString c8,
                                  CInsertionString c9,
                                  CInsertionString c10 )
{
    HRESULT hr = WBEM_E_FAILED;
    CEventLog el;

    if ( el.Open() )
    {
        if ( el.Report( dwEventType, dwEventID, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10 ) )
        {
            hr = WBEM_NO_ERROR;
        }
    }

    el.Close();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\adaputil.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ADAPUTIL.H

Abstract:

History:

--*/


#ifndef _ADAPUTIL_H_
#define _ADAPUTIL_H_

#include "CWbemTime.h"
#include <wstring.h>
#include <flexarry.h>
#include <arrtempl.h>
#include <evtlog.h>
#include <wbemidl.h>
#include <wbemutil.h>
#include "Adapperf.h"

class CAdapUtility
{
public:
    static HRESULT NTLogEvent(DWORD dwEventType,
							  DWORD dwEventID,
                              CInsertionString c1 = CInsertionString(),
                              CInsertionString c2 = CInsertionString(),
                              CInsertionString c3 = CInsertionString(),
                              CInsertionString c4 = CInsertionString(),
                              CInsertionString c5 = CInsertionString(),
                              CInsertionString c6 = CInsertionString(),
                              CInsertionString c7 = CInsertionString(),
                              CInsertionString c8 = CInsertionString(),
                              CInsertionString c9 = CInsertionString(),
                              CInsertionString c10 = CInsertionString() );

};

#endif  //_ADAPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\classbroker.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    CLASSBROKER.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <objbase.h>
#include <oaidl.h>
#include <winmgmtr.h>
#include "adaputil.h"
#include "classbroker.h"

#include <comdef.h>

struct _CookingTypeRec
{
    DWORD dwType;
    WCHAR wcsName[128];
}
g_aCookingRecs[] =
{
    0x00000000, L"PERF_COUNTER_RAWCOUNT_HEX",
    0x00000100,    L"PERF_COUNTER_LARGE_RAWCOUNT_HEX",
    0x00000B00, L"PERF_COUNTER_TEXT",
    0x00010000,    L"PERF_COUNTER_RAWCOUNT",
    0x00010100, L"PERF_COUNTER_LARGE_RAWCOUNT",
    0x00012000, L"PERF_DOUBLE_RAW",
    0x00400400,    L"PERF_COUNTER_DELTA",
    0x00400500,    L"PERF_COUNTER_LARGE_DELTA",
    0x00410400,    L"PERF_SAMPLE_COUNTER",
    0x00450400, L"PERF_COUNTER_QUEUELEN_TYPE",
    0x00450500, L"PERF_COUNTER_LARGE_QUEUELEN_TYPE",
    0x00550500,    L"PERF_COUNTER_100NS_QUEUELEN_TYPE",
    0x00650500, L"PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE",
    0x10410400,    L"PERF_COUNTER_COUNTER",
    0x10410500,    L"PERF_COUNTER_BULK_COUNT",
    0x20020400, L"PERF_RAW_FRACTION",
    0x20410500,    L"PERF_COUNTER_TIMER",
    0x20470500,    L"PERF_PRECISION_SYSTEM_TIMER",
    0x20510500,    L"PERF_100NSEC_TIMER",
    0x20570500,    L"PERF_PRECISION_100NS_TIMER",
    0x20610500,    L"PERF_OBJ_TIME_TIMER",
    0x20670500, L"PERF_PRECISION_OBJECT_TIMER",
    0x20C20400,    L"PERF_SAMPLE_FRACTION",
    0x21410500,    L"PERF_COUNTER_TIMER_INV",
    0x21510500,    L"PERF_100NSEC_TIMER_INV",
    0x22410500, L"PERF_COUNTER_MULTI_TIMER",
    0x22510500,    L"PERF_100NSEC_MULTI_TIMER",
    0x23410500,    L"PERF_COUNTER_MULTI_TIMER_INV",
    0x23510500, L"PERF_100NSEC_MULTI_TIMER_INV",
    0x30020400,    L"PERF_AVERAGE_TIMER",
    0x30240500,    L"PERF_ELAPSED_TIME",
    0x40000200, L"PERF_COUNTER_NODATA",
    0x40020500,    L"PERF_AVERAGE_BULK",
    0x40030401,    L"PERF_SAMPLE_BASE",
    0x40030402, L"PERF_AVERAGE_BASE",
    0x40030403, L"PERF_RAW_BASE",
    0x40030500, L"PERF_PRECISION_TIMESTAMP",
    0x40030503,    L"PERF_LARGE_RAW_BASE",
    0x42030500,    L"PERF_COUNTER_MULTI_BASE",
    0x80000000,    L"PERF_COUNTER_HISTOGRAM_TYPE",
};

HRESULT GetCounterTypeString( DWORD dwType, WCHAR** pwcsString )
{
    HRESULT hRes = WBEM_E_NOT_FOUND;

    DWORD    dwLeft = 0,
            dwRight = sizeof( g_aCookingRecs ) / sizeof( _CookingTypeRec ),
            dwMid = ( dwLeft + dwRight ) / 2;

    while ( ( dwLeft <= dwRight ) && FAILED( hRes ) )
    {
        if ( g_aCookingRecs[dwMid].dwType < dwType )
        {
            dwLeft = dwMid + 1;
        }
        else if ( g_aCookingRecs[dwMid].dwType > dwType )
        {
            dwRight = dwMid - 1;
        }
        else
        {
            *pwcsString = g_aCookingRecs[dwMid].wcsName;
            hRes = WBEM_NO_ERROR;
            break;
        }

        dwMid = ( dwLeft + dwRight ) / 2;
    }

    return hRes;
}

///////////////////////////////////////////////////////////////////////////////
//
//                              CAdapPerfClassElem
//
///////////////////////////////////////////////////////////////////////////////

CClassBroker::CClassBroker( IWbemClassObject* pBaseClass, 
                            WString wstrClassName, 
                            CPerfNameDb* pDefaultNameDb )
:    m_pPerfObj( NULL ), 
    m_pBaseClass( pBaseClass ), 
    m_wstrClassName( wstrClassName ), 
    m_pDefaultNameDb( pDefaultNameDb )
{
    if ( NULL != m_pBaseClass )
        m_pBaseClass->AddRef();
    
    if ( NULL != m_pDefaultNameDb )
        m_pDefaultNameDb->AddRef();
}

CClassBroker::CClassBroker( PERF_OBJECT_TYPE* pPerfObj, 
                            BOOL bCostly, 
                            IWbemClassObject* pBaseClass, 
                            CPerfNameDb* pDefaultNameDb, 
                            WCHAR* pwcsServiceName ) 
:   m_pPerfObj( pPerfObj ), 
    m_bCostly( bCostly ),
    m_pBaseClass( pBaseClass ),
    m_pDefaultNameDb( pDefaultNameDb ),
    m_wstrServiceName( pwcsServiceName )
{
    if ( NULL != m_pBaseClass )
        m_pBaseClass->AddRef();

    if ( NULL != m_pDefaultNameDb )
        m_pDefaultNameDb->AddRef();
}

CClassBroker::~CClassBroker()
{
    if ( NULL != m_pBaseClass )
        m_pBaseClass->Release();

    if ( NULL != m_pDefaultNameDb )
        m_pDefaultNameDb->Release();
}

HRESULT CClassBroker::Generate( DWORD dwType, IWbemClassObject** ppObj )
///////////////////////////////////////////////////////////////////////////////
//
//    Generates a class based on the object BLOB passed in via the constructor
//
//    Parameters:
//        ppObj -        A pointer to the new class object interface pointer
//
///////////////////////////////////////////////////////////////////////////////
{
    IWbemClassObject*    pNewClass = NULL;

    // Create the new class
    // ====================
    HRESULT hr = m_pBaseClass->SpawnDerivedClass( 0L, &pNewClass );
    CReleaseMe  rmNewClass( pNewClass );

    // And initialize the data
    // =======================
    if ( SUCCEEDED( hr ) )
    {
        // Class name
        // ==========
        hr = SetClassName( dwType, pNewClass );

        // Class Qualifiers
        // ================
        if ( SUCCEEDED( hr ) )
        {
            hr = SetClassQualifiers( pNewClass, dwType, ( ADAP_DEFAULT_OBJECT == m_pPerfObj->ObjectNameTitleIndex ) );
        }

        // Standard Properties
        // ===================
        if ( SUCCEEDED( hr ) )
        {
            hr = AddDefaultProperties( pNewClass );
        }

        // Perf Counter Properties
        // =======================
        if ( SUCCEEDED( hr ) )
        {
            hr = EnumProperties( dwType, pNewClass );
        }

        // Return the class object interface
        // =================================
        if ( SUCCEEDED( hr ) )
        {
            hr = pNewClass->QueryInterface( IID_IWbemClassObject, (void**) ppObj );
        }
    }

    return hr;
}

HRESULT CClassBroker::SetClassName( DWORD dwType, IWbemClassObject* pClass )
///////////////////////////////////////////////////////////////////////////////
//
//  Sets the name of the new WMI class. The syntax is: 
//
//      Win32_Perf_<servicename>_<displayname>
//
//  where the service name is the name of the namespace and the display name 
//    is the name of the object located in the perf name database
//
//    Parameters:
//        pClass -    The object which requires the name
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_NO_ERROR;

    WString wstrObjectName;
    WString wstrTempSvcName;

    if ( 0 == m_wstrClassName.Length() )
    {
        try
        {
            switch( dwType )
            {
                case WMI_ADAP_RAW_CLASS:    m_wstrClassName = ADAP_PERF_RAW_BASE_CLASS L"_"; break;
                case WMI_ADAP_COOKED_CLASS: m_wstrClassName = ADAP_PERF_COOKED_BASE_CLASS L"_"; break;
                default:                    hr = WBEM_E_INVALID_PARAMETER_ID; break;
            }
        }
        catch(...)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        // Process the performance class name
        // ==================================
        if ( SUCCEEDED( hr ) )
        {
            // Get the performance class' display name 
            // =======================================
            hr = m_pDefaultNameDb->GetDisplayName( m_pPerfObj->ObjectNameTitleIndex, wstrObjectName );

            // If no object name was returned, then log an error
            // =================================================
            if ( FAILED( hr ) )
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                          WBEM_MC_ADAP_MISSING_OBJECT_INDEX,
                                          m_pPerfObj->ObjectNameTitleIndex,
                                          (LPCWSTR)m_wstrServiceName );
            }

            // Replace reserved characters with proper names
            // =============================================
            if ( SUCCEEDED( hr ) )
            {
                hr = ReplaceReserved( wstrObjectName );
            }

            // Remove whitespace and extraneous characters
            // ===========================================
            if ( SUCCEEDED( hr ) )
            {
                hr = RemoveWhitespaceAndNonAlphaNum( wstrObjectName );
            }
        }

        // Now do the same for the service name
        // ====================================
        if ( SUCCEEDED( hr ) )
        {
            // Get the service name 
            // ====================
            wstrTempSvcName = m_wstrServiceName;

            // Replace reserved characters with proper names
            // =============================================
            if ( SUCCEEDED( hr ) )
            {
                hr = ReplaceReserved( wstrTempSvcName );
            }

            // Remove whitespace and extraneous characters
            // ===========================================
            if ( SUCCEEDED( hr ) )
            {
                hr = RemoveWhitespaceAndNonAlphaNum( wstrTempSvcName );
            }
        }

        // Now we can build the rest of the name and try setting it in the object
        // ======================================================================
        if ( SUCCEEDED( hr ) )
        {
            try
            {
                m_wstrClassName += wstrTempSvcName;
                m_wstrClassName += L"_";
                m_wstrClassName += wstrObjectName;
                if ( m_bCostly )
                {
                    m_wstrClassName += "_Costly";
                }

            }
            catch( ... )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    // Set the class name in the WMI object
    // ====================================
    if ( SUCCEEDED( hr ) )
    {
        _variant_t var = (LPWSTR) m_wstrClassName;
        hr = pClass->Put( L"__CLASS", 0L, &var, CIM_STRING );
    }

    return hr;
}

HRESULT CClassBroker::RemoveWhitespaceAndNonAlphaNum( WString& wstr )
///////////////////////////////////////////////////////////////////////////////
//
//    Removes spaces, tabs, etc. and non-alphanumeric characters from the 
//    input string
//
//    Parameters:
//        wstr -    The string to be processed
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    WCHAR*    pWstr = wstr.UnbindPtr();

    CVectorDeleteMe<WCHAR> vdmWstr( pWstr );

    if ( NULL != pWstr )
    {
        try
        {
            WCHAR*  pNewWstr = new WCHAR[lstrlenW(pWstr) + 1];
            if (NULL == pNewWstr) return WBEM_E_OUT_OF_MEMORY;

            int x = 0;
            int y = 0;

            // Dump all of the leading, trailing and internal whitespace
            // =========================================================
            for ( ; NULL != pWstr[x]; x++ )
            {
                if ( !iswspace( pWstr[x] ) && isunialphanum( pWstr[x] ) )
                {
                    pNewWstr[y] = pWstr[x];
                    y++;
                }
            }

            pNewWstr[y] = NULL;

            // This will cause the WString to acquire the new pointer
            // ======================================================
            wstr.BindPtr( pNewWstr );
        }
        catch(...)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

HRESULT CClassBroker::ReplaceReserved( WString& wstr )
///////////////////////////////////////////////////////////////////////////////
//
//    This is a 2-pass filter.  First we must determine the size of the new buffer by counting
//    the number of replacement candidates, and, after creating the new buffer, we copy the 
//    data, replacing the restricted characters where required.
//
//    Replaces:
//        "/" with "Per", 
//        "%" with "Percent", 
//        "#" with "Number", 
//        "@" with "At", 
//        "&" with "And"
//
//    Parameters:
//        wstr - String to be processed
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    int x = 0,
        y = 0;

    // Get the data buffer for processing
    // ==================================
    WCHAR*  pWstr = wstr.UnbindPtr();

    CVectorDeleteMe<WCHAR> vdmWstr( pWstr );

    if ( NULL != pWstr )
    {
        // First pass: Count the number of reserved characters
        // ===================================================
        DWORD   dwNumSlashes = 0,
                dwNumPercent = 0,
                dwNumAt = 0,
                dwNumNumber = 0,
                dwNumAmper = 0,
                dwNumReserved = 0;

        for ( ; NULL != pWstr[x]; x++ )
        {
            switch ( pWstr[x] )
            {
                case    L'/':   dwNumSlashes++; dwNumReserved++;    break;
                case    L'%':   dwNumPercent++; dwNumReserved++;    break;
                case    L'@':   dwNumAt++;      dwNumReserved++;    break;
                case    L'#':   dwNumNumber++;  dwNumReserved++;    break;
                case    L'&':   dwNumAmper++;   dwNumReserved++;    break;
                default:                        break;
            }
        }

        try
        {
            // Create the new buffer
            // =====================
            DWORD   dwBuffSize = lstrlenW(pWstr) + 1 + ( 3 * dwNumSlashes ) + ( 7 * dwNumPercent ) +
                        ( 2 * dwNumAt ) + ( 6 * dwNumNumber ) + ( 3 * dwNumAmper );

            WCHAR*  pNewWstr = new WCHAR[dwBuffSize];
            if (NULL == pNewWstr) return WBEM_E_OUT_OF_MEMORY;

            // Second pass: Replace reserved characters
            // ========================================
            DWORD dwBuffSizeCurr = dwBuffSize;
            for ( x = 0; NULL != pWstr[x]; x++ )
            {
                BOOL AllIsUpper = FALSE;
                DWORD Cnt;
                switch ( pWstr[x] )
                {
                    case    L'/':   
                        // if all characters up to the end of string or to the next space are uppercase
                        for (Cnt=1;pWstr[x+Cnt] && pWstr[x+Cnt]!=' ';Cnt++)
                        {
                            if (isupper(pWstr[x+Cnt])) 
                            {
                                AllIsUpper = TRUE;
                            }
                            else 
                            {
                                AllIsUpper = FALSE;
                                break;
                            }
                        };
                        if (!AllIsUpper) 
                        {
                            StringCchCopyW( &pNewWstr[y],dwBuffSizeCurr, L"Per" );
                            y+=3;
                            dwBuffSizeCurr-=3;
                        }
                        else
                        {
                            x++;
                            pNewWstr[y]=pWstr[x];
                            y++;
                            dwBuffSizeCurr--;
                        }
                        break;
                    case    L'%':   StringCchCopyW( &pNewWstr[y],dwBuffSizeCurr, L"Percent" );   y+=7; dwBuffSizeCurr-=7;  break;
                    case    L'@':   StringCchCopyW( &pNewWstr[y],dwBuffSizeCurr, L"At" );        y+=2;  dwBuffSizeCurr-=2; break;
                    case    L'#':   StringCchCopyW( &pNewWstr[y],dwBuffSizeCurr, L"Number" );    y+=6;  dwBuffSizeCurr-=6; break;
                    case    L'&':   StringCchCopyW( &pNewWstr[y],dwBuffSizeCurr, L"And" );       y+=3; dwBuffSizeCurr-=3;  break;
                    default:        pNewWstr[y] = pWstr[x];                 y++;  dwBuffSizeCurr--;  break;
                }
            }

            pNewWstr[y] = NULL;

            // This will cause the WString to acquire the new pointer
            // ======================================================
            wstr.BindPtr( pNewWstr );
        }
        catch(...)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CLocaleClassBroker
//
////////////////////////////////////////////////////////////////////////////////////////////

CLocaleClassBroker::CLocaleClassBroker( IWbemClassObject* pBaseClass, 
                                        WString wstrClassName, 
                                        CPerfNameDb* pDefaultNameDb, 
                                        CPerfNameDb* pLocaleNameDb )
: CClassBroker( pBaseClass, wstrClassName, pDefaultNameDb ), 
  m_pLocaleNameDb( pLocaleNameDb )
{
    if ( NULL != m_pLocaleNameDb )
        m_pLocaleNameDb->AddRef();
}

CLocaleClassBroker::CLocaleClassBroker( PERF_OBJECT_TYPE* pPerfObj, 
                                        BOOL bCostly, 
                                        IWbemClassObject* pBaseClass, 
                                        CPerfNameDb* pDefaultNameDb, 
                                        CPerfNameDb* pLocaleNameDb,
                                        LANGID LangId,
                                        WCHAR* pwcsServiceName )
: m_pLocaleNameDb( pLocaleNameDb ), m_LangId( LangId ),
  CClassBroker( pPerfObj, bCostly, pBaseClass, pDefaultNameDb, pwcsServiceName )
{
    if ( NULL != m_pLocaleNameDb )
        m_pLocaleNameDb->AddRef();
}

CLocaleClassBroker::~CLocaleClassBroker()
{
    if ( NULL != m_pLocaleNameDb )
        m_pLocaleNameDb->Release();
}

HRESULT CLocaleClassBroker::SetClassQualifiers( IWbemClassObject* pClass, DWORD dwType, BOOL fIsDefault )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Sets the class' qualifiers per the localized object rules.  Note that the operations 
//    are performed directly on the IWbemClassObject
//
//    The following qualifiers will be added:
//        - Amendment
//        - Locale(0x0409)
//        - DisplayName (Amended flavor)
//        - Genericperfctr (signals that this is a generic counter)
//
//    Parameters:
//        pClass        - The object to be massaged
//        fIsDefault    - Indicator for the default object (not used in localized objects)
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _variant_t var;

    try
    {
        IWbemQualifierSet* pQualSet = NULL;
        hr = pClass->GetQualifierSet( &pQualSet );
        CReleaseMe    rmQualSet( pQualSet );

        // Amendment
        // =========
        if ( SUCCEEDED( hr ) )
        {
            var = (bool)true;
            hr = pQualSet->Put( L"Amendment", &var, 0L );
        }

        // Locale
        // ======
        if ( SUCCEEDED( hr ) )
        {
            var.Clear();
            V_VT(&var) = VT_I4;
            V_I4(&var) = m_LangId;
            hr = pQualSet->Put( L"locale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
        }

        // DisplayName
        // ===========
        if ( SUCCEEDED( hr ) )
        {
            LPCWSTR pwcsDisplayName = NULL;

            var.Clear();

            // Fetch the name from the Names' database
            // =======================================
            hr = m_pLocaleNameDb->GetDisplayName( m_pPerfObj->ObjectNameTitleIndex, &pwcsDisplayName );

            // If this is a localized Db, this is a benign error.  We will just pull the value 
            // from the default db (it must be there, we wouldn't have a class name if it didn't
            // =================================================================================
            if ( FAILED( hr ) )
            {
                hr = m_pDefaultNameDb->GetDisplayName( m_pPerfObj->ObjectNameTitleIndex, &pwcsDisplayName );
            }

            if ( SUCCEEDED( hr ) )
            {
                var = (LPWSTR) pwcsDisplayName ;
                hr = pQualSet->Put( L"DisplayName", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );
            }
        }

        // Genericperfctr
        // ==============
        if ( SUCCEEDED(hr) )
        {
            var = (bool)true; 
            hr = pQualSet->Put( L"genericperfctr", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
        }

        // Perfindex
        // =========
                
        if ( SUCCEEDED( hr ) )
        {
            var.Clear();
            V_VT(&var) = VT_I4;
            V_I4(&var) = m_pPerfObj->ObjectNameTitleIndex;
            hr = pQualSet->Put( L"perfindex", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
        }

    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED( hr ) )
    {
        // Something whacky happened: log an event
        // =======================================
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                                  (LPCWSTR)m_wstrClassName,
                                  (LPCWSTR)m_wstrServiceName,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CLocaleClassBroker::AddDefaultProperties( IWbemClassObject* pObj )
////////////////////////////////////////////////////////////////////////////////////////////
//
//    Ignored for localized classes
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    return WBEM_S_NO_ERROR;
}

HRESULT CLocaleClassBroker::EnumProperties( DWORD dwType, IWbemClassObject* pObj )
////////////////////////////////////////////////////////////////////////////////////////////
//
//    Ignored for localized classes
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    return WBEM_S_NO_ERROR;
}

HRESULT CLocaleClassBroker::SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, 
                                                   DWORD dwType,
                                                   BOOL fIsDefault,
                                                   LPCWSTR pwcsPropertyName, 
                                                   IWbemClassObject* pClass, 
                                                   BOOL bBase )
////////////////////////////////////////////////////////////////////////////////////////////
//
//    Adds localization qualifiers for the counter properties
//
//  The following qualifiers will be added:
//        - DisplayName (Amended flavor)
//
//    Properties:
//        pCtrDefinition        - The portion of the performance blob related to the property
//        fIsDefault            - Flag identifying default property
//        pwcsPropertyName    - The name of the property
//        pClass                - The WMI class containing the property
//        bBase                - Base property identifier
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _variant_t    var;
    _variant_t    varHelp;
    
    try
    {
        // DisplayName
        // ===========
        if ( SUCCEEDED( hr ) )
        {
            LPCWSTR pwcsDisplayName = NULL;
            LPCWSTR pwcsHelpName = NULL;

            // Fetch the name from the Names' database
            // =======================================
            if ( !bBase )
            {
                hr = m_pLocaleNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, &pwcsDisplayName );

                // If this is a localized Db, this is a benign error.  We will just pull the value 
                // from the default db (it must be there, we wouldn't have a class name if it didn't
                // =================================================================================
                if ( FAILED( hr ) )
                {
                    hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, &pwcsDisplayName );
                }

                if ( SUCCEEDED( hr ) )
                {
                    var = (LPWSTR) pwcsDisplayName ;
                }

                hr = m_pLocaleNameDb->GetHelpName( pCtrDefinition->CounterHelpTitleIndex, &pwcsHelpName );

                // If this is a localized Db, this is a benign error.  We will just pull the value 
                // from the default db (it must be there, we wouldn't have a class name if it didn't
                // =================================================================================
                if ( FAILED( hr ) )
                {
                    hr = m_pDefaultNameDb->GetHelpName( pCtrDefinition->CounterHelpTitleIndex, &pwcsHelpName );
                }

                if ( SUCCEEDED( hr ) )
                {
                    varHelp = (LPWSTR) pwcsHelpName ;
                }
                
            }
            else
            {
                var = L"";
                varHelp = L"";
            }

            // Set the qualifier
            // =================
            if ( SUCCEEDED( hr ) )
            {
                IWbemQualifierSet* pQualSet = NULL;
                hr = pClass->GetPropertyQualifierSet( pwcsPropertyName, &pQualSet );
                CReleaseMe    rmQualSet( pQualSet );

                if ( SUCCEEDED( hr ) )
                {
                    hr = pQualSet->Put( L"DisplayName", &var, 
                        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );
                    if (SUCCEEDED(hr))
                    {
                        hr = pQualSet->Put( L"Description", &varHelp, 
                                            WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );

                    }
                }
            }
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED( hr ) )
    {
        // Something whacky happened: log an event
        // =======================================
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                                  (LPCWSTR)m_wstrClassName,
                                  (LPCWSTR)m_wstrServiceName,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CLocaleClassBroker::AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, 
                                         DWORD dwType,
                                         BOOL fIsDefault,
                                         IWbemClassObject* pClass,
                                         WString &wstrLastCtrName,
                                         BOOL* pbLastCounterIsNotBase )
////////////////////////////////////////////////////////////////////////////////////////////
//
//    Ignored for localized classes
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    return WBEM_S_NO_ERROR;
}

HRESULT CLocaleClassBroker::GenPerfClass( PERF_OBJECT_TYPE* pPerfObj, 
                                          DWORD dwType,
                                          BOOL bCostly, 
                                          IWbemClassObject* pBaseClass, 
                                          CPerfNameDb* pDefaultNameDb, 
                                          CPerfNameDb* pLocaleNameDb,
                                          LANGID LangId,
                                          WCHAR* pwcsServiceName,
                                          IWbemClassObject** ppObj)
///////////////////////////////////////////////////////////////////////////////
//
//    A static member of the broker.  It generates a WMI class based on the 
//    object BLOB.
//
//    Parameters:
//        pPerfObj        - The object BLOB
//        bCostly            - Costly object indicator
//        pBaseClass        - The new object's base class
//        pDefaultNameDb    - The default language names' database
//        pLocaleNameDb    - The localized language names' database
//        LangId            - The locale ID
//        pwcsServiceName    - The name of the perflib service
//        ppObj            - A pointer to the new class object interface pointer
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject* pObject = NULL;
    CLocaleClassBroker Broker( pPerfObj, bCostly, pBaseClass, pDefaultNameDb, pLocaleNameDb, LangId, pwcsServiceName );

    hr = Broker.Generate( dwType, &pObject );

    if ( SUCCEEDED( hr ) )
        *ppObj = pObject;

    return hr;
}

HRESULT CLocaleClassBroker::ConvertToLocale( IWbemClassObject* pDefaultClass,
                                             CLocaleDefn* pLocaleDefn,
                                             CLocaleDefn* pDefaultDefn,
                                             IWbemClassObject** ppObject)
///////////////////////////////////////////////////////////////////////////////
//
//    A static member of the broker.  It generates a new localized class based 
//    on the default object
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

     _variant_t  var;
    int     nLocale = 0;
    int     nPerfIndex = 0; 
    int     nHelpIndex = 0;
    WString wstrClassName;
    DWORD    dwType = WMI_ADAP_RAW_CLASS;

    CPerfNameDb*    pLocaleNameDb = NULL;
    CPerfNameDb*    pDefaultNameDb = NULL;

    // Get references to the localized name's databases
    // ================================================
    hr = pLocaleDefn->GetNameDb( &pLocaleNameDb );
    CAdapReleaseMe  armLocaleNameDb( pLocaleNameDb );

    // Get references to the default name's databases
    // ==============================================
    if ( SUCCEEDED( hr ) )
    {
        hr = pDefaultDefn->GetNameDb( &pDefaultNameDb );
    }

    CAdapReleaseMe  armDefaultNameDb( pDefaultNameDb );

    // Get the locale ID
    // =================
    if ( SUCCEEDED( hr ) )
    {
        hr = pLocaleDefn->GetLID( nLocale );
    }

    // Get the object's perf index
    // ===========================
    if ( SUCCEEDED( hr ) )
    {
        IWbemQualifierSet* pQualSet = NULL;
        hr = pDefaultClass->GetQualifierSet( &pQualSet );
        CReleaseMe    rmQualSet( pQualSet );

                
        if ( SUCCEEDED( hr ) )
        {
            hr =  pQualSet->Get( L"perfindex", 0L, &var, NULL );
            if (SUCCEEDED(hr)) 
            {
                nPerfIndex = V_I4(&var);
            } 
            else 
            {
                // see InitializeMembers
                nPerfIndex = 0;
                hr = WBEM_S_FALSE;
                
            }
        }

        if ( SUCCEEDED( hr ) )
        {
            hr =  pQualSet->Get( L"helpindex", 0L, &var, NULL );
            if (SUCCEEDED(hr)) 
            {
                nHelpIndex = V_I4(&var);
            } 
            else 
            {
                // see InitializeMembers
                nHelpIndex = 0;
                hr = WBEM_S_FALSE;
                
            }
        }
        

        if ( SUCCEEDED( hr ) )
        {
            hr = pQualSet->Get( L"Cooked", 0L, &var, NULL );

            if ( SUCCEEDED( hr ) && ( V_BOOL(&var) == VARIANT_TRUE ) )
            {
                dwType = WMI_ADAP_COOKED_CLASS;
            }
            else
            {
                dwType = WMI_ADAP_RAW_CLASS;
                hr = WBEM_S_FALSE;
            }
        }
    }

    // Get the class name
    // ==================
    if ( SUCCEEDED( hr ) )
    {
        var.Clear();
        hr =  pDefaultClass->Get( L"__CLASS", 0L, &var, NULL, NULL );
        
        wstrClassName = V_BSTR(&var); 
          
    }
    
    // Create locaized class
    // =====================
    IWbemClassObject*    pBaseClass = NULL;
    IWbemClassObject*    pLocaleClass = NULL;

    if ( SUCCEEDED( hr ) )
    {
        hr = pLocaleDefn->GetBaseClass( dwType, &pBaseClass );
        CReleaseMe  rmBaseClass( pBaseClass );

        if ( SUCCEEDED( hr ) )
        {
            hr = pBaseClass->SpawnDerivedClass( 0L, &pLocaleClass );
        }
    }

    // Initialize the data
    // ===================

    // Set the name
    // ============
    if ( SUCCEEDED( hr ) )
    {
        var.Clear();        
        var = LPCWSTR(wstrClassName);
        
        hr = pLocaleClass->Put( L"__CLASS", 0L, &var, CIM_STRING );
        
    }

    // Set Qualifiers
    // ==============
    if ( SUCCEEDED( hr ) )
    {
        IWbemQualifierSet* pQualSet = NULL;
        hr = pLocaleClass->GetQualifierSet( &pQualSet );
        CReleaseMe    rmQualSet( pQualSet );

        // Amendment
        // =========
        if ( SUCCEEDED( hr ) )
        {
            var.Clear();
            
            var = bool(true); 
            hr = pQualSet->Put( L"Amendment", &var, 0L );
        }

        // Locale
        // ======
        if ( SUCCEEDED( hr ) )
        {
            var.Clear();
            V_VT(&var) = VT_I4;
            V_I4(&var) = nLocale;
            hr = pQualSet->Put( L"locale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
        }

        
        // DisplayName
        // ===========
        if ( SUCCEEDED( hr ) )
        {
            LPCWSTR     pwcsDisplayName = NULL;

            hr = pLocaleNameDb->GetDisplayName( nPerfIndex, &pwcsDisplayName );

            // If this is a localized Db, this is a benign error.  We will just pull the value 
            // from the default db (it must be there, we wouldn't have a class name if it didn't
            // =================================================================================
            if ( FAILED( hr ) )
            {
                hr = pDefaultNameDb->GetDisplayName( nPerfIndex, &pwcsDisplayName );
            }

            if ( SUCCEEDED( hr ) )
            {
                var.Clear();
                
                var = (WCHAR *)( pwcsDisplayName );
                hr = pQualSet->Put( L"DisplayName", &var,
                        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );

            }
            else
            {
                // the nPerfInedx was bad
                ERRORTRACE((LOG_WMIADAP,"class %S: DisplayName for counter %d not found\n",(WCHAR *)wstrClassName,nPerfIndex));
            }
        }


        // Description
        // ===========
        if ( SUCCEEDED( hr ) )
        {
            LPCWSTR     pwcsHelpName = NULL;

            hr = pLocaleNameDb->GetHelpName( nHelpIndex, &pwcsHelpName );

            // If this is a localized Db, this is a benign error.  We will just pull the value 
            // from the default db (it must be there, we wouldn't have a class name if it didn't
            // =================================================================================
            if ( FAILED( hr ) )
            {
                hr = pDefaultNameDb->GetHelpName( nHelpIndex, &pwcsHelpName );
            }

            if ( SUCCEEDED( hr ) )
            {
                var.Clear();
                
                var = (WCHAR *)( pwcsHelpName );
                hr = pQualSet->Put( L"Description", &var,
                        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );

            }
            else
            {
                // the nPerfInedx was bad
                ERRORTRACE((LOG_WMIADAP,"class %S: Description for counter %d not found\n",(WCHAR *)wstrClassName,nPerfIndex));
            }
        }

        // Genericperfctr
        // ==============
        if ( SUCCEEDED(hr) )
        {
            var.Clear();
            var = bool(true); 
            hr = pQualSet->Put( L"genericperfctr", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
        }
    }

    // Set Properties
    // ==============
    if ( SUCCEEDED( hr ) )
    {
        
        BSTR bstrPropName;

        pDefaultClass->BeginEnumeration( WBEM_FLAG_LOCAL_ONLY );

        while ( WBEM_S_NO_ERROR == pDefaultClass->Next( 0, &bstrPropName, NULL, NULL, NULL ) )
        {
            CSysFreeMe sfm(bstrPropName);
            var.Clear();
            
            CIMTYPE ct;
            int nCounterIndex = 0;
            int nHelpIndex2    = 0;
            WString wstrDefaultPropDisplayName;

            // Create the property based upon the default property
            // ===================================================            
            V_VT(&var) = VT_NULL;
            V_I8(&var) = 0;

            hr = pDefaultClass->Get( bstrPropName, 0L, NULL, &ct, NULL );
            if (FAILED(hr)) continue;
            hr = pLocaleClass->Put( bstrPropName, 0L, (VARIANT*)&var, ct );
            if (FAILED(hr)) continue;

            // Grab the default property qualifier set
            // =======================================
            IWbemQualifierSet* pQualSet = NULL;
            hr = pDefaultClass->GetPropertyQualifierSet( bstrPropName, &pQualSet );
            CReleaseMe    rmQualSet( pQualSet );


            // Get the default perfindex to be (used to retrieve the display 
            // name from the localized names' database)
            // =============================================================
            if ( SUCCEEDED( hr ) )
            {
                hr = pQualSet->Get( L"perfindex", 0L, &var, NULL );
                nCounterIndex = V_UI4(&var);
            }

            // DisplayName
            // ===========
            
            if ( SUCCEEDED( hr ) )
            {
                LPCWSTR     pwcsDisplayName = NULL;                

                hr = pLocaleNameDb->GetDisplayName( nCounterIndex, &pwcsDisplayName );

                // If this is a localized Db, this is a benign error.  We will just pull the value 
                // from the default db (it must be there, we wouldn't have a class name if it didn't
                // =================================================================================
                if ( FAILED( hr ) )
                {
                    hr = pDefaultNameDb->GetDisplayName( nCounterIndex, &pwcsDisplayName );
                }

                if ( SUCCEEDED( hr ) )
                {
                    IWbemQualifierSet* pLocaleQualSet = NULL;
                    hr = pLocaleClass->GetPropertyQualifierSet( bstrPropName, &pLocaleQualSet );
                    CReleaseMe    rmLocaleQualSet( pLocaleQualSet );
                
                    var = (WCHAR *)( pwcsDisplayName );                    
                    hr = pLocaleQualSet->Put( L"DisplayName", &var, 
                        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );

                }
                else
                {
                    ERRORTRACE((LOG_WMIADAP,"class %S: Display for counter %d not found\n",(WCHAR *)wstrClassName,nCounterIndex));
                }
            }

            // HelpIndex
            if ( SUCCEEDED( hr ) )
            {
                var.Clear();
                hr = pQualSet->Get( L"helpindex", 0L, &var, NULL );
                nHelpIndex2 = V_UI4(&var);
            }

            // Description
            // ===========
            if ( SUCCEEDED( hr ) )
            {
                LPCWSTR     pwcsHelpName = NULL;    

                hr = pLocaleNameDb->GetHelpName( nHelpIndex2, &pwcsHelpName );

                // If this is a localized Db, this is a benign error.  We will just pull the value 
                // from the default db (it must be there, we wouldn't have a class name if it didn't
                // =================================================================================
                if ( FAILED( hr ) )
                {
                    hr = pDefaultNameDb->GetHelpName( nHelpIndex2, &pwcsHelpName );
                }

                if ( SUCCEEDED( hr ) )
                {
                    IWbemQualifierSet* pLocaleQualSet = NULL;
                    hr = pLocaleClass->GetPropertyQualifierSet( bstrPropName, &pLocaleQualSet );
                    CReleaseMe    rmLocaleQualSet( pLocaleQualSet );
                
                    var = (WCHAR *)( pwcsHelpName );                    
                    hr = pLocaleQualSet->Put( L"Description", &var, 
                        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_AMENDED );

                }
                else
                {
                    ERRORTRACE((LOG_WMIADAP,"class %S: Description for counter %d not found\n",(WCHAR *)wstrClassName,nCounterIndex));
                }
            }            
        }

        pDefaultClass->EndEnumeration();
    }

    if ( SUCCEEDED( hr ) )
    {
        *ppObject = pLocaleClass;

        if ( NULL != *ppObject )
            (*ppObject)->AddRef();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//                              CDefaultClassBroker
//
////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CDefaultClassBroker::SetClassQualifiers( IWbemClassObject* pClass, DWORD dwType, BOOL fIsDefault )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Sets the class' qualifiers.  Note that the operations are performed directly on the 
//  IWbemClassObject.
//
//  The following qualifiers will be added:
//        - Dynamic
//        - Provider("NT5_GenericPerfProvider_V1")
//        - Registrykey
//        - Locale(0x0409)
//        - Perfindex
//        - Helpindex
//        - Perfdetail
//        - Genericperfctr (signals that this is a generic counter)
//        - Singleton (if applicable)
//        - Costly (if applicable)  
//
//    Parameters:
//        pClass        - The object to be massaged
//        fIsDefault    - Indicator for the default object (not used in localized objects)
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _variant_t var;
 
    try
    {
        IWbemQualifierSet* pQualSet = NULL;
        hr = pClass->GetQualifierSet( &pQualSet );
        CReleaseMe    rmQualSet( pQualSet );

        switch ( dwType )
        {
            case WMI_ADAP_RAW_CLASS:
            {
                // Default
                // =======
                if ( SUCCEEDED( hr ) && fIsDefault )
                {
                    var = bool(true); 
                    hr = pQualSet->Put( L"perfdefault", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Dynamic
                // =======
                if ( SUCCEEDED( hr ) )
                {
                    var = bool(true); 
                    hr = pQualSet->Put( L"dynamic", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Provider
                // ========
                if ( SUCCEEDED( hr ) )
                {
                    var = L"Nt5_GenericPerfProvider_V1";
                    hr = pQualSet->Put( L"provider", &var, 0L );
                }

                // Registrykey
                // ===========
                if ( SUCCEEDED( hr ) )
                {
                    var = (WCHAR *)(m_wstrServiceName);
                    hr = pQualSet->Put( L"registrykey", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Locale
                // ======
                if ( SUCCEEDED( hr ) )
                {
                    var.Clear();
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = 0x0409;
                    hr = pQualSet->Put( L"locale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Perfindex
                // =========
                if ( SUCCEEDED( hr ) )
                {
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = m_pPerfObj->ObjectNameTitleIndex;
                    hr = pQualSet->Put( L"perfindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Helpindex
                // =========
                if ( SUCCEEDED( hr ) )
                {
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = m_pPerfObj->ObjectHelpTitleIndex;
                    hr = pQualSet->Put( L"helpindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

#ifdef _PM_CHANGED_THEIR_MIND_

                // Description
                // ==========
                if ( SUCCEEDED( hr ) )
                {
                    HRESULT hr2;
                    LPCWSTR     pwcsHelpName = NULL;
                    hr2 = m_pDefaultNameDb->GetHelpName( m_pPerfObj->ObjectHelpTitleIndex, &pwcsHelpName );                     
                    var = (WCHAR *)pwcsHelpName;
                    
                    if (SUCCEEDED(hr2))
                    {
                        hr = pQualSet->Put( L"Description", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );  
                    }
                    else
                    {
                        ERRORTRACE((LOG_WMIADAP,"class %S: Help for counter %d not found\n",(WCHAR *)m_wstrClassName,m_pPerfObj->ObjectHelpTitleIndex));
                    }
                    var.Clear();
                }
#endif
                // Perfdetail
                // ==========
                if ( SUCCEEDED( hr ) )
                {
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = m_pPerfObj->DetailLevel;
                    hr = pQualSet->Put( L"perfdetail", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Genericperfctr
                // ==============
                if ( SUCCEEDED(hr) )
                {
                    var = bool(true); 
                    hr = pQualSet->Put( L"genericperfctr", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // HiPerf
                // ==============
                if ( SUCCEEDED(hr) )
                {
                    var = bool(true); 
                    hr = pQualSet->Put( L"hiperf", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Singleton (set if the numinstances is PERF_NO_INSTANCES)
                // ========================================================
                if ( SUCCEEDED(hr) && IsSingleton( ) )
                {

                    var = bool(true); 
                    // This will have default flavors
                    hr = pQualSet->Put( L"singleton", &var, 0L );
                }

                // Costly
                // ======
                if ( SUCCEEDED(hr) && m_bCostly )
                {
                    var = bool(true); 
                    hr = pQualSet->Put( L"costly", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }
            }break;

            case WMI_ADAP_COOKED_CLASS:
            {
                var.Clear();
                
                // Dynamic
                // =======
                if ( SUCCEEDED( hr ) )
                {                    
                    var = bool(true); 
                    hr = pQualSet->Put( L"dynamic", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }
            
                // Provider
                // ========
                if ( SUCCEEDED( hr ) )
                {
                    var = L"HiPerfCooker_v1";
                    hr = pQualSet->Put( L"provider", &var, 0L );
                }

                // Locale
                // ======
                if ( SUCCEEDED( hr ) )
                {
                    var.Clear();
                    
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = 0x0409;
                    hr = pQualSet->Put( L"locale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Registrykey
                // ===========
                if ( SUCCEEDED( hr ) )
                {
                    var.Clear();
                    var = (WCHAR *)( m_wstrServiceName );
                    hr = pQualSet->Put( L"registrykey", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Cooked
                // ======

                if ( SUCCEEDED( hr ) )
                {
                    var.Clear();                
                    var = bool(true); 
                    hr = pQualSet->Put( L"Cooked", &var, 0 );
                }

                // AutoCook
                // ========

                if ( SUCCEEDED( hr ) )
                {
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = 1 ;
                    hr = pQualSet->Put( L"AutoCook", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Genericperfctr
                // ==============
                if ( SUCCEEDED(hr) )
                {
                    var = bool(true); 
                    hr = pQualSet->Put( L"genericperfctr", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // HiPerf
                // ==============
                if ( SUCCEEDED(hr) )
                {
                    var = bool(true); 
                    hr = pQualSet->Put( L"hiperf", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // AutoCook_RawClass
                // =================

                if ( SUCCEEDED( hr ) )
                {
                    _variant_t varClassName;
                    hr = pClass->Get( L"__CLASS", 0, &varClassName, 0, 0 );

                    if ( SUCCEEDED( hr ) )
                    {
                        WCHAR* wszRawClass = NULL;
                        WCHAR* wszClassRoot = varClassName.bstrVal + wcslen ( ADAP_PERF_COOKED_BASE_CLASS );

                        size_t cchSizeTmp = wcslen( wszClassRoot ) + wcslen( ADAP_PERF_RAW_BASE_CLASS ) + 1;
                        wszRawClass = new WCHAR[ cchSizeTmp ];
                        if (NULL == wszRawClass) hr = WBEM_E_OUT_OF_MEMORY;
                        if (SUCCEEDED(hr))
                        {            
                            CDeleteMe<WCHAR>    dmRawClass( wszRawClass );

                            StringCchPrintfW( wszRawClass,cchSizeTmp, L"%s%s", ADAP_PERF_RAW_BASE_CLASS, wszClassRoot );

                            var = wszRawClass;
                            hr = pQualSet->Put( L"AutoCook_RawClass", 
                                                &var, 
                                                WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                                                //WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
                        }
                    }                
                }

                // Perfindex
                // =========
                
                if ( SUCCEEDED( hr ) )
                {
                    var.Clear();
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = m_pPerfObj->ObjectNameTitleIndex;                    
                    hr = pQualSet->Put( L"perfindex", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Helpindex
                // =========
                if ( SUCCEEDED( hr ) )
                {
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = m_pPerfObj->ObjectHelpTitleIndex;
                    hr = pQualSet->Put( L"helpindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

#ifdef _PM_CHANGED_THEIR_MIND_
                // Description
                // ==========
                if ( SUCCEEDED( hr ) )
                {
                    HRESULT hr2;
                    LPCWSTR     pwcsHelpName = NULL;
                    hr2 = m_pDefaultNameDb->GetHelpName( m_pPerfObj->ObjectHelpTitleIndex, &pwcsHelpName );                     
                    var = (WCHAR *)pwcsHelpName;
                    if (SUCCEEDED(hr2))
                    {
                        hr = pQualSet->Put( L"Description", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );  
                    }
                    else
                    {
                        ERRORTRACE((LOG_WMIADAP,"class %S: Help for counter %d not found\n",(WCHAR *)m_wstrClassName,m_pPerfObj->ObjectHelpTitleIndex));
                    }
                    var.Clear();
                }                
#endif
                // Singleton (set if the numinstances is PERF_NO_INSTANCES)
                // ========================================================
                if ( SUCCEEDED(hr) && IsSingleton( ) )
                {
                    var.Clear();
                    var = bool(true); 
                    // This will have default flavors
                    hr = pQualSet->Put( L"singleton", (VARIANT*)&var, 0L );
                }


            }break;
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED( hr ) )
    {
        // Something whacky happened: log an event
        // =======================================
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                                  (LPCWSTR)m_wstrClassName,
                                  (LPCWSTR)m_wstrServiceName,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CDefaultClassBroker::AddDefaultProperties( IWbemClassObject* pClass )
///////////////////////////////////////////////////////////////////////////////
//
//    Adds appropriate default properties.
//
//  The following qualifiers will be added:
//        - Name
//
//    Parameters:
//        pClass        - The object to be massaged
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If we are not a singleton class, then we will
    // need a name property that is marked as a key
    // =============================================
    if ( !IsSingleton() )
    {
        _variant_t var;

        // Add the Name property
        // =====================

        V_VT(&var) = VT_NULL;
        V_I8(&var) = 0;
        hr = pClass->Put( L"Name", 0L, &var, CIM_STRING );

        // Add the property qualifiers
        // ===========================
        if ( SUCCEEDED( hr ) )
        {
            IWbemQualifierSet* pQualSet = NULL;
            hr = pClass->GetPropertyQualifierSet( L"Name", &pQualSet );
            CReleaseMe    rmQualSet( pQualSet );

            // Dynamic
            // =======
            if ( SUCCEEDED( hr ) )
            {
                var.Clear();
                var = bool(true); 
                hr = pQualSet->Put( L"key", (VARIANT*)&var, 0L );
            }
        }
    }

    return hr;
}

HRESULT CDefaultClassBroker::EnumProperties( DWORD dwType, IWbemClassObject* pClass )
///////////////////////////////////////////////////////////////////////////////
//
//    Walks the counter definitions and generates corresponding properties
//
//    Parameters:
//        pClass        - The object to be massaged
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    BOOL    bLastCounterIsNotBase = FALSE;
    WString wstrLastCtrName;

    // Set to first counter definition
    // ===============================
    LPBYTE  pbData = ((LPBYTE) m_pPerfObj) + m_pPerfObj->HeaderLength;

    // Cast to a counter definition
    // ============================
    PERF_COUNTER_DEFINITION*    pCounterDefinition = (PERF_COUNTER_DEFINITION*) pbData;


    // For each counter definition, add a corresponding property
    // =========================================================
    for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < m_pPerfObj->NumCounters; dwCtr++ )
    {
        hr = AddProperty( pCounterDefinition, dwType, ( dwCtr == (DWORD) m_pPerfObj->DefaultCounter),
                            pClass, wstrLastCtrName, &bLastCounterIsNotBase );

        // Now go to the next counter definition
        // =====================================
        pbData = ((LPBYTE) pCounterDefinition) + pCounterDefinition->ByteLength;
        pCounterDefinition = (PERF_COUNTER_DEFINITION*) pbData;
    }

    return hr;
}

HRESULT CDefaultClassBroker::AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, 
                                          DWORD dwType,
                                          BOOL fIsDefault,
                                          IWbemClassObject* pClass, 
                                          WString &wstrLastCtrName,
                                          BOOL* pbLastCounterIsNotBase )
///////////////////////////////////////////////////////////////////////////////
//
//    Adds a property defined by the counter definition
//    
//    Properties:
//        pCtrDefinition    - The counter BLOB
//        dwType            - Raw or Formatted object?
//        fIsDefault        - The default property flag
//        pClass            - The class containing the property
//        wstrLastCtrName    - The name of the last counter (required for base 
//                            properties)
//        pbLastCounterIsNotBase
//                        - An indicator for the previous counter's baseness
//
///////////////////////////////////////////////////////////////////////////////
{
    if (NULL == pbLastCounterIsNotBase) return WBEM_E_INVALID_PARAMETER;
    HRESULT hr = WBEM_S_NO_ERROR;

    WString wstrPropertyName;
    DWORD   dwCounterTypeMask = PERF_SIZE_VARIABLE_LEN;
    BOOL    bBase = FALSE;

    if ( PERF_COUNTER_BASE == ( pCtrDefinition->CounterType & 0x00070000 ) )
    {
        // It's a base property
        // ====================
        if ( *pbLastCounterIsNotBase )
        {
            try
            {
                // The property name is the same as the previous property, 
                // but with "_Base" appended to the end
                // =======================================================
                wstrPropertyName = wstrLastCtrName;

                if ( WMI_ADAP_RAW_CLASS == dwType )
                {
                    wstrPropertyName += "_Base";
                }
            }
            catch(...)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

            bBase = TRUE;
        }
        else
        {
            // Cannot have 2 consequtive bases
            // ===============================
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_INVALID_DATA, (LPCWSTR)m_wstrServiceName, CHex(0) );
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        // It's not a base property so get the name from the names' database
        // =================================================================
        hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, wstrPropertyName );

        if ( FAILED( hr ) )
        {
            // Index does not exist in the Names' DB: log an event
            // ===================================================
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                      WBEM_MC_ADAP_MISSING_PROPERTY_INDEX,
                                      (LPCWSTR)m_wstrClassName,
                                      (LPCWSTR)m_wstrServiceName,
                                      pCtrDefinition->CounterNameTitleIndex );
        }

        // Replace reserved characters with text
        // =====================================
        if ( SUCCEEDED( hr ) )
        {
            hr = ReplaceReserved( wstrPropertyName );
        }

        // Remove restricted characters
        // ============================
        if ( SUCCEEDED ( hr ) )
        {
            hr = RemoveWhitespaceAndNonAlphaNum( wstrPropertyName );
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        _variant_t    varTest;
        DWORD   dwBaseCtr = 1;

        // Ensure that the property does not exist
        // =======================================
        if ( FAILED( pClass->Get( wstrPropertyName, 0L, &varTest, NULL, NULL ) ) ) 
        {
            // Now check the perf counter type to see if it's a DWORD or LARGE.  
            // If it's anything else, we will NOT support this object
            // ================================================================
            DWORD   dwCtrType = pCtrDefinition->CounterType & dwCounterTypeMask;

            if ( PERF_SIZE_DWORD == dwCtrType ||
                 PERF_SIZE_LARGE == dwCtrType )
            {
                _variant_t    var;
                CIMTYPE ct = ( PERF_SIZE_DWORD == dwCtrType ? CIM_UINT32 : CIM_UINT64 );

                // Add the property
                // ================
                V_VT(&var) = VT_NULL;
                V_I8(&var) = 0;
                hr = pClass->Put( wstrPropertyName, 0L, &var, ct );

                // Set the property qualifiers
                // ===========================
                if ( SUCCEEDED( hr ) )
                {
                    hr = SetPropertyQualifiers( pCtrDefinition, 
                                                dwType,
                                                fIsDefault, 
                                                wstrPropertyName,
                                                pClass,
                                                bBase );
                }
            }
            else if ( PERF_SIZE_ZERO == dwCtrType )
            {
                // Ignore zero size properties
                // ===========================
            }
            else
            {
                // Illegal property type: log an event
                // ===================================
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                          WBEM_MC_ADAP_BAD_PERFLIB_BAD_PROPERTYTYPE,
                                          (LPCWSTR)m_wstrClassName,
                                          (LPCWSTR)m_wstrServiceName,
                                          (LPCWSTR)wstrPropertyName);
                hr = WBEM_E_FAILED;
            }
        }
        else if ( ( WMI_ADAP_COOKED_CLASS == dwType ) && ( bBase ) )
        {
            hr = SetPropertyQualifiers( pCtrDefinition, 
                                        dwType,
                                        fIsDefault, 
                                        wstrPropertyName,
                                        pClass,
                                        bBase );
        }
        else
        {
            // Raw Property already exists: log an event (
            // =========================================
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                      WBEM_MC_ADAP_DUPLICATE_PROPERTY,
                                      (LPCWSTR)m_wstrClassName,
                                      (LPCWSTR)m_wstrServiceName,
                                      (LPCWSTR) wstrPropertyName );
            hr = WBEM_E_FAILED;
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        *pbLastCounterIsNotBase = !bBase;
        wstrLastCtrName = wstrPropertyName;
    }
    else
    {
        // Wierdness: log an event
        // =======================
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                                  (LPCWSTR)m_wstrClassName,
                                  (LPCWSTR)m_wstrServiceName,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CDefaultClassBroker::SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition,
                                                    DWORD dwType,
                                                    BOOL fIsDefault,
                                                    LPCWSTR pwcsPropertyName, 
                                                    IWbemClassObject* pClass,
                                                    BOOL bBase )
///////////////////////////////////////////////////////////////////////////////
//
//  Sets the qualifier values of the properties defined by the counter
//    definition.
//
//  The following qualifiers will be added:
//        - Perfdefault
//        - Display
//        - Countertype
//        - Perfindex
//        - Helpindex
//        - Defaultscale
//        - Perfdetail
//
//    Properties:
//        pCtrDefinition        - The portion of the performance blob related to the property
//        fIsDefault            - Flag identifying default property
//        pwcsPropertyName    - The name of the property
//        pClass                - The WMI class containing the property
//        bBase                - Base property identifier
//
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_S_NO_ERROR;

    _variant_t  var;

    try
    {
        IWbemQualifierSet* pQualSet = NULL;
        hr = pClass->GetPropertyQualifierSet( pwcsPropertyName, &pQualSet );
        CReleaseMe    rmQualSet( pQualSet );

        switch ( dwType )
        {
            case WMI_ADAP_RAW_CLASS:
            {
                // Perfdefault
                // ===========
                if ( SUCCEEDED( hr ) && fIsDefault )
                {
                    var = bool(true); 
                    hr = pQualSet->Put( L"perfdefault", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Display
                // =======
                if ( SUCCEEDED( hr ) )
                {
                    LPCWSTR pwcsDisplayName = NULL;

                    var.Clear();

                    // Fetch the name from the Names' database
                    // =======================================
                    if ( !bBase )
                    {
                        hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, &pwcsDisplayName );
                        if ( SUCCEEDED( hr ) )
                        {
                            var = pwcsDisplayName;
                        }
                        else
                        {
                            ERRORTRACE((LOG_WMIADAP,"class %S: DisplayName for counter %d not found\n",(WCHAR *)m_wstrClassName,pCtrDefinition->CounterNameTitleIndex));
                        }
                    }
                    else
                    {
                        var = L"";
                    }

                    // If this is a localized Db, this could be a benign error
                    // =======================================================
                    if ( SUCCEEDED( hr ) )
                    {
                        hr = pQualSet->Put( L"DisplayName", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                    }
                }
                
#ifdef _PM_CHANGED_THEIR_MIND_
                // Description
                // ===========
                if ( SUCCEEDED( hr ) )
                {
                    LPCWSTR pwcsHelpName = NULL;

                    var.Clear();

                    if ( !bBase )
                    {
                        hr = m_pDefaultNameDb->GetHelpName( pCtrDefinition->CounterHelpTitleIndex, &pwcsHelpName );
                        if ( SUCCEEDED( hr ) )
                        {
                            var = pwcsHelpName;
                        }
                        else
                        {
                            ERRORTRACE((LOG_WMIADAP,"class %S: Help for counter %d not found\n",(WCHAR *)m_wstrClassName,pCtrDefinition->CounterNameTitleIndex));
                        }

                    }
                    else
                    {
                        var = L"";
                    }

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = pQualSet->Put( L"Description", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                    }
                }
#endif                


                // Countertype
                // ===========
                if ( SUCCEEDED( hr ) )
                {
                    var.Clear();
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = pCtrDefinition->CounterType ;
                    hr = pQualSet->Put( L"countertype", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Perfindex
                // =========
                if ( SUCCEEDED( hr ) )
                {
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = pCtrDefinition->CounterNameTitleIndex ;
                    hr = pQualSet->Put( L"perfindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Helpindex
                // =========
                if ( SUCCEEDED( hr ) )
                {
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = pCtrDefinition->CounterHelpTitleIndex ;
                    hr = pQualSet->Put( L"helpindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Defaultscale
                // ============
                if ( SUCCEEDED( hr ) )
                {
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = pCtrDefinition->DefaultScale ;
                    hr = pQualSet->Put( L"defaultscale", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }

                // Perfdetail
                // ==========
                if ( SUCCEEDED( hr ) )
                {
                    V_VT(&var) = VT_I4;
                    V_I4(&var) = pCtrDefinition->DetailLevel ;
                    hr = pQualSet->Put( L"perfdetail", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                }
            }break;
            case WMI_ADAP_COOKED_CLASS:
            {
                var.Clear();

#ifdef _PM_CHANGED_THEIR_MIND_
                // Display
                // =======
                if ( SUCCEEDED( hr ) )
                {
                    LPCWSTR pwcsDisplayName = NULL;

                    var.Clear();

                    // Fetch the name from the Names' database
                    // =======================================
                    if ( !bBase )
                    {
                        hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, &pwcsDisplayName );
                        if ( SUCCEEDED( hr ) )
                        {
                            var = pwcsDisplayName;
                        }
                        else
                        {
                            ERRORTRACE((LOG_WMIADAP,"class %S: DisplayName for counter %d not found\n",(WCHAR *)m_wstrClassName,pCtrDefinition->CounterNameTitleIndex));
                        }
                    }
                    else
                    {
                        var = L"";
                    }

                    // If this is a localized Db, this could be a benign error
                    // =======================================================
                    if ( SUCCEEDED( hr ) )
                    {
                        hr = pQualSet->Put( L"DisplayName", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                    }
                }

                // Description
                // ===========
                if ( SUCCEEDED( hr ) )
                {
                    LPCWSTR pwcsHelpName = NULL;

                    var.Clear();

                    if ( !bBase )
                    {
                        hr = m_pDefaultNameDb->GetHelpName( pCtrDefinition->CounterHelpTitleIndex, &pwcsHelpName );
                        if ( SUCCEEDED( hr ) )
                        {
                            var = pwcsHelpName;
                        }
                    }
                    else
                    {
                        var = L"";
                    }

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = pQualSet->Put( L"Description", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                    }
                }
#endif

                
                if ( !bBase )
                {
                    // CookingType
                    // ===========
                    if ( SUCCEEDED( hr ) )
                    {
                        WCHAR*    wszCookingType = NULL;
                        hr = GetCounterTypeString( pCtrDefinition->CounterType, &wszCookingType );

                        if ( SUCCEEDED( hr ) )
                        {
                            var = wszCookingType;
                            hr = pQualSet->Put( L"CookingType", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                        }
                    }

                    // Counter
                    // =======
                    if ( SUCCEEDED( hr ) )
                    {
                        WString wstrPropertyName;

                        var.Clear();

                        // Fetch the name from the Names' database
                        // =======================================
                        hr = m_pDefaultNameDb->GetDisplayName( pCtrDefinition->CounterNameTitleIndex, wstrPropertyName );

                        // Replace reserved characters with proper names
                        // =============================================
                        if ( SUCCEEDED( hr ) )
                        {
                            hr = ReplaceReserved( wstrPropertyName );
                        }

                        // Remove whitespace and extraneous characters
                        // ===========================================
                        if ( SUCCEEDED( hr ) )
                        {
                            hr = RemoveWhitespaceAndNonAlphaNum( wstrPropertyName );
                        }

                        if ( SUCCEEDED( hr ) )
                        {
                            var = LPCWSTR(wstrPropertyName );

                            // If this is a localized Db, this could be a benign error
                            // =======================================================
                            hr = pQualSet->Put( L"Counter", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                        }                
                    }

                    // PerfTimeStamp & PerfTimeFreq
                    // ============================
                    if ( SUCCEEDED( hr ) )
                    {
                        _variant_t varStamp;
                        _variant_t varFreq;

                        if ( pCtrDefinition->CounterType & PERF_TIMER_100NS )
                        {
                            varStamp = L"TimeStamp_Sys100NS";
                            varFreq = L"Frequency_Sys100NS";
                        }
                        else if ( pCtrDefinition->CounterType & PERF_OBJECT_TIMER )
                        {
                            varStamp = L"Timestamp_Object" ;
                            varFreq = L"Frequency_Object" ;
                        }
                        else
                        {
                            varStamp = L"Timestamp_PerfTime";
                            varFreq = L"Frequency_PerfTime";
                        }
                        
                        hr = pQualSet->Put( L"PerfTimeStamp", &varStamp, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );

                        if ( SUCCEEDED( hr ) )
                        {
                            hr = pQualSet->Put( L"PerfTimeFreq", &varFreq, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                        }
                    }

                    // Perfindex
                    // =========
                    if ( SUCCEEDED( hr ) )
                    {
                        var.Clear();
                        V_VT(&var) = VT_I4;
                        V_I4(&var) = pCtrDefinition->CounterNameTitleIndex;
                        hr = pQualSet->Put( L"perfindex", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                    }
                    
                    // Helpindex
                    // =========
                    if ( SUCCEEDED( hr ) )
                    {
                        V_VT(&var) = VT_I4;
                        V_I4(&var) = pCtrDefinition->CounterHelpTitleIndex ;
                        hr = pQualSet->Put( L"helpindex", &var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                    }
                    
                    
                }
                else
                {
                    // Base
                    // ====
                    if ( SUCCEEDED( hr ) )
                    {
                        WCHAR*    wszCounterBase = NULL;
                        _variant_t    varCounter;
                        hr = pQualSet->Get( L"Counter", 0L, &varCounter, NULL );
                        size_t cchSizeTmp = wcslen( varCounter.bstrVal ) + 5 + 1;
                        wszCounterBase = new WCHAR[ cchSizeTmp  ];
                        CDeleteMe<WCHAR>    dmCounterBase( wszCounterBase );

                        if ( NULL == wszCounterBase )
                        {
                            hr = WBEM_E_OUT_OF_MEMORY;
                        }
                        else
                        {
                            StringCchPrintfW( wszCounterBase, cchSizeTmp , L"%s_Base", varCounter.bstrVal );
                            var = wszCounterBase;
                            hr = pQualSet->Put( L"Base", (VARIANT*)&var, WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE );
                        }
                    }
                }
            }break;
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED( hr ) )
    {
        // Weirdness: log an event
        // =======================
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                  WBEM_MC_ADAP_GENERAL_OBJECT_FAILURE,
                                  (LPCWSTR)m_wstrClassName,
                                  (LPCWSTR)m_wstrServiceName,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CDefaultClassBroker::GenPerfClass( PERF_OBJECT_TYPE* pPerfObj, 
                                           DWORD dwType,
                                           BOOL bCostly, 
                                           IWbemClassObject* pBaseClass, 
                                           CPerfNameDb* pDefaultNameDb, 
                                           WCHAR* pwcsServiceName,
                                           IWbemClassObject** ppObj)
///////////////////////////////////////////////////////////////////////////////
//
//    A static member of the broker.  It generates a WMI class based on the 
//    object BLOB.
//
//    Parameters:
//        pPerfObj        - The object BLOB
//        bCostly            - Costly object indicator
//        pBaseClass        - The new object's base class
//        pDefaultNameDb    - The default language names' database
//        pwcsServiceName    - The name of the perflib service
//        ppObj            - A pointer to the new class object interface pointer
//
///////////////////////////////////////////////////////////////////////////////
{
    if (NULL == ppObj) return WBEM_E_INVALID_PARAMETER;
    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject* pObject = NULL;
    CDefaultClassBroker Broker( pPerfObj, bCostly, pBaseClass, pDefaultNameDb, pwcsServiceName );

    hr = Broker.Generate( dwType, &pObject );

    if ( SUCCEEDED( hr ) )
        *ppObj = pObject;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\classbroker.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    CLASSBROKER.H

Abstract:

History:

--*/


#ifndef _CLASSBROKER_H_
#define _CLASSBROKER_H_

#include <windows.h>
#include <wbemcomn.h>
#include <wbemcli.h>
#include <wbemint.h>
#include "perfndb.h"

#define WMI_ADAP_DEFAULT_OBJECT		238;

class CClassBroker
{
protected:

	PERF_OBJECT_TYPE*	m_pPerfObj;
	BOOL				m_bCostly;
	WString				m_wstrServiceName;
	WString				m_wstrClassName;
	IWbemClassObject*	m_pBaseClass;
	CPerfNameDb*		m_pDefaultNameDb;

	HRESULT SetClassName( DWORD dwType, IWbemClassObject* pObj );

	virtual HRESULT SetClassQualifiers(	IWbemClassObject* pObj, DWORD dwType, BOOL fIsDefault ) = 0;

	virtual HRESULT AddDefaultProperties( IWbemClassObject* pObj ) = 0;

	virtual HRESULT EnumProperties( DWORD dwType, IWbemClassObject* pObj ) = 0;

	virtual HRESULT SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, 
										   DWORD dwType,
										   BOOL fIsDefault,
										   LPCWSTR pwcsPropertyName,
										   IWbemClassObject* pClass,
										   BOOL bBase ) = 0;


	virtual HRESULT AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, 
								 DWORD dwType,
								 BOOL fIsDefault,
								 IWbemClassObject* pClass,
								 WString &wstrLastCtrName,
								 BOOL* pbLastCounterIsNotBase ) = 0;

// Helper methods
// ==============

	BOOL IsSingleton()
	{
		return ( PERF_NO_INSTANCES == m_pPerfObj->NumInstances );
	}

	HRESULT RemoveWhitespaceAndNonAlphaNum( WString& wstr );
	HRESULT ReplaceReserved( WString& wstr );

public:

	CClassBroker( IWbemClassObject* pBaseClass, WString wstrClassName, CPerfNameDb* pDefaultNameDb );

	CClassBroker( PERF_OBJECT_TYPE* pPerfObj, 
				  BOOL bCostly, 
				  IWbemClassObject* pBaseClass, 
				  CPerfNameDb* pDefaultNameDb, 
				  WCHAR* pwcsServiceName );

	virtual ~CClassBroker();

	HRESULT Generate( DWORD dwType, IWbemClassObject** ppObj );
};

class CLocaleClassBroker : public CClassBroker
{
protected:
	CPerfNameDb*		m_pLocaleNameDb;
	LANGID				m_LangId;

	virtual HRESULT SetClassQualifiers(	IWbemClassObject* pObj, DWORD dwType, BOOL fIsDefault );

	virtual HRESULT AddDefaultProperties( IWbemClassObject* pObj );

	virtual HRESULT EnumProperties( DWORD dwType, IWbemClassObject* pObj );

	virtual HRESULT SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, 
										   DWORD dwType,
										   BOOL fIsDefault,
										   LPCWSTR pwcsPropertyName,
										   IWbemClassObject* pClass,
										   BOOL bBase );

	virtual HRESULT AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, 
								 DWORD dwType,
								 BOOL fIsDefault,
								 IWbemClassObject* pClass,
								 WString &wstrLastCtrName,
								 BOOL* pbLastCounterIsNotBase );
public:

	CLocaleClassBroker( IWbemClassObject* pBaseClass, 
						WString wstrClassName, 
						CPerfNameDb* pDefaultNameDb, 
						CPerfNameDb* pLocaleNameDb );

	CLocaleClassBroker( PERF_OBJECT_TYPE* pPerfObj, 
						BOOL bCostly, 
						IWbemClassObject* pBaseClass, 
						CPerfNameDb* pDefaultNameDb, 
						CPerfNameDb* pLocaleNameDb,
						LANGID LangId,
						WCHAR* pwcsServiceName );

	~CLocaleClassBroker();

	static HRESULT GenPerfClass( PERF_OBJECT_TYPE* pPerfObj, 
						DWORD dwType,
						BOOL bCostly, 
						IWbemClassObject* pBaseClass, 
						CPerfNameDb* pDefaultNameDb, 
						CPerfNameDb* pLocaleNameDb,
						LANGID LangId,
						WCHAR* pwcsServiceName,
						IWbemClassObject** ppObj);

	static HRESULT ConvertToLocale( IWbemClassObject* pDefaultObject,
									CLocaleDefn* pLocaleDefn,
									CLocaleDefn* pDefaultDefn,
									IWbemClassObject** ppObject );

};

class CDefaultClassBroker : public CClassBroker
{
protected:
	virtual HRESULT SetClassQualifiers(	IWbemClassObject* pObj, DWORD dwType, BOOL fIsDefault );

	virtual HRESULT AddDefaultProperties( IWbemClassObject* pObj );

	virtual HRESULT EnumProperties( DWORD dwType, IWbemClassObject* pObj );

	virtual HRESULT SetPropertyQualifiers( PERF_COUNTER_DEFINITION* pCtrDefinition, 
										   DWORD dwType,
										   BOOL fIsDefault,
										   LPCWSTR pwcsPropertyName,
										   IWbemClassObject* pClass,
										   BOOL bBase );

	virtual HRESULT AddProperty( PERF_COUNTER_DEFINITION* pCtrDefinition, 
								 DWORD dwType,
								 BOOL fIsDefault,
								 IWbemClassObject* pClass,
								 WString &wstrLastCtrName,
								 BOOL* pbLastCounterIsNotBase );

public:
	CDefaultClassBroker( PERF_OBJECT_TYPE* pPerfObj, 
						 BOOL bCostly, 
						 IWbemClassObject* pBaseClass, 
						 CPerfNameDb* pDefaultNameDb, 
						 WCHAR* pwcsServiceName )
	: CClassBroker( pPerfObj, bCostly, pBaseClass, pDefaultNameDb, pwcsServiceName ) {}

	static HRESULT GenPerfClass( PERF_OBJECT_TYPE* pPerfObj, 
					DWORD dwType,
					BOOL bCostly, 
					IWbemClassObject* pBaseClass, 
					CPerfNameDb* pDefaultNameDb, 
					WCHAR* pwcsServiceName,
					IWbemClassObject** ppObj);
};



#endif	// _BROKERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\localloc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\ntreg.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    NTREG.H

Abstract:

History:

--*/

#ifndef _NTREG_H_
#define _NTREG_H_

#include <windows.h>
//#include "corepol.h"

class CNTRegistry
{
    HKEY    m_hPrimaryKey;
    HKEY    m_hSubkey;
    int     m_nStatus;
    LONG    m_nLastError;
   
public:
    enum { no_error, failed, out_of_memory, no_more_items, access_denied, not_found };
    
    CNTRegistry();
   ~CNTRegistry();

    int Open(HKEY hStart, WCHAR *pszStartKey);

    int MoveToSubkey(WCHAR *pszNewSubkey);

    int DeleteValue(WCHAR *pwszValueName);

    int GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue);
    int GetStr(WCHAR *pwszValueName, WCHAR **pwszValue);
    int GetBinary(WCHAR *pwszValueName, BYTE** ppBuffer, DWORD * pdwSize);

    //Returns a pointer to a string buffer containing the null-terminated string.
    //The last entry is a double null terminator (i.e. the registry format for
    //a REG_MULTI_SZ).  Caller has do "delete []" the returned pointer.
    //dwSize is the size of the buffer returned.
    int GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize);

    // Allows key enumneration
    int Enum( DWORD dwIndex, wmilib::auto_buffer<WCHAR> & pwszValue, DWORD& dwSize );

    int SetDWORD(WCHAR *pwszValueName, DWORD dwValue);
    int SetStr(WCHAR *pwszValueName, WCHAR *wszValue);
    int SetBinary(WCHAR *pwszValueName, BYTE* pBuffer, DWORD dwSize );

    LONG GetLastError() { return m_nLastError; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\ntreg.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    NTREG.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <oaidl.h>
#include "ntreg.h"

#include "adaputil.h"

CNTRegistry::CNTRegistry() : m_hPrimaryKey(0), 
                             m_hSubkey(0),
                             m_nStatus(0),
                             m_nLastError(no_error)
{
}

CNTRegistry::~CNTRegistry()
{
    if (m_hSubkey)
        RegCloseKey(m_hSubkey);
    if (m_hPrimaryKey != m_hSubkey)
        RegCloseKey(m_hPrimaryKey);
}

int CNTRegistry::Open(HKEY hStart, WCHAR *pszStartKey)
{
    int nStatus = no_error;

    m_nLastError = RegOpenKeyExW(hStart, pszStartKey,
                                    0, KEY_ALL_ACCESS, &m_hPrimaryKey );

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    m_hSubkey = m_hPrimaryKey;

    return nStatus;
}

int CNTRegistry::MoveToSubkey(WCHAR *pszNewSubkey)
{
    int nStatus = no_error;

    m_nLastError = RegOpenKeyExW(m_hPrimaryKey, pszNewSubkey, 0, KEY_ALL_ACCESS, &m_hSubkey );

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    default:
        nStatus = failed; break;
    }

    return nStatus;
}

int CNTRegistry::DeleteValue(WCHAR *pwszValueName)
{
    int nStatus = no_error;

    m_nLastError = RegDeleteValueW(m_hSubkey, pwszValueName);

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    return nStatus;
}

int CNTRegistry::GetDWORD(WCHAR *pwszValueName, DWORD *pdwValue)
{
    int nStatus = no_error;

    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = 0;

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
                                LPBYTE(pdwValue), &dwSize);

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        {
            if (dwType != REG_DWORD)
                nStatus = failed;
            else
                nStatus = no_error; 
        }break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    return nStatus;
}

int CNTRegistry::GetStr(WCHAR *pwszValueName, WCHAR **pwszValue)
{
    *pwszValue = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
                                    0, &dwSize);
    if (m_nLastError != 0)
    {
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    if ( ( dwType != REG_SZ ) && ( dwType != REG_EXPAND_SZ ) )
    {
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetStr() failed due to an invalid registry data type.\n" ) );
        return failed;
    }

    BYTE *p = new BYTE[dwSize+sizeof(WCHAR)];
    if (NULL == p) return out_of_memory;
    p[dwSize] = 0;
    p[dwSize+1] = 0;        

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType,
                                    LPBYTE(p), &dwSize);
    if (m_nLastError != 0)
    {
        delete [] p;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    if(dwType == REG_EXPAND_SZ)
    {
        // Get the initial length
        DWORD nSize = ExpandEnvironmentStringsW( (WCHAR *)p, NULL, 0 ) + 1;
        WCHAR* wszTemp = new WCHAR[ nSize + sizeof(WCHAR) ];        
        if (NULL == wszTemp) { delete [] p; return out_of_memory; };
        wszTemp[nSize] = 0;
        ExpandEnvironmentStringsW( (WCHAR *)p, wszTemp, nSize - 1 );
        delete [] p;
        *pwszValue = wszTemp;
    }
    else
        *pwszValue = (WCHAR *)p;

    return no_error;
}

int CNTRegistry::GetBinary(WCHAR *pwszValueName, BYTE **ppBuffer, DWORD * pdwSize)
{
    int nStatus = no_error;
    
    DWORD dwSize = 0;
    DWORD dwType = 0;

    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, 0, &dwSize );

    switch( m_nLastError )
    {
    case ERROR_SUCCESS:
        nStatus = no_error; break;
    case ERROR_ACCESS_DENIED:
        nStatus = access_denied; break;
    case ERROR_FILE_NOT_FOUND:
        nStatus = not_found; break;
    default:
        nStatus = failed; break;
    }

    if ( no_error == nStatus )
    {
        if ( dwType != REG_BINARY ) return failed;
      
        BYTE* pBuffer = new BYTE[dwSize];
        if (NULL == pBuffer) return out_of_memory;

        m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, pBuffer, &dwSize );

        if ( ERROR_SUCCESS != m_nLastError )
        {
            delete [] pBuffer;
            nStatus = failed;
        }
        else
        {
            *ppBuffer = pBuffer;
            *pdwSize = dwSize;
        }
        
    }

    return nStatus;
}

int CNTRegistry::Enum( DWORD dwIndex, wmilib::auto_buffer<WCHAR> & pwszValue, DWORD& dwSize )
{


    DWORD   dwBuffSize = dwSize;

    m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, pwszValue.get(), &dwBuffSize,
                                    NULL, NULL, NULL, NULL );

    while ( m_nLastError == ERROR_MORE_DATA )
    {
        // Grow in 256 byte chunks
        dwBuffSize += 256;

        // Reallocate the buffer and retry
        pwszValue.reset(new WCHAR[dwBuffSize]);
        if (NULL == pwszValue.get()) return out_of_memory;

        dwSize = dwBuffSize;
        m_nLastError = RegEnumKeyExW(m_hSubkey, dwIndex, pwszValue.get(), &dwBuffSize,
                                        NULL, NULL, NULL, NULL );

    }

    if ( ERROR_SUCCESS != m_nLastError )
    {
        if ( ERROR_NO_MORE_ITEMS == m_nLastError )
        {
            return no_more_items;
        }
        else
        {
            return failed;
        }
    }

    return no_error;
}

int CNTRegistry::GetMultiStr(WCHAR *pwszValueName, WCHAR** pwszValue, DWORD &dwSize)
{
    //Find out the size of the buffer required    
    DWORD dwType;
    m_nLastError = RegQueryValueExW(m_hSubkey, pwszValueName, 0, &dwType, NULL, &dwSize);

    //If the error is an unexpected one bail out
    if ((m_nLastError != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ))
    {
       dwSize = 0;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetMultiStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    if (dwSize == 0)
    {
        dwSize = 0;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetMultiStr() failed due to null string.\n" ) );
        return failed;
    }

    //allocate the buffer required
    BYTE *pData = new BYTE[dwSize];
    if (NULL == pData) return out_of_memory;
    
    //get the values
    m_nLastError = RegQueryValueExW(m_hSubkey, 
                                   pwszValueName, 
                                   0, 
                                   &dwType, 
                                   LPBYTE(pData), 
                                   &dwSize);

    //if an error bail out
    if (m_nLastError != 0)
    {
        delete [] pData;
        dwSize = 0;
        DEBUGTRACE( ( LOG_WMIADAP, "CNTRegistry::GetMultiStr() failed: %X.\n", m_nLastError ) );
        return failed;
    }

    *pwszValue = (WCHAR *)pData;

    return no_error;
}

int CNTRegistry::SetDWORD(WCHAR *pwszValueName, DWORD dwValue)
{
    int nStatus = no_error;

    m_nLastError = RegSetValueExW( m_hSubkey, 
                                   pwszValueName,
                                   0,
                                   REG_DWORD,
                                   (BYTE*)&dwValue,
                                   sizeof( dwValue ) );

    if ( m_nLastError != ERROR_SUCCESS )
    {
        nStatus = failed;
    }

    return nStatus;
}

int CNTRegistry::SetStr(WCHAR *pwszValueName, WCHAR *wszValue)
{
    int nStatus = no_error;

    m_nLastError = RegSetValueExW( m_hSubkey, 
                                   pwszValueName,
                                   0,
                                   REG_SZ,
                                   (BYTE*)wszValue,
                                   sizeof(WCHAR) * (wcslen(wszValue) + 1) );

    if ( m_nLastError != ERROR_SUCCESS )
    {
        nStatus = failed;
    }

    return nStatus;
}

int CNTRegistry::SetBinary(WCHAR *pwszValueName, BYTE* pBuffer, DWORD dwSize )
{
    int nStatus = no_error;

    m_nLastError = RegSetValueExW( m_hSubkey, pwszValueName, 0, REG_BINARY, pBuffer, dwSize );

    if ( ERROR_SUCCESS != m_nLastError )
    {
        nStatus = failed;
    }

    return nStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\perflibschema.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFLIBSCHEMA.CPP

Abstract:

    implementation of the CPerfLibSchema class.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wtypes.h>
#include <oleauto.h>
#include <winmgmtr.h>
#include "PerfLibSchema.h"
#include "AdapUtil.h"

////////////////////////////////////////////////////////////////////////////////
//
//  CIndexTable
//
//  This is a look aside table used for processing the perflib data blob.  It
//  guarentees that no duplicate indicies will be allowed to be added to the 
//  table.
//
////////////////////////////////////////////////////////////////////////////////

int CIndexTable::Locate( int nIndex )
{
    int nRet    = not_found;
    int nSize   = m_array.Size();

    for ( int n = 0; ( not_found == nRet ) && ( n < nSize ); n++ )
    {
        int* pIndex = (int*)m_array.GetAt( n );

        if ( *pIndex == nIndex )
            nRet = n;
    }

    return nRet;
}

BOOL CIndexTable::Add( int nIndex )
{
    BOOL bRet = FALSE;

    if ( not_found == Locate( nIndex ) )
    {
        int* pIndex = new int( nIndex );
        if (NULL == pIndex) return FALSE;
        if (CFlexArray::no_error != m_array.Add( pIndex )) return FALSE;
        bRet = TRUE;
    }

    return bRet;
}

void CIndexTable::Empty()
{
    int nSize = m_array.Size();

    for ( int nIndex = 0; nIndex < nSize; nIndex++ )
    {
        int* pIndex = (int*)m_array.GetAt( nIndex );
        delete pIndex;
    }

    m_array.Empty();
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CPerfLibSchema::CPerfLibSchema( WCHAR* pwcsServiceName, 
                                CLocaleCache* pLocaleCache ): 
    m_pLocaleCache(pLocaleCache),
    m_dwFirstCtr(2),
    m_dwLastCtr(CPerfNameDb::GetSystemReservedHigh())
{
    if ( NULL != m_pLocaleCache )
        m_pLocaleCache->AddRef();

    memset( m_apClassList, NULL, WMI_ADAP_NUM_TYPES * sizeof( CPerfClassList* ) );
    
    m_wstrServiceName = pwcsServiceName;
}

CPerfLibSchema::~CPerfLibSchema()
{
    if ( NULL != m_pLocaleCache )
        m_pLocaleCache->Release();

    for ( DWORD dwType = 0; dwType < WMI_ADAP_NUM_TYPES; dwType++ )
    {
        if ( NULL != m_apClassList[ dwType ] )
            m_apClassList[ dwType ]->Release();

        m_aIndexTable[ dwType ].Empty();
    }
}

HRESULT CPerfLibSchema::Initialize( BOOL bDelta, DWORD * pLoadStatus)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CAdapPerfLib*   pPerfLib = NULL;
    BOOL            bInactive = TRUE;

    try
    {
        // Create and initialize the perflib wrapper
        // =========================================
        pPerfLib = new CAdapPerfLib( m_wstrServiceName,pLoadStatus );
        CAdapReleaseMe  rmPerfLib( pPerfLib );

        if ( NULL != pPerfLib )
        {
            if ( bDelta && pPerfLib->CheckStatus( ADAP_PERFLIB_PREVIOUSLY_PROCESSED ) )
        {
            hr = WBEM_S_ALREADY_EXISTS;            
        }
        else if ( pPerfLib->IsOK() )            
        {
                m_dwFirstCtr = pPerfLib->GetFirstCtr();
                m_dwLastCtr = pPerfLib->GetLastCtr();

                //
                // errors from the perflib!Open call are returned here
                //
                hr = pPerfLib->Initialize();

                // Get the perflib blobs
                // =====================
                if ( SUCCEEDED ( hr ) )
                {
                    m_aBlob[COSTLY].SetCostly( TRUE );

                    for ( int nBlob = GLOBAL; SUCCEEDED ( hr ) && nBlob < NUMBLOBS; nBlob ++ )
                    {
                        hr = pPerfLib->GetBlob( m_aBlob[nBlob].GetPerfBlockPtrPtr(), 
                                                m_aBlob[nBlob].GetSizePtr(), 
                                                m_aBlob[nBlob].GetNumObjectsPtr(), 
                                                m_aBlob[nBlob].GetCostly() );

                        if  (FAILED(hr))
                        {
                            ERRORTRACE((LOG_WMIADAP,"Collect for service %S for %s counters failed\n",(WCHAR *)m_wstrServiceName,m_aBlob[nBlob].GetCostly()?"Costly":"Global"));
                        }

                            // check the return status hr
                            if (FAILED(hr) && 
                                (!pPerfLib->IsCollectOK()) && 
                                pLoadStatus )
                            {
                                (*pLoadStatus) |= EX_STATUS_COLLECTFAIL;
                            }

                        // Perflib is inactive if ALL blobs are 0 length
                        // =============================================
                        bInactive = bInactive && ( 0 == m_aBlob[nBlob].GetSize() );
                    }

                    if ( bInactive )
                    {
                        pPerfLib->SetStatus( ADAP_PERFLIB_IS_INACTIVE );
                        hr = WBEM_E_FAILED;
                        ERRORTRACE((LOG_WMIADAP,"Collect for service %S returned 0-Size BLOBs\n",(WCHAR *)m_wstrServiceName));
                    }

                    pPerfLib->Close();
                }            
        }
            else
        {
                hr = WBEM_E_FAILED;
        }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }

        // store the final status in the registry in the EndProcessingStatus
        if ( NULL != pPerfLib )
        {            
            pPerfLib->Cleanup();
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CPerfLibSchema::GetClassList( DWORD dwType, CClassList** ppClassList )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // If the class list does not already exist, then create it
    // ========================================================
    if ( NULL == m_apClassList[ dwType ] )
    {
        hr = CreateClassList( dwType );
    }

    // Set pass back the pointer
    // =========================
    if ( SUCCEEDED( hr ) )
    {
        *ppClassList = m_apClassList[ dwType ];
        if ( NULL != *ppClassList )
            (*ppClassList)->AddRef();
    }

    return hr;
}

HRESULT CPerfLibSchema::CreateClassList( DWORD dwType )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_apClassList[ dwType ] = new CPerfClassList( m_pLocaleCache, m_wstrServiceName );

    if ( NULL == m_apClassList[ dwType ] )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    // Cycle through all perfomance blobs (Global & Costly)
    // ====================================================
    if ( SUCCEEDED( hr ) )
    {
        for ( DWORD dwBlob = GLOBAL; dwBlob < NUMBLOBS; dwBlob++ )
        {
            PERF_OBJECT_TYPE* pCurrentObject = NULL;

            CPerfLibBlobDefn* pBlobDefn = &m_aBlob[dwBlob];
            DWORD dwNumObjects = pBlobDefn->GetNumObjects();

            for ( DWORD dwCtr = 0; SUCCEEDED( hr ) && dwCtr < dwNumObjects; dwCtr++ )
            {
                // Get the current object
                // ======================
                if ( 0 == dwCtr )
                {
                    pCurrentObject = pBlobDefn->GetBlob();
                }
                else
                {
                    LPBYTE  pbData = (LPBYTE) pCurrentObject;
                    pbData += pCurrentObject->TotalByteLength;
                    pCurrentObject = (PERF_OBJECT_TYPE*) pbData;
                }

                if (m_dwFirstCtr <= pCurrentObject->ObjectNameTitleIndex &&
                    pCurrentObject->ObjectNameTitleIndex <= m_dwLastCtr)
                {
                    // To ensure uniqueness, we manage a list of processed indicies
                    // ============================================================
                    if ( m_aIndexTable[dwType].Add( pCurrentObject->ObjectNameTitleIndex ) )
                    {
                        hr = m_apClassList[dwType]->AddPerfObject( pCurrentObject, dwType, pBlobDefn->GetCostly() );
                    }
                }
                else
                {
                    ERRORTRACE((LOG_WMIADAP,"Skipping Object of index %d of service %S "
                                            " because index does not belong to the range %d - %d "
                                            " assigned to the service by LodCtr\n",
                                pCurrentObject->ObjectNameTitleIndex,
                                (WCHAR *)m_wstrServiceName,
                                m_dwFirstCtr,
                                m_dwLastCtr));
                }
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\perflibschema.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFLIBSCHEMA.H

Abstract:

	interface for the CPerfLibSchema class.

History:

--*/

#ifndef _PERFLIBSCHEMA_H_
#define _PERFLIBSCHEMA_H_

#include <flexarry.h>
#include "perfndb.h"
#include "adapelem.h"
#include "adapcls.h"
#include "adapperf.h"
#include "perfthrd.h"

class CIndexTable
{
	enum { not_found = -1 };
private:
	CFlexArray	m_array;	// Array of indices

protected:
	int	Locate( int nIndex );

public:
	BOOL Add( int nIndex );
	void Empty();
};

class CPerfLibBlobDefn
{
protected:
	PERF_OBJECT_TYPE*	m_pPerfBlock;
	DWORD				m_dwNumBytes;
	DWORD				m_dwNumObjects;
	BOOL				m_fCostly;

public:
	CPerfLibBlobDefn() : m_pPerfBlock( NULL ), m_dwNumBytes ( 0 ), m_dwNumObjects ( 0 ), m_fCostly ( FALSE ) 
	{}

	virtual ~CPerfLibBlobDefn() 
	{
		if ( NULL != m_pPerfBlock )
			delete m_pPerfBlock;
	}

	PERF_OBJECT_TYPE*	GetBlob() { return m_pPerfBlock; }
	DWORD				GetNumObjects() { return m_dwNumObjects; }
	DWORD				GetSize() { return m_dwNumBytes; }
	BOOL				GetCostly() { return m_fCostly; }
	void				SetCostly( BOOL fCostly ) { m_fCostly = fCostly; }

	PERF_OBJECT_TYPE**	GetPerfBlockPtrPtr() { return &m_pPerfBlock; }
	DWORD*				GetSizePtr() { return &m_dwNumBytes; }
	DWORD*				GetNumObjectsPtr() { return &m_dwNumObjects; }
};

class CAdapPerfLib;
class CPerfThread;
class CLocaleCache;

class CPerfLibSchema  
{
protected:
	
// Perflib data
// ============

	// The service name of the perflib
	// ===============================
	WString	m_wstrServiceName;

	// The blobs
	// =========
	enum { GLOBAL, COSTLY, NUMBLOBS };
	CPerfLibBlobDefn	m_aBlob[NUMBLOBS];

	// The look aside table for blob processing
	// ========================================
	CIndexTable		m_aIndexTable[WMI_ADAP_NUM_TYPES];

	// The repository with all localized names databases
	// =================================================
	CLocaleCache*	m_pLocaleCache;

	// The unified class list for the perflib schema
	// =============================================
	CPerfClassList* m_apClassList[WMI_ADAP_NUM_TYPES];

	DWORD m_dwFirstCtr;
	DWORD m_dwLastCtr;

	// Methods
	// =======
	HRESULT CreateClassList( DWORD dwType );

public:
	CPerfLibSchema( WCHAR* pwcsServiceName, CLocaleCache* pLocaleCache ); 
	virtual ~CPerfLibSchema();

	HRESULT Initialize( BOOL bDelta, DWORD * LoadStatus);
	HRESULT GetClassList( DWORD dwType, CClassList** ppClassList );
};

#endif	// _PERFLIBSCHEMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\perfndb.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFNDB.H

Abstract:

History:

--*/

#ifndef __PERFNDB_H__
#define __PERFNDB_H__

#include <wbemcomn.h>
#include "adapelem.h"
#include "ntreg.h"

class CPerfNameDb: public CAdapElement
{
public:
    CPerfNameDb(HKEY hKey);
	~CPerfNameDb();
	HRESULT Init(HKEY hKey);

	BOOL IsOk(void){ return m_fOk; };

	HRESULT GetDisplayName( DWORD dwIndex, WString& wstrDisplayName );
	HRESULT GetDisplayName( DWORD dwIndex, LPCWSTR* ppwcsDisplayName );

	HRESULT GetHelpName( DWORD dwIndex, WString& wstrHelpName );
	HRESULT GetHelpName( DWORD dwIndex, LPCWSTR* ppwcsHelpName );
	
	//VOID Dump();
	static DWORD GetSystemReservedHigh(){return s_SystemReservedHigh; };
	
private:
	// these are the MultiSz Pointers
    WCHAR * m_pMultiCounter;
    WCHAR * m_pMultiHelp;
	// these are the "indexed" pointers
    WCHAR ** m_pCounter;
	WCHAR ** m_pHelp;
	DWORD m_Size;

	static DWORD s_SystemReservedHigh;
	//
	BOOL  m_fOk;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\precomp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS

#include <ole2.h>
#include <windows.h>

#include "corepol.h"

#include <comdef.h>
#include <helper.h>
#include <strsafe.h>

#include <autoptr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\perfthrd.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFTHRD.H

Abstract:

History:

--*/


#ifndef __PERFTHRD_H__
#define __PERFTHRD_H__

#include <wbemcomn.h>
#include <wbemint.h>
#include <winperf.h>
#include "adapthrd.h"

// One minute timeout
#define	PERFTHREAD_DEFAULT_TIMEOUT	60

class CPerfOpenRequest : public CAdapThreadRequest
{
public:

	HRESULT Execute( CAdapPerfLib* pPerfLib );
};

class CPerfCollectRequest : public CAdapThreadRequest
{
private:

	// Return data holders
	PERF_OBJECT_TYPE* m_pData;
	DWORD			m_dwBytes;
	DWORD			m_dwNumObjTypes;
	BOOL			m_fCostly;


public:

	CPerfCollectRequest( BOOL fCostly )
		: m_pData( NULL ), m_dwBytes( 0 ), m_dwNumObjTypes( 0 ), m_fCostly( fCostly ){};

	HRESULT Execute( CAdapPerfLib* pPerfLib );

	void GetData( PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes )
	{
		*ppData = m_pData;
		*pdwBytes = m_dwBytes;
		*pdwNumObjTypes = m_dwNumObjTypes;
	}
};

class CPerfCloseRequest : public CAdapThreadRequest
{
public:

	HRESULT Execute( CAdapPerfLib* pPerfLib );
};

class CPerfThread : public CAdapThread
{
	DWORD	m_dwPerflibTimeoutSec;

public:
	CPerfThread( CAdapPerfLib* pPerfLib );

	HRESULT Open( CAdapPerfLib* pLib );
	HRESULT	GetPerfBlock( CAdapPerfLib* pLib, PERF_OBJECT_TYPE** ppData, DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly );
	HRESULT	Close( CAdapPerfLib* pLib );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\perfthrd.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFTHRD.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <process.h>
#include <WinMgmtR.h>
#include "ntreg.h"
#include "perfthrd.h"
#include "adaputil.h"


CPerfThread::CPerfThread( CAdapPerfLib* pPerfLib ) : CAdapThread( pPerfLib )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Constructor
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    CNTRegistry reg;

    if ( CNTRegistry::no_error == reg.Open( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\WBEM\\CIMOM" ) )
    {
        long lError = reg.GetDWORD( L"ADAPPerflibTimeout", &m_dwPerflibTimeoutSec );
        if ( CNTRegistry::no_error == lError )
        {
            // This is what we want
        }
        else if ( CNTRegistry::not_found == lError )
        {
            // Not set, so add it
            reg.SetDWORD( L"ADAPPerflibTimeout", PERFTHREAD_DEFAULT_TIMEOUT );
            m_dwPerflibTimeoutSec = PERFTHREAD_DEFAULT_TIMEOUT;
        }
        else 
        {
            // Unknown error, continue with default value
            m_dwPerflibTimeoutSec = PERFTHREAD_DEFAULT_TIMEOUT;
        }
    }
    else
    {
        m_dwPerflibTimeoutSec = PERFTHREAD_DEFAULT_TIMEOUT;
    }
}

HRESULT CPerfThread::Open( CAdapPerfLib* pLib )
////////////////////////////////////////////////////////////////////////////////////////////
//
//  Open creates a new open request object using the CAdapPerfLib parameter.  It then queues
//  it up and waits for PERFTHREAD_TIMEOUT milliseconds.  If the operation has not returned 
//  in time, then ...
//
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = WBEM_E_FAILED;

    try
    {
        // Create new request object
        // =========================
        CPerfOpenRequest*   pRequest = new CPerfOpenRequest;
        if ( NULL == pRequest ) return WBEM_E_OUT_OF_MEMORY;        
        CAdapReleaseMe      armRequest( pRequest );

        // Queue the request and return
        // ============================

       if (FAILED(hr = Enqueue( pRequest ))) return hr;
       
        // Wait for the call to return
        // ===========================

        switch ( WaitForSingleObject( pRequest->GetWhenDoneHandle(), ( m_dwPerflibTimeoutSec * 1000 ) ) )
        {
        case WAIT_OBJECT_0:
            {
                // SUCCESS: Call returned before it timed-out
                // ==========================================

                hr = pRequest->GetHRESULT();
            }break;

        case WAIT_TIMEOUT:
            {
                pLib->SetStatus( ADAP_PERFLIB_IS_INACTIVE );
                hr = WBEM_E_FAILED; //Reset();
                if (!pLib->GetEventLogCalled())
                {
                    pLib->SetEventLogCalled(TRUE);
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_PERFLIB_FUNCTION_TIMEOUT, (LPCWSTR)pLib->GetServiceName(), L"open" );
                }
            }
        }
    }
    catch(...)
    {
        ERRORTRACE( ( LOG_WMIADAP, "CPerfThread::Open() failed due to out of memory exception.\n" ) );
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CPerfThread::GetPerfBlock( CAdapPerfLib* pLib, PERF_OBJECT_TYPE** ppData,
                                       DWORD* pdwBytes, DWORD* pdwNumObjTypes, BOOL fCostly )
{

    if (NULL == ppData || NULL == pdwBytes || NULL == pdwNumObjTypes) return WBEM_E_INVALID_PARAMETER;
    HRESULT hr = WBEM_E_FAILED;

    try
    {
        CPerfCollectRequest*    pRequest = new CPerfCollectRequest( fCostly );
        if (NULL == pRequest) return WBEM_E_OUT_OF_MEMORY;
        CAdapReleaseMe          armRequest( pRequest );

        if (FAILED(hr = Enqueue( pRequest ))) return hr;

        switch ( WaitForSingleObject( pRequest->GetWhenDoneHandle(), ( m_dwPerflibTimeoutSec * 1000 ) ) )
        {
        case WAIT_OBJECT_0:
            {
                hr = pRequest->GetHRESULT();
                pRequest->GetData( ppData, pdwBytes, pdwNumObjTypes );
                if (FAILED(hr)){
                    pLib->SetStatus( ADAP_PERFLIB_FAILED );
                }
            }break;
        case WAIT_TIMEOUT:
            {
                pLib->SetStatus( ADAP_PERFLIB_IS_INACTIVE );
                hr = WBEM_E_FAILED; //Reset();
                if (!pLib->GetEventLogCalled())
                {
                    pLib->SetEventLogCalled(TRUE);
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_TIMEOUT, (LPCWSTR)pLib->GetServiceName(), L"collect" );
                }
            }break;
        }
    }
    catch(...)
    {
        // DEVDEV
        // should se call pLib->SetStatus(SOMETHING); ?
        //
        ERRORTRACE( ( LOG_WMIADAP, "CPerfThread::GetPerfBlock() failed due to out of memory exception.\n" ) );
        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CPerfThread::Close( CAdapPerfLib* pLib )
{
    HRESULT hr = WBEM_E_FAILED;
    
    try
    {
        CPerfCloseRequest*  pRequest = new CPerfCloseRequest;
        if (NULL == pRequest) return WBEM_E_OUT_OF_MEMORY;
        CAdapReleaseMe      armRequest( pRequest );

        if (FAILED(hr = Enqueue( pRequest ))) return hr;

        switch ( WaitForSingleObject( pRequest->GetWhenDoneHandle(), ( m_dwPerflibTimeoutSec * 1000 ) ) )
        {
        case WAIT_OBJECT_0:
            {
                hr = pRequest->GetHRESULT();
            }break;
        case WAIT_TIMEOUT:
            {
                pLib->SetStatus( ADAP_PERFLIB_IS_INACTIVE );
                hr = WBEM_E_FAILED; //Reset();
                if (!pLib->GetEventLogCalled())
                {
                    pLib->SetEventLogCalled(TRUE);
                    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, WBEM_MC_ADAP_BAD_PERFLIB_TIMEOUT, (LPCWSTR)pLib->GetServiceName(), L"close" );
                }
            }break;
        }
    }
    catch(...)
    {
        ERRORTRACE( ( LOG_WMIADAP, "CPerfThread::Close() failed due to out of memory exception.\n" ) );
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CPerfOpenRequest::Execute( CAdapPerfLib* pPerfLib )
{
    // Call the open function in the perflib
    // =====================================

    m_hrReturn = pPerfLib->_Open();
    return m_hrReturn;
}

HRESULT CPerfCollectRequest::Execute( CAdapPerfLib* pPerfLib )
{
    // Call the collect function in the perflib
    // ========================================

    m_hrReturn = pPerfLib->_GetPerfBlock( &m_pData, &m_dwBytes, &m_dwNumObjTypes, m_fCostly );
    return m_hrReturn;
}

HRESULT CPerfCloseRequest::Execute( CAdapPerfLib* pPerfLib )
{
    // Call the open function in the perflib
    // =====================================

    m_hrReturn = pPerfLib->_Close();
    return m_hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\perfndb.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PERFNDB.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include <winmgmtr.h>
#include "perfndb.h"
#include "adaputil.h"
#include "adapreg.h"

DWORD CPerfNameDb::s_SystemReservedHigh = 0;

CPerfNameDb::CPerfNameDb(HKEY hKey):
    m_pMultiCounter(NULL),
    m_pMultiHelp(NULL),
    m_pCounter(NULL),
    m_pHelp(NULL),
    m_Size(0),
    m_fOk(FALSE)
{    
    try 
    {
        
        m_fOk = SUCCEEDED(Init(hKey));
    } 
    catch (...) 
    {
       CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                 WBEM_MC_ADAP_PERFLIB_SUBKEY_FAILURE,
                                 L"HKEY_PERFORMANCE_xxxTEXT",
                                 CHex( ::GetLastError() ));
    
    }
    //Dump();
}

HRESULT
CPerfNameDb::Init(HKEY hKey)
{
    LONG lRet;
    DWORD dwType;
    DWORD dwInc = 0x10000;
    DWORD dwSize = dwInc;
    BYTE * pData;
    DWORD SizeCounter;
    DWORD SizeHelp;
    WCHAR * pEnd;
    DWORD Index;
    
    HRESULT hr = S_FALSE;


    pData = new BYTE[dwSize];

    if (!pData)
        return WBEM_E_OUT_OF_MEMORY;

retry1:
    {
        lRet = RegQueryValueEx(hKey,
                               TEXT("Counter"),
                               NULL,
                               &dwType,
                               pData,
                               &dwSize);
        if (ERROR_SUCCESS == lRet)
        {
            m_pMultiCounter = (WCHAR *)pData;
            pData = NULL;
            hr = S_OK;
            SizeCounter = dwSize;
        }
        else if (ERROR_MORE_DATA == lRet)
        {
            delete [] pData;            
            pData = new BYTE[dwSize];
            if (!pData)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto cleanup;
            }
            else
            {
                goto retry1;
            }
        }
        else
        {
            hr = WBEM_E_FAILED;
            goto cleanup;
        }
    };

    if (S_OK != hr) // we exited the loop without openeing the DB
        goto cleanup;

    hr = S_FALSE;
    dwSize = dwInc;

    //
    // start a new loop for the help texts
    //
    pData = new BYTE[dwSize];

    if (!pData)
        return WBEM_E_OUT_OF_MEMORY;

retry2:
    {
        lRet = RegQueryValueEx(hKey,
                               TEXT("Help"),
                               NULL,
                               &dwType,
                               pData,
                               &dwSize);
        if (ERROR_SUCCESS == lRet)
        {
            m_pMultiHelp = (WCHAR *)pData;
            pData = NULL;
            hr = S_OK;
            SizeHelp = dwSize;            
        }
        else if (ERROR_MORE_DATA == lRet)
        {
            delete [] pData;            
            pData = new BYTE[dwSize];
            if (!pData)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                goto cleanup;
            }
            else
            {
                goto retry2;
            }
        }
        else
        {
            hr = WBEM_E_FAILED;
            goto cleanup;
        }
    };

    if (S_OK != hr) // we exited the loop without openeing the DB
        goto cleanup;
    //
    //  now parse the string, and set-up the arrays
    //
    pEnd = (WCHAR *)(((ULONG_PTR)m_pMultiCounter)+SizeCounter);
    // points to the last char
    pEnd--;
    while (*pEnd == L'\0')
        pEnd--;
    while (*pEnd)
        pEnd--;
    // past the zero after the last index
    pEnd--; 
    while (*pEnd)
        pEnd--;
    // this should point to the last index as a string
    pEnd++;
    
    Index = _wtoi(pEnd);

    if (Index)
    {
        Index+=2; // just to be safe
        m_Size = Index;

        m_pCounter = new WCHAR*[Index];
        if (!m_pCounter){
            hr = WBEM_E_OUT_OF_MEMORY;
            goto cleanup;
        }
        memset(m_pCounter,0,Index*sizeof(WCHAR *));

        m_pHelp = new WCHAR*[Index];
        if (!m_pHelp){
            hr = WBEM_E_OUT_OF_MEMORY;
            goto cleanup;
        }
        memset(m_pHelp,0,Index*sizeof(WCHAR *));

        DWORD IndexCounter;
        DWORD IndexHelp;
        WCHAR * pStartCounter = m_pMultiCounter;
        WCHAR * pStartHelp = m_pMultiHelp;

        ULONG_PTR LimitMultiCounter = (ULONG_PTR)m_pMultiCounter + SizeCounter;
        ULONG_PTR LimitMultiHelp = (ULONG_PTR)m_pMultiHelp + SizeHelp;

        while ((*pStartCounter) && ((ULONG_PTR)pStartCounter < LimitMultiCounter))
        {
            IndexCounter = _wtoi(pStartCounter);
            while(*pStartCounter)
                pStartCounter++;
            pStartCounter++;     // points to the string
            if (IndexCounter && (IndexCounter < Index))
                m_pCounter[IndexCounter] = pStartCounter;
            // skip the string
            while(*pStartCounter)
                pStartCounter++;  
            pStartCounter++; // points to the next number
        }
        while((*pStartHelp) && ((ULONG_PTR)pStartHelp < LimitMultiHelp))
        {
            IndexHelp = _wtoi(pStartHelp);
            while(*pStartHelp)
                pStartHelp++;
            pStartHelp++;     // points to the string
            if (IndexHelp && (IndexHelp < Index))
                m_pHelp[IndexHelp] = pStartHelp;
            // skip the string
            while(*pStartHelp)
                pStartHelp++;  
            pStartHelp++; // points to the next number        
        }
        hr = S_OK;
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    if (SUCCEEDED(hr) && 
        (0 == CPerfNameDb::s_SystemReservedHigh))
    {
       CPerfNameDb::s_SystemReservedHigh = _wtoi(m_pCounter[1]);
       if (0 == CPerfNameDb::s_SystemReservedHigh)
           hr = WBEM_E_FAILED;
    };

cleanup:
    if (pData)
        delete [] pData;
    return hr;
}

HRESULT 
CPerfNameDb::GetDisplayName(DWORD dwIndex, 
                            WString& wstrDisplayName )
{
    HRESULT hr;
    if (dwIndex < m_Size)
    {
        try {
            // Check for a vaild display name
            if (m_pCounter[dwIndex]) {
                wstrDisplayName = m_pCounter[dwIndex];
                hr = WBEM_S_NO_ERROR;
            } else {
                hr = WBEM_E_FAILED;
            }            
        } catch (...) {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    } else {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    return hr;
}

HRESULT 
CPerfNameDb::GetDisplayName(DWORD dwIndex, 
                            LPCWSTR* ppwcsDisplayName )
{
    HRESULT hr;
    if (dwIndex < m_Size && ppwcsDisplayName)
    {
        // Check for a vaild display name
        if (m_pCounter[dwIndex]) 
        {
            *ppwcsDisplayName = m_pCounter[dwIndex];
            hr = WBEM_S_NO_ERROR;
        } 
        else 
        {
            hr = WBEM_E_FAILED;
        }
    } else {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    return hr;
}

HRESULT 
CPerfNameDb::GetHelpName( DWORD dwIndex, WString& wstrHelpName )
{
    HRESULT hr;
    if (dwIndex < m_Size)
    {
        try {
            // Check for a vaild display name
            if (m_pHelp[dwIndex]) {
                wstrHelpName = m_pHelp[dwIndex];
                hr = WBEM_S_NO_ERROR;
            } else {
                hr = WBEM_E_FAILED;
            }            
        } catch (...) {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    } else {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    return hr;
};

HRESULT 
CPerfNameDb::GetHelpName( DWORD dwIndex, LPCWSTR* ppwcsHelpName )
{
    HRESULT hr;
    if (dwIndex < m_Size && ppwcsHelpName)
    {
        // Check for a vaild display name
        if (m_pHelp[dwIndex]) 
        {
            *ppwcsHelpName = m_pHelp[dwIndex];
            hr = WBEM_S_NO_ERROR;
        } 
        else 
        {
            hr = WBEM_E_FAILED;
        }
    } else {
        hr = WBEM_E_INVALID_PARAMETER;
    }
    return hr;
};


#ifdef _DUMP_DATABASE_NAME_

VOID 
CPerfNameDb::Dump()
{
    if (m_pHelp && m_pCounter)
    {
        WCHAR pBuff[512];
        DWORD i;

        for (i=0;i<m_Size;i++)
        {
            if (m_pCounter[i])
            {
                  StringCchPrintfW(pBuff,512,L"%d %s\n",i,m_pCounter[i]);
                OutputDebugStringW(pBuff);
            }
        }
        
        for (i=0;i<m_Size;i++)
        {
            if (m_pHelp[i])
            {
                if (lstrlenW(m_pHelp[i]) > 100)
                {
                    m_pHelp[i][100]=0;
                }
                StringCchPrintfW(pBuff,512,L"%d %s\n",i,m_pHelp[i]);
                OutputDebugStringW(pBuff);
            }
        }
    }
};

#endif

CPerfNameDb::~CPerfNameDb()
{
    delete [] m_pMultiCounter;
    delete [] m_pMultiHelp;
    delete [] m_pCounter;
    delete [] m_pHelp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\resync.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    RESYNC.CPP

Abstract:

    Implements the windows application or an NT service which
    loads up the various transport prtocols.

    If started with /exe argument, it will always run as an exe.
    If started with /kill argument, it will stop any running exes or services.
    If started with /? or /help dumps out information.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <tchar.h>
#include <reg.h>
#include <wbemutil.h>
#include <cntserv.h>
#include <sync.h>
#include <winntsec.h>

#include <wbemidl.h>
#include <cominit.h>
#include <wbemint.h>
#include <wbemprov.h>
#include <winmgmtr.h>
#include <genutils.h>

#include "WinMgmt.h"
#include "adapreg.h"
#include "adaputil.h"
#include "process.h"
#include "resync.h"


// Timeout is a 64-bit value.  See documentation on SetWaitableTimer
// for why we are setting it this way.
#define             _SECOND     10000000
#define             RESYNC_TIMEOUT_INTERVAL 10 * _SECOND
#define             WMIADAP_DEFAULT_DELAY   10

BOOL                gfResyncInit = FALSE;
HANDLE              ghWaitableTimer = NULL;
BOOL                gfSpawnedResync = FALSE;
DWORD               gdwADAPDelaySec = 0;

HANDLE              ghResyncThreadHandle = NULL;
HANDLE              ghResyncThreadEvent = NULL;
CRITICAL_SECTION*   g_pResyncCs = NULL;
DWORD               gdwResyncThreadId = 0;

// A global handle used to store the last dredger we
// kicked off!
HANDLE              ghChildProcessHandle = NULL;

PCREATEWAITABLETIMERW   gpCreateWaitableTimerW = NULL;
PSETWAITABLETIMER       gpSetWaitableTimerW = NULL;
HINSTANCE               ghKernel32;

class CAutoFreeLib
{
public:
    ~CAutoFreeLib() { if ( NULL != ghKernel32 ) FreeLibrary( ghKernel32); }
};

void ResetResyncTimer( HANDLE hResyncTimer )
{
    DWORD dwErr = 0;
    __int64 qwDueTime  = gdwADAPDelaySec * _SECOND; // RESYNC_TIMEOUT_INTERVAL;

    // Convert it to relative time
    qwDueTime *= -1;

    // Copy the relative time into a LARGE_INTEGER.
    LARGE_INTEGER   li;

    li.LowPart  = (DWORD) ( qwDueTime & 0xFFFFFFFF );
    li.HighPart = (LONG)  ( qwDueTime >> 32 );

    if ( !gpSetWaitableTimerW( hResyncTimer, &li, 0, NULL, NULL, FALSE ) )
    {
        dwErr = GetLastError();
    }

}

// This thread controls the actual shelling of a resync perf operation
unsigned __stdcall ResyncPerfThread( void* pVoid )
{
    RESYNCPERFDATASTRUCT*   pResyncPerfData = (RESYNCPERFDATASTRUCT*) pVoid;

    // We get the two handles, copy them and wait on them
    // The first handle is the terminate event, the second is the
    // timer on which to spin off the resync

    HANDLE  aHandles[2];

    aHandles[0] = pResyncPerfData->m_hTerminate;
    HANDLE  hTimer = pResyncPerfData->m_hWaitableTimer;

    CRITICAL_SECTION*   pcs = pResyncPerfData->m_pcs;

    delete pResyncPerfData;
    pResyncPerfData = NULL;

    // Reset the spawned flag
    gfSpawnedResync = FALSE;

    // Okay.  Signal this event so the starting thread can get us going
    SetEvent( ghResyncThreadEvent );

    // Now, if ghChildProcessHandle is not NULL, then we've obviously kicked off a
    // dredge before.  See where the last one is at.  If it's not done, wait for
    // it to finish.  We will always check this at the start of this chunk of code,
    // since we are really the only location in which the process handle can ever get set,
    // and there really shouldn't be more than one thread ever, waiting to start another
    // dredge

    if ( NULL != ghChildProcessHandle )
    {

        aHandles[1] = ghChildProcessHandle;

        DWORD   dwWait = WaitForMultipleObjects( 2, aHandles, FALSE, INFINITE );

        // If abort was signalled, leave!
        if ( dwWait == WAIT_OBJECT_0 )
        {
            return 0;
        }

        // If the process handle was signalled, close the process, reset the timer
        // and we'll get ready to start the next dredge!
        if ( dwWait == WAIT_OBJECT_0 + 1 )
        {
            EnterCriticalSection( pcs );

            CloseHandle( ghChildProcessHandle );
            ghChildProcessHandle = NULL;
            ResetResyncTimer( hTimer );

            LeaveCriticalSection( pcs );

        }

    }
    else
    {
        // If the Child Process Handle is NULL, we've never dredged before, so we'll
        // just reset the timer
        ResetResyncTimer( hTimer );
    }

    BOOL    fHoldOff = TRUE;

    // Reset this handle to the timer now
    aHandles[1] = hTimer;

    while ( fHoldOff )
    {
        // Wait for either the terminate event or the timer
        DWORD   dwWait = WaitForMultipleObjects( 2, aHandles, FALSE, INFINITE );

        // This means the timer was signaled
        if ( dwWait == WAIT_OBJECT_0 + 1 )
        {
            // Quick sanity check on the abort event
            if ( WaitForSingleObject( aHandles[0], 0 ) == WAIT_OBJECT_0 )
            {
                // Outa here!
                break;
            }

            EnterCriticalSection( pcs );

            // Finally, if the current thread id != gdwResyncThreadId, this means another
            // resync perf thread got kicked off, inside of the critical section,
            // so we should just let it wait on the timer.  We don't really need to do
            // this, since the main thread will wait on this thread to complete before
            // it actually kicks off another thread.

            if ( GetCurrentThreadId() != gdwResyncThreadId )
            {
                // Used the following int 3 for debugging
                // _asm int 3;
                LeaveCriticalSection( pcs );
                break;
            }

            // Once we get through the critical section, check that the
            // timer is still signalled.  If it is not, this means that somebody
            // got control of the critical section and reset the timer

            if ( WaitForSingleObject( aHandles[1], 0 ) == WAIT_OBJECT_0 )
            {

                // Last quick sanity check on the abort event
                if ( WaitForSingleObject( aHandles[0], 0 ) == WAIT_OBJECT_0 )
                {
                    // Outa here!
                    LeaveCriticalSection( pcs );
                    break;
                }

                // Okay, we really will try to create the process now.
                gfSpawnedResync = TRUE;

                // We signalled to start the process, so make it so.
                PROCESS_INFORMATION pi;
                STARTUPINFO si;
                memset(&si, 0, sizeof(si));
                si.cb = sizeof(si);

                TCHAR szPath[MAX_PATH+1];
                GetModuleFileName(NULL, szPath, MAX_PATH);

                TCHAR szCmdLine[256];

                _stprintf(szCmdLine, __TEXT("WINMGMT.EXE -RESYNCPERF %d"), _getpid());

                BOOL bRes = CreateProcess(szPath, szCmdLine, NULL, NULL, FALSE, CREATE_NO_WINDOW,
                                        NULL, NULL,  &si, &pi);
                if(bRes)
                {
                    // Who cares about this one?
                    CloseHandle(pi.hThread);

                    // Clean up our old values
                    if ( NULL != ghChildProcessHandle )
                    {
                        CloseHandle( ghChildProcessHandle );
                        ghChildProcessHandle = NULL;
                    }


                    ghChildProcessHandle = pi.hProcess;
                }

                // We're done
                fHoldOff = FALSE;

            }   // Check that we're still signalled, or we will just have to go back to waiting

            LeaveCriticalSection( pcs );

        }   // IF timer was signalled

    }   // WHILE fHoldOff

    return 0;
}

// For the waitable timer
//#define _SECOND 10000000

// Create all the things we need
BOOL InitResync( void )
{
    if ( gfResyncInit )
        return gfResyncInit;

    if ( ( NULL == gpCreateWaitableTimerW ) && ( NULL == gpSetWaitableTimerW ) )
    {
        ghKernel32 = LoadLibrary( __TEXT("Kernel32.dll") );
        if ( NULL == ghKernel32 )
        {
            return FALSE;
        }
        
        gpCreateWaitableTimerW = ( PCREATEWAITABLETIMERW ) GetProcAddress( ghKernel32, "CreateWaitableTimerW" );
        gpSetWaitableTimerW = ( PSETWAITABLETIMER ) GetProcAddress( ghKernel32, "SetWaitableTimer" );

        if ( ( NULL == gpCreateWaitableTimerW ) || ( NULL == gpSetWaitableTimerW ) )
        {
            FreeLibrary( ghKernel32 );
            ghKernel32 = NULL;
            return FALSE;
        }
    }
        
    if ( NULL == ghWaitableTimer )
    {
        ghWaitableTimer = gpCreateWaitableTimerW( NULL, TRUE, NULL );

        // We gotta big problem
        if ( NULL == ghWaitableTimer )
        {
            // Log an error here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a waitable timer for Resyncperf.\n" ) );
        }

    }

    if ( NULL == ghResyncThreadEvent )
    {
        ghResyncThreadEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        // We gotta big problem
        if ( NULL == ghResyncThreadEvent )
        {
            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncThreadEvent event for Resyncperf.\n" ) );
        }

    }

    // This critical section won't be freed or deleted because of
    // potential timing issues.  But since it's only one, I think
    // we can live with it.
    if ( NULL == g_pResyncCs )
    {
        g_pResyncCs = new CRITICAL_SECTION;

        // We gotta big problem
        if ( NULL == g_pResyncCs )
        {
            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncCs critical section for Resyncperf.\n" ) );
        }
        else
        {
            InitializeCriticalSection( g_pResyncCs );
        }

    }

    gfResyncInit = (    NULL    !=  ghWaitableTimer &&
                        NULL    !=  g_pResyncCs     &&
                        NULL    != ghResyncThreadEvent  );

    // Read the initialization information

    CNTRegistry reg;
    
    if ( CNTRegistry::no_error == reg.Open( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\WBEM\\CIMOM" ) )
    {
        long lError = reg.GetDWORD( L"ADAPDelay", &gdwADAPDelaySec );

        if ( CNTRegistry::no_error == lError )
        {
            //This is what we want
        }
        else if ( CNTRegistry::not_found == lError )
        {
            // Not set, so add it
            reg.SetDWORD( L"ADAPDelay", WMIADAP_DEFAULT_DELAY );
            gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
            gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
        }
    }
    else
    {
        // Error
        ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf could not open the CIMOM subkey to read initialization data. Continuing using a default value.\n" ) );
        gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
    }

    return gfResyncInit;
}

// PLEASE NOTE - THIS FUNCTION IS NOT REENTRANT!  PLEASE DO NOT CALL IT ON MULTIPLE THREADS!
void ResyncPerf( HANDLE hTerminate )
{
    // Make sure this is Win2000 or greater
    if ( !IsW2KOrMore() )
    {
        return;
    }

    // Assume that we should check the timer
    BOOL    fFirstTime = !gfResyncInit;

    if ( !InitResync() )
        return;

    // Auto FreeLibrary for the gpKernel32 Library handle
    CAutoFreeLib    aflKernel32;
    
    EnterCriticalSection( g_pResyncCs );

    // Now, if this or the first time, or the spawned resyncflag is set to TRUE, then we need
    // to kick off another thread.  By checking gfSpawnedResync in a critical section, since
    // it only gets set in the same critical section, we ensure that we will resignal as needed
    // as well as only kick off a thread when we really need to.

    BOOL    fSpawnThread = ( fFirstTime || gfSpawnedResync );

    if ( !fSpawnThread )
    {
        // We are here because we don't appear to have spawned a resync.
        // This is either because we are servicing many lodctr requests
        // within our time delay, or a dredger was started and
        // a previous request request to dredge is waiting for
        // the process to complete.  If the child process handle
        // is not NULL, there is no real need to reset the
        // waitable timer

        if ( NULL == ghChildProcessHandle && ghResyncThreadHandle )
        {
            // Reset the timer here
            ResetResyncTimer( ghWaitableTimer );
        }

    }

    LeaveCriticalSection( g_pResyncCs );


    if ( fSpawnThread )
    {
        HANDLE  ahHandle[2];

        if ( NULL != ghResyncThreadHandle )
        {
            ahHandle[0] = hTerminate;
            ahHandle[1] = ghResyncThreadHandle;

            // Wait for ten seconds on this handle.  If it is not signalled, something is
            // direly wrong.  We're probably not going to be able to kick off a dredge
            // so put some info to this effect in the error log.  The only time we should
            // have contention here, is when a lodctr event is signalled, just as the timer
            // becomes signalled.  The resync thread will wake up and start another dredge
            // this thread will wait for the other thread to complete before continuing.
            // We will kick off another resync thread, which will start another dredge,
            // but it will wait for the first dredge to continue.  This is a worst case
            // scenario, and arguably kicking off two dredges isn't that bad of a bailout

            DWORD   dwRet = WaitForMultipleObjects( 2, ahHandle, FALSE, 10000 );

            // We're done
            if ( dwRet == WAIT_OBJECT_0 )
            {
                return;
            }

            if ( dwRet != WAIT_OBJECT_0 + 1 )
            {
                ERRORTRACE( ( LOG_WINMGMT, "The wait for a termination event or ResyncThreadHandle timed out in Resyncperf.\n" ) );
                return;
            }

            CloseHandle( ghResyncThreadHandle );
            ghResyncThreadHandle = NULL;
        }

        EnterCriticalSection( g_pResyncCs );

        DWORD   dwThreadId = 0;

        RESYNCPERFDATASTRUCT*   pResyncData = new RESYNCPERFDATASTRUCT;

        // Boy are we low on memory!
        if ( NULL == pResyncData )
        {
            LeaveCriticalSection( g_pResyncCs );

            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a RESYNCPERFDATASTRUCT in Resyncperf.\n" ) );
            
            return;
        }

        // Store the data for the resync operation
        pResyncData->m_hTerminate = hTerminate;
        pResyncData->m_hWaitableTimer = ghWaitableTimer;
        pResyncData->m_pcs = g_pResyncCs;

        ghResyncThreadHandle = (HANDLE) _beginthreadex( NULL, 0, ResyncPerfThread, (void*) pResyncData,
                                                        0, (unsigned int *) &gdwResyncThreadId );

        LeaveCriticalSection( g_pResyncCs );


        if ( NULL == ghResyncThreadHandle )
        {
            LeaveCriticalSection( g_pResyncCs );

            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncPerfThread thread in Resyncperf.\n" ) );

            return;
        }
        else
        {
            // Wait for the resync thread event to be signalled by the thread we just started.
            // If it doesn't signal in 10 seconds, something is VERY wrong
            DWORD   dwWait = WaitForSingleObject( ghResyncThreadEvent, INFINITE );

            if ( dwWait != WAIT_OBJECT_0 )
            {
                // Log an event
                ERRORTRACE( ( LOG_WINMGMT, "The ResyncPerfThread thread never signaled the ghResyncThreadEvent in Resyncperf.\n" ) );

                return;
            }
        }

    }   // IF fSpawnThread

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\wmibroker.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    WMIBROKER.H

Abstract:

    implementation of the CWMIBroker class.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcli.h>
#include <cominit.h>
#include <winmgmtr.h>
#include <stdio.h>

#include "perfndb.h"
#include "adaputil.h"
#include "adapcls.h"
#include "ntreg.h"
#include "WMIBroker.h"

#include <comdef.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWMIBroker::CWMIBroker( WString wstrNamespace )
: m_wstrNamespace( wstrNamespace )
{
}

CWMIBroker::~CWMIBroker()
{
}

// This function is used to hook us up to Winmgmt and registry data
HRESULT CWMIBroker::Connect( IWbemServices** ppNamespace, CPerfNameDb* pDefaultNameDb )
{
    if (NULL == ppNamespace) return WBEM_E_INVALID_PARAMETER;
    HRESULT hr = WBEM_NO_ERROR;
    
    IWbemServices* pNamespace = NULL;

    // Connect to the namespace
    hr = ConnectToNamespace( &pNamespace );

    if ( SUCCEEDED( hr ) )
    {
        hr = VerifyNamespace( pNamespace );
    }

    if ( SUCCEEDED( hr ) )
    {
        *ppNamespace = pNamespace;
        DEBUGTRACE( ( LOG_WMIADAP, "The ADAP process ( PID: %d ) is connected to the WinMgmt service\n", GetCurrentProcessId()) );
    }

    return hr;
}

HRESULT CWMIBroker::ConnectToNamespace( IWbemServices** ppNamespace )
{
    if (NULL == ppNamespace) return WBEM_E_INVALID_PARAMETER;
 
    IWbemServices *  pNameSpace = NULL;
    IWbemLocator *   pWbemLocator = NULL;
    
    HRESULT hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (void**) &pWbemLocator );
    CReleaseMe rmWbemLocator(pWbemLocator);    

    if ( SUCCEEDED(hr) )
    {
        // Name space to connect to
        BSTR bstrNameSpace = SysAllocString( m_wstrNamespace );
        if (NULL == bstrNameSpace) hr = WBEM_E_OUT_OF_MEMORY;
  
        CSysFreeMe  sfmNameSpace( bstrNameSpace);

        if (SUCCEEDED(hr))
        {
            hr = pWbemLocator->ConnectServer(   bstrNameSpace,  // NameSpace Name
                                                NULL,           // UserName
                                                NULL,           // Password
                                                NULL,           // Locale
                                                0L,             // Security Flags
                                                NULL,           // Authority
                                                NULL,           // Wbem Context
                                                &pNameSpace     // Namespace
                                                );

            if ( SUCCEEDED( hr ) )
            {
                // Set Interface security
                hr = WbemSetProxyBlanket( pNameSpace, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                    RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

                if ( FAILED( hr ) )
                {
                     pNameSpace->Release();
                     pNameSpace = NULL;
                         
                    // Handle this as appropriate
                    if (wcsstr(bstrNameSpace,L"MS_")) {
                        ERRORTRACE( ( LOG_WMIADAP, "ConnectServer on namespace %S hr = %08x\n",(LPWSTR)bstrNameSpace,hr) );
                    } else {
                        HandleConnectServerFailure( hr );
                    }
                }

            }   // IF ConnectServer
            else
            {
                // We are no longer creating namespaces since we are living under
                // root\cimv2 and NOW deriving off of CIM_StatisticalInformation

                // Handle this as appropriate
                if (wcsstr(bstrNameSpace,L"MS_")) {
                    ERRORTRACE( ( LOG_WMIADAP, "ConnectServer on namespace %S hr = %08x\n",(LPWSTR)bstrNameSpace,hr) );
                } else {
                    HandleConnectServerFailure( hr );
                }
            }
        }
        else
        {
            HandleConnectServerFailure( hr );
        }        
    }
    else
    {
        HandleConnectServerFailure(hr);
    }
    
    *ppNamespace = pNameSpace;

    return hr;
}

HRESULT CWMIBroker::VerifyNamespace( IWbemServices* pNS )
{
    HRESULT hr = WBEM_NO_ERROR;

    // Check that the provider classes exist.  We will only do this for the base namespace,
    // Root\cimv2
    if ( lstrcmpiW( m_wstrNamespace, ADAP_ROOT_NAMESPACE ) == 0 )
    {
        hr = VerifyProviderClasses( pNS, L"NT5_GenericPerfProvider_V1", 
                                    CLSID_NT5PerfProvider_V1_Srv,
                                    CLSID_NT5PerfProvider_V1 );

        if ( SUCCEEDED( hr ) )
        {
            hr = VerifyProviderClasses( pNS, L"HiPerfCooker_v1", 
                                       CLSID_HiPerfCooker_V1_Srv,
                                       CLSID_HiPerfCooker_V1);
        }
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = VerifyBaseClasses( pNS );
    }

    return hr;
}

HRESULT 
CWMIBroker::VerifyProviderClasses( IWbemServices* pNamespace, 
                                           LPCWSTR wszProvider, 
                                           LPCWSTR wszGUID_Server,
                                           LPCWSTR wszGUID_Client)
{
    HRESULT hr = WBEM_NO_ERROR;

    // Verify that an instance of the generic provider exists
    // We need to create an object with our desired attributes so that we may
    // use it to compare it to the instance in WMI, if it already exists
    // ======================================================================

    // NOTE:    
    //      What if the generic provider has not been installed
    // ========================================================

    try
    {
        // Create the generic provider instance 
        // ====================================
        IWbemClassObject*    pProviderClass = NULL;

        size_t cchSizeTmp = 64 + wcslen( wszProvider );
        WCHAR*    wszRelPath = new WCHAR[cchSizeTmp];
        if (NULL == wszRelPath) return WBEM_E_OUT_OF_MEMORY;
        CVectorDeleteMe<WCHAR> dmRelPath( wszRelPath );
        
        StringCchPrintfW( wszRelPath, cchSizeTmp, L"__Win32Provider.Name=\"%s\"", wszProvider );

        BSTR        bstrProviderInst = SysAllocString( wszRelPath );
        if (NULL == bstrProviderInst) return WBEM_E_OUT_OF_MEMORY;
        CSysFreeMe  fmProviderInst(bstrProviderInst);

        BSTR        bstrProviderClass = SysAllocString( L"__Win32Provider" );
        if (NULL == bstrProviderClass) return WBEM_E_OUT_OF_MEMORY;
        CSysFreeMe  fmProviderClass(bstrProviderClass);

        hr = pNamespace->GetObject( bstrProviderClass, 0L, NULL, &pProviderClass, NULL );
        CReleaseMe      rmProviderClass( pProviderClass );

        if ( SUCCEEDED( hr ) )
        {
            IWbemClassObject*    pProviderInstance = NULL;
            _variant_t var;

            hr = pProviderClass->SpawnInstance( 0L, &pProviderInstance );
            CReleaseMe      rmProviderInstance( pProviderInstance );

            if ( SUCCEEDED( hr ) )
            {
                var = wszProvider;
                hr = pProviderInstance->Put(L"Name", 0L, &var, CIM_STRING );
            }

            if ( SUCCEEDED( hr ) )
            {
                var = wszGUID_Server;
                hr = pProviderInstance->Put( L"CLSID", 0L, &var, CIM_STRING );

                if ( SUCCEEDED( hr ) )
                {
                    var = wszGUID_Client;
                    hr = pProviderInstance->Put( L"ClientLoadableCLSID", 0L, &var, CIM_STRING );
                    
                    if ( SUCCEEDED(hr) ){
                        var = L"NetworkServiceHost";
                        hr = pProviderInstance->Put(L"HostingModel",0L,&var,CIM_STRING);
                    }
                    
                }
            }

            if ( SUCCEEDED( hr ) )
            {

                IWbemClassObject*   pDbProviderInstance = NULL;

                // Try to get the object from the db.
                // ==================================

                HRESULT hresDb = pNamespace->GetObject( bstrProviderInst, 0L, NULL,
                                        (IWbemClassObject**)&pDbProviderInstance, NULL );

                // If we got an object from the database, then we need to compare it to the
                // one we just built.  If the comparison fails, we should replace the object
                // =========================================================================

                if ( SUCCEEDED( hresDb ) && NULL != pDbProviderInstance )
                {
                    if ( pProviderInstance->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE,
                                                pDbProviderInstance ) != WBEM_S_SAME )
                    {
                        hr = pNamespace->PutInstance( pProviderInstance, 0L, NULL, NULL );
                    }

                    pDbProviderInstance->Release();
                }
                else
                {
                    hr = pNamespace->PutInstance( pProviderInstance, 0L, NULL, NULL );
                }
            }
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    // Log an error event and bail, because something is pretty badly wrong
    // ====================================================================
    if ( FAILED( hr ) )
    {
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                  WBEM_MC_ADAP_UNABLE_TO_ADD_PROVIDER,
                                  CHex( hr ) );

        ERRORTRACE( ( LOG_WMIADAP, "CAdapSync::VerifyProviderClasses() failed: %X.\n", hr ) );

        return hr;
    }

    // Add the Instance Provider
    // =========================
    try
    {
        IWbemClassObject*    pInstProvRegClass = NULL;

        size_t cchSizeTmp = 128 + wcslen( wszProvider );
        WCHAR*    wszProviderKey = new WCHAR[cchSizeTmp];
        if (NULL == wszProviderKey) return WBEM_E_OUT_OF_MEMORY;
        CVectorDeleteMe<WCHAR>    dmProviderKey( wszProviderKey );

        StringCchPrintfW( wszProviderKey, cchSizeTmp, L"__InstanceProviderRegistration.Provider=\"\\\\\\\\.\\\\root\\\\cimv2:__Win32Provider.Name=\\\"%s\\\"\"", wszProvider );

        BSTR        bstrInstProvRegInst = SysAllocString( wszProviderKey );
        if (NULL == bstrInstProvRegInst) return WBEM_E_OUT_OF_MEMORY;
        CSysFreeMe  fmInstProvRegInst( bstrInstProvRegInst );

        BSTR        bstrInstProvRegClass = SysAllocString( L"__InstanceProviderRegistration" );
        if (NULL == bstrInstProvRegClass) return WBEM_E_OUT_OF_MEMORY;
        CSysFreeMe  fmInstProvRegClass( bstrInstProvRegClass );
    
        hr = pNamespace->GetObject( bstrInstProvRegClass, 0L, NULL, &pInstProvRegClass, NULL );
        CReleaseMe      rmProviderClass( pInstProvRegClass );

        if ( SUCCEEDED( hr ) )
        {
            IWbemClassObject*    pInstProvRegInstance = NULL;
            _variant_t var;

            hr = pInstProvRegClass->SpawnInstance( 0L, &pInstProvRegInstance);
            CReleaseMe      rmInstProvRegInstance( pInstProvRegInstance );

            if ( SUCCEEDED( hr ) )
            {
                cchSizeTmp = 64 + wcslen( wszProvider );
                WCHAR*    wszProviderInst = new WCHAR[cchSizeTmp];
                if (NULL == wszProviderInst) return WBEM_E_OUT_OF_MEMORY;
                CVectorDeleteMe<WCHAR> dmProviderInst( wszProviderInst );

                StringCchPrintfW( wszProviderInst, cchSizeTmp, L"\\\\.\\root\\cimv2:__Win32Provider.Name=\"%s\"", wszProvider );

                var = wszProviderInst;
                hr = pInstProvRegInstance->Put( L"Provider", 0L, (VARIANT*)&var, CIM_REFERENCE );
            }

            if ( SUCCEEDED( hr ) )
            {
                var = bool(true);
                hr = pInstProvRegInstance->Put( L"SupportsGet", 0L, (VARIANT*)&var, CIM_BOOLEAN );
            }
            
            if ( SUCCEEDED( hr ) )
            {
                var = bool(true);
                hr = pInstProvRegInstance->Put( L"SupportsEnumeration", 0L, (VARIANT*)&var, CIM_BOOLEAN );
            }

            if ( SUCCEEDED( hr ) )
            {

                IWbemClassObject*   pDbInstProvRegInstance = NULL;

                // Try to get the object from the db.
                HRESULT hresDb = pNamespace->GetObject( bstrInstProvRegInst, 0L, NULL, &pDbInstProvRegInstance, NULL );

                // If we got an object from the database, then we need to compare it to
                // the one we just built.  If the comparison fails, we should replace the
                // object.

                if ( SUCCEEDED( hresDb ) && NULL != pDbInstProvRegInstance )
                {
                    if ( pInstProvRegInstance->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE,
                                                pDbInstProvRegInstance ) != WBEM_S_SAME )
                    {
                        hr = pNamespace->PutInstance( pInstProvRegInstance, 0L, NULL, NULL );
                    }

                    pDbInstProvRegInstance->Release();
                }
                else
                {
                    hr = pNamespace->PutInstance( pInstProvRegInstance, 0L, NULL, NULL );
                }

            }   // IF Successfully built the object

        }   // IF able to get the class

    }   
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED( hr ) )
    {
        // Log the event
        CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                  WBEM_MC_ADAP_UNABLE_TO_ADD_PROVREG,
                                  CHex( hr ) );
    }

    return hr;
}

HRESULT CWMIBroker::VerifyBaseClasses( IWbemServices* pNS )
{
    HRESULT hr = WBEM_NO_ERROR;

    BOOL bDefault = TRUE;

    // Verify the base Perf classes
    // ============================

    try
    {
        _variant_t    var;

        // Verify CIM_StatisticalInformation
        // =================================
        // If the "abstract" qualifier exists, then we presume to be in the 
        // default (as opposed to localized) namespace 

        BSTR    bstrCimStatisticalClass = SysAllocString( ADAP_PERF_CIM_STAT_INFO );
        if (NULL == bstrCimStatisticalClass) return WBEM_E_OUT_OF_MEMORY;
        CSysFreeMe  fmCimStatisticalClass(bstrCimStatisticalClass);

        IWbemClassObject*   pCimStatClass = NULL;

        hr = pNS->GetObject( bstrCimStatisticalClass, 0L, NULL, (IWbemClassObject**)&pCimStatClass, NULL );
        CReleaseMe  rmCimStatClass( pCimStatClass );

        if ( SUCCEEDED( hr ) )
        {
            IWbemQualifierSet* pQualSet = NULL;

            hr = pCimStatClass->GetQualifierSet( &pQualSet );
            CReleaseMe rmStatClass( pQualSet );

            if ( SUCCEEDED ( hr ) )
            {
                bDefault = ( SUCCEEDED ( ( pQualSet->Get( L"abstract", 0, &var, NULL ) ) ) );
            }
        }
        else
        {
            ERRORTRACE((LOG_WMIADAP,"unable to obtain class CIM_StatisticalInformation for namespace %S:  hr = %08x\n",(WCHAR *)m_wstrNamespace,hr));
        }

        // Verify Win32_Perf
        // =================
        //    We do this by creating a template class with all of the properties and 
        //    qualifiers set, and then compare this to the object in the repository.
        //    If the class does not exist, or if it different that the template, then
        //    update the repository using the template object

        if ( SUCCEEDED ( hr ) )
        {
            IWbemClassObject*    pPerfClass = NULL;

            // Do not use auto release since the pointer 
            // may change in the VerifyByTemplate method
            // =========================================
            hr = pCimStatClass->SpawnDerivedClass( 0L, &pPerfClass );
            CReleaseMeRef<IWbemClassObject*> rmPrf(pPerfClass);

            // Set the name
            // ============
            if ( SUCCEEDED( hr ) )
            {                
                var = ADAP_PERF_BASE_CLASS ;
                hr = pPerfClass->Put(L"__CLASS", 0L, &var, CIM_STRING );
            }

            // Set the class qualifiers
            // ========================
            if ( SUCCEEDED( hr ) )
            {
                hr = SetBaseClassQualifiers( pPerfClass, bDefault );
            }

            // Create the class properties
            // ===========================
            if ( SUCCEEDED( hr ) )
            {
                hr = SetProperties( pPerfClass );
            }

            // Verify the repository's version
            // ===============================
            if ( SUCCEEDED( hr ) )
            {
                hr = VerifyByTemplate( pNS, &pPerfClass, ADAP_PERF_BASE_CLASS );
            }

            // If we have had a failure, log an error event and bail
            // =====================================================
            if ( FAILED( hr ) )
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                          WBEM_MC_ADAP_UNABLE_TO_ADD_WIN32PERF,
                                          (LPCWSTR)m_wstrNamespace, CHex( hr ) );
                ERRORTRACE( ( LOG_WMIADAP, "CAdapSync::VerifyBaseClasses() failed when comparing Win32_Perf: %X.\n", hr ) );
                return hr;
            }

            // Verify Win32_PerfRawData
            // ========================

            IWbemClassObject*    pRawPerfClass = NULL;
            _variant_t var2;

            // Spawn a derived class
            // =====================
            if ( SUCCEEDED ( hr ) )
            {
                // Do not use auto release since the pointer 
                // may change in the VerifyByTemplate method
                // =========================================
                hr = pPerfClass->SpawnDerivedClass( 0L, &pRawPerfClass );
                CReleaseMeRef<IWbemClassObject*> rmRefRaw(pRawPerfClass);

                // Set the name
                // ============
                if ( SUCCEEDED( hr ) )
                {
                    var2 =  ADAP_PERF_RAW_BASE_CLASS ;
                    hr = pRawPerfClass->Put(L"__CLASS", 0L, (VARIANT*)&var2, CIM_STRING );

                    // Set the class qualifiers
                    // ========================
                    hr = SetBaseClassQualifiers( pRawPerfClass, bDefault );

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = VerifyByTemplate( pNS, &pRawPerfClass, ADAP_PERF_RAW_BASE_CLASS );
                    }
                }
                
            }

            // If we have had a failure, log an error event and bail
            // =====================================================
            if ( FAILED( hr ) )
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                          WBEM_MC_ADAP_UNABLE_TO_ADD_WIN32PERFRAWDATA,
                                          (LPCWSTR)m_wstrNamespace, CHex( hr ) );
                ERRORTRACE( ( LOG_WMIADAP, "CAdapSync::VerifyBaseClasses() failed when comparing Win32_PerfRawData: %X.\n", hr ) );
                return hr;
            }

            // Verify Win32_PerfFormattedData
            // ==============================

            IWbemClassObject*    pFormattedPerfClass = NULL;

            // Spawn a derived class
            // =====================
            if ( SUCCEEDED ( hr ) )
            {
                // Do not use auto release since the pointer 
                // may change in the VerifyByTemplate method
                // =========================================
                hr = pPerfClass->SpawnDerivedClass( 0L, &pFormattedPerfClass );
                            CReleaseMeRef<IWbemClassObject*> rmRefForm(pFormattedPerfClass);
                            
                // Set the name
                // ============
                if ( SUCCEEDED( hr ) )
                {
                    var2 = ADAP_PERF_COOKED_BASE_CLASS ;
                    hr = pFormattedPerfClass->Put(L"__CLASS", 0L, &var2, CIM_STRING );

                    // Set the class qualifiers
                    // ========================
                    hr = SetBaseClassQualifiers( pFormattedPerfClass, bDefault );

                    if ( SUCCEEDED( hr ) )
                    {
                        hr = VerifyByTemplate( pNS, &pFormattedPerfClass, ADAP_PERF_COOKED_BASE_CLASS );
                    }
                }
                
            }

            if ( FAILED( hr ) )
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                          WBEM_MC_ADAP_UNABLE_TO_ADD_WIN32PERFRAWDATA, 
                                          (LPCWSTR)m_wstrNamespace, CHex( hr ) );
                ERRORTRACE( ( LOG_WMIADAP, "CAdapSync::VerifyBaseClasses() failed when comparing Win32_PerfFormattedData: %X.\n", hr ) );
                return hr;
            }
        }
    }
    catch(...)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CWMIBroker::VerifyByTemplate( IWbemServices* pNS, IWbemClassObject** ppTemplate, WCHAR* wcsClassName )
{
    HRESULT hr = WBEM_NO_ERROR;
    BOOL    fGetClass = FALSE;

    IWbemClassObject*   pClass = NULL;

    // Get the repository's version of the class
    // =========================================

    BSTR strClassName = SysAllocString( wcsClassName );
    if (NULL == strClassName) return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe  fmClassName( strClassName );

    HRESULT hresDb = pNS->GetObject( strClassName, 0L, NULL, &pClass, NULL );
    CReleaseMe    rmClass( pClass );

    // If we successfully retrieved an object from the database, then we compare it to
    // the template we just built.  If the comparison fails, we should replace the object
    // ==================================================================================

    if ( SUCCEEDED( hresDb ) && NULL != pClass )
    {
        if ( WBEM_S_SAME == pClass->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE, *ppTemplate ) )
        {
            // If they are the same, then swap the template for the stored object
            // ==================================================================
            (*ppTemplate)->Release();
            *ppTemplate = pClass;
            (*ppTemplate)->AddRef();
        }
        else
        {
            // If they are not the same, then force an update of the repository
            // ================================================================
            hr = pNS->PutClass( *ppTemplate, WBEM_FLAG_UPDATE_FORCE_MODE, NULL, NULL );

            if ( FAILED( hr ) )
            {
                CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                          WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
                                          ADAP_PERF_RAW_BASE_CLASS, (LPCWSTR) m_wstrNamespace, CHex( hr ) );
            }
            else
            {
                // Now we need to retrieve the class so we can spawn subclasses as necessary
                fGetClass = TRUE;
            }
        }
    }
    else
    {
        // If the retrieval failed, then add the template class to the repository
        // ======================================================================

        hr = pNS->PutClass( *ppTemplate, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

        if ( FAILED( hr ) )
        {
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                                      WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
                                      ADAP_PERF_RAW_BASE_CLASS, (LPCWSTR) m_wstrNamespace, CHex( hr ) );
        }
        else
        {
            // Now we need to retrieve the class so we can spawn subclasses as necessary
            fGetClass = TRUE;
        }
    }

    // If we need to retrieve the class from the repository, do so now
    if ( SUCCEEDED( hr ) && fGetClass )
    {
        IWbemClassObject*    pSavedObj = NULL;

        hr = pNS->GetObject( strClassName, 0L, NULL, &pSavedObj, NULL );

        if ( SUCCEEDED( hr ) )
        {
            (*ppTemplate)->Release();
            *ppTemplate = pSavedObj;
        }
        else
        {
            CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE, 
                                      WBEM_MC_ADAP_PERFLIB_PUTCLASS_FAILURE, 
                                      ADAP_PERF_RAW_BASE_CLASS, (LPCWSTR) m_wstrNamespace, CHex( hr ) );
        }
    }

    return hr;
}

HRESULT CWMIBroker::SetBaseClassQualifiers( IWbemClassObject* pBaseClass, BOOL bDefault )
{
    HRESULT hr = WBEM_NO_ERROR;

    _variant_t    var;
    IWbemQualifierSet*    pQualSet = NULL;

    hr = pBaseClass->GetQualifierSet( &pQualSet );
    CReleaseMe    rmQualSet( pQualSet );

    // In the root namespace the class is abstract, in the 
    // localized namespaces the class is an amendment
    // ===================================================
    if ( bDefault )
    {
        var = bool(true); 
        hr = pQualSet->Put( L"abstract", &var, 0L );

        if ( SUCCEEDED( hr ) )
        {
            V_VT(&var) = VT_I4;
            V_I4(&var) = ( ADAP_DEFAULT_LANGID );
            hr = pQualSet->Put( L"Locale", &var, 0L );
        }
    }
    else
    {
        var = bool(true); 
        hr = pQualSet->Put( L"amendment", &var, 0L );
    }

    return hr;
}

HRESULT CWMIBroker::SetProperties( IWbemClassObject* pPerfClass )
{
    HRESULT hr = WBEM_NO_ERROR;

    _variant_t    var;
    V_VT(&var) = VT_NULL;
    V_I8(&var) = 0;
    
    // Create the class properties
    // ===========================

    if ( SUCCEEDED( hr ) )
        hr = pPerfClass->Put(L"Frequency_PerfTime", 0L, &var, CIM_UINT64 );

    if ( SUCCEEDED( hr ) )
        hr = pPerfClass->Put(L"Timestamp_PerfTime", 0L, &var, CIM_UINT64 );
    
    if ( SUCCEEDED( hr ) )
        hr = pPerfClass->Put(L"Timestamp_Sys100NS", 0L, &var, CIM_UINT64 );

    if ( SUCCEEDED( hr ) )
        hr = pPerfClass->Put(L"Frequency_Sys100NS", 0L, &var, CIM_UINT64 );

    if ( SUCCEEDED( hr ) )
        hr = pPerfClass->Put(L"Frequency_Object", 0L, &var, CIM_UINT64 );

    if ( SUCCEEDED( hr ) )
        hr = pPerfClass->Put(L"Timestamp_Object", 0L, &var, CIM_UINT64 );
    
    return hr;
}

// This function is called when we actually fail to connect to a namespace.  Because there are special
// cases for when a localized namespace may or may not exist, derived classes can do their own
// handling.  We, on the other hand, could care less and will always log an event
void CWMIBroker::HandleConnectServerFailure( HRESULT hr )
{
    // Log an event
    CAdapUtility::NTLogEvent( EVENTLOG_WARNING_TYPE,
                              WBEM_MC_ADAP_CONNECTION_FAILURE,
                              (LPCWSTR) m_wstrNamespace,
                              CHex( hr ) );

}

HRESULT CWMIBroker::GetNamespace( WString wstrNamespace, IWbemServices** ppNamespace )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CWMIBroker aBroker( wstrNamespace );

    hr = aBroker.Connect( ppNamespace );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\comlib\precomp.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS

#include <windows.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\comlib\sources.inc ===
############################################################################
#
#   Copyright (C) 1999, Microsoft Corporation.
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETPATH=obj
TARGETTYPE=LIBRARY

# The INCLUDES variable specifies any include paths that are specific to
# this source directory. Separate multiple paths with single
# semicolons. Relative path specifications are okay.
INCLUDES=$(INCLUDES); \
	$(STDLIBRARY_INC); \
	$(WBEMCOMN_INC)

# Next, specify options for the compiler using C_DEFINES.
C_DEFINES=$(C_DEFINES) /D__WINNT_BUILD__ /D_UNICODE /DUNICODE
USE_NATIVE_EH=1
USE_STL=1
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\adap\wmibroker.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    WMIBROKER.H

Abstract:

	interface for the CWMIBroker class.

History:

--*/

#ifndef _WMIBROKER_H_
#define _WMIBROKER_H_

#include <wbemcli.h>
#include "perfndb.h"

#define CLSID_NT5PerfProvider_V1     L"{FF37A93C-C28E-11d1-AEB6-00C04FB68820}"
#define CLSID_NT5PerfProvider_V1_Srv L"{76A94DE3-7C26-44f5-8E98-C5AEA48186CB}"

#define CLSID_HiPerfCooker_V1      L"{B0A2AB46-F612-4469-BEC4-7AB038BC476C}"
#define CLSID_HiPerfCooker_V1_Srv  L"{B0A2AB46-F612-4469-BEC4-7AB038BC476C}"


class CWMIBroker  
{
	WString m_wstrNamespace;

	HRESULT Connect( IWbemServices** ppNamespace, CPerfNameDb* pDefaultNameDb = NULL );
	HRESULT ConnectToNamespace( IWbemServices** ppNamespace );
	virtual void HandleConnectServerFailure( HRESULT hr );

	HRESULT VerifyNamespace( IWbemServices* pNS );

	virtual HRESULT VerifyProviderClasses( IWbemServices* pNS, 
	                                       LPCWSTR wszProvider, 
	                                       LPCWSTR wszGUID_Client,
	                                       LPCWSTR wszGUID_Server = NULL);
	virtual HRESULT VerifyBaseClasses( IWbemServices* pNS );

	HRESULT VerifyByTemplate( IWbemServices* pNS, IWbemClassObject** ppTemplate, WCHAR* wcsClassName );

	HRESULT SetBaseClassQualifiers( IWbemClassObject* pBaseClass, BOOL bDefault );
	HRESULT SetProperties( IWbemClassObject* pPerfClass );

public:
	CWMIBroker( WString wstrNamespace );
	virtual ~CWMIBroker();

	static HRESULT GetNamespace( WString wstrNamespace, IWbemServices** ppNamespace );
};

#endif // _WMIBROKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\comlib\commain.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COMMAIN.H

Abstract:

	COM Helpers.

History:

--*/

#ifndef __WBEM_COMMAIN__H_
#define __WBEM_COMMAIN__H_

#include <unk.h>
#include <clsfac.h>

HMODULE GetThisModuleHandle();

class CComServer
{
public:
    virtual HRESULT Initialize() = 0;
    virtual void Uninitialize(){}
    virtual void PostUninitialize(){}
    virtual HRESULT InitializeCom();
    virtual void Register(){}
    virtual void Unregister(){}
    virtual BOOL CanShutdown(){ return TRUE; }

    CLifeControl* GetLifeControl();
protected:
    CComServer();

    HRESULT AddClassInfo( REFCLSID rclsid, 
                          CUnkInternal* pFactory, 
                          LPTSTR szName,
                          BOOL bFreeThreaded, 
                          BOOL bReallyFree = FALSE );
	
	// Assumes riid and ProxyStubClsId are same
    HRESULT RegisterInterfaceMarshaler(REFIID riid, LPTSTR szName, 
                                int nNumMembers, REFIID riidParent);
	// ProxyStubClsId must be explicitly specified
    HRESULT RegisterInterfaceMarshaler(REFIID riid, CLSID psclsid, LPTSTR szName, 
                                int nNumMembers, REFIID riidParent);
    HRESULT UnregisterInterfaceMarshaler(REFIID riid);
};

/***************************************************************************
  We are trying NOT to be dependant on wbemcomn in this module.  This is 
  so this library will not have to be paired with the static or dll version
  of wbemcomn.  This is the reason for the following definitions ...
****************************************************************************/

#ifndef STATUS_POSSIBLE_DEADLOCK 
#define STATUS_POSSIBLE_DEADLOCK (0xC0000194L)
#endif /*STATUS_POSSIBLE_DEADLOCK */


#ifndef InitializeCriticalSectionAndSpinCount

WINBASEAPI
BOOL
WINAPI
InitializeCriticalSectionAndSpinCount(
    IN OUT LPCRITICAL_SECTION lpCriticalSection,
    IN DWORD dwSpinCount
    );

#endif


DWORD MyBreakOnDbgAndRenterLoop(void);

class CMyCritSec : public CRITICAL_SECTION
{
public:
    CMyCritSec() 
    {
        bool initialized = (InitializeCriticalSectionAndSpinCount(this,0))?true:false;
        if (!initialized) throw CX_MemoryException();
    }

    ~CMyCritSec()
    {
        DeleteCriticalSection(this);
    }

    void Enter()
    {
        __try {
          EnterCriticalSection(this);
        } __except((STATUS_POSSIBLE_DEADLOCK == GetExceptionCode())? MyBreakOnDbgAndRenterLoop():EXCEPTION_CONTINUE_SEARCH) {
        }    
    }

    void Leave()
    {
        LeaveCriticalSection(this);
    }
};

        
class CMyInCritSec
{
protected:
    CRITICAL_SECTION* m_pcs;
public:
    CMyInCritSec(CRITICAL_SECTION* pcs) : m_pcs(pcs)
    {
        __try {
          EnterCriticalSection(m_pcs);
        } __except((STATUS_POSSIBLE_DEADLOCK == GetExceptionCode())? MyBreakOnDbgAndRenterLoop():EXCEPTION_CONTINUE_SEARCH) {
        }    
    }
    inline ~CMyInCritSec()
    {
        LeaveCriticalSection(m_pcs);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\comlib\commain.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COMMAIN.CPP

Abstract:

    COM Helpers

History:

--*/

#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <vector>
#include <clsfac.h>
#include "commain.h"

DWORD MyBreakOnDbgAndRenterLoop(void)
{
    __try
    { 
        DebugBreak();
    }
    _except (EXCEPTION_EXECUTE_HANDLER) {};
    
    return EXCEPTION_CONTINUE_EXECUTION;
}

void CreatePathString( TCHAR* pTo, 
                       int cTo, 
                       WCHAR* pId, 
                       TCHAR* pPrefix )
{
    TCHAR chId[128];
#ifdef UNICODE
    StringCchCopy( chId, 128, pId );
#else
    wcstombs( chId, pId, 128 );
#endif
    StringCchCopy( pTo, cTo, pPrefix );
    StringCchCat( pTo, cTo, chId );
}

struct CClassInfo
{
    LIST_ENTRY m_Entry;
    const CLSID* m_pClsid;
    CUnkInternal* m_pFactory;
    LPTSTR m_szName;
    BOOL m_bFreeThreaded;
    BOOL m_bReallyFree;
    DWORD m_dwCookie;
public:
    CClassInfo(): m_pClsid(0), m_pFactory(0), m_szName(0), m_bFreeThreaded(0), m_dwCookie(0){}
    CClassInfo(CLSID* pClsid, LPTSTR szName, BOOL bFreeThreaded, BOOL bReallyFree) : 
        m_pClsid(pClsid), m_pFactory(NULL), m_szName(szName), 
        m_bFreeThreaded(bFreeThreaded), m_bReallyFree( bReallyFree )
    {}
    virtual ~CClassInfo() 
    { 
    	 delete [] m_szName; 
        m_pFactory->InternalRelease();
    }
};

LIST_ENTRY g_ClassInfoHead = { &g_ClassInfoHead, &g_ClassInfoHead };

static HMODULE ghModule;

void SetModuleHandle(HMODULE hModule)
{
    ghModule = hModule;
}

HMODULE GetThisModuleHandle()
{
    return ghModule;
}


HRESULT RegisterServer(CClassInfo* pInfo, BOOL bExe)
{
    WCHAR       wchId[128];
    TCHAR       szPath[256];
    TCHAR       szModule[MAX_PATH+1];
    HKEY        hKey1, hKey2;

    StringFromGUID2( *pInfo->m_pClsid, wchId, 128 );

    // Create the path.

    CreatePathString( szPath, 
                      256, 
                      wchId,
                      TEXT("SOFTWARE\\Classes\\CLSID\\"));

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szPath, &hKey1);

    int cLen = lstrlen(pInfo->m_szName)+100;
    TCHAR* szName = new TCHAR[cLen];
    StringCchPrintf( szName, cLen, L"Microsoft WBEM %s", pInfo->m_szName );

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, 
                  (BYTE *)szName, (lstrlen(szName)+1) * sizeof(TCHAR));
    RegCreateKey(hKey1,
        bExe?TEXT("LocalServer32"): TEXT("InprocServer32"),
        &hKey2);

    szModule[MAX_PATH] = L'0';
    GetModuleFileName(ghModule, szModule,  MAX_PATH);
    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
                                        (lstrlen(szModule)+1) * sizeof(TCHAR));

    const TCHAR* szModel;
    if(pInfo->m_bFreeThreaded)
    {
		if ( !pInfo->m_bReallyFree )
		{
			szModel = TEXT("Both");
		}
		else
		{
			szModel = TEXT("Free");
		}
    }
    else
    {
        szModel = TEXT("Apartment");
    }
    RegSetValueEx(hKey2, TEXT("ThreadingModel"), 0, REG_SZ, 
                                        (BYTE *)szModel, (lstrlen(szModel)+1) * sizeof(TCHAR));

    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return NOERROR;
}

HRESULT UnregisterServer(CClassInfo* pInfo, BOOL bExe)
{
    WCHAR  wchId[128];
    TCHAR  szPath[256];
    HKEY hKey;

    StringFromGUID2( *pInfo->m_pClsid, wchId, 128 );

    // Create the path using the CLSID



    CreatePathString( szPath, 
                      256, 
                      wchId,
                      TEXT("SOFTWARE\\Classes\\CLSID\\")); 

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szPath, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, bExe? TEXT("LocalServer32"): TEXT("InProcServer32"));
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\CLSID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKeyW(hKey, wchId);
        RegCloseKey(hKey);
    }

    return NOERROR;
}

extern CLifeControl* g_pLifeControl;
CComServer* g_pServer = NULL;

CComServer::CComServer()    
{
    g_pServer = this;
}

CLifeControl* CComServer::GetLifeControl()
{
    return g_pLifeControl;
}

HRESULT CComServer::InitializeCom()
{
    return CoInitialize(NULL);
}

HRESULT CComServer::AddClassInfo( REFCLSID rclsid, 
                                  CUnkInternal* pFactory, 
                                  LPTSTR szName, 
                                  BOOL bFreeThreaded, 
                                  BOOL bReallyFree /* = FALSE */)
{
    if(pFactory == NULL)
        return E_OUTOFMEMORY;

    CClassInfo* pNewInfo = new CClassInfo;

    if (!pNewInfo)
        return E_OUTOFMEMORY;
    
    //
    // this object does not hold external references to class factories.
    //
    pFactory->InternalAddRef();

    pNewInfo->m_pFactory = pFactory;
    pNewInfo->m_pClsid = &rclsid;

    pNewInfo->m_szName = new TCHAR[lstrlen(szName) + 1];
    if (!pNewInfo->m_szName)
    {
        delete pNewInfo;
        return E_OUTOFMEMORY;
    }

    StringCchCopy( pNewInfo->m_szName, lstrlen(szName)+1, szName);
    pNewInfo->m_bFreeThreaded = bFreeThreaded;
    pNewInfo->m_bReallyFree = bReallyFree;

    InsertTailList(&g_ClassInfoHead,&pNewInfo->m_Entry);
    return S_OK;
}

HRESULT CComServer::RegisterInterfaceMarshaler(REFIID riid, LPTSTR szName,
                                            int nNumMembers, REFIID riidParent)
{
    WCHAR       wchId[128];
    TCHAR       szPath[256];
    HKEY        hKey1, hKey2;

    StringFromGUID2( riid, wchId, 128 );
    
    // Create the path.

    CreatePathString(szPath,256,wchId,TEXT("SOFTWARE\\Classes\\Interface\\"));


    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szPath, &hKey1);

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)szName, (lstrlen(szName)+1) * sizeof(TCHAR));
    RegCreateKey(hKey1, TEXT("ProxyStubClsid32"), &hKey2);
    RegSetValueExW( hKey2, NULL, 0, REG_SZ,(BYTE*)wchId,(wcslen(wchId)+1)*2);
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    return S_OK;
}

HRESULT CComServer::RegisterInterfaceMarshaler( REFIID riid, 
                                                CLSID psclsid, 
                                                LPTSTR szName,
                                                int nNumMembers, 
                                                REFIID riidParent)
{
   
    WCHAR wchId[128];
    WCHAR wchClsid[128];   
    TCHAR szPath[256];
    TCHAR szNumMethods[32];
    HKEY hKey1, hKey2, hKey3;

    // Create the path.

    StringFromGUID2(riid, wchId, 128);

    // ProxyStub Class ID

    StringFromGUID2(psclsid, wchClsid, 128);

    CreatePathString( szPath, 
                      256, 
                      wchId, 
                      TEXT("SOFTWARE\\Classes\\Interface\\"));

    // Number of Methods
    StringCchPrintf( szNumMethods, 32, TEXT("%d"), nNumMembers );

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szPath, &hKey1);

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)szName, (lstrlen(szName)+1) * sizeof(TCHAR));
    RegCreateKey(hKey1, TEXT("ProxyStubClsid32"), &hKey2);
    RegSetValueExW(hKey2,NULL,0,REG_SZ,(BYTE*)wchClsid,(wcslen(wchClsid)+1)*2);

    RegCreateKey(hKey1, TEXT("NumMethods"), &hKey3);
    RegSetValueEx(hKey3, NULL, 0, REG_SZ, (BYTE *)szNumMethods, (lstrlen(szNumMethods)+1) * sizeof(TCHAR));
    
    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    RegCloseKey(hKey3);
    return S_OK;
}

HRESULT CComServer::UnregisterInterfaceMarshaler(REFIID riid)
{
    WCHAR  wchId[128];
    TCHAR  szPath[256];
    HKEY hKey;

    // Create the path using the CLSID

    StringFromGUID2(riid, wchId, 128);
    CreatePathString(szPath,256,wchId,TEXT("SOFTWARE\\Classes\\Interface\\"));

    // First delete the ProxyStubClsid32 subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szPath, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, TEXT("ProxyStubClsid32"));
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Classes\\Interface"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKeyW( hKey, wchId );
        RegCloseKey(hKey);
    }

    return S_OK;
}

//
// the caller will hold g_CS
//

void EmptyList()
{
    while(!IsListEmpty(&g_ClassInfoHead))
    {
        CClassInfo * pInfo = CONTAINING_RECORD(g_ClassInfoHead.Blink,CClassInfo,m_Entry);
        RemoveEntryList(&pInfo->m_Entry);
        delete pInfo;
    }
}

BOOL GlobalCanShutdown()
{
    return g_pServer->CanShutdown();
}

HRESULT GlobalInitialize()
{
    return g_pServer->Initialize();
}

void GlobalUninitialize()
{
    g_pServer->Uninitialize();
    EmptyList();  
}

void GlobalPostUninitialize()
{
    g_pServer->PostUninitialize();
}

void GlobalRegister()
{
    g_pServer->Register();
}

void GlobalUnregister()
{
    g_pServer->Unregister();
}

HRESULT GlobalInitializeCom()
{
    return g_pServer->InitializeCom();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\comlib\comdllsv\dllmain.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DLLMAIN.CPP

Abstract:

    DLL/COM helpers.

History:

--*/

#include "precomp.h"
#include "commain.cpp"

#include <statsync.h>

void EmptyList();

class CDllLifeControl : public CLifeControl
{
protected:
    long m_lCount;
public:
    CDllLifeControl() : m_lCount(0) {}

    virtual BOOL ObjectCreated(IUnknown* pv)
    {
        InterlockedIncrement(&m_lCount);
        return TRUE;
    }
    virtual void ObjectDestroyed(IUnknown* pv)
    {
        InterlockedDecrement(&m_lCount);
    }
    virtual void AddRef(IUnknown* pv){}
    virtual void Release(IUnknown* pv){}

    HRESULT CanUnloadNow()
    {
        HRESULT hRes = (m_lCount == 0)?S_OK:S_FALSE;
        return hRes;
    }
};

CStaticCritSec g_CS;
static BOOL g_bInit = FALSE;
static BOOL g_fAttached = FALSE;
CDllLifeControl   g_LifeControl;
CLifeControl* g_pLifeControl = &g_LifeControl;

//
// these 2 functions assume that g_CS is held.
// 

HRESULT EnsureInitialized()
{
    HRESULT hr;

    if ( g_bInit )
    {
        return S_OK;
    }

    hr = GlobalInitialize();

    if ( FAILED(hr) )
    {
        return hr;
    }

    g_bInit = TRUE;

    return S_OK;
}

void EnsureUninitialized()
{
    if ( g_bInit )
    {
        GlobalUninitialize();
        g_bInit = FALSE;
    }
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppv)
{
    HRESULT hr;

    if ( !g_fAttached )  return E_UNEXPECTED;

    CMyInCritSec ics( &g_CS ); 
    
    if ( !g_fAttached )  return E_UNEXPECTED;

    hr = EnsureInitialized();

    if ( FAILED(hr) )
    {
        return hr;
    }

    for(LIST_ENTRY * pEntry = g_ClassInfoHead.Flink; 
         pEntry != &g_ClassInfoHead ;
         pEntry = pEntry->Flink)
    {
        CClassInfo* pInfo = CONTAINING_RECORD(pEntry,CClassInfo,m_Entry);
        if(*pInfo->m_pClsid == rclsid)    
        {
            return pInfo->m_pFactory->QueryInterface(riid, ppv);
        }
    }

    return E_FAIL;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{

    if ( !g_fAttached )  return S_FALSE;
    
    CMyInCritSec ics( &g_CS ); 

    if ( !g_fAttached )  return S_FALSE;

    if ( !g_bInit )
    {
        return S_OK;
    }

    HRESULT hres = g_LifeControl.CanUnloadNow();
    
    if( hres == S_OK )
    {
        if ( GlobalCanShutdown() )
        {
            EnsureUninitialized();
            return S_OK;
        }
    }

    return S_FALSE;
}


//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during initialization or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    HRESULT hr;

    if ( !g_fAttached )  return E_UNEXPECTED;
    CMyInCritSec ics( &g_CS ); 
    if ( !g_fAttached )  return E_UNEXPECTED;
    
    hr = EnsureInitialized();

    if ( FAILED(hr) )  return hr;


    GlobalRegister();

    for(LIST_ENTRY * pEntry = g_ClassInfoHead.Flink;
         pEntry != &g_ClassInfoHead;
         pEntry = pEntry->Flink)
    {
        CClassInfo* pInfo = CONTAINING_RECORD(pEntry,CClassInfo,m_Entry);
        HRESULT hres = RegisterServer(pInfo, FALSE);
        if(FAILED(hres)) return hres;
    }

    return S_OK;
}


//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    if ( !g_fAttached )  return E_UNEXPECTED;
    CMyInCritSec ics( &g_CS ); 
    if ( !g_fAttached )  return E_UNEXPECTED;

    
    hr = EnsureInitialized();

    if ( FAILED(hr) )
    {
        return hr;
    }

    GlobalUnregister();

    for(LIST_ENTRY * pEntry = g_ClassInfoHead.Flink;
          pEntry != &g_ClassInfoHead;
          pEntry = pEntry->Flink)
    {
        CClassInfo* pInfo = CONTAINING_RECORD(pEntry,CClassInfo,m_Entry);
        HRESULT hres = UnregisterServer(pInfo, FALSE);
        if(FAILED(hres)) return hres;
    }

    return S_OK;
}

BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    if (DLL_PROCESS_ATTACH==ulReason)
    {
        SetModuleHandle(hInstance);
        g_fAttached = TRUE;
	 DisableThreadLibraryCalls ( hInstance ) ;
        if (CStaticCritSec::anyFailure())
        	return FALSE;                       
    }
    else if(DLL_PROCESS_DETACH==ulReason)
    {
        if ( g_fAttached )
        {
            GlobalPostUninitialize();

            CMyInCritSec ics( &g_CS );
            EmptyList();
        }

        // This will prevent us from performing any other logic
        // until we are attached to again.
        g_fAttached = FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\comlib\comexesv\exemain.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXEMAIN.CPP

Abstract:

  EXE/COM Helpers

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include "commain.cpp"
#include <strutils.h>

DWORD g_dwMainThreadId = 0xFFFFFFFF;

class CExeClassFactory : public IClassFactory, IExternalConnection 
{
    long m_lRef;
    IClassFactory* m_pFactory;
    CUnkInternal* m_pInternalUnk;

public:
    
    CExeClassFactory( CUnkInternal* pInternalUnk )
    : m_pInternalUnk( pInternalUnk ), m_lRef(0), m_pFactory(0)
    { 
        m_pInternalUnk->InternalAddRef();
        m_pInternalUnk->InternalQueryInterface( IID_IClassFactory,
                                                (void**)&m_pFactory );
    }

    ~CExeClassFactory()
    {
        m_pInternalUnk->InternalRelease();
    }

    STDMETHOD(QueryInterface)( REFIID riid, void** ppv )
    {
        HRESULT hr;

        if ( riid == IID_IUnknown || riid == IID_IClassFactory )
        {
            *ppv = this;
            AddRef();
            hr = S_OK;
        }
        else if ( riid == IID_IExternalConnection )
        {
            *ppv = (IExternalConnection*)this;
            AddRef();
            hr = S_OK;
        }
        else
        {
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }

        return hr;
    }
    
    STDMETHOD_(ULONG, AddRef)()
    {
        return InterlockedIncrement( &m_lRef );
    }
    
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement( &m_lRef );

        if ( lRef == 0 )
        {
            delete this;
        }

        return lRef;
    }

    STDMETHOD(CreateInstance)(IUnknown* pOuter, REFIID riid, void** ppv)
    {
        return m_pFactory->CreateInstance( pOuter, riid, ppv );
    }

    STDMETHOD(LockServer)(BOOL fLock)
    {
        return m_pFactory->LockServer( fLock );
    }

    STDMETHOD_(DWORD,AddConnection)( DWORD exconn, DWORD dwreserved )
    {
        m_pFactory->LockServer( TRUE );
        return 1;
    }

    STDMETHOD_(DWORD,ReleaseConnection)( DWORD exconn, 
                                         DWORD dwreserved,
                                         BOOL fLastReleaseCloses )
    {
        m_pFactory->LockServer( FALSE );
        return 1;
    }
};

class CExeLifeControl : public CLifeControl
{
protected:
    long m_lNumObjects;
    BOOL m_bUnloading;
    CMyCritSec m_cs;

protected:
    virtual void Quit()
    {
        PostThreadMessage(g_dwMainThreadId, WM_QUIT, 0, 0);
    }
public:
    CExeLifeControl() : m_lNumObjects(0), m_bUnloading(FALSE){}
    virtual BOOL ObjectCreated(IUnknown* pv)
    {
        CMyInCritSec ics(&m_cs);
        if(m_bUnloading)
            return FALSE;

        m_lNumObjects++;
        return TRUE;
    }
    virtual void ObjectDestroyed(IUnknown* pv)
    {
        EnterCriticalSection(&m_cs);
        long l = --m_lNumObjects;
        if(l == 0)
        {
            m_bUnloading = TRUE;
            LeaveCriticalSection(&m_cs);
            Quit();
        }
        else
        {
            LeaveCriticalSection(&m_cs);
        }
    }

    virtual void AddRef(IUnknown* pv){}
    virtual void Release(IUnknown* pv){}
};

BOOL ContainsSubstring( LPCTSTR szStr, LPCTSTR szSubStr )
{
    BOOL bContains;
#ifdef UNICODE
    bContains = wcsstr(szStr,szSubStr) != NULL;
#else
    bContains = strstr(szStr,szSubStr) != NULL;
#endif
    return bContains;
} 

void MessageLoop()
{
    MSG msg;
    while(GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}


struct ServiceInfo
{
    BOOL m_bUsed;

    LPTSTR m_szServiceName;
    LPTSTR m_szDisplayName;
    BOOL m_bAuto;

    HANDLE m_hEvent;
    SERVICE_STATUS_HANDLE m_hStatus;

    ServiceInfo() : m_bUsed(FALSE){}

} g_ServiceInfo;

void SetServiceInfo(LPTSTR szServiceName, LPTSTR szDisplayName, BOOL bAuto)
{
    g_ServiceInfo.m_bUsed = TRUE;
    g_ServiceInfo.m_szServiceName = szServiceName;
    g_ServiceInfo.m_szDisplayName = szDisplayName;
    g_ServiceInfo.m_bAuto = bAuto;
}

void WINAPI ServiceHandler(DWORD dwControl)
{
    SERVICE_STATUS Status;
    Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    Status.dwCurrentState = SERVICE_RUNNING;
    Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    Status.dwWin32ExitCode = NO_ERROR;
    Status.dwCheckPoint = 0;
    Status.dwWaitHint = 0;

    if(!SetServiceStatus(g_ServiceInfo.m_hStatus, &Status))
    {
        long lRes = GetLastError();
        return;
    }
    switch(dwControl)
    {
    case SERVICE_CONTROL_STOP:
        Status.dwCurrentState = SERVICE_STOPPED;
        SetServiceStatus(g_ServiceInfo.m_hStatus, &Status);
        SetEvent(g_ServiceInfo.m_hEvent);
        ExitProcess(0);
        return;
    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_SHUTDOWN:
        return;
    };
}

void WINAPI ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    g_ServiceInfo.m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    g_ServiceInfo.m_hStatus = RegisterServiceCtrlHandler(
        g_ServiceInfo.m_szServiceName,
        (LPHANDLER_FUNCTION)&ServiceHandler);
    if(g_ServiceInfo.m_hStatus == NULL)
    {
        long lRes = GetLastError();
        return;
    }

    SERVICE_STATUS Status;
    Status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    Status.dwCurrentState = SERVICE_START_PENDING;
    Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    Status.dwWin32ExitCode = NO_ERROR;
    Status.dwCheckPoint = 0;
    Status.dwWaitHint = 10000;

    if(!SetServiceStatus(g_ServiceInfo.m_hStatus, &Status))
    {
        long lRes = GetLastError();
        return;
    }

    Status.dwCurrentState = SERVICE_RUNNING;
    if(!SetServiceStatus(g_ServiceInfo.m_hStatus, &Status))
    {
        long lRes = GetLastError();
        return;
    }

    MessageLoop();
}


BOOL StartService()
{
    SERVICE_TABLE_ENTRY aEntries[2];
    aEntries[0].lpServiceName = g_ServiceInfo.m_szServiceName;
    aEntries[0].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)&ServiceMain;
    aEntries[1].lpServiceName = NULL;
    aEntries[1].lpServiceProc = NULL;

    if(!StartServiceCtrlDispatcher(aEntries))
    {
        long lRes = GetLastError();
        return FALSE;
    }

    return TRUE;
}

BOOL InstallService()
{
    SC_HANDLE hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    TCHAR szFilename[1024];
    GetModuleFileName(NULL, szFilename, 1023);

    SC_HANDLE hService = CreateService(hManager,
        g_ServiceInfo.m_szServiceName,
        g_ServiceInfo.m_szDisplayName,
        SERVICE_ALL_ACCESS,
        SERVICE_WIN32_OWN_PROCESS,
        g_ServiceInfo.m_bAuto?SERVICE_AUTO_START : SERVICE_DEMAND_START,
        SERVICE_ERROR_NORMAL,
        szFilename, NULL, NULL, NULL,
        NULL, //Local System
        NULL // no password
    );

    if(hService == NULL)
    {
        long lRes = GetLastError();
        return FALSE;
    }
/*
    // Create AppId key
    // ================

    GUID AppId = *g_aClassInfos[0].m_pClsid;
    char szAppId[128];
    WCHAR wszAppId[128];
    char szAppIdKey[128];

    StringFromGUID2(*pInfo->m_pClsid, wszAppId, 128);
    wcstombs(szAppId, wszAppId, 128);
    strcpy(szAppIdKey, "SOFTWARE\\Classes\\AppId\\");
    strcat(szAppIdKey, szAppId);

    HKEY hKey1;
    RegCreateKey(HKEY_LOCAL_MACHINE, szAppIdKey, &hKey1);

    RegSetValueEx(hKey1, "LocalService", 0, REG_SZ,
        g_ServiceInfo.m_szServiceName,
        strlen(g_ServiceInfo.m_szServiceName)+1);
*/
    return TRUE;

}

BOOL DeinstallService()
{
    SC_HANDLE hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    SC_HANDLE hService = OpenService(hManager, g_ServiceInfo.m_szServiceName,
        SERVICE_ALL_ACCESS);
    if(hService == NULL)
    {
        long lRes = GetLastError();
        return FALSE;
    }

    if(!DeleteService(hService))
    {
        long lRes = GetLastError();
        return FALSE;
    }

    return TRUE;
}


CExeLifeControl g_LifeControl;
CLifeControl* g_pLifeControl = &g_LifeControl;

void CALLBACK MyTimerProc(HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime)
{
    PostQuitMessage(0);
}

void __cdecl main()
{
    LPTSTR szOrigCommandLine = GetCommandLine();
    size_t cchLen = lstrlen(szOrigCommandLine)+1;
    LPTSTR szCommandLine = new TCHAR[cchLen];

    if (!szCommandLine)
        return;

    StringCchCopy( szCommandLine,cchLen,szOrigCommandLine );
    TCHAR * pc = szCommandLine;
    while(*pc)
        *(pc++) = (TCHAR)wbem_towupper(*pc);

    GlobalInitialize();

    if ( ContainsSubstring(szCommandLine, TEXT("-REGSERVER")) ||
         ContainsSubstring(szCommandLine, TEXT("/REGSERVER")) )
    {
        GlobalRegister();
        for(LIST_ENTRY * pEntry = g_ClassInfoHead.Flink;
             pEntry != &g_ClassInfoHead;
             pEntry = pEntry->Flink)
        {
            CClassInfo* pInfo = CONTAINING_RECORD(pEntry,CClassInfo,m_Entry);
            HRESULT hres = RegisterServer(pInfo, TRUE);
            if(FAILED(hres)) return;
        }
        if(g_ServiceInfo.m_bUsed)
        {
            InstallService();
        }
    }
    else if ( ContainsSubstring( szCommandLine, TEXT("-UNREGSERVER")) ||
              ContainsSubstring( szCommandLine, TEXT("/UNREGSERVER")))
    {
        GlobalUnregister();
        for(LIST_ENTRY * pEntry = g_ClassInfoHead.Flink;
             pEntry != &g_ClassInfoHead;
             pEntry = pEntry->Flink)
        {
            CClassInfo* pInfo = CONTAINING_RECORD(pEntry,CClassInfo,m_Entry);            
            HRESULT hres = UnregisterServer(pInfo, TRUE);
            if(FAILED(hres)) return;
        }
        if(g_ServiceInfo.m_bUsed)
        {
            DeinstallService();
        }
    }
    else if( !ContainsSubstring(szCommandLine, TEXT("EMBEDDING")) &&
             !g_ServiceInfo.m_bUsed )
    {
        printf("Cannot run standalone\n");
    }
    else
    {
        int i;
        if(FAILED(GlobalInitializeCom()))
            return;

        for(LIST_ENTRY * pEntry = g_ClassInfoHead.Flink;
             pEntry != &g_ClassInfoHead;
             pEntry = pEntry->Flink)
        {
            CClassInfo* pInfo = CONTAINING_RECORD(pEntry,CClassInfo,m_Entry);

            IClassFactory* pFactory = new CExeClassFactory( pInfo->m_pFactory);

            if ( pFactory == NULL )
                return;

            HRESULT hres = CoRegisterClassObject(
                *pInfo->m_pClsid, pFactory, CLSCTX_SERVER,
                REGCLS_MULTIPLEUSE, &pInfo->m_dwCookie);

            if(FAILED(hres)) return;
        }

        if(g_ServiceInfo.m_bUsed)
        {
            StartService();
        }
        else
        {
            g_dwMainThreadId = GetCurrentThreadId();
            MessageLoop();
        }

        for(LIST_ENTRY * pEntry = g_ClassInfoHead.Flink;
             pEntry != &g_ClassInfoHead;
             pEntry = pEntry->Flink)
        {
            CClassInfo* pInfo = CONTAINING_RECORD(pEntry,CClassInfo,m_Entry);            
            HRESULT hres = CoRevokeClassObject(pInfo->m_dwCookie);
            if(FAILED(hres)) return;
        }

        SetTimer(NULL, 0, 1000, (TIMERPROC)MyTimerProc);
        MessageLoop();

        GlobalUninitialize();
    }
}

int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine,
                   int nCmdShow)
{
    main();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\assocqe.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ASSOCQE.CPP

Abstract:

    WinMgmt Association Query Engine

History:

    raymcc  04-Jul-99   Adapted from QENGINE.CPP sources by revolutionary means,
                        as it was 'Independence Day 1999'.
    raymcc  31-Jul-99   Finished classref support
    raymcc  19-Aug-99   Fixed security & IN/OUT tagging problems.
    raymcc  10-Sep-99   Remaining Win2K bugs
    raymcc  25-May-00   Assoc-by-rule

--*/

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>

#include <wbemcore.h>

#include <oahelp.inl>
#include <wqllex.h>
#include <wqlnode.h>

//
// parses a string like "REF:aaaa=cccc"
// returns "AAAA=CCCC" (it uses uppercase)
// it does not use more than MaxCch charactes from the dest buffer
// and it sets a null terminator there
//
/////////////////////////////////////////

void parse_REF(WCHAR * pSrc,size_t MaxCch,WCHAR * pOut)
{
    if (L'R' == *pSrc || L'r' == *pSrc) pSrc++;
    else goto end_;
    if (L'E' == *pSrc || L'e' == *pSrc) pSrc++;
    else goto end_;
    if (L'F' == *pSrc || L'f' == *pSrc) pSrc++;
    else goto end_;
    if (L':' == *pSrc) pSrc++;
    else goto end_;
    WCHAR * pEnd = pOut + MaxCch - 1;
    while(*pSrc && (ULONG_PTR)pOut < (ULONG_PTR)pEnd) 
    {
        *pOut = ToUpper((WCHAR)*pSrc);
        pOut++;
        pSrc++;
    }
end_:
    *pOut = 0;
}


#define WBEM_S_QUERY_OPTIMIZED_OUT  0x48001

//***************************************************************************
//
//  Change these to ConfigMgr
//
//***************************************************************************

#define RUNAWAY_QUERY_TEST_THRESHOLD     (60000*10)
#define START_ANOTHER_SINK_THRESHOLD     (5000)
#define MAX_CONCURRENT_SINKS             5
#define MAX_CLASS_NAME                   512 // SEC:REVIEWED
#define DYN_CLASS_CACHE_REUSE_WINDOW     5000
#define MAX_INTERLEAVED_RESOLUTIONS      5



//
//
//  CAssocQuery::CAssocQuery
//
//***************************************************************************
// full profiler line coverage

CAssocQuery::CAssocQuery():
    m_lRef(0),
    m_pDestSink(0),
    m_pEndpoint(0),
    m_bstrEndpointClass(0),
    m_bstrEndpointRelPath(0),
    m_bstrEndpointPath(0),
    m_bEndpointIsClass(false),
    m_dwQueryStartTime(0),
    m_dwLastResultTime(0),
    m_lActiveSinks(0),
    m_hSinkDoneEvent(0),
    m_pContext(0),
    m_pNs(0),
    m_bCancel(false),
    m_bLimitNeedsDecrement(false),
    m_Parser()
{
    
    CAsyncServiceQueue* pTemp = ConfigMgr::GetAsyncSvcQueue();
    if(pTemp)
    {
        pTemp->IncThreadLimit();
        m_bLimitNeedsDecrement = true;
        pTemp->Release();
    }

}

//
//
//  CAssocQuery::~CAssocQuery()
//
//***************************************************************************
// full profiler line coverage

CAssocQuery::~CAssocQuery()
{
    // Cleanup.
    // ========

    SysFreeString(m_bstrEndpointClass);
    SysFreeString(m_bstrEndpointRelPath);
    SysFreeString(m_bstrEndpointPath);

    if (m_hSinkDoneEvent)
        CloseHandle(m_hSinkDoneEvent);

    EmptyObjectList(m_aMaster);
    EmptyObjectList(m_aDynClasses);

    // Release objects.
    // ================
    if (m_pDestSink)
        m_pDestSink->Release();
    if (m_pEndpoint)
        m_pEndpoint->Release();
    if (m_pContext)
        m_pContext->Release();
    if (m_pNs)
        m_pNs->Release();

    EmptyCandidateEpArray();    // Call this before deleting critsec

    if(m_bLimitNeedsDecrement)
    {
        CAsyncServiceQueue* pTemp = ConfigMgr::GetAsyncSvcQueue();
        if(pTemp)
        {
            pTemp->DecThreadLimit();
            pTemp->Release();
        }
    }

}


//
//
//  CAssocQuery::CreateInst
//
//  Mini factory
//
//***************************************************************************
// full profiler line coverage
CAssocQuery* CAssocQuery::CreateInst()
{
    try 
    {
        CAssocQuery *p = new CAssocQuery();  // CCritSec throws
        if (p) p->AddRef();
        return p;
    } 
    catch (CX_Exception &) 
    {
        return NULL;
    }
}


//***************************************************************************
//
//  CAssocQuery::AddRef
//
//***************************************************************************
// full profiler line coverage
ULONG CAssocQuery::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CAssocQuery::Release
//
//***************************************************************************
// full profiler line coverage
ULONG CAssocQuery::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CAssocQuery::QueryInterface
//
//***************************************************************************
// not called
HRESULT CAssocQuery::QueryInterface(
    REFIID riid,
    void** ppv
    )
{
    if (riid == IID_IUnknown)
    {
        *ppv = (IUnknown *) this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}


//***************************************************************************
//
//  CAssocQuery::Cancel
//
//  Attempts to cancel the query in the prime of its life.
//
//***************************************************************************
// not called

HRESULT CAssocQuery::Cancel()
{
    m_bCancel = true;
    return WBEM_S_NO_ERROR;
}



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN FLOW CONTROL
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//***************************************************************************
//
//  CAssocQuery::Execute
//
//  ENTRY POINT from QENGINE.CPP
//
//  Attempts to executes a 'references' or 'associators' query.
//  Returns status via <pSink>.
//
//  Uses the calling thread to coordinate the entire query. The thread
//  logically blocks (and does some background work) until the entire query
//  is finished and is responsible for sending the final HRESULT
//  to the destination sink.
//
//  Ref count of 'this' is not changed in this function.  On entry,
//  the ref count is 1, so the caller makes the Release call.
//
//***************************************************************************
// ok

HRESULT CAssocQuery::Execute(
    IN  CWbemNamespace *pNs,
    IN  LPWSTR pszQuery,
    IN  IWbemContext* pContext,
    IN  CBasicObjectSink* pSink
    )
{


    m_dwQueryStartTime = GetCurrentTime();

    // Check the Repository.
    // =====================

    m_pNs = pNs;                // Copy this for future use
    m_pNs->AddRef();

    HRESULT hRes = WBEM_E_FAILED;   
    IWbemClassObject* pErrorObj = NULL;
    // keep the order of these two objects, since CSetStatusOnMe wants ErrObj to be alive
    CReleaseMeRef<IWbemClassObject*> rmErr(pErrorObj);
    CSetStatusOnMe SetMe(pSink,hRes,pErrorObj);

    // Parse the query.
    hRes = m_Parser.Parse(pszQuery);
    if (FAILED(hRes)) return hRes;

    // If the query is KEYSONLY, we can toss out the original
    // context object and use a copy with merged in __GET_EXT_KEYS_ONLY
    // techniques.  Otherwise, we AddRef() the original context.
    // =================================================================

    BOOL bKeysOnlyQuery = (m_Parser.GetQueryType() & QUERY_TYPE_KEYSONLY) != 0;
    if (pContext)
    {
        if (bKeysOnlyQuery)
        {
            hRes = pContext->Clone(&m_pContext);  
            if (FAILED(hRes)) return hRes;

            hRes = m_pNs->MergeGetKeysCtx(m_pContext);
            if (FAILED(hRes)) return hRes;
        }
        else
        {
            m_pContext = pContext;      // Yup, this too.
            m_pContext->AddRef();
        }
    }

    // At this point, the query and object path are syntactically
    // valid.  That's all we know.  Not much, eh?
    //
    // Next, get the endpoint referred to in the query.
    // ===========================================================



    hRes = pNs->Exec_GetObjectByPath((LPWSTR) m_Parser.GetTargetObjPath(),
                                                            0,             
                                                            pContext,  
                                                            &m_pEndpoint,                
                                                            &pErrorObj);
    if (FAILED(hRes)) return hRes;

    rmErr.release();
    pErrorObj = NULL;

    // Record whether the endpoint is a class or instance.
    CVARIANT v;
    m_pEndpoint->Get(L"__GENUS", 0, &v, 0, 0);
    if (v.GetLONG() == 1)
        m_bEndpointIsClass = true;
    else
        m_bEndpointIsClass = false;

    // Initial validation.
    // For SCHEMAONLY, the endpoint must be a class.
    // For CLASSDEFS_ONLY, the endpoint must be an instance.
    // Otherwise, the endpoint can be either a class or
    // instance the association must be an instance.
    // ====================================================

    if (m_Parser.GetQueryType() & QUERY_TYPE_SCHEMA_ONLY)
    {
        if (m_bEndpointIsClass == false)  return hRes = WBEM_E_INVALID_QUERY;
    }
    else if (m_Parser.GetQueryType() & QUERY_TYPE_CLASSDEFS_ONLY)
    {
        if (m_bEndpointIsClass == true) return hRes = WBEM_E_INVALID_QUERY;

        // Don't allow CLASSDEFSONLY and RESULTCLASS at the same time.
        if (m_Parser.GetResultClass() != 0)  return hRes = WBEM_E_INVALID_QUERY;
    }

    // Get the class hierarchy and other info about the endpoint.
    // ==========================================================

    hRes = St_GetObjectInfo(m_pEndpoint,
                                        &m_bstrEndpointClass,
                                        &m_bstrEndpointRelPath,
                                        &m_bstrEndpointPath,
                                        m_aEndpointHierarchy);

    if (FAILED(hRes))  return hRes;


    // Now we at least know if there is going to be a chance.
    m_pDestSink = pSink;
    m_pDestSink->AddRef();

    try
    {
        BranchToQueryType();            // Forward-only execution, conceptually
    }
    catch(CX_Exception &)
    {       
        return hRes = WBEM_E_CRITICAL_ERROR;
    }

    SetMe.dismiss();
    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//  CAssocQuery::BranchToQueryType
//
//  This takes over once the query is known to be syntactically valid
//  and the endpoint object was found.
//
//  Status & results are returned to the destination sink in the
//  deeper functions.
//
//***************************************************************************
// ok

void CAssocQuery::BranchToQueryType()
{
    // Next, test for <SchemaOnly> or <ClassDefsOnly> query,
    // which allows us a short-cut.
    // =====================================================

    if (m_Parser.GetQueryType() & QUERY_TYPE_SCHEMA_ONLY)
    {
        ExecSchemaQuery();  // forward-only branch
    }
    // If here, we are executing a 'normal' query where
    // the association must be an instance.
    // ================================================
    else
    {
        ExecNormalQuery();
    }
}


//****************************************************************************
//
//  CAssocQuery::ExecSchemaQuery
//
//  This executes a SCHEMAONLY.
//
//  1. Get the list of classes which can reference the endpoint.
//  2. If REFERENCES OF, branch.
//  3. IF ASSOCIATORS OF, branch.
//
//  Execution model from this point:
//    Deeper functions only Indicate() results or else return hRes to
//    caller.  The only SetStatus() call for the destination sink
//    is at the bottom of this function.
//
//***************************************************************************
// ok

void CAssocQuery::ExecSchemaQuery()
{
    HRESULT hRes;
    CFlexArray aResultSet;

    // (1)
    // ===
    hRes = BuildMasterAssocClassList(aResultSet);

    if (SUCCEEDED(hRes))
    {
        // (2)
        // ===
        if (m_Parser.GetQueryType() & QUERY_TYPE_GETREFS)
            hRes = SchemaQ_RefsQuery(aResultSet);
        // (3)
        // ===
        else
            hRes = SchemaQ_AssocsQuery(aResultSet);
    }

    m_pDestSink->Return(hRes);
}


//****************************************************************************
//
//   CAssocQuery::ExecNormalQuery
//
//  This executes a normal query.  The association object must be
//  an instance pointing to the endpoint.  Either endpoint can be a
//  class or an instance.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::ExecNormalQuery()
{
    HRESULT hRes = WBEM_E_FAILED;
    IWbemClassObject * pErrObj = NULL;
    CSetStatusOnMe SetMe(m_pDestSink,hRes,pErrObj);

    DWORD dwQueryType = m_Parser.GetQueryType();

    // Set up some helper events.
    // ==========================

    m_hSinkDoneEvent = CreateEvent(0,0,0,0);
    if (NULL == m_hSinkDoneEvent) return hRes = WBEM_E_OUT_OF_MEMORY;

        
    // Get the list of classes that can participate.
    hRes = BuildMasterAssocClassList(m_aMaster);
    if (FAILED(hRes)) return hRes;

    // Now reduce this to instantiable classes.
    hRes = ReduceToRealClasses(m_aMaster);
    if (FAILED(hRes)) return hRes;

    // Filter class list based on some quick analysis of the query.
    hRes = NormalQ_PreQueryClassFilter(m_aMaster);
    if (FAILED(hRes)) return hRes;

    // Remove non-dynamic classes, as we will get static refs all in one go.
    // IMPORTANT: This must remain located after the zero-array size test above,
    // because the array size *will* be zero if the relationships are
    // all in the repository and we don't want the query to fail!
    hRes = RemoveNonDynClasses(m_aMaster);
    if (FAILED(hRes)) return hRes;

    if (ConfigMgr::ShutdownInProgress()) return hRes = WBEM_E_SHUTTING_DOWN;

    // Now, we branch depending on the query type.
    // REFERENCES OF
    if (dwQueryType & QUERY_TYPE_GETREFS)
    {
        hRes = NormalQ_ReferencesOf();
    }
    else    // ASSOCIATORS OF
    {
        hRes = NormalQ_AssociatorsOf();
    }
    if (FAILED(hRes)) return hRes;

    // At this point, we simply wait until the
    // total sink count is zero, indicating that the
    // query is completed.  We look at any errors
    // that were reported and determine what to return.
    
    while (m_lActiveSinks)
    {
        // Break if a sink finishes or 250 milliseconds pass
        // =================================================

        WaitForSingleObject(m_hSinkDoneEvent, 250);

        // If doing an ASSOCIATORS OF query (not with CLASSDEFSONLY)
        // then do some background tasking.
        // =========================================================

        if ((dwQueryType & QUERY_TYPE_GETASSOCS) != 0 &&
             (dwQueryType & QUERY_TYPE_CLASSDEFS_ONLY) == 0)
        {
                hRes = ResolveEpPathsToObjects(MAX_INTERLEAVED_RESOLUTIONS);
        }

        if (FAILED(hRes)) return hRes;
        if (m_bCancel) return hRes = WBEM_E_CALL_CANCELLED;
    }

    // If an associators query, resolve the endpoints.
    // ===============================================
    if ((dwQueryType & QUERY_TYPE_GETASSOCS) != 0)
    {
        hRes = ResolveEpPathsToObjects(-1);
    }
    return hRes;
}

//****************************************************************************
//
//  CAssocQuery::LoadCheck
//
//  Checks the load being induced by this query and prevents too much
//  concurrency.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::NormalQ_LoadCheck()
{
    while (1)
    {
        if (m_lActiveSinks <= MAX_CONCURRENT_SINKS)
            break;

        // If we have a lot of active sinks, see if they
        // are fairly active, otherwise add another one.
        // =============================================

        DWORD dwNow = GetCurrentTime();
        if (dwNow - m_dwLastResultTime > START_ANOTHER_SINK_THRESHOLD)
            break;

        if (dwNow - m_dwQueryStartTime > RUNAWAY_QUERY_TEST_THRESHOLD)
            return WBEM_E_CRITICAL_ERROR;

        Sleep(50);  // Yield time to other threads
    }

    return WBEM_S_NO_ERROR;
}



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END FLOW CONTROL
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN MASTER ASSOC CLASS LIST MANIPULATION
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


//****************************************************************************
//
//  CAssocQuery::BuildMasterAssocClassList
//
//  This function determines all the classes that could reference the
//  endpoint, depending on the query type.
//
//  Note: If the endpoint is a class and the query type is NOT schema-only,
//  this includes weakly typed classes that have HASCLASSREFS qualifiers
//  which can actually potentially reference the endpoint.
//
//  HRESULT only
//  Does not access the destination sink on error.
//
//  PARAMETERS:
//  <aClasses>      On entry, this is empty.  On exit, it contains
//                  ref counted copies of cached classes.  The objects
//                  within it need to be treated as read-only.  If they
//                  are modified in any way, they should be cloned.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::BuildMasterAssocClassList(
    IN OUT CFlexArray &aMaster
    )
{
    CWStringArray aAllRefClasses;
    HRESULT hRes;

    BOOL bSchemaOnly = (m_Parser.GetQueryType() & QUERY_TYPE_SCHEMA_ONLY) != 0;

    // If the endpoint is a class, we want to add in
    // classes with HASCLASSREF qualifiers.
    // =============================================

    if (m_bEndpointIsClass && !bSchemaOnly)
        hRes = MergeInClassRefList(aMaster);

    // Go to the repository and get all classes which
    // can reference this class. Since a lot of duplicates
    // can happen, we do a union of the class list as
    // we move through it.
    // ====================================================

    for (int i = 0; i < m_aEndpointHierarchy.Size(); i++)
    {
        CWStringArray aRefClasses;

        hRes = Db_GetRefClasses(m_aEndpointHierarchy[i],aRefClasses);

        if (hRes == WBEM_E_NOT_FOUND)
            continue;         // It might be a dynamic endpoint
        else if (FAILED(hRes))
            return hRes;

        CWStringArray aTmp;
        CWStringArray::Union(aAllRefClasses, aRefClasses, aTmp);
        aAllRefClasses = aTmp;
    }

    // Now get each class definition from the repository.
    // This results in a lot of redundancy, since we end up
    // with subclasses of classes which actually contain
    // the references.
    // ====================================================

    for (i = 0; i < aAllRefClasses.Size(); i++)
    {
        LPWSTR pszClassName = aAllRefClasses[i];

        IWbemClassObject *pObj = 0;
        hRes = Db_GetClass(pszClassName,&pObj);
        if (FAILED(hRes)) return hRes;
        CReleaseMe rmObj(pObj);

        // See if the class can really reference the endpoint
        // and discard it if not.
        hRes = CanClassRefQueryEp(bSchemaOnly, pObj, 0);
        if (FAILED(hRes)) continue;
                    
        if (CFlexArray::no_error == aMaster.Add(pObj))
        {
              pObj->AddRef();
        }
    }

    // Now get the dynamic classes from class providers.
    // =================================================

    hRes = GetDynClasses();

    // Eliminate all the classes that cannot really
    // reference the endpoint.
    // ============================================

    for (i = 0; i < m_aDynClasses.Size(); i++)
    {
        IWbemClassObject *pDynClass = (IWbemClassObject *) m_aDynClasses[i];
        hRes = CanClassRefQueryEp(bSchemaOnly, pDynClass, 0);
        if (FAILED(hRes)) continue;

        // If here, we will keep the dyn class as a result
        // set candidate.            
        if (CFlexArray::no_error == aMaster.Add(pDynClass))
        {
            pDynClass->AddRef();
        }
    }

#ifdef DIAGNOSTICS
    ClassListDump(L"BuildMasterAssocClassList", aMaster);
#endif

    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//
//  CAssocQuery::RemoveNonDynClasses
//
//  Removes all classes which don't have [dynamic] qualifiers.
//  This allows a single query to the repository for all references
//  and individual queries to providers to be cleanly separated.
//
//****************************************************************************
//  full profiler line coverage

HRESULT CAssocQuery::RemoveNonDynClasses(
    IN OUT CFlexArray &aMaster
    )
{
    HRESULT hRes1, hRes2;

    for (int i = 0; i < aMaster.Size(); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) aMaster[i];
        hRes1 = St_ObjHasQualifier(L"dynamic", pClass);
        hRes2 = St_ObjHasQualifier(L"rulebased", pClass);

        if (FAILED(hRes1) && FAILED(hRes2))
        {
            aMaster[i] = 0;
            pClass->Release();
        }
    }

    aMaster.Compress();
    return WBEM_S_NO_ERROR;
}

//****************************************************************************
//
//  CAssocQuery::MergeInClassRefList
//
//  Builds the list of classes from all sources which have HasClassRefs
//  qualifiers.  In addition, the class must be capable of referencing
//  the endpoint when it is a class.
//
//  Precondition: Query endpoint is known to be a class.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::MergeInClassRefList(
    IN OUT CFlexArray &aResultSet
    )
{
    HRESULT hRes;

    CFlexArray aTemp;
    hRes = Db_GetClassRefClasses(aTemp);
    if (FAILED(hRes)) return hRes;

    int i;
    for (i = 0; i < aTemp.Size() && SUCCEEDED(hRes); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) aTemp[i];
        HRESULT hResInner = CanClassRefQueryEp(FALSE, pClass, 0);

        if (SUCCEEDED(hResInner))
        {
            if (CFlexArray::no_error != aResultSet.Add(pClass))
            {
                pClass->Release();
                hRes = WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
            pClass->Release();
    }

    // final cleanup, start from where the other loop ended
    for (int j=i;j<aTemp.Size();j++)
    {
            IWbemClassObject *pClass = (IWbemClassObject *) aTemp[i];
            pClass->Release();
    }

    return hRes;
}


//****************************************************************************
//
//  CAssocQuery::CanClassRefQueryEp
//
//  Determines if a class can reference the endpoint class.
//
//  This works for both strongly typed and CLASSREF typed objects.
//
//  PARAMETERS:
//  <bStrict>           If TRUE, the match must be exact.  The tested
//                      class must have properties which directly reference
//                      the endpoint class name.  If FALSE, the class
//                      can have properties which reference any of the
//                      superclasses of the query endpoint class.
//  <pCls>              The class to test.
//  <paNames>           The role properties which would reference the query
//                      endpoint. (optional). If not NULL, should point to
//                      an empty array.
//
//  Returns:
//  WBEM_S_NO_ERROR if so
//  WBEM_E_FAILED
//
//****************************************************************************
// partly tested

HRESULT CAssocQuery::CanClassRefQueryEp(
    IN BOOL bStrict,
    IN IWbemClassObject *pCls,
    OUT CWStringArray *paNames
    )
{
    BOOL bIsACandidate = FALSE;
    HRESULT hRes;
    CIMTYPE cType;
    LONG lFlavor;

    LPCWSTR pszRole = m_Parser.GetRole();

    // Loop through the properties trying to find a legitimate
    // reference to our endpoint class.
    // =======================================================

    pCls->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;
        hRes = pCls->Next(
            0,                  // Flags
            &strPropName,       // Name
            0,                  // Value
            &cType,             // CIMTYPE
            &lFlavor            // FLAVOR
            );

        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        // If the ROLE property is specified, and this property is not that
        // ROLE, we can immediately eliminate it.
        // ================================================================

        if (pszRole && wbem_wcsicmp(strPropName, pszRole) != 0)
            continue;

        // Mask out references inherited from parent classes, if strict
        // rules in force.
        // ============================================================

        //if (bStrict && lFlavor == WBEM_FLAVOR_ORIGIN_PROPAGATED)
        //    continue;

        // If the object has reference properties which are not inherited
        // from the parent, then it is immediately candidate.
        // ===============================================================

        hRes = CanPropRefQueryEp(bStrict, strPropName, pCls, 0);
        if (SUCCEEDED(hRes))
        {
            bIsACandidate = TRUE;
            if (paNames)
                paNames->Add(strPropName);
        }
    }   // Enum of ref properties


    pCls->EndEnumeration();

    if (bIsACandidate)
        return WBEM_S_NO_ERROR;

    return WBEM_E_FAILED;
}

//****************************************************************************
//
//  CAssocQuery::GetCimTypeForRef
//
//****************************************************************************
//

HRESULT CAssocQuery::GetCimTypeForRef(
    IN IWbemClassObject *pCandidate,
    IN BSTR pszRole,
    OUT BSTR *strCimType
    )
{
    if (strCimType == 0)
        return WBEM_E_INVALID_PARAMETER;
    *strCimType = 0;

    // Get the qualifier set for the specified <role> property.
    // ========================================================

    IWbemQualifierSet *pQSet = 0;
    HRESULT hRes = pCandidate->GetPropertyQualifierSet(pszRole, &pQSet);
    if (FAILED(hRes))
        return WBEM_E_NOT_FOUND;
    CReleaseMe _1(pQSet);

    // Now, get the type of the role.
    // ==============================

    CVARIANT vCimType;
    hRes = pQSet->Get(L"CIMTYPE", 0, &vCimType, 0);
    if (FAILED(hRes) || V_VT(&vCimType) != VT_BSTR)
        return WBEM_E_FAILED;

    // Get the class name from it.
    // ===========================

    BSTR strRefClass = V_BSTR(&vCimType);
    if (wcslen_max(strRefClass,MAX_CLASS_NAME) > MAX_CLASS_NAME)        
        return WBEM_E_FAILED;

    wchar_t ClassName[MAX_CLASS_NAME];
    *ClassName = 0;
    if (strRefClass)
    {
        if (wcslen_max(strRefClass,MAX_CLASS_NAME) > MAX_CLASS_NAME)  return WBEM_E_FAILED;        
        parse_REF(strRefClass,MAX_CLASS_NAME,ClassName);       
    }

    if (0 != ClassName[0])
    {
        *strCimType = SysAllocString(ClassName);
        return WBEM_S_NO_ERROR;
    }

    return WBEM_E_NOT_FOUND;
}



//****************************************************************************
//
//  CAssocQuery::DoesAssocInstRefQueryEp
//
//  Determines if an association instance actually references the
//  query endpoint.  Returns the role via which it actually references
//  the query endpoint.
//
//****************************************************************************
//
HRESULT CAssocQuery::DoesAssocInstRefQueryEp(
    IN IWbemClassObject *pObj,
    OUT BSTR *pstrRole
    )
{
    if (pstrRole == 0 || pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    BOOL bIsACandidate = FALSE;
    HRESULT hRes;

    // Loop through the properties trying to find a legitimate
    // reference to our endpoint class.
    // =======================================================

    pObj->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;
        hRes = pObj->Next(
            0,                  // Flags
            &strPropName,       // Name
            0,                  // Value
            0,
            0
            );

        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        hRes = RoleTest(m_pEndpoint, pObj, m_pNs, strPropName, ROLETEST_MODE_PATH_VALUE);
        if (SUCCEEDED(hRes))
        {
            *pstrRole = SysAllocString(strPropName);
            pObj->EndEnumeration();
            return WBEM_S_NO_ERROR;
        }
    }   // Enum of ref properties


    pObj->EndEnumeration();

    return WBEM_E_NOT_FOUND;
}

//****************************************************************************
//
//  CAssocQuery::NormalQ_PreQueryClassFilter
//
//  For normal queries, filters the master class list depending on the
//  query parameters and the query type to eliminate as many association
//  classes as possible from participating in the query.  This is done
//  entirely by schema-level analysis and the query parameters.
//
//  Also, if the query endpoint is a class, then we eliminate dynamic
//  classes which don't have HasClassRefs qualifiers.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::NormalQ_PreQueryClassFilter(
    CFlexArray &aMaster
    )
{
    HRESULT hRes;
    BOOL bChg = FALSE;

    CWStringArray aResClassHierarchy;    // Result class hierarchy
    CWStringArray aAssocClassHierarchy;  // Association class hierarchy

    IWbemClassObject *pResClass = 0;     // Result class object
    IWbemClassObject *pAssocClass = 0;   // Assoc class object

    LPCWSTR pszResultClass = m_Parser.GetResultClass();
    LPCWSTR pszAssocClass = m_Parser.GetAssocClass();

    // Get the RESULTCLASS.
    // ====================

    if (pszResultClass)
    {
        HRESULT hRes = GetClassFromAnywhere(pszResultClass, 0, &pResClass);
        if (hRes == WBEM_E_NOT_FOUND)
        {
            EmptyObjectList(aMaster);
            return WBEM_S_NO_ERROR;
        }
        else if (FAILED(hRes))
            return WBEM_E_FAILED;

        // Get its hierarchy.
        // ==================

        hRes = St_GetObjectInfo(
            pResClass, 0, 0, 0,
            aResClassHierarchy
            );

        if (FAILED(hRes))
            return WBEM_E_FAILED;

        // Get all the subclasses.
        // =======================

        CFlexArray aFamily;
        hRes = GetClassDynasty(pszResultClass, aFamily);
        OnDelete<CFlexArray &,void(*)(CFlexArray &),EmptyObjectList> ArrRelMe(aFamily);

        for (int i = 0; i < aFamily.Size(); i++)
        {
            CVARIANT vClass;
            IWbemClassObject *pCls = (IWbemClassObject *) aFamily[i];
            if (FAILED(hRes = pCls->Get(L"__CLASS", 0, &vClass, 0, 0))) return hRes;
            if (CFlexArray::no_error != aResClassHierarchy.Add(vClass.GetStr()))
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    CReleaseMe _1(pResClass);

    // If the ASSOCCLASS was specified, get it and its hierarchy.
    // ==========================================================

    if (pszAssocClass)
    {
        HRESULT hRes = GetClassFromAnywhere(pszAssocClass, 0, &pAssocClass);
        if (hRes == WBEM_E_NOT_FOUND)
        {
            EmptyObjectList(aMaster);
            return WBEM_S_NO_ERROR;
        }
        else if (FAILED(hRes))
            return WBEM_E_FAILED;

        // Get its hierarchy.
        // ==================

        hRes = St_GetObjectInfo(
            pAssocClass, 0, 0, 0,
            aAssocClassHierarchy
            );

        if (FAILED(hRes))
            return WBEM_E_FAILED;
    }

    CReleaseMe _2(pAssocClass);


    // Prepurge if REFERENCES OF + RESULTCLASS is used
    // or ASSOCIATORS OR + ASSOCCLASS.  In both of these cases, the master class
    // list is largely irrelevant and will be mostly purged because these are present
    // in the query.
    //
    // [a] If RESULTCLASS/ASSOCCLASS is directly mentioned in the master, the master is
    //     purged and RESULTCLASS/ASSOCCLASS is added.
    //
    // [b] If RESULTCLASS/ASSOCCLASS is a subclass of a class in the master list, we examine
    //     its class hierarchy and determine if any of its superclasses appear in
    //     the master list.  If so, we purge the master list and replace it with a
    //     single entry, containing the RESULTCLASS def.
    //
    // [c] If RESULTCLASS/ASSOCCLASS is a superclass, we examine each class C in the
    //     master and determine if any of the superclasses of C are the
    //     RESULTCLASS/ASSOCCLASS.  If so, we retain C in the master. If not, we purge it.
    //

    LPCWSTR pszTestClass = 0;   // RESULTCLASS/ASSOCCLASS alias
    IWbemClassObject *pTestClass = 0;
    CWStringArray *paTest = 0;

    if ((m_Parser.GetQueryType() & QUERY_TYPE_GETREFS) && pszResultClass)
    {
        pszTestClass = pszResultClass;
        pTestClass = pResClass;
        paTest = &aResClassHierarchy;
    }

    if ((m_Parser.GetQueryType() & QUERY_TYPE_GETASSOCS) && pszAssocClass)
    {
        pszTestClass = pszAssocClass;
        pTestClass = pAssocClass;
        paTest = &aAssocClassHierarchy;
    }

    if (pszTestClass && pTestClass && paTest)
    {
        // Test [a] : Look for direct match.
        // =================================

        BOOL bPurgeAndReplace = FALSE;

        for (int i = 0; i < aMaster.Size(); i++)
        {
            IWbemClassObject *pClass = (IWbemClassObject *) aMaster[i];
            CVARIANT v;
            hRes = pClass->Get(L"__CLASS", 0, &v, 0, 0);
            if (FAILED(hRes))
                return hRes;

            if (wbem_wcsicmp(V_BSTR(&v), pszTestClass) == 0)
            {
                bPurgeAndReplace = TRUE;
            }

            // Test [b]
            // If here, there was no equivalence.  So, the test class may be a subclass
            // of a class in master.  We simply look to see if this class name appears
            // in the hierarchy of the result class.
            // ===========================================================================

            if (!bPurgeAndReplace)
            for (int ii = 0; ii < paTest->Size(); ii++)
            {
                if (wbem_wcsicmp(V_BSTR(&v), paTest->operator[](ii)) == 0) 
                {
                    bPurgeAndReplace = TRUE;
                    break;
                }
            }


            if (bPurgeAndReplace)
            {
                // Get rid of everything but this one.
                // ===================================
                EmptyObjectList(aMaster);    // Will Release <pClass> once
                if (CFlexArray::no_error == aMaster.Add(pTestClass))
                {
                    pTestClass->AddRef();                    
                }
                break;
            }
        }
    }

    // Process possibly-altered master class list using other filters.
    // ===============================================================

    for (int i = 0; i < aMaster.Size(); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) aMaster[i];
        BOOL bKeep = TRUE;

        CVARIANT v;
        hRes = pClass->Get(L"__CLASS", 0, &v, 0, 0);
        if (FAILED(hRes))
            return hRes;

        // If query type is REFERENCES OF
        // ==============================

        if (m_Parser.GetQueryType() & QUERY_TYPE_GETREFS)
        {
            // ROLE test
            // =========

            LPCWSTR pszRole = m_Parser.GetRole();
            if (pszRole)
            {
                CWStringArray aNames;
                hRes = CanClassRefQueryEp(FALSE, pClass, &aNames);
                if (FAILED(hRes))
                    bKeep = FALSE;
                else
                {
                    for (int ii = 0; ii < aNames.Size(); ii++)
                    {
                        if (wbem_wcsicmp(aNames[ii], pszRole) != 0)  
                           bKeep = FALSE;
                    }
                }
            }

            // REQUIREDQUALIFIER test
            // =======================
            LPCWSTR pszRequiredQual = m_Parser.GetRequiredQual();
            if (pszRequiredQual)
            {
                hRes = St_ObjHasQualifier(pszRequiredQual, pClass);
                if (FAILED(hRes))
                {
                    // If not in the primary object, check subclasses.
                    CFlexArray aDynasty;
                    hRes = GetClassDynasty(v.GetStr(), aDynasty);
                    if (FAILED(hRes))
                        bKeep = FALSE;

                    int nCandidateCount = 0;
                    for (int ii = 0; ii< aDynasty.Size(); ii++)
                    {
                        IWbemClassObject *pTestCls = (IWbemClassObject *) aDynasty[ii];
                        hRes = St_ObjHasQualifier(pszRequiredQual, pTestCls);
                        if (SUCCEEDED(hRes))
                            nCandidateCount++;
                    }
                    EmptyObjectList(aDynasty);
                    if (nCandidateCount == 0)
                        bKeep = FALSE;  // Nobody in the family has the qualifier
                }
            }

            // RESULTCLASS test, test [c]
            // ==========================
            LPCWSTR pszResultClass2 = m_Parser.GetResultClass();
            if (pszResultClass2)
            {
                hRes = St_ObjIsOfClass(pszResultClass2, pClass);
                if (FAILED(hRes))
                    bKeep = FALSE;
            }
        }

        // If query type is ASSOCIATORS OF
        // ===============================

        else
        {
            // ROLE test
            // =========

            LPCWSTR pszRole = m_Parser.GetRole();
            if (pszRole)
            {
                CWStringArray aNames;
                hRes = CanClassRefQueryEp(FALSE, pClass, &aNames);
                if (FAILED(hRes))
                    bKeep = FALSE;
                else
                {
                    bKeep = FALSE;
                    for (int ii = 0; ii < aNames.Size(); ii++)
                    {
                        if (wbem_wcsicmp(aNames[ii], pszRole) == 0) 
                            bKeep = TRUE;
                    }
                }
            }

            // ASSOCCLASS, test[c]
            // ===================

            LPCWSTR pszAssocClass2 = m_Parser.GetAssocClass();
            if (pszAssocClass2)
            {
                hRes = St_ObjIsOfClass(pszAssocClass2, pClass);
                if (FAILED(hRes))
                    bKeep = FALSE;
            }

            // REQUIREDASSOCQUALIFER
            // =====================

            LPCWSTR pszRequiredAssocQual = m_Parser.GetRequiredAssocQual();
            if (pszRequiredAssocQual)
            {
                hRes = St_ObjHasQualifier(pszRequiredAssocQual, pClass);
                if (FAILED(hRes))
                {
                    // If not in the primary object, check subclasses.
                    CFlexArray aDynasty;
                    hRes = GetClassDynasty(v.GetStr(), aDynasty);
                    if (FAILED(hRes))
                        bKeep = FALSE;

                    int nCandidateCount = 0;
                    for (int ii = 0; ii < aDynasty.Size(); ii++)
                    {
                        IWbemClassObject *pTestCls = (IWbemClassObject *) aDynasty[ii];
                        hRes = St_ObjHasQualifier(pszRequiredAssocQual, pTestCls);
                        if (SUCCEEDED(hRes))
                            nCandidateCount++;
                    }
                    EmptyObjectList(aDynasty);
                    if (nCandidateCount == 0)
                        bKeep = FALSE;  // Nobody in the family has the qualifier
                }
            }

            // If RESULTCLASS was used, branch out and see if the association
            // class can even reference it.
            // ==============================================================

            LPCWSTR pszResultClass3 = m_Parser.GetResultClass();
            if (pszResultClass3 && m_bEndpointIsClass == FALSE)
            {
                // The above compound test is to err on the side of safety,
                // as the following function cannot deal with CLASSREFs. So,
                // we simply don't try to prefilter in that case.
                // =========================================================

                hRes = CanAssocClassRefUnkEp(pClass, aResClassHierarchy);
                if (FAILED(hRes))
                    bKeep = FALSE;
            }

            // If RESULTROLE is used, ensure the class even has a property of this name.
            // =========================================================================

            LPCWSTR pszResultRole = m_Parser.GetResultRole();
            if (pszResultRole)
            {
                CVARIANT v2;
                hRes = pClass->Get(pszResultRole, 0, &v2, 0, 0);
                if (FAILED(hRes))
                    bKeep = FALSE;
            }

        }   // end ASSOCIATORS OF test block

        // If query endpoint is a class, eliminate [dynamic] classes which don't
        // have HasClassRefs.
        // ======================================================================

        if (m_bEndpointIsClass)
        {
            hRes = St_ObjHasQualifier(L"dynamic", pClass);
            if (SUCCEEDED(hRes))
            {
                hRes = St_ObjHasQualifier(L"HasClassRefs", pClass);
                if (FAILED(hRes))
                    bKeep = FALSE;
            }
        }


        // Yawn.  So what did we end up deciding, anyway?
        // ==============================================

        if (bKeep == FALSE)
        {
            aMaster[i] = 0;
            pClass->Release();
        }
    }

    // No Swiss Cheese allowed. Close them holes.
    // ==========================================

    aMaster.Compress();

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CAssocQuery::CanAssocClassRefUnkEp
//
//  Determines if the association class can reference the specified
//  class.
//
//  Returns:
//  WBEM_S_NO_ERROR if the assoc can reference the specified class.
//  WBEM_E_NOT_FOUND if the assoc cannot reference the class.
//  WBEM_E_FAILED in other cases.
//
//***************************************************************************
//
HRESULT CAssocQuery::CanAssocClassRefUnkEp(
    IN IWbemClassObject *pAssocClass,
    IN CWStringArray &aUnkEpHierarchy
    )
{
    HRESULT hRes;
    BOOL bFound = FALSE;

    // Loop through all references and see if any of them can
    // reference any of the classes in the result class hierarchy.
    // ===========================================================

    hRes = pAssocClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;

        hRes = pAssocClass->Next(
            0,                  // Flags
            &strPropName,       // Name
            0,                  // Value
            0,
            0
            );

        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        BSTR strCimType = 0;
        hRes = GetCimTypeForRef(pAssocClass, strPropName, &strCimType);
        CSysFreeMe _2(strCimType);

        if (SUCCEEDED(hRes) && strCimType)
            for (int i = 0; i < aUnkEpHierarchy.Size(); i++)
            {
                if (wbem_wcsicmp(aUnkEpHierarchy[i], strCimType) == 0)  
                {
                    bFound = TRUE;
                    break;
                }
            }
    }

    pAssocClass->EndEnumeration();

    if (bFound)
    {
        return WBEM_S_NO_ERROR;
    }

    return WBEM_E_NOT_FOUND;
}


//***************************************************************************
//
//  CAssocQuery::ReduceToRealClasses
//
//  Reduces the master class list to classes which can be instantiated.
//
//  To have an instance, a class must
//  1. Have a [key] or be singleton
//  2. Not be abstract
//  3. Not have an instantiable superclass
//
//  Parameters:
//      IN OUT aMaster          Contains the unpruned result inbound
//                              and contains the pruned result set outbound
//
//  Return value:
//      HRESULT                  The destination sink is not accessed
//
//***************************************************************************
//

HRESULT CAssocQuery::ReduceToRealClasses(
    IN OUT CFlexArray & aMaster
    )
{
    HRESULT hRes;

    for (int i = 0; i < aMaster.Size(); i++)
    {
        BOOL bKeep = TRUE;
        IWbemClassObject *pObj = (IWbemClassObject *) aMaster[i];

        // See if class is abstract.
        // =========================
        IWbemQualifierSet *pQSet = 0;
        hRes = pObj->GetQualifierSet(&pQSet);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pQSet);

        CVARIANT v1, v2, v3;
        HRESULT hResAbstract = pQSet->Get(L"ABSTRACT", 0, &v1, 0);
        HRESULT hResSingleton = pQSet->Get(L"SINGLETON", 0, &v2, 0);
        HRESULT hResDynamic = pQSet->Get(L"DYNAMIC", 0, &v3, 0);

        // See if there is at least one key.
        // =================================
        HRESULT hResHasKeys = WBEM_E_FAILED;
        pObj->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
        int nCount = 0;

        while (1)
        {
            // Actually, we don't care about anything
            // other than if keys even exist.  We
            // do this by simply testing how many
            // times this iterates.

            hRes = pObj->Next(0,0,0,0,0);
            if (hRes == WBEM_S_NO_MORE_DATA)
                break;
            nCount++;
        }

        pObj->EndEnumeration();
        if (nCount)
            hResHasKeys = WBEM_S_NO_ERROR;

        // Decision matrix which perform tests as to whether
        // this is an instantiable class.
        // ==================================================

        if (SUCCEEDED(hResAbstract))           // Abstracts are never instantiable
            bKeep = FALSE;
        else if (SUCCEEDED(hResDynamic))       // Dynamics must be instantiable
            bKeep = TRUE;
        else if (SUCCEEDED(hResHasKeys))       // Must be static/non-abstract
            bKeep = TRUE;
        else if (SUCCEEDED(hResSingleton))     // Must be static/non-abstract
            bKeep = TRUE;
        else
            bKeep = FALSE;          // Must be plain old keyless class

        // Final decision to zap or keep.
        // ==============================
        if (!bKeep)
        {
            aMaster[i] = 0;
            pObj->Release();
        }
    }

    aMaster.Compress();

    // Next, eliminate subclass/superclass pairs.
    // ==========================================

    for (i = 0; i < aMaster.Size(); i++)
    {
        IWbemClassObject *pObj = (IWbemClassObject *) aMaster[i];
        CWStringArray aHierarchy;
        hRes = St_GetObjectInfo(pObj, 0, 0, 0, aHierarchy);
        BOOL bKillIt = FALSE;

        if (FAILED(hRes))
            return WBEM_E_FAILED;

        // We now have the class and all of its superclasses in
        // <aHierarchy>.  We need to look at all the other classes
        // and see if any of them have a class name mentioned in
        // this array.
        // ========================================================

        for (int i2 = 0; i2 < aMaster.Size(); i2++)
        {
            IWbemClassObject *pTest = (IWbemClassObject *) aMaster[i2];

            if (pTest == 0 || i2 == i)
                continue;
                    // If the object has already been eliminated or
                    // if we are comparing an object with itself

            CVARIANT v;
            hRes = pTest->Get(L"__CLASS", 0, &v, 0, 0);
            if (FAILED(hRes))
                return hRes;

            LPWSTR pszName = V_BSTR(&v);
            if (pszName == 0)
                return WBEM_E_FAILED;

            bKillIt = FALSE;
            for (int i3 = 0; i3 < aHierarchy.Size(); i3++)
            {
                if (wbem_wcsicmp(aHierarchy[i3], pszName) == 0)
                {
                    bKillIt = TRUE;
                    break;
                }
            }
            if (bKillIt)
                break;
        }

        if (bKillIt)
        {
            aMaster[i] = 0;
            pObj->Release();
        }
    }

    // Get rid of NULL entries.
    // ========================

    aMaster.Compress();

#ifdef DIAGNOSTICS
    ClassListDump(L"Reduced Class Set", aMaster);
#endif

    return WBEM_S_NO_ERROR;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END MASTER ASSOC CLASS LIST MANIPULATION
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@









//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN NORMAL QUERY SUPPORT
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



//****************************************************************************
//
//  CAssocQuery::NormalQ_ReferencesOf
//
//  Entry point for all normal REFERENCES OF queries.
//
//****************************************************************************
// untested; no support for classrefs, autoassocs, or classdefsonly

HRESULT CAssocQuery::NormalQ_ReferencesOf()
{
    HRESULT hRes;

    // Issue one-time call into repository for static instances.    
    CObjectSink * pSink = CreateSink(FilterForwarder_NormalRefs, L"<objdb refs request>");
    if (NULL == pSink) return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe rmSink(pSink);

    hRes = Db_GetInstRefs(m_bstrEndpointPath,pSink);
    rmSink.release();

    if ( FAILED(hRes) && !(hRes == WBEM_E_NOT_FOUND || hRes == WBEM_E_CALL_CANCELLED))
    {
        // We only go here if the repository is really griping.
        return WBEM_E_FAILED;
    }

    // Check for cancellation.
    if (m_bCancel) return WBEM_E_CALL_CANCELLED;

    hRes = WBEM_S_NO_ERROR;    

    // Now get all the dynamic ones.
    // =============================

    for (int i = 0; i < m_aMaster.Size(); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) m_aMaster[i];

        IWbemQualifierSet *pQSet = 0;
        hRes = pClass->GetQualifierSet(&pQSet);
        if (FAILED(hRes)) return hRes;
        CReleaseMe _1(pQSet);

        CVARIANT v1, v2;
        HRESULT hResRuleBased = pQSet->Get(L"RULEBASED", 0, &v1, 0);
        HRESULT hResDynamic = pQSet->Get(L"DYNAMIC", 0, &v2, 0);

        if (SUCCEEDED(hResDynamic))
        {
            // If here, a normal association class.
            //
            // Build the query relative to this class that would select instances
            // which can point to the endpoint.
            // ==================================================================

            // We may be able to infer that keys_only behavior is possible.
            // ============================================================
            IWbemContext *pCopy = 0;
            if (m_pContext)
            {
                if (FAILED(hRes = m_pContext->Clone(&pCopy))) return hRes;
            }
            CReleaseMe rmCtx(pCopy);

            BSTR strQuery = 0;
            if (FAILED(hRes = NormalQ_ConstructRefsQuery(pClass, pCopy, &strQuery))) return hRes;
            CSysFreeMe fm(strQuery);

            // The query may have been optimized out of existence.
            if (hRes == WBEM_S_QUERY_OPTIMIZED_OUT)
            {
                hRes = 0;
                continue;
            }

            // Now submit the query to the sink.
            pSink = CreateSink(FilterForwarder_NormalRefs, strQuery);
            if (NULL == pSink) WBEM_E_OUT_OF_MEMORY;
            CReleaseMe rmSink2(pSink);

            if (FAILED(hRes = CoImpersonateClient())) return hRes;
            OnDelete0<HRESULT(*)(void),CoRevertToSelf> RevertMe;
            
            BSTR bStrWQL = SysAllocString(L"WQL");
            if (NULL == bStrWQL) return WBEM_E_OUT_OF_MEMORY;;
            CSysFreeMe fm_(bStrWQL);
            
            if (FAILED(hRes = m_pNs->ExecQueryAsync(bStrWQL, strQuery, 0, pCopy, pSink))) return hRes;

            if (FAILED(hRes = NormalQ_LoadCheck())) return hRes;
            if (m_bCancel) return WBEM_E_CALL_CANCELLED;
        }
        else if (SUCCEEDED(hResRuleBased))         // Rule based
        {
            CFlexArray aTriads;
            OnDelete<CFlexArray &,void(*)(CFlexArray &),SAssocTriad::ArrayCleanup> CleanMe(aTriads);

            if (FAILED(hRes = CoImpersonateClient())) return hRes;

            {
                OnDelete0<HRESULT(*)(void),CoRevertToSelf> RevertMe;  
                if (FAILED(hRes = m_pNs->ManufactureAssocs(pClass, m_pEndpoint, m_pContext, v1.GetStr(), aTriads))) return hRes;
            }

            // Now deliver stuff to sink
            pSink = CreateSink(FilterForwarder_NormalRefs, L"<rulebased>");
            if (NULL == pSink) return WBEM_E_OUT_OF_MEMORY;
            CReleaseMe rmSink2(pSink);

            for (int ii = 0; ii < aTriads.Size(); ii++)
            {
                SAssocTriad *pTriad = (SAssocTriad *) aTriads[ii];
                pSink->Indicate(1, &pTriad->m_pAssoc);
            }
            pSink->SetStatus(0, 0, 0, 0);

        }
    }

    return hRes;
}

//****************************************************************************
//
//  CAssocQuery::NormalQ_AssociatorsOf
//
//  Entry point for all normal ASSOCIATORS OF queries.
//
//****************************************************************************
//
//

HRESULT CAssocQuery::NormalQ_AssociatorsOf()
{
    HRESULT hRes;
    CObjectSink *pSink;

    // Issue one-time call into repository for static instances.
    // =========================================================
    pSink = CreateSink(FilterForwarder_NormalAssocs, L"<objdb assocs request>");
    if (NULL == pSink) return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe rmSink(pSink);
    
    hRes = Db_GetInstRefs(m_bstrEndpointPath,pSink); // thows
    rmSink.release();

    if (FAILED(hRes) &&  !(hRes == WBEM_E_NOT_FOUND || hRes == WBEM_E_CALL_CANCELLED))
    {
        // We only go here if the repository is really griping.
        return WBEM_E_FAILED;
    }

    // Check for cancellation.
    if (m_bCancel)  return WBEM_E_CALL_CANCELLED;

    hRes = WBEM_S_NO_ERROR;

    // Now get dynamic associations.
    for (int i = 0; i < m_aMaster.Size(); i++)
    {
        IWbemClassObject *pClass = (IWbemClassObject *) m_aMaster[i];

        IWbemQualifierSet *pQSet = 0;
        hRes = pClass->GetQualifierSet(&pQSet);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe _1(pQSet);

        CVARIANT v1, v2;
        HRESULT hResRuleBased = pQSet->Get(L"RULEBASED", 0, &v1, 0);
        HRESULT hResDynamic = pQSet->Get(L"DYNAMIC", 0, &v2, 0);

        if (SUCCEEDED(hResDynamic))
        {
            // Build the query relative to this class that would select instances
            // which can point to the endpoint.
            BSTR strQuery = 0;
            hRes = NormalQ_ConstructRefsQuery(pClass, 0, &strQuery); // thows
            CSysFreeMe fm(strQuery);
            if (FAILED(hRes))
                return WBEM_E_FAILED;

            if (hRes == WBEM_S_QUERY_OPTIMIZED_OUT)
            {
                hRes = 0;
                continue;
            }

            CObjectSink *pInSink = CreateSink(FilterForwarder_NormalAssocs, strQuery);
            if (NULL == pInSink) return WBEM_E_OUT_OF_MEMORY;
            CReleaseMe rmInSink(pInSink);

            IWbemContext *pCopy = 0;
            if (m_pContext)
            {
                if (FAILED(hRes = m_pContext->Clone(&pCopy))) return hRes;
            }
            CReleaseMe rmCtx(pCopy);

            if (FAILED(hRes =m_pNs->MergeGetKeysCtx(pCopy))) return hRes;

            if (FAILED(hRes = CoImpersonateClient())) return hRes;
            OnDelete0<HRESULT(*)(void),CoRevertToSelf> RevertMe;    
               
            BSTR bStrWQL = SysAllocString(L"WQL");
            if (NULL == bStrWQL) return WBEM_E_OUT_OF_MEMORY;
            CSysFreeMe fm_(bStrWQL);
            if (FAILED(hRes = m_pNs->ExecQueryAsync(bStrWQL, strQuery, 0, pCopy, pInSink))) return hRes;

            if (FAILED(hRes = NormalQ_LoadCheck())) return hRes;
            if (m_bCancel) return WBEM_E_CALL_CANCELLED;
            
        }
        else if (SUCCEEDED(hResRuleBased)) // Rule based
        {
            CFlexArray aTriads;
            OnDelete<CFlexArray &,void(*)(CFlexArray &),SAssocTriad::ArrayCleanup> CleanMe(aTriads);
            
            if (FAILED(hRes = CoImpersonateClient())) return hRes;
            
            {
                OnDelete0<HRESULT(*)(void),CoRevertToSelf> RevertMe;                
                if (FAILED(hRes = m_pNs->ManufactureAssocs(pClass, m_pEndpoint, m_pContext, v1.GetStr(), aTriads))) return hRes;
            }

            // Now deliver stuff to sink
            pSink = CreateSink(FilterForwarder_NormalRefs, L"<rulebased>");
            if (NULL == pSink) return WBEM_E_OUT_OF_MEMORY;
            CReleaseMe rmSink2(pSink);

            for (int ii = 0; ii < aTriads.Size(); ii++)
            {
                SAssocTriad *pTriad = (SAssocTriad *) aTriads[ii];
                pSink->Indicate(1, &pTriad->m_pEp2);
            }
            pSink->SetStatus(0, 0, 0, 0);

        }
    }

    return hRes;
}


//***************************************************************************
//
//  CAssocQuery::NormalQ_GetRefsOfEndpoint
//
//  Builds a query text to select association instances which can reference
//  the endpoint instance.
//
//  Returns:
//  WBEM_S_NO_ERROR
//  A WBEM_E_ code
//
//***************************************************************************
//  ok

HRESULT CAssocQuery::NormalQ_ConstructRefsQuery(
    IN IWbemClassObject *pClass,
    IN OUT IWbemContext *pContextCopy,
    OUT BSTR *strQuery
    )
{
    if (strQuery == 0)
        return WBEM_E_INVALID_PARAMETER;

    *strQuery = 0;

    HRESULT hRes;
    CVARIANT v;

    // Get the class name of the association we are
    // trying to get instances for.
    // ============================================

    hRes = pClass->Get(L"__CLASS", 0, &v, 0, 0);
    if (FAILED(hRes)) return WBEM_E_FAILED;

    // Build up the query we want.
    // ===========================

    WString wsQuery = "select * from ";
    wsQuery += V_BSTR(&v);                  // Add in assoc class
    wsQuery += " where ";

    // Next determine which role to use to reach the query endpoint.
    // =============================================================

    CWStringArray aNames;
    hRes = CanClassRefQueryEp(FALSE, pClass, &aNames);
    if (FAILED(hRes))
        return WBEM_E_FAILED;

    // If RESULTROLE is specified in the query, then eliminate
    // it from aNames, since aNames is reserved for roles
    // pointing to the query endpoint.
    // =======================================================
    LPCWSTR pszResultRole = m_Parser.GetResultRole();
    if (pszResultRole)
    {
        for (int i = 0; i < aNames.Size(); i++)
        {
            if (wbem_wcsicmp(aNames[i], pszResultRole) == 0) 
            {
                aNames.RemoveAt(i);
                i--;
            }
        }
    }

    // Ensure something is going to point to our endpoint.
    // ===================================================
    if (aNames.Size() == 0)
        return WBEM_S_QUERY_OPTIMIZED_OUT;

    // Now build up the query which refers to the endpoint explicitly.
    // If more than one role works, build up an OR clause.
    // ===============================================================

    while (aNames.Size())
    {
        wsQuery += aNames[0];
        wsQuery += "=\"";

        WString Path(m_bstrEndpointRelPath);
        wsQuery += Path.EscapeQuotes();
        wsQuery += "\"";

        aNames.RemoveAt(0);
        if (aNames.Size())
            wsQuery += " OR ";
    }

    // If here, we have the role to use.
    // =================================

    *strQuery = SysAllocString(wsQuery);

    DEBUGTRACE((LOG_WBEMCORE, "Association Engine: submitting query <%S> to core\n", LPWSTR(wsQuery) ));

    // Determine if association class only has keys anyway, in which
    // case we can merge in the keys_only behavior.  In cases
    // where the provider can only enumerate instead of interpret
    // the query, this might help.
    // =============================================================

    if (pContextCopy)
    {
        hRes = AssocClassHasOnlyKeys(pClass);
        if (hRes == WBEM_S_NO_ERROR)
        {
            hRes = m_pNs->MergeGetKeysCtx(pContextCopy);
        }
    }

    return WBEM_S_NO_ERROR;
}

//****************************************************************************
//
//  CAssocQuery::AssocClassHasOnlyKeys
//
//  Returns WBEM_S_NO_ERROR if the assoc class only has keys.
//
//****************************************************************************
//
HRESULT CAssocQuery::AssocClassHasOnlyKeys(
    IN IWbemClassObject *pObj
    )
{
    int nKeyCount = 0;
    HRESULT hRes;

    pObj->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
    while (1)
    {
        hRes = pObj->Next(0, 0, 0, 0, 0);
        if (hRes == WBEM_S_NO_MORE_DATA)
            break;
        nKeyCount++;
    }
    pObj->EndEnumeration();

    CVARIANT v;
    hRes = pObj->Get(L"__PROPERTY_COUNT", 0, &v, 0, 0);
    if (FAILED(hRes) || v.GetType() != VT_I4)
        return WBEM_E_FAILED;

    if (V_I4(&v) == nKeyCount)
        return WBEM_S_NO_ERROR;

    return WBEM_E_FAILED;
}

//****************************************************************************
//
//  CAssocQuery::FilterFowarder_NormalRefs
//
//  Filtering and forwarding for REFERENCES OF queries.
//  Handles normal queries and CLASSDEFSONLY queries; not used for
//  SCHEMAONLY queries.
//
//****************************************************************************
//  visual ok

HRESULT CAssocQuery::FilterForwarder_NormalRefs(
    IN IWbemClassObject *pCandidate
    )
{
    BOOL bKeep = TRUE;
    HRESULT hRes = 0;

    if (pCandidate == 0)
        return WBEM_E_INVALID_PARAMETER;

    // All objects must be instances.  We filter out any
    // class definitions.
    // ==================================================

    CVARIANT vGenus;
    pCandidate->Get(L"__GENUS", 0, &vGenus, 0, 0);
    if (vGenus.GetType() == VT_I4 && LONG(vGenus) == 1)
        return WBEM_S_NO_ERROR;

    // The object must pass a security check.
    // ======================================

    hRes = AccessCheck((CWbemObject *) pCandidate);
    if (FAILED(hRes)) return WBEM_S_NO_ERROR;

    // RESULTCLASS test
    // ================

    LPCWSTR pszResultClass = m_Parser.GetResultClass();
    if (pszResultClass)
    {
        hRes = St_ObjIsOfClass(pszResultClass, pCandidate);
        if (FAILED(hRes))
            bKeep = FALSE;
    }


    // Verify the association points to the endpoint and
    // if so, get the role via which it does so.
    // ==================================================

    BSTR strRole = 0;
    hRes = DoesAssocInstRefQueryEp(pCandidate,&strRole);
    CSysFreeMe _1(strRole);

    if (FAILED(hRes))
        bKeep = FALSE;

    // ROLE
    LPCWSTR pszRole = m_Parser.GetRole();
    if (pszRole && strRole)
    {
         if (wbem_wcsicmp(pszRole, strRole) != 0)
             bKeep = FALSE;
    }

    // REQUIREDQUALIFIER test
    LPCWSTR pszRequiredQual = m_Parser.GetRequiredQual();
    if (pszRequiredQual)
    {
        hRes = St_ObjHasQualifier(pszRequiredQual, pCandidate);
        if (FAILED(hRes))
            bKeep = FALSE;
    }

    if (!bKeep)
        return WBEM_S_NO_ERROR;

    // If here, the object is a candidate.  If the query type
    // is not CLASSDEFSONLY, then we directly send it back.
    // ======================================================

    if ((m_Parser.GetQueryType() & QUERY_TYPE_CLASSDEFS_ONLY) == 0)
    {
        hRes = m_pDestSink->Indicate(1, &pCandidate);
        return hRes;
    }

    IWbemClassObject *pRetCls = NULL;
    {
        CInCritSec ics(&m_csDeliveredAccess);
    
        hRes = GetClassDefsOnlyClass(pCandidate, &pRetCls);
    }
    CReleaseMe rmRetClass(pRetCls);

    // We may already have delivered the class in question,
    // so we don't just assume there is a pointer here.
    // ====================================================

    if (SUCCEEDED(hRes) && pRetCls)
    {
        hRes = m_pDestSink->Indicate(1, &pRetCls);
    }

    if (FAILED(hRes))
        return hRes;

    return WBEM_S_OPERATION_CANCELLED;
}



//****************************************************************************
//
//  CAssocQuery::FilterForwarder_NormalAssocs
//
//  First level association instance filtering for ASSOCIATORS OF queries.
//  Handles normal queries and CLASSDEFSONLY queries; not used for
//  SCHEMAONLY queries.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::FilterForwarder_NormalAssocs(
    IN IWbemClassObject *pAssocInst
    )
{
    HRESULT hRes = 0;
    BOOL bKeep = TRUE;

    if (pAssocInst == 0)
        return WBEM_E_INVALID_PARAMETER;

    // All objects must be instances.  We filter out any
    // class definitions.
    // ==================================================

    CVARIANT vGenus;
    pAssocInst->Get(L"__GENUS", 0, &vGenus, 0, 0);
    if (vGenus.GetType() == VT_I4 && LONG(vGenus) == 1)
        return WBEM_S_NO_ERROR;

    // The object must pass a security check.
    // ======================================

    hRes = AccessCheck((CWbemObject *) pAssocInst);
    if (FAILED(hRes))
        return WBEM_S_NO_ERROR;

    // ASSOCCLASS
    // ==========

    LPCWSTR pszAssocClass = m_Parser.GetAssocClass();
    if (pszAssocClass)
    {
        hRes = St_ObjIsOfClass(pszAssocClass, pAssocInst);
        if (FAILED(hRes))
            bKeep = FALSE;
    }

    // REQUIREDASSOCQUALIFIER
    // ======================
    LPCWSTR pszRequiredAssocQual = m_Parser.GetRequiredAssocQual();
    if (pszRequiredAssocQual)
    {
        hRes = St_ObjHasQualifier(pszRequiredAssocQual, pAssocInst);
        if (FAILED(hRes))
            bKeep = FALSE;
    }

    // ROLE
    // ====
    LPCWSTR pszRole = m_Parser.GetRole();
    if (pszRole)
    {
         hRes = RoleTest(m_pEndpoint, pAssocInst, m_pNs, pszRole, ROLETEST_MODE_PATH_VALUE);
         if (FAILED(hRes))
             bKeep = FALSE;
    }

    // If we have already rejected the instance, just give up without going any further.
    // =================================================================================

    if (bKeep == FALSE)
        return WBEM_S_NO_ERROR;

    // If here, looks like we'll be in the business of actually getting
    // the other endpoint.  Other rejections are still possible based
    // on RESULTROLE, however.
    // ================================================================

    // Get the Unknown Ep role.
    // ========================

    hRes = WBEM_S_NO_ERROR;

    // By keeping track of the last property we enumed, we will be able to handle
    // associations with multiple endpoints. (sanjes)
    // ==========================================================================

    BOOL bQueryEndpointFound = FALSE;

    pAssocInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    OnDeleteObj0<IWbemClassObject,
                          HRESULT(__stdcall IWbemClassObject:: *)(void),IWbemClassObject::EndEnumeration> EndMe(pAssocInst);

    while (hRes == WBEM_S_NO_ERROR)
    {
        // Make sure these are reinitialized on each loop.

        BSTR strUnkEpPath = 0, strUnkEpRole = 0;
        bKeep = TRUE;

        // Just keep passing in the last property we got
        // ==============================================

        hRes = GetUnknownEpRoleAndPath(pAssocInst, &bQueryEndpointFound, &strUnkEpRole, &strUnkEpPath );
        auto_bstr rmUnkEpRole(strUnkEpRole);
        auto_bstr rmUnkEpPath(strUnkEpPath);
        
        if (FAILED(hRes)) return hRes;;
        if (hRes == WBEM_S_NO_MORE_DATA) break;
        
        // If we ran out of properties we should quit.
        // ===========================================

        if (SUCCEEDED(hRes))
        {
            // Verify the RESULTROLE.
            // ======================

            LPCWSTR pszResultRole = m_Parser.GetResultRole();
            if (pszResultRole)
            {
                if (wbem_wcsicmp(pszResultRole, rmUnkEpRole.get()) != 0) 
                    bKeep = FALSE;
            }

            // If here, we have the path of the unknown endpoint.
            // We save it away in a protected array.
            // ==================================================

            if (bKeep)
                hRes = AddEpCandidatePath(rmUnkEpPath.release());    // Acquires pointer
        }
    }

    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//
//  CAssocQuery::AddEpCandidatePath
//
//  Adds the path to a candidate endpoint.  This is an intermediate
//  step in an ASSOCIATORS OF query.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::AddEpCandidatePath(
    IN BSTR strOtherEp
    )
{
    CInCritSec ics(&m_csCandidateEpAccess); 

    if (CFlexArray::no_error != m_aEpCandidates.Add(strOtherEp))
    {
        SysFreeString(strOtherEp);
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

//****************************************************************************
//
//  CAssocQuery::EmptyCandidateEpArray
//
//  Empties the Endpoint candidate array.
//
//****************************************************************************
// visual ok

void CAssocQuery::EmptyCandidateEpArray()
{
    CInCritSec ics(&m_csCandidateEpAccess);

    for (int i = 0; i < m_aEpCandidates.Size(); i++)
        SysFreeString((BSTR) m_aEpCandidates[i]);
    m_aEpCandidates.Empty();
}


//****************************************************************************
//
//  CAssocQuery::PerformFinalEpTests
//
//  Performs all final filter tests on the query endpoint.
//
//  Returns
//  WBEM_S_NO_ERROR if the object should be retained.
//  WBEM_E_INVALID_OBJECT if the object should not be retained.
//
//****************************************************************************
//
HRESULT CAssocQuery::PerformFinalEpTests(
    IWbemClassObject *pEp
    )
{
    BOOL bKeep = TRUE;
    HRESULT hRes;

    // Perform final tests. RESULTROLE
    // was verified in the intermediate stage.
    // =======================================

    LPCWSTR pszResultClass = m_Parser.GetResultClass();
    if (pszResultClass)
    {
        hRes = St_ObjIsOfClass(pszResultClass, pEp);
        if (FAILED(hRes))
             bKeep = FALSE;
    }

    // REQUIREDQUALIFIER test
    // =======================

    LPCWSTR pszRequiredQual = m_Parser.GetRequiredQual();
    if (pszRequiredQual)
    {
        hRes = St_ObjHasQualifier(pszRequiredQual, pEp);
        if (FAILED(hRes))
            bKeep = FALSE;
    }

    if (bKeep)
        return WBEM_S_NO_ERROR;

    return WBEM_E_INVALID_OBJECT;
}


//****************************************************************************
//
//  CAssocQuery::ResolvePathsToObjects
//
//****************************************************************************
//

HRESULT CAssocQuery::EpClassTest(
    LPCWSTR pszResultClass,
    LPCWSTR strClassName,
    IWbemClassObject *pTestClass
    )
{
    HRESULT hRes;

    if (pszResultClass == 0 || strClassName == 0 || pTestClass == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (wbem_wcsicmp(pszResultClass, strClassName) == 0)
        return WBEM_S_NO_ERROR;

    // Check the derivation of the class and see if the result class is mentioned.
    // ===========================================================================

    CVARIANT v;
    hRes = pTestClass->Get(L"__DERIVATION", 0,&v, 0, 0);
    if (FAILED(hRes))
        return hRes;

    CSAFEARRAY sa((SAFEARRAY *) v);
    v.Unbind();

    int nNum = sa.GetNumElements();

    for (int j = 0; j < nNum; j++)
    {
        BSTR bstrCls = 0;
        if (FAILED(sa.Get(j, &bstrCls)))
        return WBEM_E_OUT_OF_MEMORY;
        CSysFreeMe _(bstrCls);
        if (wbem_wcsicmp(bstrCls, pszResultClass) == 0) 
            return WBEM_S_NO_ERROR;
    }

    return WBEM_E_NOT_FOUND;
}



//****************************************************************************
//
//  CAssocQuery::ResolvePathsToObjects
//
//  Runs through the existing endpoints and gets the objects, passes them
//  through the final tests sends them to to the caller.
//
//  Autoassoc support can directly populate the m_aEpCandidates array.
//
//  <nMaxToProcess>     If -1, process all.  Otherwise, only process
//                      as many as are requested.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::ResolveEpPathsToObjects(
    IN int nMaxToProcess
    )
{
    if (ConfigMgr::ShutdownInProgress())
        return WBEM_E_SHUTTING_DOWN;

    HRESULT hRes = WBEM_S_NO_ERROR;
    IWbemClassObject *pEp = NULL;

    // If the query type is CLASSDEFS only, reduce the Ep list
    // to a list of class definitions.
    // =======================================================

    if (m_Parser.GetQueryType() & QUERY_TYPE_CLASSDEFS_ONLY)
        ConvertEpListToClassDefsOnly();

    // Determine how much of the ep list to process.
    // =============================================


    int nArraySize;
    {
        CInCritSec ics(&m_csCandidateEpAccess);
        nArraySize = m_aEpCandidates.Size();

        if (nMaxToProcess == -1 || nMaxToProcess > nArraySize)
            nMaxToProcess = nArraySize;
    }

    // RESULTCLASS test
    // ================
    LPCWSTR pszResultClass = m_Parser.GetResultClass();

    // Process each element in EP list.
    // ================================

    for (int i = 0; i < nMaxToProcess; i++)
    {
        pEp = 0;

        // Extract one endpoint.
        // =====================
        BSTR strEpPath = NULL;
        {
            CInCritSec ics(&m_csCandidateEpAccess);
            strEpPath = (BSTR) m_aEpCandidates[0];
            m_aEpCandidates.RemoveAt(0);
        }
        CSysFreeMe _2(strEpPath);

        // Do some analysis on the path.
        // =============================

        BSTR strClassName = 0;
        BOOL bIsClass;
        hRes = St_ObjPathInfo(strEpPath, &strClassName, &bIsClass);
        if (FAILED(hRes))
        {
            hRes = 0;
            continue;
        }

        BOOL bKeep = TRUE;

        CSysFreeMe _1(strClassName);

        // Important optimization: If RESULTCLASS is specified, look
        // up the class definition before trying to get the endpoint
        // just in case it can't pass the test.
        // ==========================================================

        if (pszResultClass)
        {
        // search for RESULTCLASS in derivation list of class from path
        // if not search in derived classes from it

            // Get the class and do a RESULTCLASS test to avoid
            // getting the object.
            // =================================================
            IWbemClassObject *pTestClass;
            hRes = GetClassFromAnywhere(strClassName, 0, &pTestClass);

            if (FAILED(hRes))
            {
                DEBUGTRACE((LOG_WBEMCORE, "Association cannot find class <%S> hr = %08x\n",strClassName,hRes));
                hRes = 0;
                continue;
            }
            CReleaseMe _11(pTestClass);

            // Make sure the endpoint class passes query tests.
            // =================================================

            hRes = EpClassTest(pszResultClass, strClassName, pTestClass);
            if (FAILED(hRes))
            {
                IWbemClassObject *pTestResultClass;
                hRes = GetClassFromAnywhere(pszResultClass, 0, &pTestResultClass);
                if (FAILED(hRes))
                {
                    DEBUGTRACE((LOG_WBEMCORE, "Association cannot find class <%S> hr %08x\n", pszResultClass, hRes));
                    hRes = 0;
                    continue;
                }
                       CReleaseMe _111(pTestResultClass);
                  hRes = EpClassTest(strClassName, pszResultClass, pTestResultClass);    
                  if (FAILED(hRes))
                      {
                        hRes = WBEM_S_NO_ERROR;
                        continue;

                      }

            }
        }


        // If a class, use our high-speed class getter.
        // ============================================

        if (bIsClass)
        {
            // GetClassFromAnyWhere

            hRes = GetClassFromAnywhere(strClassName, strEpPath, &pEp);
            if (FAILED(hRes))
            {
                DEBUGTRACE((LOG_WBEMCORE, "Association cannot resolve dangling reference <%S> hr = %08x\n",strEpPath,hRes));
                hRes = 0;
                continue;
            }
        }

        // Otherwise, an instance and we go the slow route.
        // ================================================

        else    // An instance
        {

            IWbemClassObject* pErrorObj = NULL;
            hRes = m_pNs->Exec_GetObjectByPath(
                strEpPath,
                0,                              // Flags
                m_pContext,                     // Context
                &pEp,                           // Result obj
                &pErrorObj                      // Error obj, if any
                );

            CReleaseMe _11(pErrorObj);

            if (FAILED(hRes))
            {
                DEBUGTRACE((LOG_WBEMCORE, "Association cannot resolve reference <%S> hr = %08x\n",strEpPath,hRes));
                hRes = 0;
                continue;
            }
        }

        // So, do we actually have an object, or are we fooling
        // ourselves?
        // =====================================================
        if (!pEp)
        {
            hRes = 0;
            continue;
        }


        // The object must pass a security check.
        // ======================================

        hRes = AccessCheck((CWbemObject *) pEp);
        if (FAILED(hRes))
        {
            pEp->Release();
            hRes = 0;
            continue;
        }

        // If we are going to keep this, send it to the caller.
        // ====================================================

        hRes = PerformFinalEpTests(pEp);

        if (SUCCEEDED(hRes))
            hRes = m_pDestSink->Indicate(1, &pEp);

        pEp->Release();
        hRes = WBEM_S_NO_ERROR;
    }

    return hRes;
}


//****************************************************************************
//
//  CAssocQuery::St_ObjPathPointsToClass
//
//  Returns WBEM_S_NO_ERROR if the object path points to a class,
//  or WBEM_E_FAILED if not.  Can also return codes for invalid paths,
//  out of memory, etc.
//
//****************************************************************************
//
HRESULT CAssocQuery::St_ObjPathInfo(
    IN LPCWSTR pszPath,
    OUT BSTR *pszClass,
    OUT BOOL *pbIsClass
    )
{
    CObjectPathParser Parser;
    ParsedObjectPath* pParsedPath = NULL;

    if (pszPath == 0)
        return WBEM_E_INVALID_PARAMETER;

    int nRes = Parser.Parse(pszPath, &pParsedPath);

    if (nRes != CObjectPathParser::NoError ||
        pParsedPath->m_pClass == NULL)
    {
        // Fatal. Bad path in association.
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    if (pbIsClass)
    {
        if (pParsedPath->m_dwNumKeys == 0)
            *pbIsClass = TRUE;
        else
            *pbIsClass = FALSE;
    }

    if (pszClass && pParsedPath->m_pClass)
        *pszClass = SysAllocString(pParsedPath->m_pClass);

    Parser.Free(pParsedPath);

    return WBEM_S_NO_ERROR;
}


//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END NORMAL QUERY SUPPORT
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@











//***************************************************************************
//
//***************************************************************************
//


//***************************************************************************
//
//  CAssocQuery::CanClassRefReachQueryEp
//
//  Determines whether the property to which pQSet is bound can reach
//  the query endpoint via a CLASSREF qualifier.
//
//  <pQSet> bound to the property which supposedly references the query
//          endpoint.
//  <bStrict>  If true, the reference must directly reference the query
//          endpoint class, if FALSE it may reference any of the superclasses.
//
//  Returns:
//  WBEM_S_NO_ERROR if the reference occurs.
//  WBEM_E_NOT_FOUND if the references does not occur.
//
//***************************************************************************
// visual ok

HRESULT CAssocQuery::CanClassRefReachQueryEp(
    IWbemQualifierSet *pQSet,
    BOOL bStrict
    )
{
    HRESULT hRes;
    CVARIANT v;
    hRes = pQSet->Get(L"CLASSREF", 0, &v, 0);
    if (FAILED(hRes))
        return WBEM_E_NOT_FOUND;

    if (V_VT(&v) != (VT_BSTR | VT_ARRAY))
        return WBEM_E_INVALID_OBJECT;

    CSAFEARRAY sa((SAFEARRAY *) v);
    v.Unbind();

    int nNum = sa.GetNumElements();

    // Iterate through the safearray.
    // ==============================

    for (int i = 0; i < nNum; i++)
    {
        BSTR bstrClass = 0;
        if (FAILED(sa.Get(i, &bstrClass)))
        return WBEM_E_OUT_OF_MEMORY;
        if (bstrClass == 0)
            continue;
        CSysFreeMe _(bstrClass);
        if (bStrict)
        {
            if (wbem_wcsicmp(bstrClass, m_bstrEndpointClass) == 0) 
                return WBEM_S_NO_ERROR;
        }
        else for (int i2 = 0; i2 < m_aEndpointHierarchy.Size(); i2++)
        {
            if (wbem_wcsicmp(bstrClass, m_aEndpointHierarchy[i2]) == 0)
                return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_E_NOT_FOUND;
}








//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN HELPER FUNCTIONS
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//****************************************************************************
//
//  CAssocQuery::St_GetObjectInfo
//
//  Returns info about the object, such as its path, class, and
//  class hierarchy.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::St_GetObjectInfo(
    IN  IWbemClassObject *pObj,
    OUT BSTR *pClass,
    OUT BSTR *pRelpath,
    OUT BSTR *pPath,
    OUT CWStringArray &aHierarchy
    )
{
    HRESULT hRes;
    int nRes;
    CVARIANT v;

    if (!pObj)
        return WBEM_E_INVALID_PARAMETER;

    // Get the owning class.
    // =====================

    hRes = pObj->Get(L"__CLASS", 0, &v, 0, 0);
    if (FAILED(hRes))
        return hRes;

    if (V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    nRes = aHierarchy.Add(LPWSTR(v));
    if (nRes)
        return WBEM_E_OUT_OF_MEMORY;

    if (pClass)
    {
        *pClass = V_BSTR(&v);
        v.Unbind();
    }
    v.Clear();

    // Get the rel path.
    // =================

    if (pRelpath)
    {
        hRes = pObj->Get(L"__RELPATH", 0, &v, 0, 0);
        if (FAILED(hRes)) return hRes;
        if ( VT_BSTR != V_VT(&v))  return WBEM_E_INVALID_OBJECT;
        *pRelpath = V_BSTR(&v);
        v.Unbind();
    }
    v.Clear();

    if (pPath)
    {
        hRes = pObj->Get(L"__PATH", 0, &v, 0, 0);
        if (FAILED(hRes))
            return hRes;
        *pPath = V_BSTR(&v);
        v.Unbind();
    }
    v.Clear();

    // Get the superclasses.
    // =====================

    hRes = pObj->Get(L"__DERIVATION", 0,&v, 0, 0);
    if (FAILED(hRes))
        return hRes;

    CSAFEARRAY sa((SAFEARRAY *) v);
    v.Unbind();

    int nNum = sa.GetNumElements();

    for (int j = 0; j < nNum; j++)
    {
        BSTR bstrClass = 0;
        nRes = sa.Get(j, &bstrClass);
        if (FAILED(nRes))
            return WBEM_E_OUT_OF_MEMORY;

        CSysFreeMe _(bstrClass);
        nRes = aHierarchy.Add(bstrClass);
        if (nRes)
            return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}



//****************************************************************************
//
//  CAssocQuery::GetUnknownEpRoleAndPath
//
//  Given an association object (class or inst), returns the role and
//  path which references the unknown endpoint.
//
//  Calling code is responsible for calling BeginEnum/EndEnum
//
//  All the OUT parameters are optional.
//
//****************************************************************************
//
HRESULT CAssocQuery::GetUnknownEpRoleAndPath(
    IN IWbemClassObject *pAssoc,
    IN BOOL *pFoundQueryEp,
    OUT BSTR *pszRole,
    OUT BSTR *pszUnkEpPath
    )
{
    HRESULT hRes = WBEM_E_FAILED;

    if (pAssoc == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Loop through the properties trying to find a legitimate
    // reference to our endpoint class.
    // =======================================================

    // sanjes
    // pAssoc->BeginEnumeration(WBEM_FLAG_REFS_ONLY);

    while (1)
    {
        BSTR strPropName = 0;
        hRes = pAssoc->Next(0, &strPropName,  0, 0, 0);
        CSysFreeMe _1(strPropName);

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        hRes = RoleTest(m_pEndpoint, pAssoc, m_pNs, strPropName, ROLETEST_MODE_PATH_VALUE);
        if (SUCCEEDED(hRes) && *pFoundQueryEp == FALSE)    // The query  ep
        {
            *pFoundQueryEp = TRUE;
            continue;
        }

        // If here, we found the prop name which apparently references the
        // other endpoint.
        // ===============================================================

        if (pszRole)
        {
            *pszRole = SysAllocString(strPropName);
             if (NULL ==  *pszRole) return WBEM_E_OUT_OF_MEMORY;
        }

        CVARIANT vPath;
        hRes = pAssoc->Get(strPropName, 0, &vPath, 0, 0);
        if (FAILED(hRes) || vPath.GetType() != VT_BSTR)
            break;

        if (pszUnkEpPath)
        {
            *pszUnkEpPath = SysAllocString(vPath.GetStr());
            if (NULL ==  *pszUnkEpPath) return WBEM_E_OUT_OF_MEMORY;
        }
        hRes = WBEM_S_NO_ERROR;
        break;
    }

    // sanjes
    // pAssoc->EndEnumeration();

    return hRes;    // Unexpected in real life
}

//****************************************************************************
//
//  CAssocQuery::RoleTest
//
//  Determines if the <pCandidate> object can point to the <pEndpoint> object
//  via the specified <pszRole> property.
//
//  Parameters:
//  <pEndpoint>     The test endpoint object
//  <pCandidate>    The association object which may point to the endpoint.
//  <pszRole>       The role to use for the test.
//  <dwMode>        One of the ROLETEST_MODE_ constants.
//
//  Precisely,
//
//  (1) ROLETEST_MODE_PATH_VALUE
//  The candidate must reference the endpoint exactly via the specified
//  role property, which must contain the path of the endpoint.
//  Requirement: Both <pEndpoint> <pCandidate> can be anything.
//
//  (2) ROLETEST_MODE_CIMREF_TYPE
//  The role path is NULL and the CIM reference type is used to determine
//  if the endpoint can be referenced.  In this case, the CIM reference
//  type must exactly reference the endpoint class.
//  Requirement: Both <pEndpoint> and <pCandidate> are classes.
//
//  Returns:
//      WBEM_S_NO_ERROR
//      WBEM_E_NOT_FOUND         If the role cannot reference the endpoint.
//      WBEM_E_INVALID_PARAMETER ...in most other cases.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::RoleTest(
    IN IWbemClassObject *pEndpoint,
    IN IWbemClassObject *pCandidate,
    IN CWbemNamespace *pNs,
    IN LPCWSTR pszRole,
    IN DWORD dwMode
    )
{
    HRESULT hRes;
    CVARIANT v;
    BOOL bEndpointIsClass, bCandidateIsClass;

    if (!pszRole || !pEndpoint || !pCandidate)
        return WBEM_E_INVALID_PARAMETER;

    // Get the genus values of the endpoint & candidate.
    // =================================================

    pEndpoint->Get(L"__GENUS", 0, &v, 0, 0);
    if (v.GetLONG() == 1)
        bEndpointIsClass = TRUE;
    else
        bEndpointIsClass = FALSE;
    v.Clear();

    pCandidate->Get(L"__GENUS", 0, &v, 0, 0);
    if (v.GetLONG() == 1)
        bCandidateIsClass = TRUE;
    else
        bCandidateIsClass = FALSE;
    v.Clear();

    // Get the qualifier set for the specified <role> property.
    // ========================================================

    IWbemQualifierSet *pQSet = 0;
    hRes = pCandidate->GetPropertyQualifierSet(pszRole, &pQSet);
    if (FAILED(hRes))
        return WBEM_E_NOT_FOUND;
    CReleaseMe _1(pQSet);

    // Now, get the type of the role.
    // ==============================

    CVARIANT vCimType;
    hRes = pQSet->Get(L"CIMTYPE", 0, &vCimType, 0);
    if (FAILED(hRes) || V_VT(&vCimType) != VT_BSTR)
        return WBEM_E_FAILED;

    // Get the class name from it.
    // ===========================

    wchar_t ClassName[MAX_CLASS_NAME];
    *ClassName = 0;
    BSTR strRefClass = V_BSTR(&vCimType);
    if (strRefClass)
    {
        if (wcslen_max(strRefClass,MAX_CLASS_NAME) > MAX_CLASS_NAME)  return WBEM_E_FAILED;        
        parse_REF(strRefClass,MAX_CLASS_NAME,ClassName);
    }
    // Once here, 'object ref' types will simply
    // have a zero-length <ClassName> string.


    // Determine which of the four cases we are executing.
    // ===================================================

    if (dwMode == ROLETEST_MODE_CIMREF_TYPE)
    {
        if (bCandidateIsClass == FALSE && bEndpointIsClass == FALSE)
            return WBEM_E_INVALID_PARAMETER;

        if (*ClassName == 0)
            return WBEM_E_NOT_FOUND;

        // See if the class name and the class of the object
        // are the same.
        // ==================================================
        CVARIANT vCls;
        HRESULT hResInner = pEndpoint->Get(L"__CLASS", 0, &vCls, 0, 0);
        if (FAILED(hResInner))
            return hResInner;

        if (wbem_wcsicmp(ClassName, vCls.GetStr()) == 0)
            return WBEM_S_NO_ERROR;

        // Find out if the CIM type string points to the object.
        // =====================================================
        hRes = PathPointsToObj(ClassName, pEndpoint, pNs);
    }

    // The endpoint must be directly and exactly referenced
    // by the role property's *value*.
    // ====================================================

    else if (dwMode == ROLETEST_MODE_PATH_VALUE)
    {
        // Get the value of the role property.
        // ===================================

        CVARIANT vRolePath;
        hRes = pCandidate->Get(pszRole, 0, &vRolePath, 0, 0);
        if (FAILED(hRes))
            return WBEM_E_FAILED;

        if (vRolePath.GetType() == VT_NULL)
            return WBEM_E_NOT_FOUND;

        hRes = PathPointsToObj(vRolePath.GetStr(), pEndpoint, pNs);
    }
    else
        return WBEM_E_INVALID_PARAMETER;

    return hRes;
}




//****************************************************************************
//
//  CAssocQuery::St_ObjIsOfClass
//
//  Determines if the specified object is of or derives from the specified
//  class.
//
//  Returns:
//      WBEM_E_INVALID_CLASS if there is no match.
//      WBEM_S_NO_ERROR      if there is a match.
//      WBEM_E_*             on other failures
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::St_ObjIsOfClass(
    IN LPCWSTR pszRequiredClass,
    IN IWbemClassObject *pObj
    )
{
    if (pszRequiredClass == 0)
        return WBEM_E_INVALID_PARAMETER;

    HRESULT hRes;
    CWStringArray aHierarchy;

    hRes = St_GetObjectInfo(pObj, 0, 0, 0, aHierarchy);
    if (FAILED(hRes))
        return hRes;

    for (int i = 0; i < aHierarchy.Size(); i++)
        if (wbem_wcsicmp(pszRequiredClass, aHierarchy[i]) == 0)
            return WBEM_S_NO_ERROR;

    return WBEM_E_INVALID_CLASS;
}



//****************************************************************************
//
//  CAssocQuery::PathPointsToObj
//
//  Determines if a particular object path points to the specified object
//  or not.  Tries to avoid full object path parsing, if possible.
//
//  Returns WBEM_S_NO_ERROR, WBEM_E_FAILED
//
//****************************************************************************
// ok

HRESULT CAssocQuery::PathPointsToObj(
    IN LPCWSTR pszPath,
    IN IWbemClassObject *pObj,
    IN CWbemNamespace *pNs
    )
{
    HRESULT hRes;

    if (pszPath == 0 || pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Test for simple equality of __RELPATH.
    // ======================================

    CVARIANT vRel;
    hRes = pObj->Get(L"__RELPATH", 0, &vRel, 0, 0);
    if (FAILED(hRes) || VT_BSTR != V_VT(&vRel))
        return WBEM_E_FAILED;

    if (wbem_wcsicmp(pszPath, V_BSTR(&vRel)) == 0)
        return WBEM_S_NO_ERROR;

    // Test for simple equality of __PATH.
    // ===================================

    CVARIANT vFullPath;
    hRes = pObj->Get(L"__PATH", 0, &vFullPath, 0, 0);
    if (FAILED(hRes) || VT_BSTR != V_VT(&vRel))
        return WBEM_E_FAILED;

    if (wbem_wcsicmp(pszPath, V_BSTR(&vFullPath)) == 0)
        return WBEM_S_NO_ERROR;

    // If here, we have to actually parse the object paths
    // in question.
    // ===================================================

    LPWSTR pszNormalizedPath = CQueryEngine::NormalizePath(pszPath, pNs);
    LPWSTR pszNormalizedTargetPath = CQueryEngine::NormalizePath(vFullPath.GetStr(), pNs);
    CDeleteMe <wchar_t> _1(pszNormalizedPath);
    CDeleteMe <wchar_t> _2(pszNormalizedTargetPath);

    if (pszNormalizedPath && pszNormalizedTargetPath)
        if (wbem_wcsicmp(pszNormalizedPath, pszNormalizedTargetPath) == 0)
            return WBEM_S_NO_ERROR;

    return WBEM_E_FAILED;
}

//***************************************************************************
//
//  CAssocQualifierL::St_ObjHasQualifier
//
//  Determines if an object has a particular qualifier.  Used for
//  REQUIREDQUALIFIER or REQUIREDASSOCQUALIFIER tests.  The qualifier
//  must be present and not be VARIANT_FALSE.
//  Returns WBEM_S_NO_ERROR if the object has the qualifier.
//  Returns an WBEM_E_ error code otherwise.
//
//***************************************************************************
// visual ok

HRESULT CAssocQuery::St_ObjHasQualifier(
    IN LPCWSTR pszQualName,
    IN IWbemClassObject *pObj
    )
{
    if (pszQualName == 0 || wcslen(pszQualName) == 0 || pObj == 0) 
        return WBEM_E_INVALID_PARAMETER;

    IWbemQualifierSet *pQSet = 0;

    HRESULT hRes = pObj->GetQualifierSet(&pQSet);
    if (FAILED(hRes))
        return WBEM_E_FAILED;
    CReleaseMe _1(pQSet);

    CVARIANT v;
    hRes = pQSet->Get(pszQualName, 0, &v, 0);

    if (SUCCEEDED(hRes))
    {
        if (V_VT(&v) == VT_BOOL && V_BOOL(&v) == VARIANT_FALSE)
            return WBEM_E_FAILED;
        return WBEM_S_NO_ERROR;
    }

    return WBEM_E_FAILED;
}




//***************************************************************************
//
//  CAssocQuery::St_ReleaseArray
//
//***************************************************************************
// visual ok

HRESULT CAssocQuery::St_ReleaseArray(
    IN CFlexArray &aObjects
    )
{
    // Release all the objects.
    // ========================

    for (int i = 0; i < aObjects.Size(); i++)
    {
        IWbemClassObject *p = (IWbemClassObject *) aObjects[i];
        p->Release();
    }

    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//
//  CAssocQuery::Db_GetClass
//
//  DB abstraction layer.  Will make it easier to plug in Quasar engine.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::Db_GetClass(
    IN LPCWSTR pszClassName,
    OUT IWbemClassObject **pClass
    )
{
    HRESULT hRes = CRepository::GetObject(
            m_pNs->GetNsSession(),
            m_pNs->GetScope(),
            pszClassName,
            0,
            pClass
            );

    return hRes;
}


//****************************************************************************
//
//  CAssocQuery::Db_GetInstRefs
//
//  DB abstraction layer.  Will make it easier to plug in Quasar engine.
//
//****************************************************************************
//

HRESULT CAssocQuery::Db_GetInstRefs(
    IN LPCWSTR pszTargetObj,
    IN IWbemObjectSink *pSink
    )
{
    HRESULT hRes = CRepository::GetInstanceRefs(
        m_pNs->GetNsSession(),
        m_pNs->GetScope(),
        pszTargetObj,
        pSink
        );

    return hRes;
}


//****************************************************************************
//
//  CAssocQuery::Db_GetClass
//
//  DB abstraction layer.  Will make it easier to plug in Quasar engine.
//
//****************************************************************************
// ok

HRESULT CAssocQuery::Db_GetRefClasses(
    IN  LPCWSTR pszClass,
    OUT CWStringArray &aRefClasses
    )
{
    HRESULT hRes = CRepository::GetRefClasses(
            m_pNs->GetNsSession(),
            m_pNs->GetNsHandle(),
            pszClass,
            FALSE,
            aRefClasses
            );

    return hRes;
}


//***************************************************************************
//
//  CAssocQuery::Db_GetClassRefClasses
//
//  Gets all classes with HasClassRefs qualifiers.
//
//***************************************************************************
//
HRESULT CAssocQuery::Db_GetClassRefClasses(
    IN CFlexArray &aDest
    )
{
    HRESULT hRes;
    CSynchronousSink* pRefClassSink = CSynchronousSink::Create(); 
    if (NULL == pRefClassSink) return WBEM_E_OUT_OF_MEMORY;
    pRefClassSink->AddRef();
    CReleaseMe _1(pRefClassSink);

    hRes = CRepository::GetClassesWithRefs(m_pNs->GetNsSession(),m_pNs->GetNsHandle(),pRefClassSink);
    if (FAILED(hRes)) return hRes;
    pRefClassSink->GetStatus(&hRes, NULL, NULL);
    if (FAILED(hRes)) return hRes;    

    aDest.Bind(pRefClassSink->GetObjects().GetArray());

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CAssocQuery::GetClassFromAnywhere
//
//  Tries to get a class definition from anywhere as fast as possible.
//  We do this by the following algorithm in a hope to achieve best
//  performance:
//
//  (1) Search the dynamic class cache
//  (2) Call the database directly for this namespace
//  (3) Call Exec_GetObjectByPath (hoping that an unrelated dyn class
//      provider has the class)
//
//***************************************************************************
// visual ok

HRESULT CAssocQuery::GetClassFromAnywhere(
    IN  LPCWSTR pszEpClassName,
    IN  LPCWSTR pszFullClassPath,
    OUT IWbemClassObject **pCls
    )
{
    HRESULT hRes;

    // Try to find the class in the dynamic class cache.
    // We will only look for classes in our own namespace, however.
    // ============================================================
    hRes = GetDynClass(pszEpClassName, pCls);

    if (SUCCEEDED(hRes))
        return hRes;

    // If here, no luck in the dynamic class cache.  Try
    // the repository.  We try to use the full path to support
    // the limited cross-namespace support required by
    // SNMP SMIR, etc.
    // ========================================================

    if (pszFullClassPath == 0)
        pszFullClassPath = pszEpClassName;

    hRes = Db_GetClass(pszFullClassPath, pCls);

    if (SUCCEEDED(hRes))
        return hRes;

    // If here, our hopes are nearly dashed. One last chance
    // that a dyn class provider may have it if the
    // class was supplied by a provider other than the
    // one which supplied the association class.
    // =====================================================

    IWbemClassObject* pErrorObj = NULL;

    hRes = m_pNs->Exec_GetObjectByPath(
            (LPWSTR) pszFullClassPath,          // Class name
            0,                                  // Flags
            m_pContext,                         // Context
            pCls,                               // Result obj
            &pErrorObj                          // Error obj, if any
            );

    CReleaseMe _1(pErrorObj);

    // If we found it, great.
    // ======================

    if (SUCCEEDED(hRes))
        return hRes;

    return WBEM_E_NOT_FOUND;
}


//***************************************************************************
//
//  CAssocQuery::St_HasClassRefs
//
//  Determines if a class has a <HasClassRefs> qualifier.
//
//  Parameters
//  <pCandidate>        Points to the object to be tested (read-only).
//
//  Return value:
//  WBEM_S_NO_ERROR     If the class has a <HasClassRefs> qualifier.
//  WBEM_E_NOT_FOUND        If the class doesn't have the qualifier.
//  ...other codes
//
//***************************************************************************
// visual ok

HRESULT CAssocQuery::St_HasClassRefs(
    IN IWbemClassObject *pCandidate
    )
{
    if (pCandidate == 0)
        return WBEM_E_INVALID_PARAMETER;

    HRESULT hRes = St_ObjHasQualifier(L"HasClassRefs", pCandidate);
    if (SUCCEEDED(hRes))
        return WBEM_S_NO_ERROR;

    return WBEM_E_NOT_FOUND;
}


//***************************************************************************
//
//  CAssocQuery::AccessCheck
//
//  Does a security check on a static object to make sure that the user
//  should see it.
//
//  If the object is in the current namespace anyway, we short-circuit
//  and allow it without a lot of hassle. The guy is obviously one of us
//  and should be allowed to proceed unhindered. In those weird cases where
//  the object was from a foreign namespace, we have to play INS and check
//  on him.
//
//***************************************************************************

HRESULT CAssocQuery::AccessCheck(
    IWbemClassObject *pSrc
    )
{
    if (pSrc == 0)
        return WBEM_E_INVALID_PARAMETER;

    CWbemObject *pObj = (CWbemObject *) pSrc;

    // Easy case is 9x box where user is cleared for everything
    // ========================================================

    if((m_pNs->GetSecurityFlags() & SecFlagWin9XLocal) != 0)
        return WBEM_S_NO_ERROR;

    // Short-circuit case: We get the __NAMESPACE and see if it
    // the same as the NS in which we are executing the query.
    // ========================================================

    try // native interfaces throws
    {
        LPWSTR pszNamespace = m_pNs->GetName();

        CVar vNs, vServer;
        if (FAILED(pObj->GetProperty(L"__NAMESPACE" , &vNs)) ||vNs.IsNull())
            return WBEM_E_INVALID_OBJECT;
        if (FAILED(pObj->GetProperty(L"__SERVER", &vServer)) || vServer.IsNull())
            return WBEM_E_INVALID_OBJECT;

        // If server name and namespace are the same, we are already implicitly
        // allowed to see the object.
        // ====================================================================
        if (wbem_wcsicmp(LPWSTR(vNs), pszNamespace) == 0 &&
            wbem_wcsicmp(LPWSTR(vServer), ConfigMgr::GetMachineName()) == 0)
                return WBEM_S_NO_ERROR;
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch (CX_Exception &)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    // If here, we have to do a real check.
    // ====================================

    HRESULT hRes = WBEM_S_NO_ERROR;

    BOOL bRet = TRUE;
    CVar vProp;
    if (FAILED(pObj->GetProperty(L"__Path" , &vProp)) || vProp.IsNull())
        return WBEM_E_INVALID_OBJECT;

    // Parse the object path to get the class involved.
    // ================================================

    CObjectPathParser p;
    ParsedObjectPath* pOutput = 0;

    int nStatus = p.Parse(vProp.GetLPWSTR(),  &pOutput);

    if (CObjectPathParser:: NoError != nStatus) return WBEM_E_OUT_OF_MEMORY;

    OnDeleteObj<ParsedObjectPath*,CObjectPathParser,
                     void (CObjectPathParser:: *)(ParsedObjectPath *),
                     &CObjectPathParser::Free> FreeMe(&p,pOutput);


    if (pOutput->IsLocal(ConfigMgr::GetMachineName()))
    {
        LPWSTR wszNewNamespace = pOutput->GetNamespacePart();
        CDeleteMe<WCHAR> dm1(wszNewNamespace);

        if (NULL == wszNewNamespace) return WBEM_E_OUT_OF_MEMORY;

        if (wbem_wcsicmp(wszNewNamespace, m_pNs->GetName()))
        {
            CWbemNamespace* pNewLocal = CWbemNamespace::CreateInstance();
            if (NULL == pNewLocal) return WBEM_E_OUT_OF_MEMORY;
            CReleaseMe rmNS((IWbemServices *)pNewLocal);

            hRes = pNewLocal->Initialize(wszNewNamespace, 
                                                       m_pNs->GetUserName(), 
                                                        0, 0, m_pNs->IsForClient(), 
                                                        TRUE,
                                                        m_pNs->GetClientMachine(), 
                                                        m_pNs->GetClientProcID(),
                                                        FALSE, NULL);
            if (SUCCEEDED(hRes))
            {
                DWORD dwAccess = pNewLocal->GetUserAccess();
                if ((dwAccess  & WBEM_ENABLE) == 0)
                    hRes = WBEM_E_ACCESS_DENIED;;
            }
        }
    }

    return hRes;
}









//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END HELPER FUNCTIONS
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@





//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN SINK CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



//***************************************************************************
//
//  CAssocQuery::CreateSink
//
//  Creates a sink which is bound this the current query.
//
//***************************************************************************
//
CObjectSink *CAssocQuery::CreateSink(
    PF_FilterForwarder pfnFilter,
    BSTR strTrackingQuery
    )
{
    CAssocQE_Sink *p = new CAssocQE_Sink(this, pfnFilter, strTrackingQuery);
    if (p) p->AddRef();
    return p;
}


//***************************************************************************
//
//  CAssocQE_Sink::CAssocQE_Sink
//
//***************************************************************************
//
CAssocQE_Sink::CAssocQE_Sink(
    CAssocQuery *pQuery,
    PF_FilterForwarder pFilter,
    BSTR strTrackingQuery
    )
    : CObjectSink(0)    // Starting ref count
{
    m_pQuery = pQuery;
    m_pQuery->AddRef();
    m_pfnFilter = pFilter;
    m_lRef = 0;
    m_bQECanceled = FALSE;
    m_bOriginalOpCanceled = FALSE;
    InterlockedIncrement(&m_pQuery->m_lActiveSinks);
    if (strTrackingQuery)
        m_strQuery = SysAllocString(strTrackingQuery);

}

//***************************************************************************
//
//  CAssocQE_Sink::~CAssocQE_Sink
//
//***************************************************************************
// ok

CAssocQE_Sink::~CAssocQE_Sink()
{
    InterlockedDecrement(&m_pQuery->m_lActiveSinks);
    m_pQuery->SignalSinkDone();
    m_pQuery->Release();
    SysFreeString(m_strQuery);
}

//***************************************************************************
//
//  CAssocQE_Sink::Indicate
//
//***************************************************************************
// ok

STDMETHODIMP CAssocQE_Sink::Indicate(
    IN long lNumObjects,
    IN IWbemClassObject** apObj
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (ConfigMgr::ShutdownInProgress())
        return WBEM_E_SHUTTING_DOWN;

    // Short-circuit a cancelled sink.
    // ===============================
    if (m_bQECanceled)
    {
        return hRes;
    }

    for (int i = 0; i < lNumObjects; i++)
    {
        IWbemClassObject *pCandidate = apObj[i];

        if (m_pfnFilter)
        {
            // Call the filter & forward function bound to this
            // sink instance.

            hRes = (m_pQuery->*m_pfnFilter)(pCandidate);

            // Check for out-and-out failure.
            // ==============================

            if (FAILED(hRes))
            {
                m_bQECanceled = TRUE;
                m_pQuery->Cancel();
                break;
            }

            // If we are simply cancelling this one sink due to efficiency
            // reasons, then tell just the provider to cancel, but not the
            // whole query.
            // ============================================================

            if (hRes == WBEM_S_OPERATION_CANCELLED)
            {
                m_bQECanceled = TRUE;
                hRes = WBEM_E_CALL_CANCELLED;
                break;
            }
        }
    }

    m_pQuery->UpdateTime();
    return hRes;
}

HRESULT CAssocQE_Sink::Add(IWbemClassObject* pObj)
{
    return Indicate(1, &pObj);
}

//***************************************************************************
//
//  CAssocQE_Sink::SetStatus
//
//***************************************************************************
//

STDMETHODIMP CAssocQE_Sink::SetStatus(
    long lFlags,
    long lParam,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
    m_pQuery->UpdateTime();
    m_pQuery->SignalSinkDone();

    if (FAILED(lParam))
    {
        // TBD report provider error; cancel query
    }
    return WBEM_S_NO_ERROR;
};





//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END SINK CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@





//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN CLASSDEFSONLY CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


//***************************************************************************
//
//  GetClassDefsOnlyClass
//
//  This takes an association instance, and looks up its class definition.
//  It looks up the parent-most class possible which is non-abstract
//  and instantiable.  This class is already in the master class list.
//
//  It then tags the roles on that class definition with IN or OUT depending
//  on which property actually references the endpoint and which ones do
//  not.
//
//  Second, it does 'hypothetical' tagging, where the OUT roles are each
//  given an independent pass to see if they *could* reference the
//  query endpoint, and the IN role is examined to see if it could
//  in turn reference the unknowns.
//
//  Returns
//  WBEM_E_INVALID_OBJECT if the association cannot point to
//  the endpoint in the current query.
//
//  WBEM_S_NO_ERROR is returned if IN/OUT tagging was properly
//  achieved.
//
//  WBEM_E_* on other conditions, which indicate drastic failure, such
//  as out-of-memory.
//
//***************************************************************************
//

HRESULT CAssocQuery::GetClassDefsOnlyClass(
    IN  IWbemClassObject *pExample,
    OUT IWbemClassObject **pClass
    )
{
    if (!pExample || !pClass)  return WBEM_E_INVALID_PARAMETER;

    *pClass = 0;
    // Get the class that we need.
    // ===========================
    
    HRESULT hRes;
    IWbemClassObject *pCandidate = 0;
    hRes = FindParentmostClass(pExample, &pCandidate);
    if (FAILED(hRes)) return hRes;
    CReleaseMe _(pCandidate);

    _variant_t vClassName;
    hRes = pCandidate->Get(L"__CLASS", 0, &vClassName, 0, 0);
    if (FAILED(hRes) || V_VT(&vClassName) != VT_BSTR)  return WBEM_E_FAILED;

    // If the class has already been delivered, just quit now.
    // =======================================================

    for (int i = 0; i < m_aDeliveredClasses.Size(); i++)
    {
        if (wbem_wcsicmp(m_aDeliveredClasses[i], V_BSTR(&vClassName)) == 0)
            return WBEM_S_NO_ERROR;
    }

    // If here, it's a new class.  Make a copy that we can modify
    // and send back to the user.
    // ==========================================================

    IWbemClassObject *pCopy = 0;
    hRes = pCandidate->Clone(&pCopy);
    if (FAILED(hRes)) return hRes;
    CReleaseMe rmCopy(pCopy);

    hRes = ComputeInOutTags(pExample, pCopy);
    if (FAILED(hRes)) return hRes;        

    // Add the class name to the 'delivered' list.
    // ===========================================

    if (CFlexArray::no_error != m_aDeliveredClasses.Add(V_BSTR(&vClassName)))
        return WBEM_E_OUT_OF_MEMORY;

    // Send it back.  The additional AddRef is because of the
    // CReleaseMe binding.
    // ======================================================
     *pClass = (IWbemClassObject *)rmCopy.dismiss();

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//  CAssocQuery::TagProp
//
//  Tags a property in an object with the named qualifier.  Used to
//  add IN or OUT to class definitions when executing CLASSDEFSONLY queries.
//
//***************************************************************************
//
HRESULT CAssocQuery::TagProp(
    IN IWbemClassObject *pObjToTag,
    IN LPCWSTR pszPropName,
    IN LPCWSTR pszInOutTag
    )
{
    IWbemQualifierSet *pQSet = 0;
    HRESULT hRes = pObjToTag->GetPropertyQualifierSet(pszPropName, &pQSet);
    if (FAILED(hRes))
        return hRes;
    CReleaseMe _1(pQSet);

    CVARIANT v;
    v.SetBool(TRUE);
    pQSet->Put(pszInOutTag, &v, 0);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CAssocQuery::ComputeInOutTags
//
//  Computes the IN/OUT tags on a class using the specified association
//  instance.
//
//  Does not deliver the instance to the sink.
//
//***************************************************************************
// ok

HRESULT CAssocQuery::ComputeInOutTags(
    IN IWbemClassObject *pAssocInst,
    IN IWbemClassObject *pClass
    )
{
    HRESULT hRes;

    if (pAssocInst == 0 || pClass == 0)
        return WBEM_E_INVALID_PARAMETER;

    try
    {
        // Loop through the properties trying to find a legitimate
        // reference to our endpoint class.
        // =======================================================

        pAssocInst->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
        while (1)
        {
            BSTR strPropName = 0;
            hRes = pAssocInst->Next(0,&strPropName,0,0,0);
            CSysFreeMe _1(strPropName);
            if (hRes == WBEM_S_NO_MORE_DATA)
                break;

            hRes = RoleTest(m_pEndpoint, pAssocInst, m_pNs, strPropName, ROLETEST_MODE_PATH_VALUE);
            if (SUCCEEDED(hRes))
            {
                TagProp(pClass, strPropName, L"IN");
            }
            else
                TagProp(pClass, strPropName, L"OUT");
        }   // Enum of ref properties

        pAssocInst->EndEnumeration();


        // Try to infer additional IN/OUT flows by examining the
        // class itself.   Some of these are only possible, rather
        // the definite.  Note that if more than one property
        // has IN flow, {P1=IN, P2=IN, P3=OUT } then by implication each
        // of P1 and P2 can also be OUT, since when one of (P1,P2) is IN
        // the other must be OUT unless there are two refecences to
        // the same object.  Obviously, this entire mechanism is weak
        // theoretically.  It is only there for the CIM Object Browser
        // to have some good idea that there are 'probably' instances
        // for that particular association.
        // =============================================================
        CWStringArray aClassInProps;
        hRes = CanClassRefQueryEp(FALSE, pClass, &aClassInProps);

        for (int i = 0; i < aClassInProps.Size(); i++)
        {
            TagProp(pClass, aClassInProps[i], L"IN");
            for (int i2 = 0; i2 < aClassInProps.Size(); i2++)
            {
                // Tag all the others as OUTs as well.
                if (wbem_wcsicmp(aClassInProps[i2], aClassInProps[i]) != 0)
                {
                    TagProp(pClass, aClassInProps[i], L"OUT");
                }
            }
        }
    }
    catch (CX_MemoryException &) // WString throws
    {
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//  CAssocQuery::FindParentMostClass
//
//  Finds the parent-most class definition object which is still a 'real'
//  class, of the class name specified.  Given {A,B:A,C:B,D:C}, all of
//  which are instantiable, finds 'A' if 'D' is specified in the <pszClass>
//  parameter.
//
//  Note that the master class list only contains classes from the
//  dynamic portion of the database.  Thus, if the association is a static
//  type, we simply look up the first non-abstract class in the repository.
//
//***************************************************************************
//
HRESULT CAssocQuery::FindParentmostClass(
    IN  IWbemClassObject *pAssocInst,
    OUT IWbemClassObject **pClassDef
    )
{
    HRESULT hRes;
    int i;

    if (pAssocInst == 0 || pClassDef == 0)
        return WBEM_E_INVALID_PARAMETER;
    *pClassDef = 0;

    // Get the class hierarchy of the object.
    // ======================================
    CWStringArray aHierarchy;
    hRes = St_GetObjectInfo(
        pAssocInst,
        0, 0, 0,
        aHierarchy
        );

    if (FAILED(hRes))
        return hRes;

    IWbemClassObject *pTarget = 0;

    // Traverse the hierarchy, looking for the class def.
    // ==================================================

    for (i = aHierarchy.Size() - 1; i >= 0; i--)
    {
        for (int i2 = 0; i2 < m_aMaster.Size(); i2++)
        {
            IWbemClassObject *pObj = (IWbemClassObject *) m_aMaster[i2];
            CVARIANT vClassName;
            hRes = pObj->Get(L"__CLASS", 0, &vClassName, 0, 0);
            if (FAILED(hRes) || vClassName.GetType() != VT_BSTR)
                return WBEM_E_FAILED;

            if (wbem_wcsicmp(aHierarchy[i], vClassName.GetStr()) == 0)
            {
                pTarget = pObj;
                break;
            }
        }
        if (pTarget)
            break;
    }

    // If the association class was non-dynamic, it won't have been located
    // by the above search.  Instead, we will go to the repository and
    // starting with the dynasty superclass, work down to the current class
    // until we find a non-abstract class.
    // ====================================================================

    if (pTarget == 0)
    {
        for (i = aHierarchy.Size() - 1; i >= 0; i--)
        {
            IWbemClassObject *pTest = 0;
            hRes = Db_GetClass(aHierarchy[i], &pTest);
            if (FAILED(hRes))
                break;
            hRes = St_ObjHasQualifier(L"ABSTRACT", pTest);
            if (SUCCEEDED(hRes))
            {
                pTest->Release();
                continue;
            }
            else    // This is what we want to send back
            {
                *pClassDef = pTest;
                return WBEM_S_NO_ERROR;
            }
        }
    }

    // Now, see if we found it.
    // ========================

    if (pTarget == 0)
        return WBEM_E_NOT_FOUND;

    pTarget->AddRef();
    *pClassDef = pTarget;
    return WBEM_S_NO_ERROR;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END CLASSDEFSONLY CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN SCHEMA-ONLY SPECIFIC CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//***************************************************************************
//
//  CAssocQuery::SchemaQ_RefsFilter
//
//  Reduces the class set of a schemaonly 'references of' query by
//  cutting out anything specified in the filters.  The filters applied
//  are RESULTCLASS, REQUIREDQUALIFIER, and ROLE.
//
//  The size and content of <aSrc> is altered.  Objects not used
//  are Released().
//
//  Returns status in HRESULT, does not access the destination sink on error.
//
//***************************************************************************
// executions=1; no filtering though

HRESULT CAssocQuery::SchemaQ_RefsFilter(
    IN OUT CFlexArray &aSrc // IN: the unreduced class set, OUT the reduced one
    )
{
    HRESULT hRes;

    // Loop through the result set, looking for things to toss out.
    // ============================================================

    for (int i = 0; i < aSrc.Size(); i++)                   // x
    {
        BOOL bIsACandidate = TRUE;

        // Extract this class definition from the source array.
        // ====================================================

        IWbemClassObject *pCls = (IWbemClassObject *) aSrc[i];

        // Start testing.
        //
        // RESULTCLASS --the object must be of the specified
        // class or part of its hierarchy.
        // ==================================================

        LPCWSTR pszResultClass = m_Parser.GetResultClass();
        if (pszResultClass)
        {
            hRes = St_ObjIsOfClass(pszResultClass, pCls);
            if (FAILED(hRes))
            {
                aSrc[i] = 0;
                pCls->Release();
                hRes = 0;
                continue;
            }
        }

        // If here, there either isn't a RESULTCLASS test or we passed it.
        // Next, we try REQUIREDQUALIFIER.
        // ===============================================================

        LPCWSTR pszRequiredQual = m_Parser.GetRequiredQual();
        if (pszRequiredQual)
        {
            hRes = St_ObjHasQualifier(pszRequiredQual, pCls);
            if (FAILED(hRes))
            {
                aSrc[i] = 0;
                pCls->Release();
                hRes = 0;
                continue;
            }
        }


        // Next, we try ROLE.
        // ==================

        LPCWSTR pszRole = m_Parser.GetRole();          // x

        if (pszRole)
        {
             hRes = RoleTest(m_pEndpoint, pCls, m_pNs, pszRole, ROLETEST_MODE_CIMREF_TYPE);
             if (FAILED(hRes))
             {
                aSrc[i] = 0;
                pCls->Release();
                hRes = 0;
                continue;
             }
        }

    }

    aSrc.Compress();

    return WBEM_S_NO_ERROR;
}


//****************************************************************************
//
//  CAssocQuery::TerminateSchemaQuery
//
//  For schema queries, sends the final result objects to the destination
//  sink and shuts down the query.  At this point, all the objects are in
//  the result set array and ready to be delivered.
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::SchemaQ_Terminate(
    IN CFlexArray &aResultSet
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    aResultSet.Compress();  // Remove NULLs

    // Indicate everything.
    // ====================

    if (aResultSet.Size())
    {
        IWbemClassObject **p = (IWbemClassObject **) aResultSet.GetArrayPtr();
        hRes = m_pDestSink->Indicate(aResultSet.Size(), p);
        St_ReleaseArray(aResultSet);
    }

    return hRes;
}

//****************************************************************************
//
//  CAssocQuery::SchemaQ_RefsQuery
//
//  At this point we have the final list of classes. We now apply any
//  secondary filters and send the result back to the client.
//
//  (1) We apply all filters specified in the query.
//  (2) If CLASSDEFSONLY, we post filter yet again.
//  (3) Deliver to client
//
//****************************************************************************
// visual ok

HRESULT CAssocQuery::SchemaQ_RefsQuery(
    IN OUT CFlexArray &aResultSet
    )
{
    HRESULT hRes;

    // Apply various filters.
    // ======================

    hRes = SchemaQ_RefsFilter(aResultSet);
    if (FAILED(hRes))
        return hRes;

    return SchemaQ_Terminate(aResultSet);
}


//****************************************************************************
//
//  CAssocQuery::SchemaQ_AssocsQuery
//
//  At this point we have the list of association classes.  We apply
//  association-level filters, and then get the other endpoint classes,
//  filtering them in parallel.  The final result set is placed in
//  <aOtherEndpoints> and delivered to the user by the final call
//  to SchemaQ_Terminate.
//
//****************************************************************************
//  visual ok

HRESULT CAssocQuery::SchemaQ_AssocsQuery(
    IN CFlexArray &aAssocSet
    )
{
    HRESULT hRes;

    // Apply association filters.
    // ========================

    hRes = SchemaQ_AssocsFilter(aAssocSet);
    if (FAILED(hRes))
        return hRes;

    // Now, get the other endpoints.  We filter them
    // in parallel, due to the good locality of reference
    // in this case.
    // ==================================================

    CFlexArray aOtherEndpoints;

    hRes = SchemaQ_GetAndFilterOtherEndpoints(
        aAssocSet,
        aOtherEndpoints
        );

    St_ReleaseArray(aAssocSet); // Done with the associations themselves

    if (FAILED(hRes))
        return hRes;

    // Apply other-endpoint filters.
    // =============================

    return SchemaQ_Terminate(aOtherEndpoints);
}


//***************************************************************************
//
//  CAssocQuery::ConvertEpListToClassDefsOnly
//
//  Filters the endpoint list of instances and changes it into the minimal
//  set of class definitions.  Classes must be in the same namespace.
//
//***************************************************************************
//
HRESULT CAssocQuery::ConvertEpListToClassDefsOnly()
{
    CFlexArray aNew;
    HRESULT hRes;
    BOOL bArrayNeedsCleanup = FALSE;

    CInCritSec ics(&m_csCandidateEpAccess);

    for (int i = 0; i < m_aEpCandidates.Size(); i++)
    {
        BSTR strEpPath = (BSTR) m_aEpCandidates[i];
        if (strEpPath == 0)
            continue;

        BSTR strClassName = 0;
        hRes = St_ObjPathInfo(strEpPath, &strClassName, 0);
        if (FAILED(hRes))
        {
            hRes = 0;
            continue;
        }

        BOOL bFound = FALSE;

        // See if class is in our new destination array.
        // =============================================

        for (int i2 = 0; i2 < aNew.Size(); i2++)
        {
            BSTR strTest = (BSTR) aNew[i2];
            if (wbem_wcsicmp(strClassName, strTest) == 0)
            {
                bFound = TRUE;
                break;
            }
        }

        if (bFound == TRUE)
            SysFreeString(strClassName);
        else
        {
            if (CFlexArray::no_error != aNew.Add(strClassName))
            {
                SysFreeString(strClassName);
                bArrayNeedsCleanup = TRUE;
                break;
            }
        }
    }

    if (bArrayNeedsCleanup)
    {
        for (i = 0; i < aNew.Size(); i++) SysFreeString((BSTR)aNew[i]);
        return WBEM_E_OUT_OF_MEMORY;
    }

    EmptyCandidateEpArray();

    for (i = 0; i < aNew.Size(); i++)
    {
        if (CFlexArray::no_error != m_aEpCandidates.Add(aNew[i]))
        {
              bArrayNeedsCleanup = TRUE;
              break;
        }
    }

    if (bArrayNeedsCleanup)
    {
        // continue from where you finished
        for (; i < aNew.Size(); i++) SysFreeString((BSTR)aNew[i]);
        return WBEM_E_OUT_OF_MEMORY;        
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CAssocQuery::SchemaQ_AssocsFilter
//
//  Called during an 'associators of' query, this filters out the
//  classes which don't pass the test for the association classes
//  themselves.
//
//  Tests for ROLE and REQUIREDASSOCQUALIFIER.
//
//***************************************************************************
// ok

HRESULT CAssocQuery::SchemaQ_AssocsFilter(
    IN OUT CFlexArray &aSrc
    )
{
    HRESULT hRes;

    LPCWSTR pszRole = m_Parser.GetRole();
    LPCWSTR pszRequiredAssocQual = m_Parser.GetRequiredAssocQual();

    // If there are no filters anyway, short-circuit.
    // ==============================================

    if (pszRole == 0 && pszRequiredAssocQual == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    // If here, some tests are required.
    // =================================

    for (int i = 0; i < aSrc.Size(); i++)
    {
        IWbemClassObject *pCls = (IWbemClassObject *) aSrc[i];

        // If ROLE is present, ensure query endpoint is referenced
        // by it.
        // =======================================================

        if (pszRole)
        {
             hRes = RoleTest(m_pEndpoint, pCls, m_pNs, pszRole, ROLETEST_MODE_CIMREF_TYPE);
             if (FAILED(hRes))
             {
                aSrc[i] = 0;
                pCls->Release();
                hRes = 0;
                continue;
             }
        }

        // If REQUIREDASSOCQUALIFIER was in the query,
        // ensure it is present.
        // ===========================================

        if (pszRequiredAssocQual)
        {
            hRes = St_ObjHasQualifier(pszRequiredAssocQual, pCls);
            if (FAILED(hRes))
            {
                aSrc[i] = 0;
                pCls->Release();
                hRes = 0;
                continue;
            }
        }
    }

    aSrc.Compress();

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CAssocQuery::SchemaQ_GetAndFilterOtherEndpoints
//
//  Given the set of classes in <aAssocs>, get the other endpoint
//  classes.
//
//  The filtering is achieved in parallel, since we have locality
//  of reference between the association object and the endpoint.
//
//  Parameters:
//  <aAssocs>       The association classes.
//  <aEndpoints>    Receives the endpoint classes.
//
//  Result:
//  HRESULT         Does not access the destination sink.
//
//***************************************************************************
// ok

HRESULT CAssocQuery::SchemaQ_GetAndFilterOtherEndpoints(
    IN CFlexArray &aAssocs,
    OUT CFlexArray &aEndpoints
    )
{
    HRESULT hRes;

    for (int i = 0; i < aAssocs.Size(); i++)
    {
        IWbemClassObject *pAssoc = (IWbemClassObject *) aAssocs[i];
        IWbemClassObject *pEpClass = 0;

        // Find the property that references the other endpoint.
        // ====================================================

        BSTR strOtherEpName = 0;
        hRes = SchemaQ_GetOtherEpClassName(pAssoc, &strOtherEpName);
        if (FAILED(hRes))
            continue;

        CSysFreeMe _1(strOtherEpName);

        // If we failed to get a name we should continue.
        if ( S_OK != hRes )
        {
            hRes = 0;
            continue;
        }

        // Now, get that class.  The class comes back
        // property AddRef'ed. If we don't use it, then we
        // have to Release it.
        // ===============================================
        hRes = GetClassFromAnywhere(strOtherEpName, 0, &pEpClass);

        if (FAILED(hRes))
        {
            // WE have a dangling reference.
            // =============================
            ERRORTRACE((LOG_WBEMCORE, "Invalid path %S specified in an association class\n", strOtherEpName));
            EmptyObjectList(aEndpoints);
            return WBEM_E_INVALID_OBJECT_PATH;
        }

        //
        // If here, we have the endpoint class in <pEpClass>
        // and the associationclass in pAssoc.
        // Now, apply the filters, both to the association and the endpoint.
        //


        // RESULTCLASS
        // Verify that the class of the endpoint is this
        // or part of its hierarchy.
        // =============================================

        LPCWSTR pszResultClass = m_Parser.GetResultClass();
        if (pszResultClass)
        {
            hRes = St_ObjIsOfClass(pszResultClass, pEpClass);
            if (FAILED(hRes))
            {
                pEpClass->Release();
                hRes = 0;
                continue;
            }
        }

        // ROLE.
        // The association must point back to the endpoint
        // via this.
        // ================================================

        LPCWSTR pszRole = m_Parser.GetRole();
        if (pszRole)
        {
             hRes = RoleTest(m_pEndpoint, pAssoc, m_pNs, pszRole, ROLETEST_MODE_CIMREF_TYPE);
             if (FAILED(hRes))
             {
                pEpClass->Release();
                hRes = 0;
                continue;
             }
        }

        // RESULTROLE
        // The association must point to the other endpoint
        // via this property.
        // ================================================

        LPCWSTR pszResultRole = m_Parser.GetResultRole();
        if (pszResultRole)
        {
             hRes = RoleTest(pEpClass, pAssoc, m_pNs, pszResultRole, ROLETEST_MODE_CIMREF_TYPE);
             if (FAILED(hRes))
             {
                pEpClass->Release();
                hRes = 0;
                continue;
             }
        }

        // ASSOCCLASS
        // Verify that the class of the association is this.
        // =================================================

        LPCWSTR pszAssocClass = m_Parser.GetAssocClass();
        if (pszAssocClass)
        {
            hRes = St_ObjIsOfClass(pszAssocClass, pAssoc);
            if (FAILED(hRes))
            {
                pEpClass->Release();
                hRes = 0;
                continue;
            }
        }

        // REQUIREDQUALIFIER
        // Endpoint must have this qualifier.
        // ===================================

        LPCWSTR pszQual = m_Parser.GetRequiredQual();
        if (pszQual)
        {
            hRes = St_ObjHasQualifier(pszQual, pEpClass);
            if (FAILED(hRes))
            {
                pEpClass->Release();
                hRes = 0;
                continue;
            }
        }

        // REQUIREDASSOCQUALIFIER
        // Association object must have this qualifier.
        // ============================================

        LPCWSTR pszRequiredAssocQual = m_Parser.GetRequiredAssocQual();
        if (pszRequiredAssocQual)
        {
            hRes = St_ObjHasQualifier(pszRequiredAssocQual, pAssoc);
            if (FAILED(hRes))
            {
                pEpClass->Release();
                hRes = 0;
                continue;
            }
        }

        // If here, we passed the barrage of filtering
        // tests and can happily report that the class
        // is part of the result set.
        // ===========================================

        if (CFlexArray::no_error != aEndpoints.Add(pEpClass))
        {
            pEpClass->Release();            
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CAssocQuery::SchemaQ_GetOtherEpClassName
//
//  Finds the property in the association which references the
//  'other endpoint' in the query.  This is achieved by locating
//  a property which *does* reference the endpoint and assuming that
//  any remaining property must reference the 'other endpoint'.
//  If both references can reach the query endpoint, then no
//  harm is done
//
//  This function assumes well-formed associations with two
//  references.
//
//  PARAMETERS:
//  <pAssoc>            The association class
//  <strOtherEpName>    Receives the name of the class of the 'other endpoint'
//
//  RESULT:
//  WBEM_S_NO_ERROR, WBEM_E_FAILED
//
//***************************************************************************
// ok

HRESULT CAssocQuery::SchemaQ_GetOtherEpClassName(
    IN IWbemClassObject *pAssocClass,
    OUT BSTR *strOtherEpName
    )
{
    HRESULT hRes = WBEM_E_FAILED;

    if (strOtherEpName == 0)
        return hRes;
    *strOtherEpName = 0;

    BOOL bStrict = (m_Parser.GetQueryType() & QUERY_TYPE_SCHEMA_ONLY) != 0;

    // Enumerate just the references.
    // ===============================

    hRes = pAssocClass->BeginEnumeration(WBEM_FLAG_REFS_ONLY);
    if (FAILED(hRes))
        return WBEM_E_FAILED;

    // Loop through the references.
    // ============================

    int nCount = 0;
    while (1)
    {
        CVARIANT vRefPath;
        BSTR strPropName = 0;
        BSTR strEpClass = 0;

        hRes = pAssocClass->Next(
            0,                  // Flags
            &strPropName,       // Name
            vRefPath,           // Value
            0,                  // CIM type (refs only already)
            0                   // Flavor
            );

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        CSysFreeMe _1(strPropName);
        hRes = CanPropRefQueryEp(bStrict, strPropName, pAssocClass, &strEpClass);
        CSysFreeMe _2(strEpClass);

        if (FAILED(hRes) || nCount)
        {
            // If here on the second iteration or the first iteration
            // with a failure, we have found the 'other endpoint'.
            // ======================================================
            *strOtherEpName = SysAllocString(strEpClass);
            if (*strOtherEpName == 0)
                return WBEM_E_OUT_OF_MEMORY;
            hRes = WBEM_S_NO_ERROR;
            break;
        }
        else
            nCount++;
    }

    pAssocClass->EndEnumeration();

    return hRes;
}


//***************************************************************************
//
//  CAssocQuery::CanPropRefQueryEp
//
//  For class definitions, determines if the specified property in the
//  object can reference the query endpoint.   This works for both strongly
//  typed and CLASSREF typed properties.
//
//  PARAMETERS:
//  <pszPropName>       The property to test.  Must be a reference property.
//  <bStrict>           If TRUE, then the property must actually reference
//                      the class of the endpoint. If FALSE, it may reference
//                      any of the superclasses of the endpoint.
//  <pObj>              The association object with the property to be tested.
//  <strRefType>        Optionally receives the name of the class in the
//                      CIMTYPE "REF:Classname>" string, as long as
//                      the reference is strongly typed (does not work
//                      for CLASSREF types).
//
//  RETURNS:
//  HRESULT
//      WBEM_S_NO_ERROR if the property can reference the query endpoint.
//      WBEM_E_NOT_FOUND if the property cannot reference the query endpoint.
//      or
//      WBEM_E_INVALID_PARAMETER
//      WBEM_E_FAILED
//
//***************************************************************************
//

HRESULT CAssocQuery::CanPropRefQueryEp(
    IN BOOL bStrict,
    IN LPWSTR pszPropName,
    IN IWbemClassObject *pObj,
    OUT BSTR *strRefType
    )
{
    HRESULT hRes;
    wchar_t ClassName[MAX_CLASS_NAME];

    *ClassName = 0;

    if (pszPropName == 0 || pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Get the qualifier set for this property.
    // ========================================

    IWbemQualifierSet *pQSet = 0;
    hRes = pObj->GetPropertyQualifierSet(pszPropName,&pQSet);
    if (FAILED(hRes))
        return WBEM_E_FAILED;
    CReleaseMe _1(pQSet);

    // Now get the CIMTYPE of this reference.
    // ======================================

    CVARIANT v;
    hRes = pQSet->Get(L"CIMTYPE", 0, &v, 0);
    if (FAILED(hRes) || V_VT(&v) != VT_BSTR)
        return WBEM_E_FAILED;

    BSTR strRefClass = V_BSTR(&v);
    if (strRefClass)
    {
        if (wcslen_max(strRefClass,MAX_CLASS_NAME) > MAX_CLASS_NAME)  return WBEM_E_FAILED;        
        parse_REF(strRefClass,MAX_CLASS_NAME,ClassName);     
    }


    // Send a copy of the class name back to the
    // caller, if required.
    // =========================================

    if (strRefType)
    {
        *strRefType = 0;
        if (*ClassName)
        {
            *strRefType = SysAllocString(ClassName);
            if (*strRefType == 0)
                return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // Now see if this class is any of the classes in our
    // query endpoint.
    // ==================================================

    if (*ClassName)
    {
        // If <bStrict> we must match the class name of the
        // query endpoint exactly.

        if (bStrict)
        {
            if (wbem_wcsicmp(ClassName, m_bstrEndpointClass) == 0)
                return WBEM_S_NO_ERROR;
        }
        // Else, any of the superclasses of the endpoint will do.
        else
        {
           for (int i = 0; i < m_aEndpointHierarchy.Size(); i++)
           {
                if (wbem_wcsicmp(ClassName, m_aEndpointHierarchy[i]) == 0)
                    return WBEM_S_NO_ERROR;
           }
        }
    }

    // If here, we can try to see if the property has a CLASSREF
    // qualifier instead.
    // =========================================================

    hRes = CanClassRefReachQueryEp(pQSet, bStrict);

    if (SUCCEEDED(hRes))
        return WBEM_S_NO_ERROR;

    // If here, the property doesn't reference the query
    // endpoint in any way.
    // =================================================

    return WBEM_E_NOT_FOUND;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END SCHEMA-ONLY SPECIFIC CODE
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  BEGIN DYNAMIC CLASS HELPERS
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



//***************************************************************************
//
//  ClassNameTest
//
//  Sort helper
//
//***************************************************************************
//
static int ClassNameTest(
    IN CFlexArray &Classes,
    IN int nIndex1,                // iBackscan
    IN int nIndex2                 // iBackscan-nInterval
    )
{
    HRESULT hr;
    // Name test.
    IWbemClassObject *pC1 = (IWbemClassObject *) Classes[nIndex1];
    IWbemClassObject *pC2 = (IWbemClassObject *) Classes[nIndex2];

    CVARIANT v1, v2;
    hr = pC1->Get(L"__CLASS", 0, &v1, 0, 0);
    if (FAILED(hr) || VT_BSTR != V_VT(&v1)) return 1;
    hr = pC2->Get(L"__CLASS", 0, &v2, 0, 0);
    if (FAILED(hr) || VT_BSTR != V_VT(&v2)) return 1;
    
    return wbem_wcsicmp(V_BSTR(&v1), V_BSTR(&v2));
}


//***************************************************************************
//
//  CAssocQuery::SortDynClasses
//
//  Sorts the dynamic classes so they can be binary searched later.
//
//***************************************************************************
//
void CAssocQuery::SortDynClasses()
{
    // Shell sort.
    // ===========
    int nSize = m_aDynClasses.Size();

    for (int nInterval = 1; nInterval < nSize / 9; nInterval = nInterval * 3 + 1);

    while (nInterval)
    {
        for (int iCursor = nInterval; iCursor < nSize; iCursor++)
        {
            int iBackscan = iCursor;

            while (iBackscan - nInterval >= 0
                   && ClassNameTest(m_aDynClasses, iBackscan, iBackscan-nInterval) < 0)
            {
                // Swap.
                // =====
                IWbemClassObject *pTmp = (IWbemClassObject *) m_aDynClasses[iBackscan - nInterval];
                m_aDynClasses[iBackscan - nInterval] = m_aDynClasses[iBackscan];
                m_aDynClasses[iBackscan] = pTmp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


//***************************************************************************
//
//  CAssocQuery::GetDynClasses
//
//  Fills the per-query cache with all available dynamic assoc classes.
//
//***************************************************************************
//
HRESULT CAssocQuery::GetDynClasses()
{

    CSynchronousSink* pDynClassSink = 0;
    HRESULT hRes = 0;

    // Now, get all dynamic classes.
    // =============================

    pDynClassSink = CSynchronousSink::Create();  
    if (NULL == pDynClassSink) return WBEM_E_OUT_OF_MEMORY;
    pDynClassSink->AddRef();
    CReleaseMe _1(pDynClassSink);

    hRes = m_pNs->GetDynamicReferenceClasses( 0L, m_pContext, pDynClassSink );
    if (FAILED(hRes))  return hRes;

    pDynClassSink->Block();
    pDynClassSink->GetStatus(&hRes, NULL, NULL);

    // Now get all the dynamic class definitions.
    CRefedPointerArray<IWbemClassObject>& raObjects = pDynClassSink->GetObjects();
    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];        
        if (CFlexArray::no_error == m_aDynClasses.Add(pClsDef))
        {
            pClsDef->AddRef();
        }
    }

    SortDynClasses();

    return WBEM_S_NO_ERROR;

}

//***************************************************************************
//
//  CAssocQuery::GetDynClass
//
//  Attempts to find the requested class in the dynamic class cache.
//
//***************************************************************************
//

HRESULT CAssocQuery::GetDynClass(
    IN  LPCWSTR pszClassName,
    OUT IWbemClassObject **pCls
    )
{
    HRESULT hRes;
    if (pCls == 0 || pszClassName == 0)
        return WBEM_E_INVALID_PARAMETER;
    *pCls = 0;

    CFlexArray &a = m_aDynClasses;

    // Binary search the cache.
    // ========================

    int l = 0, u = a.Size() - 1;
    while (l <= u)
    {
        int m = (l + u) / 2;
        IWbemClassObject *pItem = (IWbemClassObject *) a[m];

        CVARIANT vClassName;
        hRes = pItem->Get(L"__CLASS", 0, &vClassName, 0, 0);
        if (FAILED(hRes) || VT_BSTR != V_VT(&vClassName)) return WBEM_E_NOT_FOUND;
        
        int nRes = wbem_wcsicmp(pszClassName, V_BSTR(&vClassName));

        if (nRes < 0)
            u = m - 1;
        else if (nRes > 0)
            l = m + 1;
        else
        {
            pItem->AddRef();
            *pCls = pItem;
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_E_NOT_FOUND;
}



//***************************************************************************
//
//  GetClassDynasty
//
//  Gets all the classes in a dynasty.  The returned array has a
//  set of IWbemClassObject pointers that need releasing.
//
//***************************************************************************
//
HRESULT CAssocQuery::GetClassDynasty(
    IN LPCWSTR pszClass,
    OUT CFlexArray &aDynasty
    )
{
    HRESULT hRes;
    CSynchronousSink* pClassSink = CSynchronousSink::Create();   
    if (NULL == pClassSink) return WBEM_E_OUT_OF_MEMORY;
    pClassSink->AddRef();
    CReleaseMe _1(pClassSink);

    hRes = m_pNs->Exec_CreateClassEnum( LPWSTR(pszClass), WBEM_FLAG_DEEP, m_pContext, pClassSink);

    if (FAILED(hRes)) return hRes;
    pClassSink->GetStatus(&hRes, NULL, NULL);
    if (FAILED(hRes)) return hRes;    

    aDynasty.Bind(pClassSink->GetObjects().GetArray());
        
    return WBEM_S_NO_ERROR;
}

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
//  END DYNAMIC CLASS HELPERS
//
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\assocqp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ASSOCQP.H

Abstract:

    WQL association query parser

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/

#ifndef _ASSOCQP_H_
#define _ASSOCQP_H_

#define QUERY_TYPE_GETASSOCS		    0x1
#define QUERY_TYPE_GETREFS			    0x2
#define QUERY_TYPE_CLASSDEFS_ONLY	    0x4
#define QUERY_TYPE_SCHEMA_ONLY		    0x8
#define QUERY_TYPE_KEYSONLY             0x10
#define QUERY_TYPE_CLASSDEFS_ONLY_EX    0x20

class CAssocQueryParser
{
    LPWSTR m_pszQueryText;
    LPWSTR m_pszTargetObjPath;
    LPWSTR m_pszResultClass;
    LPWSTR m_pszAssocClass;
    LPWSTR m_pszRole;
    LPWSTR m_pszResultRole;
    LPWSTR m_pszRequiredQual;
    LPWSTR m_pszRequiredAssocQual;
    DWORD   m_dwType;

    CObjectPathParser m_PathParser;
    ParsedObjectPath  *m_pPath;

public:
    CAssocQueryParser();
   ~CAssocQueryParser();

    HRESULT Parse(LPWSTR Query);
        // Parses both query and target object path.
        // Returns:
        //      WBEM_E_INVALID_QUERY on syntax error
        //      WBEM_E_INVALID_OBJECT_PATH if the object
        //          path is syntactically invalid.
        //      WBEM_E_OUT_OF_MEMORY
        //      WBEM_S_NO_ERROR

    LPCWSTR GetQueryText() { return m_pszQueryText; }
    LPCWSTR GetTargetObjPath() { return m_pszTargetObjPath; }
    LPCWSTR GetResultClass() { return m_pszResultClass; }
    LPCWSTR GetAssocClass() { return m_pszAssocClass; }
    LPCWSTR GetRole() { return m_pszRole; }
    LPCWSTR GetResultRole() { return m_pszResultRole; }
    LPCWSTR GetRequiredQual() { return m_pszRequiredQual; }
    LPCWSTR GetRequiredAssocQual() { return m_pszRequiredAssocQual; }
    DWORD   GetQueryType() { return m_dwType; }
        // Returns a mask of
        //      QUERY_TYPE_GETREFS
        //      QUERY_TYPE_GETASSOCS
        //      QUERY_TYPE_CLASSDEFS_ONLY
        //      QUERY_TYPE_KEYSONLY
        //      QUERY_TYPE_SCHEMA_ONLY

    const   ParsedObjectPath *GetParsedPath() { return m_pPath; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\assocqe.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ASSOCQE.H

Abstract:

	WinMgmt Association Query Engine

History:

    raymcc  04-Jul-99   Created

--*/

#ifndef _ASSOCQE_H_
#define _ASSOCQE_H_


class CAssocQE_Sink;
class CAssocQuery;
class CObjectSink;

typedef HRESULT (CAssocQuery::*PF_FilterForwarder)(IWbemClassObject *);

#define  ROLETEST_MODE_PATH_VALUE   1
#define  ROLETEST_MODE_CIMREF_TYPE  2

#define  ASSOCQ_FLAG_QUERY_ENDPOINT 1
#define  ASSOCQ_FLAG_OTHER_ENDPOINT 2

class CAssocQuery : public IUnknown
{
    friend class CAssocQE_Sink;

    LONG               m_lRef;                  // COM ref count

    CAssocQueryParser  m_Parser;               // Parsed query access
    CBasicObjectSink  *  m_pDestSink;             // Final destination sink
    IWbemClassObject  *m_pEndpoint;             // Endpoint in query
    BSTR                       m_bstrEndpointClass;     // Class name of endpoint
    BSTR                       m_bstrEndpointPath;      // Full path of endpoint
    BSTR                       m_bstrEndpointRelPath;   // Rel path of endpoint
    bool                         m_bEndpointIsClass;      // True if endpoint a class
    CWStringArray         m_aEndpointHierarchy;    // Query endpoint class hiearchy
    DWORD                   m_dwQueryStartTime;      // When query started
    DWORD                   m_dwLastResultTime;      // Updated during indications
    LONG                      m_lActiveSinks;          // How many sinks are still running
    HANDLE                   m_hSinkDoneEvent;        // Signaled as sinks complete
    CFlexArray              m_aMaster;               // Assoc class list
    BOOL                      m_bLimitNeedsDecrement;
    // Helpers for 'associators of' queries.
    // =====================================
    CFlexArray         m_aEpCandidates;         // List of paths to EP candidates for associators queries
    CCritSec           m_csCandidateEpAccess;   // Critsec to protect access to Ep candidate array

    // Dynamic class cache.
    // ====================
    CFlexArray         m_aDynClasses;           // Contains all dynamic classes available as of this query

    // Helpers for references of + CLASSDEFSONLY
    // =========================================
    CWStringArray      m_aDeliveredClasses;     // List of class names already in the below list
    CCritSec          m_csDeliveredAccess;

    // From the original call.
    // =======================
    IWbemContext      *m_pContext;
    CWbemNamespace    *m_pNs;
    bool m_bCancel;


    // Various Internal methods.
    // =========================

    CAssocQuery();
   ~CAssocQuery();

    // Class list manipulation.
    // ========================

    HRESULT BuildMasterAssocClassList(
        IN OUT CFlexArray &aResultSet
        );

    HRESULT MergeInClassRefList(
        IN OUT CFlexArray &aResultSet
        );

    HRESULT RemoveNonDynClasses(
        IN OUT CFlexArray &aMaster
        );

    HRESULT ReduceToRealClasses(
        IN OUT CFlexArray & aResultSet
        );

    // Endpoint analysis.
    // ==================

    HRESULT CanPropRefQueryEp(
        IN BOOL bStrict,
        IN LPWSTR pszPropName,
        IN IWbemClassObject *pObj,
        OUT BSTR *strRefType
        );

    HRESULT CanClassRefQueryEp(
        IN BOOL bStrict,
        IN IWbemClassObject *pCls,
        OUT CWStringArray *paNames
        );

    HRESULT CanClassRefReachQueryEp(
        IWbemQualifierSet *pQSet,
        BOOL bStrict
        );

    HRESULT DoesAssocInstRefQueryEp(
        IN IWbemClassObject *pObj,
        OUT BSTR *pszRole
        );

    HRESULT EpClassTest(
        LPCWSTR pszResultClass,
        LPCWSTR strClassName,
        IWbemClassObject *pTestClass
        );

    HRESULT GetUnknownEpRoleAndPath(
        IN IWbemClassObject *pAssoc,
        IN BOOL *pFoundQueryEp,
        OUT BSTR *pszRole,
        OUT BSTR *pszUnkEpPath
        );


    // Flow-of-control methods.
    // ========================

    void BranchToQueryType();

    // Schema-query flow-of-control.
    // =============================

    void ExecSchemaQuery();

    HRESULT SchemaQ_RefsQuery(
        IN OUT CFlexArray &aResultSet
        );

    HRESULT SchemaQ_AssocsQuery(
        IN CFlexArray &aAssocSet
        );

    HRESULT SchemaQ_Terminate(
        IN CFlexArray &aResultSet
        );

    HRESULT SchemaQ_RefsFilter(
        IN OUT CFlexArray &aSrc
        );

    HRESULT SchemaQ_AssocsFilter(
        IN OUT CFlexArray &aSrc
        );

    HRESULT SchemaQ_GetAndFilterOtherEndpoints(
        IN CFlexArray &aAssocs,
        OUT CFlexArray &aEndpoints
        );

    HRESULT SchemaQ_GetOtherEpClassName(
        IN IWbemClassObject *pAssoc,
        OUT BSTR *strOtherEpName
        );

    // Normal (instances, classrefs queries)
    // =====================================

    HRESULT ExecNormalQuery();

    HRESULT NormalQ_PreQueryClassFilter(
        CFlexArray &aMaster
        );

    HRESULT NormalQ_ReferencesOf();
    HRESULT NormalQ_AssociatorsOf();

    HRESULT NormalQ_GetRefsOfEndpoint(
        IN IWbemClassObject *pClass,
        IN IWbemObjectSink  *pSink
        );

    HRESULT ConvertEpListToClassDefsOnly();

    HRESULT NormalQ_LoadCheck();

    HRESULT PerformFinalEpTests(
        IWbemClassObject *pEp
        );

    HRESULT NormalQ_ConstructRefsQuery(
        IN IWbemClassObject *pClass,
        IN OUT IWbemContext *pContextCopy,
        OUT BSTR *strQuery
        );

    HRESULT GetCimTypeForRef(
        IN IWbemClassObject *pCandidate,
        IN BSTR pszRole,
        OUT BSTR *strCimType
        );

    HRESULT AssocClassHasOnlyKeys(
        IN IWbemClassObject *pObj
        );

    HRESULT Normal_ExecRefs(
        IN CFlexArray &aMasterClassList
        );



    // Filter auxiliaries for various query types.
    // ===========================================

    HRESULT FilterForwarder_NormalRefs(
        IN IWbemClassObject *pCandidate
        );

    HRESULT FilterForwarder_NormalAssocs(
        IN IWbemClassObject *pAssocInst
        );

    HRESULT NormalQ_AssocInstTest(
        IN IWbemClassObject *pAssoc,
        OUT LPWSTR *pszOtherEp
        );

    HRESULT CanAssocClassRefUnkEp(
        IN IWbemClassObject *pClass,
        IN CWStringArray &aUnkEpHierarchy
        );

    // DB Access abstraction for Quasar ease of porting.
    // =================================================

    HRESULT Db_GetClass(
        IN LPCWSTR pszName,
         OUT IWbemClassObject **pObj
        );

    HRESULT Db_GetRefClasses(
        IN  LPCWSTR pszClass,
        OUT CWStringArray &aRefClasses
        );

    HRESULT Db_GetInstRefs(
        IN LPCWSTR pszTarget,
        IN IWbemObjectSink *pDest
        );

    HRESULT Db_GetClassRefClasses(
        IN CFlexArray &aDest
        );

    HRESULT GetClassDynasty(
        IN LPCWSTR pszClass,
        OUT CFlexArray &aDynasty
        );


    // Various static auxiliaries for tests.
    // ======================================

    static HRESULT St_HasClassRefs(
        IN IWbemClassObject *pCandidate
        );

    HRESULT AccessCheck(IWbemClassObject* pObj);

    static HRESULT St_GetObjectInfo(
        IN  IWbemClassObject *pObj,
        OUT BSTR *pClass,
        OUT BSTR *pRelpath,
        OUT BSTR *pPath,
        OUT CWStringArray &aHierarchy
        );

    static HRESULT St_ObjPathInfo(
        IN LPCWSTR pszPath,
        OUT BSTR *pszClass,
        OUT BOOL *pbIsClass
        );

    static HRESULT St_ReleaseArray(
        IN CFlexArray &aObjects
        );

    static HRESULT St_ObjHasQualifier(
        IN LPCWSTR pszQualName,
        IN IWbemClassObject *pObj
        );

    static HRESULT St_ObjIsOfClass(
        IN LPCWSTR pszRequiredClass,
        IN IWbemClassObject *pObj
        );

    HRESULT GetClassDefsOnlyClass(
        IN IWbemClassObject *pExample,
        OUT IWbemClassObject **pClass
        );

    HRESULT FindParentmostClass(
        IN  IWbemClassObject *pAssocInst,
        OUT IWbemClassObject **pClassDef
        );

    HRESULT TagProp(
        IN IWbemClassObject *pObjToTag,
        IN LPCWSTR pszPropName,
        IN LPCWSTR pszInOutTag
        );

    // Other.
    // ======
    void UpdateTime() { m_dwLastResultTime = GetCurrentTime(); }
    void SignalSinkDone() { SetEvent(m_hSinkDoneEvent);}

    HRESULT GetDynClasses();

    HRESULT GetDynClass(
        IN  LPCWSTR pszClassName,
        OUT IWbemClassObject **pCls
        );
    void SortDynClasses();

    HRESULT ResolveEpPathsToObjects(int nMaxToProcess);

    HRESULT ComputeInOutTags(
        IN IWbemClassObject *pAssocInst,
        IN IWbemClassObject *pClass
        );

    static HRESULT PathPointsToObj(
        IN LPCWSTR pszPath,
        IN IWbemClassObject *pObj,
        IN CWbemNamespace *pNs
        );

    HRESULT GetClassFromAnywhere(
        IN  LPCWSTR pszEpClassName,
        IN  LPCWSTR pszFullClassPath,
        OUT IWbemClassObject **pCls
        );

    HRESULT AddEpCandidatePath(
        IN BSTR strOtherEp
        );

    void EmptyCandidateEpArray();

    CObjectSink * CreateSink(PF_FilterForwarder pfnFilter, BSTR strTrackingQuery);

public:
    static CAssocQuery *CreateInst();

    // IUnknown.
    // =========

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);

    HRESULT Execute(
        IN  CWbemNamespace *pNs,
        IN  LPWSTR wszQuery,
        IN  IWbemContext* pContext,
        IN  CBasicObjectSink* pSink
        );

    HRESULT Cancel();

    static HRESULT RoleTest(
        IN IWbemClassObject *pEndpoint,
        IN IWbemClassObject *pCandidate,
        IN CWbemNamespace *pNs,
        IN LPCWSTR pszRole,
        IN DWORD dwMode
        );
};




#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\assocqp.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    ASSOCQP.CPP

Abstract:

    Association query parser

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/

#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>

#include <wbemcore.h>


// ==========================================================================
//                        ASSOCIATION QUERY PARSER.
// ==========================================================================


#define QASSOC_TOK_STRING       101
#define QASSOC_TOK_IDENT        102
#define QASSOC_TOK_DOT          103
#define QASSOC_TOK_EQU          104
#define QASSOC_TOK_COLON        105

#define QASSOC_TOK_ERROR        1
#define QASSOC_TOK_EOF          0

#define ST_IDENT                13
#define ST_STRING               19
#define ST_QSTRING              26
#define ST_QSTRING_ESC          30

// DFA State Table for Assoc query tokens.
// =======================================

LexEl AssocQuery_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'{',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,

/* 4 */  L'=',   GLEX_EMPTY, 0,  QASSOC_TOK_EQU, GLEX_ACCEPT|GLEX_RETURN,
/* 5 */  L'.',   GLEX_EMPTY, 0,  QASSOC_TOK_DOT, GLEX_ACCEPT|GLEX_RETURN,
/* 6 */  L':',   GLEX_EMPTY, 0,  QASSOC_TOK_COLON, GLEX_ACCEPT|GLEX_RETURN,

/* 7 */  L' ',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 8 */  L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 9 */  L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 10 */  L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 11 */  0,      GLEX_EMPTY, 0,  QASSOC_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 12 */  GLEX_ANY, GLEX_EMPTY, 0,        QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


/* ST_IDENT */

/* 13 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 14 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 15 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 16 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 17 */  GLEX_ANY, GLEX_EMPTY,  0,  QASSOC_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

/* ST_STRING */
/* 18 */  0, GLEX_EMPTY, 0,        QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,
/* 19 */  L'"', GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
/* 20 */  L'}',  GLEX_EMPTY, 0, QASSOC_TOK_STRING, GLEX_RETURN,
/* 21 */  L' ',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 22 */  L'\r',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 23 */  L'\n',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 24 */  L'\t',  GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 25 */  GLEX_ANY, GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,

/* ST_QSTRING */
/* 26 */   0,    GLEX_EMPTY,   0, QASSOC_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,
/* 27 */   L'"', GLEX_EMPTY,   ST_STRING, 0, GLEX_ACCEPT,
/* 28 */   L'\\', GLEX_EMPTY,   ST_QSTRING_ESC, 0, GLEX_ACCEPT,
/* 29 */   GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,

/* ST_QSTRING_ESC */
/* 30 */   GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
};

/*----------------------------------------------------

References of {objpath} where
    ResultClass=XXX
    Role=YYY
    RequiredQualifier=QualifierName
    ClassDefsOnly

Associators of {objpath} where
    ResultClass=XXX
    AssocClass=YYY
    Role=PPP
    RequiredQualifier=QualifierName
    RequiredAssocQualifier=QualifierName
    ClassDefsOnly

------------------------------------------------------*/

static BOOL ParseAssocQuery(
    IN  LPWSTR  Query,
    OUT LPWSTR *pTargetObj,
    OUT LPWSTR *pResultClass,
    OUT LPWSTR *pAssocClass,
    OUT LPWSTR *pRole,
    OUT LPWSTR *pResultRole,
    OUT LPWSTR *pRequiredQualifier,
    OUT LPWSTR *pRequiredAssocQualifier,
    OUT DWORD  *pdwQueryType
    )
{
    *pTargetObj = 0;
    *pResultClass = 0;
    *pAssocClass = 0;
    *pRole = 0;
    *pResultRole = 0;
    *pRequiredQualifier = 0;
    *pRequiredAssocQualifier = 0;
    *pdwQueryType = 0;


    // SEC:REVIEWED 2002-03-22 : Enforce max query limit length here with a wcslen in an EH
    // ...

    // SEC:REVIEWED 2002-03-22 : Needs EH around these contructors in case they throw

    CTextLexSource src(Query);
    CGenLexer Lexer(AssocQuery_LexTable, &src);

    int nTok = 0;
    BOOL bHadTokens = FALSE;

    // Get first token.
    // TBD: Check for out-of-memory
    // =============================
    nTok = Lexer.NextToken();            // SEC:REVIEWED 2002-03-22 : Assume lexer enforces limit
    if (nTok != QASSOC_TOK_IDENT)
        goto Error;

    // REFERENCES or ASSOCIATORS
    // =========================
    if (wbem_wcsicmp(L"References", Lexer.GetTokenText()) == 0)  // SEC:REVIEWED 2002-03-22 : This and following occurrences are ok
        *pdwQueryType |= QUERY_TYPE_GETREFS;
    else if (wbem_wcsicmp(L"Associators", Lexer.GetTokenText()) == 0)
        *pdwQueryType |= QUERY_TYPE_GETASSOCS;
    else
        goto Error;

    // OF
    // ==
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_IDENT)
        goto Error;
    if (wbem_wcsicmp(L"of", Lexer.GetTokenText()) != 0)
        goto Error;

    // {OBJECTPATH}
    // ============
    nTok = Lexer.NextToken();
    if (nTok != QASSOC_TOK_STRING)
        goto Error;

    *pTargetObj = Macro_CloneLPWSTR(Lexer.GetTokenText());
    if (NULL == *pTargetObj)
        goto Error;        

    // WHERE
    // =====
    nTok = Lexer.NextToken();
    if (nTok == QASSOC_TOK_EOF)
        goto Completed;

    if (nTok != QASSOC_TOK_IDENT)
        goto Error;

    if (wbem_wcsicmp(L"where", Lexer.GetTokenText()) != 0)
        goto Error;

    // Check for RESULTCLASS, ROLE, ASSOCCLASS, CLASSDEFSONLY,
    // REQUIREDQUALIFIER, REQUIREDASSOCQUALIFIER
    // ======================================================

    for (;;)
    {
        nTok = Lexer.NextToken();
        if (nTok == QASSOC_TOK_ERROR)
            goto Error;

        if (nTok == QASSOC_TOK_EOF)
        {
            if(!bHadTokens)
                goto Error;
            else
                goto Completed;
        }

        if (nTok != QASSOC_TOK_IDENT)
            goto Error;

        bHadTokens = TRUE;

        if (wbem_wcsicmp(L"RESULTCLASS", Lexer.GetTokenText()) == 0)
        {
            if(*pResultClass)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pResultClass = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"ROLE", Lexer.GetTokenText()) == 0)
        {
            if(*pRole)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRole = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"RESULTROLE", Lexer.GetTokenText()) == 0)
        {
            if(*pResultRole)
                goto Error;
            if(*pdwQueryType & QUERY_TYPE_GETREFS)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pResultRole = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"ASSOCCLASS", Lexer.GetTokenText()) == 0)
        {
            if(*pAssocClass)
                goto Error;
            if(*pdwQueryType & QUERY_TYPE_GETREFS)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pAssocClass = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"REQUIREDQUALIFIER", Lexer.GetTokenText()) == 0)
        {
            if(*pRequiredQualifier)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRequiredQualifier = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"REQUIREDASSOCQUALIFIER", Lexer.GetTokenText()) == 0)
        {
            if(*pRequiredAssocQualifier)
                goto Error;
            if(*pdwQueryType & QUERY_TYPE_GETREFS)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_EQU)
                goto Error;
            nTok = Lexer.NextToken();
            if (nTok != QASSOC_TOK_IDENT)
                goto Error;
            *pRequiredAssocQualifier = Macro_CloneLPWSTR(Lexer.GetTokenText());
        }
        else if (wbem_wcsicmp(L"CLASSDEFSONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= QUERY_TYPE_CLASSDEFS_ONLY;
        }
        else if (wbem_wcsicmp(L"KEYSONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= QUERY_TYPE_KEYSONLY;
        }
        else if (wbem_wcsicmp(L"SCHEMAONLY", Lexer.GetTokenText()) == 0)
        {
            *pdwQueryType |= QUERY_TYPE_SCHEMA_ONLY;
        }
        else
        {
            goto Error;
        }
    }


Completed:
    if( (*pdwQueryType & QUERY_TYPE_SCHEMA_ONLY) &&
        (*pdwQueryType & QUERY_TYPE_CLASSDEFS_ONLY))
    {
        goto Error;
    }
    return TRUE;

Error:
    delete *pTargetObj;
    delete *pResultClass;
    delete *pAssocClass;
    delete *pRole;
    delete *pResultRole;
    delete *pRequiredQualifier;
    delete *pRequiredAssocQualifier;

    *pTargetObj = 0;
    *pResultClass = 0;
    *pAssocClass = 0;
    *pRole = 0;
    *pResultRole = 0;
    *pdwQueryType = 0;
    *pRequiredQualifier = 0;
    *pRequiredAssocQualifier = 0;

    return FALSE;
}

//***************************************************************************
//
//***************************************************************************

CAssocQueryParser::CAssocQueryParser()
{
    m_pszQueryText = 0;
    m_pszTargetObjPath = 0;
    m_pszResultClass = 0;
    m_pszAssocClass= 0;
    m_pszRole = 0;
    m_pszResultRole = 0;
    m_pszRequiredQual = 0;
    m_pszRequiredAssocQual = 0;
    m_dwType = 0;
    m_pPath = 0;
}

//***************************************************************************
//
//***************************************************************************

CAssocQueryParser::~CAssocQueryParser()
{
    delete m_pszQueryText;
    delete m_pszTargetObjPath;
    delete m_pszResultClass;
    delete m_pszAssocClass;
    delete m_pszRole;
    delete m_pszResultRole;
    delete m_pszRequiredQual;
    delete m_pszRequiredAssocQual;
    
    if (m_pPath) m_PathParser.Free(m_pPath);
}

//***************************************************************************
//
//***************************************************************************
HRESULT CAssocQueryParser::Parse(LPWSTR pszQuery)
{
    if (pszQuery == NULL)
        return WBEM_E_INVALID_QUERY;

    // Clone the query text for debugging.
    // ===================================
	DUP_STRING_NEW(m_pszQueryText, pszQuery);
    if (m_pszQueryText == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    // Parse it.
    // =========

    BOOL bRes = ParseAssocQuery(
        m_pszQueryText,
        &m_pszTargetObjPath,
        &m_pszResultClass,
        &m_pszAssocClass,
        &m_pszRole,
        &m_pszResultRole,
        &m_pszRequiredQual,
        &m_pszRequiredAssocQual,
        &m_dwType
        );

    if (bRes == FALSE)
        return WBEM_E_INVALID_QUERY;

    // Parse the object path.
    // ======================

    if (m_pszTargetObjPath)
    {
        int nStatus = m_PathParser.Parse(m_pszTargetObjPath,  &m_pPath);
        if (nStatus != 0)
            return WBEM_E_INVALID_OBJECT_PATH;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\callres.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CALLRES.CPP

Abstract:

    Call Result Class

History:

--*/

#include "precomp.h"
#include "wbemcore.h"

#pragma warning(disable:4355)

CCallResult::CCallResult(IWbemClassObject* pResObj, HRESULT hres,
            IWbemClassObject* pErrorObj)
    : m_lRef(1), m_pResObj(pResObj), m_hres(hres), m_pErrorObj(pErrorObj),
        m_pResNamespace(NULL), m_strResult(NULL), m_ppResObjDest(NULL),
        m_bReady(TRUE), m_XSink(this)
{
    m_hReady = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (NULL == m_hReady) throw CX_MemoryException();
    if(pResObj)
        pResObj->AddRef();
    if(pErrorObj)
        pErrorObj->AddRef();
    gClientCounter.AddClientPtr(&m_Entry);

}

CCallResult::CCallResult(IWbemClassObject** ppResObjDest)
    : m_lRef(1), m_pResObj(NULL), m_hres(WBEM_E_CRITICAL_ERROR),
        m_pErrorObj(NULL), m_pResNamespace(NULL), m_strResult(NULL),
        m_ppResObjDest(ppResObjDest), m_bReady(FALSE), m_XSink(this)
{
    m_hReady = CreateEvent(NULL, TRUE, FALSE, NULL);  
    if (NULL == m_hReady) throw CX_MemoryException();    
    gClientCounter.AddClientPtr(&m_Entry);
}

CCallResult::~CCallResult()
{
    if(m_pResObj)
        m_pResObj->Release();

    if(m_pErrorObj)
        m_pErrorObj->Release();

    if(m_pResNamespace)
        m_pResNamespace->Release();

    SysFreeString(m_strResult);
    CloseHandle(m_hReady);
    
    gClientCounter.RemoveClientPtr(&m_Entry);    
}

HRESULT CCallResult::SetStatus(HRESULT hres, BSTR strParam,
                                IWbemClassObject* pErrorObj)
{
    CInCritSec ics(&m_cs);

    // Check that SetStatus has not been called yet
    // ============================================

    if(m_bReady)
    {
        return WBEM_E_UNEXPECTED;
    }

    // Store data
    // ==========

    m_hres = hres;
    m_strResult = SysAllocString(strParam);
    m_pErrorObj = pErrorObj;
    if(pErrorObj)
        pErrorObj->AddRef();

    // Signal both events --- we are ready for everything
    // ==================================================

    m_bReady = TRUE;
    SetEvent(m_hReady);

    return WBEM_S_NO_ERROR;
}

HRESULT CCallResult::SetResultObject(IWbemClassObject* pResObj)
{
    CInCritSec ics(&m_cs);

    // Check that neither SetStatus nor Indicate has been called yet
    // =============================================================

    if(m_bReady)
    {
        return WBEM_E_UNEXPECTED;
    }

    // Store data
    // ==========

    m_pResObj = pResObj;
    if(pResObj)
        pResObj->AddRef();

    if(m_ppResObjDest)
    {
        *m_ppResObjDest = pResObj;
        if(pResObj)
            pResObj->AddRef();
    }

    return WBEM_S_NO_ERROR;
}


void CCallResult::SetResultString(LPWSTR wszRes)
{
    SysFreeString(m_strResult);
    m_strResult = SysAllocString(wszRes);
}

void CCallResult::SetResultServices(IWbemServices* pRes)
{
    if(m_pResNamespace)
        m_pResNamespace->Release();
    m_pResNamespace = pRes;
    if(pRes)
        pRes->AddRef();
}

void CCallResult::SetErrorInfo()
{
    if(m_pErrorObj)
    {
        IErrorInfo* pInfo = NULL;
        m_pErrorObj->QueryInterface(IID_IErrorInfo, (void**)&pInfo);
        ::SetErrorInfo(0, pInfo);
        pInfo->Release();
    }
}



STDMETHODIMP CCallResult::QueryInterface(REFIID riid, void** ppv)
{
    if (NULL == ppv) return E_POINTER;

    if(riid == IID_IUnknown || riid == IID_IWbemCallResult)
    {
        AddRef();
        *ppv = (void*)this;
        return S_OK;
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


STDMETHODIMP CCallResult::GetResultObject(long lTimeout,
                                          IWbemClassObject** ppObj)
{
    // SEC:REVIEWED 2002-03-22 : Needs EH in case <ppObj> is invalid

    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    *ppObj = NULL;
    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(m_hReady, lTimeout);
    if(dwRes == WAIT_TIMEOUT)
        return WBEM_S_TIMEDOUT;

    if(dwRes == WAIT_FAILED)
        return WBEM_E_FAILED;

    // Event is signaled --- expect object
    // ===================================

    if(m_pResObj)
    {
        *ppObj = m_pResObj;
        m_pResObj->AddRef();
        return WBEM_S_NO_ERROR;
    }
    else
    {
        *ppObj = NULL;
        if(FAILED(m_hres))
            SetErrorInfo();

        return m_hres;
    }
}

STDMETHODIMP CCallResult::GetResultString(long lTimeout, BSTR* pstr)
{
    // SEC:REVIEWED 2002-03-22 : Needs EH in case <pstr> is invalid

    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    *pstr = NULL;
    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(m_hReady, lTimeout);
    if(dwRes == WAIT_TIMEOUT)
        return WBEM_S_TIMEDOUT;

    if(dwRes == WAIT_FAILED)
        return WBEM_E_FAILED;

    // Event is signaled --- expect string
    // ===================================

    if(m_strResult)
    {
        *pstr = SysAllocString(m_strResult);
        return WBEM_S_NO_ERROR;
    }
    else
    {
        *pstr = NULL;
        if(SUCCEEDED(m_hres))
            return WBEM_E_INVALID_OPERATION;
        else
        {
            SetErrorInfo();
            return m_hres;
        }
    }
}

STDMETHODIMP CCallResult::GetCallStatus(long lTimeout, long* plStatus)
{
    // SEC:REVIEWED 2002-03-22 : Needs EH in case <plStatus> is invalid

    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    //*plStatus = WBEM_E_CRITICAL_ERROR;
    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(m_hReady, lTimeout);
    if(dwRes == WAIT_TIMEOUT)
        return WBEM_S_TIMEDOUT;

    if(dwRes == WAIT_FAILED)
        return WBEM_E_FAILED;

    // Event is signaled --- expect status
    // ===================================

	try
	{
		*plStatus = m_hres;
	}
	catch (...)
	{
        ExceptionCounter c;	
		return WBEM_E_INVALID_PARAMETER;
	}

    if(FAILED(m_hres))
    {
        SetErrorInfo();
    }
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CCallResult::GetResultServices(long lTimeout,
                                            IWbemServices** ppServices)
{
    // SEC:REVIEWED 2002-03-22 : Needs EH in case <ppServices> is not valid

    if(!m_Security.AccessCheck())
        return WBEM_E_ACCESS_DENIED;

    *ppServices = NULL;
    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(m_hReady, lTimeout);
    if(dwRes == WAIT_TIMEOUT)
        return WBEM_S_TIMEDOUT;

    if(dwRes == WAIT_FAILED)
        return WBEM_E_FAILED;

    if(m_pResNamespace)
    {
        *ppServices = m_pResNamespace;
        m_pResNamespace->AddRef();
        return WBEM_S_NO_ERROR;
    }
    else
    {
        *ppServices = NULL;
        if(SUCCEEDED(m_hres))
            return WBEM_E_INVALID_OPERATION;
        else
        {
            SetErrorInfo();
            return m_hres;
        }
    }
}


STDMETHODIMP CCallResult::GetResult(
        long lTimeout,
        long lFlags,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult
        )
{
	return WBEM_E_NOT_SUPPORTED;
}













STDMETHODIMP CCallResult::CResultSink::
Indicate(long lNumObjects, IWbemClassObject** aObjects)
{
    if(lNumObjects > 1)
    {
        return WBEM_E_UNEXPECTED;
    }
    if(lNumObjects == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    return m_pOwner->SetResultObject(aObjects[0]);
}

STDMETHODIMP CCallResult::CResultSink::
SetStatus(long lFlags, HRESULT hres, BSTR strParam, IWbemClassObject* pErrorObj)
{
    if(lFlags != 0)
    {
        return WBEM_S_NO_ERROR;
    }

    return m_pOwner->SetStatus(hres, strParam, pErrorObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\callres.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CALLRES.H

Abstract:

    Call Result Class

History:

--*/

#ifndef __CALL_RESULT__H_
#define __CALL_RESULT__H_

class CCallResult : public IWbemCallResult
{
protected:
    long m_lRef;

    IWbemClassObject* m_pResObj;
    HRESULT m_hres;
    BSTR m_strResult;
    IWbemServices* m_pResNamespace;
    IWbemClassObject* m_pErrorObj;

    BOOL m_bReady;
    HANDLE m_hReady;
    IWbemClassObject** m_ppResObjDest;
    CCritSec m_cs;
    CIdentitySecurity m_Security;
    LIST_ENTRY m_Entry;

protected:
    class CResultSink : public CBasicObjectSink
    {
        CCallResult* m_pOwner;
    public:

        STDMETHOD_(ULONG, AddRef)() {return m_pOwner->AddRef();}
        STDMETHOD_(ULONG, Release)() {return m_pOwner->Release();}

        STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** aObjects);
        STDMETHOD(SetStatus)(long lFlags, HRESULT hres, BSTR strParam,
            IWbemClassObject* pErrorObj);

    public:
        CResultSink(CCallResult* pOwner) : m_pOwner(pOwner){}
    } m_XSink;
    friend CResultSink;

public:
    STDMETHOD_(ULONG, AddRef)() {return InterlockedIncrement(&m_lRef);}
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
    {return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR** rgszNames, UINT cNames,
      LCID lcid, DISPID* rgdispid)
    {return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
      DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
      UINT* puArgErr)
    {return E_NOTIMPL;}

    STDMETHOD(GetResultObject)(long lTimeout, IWbemClassObject** ppObj);
    STDMETHOD(GetResultString)(long lTimeout, BSTR* pstr);
    STDMETHOD(GetCallStatus)(long lTimeout, long* plStatus);
    STDMETHOD(GetResultServices)(long lTimeout, IWbemServices** ppServices);


    virtual HRESULT STDMETHODCALLTYPE GetResult(
            /* [in] */ long lTimeout,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult
            );


    HRESULT Indicate(long lNumObjects, IWbemClassObject** aObjects);
    HRESULT SetStatus(HRESULT hres, BSTR strParam, IWbemClassObject* pErrorObj);
public:
    CCallResult(IWbemClassObject** ppResObjDest = NULL);

    CCallResult(IWbemClassObject* pResObj, HRESULT hres,
                IWbemClassObject* pErrorObj);
    ~CCallResult();

    INTERNAL CBasicObjectSink* GetSink() {return &m_XSink;}
    void SetResultString(LPWSTR wszRes);
    void SetResultServices(IWbemServices* pRes);
    HRESULT SetResultObject(IWbemClassObject* pRes);
    void SetErrorInfo();
};



#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\cfgmgr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CFGMGR.CPP

Abstract:

  This file implements the WinMgmt configuration manager class.

  See cfgmgr.h for documentation.

  Classes implemented:
      ConfigMgr      configuration manager

History:

    09-Jul-96   raymcc    Created.
    3/10/97     levn      Fully documented (ha, ha)


--*/


#include "precomp.h"

#define OBJECT_BLOB_CRC

#include <stdio.h>
#include <wbemcore.h>
#include <decor.h>
#include "PersistCfg.h"
#include <genutils.h>
#include <oahelp.inl>
#include <wmiarbitrator.h>
#include <comdef.h>
#include<helper.h>
#include <autoptr.h>
#include <sddl.h>
#include <md5wbem.h>
#include <accctrl.h>
#include <aclapi.h>



#define CONFIG_DEFAULT_QUEUE_SIZE                   1


#define DEFAULT_SHUTDOWN_TIMEOUT                    10000

#ifdef _WIN64
#pragma message("WIN64 QUOTA")
#define CONFIG_MAX_COMMITTED_MEMORY                 300000000
#else
#pragma message("WIN32 QUOTA")
#define CONFIG_MAX_COMMITTED_MEMORY                 150000000       // 100 meg
#endif


extern LPTSTR g_pWorkDir;
extern LPTSTR g_pDbDir;
extern LPTSTR g_pAutorecoverDir;
extern DWORD g_dwQueueSize;
extern BOOL g_bDontAllowNewConnections;
extern IWbemEventSubsystem_m4* g_pEss_m4;
extern bool g_bDefaultMofLoadingNeeded;


//*********************************************************************************
//
//*********************************************************************************

LONG ExceptionCounter::s_Count = 0;

_IWmiESS *g_pESS = 0;
_IWmiProvSS *g_pProvSS = 0;


HANDLE g_hOpenForClients = NULL;
HRESULT g_hresForClients = WBEM_E_CRITICAL_ERROR;

CAsyncServiceQueue* g_pAsyncSvcQueue = NULL;

CEventLog* g_pEventLog = NULL;

extern IClassFactory* g_pContextFac;
extern IClassFactory* g_pPathFac;
extern IClassFactory* g_pQueryFact;
CStaticCritSec ConfigMgr::g_csEss;

CPersistentConfig g_persistConfig;

_IWmiCoreWriteHook * g_pRAHook = NULL;

DWORD g_IdentifierLimit = WBEM_MAX_IDENTIFIER; // Max property, qualifier, class name (4K)
DWORD g_QueryLimit = WBEM_MAX_QUERY;         // Max query size  (16K)
DWORD g_PathLimit = WBEM_MAX_PATH;          // Max object path (8K)

/*
DWORD g_ObjectNestingLimit = WBEM_MAX_OBJECT_NESTING;     // Max embedded object nesting
DWORD g_UserPropLimit = WBEM_MAX_USER_PROPERTIES;     // Max user-defined properties in class
*/


//******************************************************************************
//
//  This routine checks if a string property has changed, and if it has, updates
//  it and setus a bool indicating that an update was done
//
//******************************************************************************

HRESULT PutValueIfDiff(CWbemObject * pObj, LPWSTR pwsValueName, LPWSTR pwsValue, bool &bDiff)
{
    if(pwsValue == NULL)
        return S_OK;

    VARIANT var;
    VariantInit(&var);
    HRESULT hr = pObj->Get(pwsValueName, 0, &var, NULL, NULL);
    CClearMe ccme(&var);
    if(SUCCEEDED(hr))
    {
        if(var.vt == VT_BSTR && var.bstrVal && !wbem_wcsicmp(var.bstrVal, pwsValue))
            return S_OK;
    }
    bDiff = true;
    BSTR bStr = SysAllocString(pwsValue);
    if (bStr)
    {
	CVar v2(VT_BSTR,auto_bstr(bStr));
	return pObj->SetPropValue(pwsValueName, &v2, CIM_STRING);
    }
    else
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}



//*********************************************************************************
//
//*********************************************************************************

void ConfigMgr::FatalInitializationError(HRESULT hRes)
{
    // If there are any clients waiting to get in, this must be set or else they
    // will wait forever.  g_hresForClients should be set to error by default!

    ERRORTRACE((LOG_WBEMCORE, "Failure to initialize WinMgmt (hRes = 0x%X)\n", hRes));

    if (g_hOpenForClients)
        SetEvent(g_hOpenForClients);

    if (g_pEventLog == NULL)
        return;

    DWORD dwMsgId;
    if(hRes == WBEM_E_ALREADY_EXISTS)
    {
        dwMsgId = WBEM_MC_MULTIPLE_NOT_SUPPORTED;
    }
    else if(hRes == WBEM_E_INITIALIZATION_FAILURE)
    {
        dwMsgId = WBEM_MC_FAILED_TO_INITIALIZE_REPOSITORY;
    }
    else
    {
        dwMsgId = WBEM_MC_WBEM_CORE_FAILURE;
    }

    g_pEventLog->Report(EVENTLOG_ERROR_TYPE, dwMsgId);

}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
HRESULT ConfigMgr::SetReady()
{
    HRESULT hRes;
    IWmiDbHandle *pNs = NULL;
    IWmiDbSession * pSess = NULL;

    DEBUGTRACE((LOG_WBEMCORE, "****************** WinMgmt Startup ******************\n"));

    // Initialize unloading instruction configuration
    // ==============================================

    hRes = CRepository::GetDefaultSession(&pSess);
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to get new session <0x%X>!\n", hRes));
        return hRes;
    }
    CReleaseMe rm0(pSess);

    //Deal with objects in root namespace...
    {
        hRes = CRepository::OpenEseNs(pSess,L"root", &pNs);
        if (FAILED(hRes))
        {
            ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to open root namespace <0x%X>!\n", hRes));
            return hRes;
        }
        CReleaseMe rm1(pNs);

        hRes = ConfigMgr::SetIdentificationObject(pNs,pSess);
        if (FAILED(hRes))
        {
            ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to set identification objects in root <0x%X>!\n", hRes));
            return hRes;
        }
    }

    {
        hRes = CRepository::OpenEseNs(pSess, L"root\\default", &pNs);
        if (FAILED(hRes))
        {
            ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to open root\\default namespace <0x%X>!\n", hRes));
            return hRes;
        }
        CReleaseMe rm1(pNs);

        hRes = ConfigMgr::SetIdentificationObject(pNs,pSess);
        if (FAILED(hRes))
        {
            ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to set identification objects in root\\default <0x%X>!\n", hRes));
            return hRes;
        }

        hRes = ConfigMgr::SetAdapStatusObject(pNs,pSess);
        if (FAILED(hRes))
        {
            ERRORTRACE((LOG_WBEMCORE, "System preperation: failed to set ADAP Status objects in root\\default <0x%X>!\n", hRes));
            return hRes;
        }
    }

    // Finish client preparations
    // ==========================

    hRes = PrepareForClients(0);
    if(FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "System preperation: Prepare for clients failed <0x%X>!\n", hRes));
        return hRes;
    }

    return WBEM_S_NO_ERROR;
}



//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
HRESULT ConfigMgr::SetIdentificationObject(
    IWmiDbHandle* pNs,
    IWmiDbSession * pSess
    )
{
    HRESULT hRes;

    // __CIMOMIdentification class
    try // CIdentificationClass can throw and internal fastprox interfaces
    {

            bool bDifferenceFound = false;
            IWbemClassObject * pInst = NULL;
            hRes = CRepository::GetObject(pSess, pNs,
                                       L"__CIMOMIdentification=@",
                                       0,&pInst);
            if(pInst == NULL)
            {
                // Instance isnt there, create it.  Start by getting the class

                bDifferenceFound = true;
                IWbemClassObject * pClass = NULL;
                hRes = CRepository::GetObject(pSess, pNs, L"__CIMOMIdentification", 0,&pClass);
                if(pClass == NULL)
                {
                    // class also needs to be created

                    CIdentificationClass * pIdentificationClass = new CIdentificationClass;
                    if(pIdentificationClass == NULL)
                        return WBEM_E_OUT_OF_MEMORY;

                    CDeleteMe<CIdentificationClass> dm1(pIdentificationClass);
    
                    pIdentificationClass->Init(); // throw

                    IWbemClassObject *pObj = NULL;
                    hRes = pIdentificationClass->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
                    if (FAILED(hRes))
                        return hRes;
                    CReleaseMe rm3(pObj);
                    hRes = CRepository::PutObject(pSess, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
                    if(FAILED(hRes))
                        return hRes;
                    hRes = CRepository::GetObject(pSess, pNs, L"__CIMOMIdentification", 0,&pClass);
                    if(FAILED(hRes))
                        return hRes;
                }
                CReleaseMe rm0(pClass);
                hRes = pClass->SpawnInstance(0, &pInst);
                if(FAILED(hRes))
                    return hRes;
            }
            CReleaseMe rm(pInst);

            // We now have an instance.  Set the values

            CWbemObject * pObj = (CWbemObject *)pInst;

            WCHAR wTemp[MAX_PATH+1];
            BOOL bRet = ConfigMgr::GetDllVersion(__TEXT("wbemcore.dll"), __TEXT("ProductVersion"), wTemp, MAX_PATH);
            if(bRet)
            {
                HKEY hKey = 0;
                if (RegOpenKey(HKEY_LOCAL_MACHINE, __TEXT("software\\microsoft\\wbem\\cimom"), &hKey) != ERROR_SUCCESS)  // SEC:REVIEWED 2002-03-22 : OK
                    return WBEM_E_FAILED;
                CRegCloseMe cm(hKey);


                // Get the properties.  Note if any changes were found.

                hRes = PutValueIfDiff(pObj, L"VersionUsedToCreateDB", wTemp, bDifferenceFound);
                if(FAILED(hRes))
                    return hRes;

                hRes = PutValueIfDiff(pObj, L"VersionCurrentlyRunning", wTemp, bDifferenceFound);
                if(FAILED(hRes))
                    return hRes;

                DWORD lSize = 2*(MAX_PATH+1);
                DWORD dwType;

                if(ERROR_SUCCESS != RegQueryValueExW(hKey, L"SetupDate",NULL, &dwType,(BYTE *)wTemp, &lSize))   // SEC:REVIEWED 2002-03-22 : OK
                    return WBEM_E_FAILED;
                hRes = PutValueIfDiff(pObj, L"SetupDate", wTemp, bDifferenceFound);
                if(FAILED(hRes))
                    return hRes;

                lSize = 2*(MAX_PATH+1);
                if(ERROR_SUCCESS != RegQueryValueExW(hKey, L"SetupTime", NULL, &dwType, (BYTE *)wTemp, &lSize)) // SEC:REVIEWED 2002-03-22 : OK
                    return WBEM_E_FAILED;
                hRes = PutValueIfDiff(pObj, L"SetupTime", wTemp, bDifferenceFound);
                if(FAILED(hRes))
                    return hRes;

                lSize = 2*(MAX_PATH+1);
                if(ERROR_SUCCESS != RegQueryValueExW(hKey, L"Working Directory", NULL, &dwType,   // SEC:REVIEWED 2002-03-22 : OK
                                                                (BYTE *)wTemp, &lSize))
                    return WBEM_E_FAILED;
                hRes = PutValueIfDiff(pObj, L"WorkingDirectory", wTemp, bDifferenceFound);
                if(FAILED(hRes))
                    return hRes;

                if(bDifferenceFound)
                    hRes = CRepository::PutObject(pSess, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
                else
                    hRes = S_OK;

            }
        else
            return WBEM_E_FAILED;

    } catch (CX_MemoryException &) {
        //
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    catch (CX_Exception &)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    return hRes;
}


HRESULT ConfigMgr::SetAdapStatusObject(
    IWmiDbHandle*  pNs,
    IWmiDbSession* pSess
    )
{
    HRESULT hRes;

    // __AdapStatus class
    try // CAdapStatusClass can throw
    {
        // if the object already exists, dont bother

        IWbemClassObject * pInst = NULL;
        HRESULT hr = CRepository::GetObject(pSess, pNs, L"__AdapStatus=@",0,&pInst);
        if(SUCCEEDED(hr) && pInst)
        {
            pInst->Release();
            return S_OK;
        }

        CAdapStatusClass * pAdapStatusClass = new CAdapStatusClass;
        if(pAdapStatusClass == NULL)
            return WBEM_E_OUT_OF_MEMORY;
            
        CDeleteMe<CAdapStatusClass> dm1(pAdapStatusClass);
    
        pAdapStatusClass->Init(); // throw

        CAdapStatusInstance * pAdapStatusInstance = new CAdapStatusInstance;
        if(pAdapStatusInstance == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CDeleteMe<CAdapStatusInstance> dm2(pAdapStatusInstance);
        
        pAdapStatusInstance->Init(pAdapStatusClass);
        
        IWbemClassObject *pObj = NULL;
        hRes = pAdapStatusClass->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe rm1(pObj);
    
        hRes = CRepository::PutObject(pSess, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
        if (FAILED(hRes))
            return hRes;
    
        IWbemClassObject *pObj2 = NULL;
        hRes = pAdapStatusInstance->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj2);
        if (FAILED(hRes))
            return hRes;
        CReleaseMe rm2(pObj2);
    
        hRes = CRepository::PutObject(pSess, pNs, IID_IWbemClassObject, pObj2, WMIDB_DISABLE_EVENTS);
        if (FAILED(hRes))
            return hRes;
    
    } catch (CX_MemoryException &) {
        //
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    catch (CX_Exception &)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    return hRes;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

IWbemEventSubsystem_m4* ConfigMgr::GetEssSink()
{
    CInCritSec ics(&g_csEss);
    if(g_pEss_m4)
        g_pEss_m4->AddRef();
    return g_pEss_m4;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
BOOL ConfigMgr::ShutdownInProgress() { return g_bDontAllowNewConnections; }

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
IWbemContext* ConfigMgr::GetNewContext()
{
    HRESULT hres;
    if(g_pContextFac == NULL)
        return NULL;

    IWbemContext* pContext;
    hres = g_pContextFac->CreateInstance(NULL, IID_IWbemContext,
                                            (void**)&pContext);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"CRITICAL ERROR: cannot create contexts: %X\n", hres));
        return NULL;
    }
    return pContext;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

READONLY LPWSTR ConfigMgr::GetMachineName()
{
    static wchar_t ThisMachine[MAX_COMPUTERNAME_LENGTH+1];
    static BOOL bFirstCall = TRUE;

    if (bFirstCall)
    {
        wchar_t localMachine[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
        GetComputerNameW(localMachine, &dwSize);  // SEC:REVIEWED 2002-03-22 : Assumes success, need error check
        bFirstCall = FALSE;
        StringCchCopyW(ThisMachine, MAX_COMPUTERNAME_LENGTH+1, localMachine);
    }

    return ThisMachine;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

CWbemQueue* ConfigMgr::GetUnRefedSvcQueue()
{
    return g_pAsyncSvcQueue;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

CAsyncServiceQueue* ConfigMgr::GetAsyncSvcQueue()
{
    CInCritSec ics(&g_csEss);
    if (g_pAsyncSvcQueue)
    {
        g_pAsyncSvcQueue->AddRef();
        return g_pAsyncSvcQueue;
    }
    else
        return NULL;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

HRESULT ConfigMgr::EnqueueRequest(CAsyncReq * pRequest)
{
    try
    {
        CAsyncServiceQueue* pTemp = 0;

        {
            CInCritSec ics(&g_csEss);
            if(g_pAsyncSvcQueue == NULL)
                return WBEM_E_SHUTTING_DOWN;
            pTemp = g_pAsyncSvcQueue;
            g_pAsyncSvcQueue->AddRef();
        }

        HRESULT hr = pTemp->Enqueue(pRequest);
        pTemp->Release();
        return hr;
    }
    catch(CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;
    }
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

HRESULT ConfigMgr::EnqueueRequestAndWait(CAsyncReq * pRequest)
{
    try
    {
        CAsyncServiceQueue* pTemp = 0;

        {
            CInCritSec ics(&g_csEss);
            if(g_pAsyncSvcQueue == NULL)
                return WBEM_E_SHUTTING_DOWN;
            pTemp = g_pAsyncSvcQueue;
            g_pAsyncSvcQueue->AddRef();
        }

        HRESULT hr = pTemp->EnqueueAndWait(pRequest);
        pTemp->Release();
        return hr;
    }
    catch(CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;
    }
}
//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

LPTSTR ConfigMgr::GetWorkingDir()
{
    return g_pWorkDir;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************


LPTSTR ConfigMgr::GetDbDir()
{
    if (g_pDbDir == NULL)
    {
        Registry r(WBEM_REG_WINMGMT);
        if (g_pWorkDir == NULL)
        {
            if (r.GetStr(__TEXT("Working Directory"), &g_pWorkDir))
            {
                size_t tmpLength = MAX_PATH + 1 + lstrlen(__TEXT("\\WBEM"));  // SEC:REVIEWED 2002-03-22 : OK
                g_pWorkDir = new TCHAR[tmpLength];
                if (g_pWorkDir == 0)
                    return 0;
                GetSystemDirectory(g_pWorkDir, MAX_PATH + 1);   // SEC:REVIEWED 2002-03-22 : Assumes success
                StringCchCat(g_pWorkDir, tmpLength,  __TEXT("\\WBEM"));
            }
        }

        if (r.GetStr(__TEXT("Repository Directory"), &g_pDbDir))
        {
            size_t tmpLength = lstrlen(g_pWorkDir) + lstrlen(__TEXT("\\Repository")) +1;  // SEC:REVIEWED 2002-03-22 : OK
            g_pDbDir = new TCHAR [tmpLength];
            if (g_pDbDir == 0)
                return 0;
            StringCchPrintf(g_pDbDir, tmpLength, __TEXT("%s\\REPOSITORY"), g_pWorkDir);
            r.SetStr(__TEXT("Repository Directory"), g_pDbDir);
        }
    }
    return g_pDbDir;
}

DWORD ConfigMgr::GetMaxMemoryQuota()
{
    static DWORD dwMaxMemQuota = CONFIG_MAX_COMMITTED_MEMORY;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Max Committed Memory Quota"), &dwMaxMemQuota) == Registry::failed)
            r.SetDWORD(__TEXT("Max Committed Memory Quota"), dwMaxMemQuota);

        bCalled = TRUE;
    }

    return dwMaxMemQuota;
}

DWORD ConfigMgr::GetMaxWaitBeforeDenial()
{
    //static DWORD dwMaxWaitBeforeDenial = 80000;
    static DWORD dwMaxWaitBeforeDenial = 5000;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Max Wait Before Denial"), &dwMaxWaitBeforeDenial) == Registry::failed)
            r.SetDWORD(__TEXT("Max Wait Before Denial"), dwMaxWaitBeforeDenial);

        bCalled = TRUE;
    }

    return dwMaxWaitBeforeDenial;
}


DWORD ConfigMgr::GetNewTaskResistance()
{
    static DWORD dwResistance = 10;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("New Task Resistance Factor"), &dwResistance) == Registry::failed)
            r.SetDWORD(__TEXT("New Task Resistance Factor"), dwResistance);

        bCalled = TRUE;
    }

    return dwResistance;
}


DWORD ConfigMgr::GetUncheckedTaskCount()
{
    static DWORD dwUncheckedTaskCount = 50;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Unchecked Task Count"), &dwUncheckedTaskCount) == Registry::failed)
            r.SetDWORD(__TEXT("Unchecked Task Count"), dwUncheckedTaskCount);

        bCalled = TRUE;
    }

    return dwUncheckedTaskCount;
}

DWORD ConfigMgr::GetMaxTaskCount()
{
    static DWORD dwMaxTasks = 5000;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Max Tasks"), &dwMaxTasks) == Registry::failed)
            r.SetDWORD(__TEXT("Max Tasks"), dwMaxTasks);

        bCalled = TRUE;
    }

    if (dwMaxTasks < 5000)
        dwMaxTasks = 5000;

    return dwMaxTasks;
}

DWORD ConfigMgr::GetProviderDeliveryTimeout()
{
    static DWORD dwDeliveryTimeout = 600000;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Provider Delivery Timeout"), &dwDeliveryTimeout) == Registry::failed)
            r.SetDWORD(__TEXT("Provider Delivery Timeout"), dwDeliveryTimeout);

        bCalled = TRUE;
    }

    return dwDeliveryTimeout;
}

BOOL ConfigMgr::GetMergerThrottlingEnabled( void )
{
    static DWORD dwMergerThrottlingEnabled = TRUE;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        // We don't write this one out
        r.GetDWORD(__TEXT("Merger Throttling Enabled"), &dwMergerThrottlingEnabled);

        bCalled = TRUE;
    }

    return dwMergerThrottlingEnabled;

}

BOOL ConfigMgr::GetEnableQueryArbitration( void )
{
    static DWORD dwEnableQueryArbitration = TRUE;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        Registry r(WBEM_REG_WINMGMT);

        // We don't write this one out
        r.GetDWORD(__TEXT("Merger Query Arbitration Enabled"), &dwEnableQueryArbitration);

        bCalled = TRUE;
    }

    return dwEnableQueryArbitration;

}

BOOL ConfigMgr::GetMergerThresholdValues( DWORD* pdwThrottle, DWORD* pdwRelease, DWORD* pdwBatching )
{
    static DWORD dwMergerThrottleThreshold = 10;
    static DWORD dwMergerReleaseThreshold = 5;
    static DWORD dwBatchingThreshold = 131072;    // 128k
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        // Temporrary stack variable to avboid thready synchronization issues
        DWORD    dwThrottle = 10;
        DWORD    dwRelease = 5;
        DWORD    dwBatching = 131072;

        Registry r(WBEM_REG_WINMGMT);

        if (r.GetDWORD(__TEXT("Merger Throttling Threshold"), &dwThrottle) == Registry::failed)
            r.SetDWORD(__TEXT("Merger Throttling Threshold"), dwThrottle);

        if (r.GetDWORD(__TEXT("Merger Release Threshold"), &dwRelease) == Registry::failed)
            r.SetDWORD(__TEXT("Merger Release Threshold"), dwRelease);

        if (r.GetDWORD(__TEXT("Merger Batching Threshold"), &dwBatching) == Registry::failed)
            r.SetDWORD(__TEXT("Merger Batching Threshold"), dwBatching);

        if ( dwThrottle < dwRelease )
        {
            // If the Throttling Threshold is < the Release Threshold, this is not
            // valid.  Spew something out into the errorlog and default to a release
            // which is 50% of the the throttle

            ERRORTRACE((LOG_WBEMCORE, "Throttling Threshold values invalid.  Release Threshold is greater than Throttle Threshold.  Defaulting to 50% of %d.\n", dwThrottle ));
            dwRelease = dwThrottle / 2;
        }

        dwMergerThrottleThreshold = dwThrottle;
        dwMergerReleaseThreshold = dwRelease;
        dwBatchingThreshold = dwBatching;

        bCalled = TRUE;
    }

    *pdwThrottle = dwMergerThrottleThreshold;
    *pdwRelease = dwMergerReleaseThreshold;
    *pdwBatching = dwBatchingThreshold;

    return bCalled;
}



/*
    * ==================================================================================================
    |
    | ULONG ConfigMgr::GetMinimumMemoryRequirements ( )
    | -------------------------------------------------
    | Returns minimum memory requirements for WMI. Currently defined as:
    |
    | ARB_DEFAULT_SYSTEM_MINIMUM    0x1E8480    
    |
    | 2Mb
    |
    |
    * ==================================================================================================
*/


ULONG ConfigMgr::GetMinimumMemoryRequirements ( )
{
    return ARB_DEFAULT_SYSTEM_MINIMUM ;
}

BOOL ConfigMgr::GetArbitratorValues( DWORD* pdwEnabled, DWORD* pdwSystemHigh, DWORD* pdwMaxSleep,
                                double* pdHighThreshold1, long* plMultiplier1, double* pdHighThreshold2,
                                long* plMultiplier2, double* pdHighThreshold3, long* plMultiplier3 )
{

    static DWORD dwArbThrottlingEnabled = 1;
    static DWORD uArbSystemHigh = ARB_DEFAULT_SYSTEM_HIGH_FACTOR;
    static DWORD  dwArbMaxSleepTime = ARB_DEFAULT_MAX_SLEEP_TIME;
    static double dArbThreshold1 = ARB_DEFAULT_HIGH_THRESHOLD1 / (double) 100;
    static long  lArbThreshold1Mult = ARB_DEFAULT_HIGH_THRESHOLD1MULT;
    static double dArbThreshold2 = ARB_DEFAULT_HIGH_THRESHOLD2 / (double) 100;
    static long  lArbThreshold2Mult = ARB_DEFAULT_HIGH_THRESHOLD2MULT;
    static double dArbThreshold3 = ARB_DEFAULT_HIGH_THRESHOLD3 / (double) 100;
    static long  lArbThreshold3Mult = ARB_DEFAULT_HIGH_THRESHOLD3MULT;
    static BOOL bCalled = FALSE;

    if (!bCalled)
    {
        // Temporrary stack variable to avoid thread synchronization issues
        DWORD dwThrottlingEnabled = 1;
        DWORD uSystemHigh = ARB_DEFAULT_SYSTEM_HIGH_FACTOR;
        DWORD dwMaxSleepTime = ARB_DEFAULT_MAX_SLEEP_TIME;
        double dThreshold1 = ARB_DEFAULT_HIGH_THRESHOLD1 / (double) 100;
        DWORD dwThreshold1Mult = ARB_DEFAULT_HIGH_THRESHOLD1MULT;
        double dThreshold2 = ARB_DEFAULT_HIGH_THRESHOLD2 / (double) 100;
        DWORD dwThreshold2Mult = ARB_DEFAULT_HIGH_THRESHOLD2MULT;
        double dThreshold3 = ARB_DEFAULT_HIGH_THRESHOLD3 / (double) 100;
        DWORD dwThreshold3Mult = ARB_DEFAULT_HIGH_THRESHOLD3MULT;

        Registry r(WBEM_REG_WINMGMT);

        // Throttling Enabled - Don't write this if it doesn't exist
        r.GetDWORD(__TEXT("ArbThrottlingEnabled"), &dwThrottlingEnabled);

        // System High Max Limit
        if (r.GetDWORD(__TEXT("ArbSystemHighMaxLimitFactor"), &uSystemHigh) == Registry::failed)
            //r.SetDWORD(__TEXT("ArbSystemHighMaxLimitFactor"), uSystemHigh);

        // Max Sleep Time
        if (r.GetDWORD(__TEXT("ArbTaskMaxSleep"), &dwMaxSleepTime) == Registry::failed)
            r.SetDWORD(__TEXT("ArbTaskMaxSleep"), dwMaxSleepTime);

        // High Threshold 1
        DWORD    dwTmp = ARB_DEFAULT_HIGH_THRESHOLD1;

        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold1"), &dwTmp) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold1"), dwTmp);
        dThreshold1 = dwTmp / (double) 100;

        // High Threshold Multiplier 1
        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold1Mult"), &dwThreshold1Mult) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold1Mult"), dwThreshold1Mult);

        // High Threshold 2
        dwTmp = ARB_DEFAULT_HIGH_THRESHOLD2;

        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold2"), &dwTmp) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold2"), dwTmp);
        dThreshold2 = dwTmp / (double) 100;

        // High Threshold Multiplier 2
        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold2Mult"), &dwThreshold2Mult) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold2Mult"), dwThreshold2Mult);

        // High Threshold 3
        dwTmp = ARB_DEFAULT_HIGH_THRESHOLD3;

        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold3"), &dwTmp) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold3"), dwTmp);
        dThreshold3 = dwTmp / (double) 100;

        // High Threshold Multiplier 3
        if (r.GetDWORD(__TEXT("ArbSystemHighThreshold3Mult"), &dwThreshold3Mult) == Registry::failed)
            r.SetDWORD(__TEXT("ArbSystemHighThreshold3Mult"), dwThreshold3Mult);

        // Store the statics

        dwArbThrottlingEnabled = dwThrottlingEnabled;
        uArbSystemHigh = uSystemHigh;
        dwArbMaxSleepTime = dwMaxSleepTime;
        dArbThreshold1 = dThreshold1;
        lArbThreshold1Mult = dwThreshold1Mult;
        dArbThreshold2 = dThreshold2;
        lArbThreshold2Mult = dwThreshold2Mult;
        dArbThreshold3 = dThreshold3;
        lArbThreshold3Mult = dwThreshold3Mult;

        bCalled = TRUE;

    }

    *pdwEnabled = dwArbThrottlingEnabled;
    *pdwSystemHigh = uArbSystemHigh;
    *pdwMaxSleep = dwArbMaxSleepTime;
    *pdHighThreshold1 = dArbThreshold1;
    *plMultiplier1 = lArbThreshold1Mult;
    *pdHighThreshold2 = dArbThreshold2;
    *plMultiplier2 = lArbThreshold2Mult;
    *pdHighThreshold3 = dArbThreshold3;
    *plMultiplier3 = lArbThreshold3Mult;


    return bCalled;
}

BOOL ConfigMgr::GetEnableArbitratorDiagnosticThread( void )
{
    BOOL fArbDiagnosticThreadEnabled = FALSE;

    Registry r(WBEM_REG_WINMGMT);
    LPTSTR pPath = 0;
    if ( r.GetStr(__TEXT("Task Log File"), &pPath) == Registry::no_error )
    {
        fArbDiagnosticThreadEnabled = TRUE;
        delete [] pPath;
        pPath = NULL;
    }

    return fArbDiagnosticThreadEnabled;
}

//******************************************************************************
//
//******************************************************************************
//
HRESULT ConfigMgr::GetDefaultRepDriverClsId(CLSID &clsid)
{
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pClsIdStr = 0;
    TCHAR *pJetClsId = __TEXT("{7998dc37-d3fe-487c-a60a-7701fcc70cc6}");
    HRESULT hRes;

    if (r.GetStr(__TEXT("Default Repository Driver"), &pClsIdStr))
    {
        // If here, default to Jet ESE for now.
        // =====================================
        r.SetStr(__TEXT("Default Repository Driver"), pJetClsId);
        hRes = CLSIDFromString(pJetClsId, &clsid);
        return hRes;
    }

    // If here, we actually retrieved one.
    // ===================================

    hRes = CLSIDFromString(pClsIdStr, &clsid);
    delete [] pClsIdStr;
    return hRes;
}



//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
DWORD ConfigMgr::InitSystem()
{
    HRESULT hres;
    DEBUGTRACE((LOG_WBEMCORE, "+ ConfigMgr::InitSystem()\n"));

    GetSystemLimits();

    g_hresForClients = WBEM_E_CRITICAL_ERROR;

    g_pEventLog = new CEventLog;
    if (g_pEventLog == 0)
        return WBEM_E_OUT_OF_MEMORY;
    g_pEventLog->Open();

    g_hOpenForClients = CreateEvent(NULL, TRUE, FALSE, NULL);  
    if (NULL == g_hOpenForClients) return WBEM_E_OUT_OF_MEMORY;
        
    // Init Arbitrator. Before the queue, since there is this dependecy now
    // ================
    _IWmiArbitrator * pTempArb = NULL;
    hres = CWmiArbitrator::Initialize(&pTempArb);
    CReleaseMe rmArb(pTempArb);
    if (FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE, "Arbitrator initialization returned failure <0x%X>!\n", hres));
        return hres;
    }

    // Create service queue objects
    // ============================
    g_pAsyncSvcQueue = new CAsyncServiceQueue(pTempArb);

    if (g_pAsyncSvcQueue == NULL   ||
        !g_pAsyncSvcQueue->IsInit())
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hres = CoGetClassObject(CLSID_WbemContext, CLSCTX_INPROC_SERVER,  // SEC:REVIEWED 2002-03-22 : OK
                NULL, IID_IClassFactory, (void**)&g_pContextFac);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"CRITICAL ERROR: cannot create contexts: %X\n", hres));
        return WBEM_E_CRITICAL_ERROR;
    }

    hres = CoGetClassObject(CLSID_WbemDefPath, CLSCTX_INPROC_SERVER,  // SEC:REVIEWED 2002-03-22 : OK
                NULL, IID_IClassFactory, (void**)&g_pPathFac);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"CRITICAL ERROR: cannot create paths: %X\n", hres));
        return WBEM_E_CRITICAL_ERROR;
    }

    hres = CoGetClassObject(CLSID_WbemQuery, CLSCTX_INPROC_SERVER, 
    	        NULL,IID_IClassFactory, (void **) &g_pQueryFact);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"CRITICAL ERROR: cannot create Query Parser: %X\n", hres));
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Must lock it to keep fastprox in memory!
    //

    g_pContextFac->LockServer(TRUE);
    g_pPathFac->LockServer(TRUE);
    g_pQueryFact->LockServer(TRUE);

    // Read registry and get system info.
    // ==================================

    DEBUGTRACE((LOG_WBEMCORE,"Reading config info from registry\n"));

    Registry r(WBEM_REG_WINMGMT);
    if (r.GetStr(__TEXT("Working Directory"), &g_pWorkDir))
    {
        size_t tmpLength = MAX_PATH + 1 + lstrlen(__TEXT("\\WBEM"));  // SEC:REVIEWED 2002-03-22 : OK
        g_pWorkDir = new TCHAR[tmpLength];
        if (NULL == g_pWorkDir)
            return WBEM_E_OUT_OF_MEMORY;
        GetSystemDirectory(g_pWorkDir, MAX_PATH + 1);   // SEC:REVIEWED 2002-03-22 : Needs check for success
        StringCchCat(g_pWorkDir, tmpLength, __TEXT("\\WBEM"));
    }

    if (r.GetStr(__TEXT("Repository Directory"), &g_pDbDir))
    {
        size_t tmpLength = lstrlen(g_pWorkDir) + lstrlen(__TEXT("\\Repository")) +1;  // SEC:REVIEWED 2002-03-22 : OK
        g_pDbDir = new TCHAR [tmpLength];
        if (NULL == g_pDbDir)
            return WBEM_E_OUT_OF_MEMORY;
        StringCchPrintf(g_pDbDir, tmpLength, __TEXT("%s\\Repository"), g_pWorkDir);

        r.SetStr(__TEXT("Repository Directory"), g_pDbDir);
    }

    // Write build info to the registry.
    // =================================
    TCHAR tchDateTime[30];
    StringCchPrintf(tchDateTime, 30, __TEXT("%S %S"), __DATE__, __TIME__);

    TCHAR * pCurrVal = NULL;
    int iRet = r.GetStr(__TEXT("Build"), &pCurrVal);
    if(iRet == Registry::failed || wbem_wcsicmp(pCurrVal, tchDateTime))
        r.SetStr(__TEXT("Build"),  tchDateTime );
    if(iRet == Registry::no_error)
        delete pCurrVal;

    // The Database directory: same permission as the repository
    DEBUGTRACE((LOG_WBEMCORE,"Database location = <%S>\n", g_pDbDir));

    TCHAR * pString = __TEXT("D:P(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)");
    HRESULT hRes = TestDirExistAndCreateWithSDIfNotThere(g_pDbDir, pString);
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE,"TestDirExistAndCreateWithSDIfNotThere %S hr %08x\n",g_pDbDir,hRes));
        return hRes;
    }

    // The Loggingdirectory: same permission as the repository
    TCHAR * pLogDir = NULL;
    if (r.GetStr(__TEXT("Logging Directory"), &pLogDir))
    {
        size_t tmpLength = MAX_PATH + 1 + lstrlen(__TEXT("\\wbem\\Logs"));  // SEC:REVIEWED 2002-03-22 : OK
        pLogDir = new TCHAR[tmpLength];
        if (NULL == pLogDir)
            return WBEM_E_OUT_OF_MEMORY;
        GetSystemDirectory(pLogDir, MAX_PATH + 1);  // SEC:REVIEWED 2002-03-22 : Needs check on return code
        StringCchCat(pLogDir, tmpLength, __TEXT("\\wbem\\Logs"));
    }
    wmilib::auto_buffer<TCHAR> dm(pLogDir);
    // remove trailing BackSlash
    DWORD dwLast = lstrlen(pLogDir);    // SEC:REVIEWED 2002-03-22 : OK or we wouldn't be here

    if (dwLast > 3 && pLogDir[dwLast-1] == __TEXT('\\')) pLogDir[dwLast-1] = 0;

    pString = __TEXT("D:P(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)(A;CIOI;GRGW;;;NS)(A;CIOI;GRGW;;;LS)");
    hRes = TestDirExistAndCreateWithSDIfNotThere(pLogDir, pString);
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE,"TestDirExistAndCreateWithSDIfNotThere %S hr %08x\n",pLogDir,hRes));
        return hRes;
    }

    // The Autorecover directory: same permission as the repository
    DWORD dwLen = lstrlen(g_pWorkDir);   // SEC:REVIEWED 2002-03-22 : OK, or we wouldn't be here
    size_t tmpLength = dwLen + 1 + lstrlen(__TEXT("\\AutoRecover"));   // SEC:REVIEWED 2002-03-22 : OK
    g_pAutorecoverDir = new TCHAR[tmpLength];
    if (NULL == g_pAutorecoverDir) return WBEM_E_OUT_OF_MEMORY;
    StringCchCopy(g_pAutorecoverDir,tmpLength, g_pWorkDir);
    StringCchCat(g_pAutorecoverDir,tmpLength,  __TEXT("\\AutoRecover"));           // SEC:REVIEWED 2002-03-22 : OK

    pString =__TEXT("D:P(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)");
    hRes = TestDirExistAndCreateWithSDIfNotThere(g_pAutorecoverDir, pString);
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE,"TestDirExistAndCreateWithSDIfNotThere %S hr %08x\n",g_pAutorecoverDir,hRes));
        return hRes;
    }

    // The HotMof same permission as the autorecover
    TCHAR * pMofDir = NULL;
    if (r.GetStr(__TEXT("MOF Self-Install Directory"), &pMofDir))
    {
        size_t tmpLength = MAX_PATH + 1 + lstrlen(__TEXT("\\wbem\\mof")); // SEC:REVIEWED 2002-03-22 : OK
        pMofDir = new TCHAR[tmpLength];
        if (NULL == pMofDir)
            return WBEM_E_OUT_OF_MEMORY;
        GetSystemDirectory(pMofDir, MAX_PATH + 1);   // SEC:REVIEWED 2002-03-22 : No check
        StringCchCat(pMofDir, tmpLength, __TEXT("\\wbem\\mof"));
    }
    wmilib::auto_buffer<TCHAR> dm1(pMofDir);

    pString =__TEXT("D:P(A;CIOI;GA;;;BA)(A;CIOI;GA;;;SY)");
    hRes = TestDirExistAndCreateWithSDIfNotThere(pMofDir, pString);
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE,"TestDirExistAndCreateWithSDIfNotThere %S hr %08x\n",pMofDir,hRes));
        return hRes;
    }
       
    // Open/create the database.
    // =========================

    hRes = InitSubsystems();
    if (FAILED(hRes)) return hRes;

    // Done.
    // =====
    DEBUGTRACE((LOG_WBEMCORE, "- ConfigMgr::InitSystem()\n"));
    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
DWORD ConfigMgr::Shutdown(BOOL bProcessShutdown, BOOL bIsSystemShutDown)
{
    g_bDontAllowNewConnections = TRUE;

    ShutdownSubsystems(bIsSystemShutDown);

    if (!bIsSystemShutDown)
    {
        DEBUGTRACE((LOG_WBEMCORE, "+ ConfigMgr::Shutdown(%d,%d)\n",bProcessShutdown,bIsSystemShutDown));

        if(g_pAsyncSvcQueue)
        {
            CInCritSec ics(&g_csEss);
            g_pAsyncSvcQueue->Shutdown(bIsSystemShutDown);
            g_pAsyncSvcQueue->Release();
            g_pAsyncSvcQueue = NULL;
        }

        if (g_pContextFac)
        {
            //
            // Must unlock it to allow fastprox to go away
            //

            g_pContextFac->LockServer(FALSE);
            g_pContextFac->Release();
            g_pContextFac = NULL;
        }
        if (g_pPathFac)
        {
            // Must unlock it to allow wmiutils to go away
            g_pPathFac->LockServer(FALSE);
            g_pPathFac->Release();
            g_pPathFac = NULL;
        }
        if (g_pQueryFact)
        {
            // Must unlock it to allow wmiutils to go away        
            g_pQueryFact->LockServer(FALSE);
            g_pQueryFact->Release();
            g_pQueryFact = NULL;
        }

        if (g_pEventLog)
        {
            g_pEventLog->Close();
            delete g_pEventLog;
            g_pEventLog = NULL;
        }

        delete [] g_pDbDir;
        g_pDbDir = NULL;

        delete [] g_pWorkDir;
        g_pWorkDir = NULL;

        delete [] g_pAutorecoverDir;
        g_pAutorecoverDir = NULL;

        if (g_hOpenForClients)
        {
            CloseHandle(g_hOpenForClients);
            g_hOpenForClients = NULL;
        }

           DEBUGTRACE((LOG_WBEMCORE, "- ConfigMgr::Shutdown\n"));
    }

    return WBEM_NO_ERROR;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************
BOOL ConfigMgr::GetDllVersion(TCHAR * pDLLName, TCHAR * pResStringName,
                        WCHAR * pRes, DWORD dwResSize)
{
    // Extract Version informatio

    DWORD dwTemp, dwSize = MAX_PATH;
    TCHAR cName[MAX_PATH];
    BOOL bRet = FALSE;

    // rajeshr : Fix for Prefix Bug# 144470
    cName[0] = NULL;

    int iLen = 0;
    if(g_pWorkDir)
        iLen = wcslen(g_pWorkDir);   // SEC:REVIEWED 2002-03-22 : OK, provably has null terminator
    iLen += wcslen(pDLLName) + 2;    // SEC:REVIEWED 2002-03-22 : OK, provably a compiled const string
    if(iLen > MAX_PATH)
        return FALSE;


    if(g_pWorkDir)
        StringCchCopy(cName, MAX_PATH, g_pWorkDir);
    StringCchCat(cName,MAX_PATH, __TEXT("\\"));
    StringCchCat(cName, MAX_PATH, pDLLName);
    long lSize = GetFileVersionInfoSize(cName, &dwTemp);
    if(lSize < 1)
        return FALSE;

    TCHAR * pBlock = new TCHAR[lSize];
    if(pBlock != NULL)
    {
        CDeleteMe<TCHAR> dm(pBlock);
        try
        {
            bRet = GetFileVersionInfo(cName, NULL, lSize, pBlock);
            if(bRet)
            {
                TCHAR lpSubBlock[MAX_PATH];
                TCHAR * lpBuffer = NULL;
                UINT wBuffSize = MAX_PATH;
                short * piStuff;
                bRet = VerQueryValue(pBlock, __TEXT("\\VarFileInfo\\Translation") , (void**)&piStuff, &wBuffSize);
                if(bRet)
                {
                    StringCchPrintf(lpSubBlock,MAX_PATH, __TEXT("\\StringFileInfo\\%04x%04x\\%s"),piStuff[0], piStuff[1],__TEXT("ProductVersion"));
                    bRet = VerQueryValue(pBlock, lpSubBlock, (void**)&lpBuffer, &wBuffSize);
                }
                if(bRet == FALSE)
                {
                    // Try again in english
                    StringCchPrintf(lpSubBlock, MAX_PATH, __TEXT("\\StringFileInfo\\040904E4\\%s"),pResStringName);
                    bRet = VerQueryValue(pBlock, lpSubBlock,(void**)&lpBuffer, &wBuffSize);
                }
                if(bRet)
                    StringCchCopy(pRes, dwResSize, lpBuffer);
            }
        }
        catch(...)
        {
            ExceptionCounter c;        
            return FALSE;
        }
    }
    return bRet;
}

//******************************************************************************
//
//  See cfgmgr.h for documentation
//
//******************************************************************************

CEventLog* ConfigMgr::GetEventLog()
{
    return g_pEventLog;
}


//***************************************************************************
//
//  GetPersistentCfgValue
//
//  Gets an item from persistent storage ($WINMGMT.cfg)
//
//***************************************************************************
BOOL ConfigMgr::GetPersistentCfgValue(DWORD dwOffset, DWORD &dwValue)
{
    return g_persistConfig.GetPersistentCfgValue(dwOffset, dwValue);
}

//***************************************************************************
//
//  GetPersistentCfgValue
//
//  Sets an item from persistent storage ($WinMgmt.cfg)
//
//***************************************************************************
BOOL ConfigMgr::SetPersistentCfgValue(DWORD dwOffset, DWORD dwValue)
{
    return g_persistConfig.SetPersistentCfgValue(dwOffset, dwValue);
}


//***************************************************************************
//
//  GetAutoRecoverMofsCleanDB
//
//  Retrieve a list of MOFs which need to be loaded when we have
//  have an empty database.  User needs to "delete []" the
//  returned string.  String is in a REG_MULTI_SZ format.
//
//***************************************************************************
TCHAR* ConfigMgr::GetAutoRecoverMofs(DWORD &dwSize)
{
    Registry r(WBEM_REG_WINMGMT);
    return r.GetMultiStr(__TEXT("Autorecover MOFs"), dwSize);
}

BOOL ConfigMgr::GetAutoRecoverDateTimeStamp(LARGE_INTEGER &liDateTimeStamp)
{
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pszTimestamp = NULL;
    if ((r.GetStr(__TEXT("Autorecover MOFs timestamp"), &pszTimestamp) == Registry::no_error) &&
        pszTimestamp)
    {
        liDateTimeStamp.QuadPart = _wtoi64(pszTimestamp);
        delete [] pszTimestamp;
        return TRUE;
    }
    return FALSE;
}

//***************************************************************************
//
//  PrepareForClients
//
//  Once the system is in the initialized state (SetReady has succeeded), this
//  function is called to prepare the system for real clients. This involves
//  pre-compiling the MOFs, etc.
//
//***************************************************************************
HRESULT ConfigMgr::PrepareForClients(long lFlags)
{
    ReadMaxQueueSize();
    g_hresForClients = WBEM_S_NO_ERROR;
    SetEvent(g_hOpenForClients);
    return g_hresForClients;
}

HRESULT ConfigMgr::WaitUntilClientReady()
{
    WaitForSingleObject(g_hOpenForClients, INFINITE);
    return g_hresForClients;
}

void ConfigMgr::ReadMaxQueueSize()
{
    Registry r(WBEM_REG_WINMGMT);
    // Get the database backup intervals (in minutes)
    if (r.GetDWORDStr(__TEXT("Max Async Result Queue Size"), &g_dwQueueSize) == Registry::failed)
    {
        r.SetDWORDStr(__TEXT("Max Async Result Queue Size"), CONFIG_DEFAULT_QUEUE_SIZE);
        g_dwQueueSize = CONFIG_DEFAULT_QUEUE_SIZE;
    }
}

DWORD ConfigMgr::GetMaxQueueSize()
{
    return g_dwQueueSize;
}

//
//
//////////////////////////////////////////////////////////////////////////////////

IWbemPath *ConfigMgr::GetNewPath()
{
    HRESULT hres;
    if(g_pPathFac == NULL)
        return NULL;

    IWbemPath* pPath = NULL;
    hres = g_pPathFac->CreateInstance(NULL, IID_IWbemPath, (void**)&pPath);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_WBEMCORE,"CRITICAL ERROR: cannot create paths: %X\n", hres));
        return NULL;
    }
    return pPath;
}

//
//
//////////////////////////////////////////////////////////////////////////////////

void ConfigMgr::GetSystemLimits()
{
    LONG lRes;
    HKEY hKey;
    lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,WBEM_REG_WINMGMT,0,KEY_READ,&hKey);
    if (ERROR_SUCCESS != lRes) return;
    CRegCloseMe cm(hKey);

    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwVal;
    if (ERROR_SUCCESS == RegQueryValueExW(hKey,MAX_IDENTIFIER_WBEM,0,&dwType,(BYTE*)&dwVal,&dwSize))
    {
        if (REG_DWORD == dwType) 
        {
            if (dwVal < MINIMUM_MAX_IDENTIFIER)
                g_IdentifierLimit = MINIMUM_MAX_IDENTIFIER;
            else                
                g_IdentifierLimit = dwVal;
        }
    }
    dwSize = sizeof(DWORD);
    if (ERROR_SUCCESS == RegQueryValueExW(hKey,MAX_QUERY_WBEM,0,&dwType,(BYTE*)&dwVal,&dwSize))
    {
        if (REG_DWORD == dwType) 
        {
            if (dwVal < MINIMUM_MAX_QUERY)
                g_QueryLimit = MINIMUM_MAX_QUERY;
            else
                g_QueryLimit = dwVal;
        }
    }
    dwSize = sizeof(DWORD);
    if (ERROR_SUCCESS == RegQueryValueExW(hKey,MAX_PATH_WBEM,0,&dwType,(BYTE*)&dwVal,&dwSize))
    {
        if (REG_DWORD == dwType) 
        {
            if (dwVal < g_IdentifierLimit+CLASSNAME_ADJUSTMENT)
                g_PathLimit = g_IdentifierLimit+CLASSNAME_ADJUSTMENT;
            else
                g_PathLimit = dwVal;
        }
    }
};


void ConfigMgr::SetDefaultMofLoadingNeeded()
{
    g_bDefaultMofLoadingNeeded = true;
}

//
//
// the Implementation of the Hook Class
//
/////////////////////////////////////////////////

CRAHooks::CRAHooks(_IWmiCoreServices *pSvc)
    :m_pSvc(pSvc),
    m_cRef(1)
{
    if (m_pSvc)
        m_pSvc->AddRef();
}

CRAHooks::~CRAHooks()
{
    if (m_pSvc)
        m_pSvc->Release();
}

STDMETHODIMP
CRAHooks::QueryInterface(REFIID riid, void ** ppv)
{
    if (!ppv)
        return E_POINTER;

    if (riid == IID_IUnknown ||
        riid == IID__IWmiCoreWriteHook)
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
};

ULONG STDMETHODCALLTYPE
CRAHooks::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG STDMETHODCALLTYPE
CRAHooks::Release()
{
    LONG lRet = InterlockedDecrement(&m_cRef);
    if (0 == lRet)
    {
        delete this;
        return 0;
    }
    return lRet;
}


STDMETHODIMP
CRAHooks::PostPut(long lFlags, HRESULT hApiResult,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass, _IWmiObject* pNew,
                            _IWmiObject* pOld)
{
    //
    // Here we want to do something
    //
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (SUCCEEDED(hApiResult))
    {
        if (0 == wbem_wcsicmp(GUARDED_NAMESPACE,wszNamespace))
        {
            BOOL bIsInDerivation = FALSE;

            if (WBEM_S_NO_ERROR == pNew->InheritsFrom(GUARDED_CLASS))
            {
                bIsInDerivation = TRUE;
            }

            //
            //  check qualifiers
            //
            if (bIsInDerivation)
            {
                HRESULT hRes1;
                IWbemQualifierSet * pQualSet = NULL;
                hRes1 = pNew->GetQualifierSet(&pQualSet);
                if (SUCCEEDED(hRes1))
                {
                    VARIANT Var;
                    VariantInit(&Var);
                    hRes1 = pQualSet->Get(GUARDED_HIPERF,0,&Var,NULL);
                    if (WBEM_S_NO_ERROR == hRes1 &&
                        (V_VT(&Var) == VT_BOOL) &&
                        (V_BOOL(&Var) == VARIANT_TRUE))
                    {
                        // variant does not own memory so far
                        hRes1 = pQualSet->Get(GUARDED_PERFCTR,0,&Var,NULL);
                        if (WBEM_E_NOT_FOUND == hRes1)
                        {
                            //
                            // here is our class that has been added
                            //
                            HMODULE hWmiSvc = GetModuleHandleW(WMISVC_DLL);
                            if (hWmiSvc)
                            {
                                DWORD (__stdcall * fnDredgeRA)(VOID * pVoid);
                                fnDredgeRA = (DWORD (__stdcall * )(VOID * pVoid))GetProcAddress(hWmiSvc,FUNCTION_DREDGERA);
                                if (fnDredgeRA)
                                {
                                    fnDredgeRA(NULL);
                                }
                            }
                            else
                            {
                                // be nice towards winmgmt.exe and do not propagate errors
                            }
                        }
                    }
                    VariantClear(&Var);
                    pQualSet->Release();
                }
                else
                {
                    hRes = hRes1;  // class with no qualifier set is BAD, propagate
                }
            }
        }
    }

    return hRes;
}

STDMETHODIMP
CRAHooks::PreDelete(long lFlags, long lUserFlags,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass)
{
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP
CRAHooks::PostDelete(long lFlags,
                            HRESULT hApiResult,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass, _IWmiObject* pOld)
{
    return WBEM_S_NO_ERROR;
}


STDMETHODIMP
CRAHooks::PrePut(long lFlags, long lUserFlags,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass, _IWmiObject* pCopy)
{
    return WBEM_S_NO_ERROR;
}

//
//
//   function for instaling the Hook
//
///////////////////////////////////////////////////////////

HRESULT InitRAHooks(_IWmiCoreServices *pSvc)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (!g_pRAHook)
    {
        g_pRAHook = new CRAHooks(pSvc); // refcount is ONE
        if (NULL == g_pRAHook) return WBEM_E_OUT_OF_MEMORY;

        hRes = pSvc->RegisterWriteHook(WBEM_FLAG_CLASS_PUT,g_pRAHook);
    }

    return hRes;
}


//
//
//
//
///////////////////////////////////////////////////////////

HRESULT ShutdownRAHooks()
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (g_pRAHook)
    {
        _IWmiCoreServices *pSvc = ((CRAHooks *)g_pRAHook)->GetSvc();
        if (pSvc)
        {
            hRes = pSvc->UnregisterWriteHook(g_pRAHook);
        }
        g_pRAHook->Release();
        g_pRAHook = NULL;
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************

HRESULT InitESS(_IWmiCoreServices *pSvc, BOOL bAutoRecoverd)
{
    HRESULT hRes;

    // Check if event subsystem is enabled
    // ===================================

    Registry r(WBEM_REG_WINMGMT);

    DWORD dwEnabled = 1;
    r.GetDWORDStr(__TEXT("EnableEvents"), &dwEnabled);
    if (dwEnabled != 1 || IsNtSetupRunning())
        return WBEM_S_NO_ERROR;

    // If here, we have to bring events into the picture.
    // ===================================================

    hRes = CoCreateInstance(CLSID_WmiESS, NULL,  // SEC:REVIEWED 2002-03-22 : OK
                        CLSCTX_INPROC_SERVER, IID__IWmiESS,
                        (void**) &g_pESS);

    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "Unable to load Event Subsystem: 0x%X\n", hRes));
        return hRes;
    };

    DWORD dwEssNeedsInitialStart = 0;
    g_persistConfig.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_TO_BE_INITIALIZED,dwEssNeedsInitialStart);

    if(bAutoRecoverd || dwEssNeedsInitialStart)
        hRes = g_pESS->Initialize(WMIESS_INIT_REPOSITORY_RECOVERED, 0, pSvc);
    else
        hRes = g_pESS->Initialize(0, 0, pSvc);
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "Unable to Initialize Event Subsystem: 0x%X\n", hRes));
        return hRes;
    }

    hRes = g_pESS->QueryInterface(IID_IWbemEventSubsystem_m4, (LPVOID *) &g_pEss_m4);
        if (FAILED(hRes))
            return hRes;

    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "Unable to QI for IID_IWbemEventSubsystem_m4: 0x%X\n", hRes));
        return hRes;
    }

    CCoreServices::SetEssPointers(g_pEss_m4, g_pESS);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
static HRESULT ShutdownRepository(BOOL bIsSystemShutdown)
{
    HRESULT hRes = CRepository::Shutdown(bIsSystemShutdown);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
static HRESULT ShutdownESS(BOOL bIsSystemShutDown)
{
    HRESULT hRes;

    if (g_pESS)
    {
        IWbemShutdown *pShutdown = 0;
        hRes = g_pESS->QueryInterface(IID_IWbemShutdown, (LPVOID *) & pShutdown);
        if (FAILED(hRes))
            return hRes;

        if (bIsSystemShutDown)
        {
            hRes = pShutdown->Shutdown(0, 0, 0);
        }
        else
        {
            hRes = pShutdown->Shutdown(0, DEFAULT_SHUTDOWN_TIMEOUT, 0);
        }
        if (FAILED(hRes))
            return hRes;

        if (g_pEss_m4)
            g_pEss_m4->Release();

        pShutdown->Release();
        g_pESS->Release();
        g_pESS = NULL;
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT InitProvSS(CCoreServices *pSvc)
{
    HRESULT hRes = pSvc->GetProviderSubsystem(0, &g_pProvSS);
    if (FAILED(hRes))
        return hRes;
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT ShutdownProvSS()
{
    HRESULT hRes;

    if (g_pProvSS)
    {
        IWbemShutdown *pShutdown = 0;

        hRes = g_pProvSS->QueryInterface(IID_IWbemShutdown, (LPVOID *) & pShutdown);

        if (FAILED(hRes))
            return hRes;

        hRes = pShutdown->Shutdown(0, DEFAULT_SHUTDOWN_TIMEOUT, 0);
        if (FAILED(hRes))
            return hRes;

        pShutdown->Release();
        g_pProvSS->Release();
        g_pProvSS = NULL;
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//
static HRESULT InitRepository(CCoreServices *pSvc)
{
    HRESULT hRes = CRepository::Init();
    return hRes;
}


//***************************************************************************
//
//***************************************************************************
static HRESULT InitCore(CCoreServices *pSvc)
{
    return WBEM_S_NO_ERROR;
}

static HRESULT ShutdownCore()
{
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  This determines if a previous autorecovery attempt was aborted
//
//***************************************************************************

bool AutoRecoveryWasInterrupted()
{
    DWORD dwValue;
    Registry r(WBEM_REG_WINMGMT);
    if (Registry::no_error == r.GetDWORD(__TEXT("NextAutoRecoverFile"), &dwValue))
        if(dwValue != 0xffffffff)
            return true;
    return false;
}

//***************************************************************************
//
//  Subsystem control
//
//***************************************************************************

HRESULT InitSubsystems()
{
    HRESULT hRes;
    BOOL bAutoRecovered = FALSE;

    CCoreServices::Initialize();

    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (pSvc == 0)
        return WBEM_E_OUT_OF_MEMORY;

    CReleaseMe _rm(pSvc);

    pSvc->StopEventDelivery();

    // Core startup.
    // =============

    hRes = InitCore(pSvc);
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "Core Initialization returned failure <0x%X>!\n", hRes));
        return hRes;
    }

    // Init repository.
    // ================

    hRes = InitRepository(pSvc);
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "Repository Initialization returned failure <0x%X>!\n", hRes));
        return hRes;
    }

    pSvc->StartEventDelivery();

    // This will load the default mofs if auto recover is needed

    if (g_bDefaultMofLoadingNeeded || AutoRecoveryWasInterrupted())
    {
        HRESULT hrInner = ConfigMgr::LoadDefaultMofs();    // resets g_bDefaultMofLoadingNeeded
        if (FAILED(hrInner))
        {
            ERRORTRACE((LOG_WBEMCORE,"LoadDefaultMofs hr = %08x\n",hrInner));
        }
        bAutoRecovered = TRUE;
    }

    // Init Provider Subsystem.
    // ========================

    hRes = InitProvSS(pSvc);
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "Provider Subsystem initialization returned failure <0x%X>!\n", hRes));
        return hRes;
    }

    // Init ESS.
    // =========

    hRes = InitESS(pSvc, bAutoRecovered);
    if (FAILED(hRes))
    {
        ERRORTRACE((LOG_WBEMCORE, "Event Subsystem initialization returned failure <0x%X>!\n", hRes));
        return hRes;
    }

    // Init ReverseAdapters Hooks
    // =========
    hRes = InitRAHooks(pSvc);
    if (FAILED(hRes))
        return hRes;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT ShutdownSubsystems(BOOL bIsSystemShutdown)
{
    HRESULT hRes1, hRes2, hRes3, hRes4, hRes5, hRes6, hRes7 ;

    if (!bIsSystemShutdown)
    {
        // ShutDown ReverseAdapters Hooks
        // =========

        hRes7 = ShutdownRAHooks();

        // Kill ESS.
        // =========

        hRes1 = ShutdownESS(bIsSystemShutdown);

        // Kill Provider Subsystem.
        // ========================

        hRes2 = ShutdownProvSS();


        // Arbitrator
        // ==========

        hRes3 = CWmiArbitrator::Shutdown(bIsSystemShutdown);    

    }

    // Repository.
    // ===========

    hRes4 = ShutdownRepository(bIsSystemShutdown);

    if (!bIsSystemShutdown)
    {
        // Core startup.
        // =============

        hRes5 = ShutdownCore();


        hRes6 = CCoreServices::UnInitialize();
    }

    return WBEM_S_NO_ERROR;
}



//
//
////////////////////////////////////////////////

VOID inline Hex2Char(BYTE Byte,TCHAR * &pOut)
{
    BYTE HiNibble = (Byte&0xF0) >> 4;
    BYTE LoNibble = Byte & 0xF;

    *pOut = (HiNibble<10)?(__TEXT('0')+HiNibble):(__TEXT('A')+HiNibble-10);
    pOut++;
    *pOut = (LoNibble<10)?(__TEXT('0')+LoNibble):(__TEXT('A')+LoNibble-10);
    pOut++;
}

// returns "string" representation of a buffer as a HEX number

VOID Buffer2String(BYTE * pStart,DWORD dwSize,TCHAR * pOut)
{
    for (DWORD i=0;i<dwSize;i++) Hex2Char(pStart[i],pOut);
}

//
// given the pathname d:\folder1\folder2\foo.mof
// it returns
// ppHash        = MD5 Hash of the UPPERCASE UNICODE Path + '.mof'
// call delete [] on return vclues
//
//////////////////////////////////////////////

DWORD ComposeName(WCHAR * pFullLongName, WCHAR **ppHash)
{
    if (NULL == ppHash ) return ERROR_INVALID_PARAMETER;

    DWORD dwLen = wcslen(pFullLongName);    // SEC:REVIEWED 2002-03-22 : Needs NULL check and EH

    WCHAR * pConvert = pFullLongName;
    for (DWORD i=0;i<dwLen;i++) pConvert[i] = wbem_towupper(pConvert[i]);

    wmilib::auto_buffer<WCHAR> pHash(new WCHAR[32 + 4 + 1]);
    if (NULL == pHash.get()) return ERROR_OUTOFMEMORY;

    MD5    md5;
    BYTE aSignature[16];
    md5.Transform( pFullLongName, dwLen * sizeof(WCHAR), aSignature );
    Buffer2String(aSignature,16,pHash.get());

    StringCchCopy(&pHash[32],5 ,__TEXT(".mof"));

    *ppHash = pHash.release();
    return ERROR_SUCCESS;
}


class AutoRevert
{
private:
    HANDLE oldToken_;
    BOOL SetThrTokResult_;
    bool self_;
public:
    AutoRevert();
    ~AutoRevert();
    void dismiss();
    bool self(){ return self_;}
};


AutoRevert::AutoRevert():oldToken_(NULL),self_(true),SetThrTokResult_(FALSE)
{
    if (OpenThreadToken(GetCurrentThread(),TOKEN_IMPERSONATE,TRUE,&oldToken_))
    {
        RevertToSelf();
    }
    else
    {
        if (GetLastError() != ERROR_NO_TOKEN)
            self_ = false;
    };
}

AutoRevert::~AutoRevert()
{
    dismiss();
}

void AutoRevert::dismiss()    
{
    if (oldToken_)
    {
        // if the handle has been opened with TOKEN_IMPERSONATE
        // and if nobody has touched the SD for the ETHREAD object, this will work
        SetThrTokResult_ = SetThreadToken(NULL,oldToken_);
        CloseHandle(oldToken_);
    }
}


HRESULT ConfigMgr::LoadDefaultMofs()
{
    g_bDefaultMofLoadingNeeded = false;

    HRESULT hr;
    AutoRevert revert; 
    if (revert.self()==false) return HRESULT_FROM_WIN32(GetLastError());

    IWbemCallSecurity * pCallSec = CWbemCallSecurity::CreateInst();
    if (NULL == pCallSec) return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe rm(pCallSec);

    IUnknown * pOldCtx = NULL;
    IUnknown * pDiscard = NULL;    
    if (FAILED(hr = CoSwitchCallContext(NULL,&pOldCtx))) return hr;
    OnDelete2<IUnknown *,IUnknown **,
                     HRESULT(*)(IUnknown *,IUnknown **),
                     CoSwitchCallContext> SwitchBack(pOldCtx,&pDiscard);

    if (FAILED(hr = pCallSec->CloneThreadContext(TRUE))) return hr;
    
    if (FAILED(hr = CoSwitchCallContext(pCallSec,&pDiscard))) return hr;    

    size_t cchAutoRecLen = wcslen(g_pAutorecoverDir);
    size_t cchRealPath = 32 + 4 + 1 + 1 + cchAutoRecLen;
    wmilib::auto_buffer<WCHAR> pRealPath(new WCHAR[cchRealPath]);
    if (NULL == pRealPath.get()) return WBEM_E_OUT_OF_MEMORY;
    StringCchCopy(pRealPath.get(),cchRealPath,g_pAutorecoverDir);
    WCHAR * pInsertPoint = &pRealPath[cchAutoRecLen];
    *pInsertPoint = L'\\';
    pInsertPoint++;

    DWORD dwSize;
    TCHAR *pszMofs;
    TCHAR szExpandedFilename[MAX_PATH+1];    
    DWORD dwCurrMof;


    DWORD dwNextAutoRecoverFile = 0xffffffff;   // assume that this is clean
    Registry r(WBEM_REG_WINMGMT);
    r.GetDWORD(__TEXT("NextAutoRecoverFile"), &dwNextAutoRecoverFile);

    IWbemContext * pCtx = NULL;
    HRESULT hRes = CoCreateInstance(CLSID_WbemContext, 0, CLSCTX_INPROC_SERVER,  
                                                         IID_IWbemContext, (LPVOID *) &pCtx);
    if (FAILED(hRes)) return hRes;
    CReleaseMe rmCtx(pCtx);

    _variant_t Var = true;                
    if (FAILED(hRes = pCtx->SetValue(L"__MOFD_NO_STORE",0,&Var))) return hRes;
    
    
    IWinmgmtMofCompiler * pCompiler = NULL;
    hRes = CoCreateInstance(CLSID_WinmgmtMofCompiler, 0, CLSCTX_INPROC_SERVER,  // SEC:REVIEWED 2002-03-22 : OK
                                                         IID_IWinmgmtMofCompiler, (LPVOID *) &pCompiler);
    if(FAILED(hRes))
    {
        return hRes;
    }
    CReleaseMe relMe(pCompiler);

    CLSID clsid;
    IWmiDbController *pController = 0;
    hRes = GetDefaultRepDriverClsId(clsid);
    if (FAILED(hRes))
        return hRes;
    hRes = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, 
                          IID_IWmiDbController, (void **)&pController); 
    if (FAILED(hRes))
        return hRes;
    CReleaseMe relMe2(pController);

    //Get the list of MOFs we need to
    pszMofs = ConfigMgr::GetAutoRecoverMofs(dwSize);
    CVectorDeleteMe<TCHAR> vdm(pszMofs);

    if (pszMofs)
    {
        for (dwCurrMof = 0; *pszMofs != '\0'; dwCurrMof++)
        {
            if(dwNextAutoRecoverFile == 0xffffffff || dwCurrMof >= dwNextAutoRecoverFile)
            {
            	//Make sure we restart from where we left off from in case of reboot or service failure!
                r.SetDWORD(__TEXT("NextAutoRecoverFile"), dwCurrMof);
                
                DWORD nRes = ExpandEnvironmentStrings(pszMofs,szExpandedFilename,FILENAME_MAX);  // SEC:REVIEWED 2002-03-22 : OK
                if (0 == nRes)
                {
                    StringCchCopy(szExpandedFilename, MAX_PATH+1, pszMofs);
                }


                WCHAR * wPath = szExpandedFilename;
                WCHAR * pHash = NULL;
                DWORD dwRes = ComposeName(wPath,&pHash);
                if (ERROR_SUCCESS != dwRes) return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,dwRes);
                wmilib::auto_buffer<WCHAR> DelMe(pHash);

                StringCchCopy(pInsertPoint,34+4+1,pHash);

                //Call MOF Compiler with (pszMofs);                
                WBEM_COMPILE_STATUS_INFO Info;
                hr = pCompiler->WinmgmtCompileFile(pRealPath.get(),
                                                 NULL,
                                                 WBEM_FLAG_CONNECT_REPOSITORY_ONLY |
                                                 WBEM_FLAG_CONNECT_PROVIDERS |
                                                 WBEM_FLAG_DONT_ADD_TO_LIST,
                                                 WBEM_FLAG_OWNER_UPDATE,
                                                 WBEM_FLAG_OWNER_UPDATE,
                                                 NULL, pCtx, &Info);

                if(Info.hRes == CO_E_SERVER_STOPPING)
                {
                    return CO_E_SERVER_STOPPING;
                }
                else if(hr) // will include S_FALSE
                {
                    ERRORTRACE((LOG_WBEMCORE, "MOF compilation of <%S> failed during auto-recovery.  Refer to the mofcomp.log for more details of failure.\n", wPath));

                    CEventLog *pEvt = ConfigMgr::GetEventLog();
                    if (pEvt)
                        pEvt->Report(EVENTLOG_ERROR_TYPE,
                                     WBEM_MC_MOF_NOT_LOADED_AT_RECOVERY,
                                     szExpandedFilename);
                }
                else
                {
                	//We need to check-point the repository to make sure it is in a consistent state in case we get rebooted before
                	//writing the next MOF to load index in the registry.
                	hr = pController->LockRepository();
                	if (FAILED(hr))
                		return hr;
                	hr = pController->UnlockRepository();                	
                	if (FAILED(hr))
                		return hr;
                }
                
            }
            //Move on to the next string
            pszMofs += lstrlen(pszMofs) + 1;    // SEC:REVIEWED 2002-03-22 : OK, assumes GetAutocoverMofs() returns correct string format
        }

    }

    //We Have completed the MOF load, so make sure we don't continue from where we left off!
    r.SetDWORD(__TEXT("NextAutoRecoverFile"), 0xffffffff);
    return WBEM_S_NO_ERROR;;
}

//
//  secure a registry key
//  the name must be suitable for SetNamedSecurityInfoW
//  of the SDDL string, we care only about the DACL
//
///////////////////////////////////////////////////////////////

HRESULT SecureKey(WCHAR * pKeyName,WCHAR * pSDDLString)
{
    PSECURITY_DESCRIPTOR pSD = NULL;
    if (FALSE == ConvertStringSecurityDescriptorToSecurityDescriptor(pSDDLString,  // SEC:REVIEWED 2002-03-22 : OK
                                                SDDL_REVISION_1,
                                                &pSD,
                                                NULL)) return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,GetLastError());
    OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> dm1(pSD);

    SECURITY_DESCRIPTOR_RELATIVE * pRel = (SECURITY_DESCRIPTOR_RELATIVE *)pSD;
    if (!(pRel->Control & (SE_DACL_PRESENT | SE_SELF_RELATIVE)))
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,ERROR_INVALID_PARAMETER);

    DWORD dwLen = 0;
    DWORD dwLenDACL = 0;
    DWORD dwLenSACL = 0;
    DWORD dwLenOWNER = 0;
    DWORD dwLenGRP = 0;
    if (TRUE == MakeAbsoluteSD(pSD,
                             NULL,&dwLen,
                             NULL,&dwLenDACL,
                             NULL,&dwLenSACL,
                             NULL,&dwLenOWNER,
                             NULL,&dwLenGRP))
           return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,GetLastError());

    PACL pDacl = (PACL)LocalAlloc(0,dwLenDACL);
    if (NULL == pDacl) return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,GetLastError());
    OnDelete<HLOCAL,HLOCAL(*)(HLOCAL),LocalFree> dm2(pDacl);

    memcpy(pDacl,(BYTE *)pRel+pRel->Dacl,dwLenDACL);  // SEC:REVIEWED 2002-03-22 : OK

    SECURITY_INFORMATION SecurityInfo = DACL_SECURITY_INFORMATION |
                                      PROTECTED_DACL_SECURITY_INFORMATION;

    LONG lRet;
    if (ERROR_SUCCESS != (lRet = SetNamedSecurityInfoW(pKeyName,   // SEC:REVIEWED 2002-03-22 : OK
                                                   SE_REGISTRY_KEY,
                                                   SecurityInfo,
                                                   NULL, NULL, pDacl,NULL)))
           return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,GetLastError());        

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\cfgmgr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CFGMGR.H

Abstract:

  This file implements the WinMgmt configuration manager class.

  See cfgmgr.h for documentation.

  Classes implemented:
      ConfigMgr      configuration manager

History:

    09-Jul-96   raymcc    Created.
    3/10/97     levn      Fully documented (ha ha)


--*/

#ifndef _CFGMGR_H_
#define _CFGMGR_H_

class CWbemObject;
class CDynasty;
class CWbemQueue;
class CAsyncServiceQueue;
struct IWbemEventSubsystem_m4;

#define READONLY

#include <wmiutils.h>
#include <ql.h>
#include <reposit.h>
#include "coreq.h"

//******************************************************************************
//******************************************************************************
//
//  class ConfigMgr
//
//  This completely static class represents global configuration data for WinMgmt.
//  The rest of WinMgmt uses this class instead of global data itself.
//
//******************************************************************************
//
//  static GetProviderCache
//
//  Returns the pointer to the global provider cache object, as defined and
//  described in prvcache.h.
//
//  Returns:
//
//      CProviderCache*: internal pointer not to be modified or deleted!
//
//******************************************************************************
//
//  GetDbPtr
//
//  Returns the pointer to the WinMgmt static database object. The static database
//  is defined and described in objdb.h.
//
//  Returns:
//
//      CObjectDatabase*: internal pointer not to be modified or deleted!
//
//******************************************************************************
//
//  GetUnRefedSvcQueue
//
//  Returns the pointer to the global queue handling requests to providers.
//  Whenever WinMgmt needs to communicate to a provider, a request us added to
//  this queue. This queue is defined and described in provsvcq.h.
//
//  Returns:
//
//      CAsyncSvcQueue*: internal pointer not to be modified or deleted!
//
//******************************************************************************
//
//  GetAsyncSvcQueue
//
//  Returns the pointer to the global queue handling asynchrnous requests to
//  WinMgmt. Whenever a client makes a call into IWbemServices, WinMgmt adds a request
//  to this queue. This queue is defined and described in svcq.h
//
//  Returns:
//
//      CAsyncServiceQueue*: internal pointer not to be modified or deleted!
//
//******************************************************************************
//
//  GetMachineName
//
//  Returns the name of the computer we are running on as a UNICODE string,
//  even on Win95 where machine names are ASCII.
//
//  Returns:
//
//      LPWSTR: machine name. internal poitner not to be deleted!
//
//******************************************************************************
//
//  GetWorkingDir
//
//  Returns the working directory of WinMgmt, that is, where the database is
//  located.
//
//  Returns:
//
//      LPWSTR: internal pointer not to be deleted!
//
//******************************************************************************
//
//  static InitSystem
//
//  System initialization function invoked from wbemcore.dll entry point.
//  Performs the following tasks:
//
//  1) Looks for other copies of WinMgmt already running and stops with a fatal
//      error message if found.
//  2) Reads the registry for initialization information.
//  3) Creates the database object (this will in turn create the database file
//      if not found. See CObjectDatabase in objdb.h for details).
//  4) Writes appropriate information (like database location) into the
//      registry.
//
//  NOTE: since this function is invoked from inside the DLL entry point, there
//  are many restrictions on what it can do. In particular, it cannot create
//  threads and expect them to run. Thus, due to the multi-threaded nature of
//  WinMgmt, this function may not attempt to perform any WinMgmt operations at the
//  COM layer or the system will hang!
//
//******************************************************************************
//
//  static Shutdown
//
//  System Shutdown function invoked from wbemcore.dll entry point on PROCESS_
//  DETACH.  Deletes the CObjectDatabase instance (see objdb.h).
//
//******************************************************************************
//
//  static LoggingEnabled
//
//  Checks if logging has been enabled. If it is, Trace calls output data to
//  a log file. If not, Trace calls are noops.
//
//  Returns:
//
//      BOOL:   TRUE iff logging is enabled.
//
//******************************************************************************
//
//  static GetEssSink
//
//  Retrieves the pointer to the Event Subsystem. Event subsystem pointer will
//  only be available if EnableEvents registry value is set to TRUE. Otherwise,
//  this function returns NULL. Note, that the Event Subsystem is loaded only
//  by ConfigMgr::SetReady function which is invoked the first time
//  DllGetClassObject is called in wbemcore.dll. Thus, ESS is not available
//  during WinMgmt initialization (InitSystem).
//
//  Returns:
//
//      IWbemObjectSink*:    the pointer to the ESS. Not to be released or
//                          deleted by the caller! May be NULL, see above.
//
//******************************************************************************
//
//  static SetReady
//
//  This function performs initialization, once WinMgmt is ready to go.
//  It is invoked the first type DllGetClassObject is called in wbemcore.dll.
//  By now, wbemcorwbemcore.dll has exited its entry point and so it is safe to load
//  additional DLLs and perform multi-threaded operations (unlike InitSystem).
//
//******************************************************************************
//
//  static SetIdentificationObject
//
//  This function (invoked from the SetReady function) stores proper information
//  in the root and root\defualt __WinMgmtIdentification objects. Namely, it
//  creates instances of this class in both namespace if not already there and
//  sets the current build of WinMgmt in the appropriate fields.
//
//  Parameters:
//
//      IN WCHAR* pwcNamespace     The namespace to initialize.
//
//******************************************************************************
//
//  static GetDllVersion
//
//  Retrives a string from a given DLLs resource table. If the string is longer
//  that the buffer, it is trucated.
//
//  Parameters:
//
//      IN char * pDLLName          The filename of the DLL. The DLL must be
//                                  located in WinMgmt working directory (See
//                                  GetWorkingDir) and a relative path is
//                                  expected here.
//      IN char * pResStringName    The resource string to query, e.g.,
//                                  "ProductVersion".
//      OUT WCHAR * pRes            Destination buffer.
//      IN DWORD dwResSize          Size of the destination buffer.
//
//  Returns:
//
//      BOOL:   TRUE on success, FALSE if DLL or string was not found.
//
//******************************************************************************
//
//  static RaiseClassDeletionEvent
//
//  Temporarary: raises a class deletion event. This function is used in the
//  object database, since events need to be raised for every deleted class.
//
//  Parameters:
//
//      LPWSTR wszNamespace         The name of the namespace where the class
//                                  is being deleted.
//      LPWSTR wszClass             The name of the class being deleted.
//      IWbemClassObject* pClass     The definition of the class being deleted.
//
//  Returns:
//
//      HRESULT: Whatever error code the ESS returns. Only WBEM_S_NO_ERROR is
//              documented.
//
//******************************************************************************
//
//  static LoadResourceStr
//
//  Loads a string resource from the string table in WBEMCORE.RC.
//
//  Parameters:
//      DWORD dwId          The string id.
//
//  Return value:
//  A dynamically allocated LPWSTR.  This string is loaded in DBCS form
//  for compatibility with Win98, but is returned in UNICODE form on both
//  Win98 and Windows NT.  Deallocate with operator delete.
//
//******************************************************************************
//
//	static GetPersistentCfgValue
//
//	retrieves a persistent value from the $WINMGMT.cfg file (or from the memory
//	cache of it if already loaded).
//
//	Parameters:
//		DWORD dwOffset		Persistent value index
//
//	Return Values
//		DWORD &dwValue		Returned value
//		BOOL				returns TRUE if successful, FALSE otherwise.
//******************************************************************************
//
//	static SetPersistentCfgValue
//
//	sets a persistent value in the $WinMgmt.cfg file (and in the memory cache).
//
//	Parameters:
//		DWORD dwOffset		Persistent value index
//
//	Return Values
//		DWORD &dwValue		Returned value
//		BOOL				returns TRUE if successful, FALSE otherwise.
//******************************************************************************
//
//  static SetADAPStatus
//
//  This function (invoked from the SetReady function) stores an __ADAPStatus
//	instance in the root\default namespace on W2k boxes. Namely, it creates
//	the class if it doesn't exist as well as a singleton instance if it is
//	not there.
//
//  Parameters:
//
//      IN WCHAR* pwcNamespace     The namespace to initialize.
//
//******************************************************************************

class CAsyncReq;

class ConfigMgr
{
    static CStaticCritSec g_csEss;
public:
    static READONLY CWbemQueue* GetUnRefedSvcQueue();
    static READONLY CAsyncServiceQueue* GetAsyncSvcQueue();
    static HRESULT EnqueueRequest(CAsyncReq * pRequest);
    static HRESULT EnqueueRequestAndWait(CAsyncReq * pRequest);
    static READONLY LPWSTR GetMachineName();
    static LPTSTR   GetWorkingDir();
    static DWORD    InitSystem();
    static DWORD    Shutdown(BOOL bProcessShutdown, BOOL bIsSystemShutDown);
    static BOOL     ShutdownInProgress();
    static IWbemEventSubsystem_m4* GetEssSink();
    static HRESULT  SetReady();
    static HRESULT  PrepareForClients(long lFlags);
    static void		FatalInitializationError(HRESULT hRes);
    static HRESULT	WaitUntilClientReady();
    static HRESULT     SetIdentificationObject(IWmiDbHandle *pNs, IWmiDbSession *pSess);
    static HRESULT  SetAdapStatusObject(IWmiDbHandle *pNs, IWmiDbSession *pSess);
	//static void		ProcessIdentificationObject(IWmiDbHandle *pNs, IWbemClassObject *pInst);
    static BOOL     GetDllVersion(TCHAR * pDLLName, TCHAR * pResStringName,
                        WCHAR * pRes, DWORD dwResSize);
    static IWbemContext* GetNewContext();
	static LPTSTR	GetDbDir();

    static class CEventLog* GetEventLog();

    static DWORD GetMaxMemoryQuota();
    static DWORD GetUncheckedTaskCount();
    static DWORD GetMaxTaskCount();
    static DWORD GetMaxWaitBeforeDenial();
    static DWORD GetNewTaskResistance();

	static BOOL GetEnableQueryArbitration( void );
	static BOOL GetMergerThrottlingEnabled( void );
	static BOOL GetMergerThresholdValues( DWORD* pdwThrottle, DWORD* pdwRelease, DWORD* pdwBatching );
	static BOOL GetArbitratorValues( DWORD* pdwEnabled, DWORD* pdwSystemHigh, DWORD* pdwMaxSleep,
								double* pdHighThreshold1, long* plMultiplier1, double* pdHighThreshold2,
								long* plMultiplier2, double* pdHighThreshold3, long* plMultiplier3 );

	static ULONG GetMinimumMemoryRequirements ( ) ;
	static BOOL GetEnableArbitratorDiagnosticThread( void );

	static DWORD GetProviderDeliveryTimeout( void );

    static HRESULT  GetDefaultRepDriverClsId(CLSID &);

    static IWbemPath *GetNewPath();  // Returns NULL on error, requires Release() if successful.

	static BOOL GetPersistentCfgValue(DWORD dwOffset, DWORD &dwValue);
	static BOOL SetPersistentCfgValue(DWORD dwOffset, DWORD dwValue);

	//Retrieve a list of MOFs which need to be loaded when we have
	//have an empty database.  User needs to "delete []" the
	//returned string.  String is in a REG_MULTI_SZ format.
	//dwSize is the length of the buffer returned.
	static TCHAR* GetAutoRecoverMofs(DWORD &dwSize);

	static BOOL GetAutoRecoverDateTimeStamp(LARGE_INTEGER &liDateTimeStamp);

    static void ReadMaxQueueSize();
    static DWORD GetMaxQueueSize();

    static void SetDefaultMofLoadingNeeded();
    static HRESULT LoadDefaultMofs();
    static void GetSystemLimits();
};

//
//
//  The Hook Class for trapping the creation of Win32_PerRawData
//
///////////////////////////////////////////////////////////

extern _IWmiCoreWriteHook * g_pRAHook; // = NULL;

class CRAHooks : public _IWmiCoreWriteHook
{
public:
        CRAHooks(_IWmiCoreServices *pSvc);
        ~CRAHooks();
        _IWmiCoreServices * GetSvc(){ return m_pSvc; };

        STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        STDMETHOD(PrePut)(long lFlags, long lUserFlags, IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass, _IWmiObject* pCopy);
        STDMETHOD(PostPut)(long lFlags, HRESULT hApiResult,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass, _IWmiObject* pNew,
                            _IWmiObject* pOld);
        STDMETHOD(PreDelete)(long lFlags, long lUserFlags,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass);
        STDMETHOD(PostDelete)(long lFlags, HRESULT hApiResult,
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace,
                            LPCWSTR wszClass, _IWmiObject* pOld);
private:
    LONG m_cRef;
    _IWmiCoreServices * m_pSvc;
};

//
//
//  Data for the interception
//

#define GUARDED_NAMESPACE L"root\\cimv2"
#define GUARDED_CLASS     L"win32_perfrawdata"
#define GUARDED_HIPERF    L"hiperf"
#define GUARDED_PERFCTR   L"genericperfctr"
#define WMISVC_DLL        L"wmisvc.dll"
#define FUNCTION_DREDGERA "DredgeRA"

class ExceptionCounter
{
private:
    static LONG s_Count;
public:
    ExceptionCounter(){ InterlockedIncrement(&s_Count); };
};

HRESULT InitSubsystems();
HRESULT InitESS(_IWmiCoreServices *pSvc, BOOL bAutoRecoverd);
HRESULT ShutdownESS();
HRESULT ShutdownSubsystems(BOOL bIsSystemShutDown);

HRESULT SecureKey(WCHAR * pKeyName,WCHAR * pSDDLString);


#define ARB_DEFAULT_SYSTEM_MINIMUM            0x1E8480            // minimum is 2mb

//    Defaults for arbitrator
#define ARB_DEFAULT_SYSTEM_HIGH            0x4c4b400            // System limits [80megs]
#define ARB_DEFAULT_SYSTEM_HIGH_FACTOR    50                    // System limits [80megs] factor
#define ARB_DEFAULT_MAX_SLEEP_TIME        300000                // Default max sleep time for each task
#define ARB_DEFAULT_HIGH_THRESHOLD1        90                    // High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD1MULT 2                    // High threshold 1 multiplier
#define ARB_DEFAULT_HIGH_THRESHOLD2        95                    // High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD2MULT 3                    // High threshold 1 multiplier
#define ARB_DEFAULT_HIGH_THRESHOLD3        98                    // High threshold 1
#define ARB_DEFAULT_HIGH_THRESHOLD3MULT 4                    // High threshold 1 multiplier

// system limits reg keys

#define MAX_IDENTIFIER_WBEM L"IdentifierLimit"
#define MAX_QUERY_WBEM        L"QueryLimit"
#define MAX_PATH_WBEM          L"PathLimit"

///////////// system limits adjustment

// an instance of __namespace is put with a __RELAPATH __namespace.name="X"
#define NAMESPACE_ADJUSTMENT  (19) // lstrlen of __namespace.name=""

// a class must allow an object to be put
// if it is a singleton, it is  '=@' othewise '.P="X"' , the maximum is 6
#define CLASSNAME_ADJUSTMENT (6)

#define MINIMUM_MAX_QUERY 64
#define MINIMUM_MAX_IDENTIFIER 64

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\clicnt.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CLICNT.CPP

Abstract:

    Call Result Class

History:

    26-Mar-98   a-davj    Created.

--*/


#include "precomp.h"
#include <wbemcore.h>
// This keeps track of when the core can be unloaded

CClientCnt gClientCounter;
extern long g_lInitCount;  // 0 DURING INTIALIZATION, 1 OR MORE LATER ON!
extern ULONG g_cLock;


CClientCnt::CClientCnt():m_Count(0)
{
    InitializeListHead(&m_Head);    // SEC:REVIEWED 2002-03-22 : No check
}

CClientCnt::~CClientCnt()
{
    CInCritSec ics(&m_csEntering);     // SEC:REVIEWED 2002-03-22 : No check, assumes entry
    RemoveEntryList(&m_Head);
    InitializeListHead(&m_Head);
    m_Count = 0;
}

bool CClientCnt::AddClientPtr(LIST_ENTRY * pEntry)
{
    CInCritSec ics(&m_csEntering);   // SEC:REVIEWED 2002-03-22 : No check, assumes entry
    InterlockedIncrement(&m_Count);
    InsertTailList(&m_Head,pEntry);
    return true;
}

bool CClientCnt::RemoveClientPtr(LIST_ENTRY * pEntry)
{
    CInCritSec ics(&m_csEntering);     // SEC:REVIEWED 2002-03-22 : No check, assumes entry
    LONG lRet = InterlockedDecrement(&m_Count);
    RemoveEntryList(pEntry);
    InitializeListHead(pEntry);    // SEC:REVIEWED 2002-03-22 : No check
    if (0 == lRet) SignalIfOkToUnload();
    return true;
}

bool CClientCnt::OkToUnload()
{
    CInCritSec ics(&m_csEntering);     // SEC:REVIEWED 2002-03-22 : No check, assumes entry

    // We can shut down if we have 0 counts, and if we are not in the middle of initialization
    if( 0 == m_Count &&
      0 != g_lInitCount &&
      0 == g_cLock)
        return true;
    else
        return false;
}

void CClientCnt::SignalIfOkToUnload()
{
    // count our locks

    if(OkToUnload() && g_lInitCount != -1)
    {

        HANDLE hCanShutdownEvent = NULL;
        DEBUGTRACE((LOG_WBEMCORE,"Core can now unload\n"));
        hCanShutdownEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("WINMGMT_COREDLL_CANSHUTDOWN"));
        if(hCanShutdownEvent)
        {
            SetEvent(hCanShutdownEvent);
            CloseHandle(hCanShutdownEvent);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\clicnt.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    CLICNT.H

Abstract:

    Generic class for obtaining read and write locks to some resource.

History:
	
	26-Mar-98   a-davj    Created.

--*/

#ifndef __CLICNT__H_
#define __CLICNT__H_

#include <statsync.h>
#include <flexarry.h>

//*****************************************************************************
//
//	class CClientCnt
//
//	Keeps track of when the core can be unloaded.  Mainly it keep track of client connections,
//  but also can be called by other core code, such as the maintenance thread, to hold off
//  unloading.  This is very similar to the object counters, except this keeps track of only
//  objects which should prevent the core from unloading.  For example, a IWbemServices pointer used
//  internally for the ESS should not be in this list, but one given to a client would be.
//
//*****************************************************************************
//
//	AddClientPtr
//
//	Typcially called during the constructor of an object that has been given to a client
//
//	Parameters:
//
//		IUnknown *  punk	Pointer to an obejct.
//      DWORD dwType        Type of pointer
//
//	Returns:
//
//		true if OK
//
//*****************************************************************************
//
//	RemoveClientPtr
//
//	Typically called during the destructor of an object that might have been given to
//  a client.  Note that the code will search through the list of objects added and find
//  the object before doing anything.  So if the pointer is to an object not added via
//  AddClientPtr is passed, no harm is done.  This is important in the case of objects which
//  are not always given to a client.
//
//	Parameters:
//
//		IUnknown *  punk	Pointer to an obejct.
//
//	Returns:
//
//		true if removed.
//      flase is not necessarily a problem!
//*****************************************************************************
//
//	LockCore
//
//	Called in order to keep the core loaded.  This is called by the maintenance thread
//  in order to hold the core in memory.  Note that this acts like the LockServer call in
//  that serveral threads can call this an not block.  UnlockCore should be called when
//  the core is not needed anymore.
//
//	Returns:
//
//		long LockCount after call
//
//*****************************************************************************
//
//	UnlockCore
//
//	Called to reverse the effect of LockCore.
//
//	Returns:
//
//		long LockCount after call
//
//*****************************************************************************

enum ClientObjectType 
{    
     CALLRESULT = 0, 
     NAMESPACE, 
     LOGIN, 
     FACTORY, 
     DECORATOR,
     CORESVC,
     ESSSINK,
     LOCATOR,
     INT_PROV
};

struct Entry
{
	IUnknown * m_pUnk;
	ClientObjectType m_Type;
};

class CClientCnt
{
public:
	bool AddClientPtr(LIST_ENTRY * pEntry);
	bool RemoveClientPtr(LIST_ENTRY * pEntry);

    bool OkToUnload();
    CClientCnt();
    ~CClientCnt();

protected:
	CStaticCritSec m_csEntering; // this object is global, that's why we use CStaticCritSec
	LIST_ENTRY m_Head;
	LONG m_Count;
	void SignalIfOkToUnload();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\coresvc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    coresvc.cpp

Abstract:

    CCoreServices Class

History:

    raymcc      1-Mar-00        Created

--*/

#include "precomp.h"
#include "wbemcore.h"
#include "wmifinalizer.h"
#include "wmiarbitrator.h"

#pragma warning(disable:4355)

extern IClassFactory* g_pPathFac;
extern IClassFactory* g_pQueryFact;


_IWmiProvSS *CCoreServices::m_pProvSS = 0;
_IWbemFetchRefresherMgr* CCoreServices::m_pFetchRefrMgr = NULL;
CCoreServices* CCoreServices::g_pSvc = 0;
IWbemEventSubsystem_m4 *CCoreServices::m_pEssOld = 0;
_IWmiESS               *CCoreServices::m_pEssNew = 0;

CStaticCritSec CCoreServices::m_csHookAccess;

static BOOL g_bEventsEnabled = FALSE;
static CFlexArray g_aHooks;

LONG g_nSinkCount = 0;
LONG g_nStdSinkCount = 0;
LONG g_nSynchronousSinkCount = 0;
LONG g_nProviderSinkCount = 0;
LONG g_nNamespaceCount = 0;
LONG g_lCoreThreads = 0;

//***************************************************************************
//
//***************************************************************************

struct SHookElement
{
    _IWmiCoreWriteHook *m_pHook;
    ULONG               m_uFlags;
    HRESULT             m_hResPre; // The PreXXX return code may prevent the PostXXX code to be called

    SHookElement();
   ~SHookElement();
    SHookElement(SHookElement &Src);
    SHookElement& operator =(SHookElement &Src);
};



//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::Initialize ()
{
    m_pEssOld = 0;
    m_pEssNew = 0;

    g_pSvc = CCoreServices::CreateInstance();
    if (NULL == g_pSvc) return WBEM_E_OUT_OF_MEMORY;
    HRESULT hr = CoCreateInstance( CLSID__WbemFetchRefresherMgr, 
                                NULL, 
                                CLSCTX_INPROC_SERVER,  
                                IID__IWbemFetchRefresherMgr, 
                                (void**) &m_pFetchRefrMgr );

    return hr;
}

//***************************************************************************
//
//***************************************************************************
HRESULT CCoreServices::SetEssPointers(
    IWbemEventSubsystem_m4 *pEssOld,
    _IWmiESS               *pEssNew
    )
{
    m_pEssOld = pEssOld;
    m_pEssOld->AddRef();
    m_pEssNew = pEssNew;
    m_pEssNew->AddRef();
    return 0;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::UnInitialize ()
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (m_pProvSS)
    {
        m_pProvSS->Release () ;
        m_pProvSS = NULL ;
    }

    // Cleanup the refresher manager fetcher
    if ( NULL != m_pFetchRefrMgr )
    {
        // We should uninitialize as well - commented out for now
        // m_pFetchRefrMgr->Uninit();
        m_pFetchRefrMgr->Release ();
        m_pFetchRefrMgr = NULL;
    }

    // Free up the perflib

    ReleaseIfNotNULL(m_pEssOld);
    ReleaseIfNotNULL(m_pEssNew);

    ReleaseIfNotNULL(g_pSvc);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

CCoreServices::CCoreServices() : m_lRef(0)
{
    gClientCounter.AddClientPtr(&m_Entry);
}

//***************************************************************************
//
//***************************************************************************

CCoreServices::~CCoreServices()
{
    gClientCounter.RemoveClientPtr(&m_Entry);
}

ULONG CCoreServices::AddRef()
{
    InterlockedIncrement(&m_lRef);
    return ULONG(m_lRef);
}

//***************************************************************************
//
//***************************************************************************

ULONG CCoreServices::Release()
{
    ULONG uNewCount = (ULONG) InterlockedDecrement(&m_lRef);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID__IWmiCoreServices)
    {
        AddRef();
        *ppv = (void*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetObjFactory(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiObjectFactory __RPC_FAR *__RPC_FAR *pFact)
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetServices(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszUser,
            /* [in] */ LPCWSTR pszLocale,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices)
{
    BOOL bRepositOnly = false;
    HRESULT hRes;

    if (lFlags & WMICORE_FLAG_REPOSITORY)
        bRepositOnly = true;

    CWbemNamespace *pNs = CWbemNamespace::CreateInstance();
    if (NULL == pNs) return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe rm((IWbemServices *)pNs);

    LPWSTR wszTempLocale = ( LPWSTR ) pszLocale ;
    if ( wszTempLocale == NULL )
    {
        wszTempLocale = GetDefaultLocale();
        if(wszTempLocale == NULL) return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<WCHAR> vdm(pszLocale ? NULL : wszTempLocale );

    hRes = pNs->Initialize(
        LPWSTR(pszNamespace),
        pszUser ? ( LPWSTR ) pszUser : ADMINISTRATIVE_USER,
        0,
        FULL_RIGHTS,
        FALSE,
        bRepositOnly,
        NULL,
        0XFFFFFFFF,
        FALSE,
        NULL);


    if (SUCCEEDED(hRes))
    {
        pNs->SetLocale (wszTempLocale);
        if ( lFlags & WMICORE_CLIENT_TYPE_PROVIDER )
        {
            pNs->SetIsProvider(TRUE) ;
        }
        if ( lFlags & WMICORE_CLIENT_TYPE_ESS )
        {
            pNs->SetIsESS ( TRUE );
        }

        *pServices = rm.dismiss();

    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetRepositoryDriver(
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pDriver)
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetCallSec(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiCallSec __RPC_FAR *__RPC_FAR *pCallSec)
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************
bool CCoreServices::IsProviderSubsystemEnabled()
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return false;

    DWORD dwEnableProviderSubSystemFlag;
    DWORD dwLen = sizeof(DWORD);
    lRes = RegQueryValueExW(hKey, L"Enable Provider Subsystem", NULL, NULL, 
                (LPBYTE)&dwEnableProviderSubSystemFlag, &dwLen);
    RegCloseKey(hKey);

    if(lRes == ERROR_SUCCESS && (dwEnableProviderSubSystemFlag == 0))
    {
        return false;
    }
    return true;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetProviderSubsystem(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiProvSS __RPC_FAR *__RPC_FAR *pProvSS)
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (m_pProvSS == NULL)
    {
        if(!IsProviderSubsystemEnabled() || IsNtSetupRunning())
        {
            //Provider subsystem is currently disabled because of it's registry key, or
            //because NT Setup is currently running.
            *pProvSS = NULL;
            return S_FALSE;
        }

        hRes = CoCreateInstance(    
            CLSID_WmiProvSS,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID__IWmiProvSS,
            (LPVOID *) &m_pProvSS
            );

        if (SUCCEEDED(hRes))
        {
            CCoreServices *pSvc = CCoreServices::CreateInstance();
            CReleaseMe _(pSvc);

            IWbemContext *pCtx = 0;

            hRes = m_pProvSS->Initialize(
                lFlags,
                pCtx,
                pSvc
                );

            if (FAILED(hRes))
            {
                ERRORTRACE((LOG_WBEMCORE, "IWmiProvSS::Initialize returned failure <0x%X>!\n", hRes));
                m_pProvSS->Release() ;
                m_pProvSS = NULL ;
            }
            else
            {
               m_pProvSS->AddRef();
               *pProvSS = m_pProvSS;
            }
        }
        else // FAILED to CoCreate
        {
            ERRORTRACE((LOG_WBEMCORE, "ProviderSubsystem CoCreateInstance returned failure <0x%X>!\n", hRes));
        }
    }
    else // Already created
    {
        m_pProvSS->AddRef();
        *pProvSS = m_pProvSS;
        hRes = WBEM_S_NO_ERROR;
    }

    return hRes;
}



//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::DeliverIntrinsicEvent(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ ULONG uType,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ LPCWSTR pszParam,
            /* [in] */ LPCWSTR pszTransGuid,
            /* [in] */ ULONG uObjectCount,
            /* [in] */ _IWmiObject __RPC_FAR *__RPC_FAR *ppObjList
            )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if (g_bEventsEnabled == FALSE)
        return hRes;

    if (m_pEssOld)
    {
        hRes = m_pEssOld->ProcessInternalEvent(
            uType,
            LPWSTR(pszNamespace),
            LPWSTR(pszParam),
            LPWSTR(pszTransGuid),
            0,
            0,
            uObjectCount,
            ppObjList,
            pCtx
            );
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::DeliverExtrinsicEvent(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ ULONG uFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ _IWmiObject __RPC_FAR *pEvt
            )
{
    return E_NOTIMPL;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::StopEventDelivery( void)
{
    g_bEventsEnabled = FALSE;
    return 0;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::StartEventDelivery( void)
{
    g_bEventsEnabled = TRUE;
    return 0;
}



//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::IncrementCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam
            )
{
    if (uID == WMICORE_SELFINST_SINK_COUNT)
    {
        InterlockedIncrement(&g_nSinkCount);
    }
    else if (uID == WMICORE_SELFINST_STD_SINK_COUNT)
    {
        InterlockedIncrement(&g_nStdSinkCount);
    }
    else if ( uID == WMICORE_SELFINST_CONNECTIONS )
    {
        InterlockedIncrement(&g_nNamespaceCount);
    }
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::DecrementCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam
            )
{
    if (uID == WMICORE_SELFINST_SINK_COUNT)
    {
        InterlockedDecrement(&g_nSinkCount);
    }
    else if (uID == WMICORE_SELFINST_STD_SINK_COUNT)
    {
        InterlockedDecrement(&g_nStdSinkCount);
    }
    else if ( uID == WMICORE_SELFINST_CONNECTIONS )
    {
        InterlockedDecrement(&g_nNamespaceCount);
    }

    return S_OK;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::SetCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam
            )
{
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::GetSelfInstInstances(
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            )
{
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

typedef _IWmiObject * PWMIOBJ;

STDMETHODIMP CCoreServices::GetSystemObjects(
            /* [in] */ ULONG lFlags,
            /* [out] */ ULONG __RPC_FAR *puArraySize,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pObjects)
{
    CFlexArray Results;
    HRESULT hr;
    if(puArraySize == NULL)
        return WBEM_E_INVALID_PARAMETER;
    try
    {
        switch(lFlags)
        {
        case GET_SYSTEM_STD_OBJECTS:
            hr = GetSystemStdObjects(&Results);
            break;
        case GET_SYSTEM_SECURITY_OBJECTS:
            hr = GetSystemSecurityObjects(&Results);
            break;
        case GET_SYSTEM_ROOT_OBJECTS:
            hr = GetSystemRootObjects(&Results);
            break;
        case GET_SYSTEM_STD_INSTANCES:
            hr = GetStandardInstances(&Results);
            break;
        default:
            return WBEM_E_INVALID_PARAMETER;
        }
    }
    catch(...)
    {
        ExceptionCounter c;
        //  The class init stuff uses exceptions to handle out of memory conditions.
        hr = WBEM_E_OUT_OF_MEMORY;
    }


    // See if the buffer is large enough

    if(SUCCEEDED(hr))
    {
        DWORD dwBuff = *puArraySize;
        *puArraySize = Results.Size();
        if(dwBuff < Results.Size() || pObjects == NULL)
            hr = WBEM_E_BUFFER_TOO_SMALL;
    }

    // If failure in lower level, free up any elements in the flex array

    if(FAILED(hr))
    {
        for(DWORD dwCnt = 0; dwCnt < Results.Size(); dwCnt++)
        {
            PWMIOBJ pObj = (PWMIOBJ)Results.GetAt(dwCnt);
            if(pObj)
                delete pObj;
        }
        return hr;
    }

    // for success, transfer the results from the flex array to the return array.

    for(DWORD dwCnt = 0; dwCnt < Results.Size(); dwCnt++)
    {
        pObjects[dwCnt] = (PWMIOBJ)Results.GetAt(dwCnt);
    }
    return hr;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetSystemClass(
            /* [in] */ LPCWSTR pszClassName,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pClassDef)
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::GetConfigObject(
            ULONG uID,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pCfgObject)
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::RegisterWriteHook(
            /* [in] */ ULONG uFlags,
            /* [in] */ _IWmiCoreWriteHook __RPC_FAR *pHook
            )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    if (pHook == 0)
        return WBEM_E_INVALID_PARAMETER;

    SHookElement *pHookEl = new SHookElement;
    if (!pHookEl)
        return WBEM_E_OUT_OF_MEMORY;

    pHookEl->m_pHook = pHook;
    pHookEl->m_pHook->AddRef();
    pHookEl->m_uFlags = uFlags;

    CInCritSec ics(&m_csHookAccess); 

    int nRes = g_aHooks.Add(pHookEl);

    if (nRes)
    {
        delete pHookEl;
        hRes = WBEM_E_FAILED;
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::UnregisterWriteHook(
      _IWmiCoreWriteHook __RPC_FAR *pTargetHook
      )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    if (pTargetHook == 0)
        return WBEM_E_INVALID_PARAMETER;

    BOOL bFound = FALSE;
    CInCritSec ics(&m_csHookAccess);
    for (int i = 0; i < g_aHooks.Size(); i++)
    {
        SHookElement *pEl = (SHookElement *) g_aHooks.GetAt(i);
        if (pEl == 0)
            continue;

        _IWmiCoreWriteHook *pHook = pEl->m_pHook;
        if (pHook == pTargetHook)
        {
            g_aHooks.RemoveAt(i);
            delete pEl;
            hRes = WBEM_S_NO_ERROR;
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
        hRes = WBEM_E_NOT_FOUND;

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::CreateCache(
            /* [in] */ ULONG uFlags,
            /* [out] */  _IWmiCache __RPC_FAR *__RPC_FAR *pCache
            )
{
    return WBEM_E_NOT_AVAILABLE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::CreateFinalizer(
            /* [in] */ ULONG uFlags,
            /* [out] */  _IWmiFinalizer __RPC_FAR *__RPC_FAR *ppFnz
            )
{
    CWmiFinalizer *pFnz;
    try
    {
        pFnz = new CWmiFinalizer(this); // throw
        if (!pFnz)
            return WBEM_E_OUT_OF_MEMORY;
    }
    catch (CX_Exception &)
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    pFnz->AddRef();
    *ppFnz = pFnz;

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::CreatePathParser(
                ULONG uFlags,
                IWbemPath **pParser
                )
{
    if (NULL == g_pPathFac) return WBEM_E_INITIALIZATION_FAILURE;
    return g_pPathFac->CreateInstance(0, IID_IWbemPath, (LPVOID *) pParser);
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::CreateQueryParser(
                ULONG uFlags,
                _IWmiQuery **pResultQueryObj
                )
{
    if (NULL == g_pQueryFact) return WBEM_E_INITIALIZATION_FAILURE;
    return g_pQueryFact->CreateInstance(0, IID__IWmiQuery, (LPVOID *)pResultQueryObj);
}

//***************************************************************************
//
//***************************************************************************
HRESULT CCoreServices::GetDecorator(
                ULONG uFlags,
                IWbemDecorator **pDest
                )
{
    CDecorator *pDec = new CDecorator;
    if (!pDec)
        return WBEM_E_OUT_OF_MEMORY;
    pDec->AddRef();
    *pDest = pDec;
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::GetServices2(
            /* [in] */ LPCWSTR pszPath,
            /* [in] */ LPCWSTR pszUser,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ ULONG uClientFlags,
            /* [in] */ DWORD dwSecFlags,
            /* [in] */ DWORD dwPermissions,
            /* [in] */ ULONG uInternalFlags,
            /* [in] */ LPCWSTR pszClientMachine,
            /* [in] */ DWORD dwClientProcessID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices
            )
{
    HRESULT hRes = CWbemNamespace::PathBasedConnect(
            pszPath,
            pszUser,
            pCtx,
            uClientFlags,
            dwSecFlags,
            dwPermissions,
            uInternalFlags,
            pszClientMachine,
            dwClientProcessID,
            riid,
            pServices
            );

    return hRes;
}



//***************************************************************************
//
//***************************************************************************
//
HRESULT CCoreServices::NewPerTaskHook(
            /* [out] */ _IWmiCoreWriteHook __RPC_FAR *__RPC_FAR *pHook
            )
{
    CPerTaskHook *pNewHook = 0;
    HRESULT hRes = CPerTaskHook::CreatePerTaskHook(&pNewHook);
    if (FAILED(hRes))
        return hRes;

    *pHook = (_IWmiCoreWriteHook *) pNewHook;
    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::GetArbitrator(
            /* [out] */ _IWmiArbitrator **pReturnedArb
            )
{
    return E_NOTIMPL;
}

HRESULT CCoreServices::DumpCounters(FILE *f)
{
    if (!f)
        return E_FAIL;

    fprintf(f, "Total sinks active     = %d\n", g_nSinkCount);     // SEC:REVIEWED 2002-03-22 : ok, no path to here
    fprintf(f, "Total std sink objects = %d\n", g_nStdSinkCount);  // SEC:REVIEWED 2002-03-22 : ok, no path to here

    return 0;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCoreServices::InitRefresherMgr(
            /* [in] */ long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    // Get a refresher manager from the provider subsystem.  We initialize this once,
    // then retrieve from the fetcher.  If this succeeds, initialize the refreshing
    // services pointer with this guy so we can pawn off all the refresher
    // hi-perf provider fixup stuff.

    _IWmiProvSS *pProvSS = 0;
    GetProviderSubsystem(0, &pProvSS);
    CReleaseMe _2(pProvSS);

    // We'll need a Services pointer to create the manager
    IWbemServices*  pService = NULL;
    hr = GetServices( L"root", NULL,NULL,WMICORE_FLAG_REPOSITORY, IID_IWbemServices, (void**) &pService );
    CReleaseMe  rm1(pService);

    if ( NULL != m_pFetchRefrMgr )
    {
        hr = m_pFetchRefrMgr->Init( pProvSS, pService );
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CCoreServices::InternalSetCounter(
            DWORD dwCounter, DWORD dwValue)
{
    return S_OK;
}
//***************************************************************************
//
//***************************************************************************

ULONG CPerTaskHook::AddRef()
{
    InterlockedIncrement((LONG *) &m_uRefCount);
    return m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************

ULONG CPerTaskHook::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 != uNewCount)
        return uNewCount;
    delete this;
    return 0;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CPerTaskHook::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    if (IID_IUnknown==riid || IID__IWmiCoreWriteHook==riid)
    {
        *ppvObj = this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}



//***************************************************************************
//
//***************************************************************************

CPerTaskHook::CPerTaskHook()
{
    m_uRefCount = 0;
}

//***************************************************************************
//
//***************************************************************************

CPerTaskHook::~CPerTaskHook()
{
    for (int i = 0; i < m_HookList.Size(); i++)
    {
        SHookElement *pHE = (SHookElement *) m_HookList.GetAt(i);
        delete pHE;
    }
}

//***************************************************************************
//
//***************************************************************************

HRESULT CPerTaskHook::CreatePerTaskHook(
    OUT CPerTaskHook **pDestNew
    )
{
    int nRes;

    *pDestNew = 0;

    wmilib::auto_ptr<CPerTaskHook> pNew(new CPerTaskHook);
    
    if (NULL == pNew.get()) return WBEM_E_OUT_OF_MEMORY;

    {
        CInCritSec ics(&CCoreServices::m_csHookAccess);

        for (int i = 0; i < g_aHooks.Size(); i++)
        {
            SHookElement *pEl = (SHookElement *) g_aHooks.GetAt(i);
            if (pEl == 0)
                continue;

            wmilib::auto_ptr<SHookElement> pNewEl( new SHookElement);

            if (NULL == pNewEl.get()) return WBEM_E_OUT_OF_MEMORY;

            *pNewEl.get() = *pEl;

            if (CFlexArray::no_error != pNew->m_HookList.Add(pNewEl.get()))
                return WBEM_E_OUT_OF_MEMORY;
            pNewEl.release();

        }

    }

    if (pNew->m_HookList.Size() != 0)
    {
        pNew->AddRef();                
        *pDestNew = pNew.release();
    }
    else
    {
        *pDestNew = 0;                  // No sense in returning an empty list
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

HRESULT CPerTaskHook::PrePut(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pCopy
            )
{
    HRESULT hRes = 0;
    HRESULT hResBoth = 0;

    for (int i = 0; i < m_HookList.Size(); i++)
    {
        SHookElement *pEl = (SHookElement *) m_HookList.GetAt(i);
        if (pEl == 0)
            continue;
        _IWmiCoreWriteHook *pHook = pEl->m_pHook;

        //
        // One can register for both CLASS and INSTANCE
        // but there will be alwys ONE bit set in the lFlags
        //
        if (lFlags & pEl->m_uFlags)
        {
            if ((WBEM_FLAG_DISABLE_WHEN_OWNER_UPDATE & pEl->m_uFlags) &&
                (lUserFlags & WBEM_FLAG_NO_EVENTS))
            {
                // this HOOK is disabled becasue OWNER_UPDATE is set
                hRes = S_OK;
            }
            else
            {
                hRes = pHook->PrePut(lFlags, lUserFlags, pCtx, pPath, pszNamespace, pszClass, pCopy);
            }
            pEl->m_hResPre = hRes;
        }
        else
        {
            continue;
        }

        if (FAILED(hRes))
            return hRes;

        if (hRes == WBEM_S_POSTHOOK_WITH_BOTH)
            hResBoth = WBEM_S_POSTHOOK_WITH_BOTH;
    }

    return hResBoth;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CPerTaskHook::PostPut(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hApiResult,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pNew,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            )
{
    HRESULT hRes = 0;

    for (int i = 0; i < m_HookList.Size(); i++)
    {
        SHookElement *pEl = (SHookElement *) m_HookList.GetAt(i);
        if (pEl == 0)
            continue;
        if (pEl->m_hResPre == WBEM_S_NO_POSTHOOK)
            continue;
        _IWmiCoreWriteHook *pHook = pEl->m_pHook;

        //
        // One can register for both CLASS and INSTANCE
        // but there will be alwys ONE bit set in the lFlags
        //
        if (lFlags & pEl->m_uFlags)
        {
            hRes |= pHook->PostPut(lFlags, hApiResult, pCtx, pPath, pszNamespace, pszClass, pNew, pOld);
            pEl->m_hResPre = 0;
        }
        else
        {
            continue;
        }
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CPerTaskHook::PreDelete(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass
            )
{
    HRESULT hRes = 0, hResWithOld = 0;

    for (int i = 0; i < m_HookList.Size(); i++)
    {
        SHookElement *pEl = (SHookElement *) m_HookList.GetAt(i);
        if (pEl == 0)
            continue;
        _IWmiCoreWriteHook *pHook = pEl->m_pHook;

        if (lFlags & pEl->m_uFlags)
        {
            hRes = pHook->PreDelete(lFlags, lUserFlags, pCtx, pPath, pszNamespace, pszClass);
            pEl->m_hResPre = ULONG(hRes);
        }
        else
        {
            continue;
        }


        if (FAILED(hRes))
            return hRes;

        if (hRes == WBEM_S_POSTHOOK_WITH_OLD)
            hResWithOld = WBEM_S_POSTHOOK_WITH_OLD;
    }

    return hResWithOld;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CPerTaskHook::PostDelete(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hApiResult,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            )
{
    HRESULT hRes = 0;

    for (int i = 0; i < m_HookList.Size(); i++)
    {
        SHookElement *pEl = (SHookElement *) m_HookList.GetAt(i);
        if (pEl == 0)
            continue;
        if (pEl->m_hResPre == WBEM_S_NO_POSTHOOK)
            continue;

        if (lFlags & pEl->m_uFlags)
        {
            _IWmiCoreWriteHook *pHook = pEl->m_pHook;
            hRes |= pHook->PostDelete(lFlags, hApiResult, pCtx, pPath, pszNamespace, pszClass, pOld);
            pEl->m_hResPre = 0;
        }
        else
        {
            continue;
        }
    }

    return hRes;
}

SHookElement::SHookElement()
{
    m_pHook = 0;
    m_uFlags = 0;
    m_hResPre = 0;
}

SHookElement::~SHookElement()
{
    ReleaseIfNotNULL(m_pHook);
}

SHookElement::SHookElement(SHookElement &Src)
{
    m_pHook = 0;
    *this = Src;
}

SHookElement & SHookElement::operator =(SHookElement &Src)
{
    m_uFlags = Src.m_uFlags;
    ReleaseIfNotNULL(m_pHook);
    m_pHook = Src.m_pHook;
    if (m_pHook)
        m_pHook->AddRef();
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\coreq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXECQ.CPP

Abstract:

  Implements classes related to abstract execution queues.

  Classes implemeted:

      CCoreExecReq    An abstract request.
      CCoreQueue      A queue of requests with an associated thread

History:

      23-Jul-96   raymcc    Created.
      3/10/97     levn      Fully documented (heh, heh)
      14-Aug-99   raymcc    Changed timeouts
      30-Oct-99   raymcc    Critsec changes for NT Wksta Stress Oct 30 1999
--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <cominit.h>
#include <sync.h>
#include "genutils.h"
#include "tls.h"
#include <wbemcore.h>
#include <wmiarbitrator.h>
#include <scopecheck.h>

#define IDLE_THREAD_TIMEOUT     12000
#define OVERLFLOW_TIMEOUT        5000




//***************************************************************************

long CCoreQueue::m_lEmergencyThreads = 0 ;
long CCoreQueue::m_lPeakThreadCount = 0 ;
long CCoreQueue::m_lPeakEmergencyThreadCount = 0;
    
CTLS g_QueueTlsIndex;

// This is TLS init for the purpose of hiding the __thisnamespace class from users.
// The idea is that we use this TLS slot to hold the flag so that
// the repository can then access this slot to determine to skip a check or not.
// The index is passed down to the repository at Logon time (cfgmgr.cpp)
CTLS g_SecFlagTlsIndex;

CCoreExecReq::CCoreExecReq(): 
    m_hWhenDone(NULL), 
    m_pNext(NULL),
    m_lPriority(0), 
    m_phTask(NULL),
    m_fOk(true)
{
}

CCoreExecReq::~CCoreExecReq()
{
    if (m_phTask)
    {
        m_phTask->Release();
        m_phTask = 0;
    }
}

HRESULT CCoreExecReq::SetTaskHandle(_IWmiCoreHandle *phTask)
{
    if (phTask)
    {
        phTask->AddRef();
        m_phTask = phTask;
    }
    return WBEM_S_NO_ERROR;
}

DWORD CCoreQueue::GetTlsIndex()
{
    return g_QueueTlsIndex.GetIndex();
}

//
// Get the security flag TLS index.
//
DWORD CCoreQueue::GetSecFlagTlsIndex ( )
{
    return g_SecFlagTlsIndex.GetIndex() ;
}

//
//
//
void CCoreQueue::SetArbitrator(_IWmiArbitrator* pArbitrator)
{
    if (!m_pArbitrator)
    {
           m_pArbitrator = pArbitrator;
           if (m_pArbitrator)
               m_pArbitrator->AddRef();
    }
}

//
// Be VERY CAREFUL when using this function.  It's here to support
// merger requests which actually execute a number of unqueued requests
// and in order to stay consistent, we want to ensure that the current
// request points to the true request, and not the dummy request we
// created as a starting point.
//

HRESULT CCoreQueue::ExecSubRequest( CCoreExecReq* pNewRequest )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    CThreadRecord* pRecord = (CThreadRecord*)TlsGetValue(GetTlsIndex());
    if(pRecord)
    {
        if ( !pRecord->m_bExitNow )
        {
            CCoreExecReq* pCurrReq = pRecord->m_pCurrentRequest;

            pRecord->m_pCurrentRequest = pNewRequest;
            
            if (!pRecord->m_pQueue->Execute( pRecord ))
            {
                // here the request has gone already
            }
                
            // Restore the request
            pRecord->m_pCurrentRequest = pCurrReq;
        }
        else
        {
            hr = WBEM_E_SHUTTING_DOWN;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}


CCoreQueue::CThreadRecord::CThreadRecord(CCoreQueue* pQueue):
      m_pQueue(pQueue),
      m_pCurrentRequest(NULL),
      m_bReady(FALSE),
      m_bExitNow(FALSE)
{
    m_hAttention = CreateEvent(NULL, FALSE, FALSE, NULL);  
    if (NULL == m_hAttention) throw CX_MemoryException();
    m_pQueue->AddRef();
    m_pArb = m_pQueue->GetArbitrator();
}

CCoreQueue::CThreadRecord::~CThreadRecord()
{
    CloseHandle(m_hAttention);
    if (m_hThread) CloseHandle(m_hThread); 
    m_pQueue->Release();
    if (m_pArb) m_pArb->Release();
}

void CCoreQueue::CThreadRecord::Signal()
{
    SetEvent(m_hAttention);
}


//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
CCoreQueue::CCoreQueue() :
    m_lNumThreads(0),
    m_lMaxThreads(1),
    m_lNumIdle(0),
    m_lNumRequests(0),
    m_pHead(NULL),
    m_pTail(NULL),
    m_dwTimeout(IDLE_THREAD_TIMEOUT),
    m_dwOverflowTimeout(OVERLFLOW_TIMEOUT),
    m_lHiPriBound(-1),
    m_lHiPriMaxThreads(1),
    m_lRef(0),
    m_bShutDownCalled(FALSE),
    m_pArbitrator(NULL)
{
    SetRequestLimits(4000);
}

//******************************************************************************
//
//  See execq.h for documentation
//
//******************************************************************************
CCoreQueue::~CCoreQueue()
{
    try
    {
        Shutdown(FALSE); // SystemShutDown is called Explicitly

        // Remove all outstanding requests
        // ===============================

        while(m_pHead)
        {
            CCoreExecReq* pReq = m_pHead;
            m_pHead = m_pHead->GetNext();
            delete pReq;
        }

        if ( m_pArbitrator )
        {
            m_pArbitrator->Release ( ) ;
            m_pArbitrator = NULL ;
        }

    }   // end try
    catch(...) // To protect svchost.exe; we know this isn't a good recovery for WMI
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::~CCoreQueue() exception\n"));
    }
}

void CCoreQueue::Shutdown(BOOL bIsSystemShutDown)
{
    try
    {
        CCritSecWrapper cs(&m_cs);

        if (!m_bShutDownCalled)
        {
            m_bShutDownCalled = TRUE;
        }
        else
        {
            return;
        }

        // Get all member thread handles
        // =============================

        cs.Enter();                                   
        int nNumHandles = m_aThreads.Size();
        HANDLE* ah = new HANDLE[nNumHandles];
        if (NULL == ah)
        {
            nNumHandles = 0;
        }
        DEBUGTRACE((LOG_WBEMCORE, "Queue is shutting down!\n"));

        int i;
        for(i = 0; i < nNumHandles; i++)
        {
            CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];
            ah[i] = pRecord->m_hThread;

            // Inform the thread it should go away when ready
            // ==============================================

            pRecord->m_bExitNow = TRUE;

            // Wake it up if necessary
            // =======================
        
            pRecord->Signal();
        }
        cs.Leave();


        // Make sure all our threads are gone
        // ==================================

        if(nNumHandles > 0 && !bIsSystemShutDown)
        {
            WaitForMultipleObjects(nNumHandles, ah, TRUE, 10000);
        }

        for(i = 0; i < nNumHandles; i++)
            CloseHandle(ah[i]);

        delete [] ah;

    }   // end try
    catch(...)
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::Shutdown() exception\n"));
    }
}


void CCoreQueue::Enter()
{
    m_cs.Enter();
}

void CCoreQueue::Leave()
{
    m_cs.Leave();
}

//******************************************************************************
//
//
//******************************************************************************
void CCoreQueue::Register(CThreadRecord* pRecord)
{
    g_QueueTlsIndex.Set((void*)pRecord);
}

void CCoreQueue::Unregister()
{
    g_QueueTlsIndex.Set(NULL);
}


BOOL CCoreQueue::IsSuitableThread(CThreadRecord* pRecord, CCoreExecReq* pReq)
{
    if(pRecord->m_pCurrentRequest == NULL)
        return TRUE;

    // This thread is in the middle of something. By default, ignore it
    // ================================================================

    return FALSE;
}

//******************************************************************************
//
//
//******************************************************************************
HRESULT CCoreQueue::Enqueue(CCoreExecReq* pRequest, HANDLE* phWhenDone)
{
    try
    {

        CCritSecWrapper cs(&m_cs);

        if (m_bShutDownCalled) return WBEM_E_SHUTTING_DOWN;
        if (!pRequest->IsOk()) return WBEM_E_OUT_OF_MEMORY;


        // Create an event handle to signal when request is finished, if required
        // ======================================================================

        if(phWhenDone)
        {
            *phWhenDone = CreateEvent(NULL, FALSE, FALSE, NULL);

            if ( NULL == *phWhenDone )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            pRequest->SetWhenDoneHandle(*phWhenDone);
        }

        cs.Enter(); 
        
        // Search for a suitable thread
        // ============================

        for(int i = 0; i < m_aThreads.Size(); i++)
        {
            CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];

            if(pRecord->m_bReady)
            {
                // Free. Check if suitable
                // =======================

                if(IsSuitableThread(pRecord, pRequest))
                {
                    pRecord->m_pCurrentRequest = pRequest;
                    pRecord->m_bReady = FALSE;
                    pRecord->Signal();
                    m_lNumIdle--;

                    // Done!
                    // =====

                    cs.Leave();
                    return WBEM_S_NO_ERROR;
                }
            }
        }

        BOOL bNeedsAttention = FALSE ;

        if ( IsDependentRequest ( pRequest ) || ( (CWbemRequest*) pRequest)->GetForceRun ( ) > 0 )
        {
            bNeedsAttention = TRUE ;
        }

        // No suitable thread found. Add to the queue
        // ==========================================

        if(m_lNumRequests >= m_lAbsoluteLimitCount && !bNeedsAttention )
        {
            cs.Leave();
            return WBEM_E_FAILED;
        }

        // Search for insert position based on priority
        // ============================================
        if ( bNeedsAttention )
        {
            // the requests that have called SetForceRun have already set their priority
            if (0 == ((CWbemRequest*)pRequest)->GetForceRun())
                pRequest->SetPriority(PriorityNeedsAttentionRequests);
        }
        else
            AdjustInitialPriority(pRequest);

        if ( bNeedsAttention )
        {
            if (!CreateNewThread ( TRUE ))
            {
                //
                // Always return a failure if we can not create a thread.
                // Avoiding very rare deadlocks when rest of system is
                // dependent on a request to finish.
                //
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            if(DoesNeedNewThread(pRequest, true))
            {
                if (!CreateNewThread())
                {
                    //
                    // Always return a failure if we can not create a thread.
                    // Avoiding very rare deadlocks when rest of system is
                    // dependent on a request to finish.
                    //
                    return WBEM_E_OUT_OF_MEMORY;                    
                }    // IF !CreateNewThread

            }    // IF DoesNeedNewThread

        }    // ELSE !bNeedsAttention

        HRESULT hr = PlaceRequestInQueue( pRequest );

        long lIndex = m_lNumRequests;
        cs.Leave();

        if ( SUCCEEDED( hr ) )
        {
            SitOutPenalty(lIndex);
        }

        return hr;

    }   // end try
    catch(...)
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::Enqueue() exception\n"));
        return WBEM_E_CRITICAL_ERROR;
    }
}


//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
HRESULT CCoreQueue::EnqueueWithoutSleep(CCoreExecReq* pRequest, HANDLE* phWhenDone)
{
    try
    {

        CCritSecWrapper cs(&m_cs);

        if (m_bShutDownCalled) return WBEM_E_SHUTTING_DOWN;
        if (!pRequest->IsOk()) return WBEM_E_OUT_OF_MEMORY;

        // Create an event handle to signal when request is finished, if required
        // ======================================================================

        if(phWhenDone)
        {
            *phWhenDone = CreateEvent(NULL, FALSE, FALSE, NULL); 
            if (NULL == *phWhenDone)
                return WBEM_E_OUT_OF_MEMORY;
            pRequest->SetWhenDoneHandle(*phWhenDone);
        }

        cs.Enter();  

        // Search for a suitable thread
        // ============================

        for(int i = 0; i < m_aThreads.Size(); i++)
        {
            CThreadRecord* pRecord = (CThreadRecord*)m_aThreads[i];

            if(pRecord->m_bReady)
            {
                // Free. Check if suitable
                // =======================

                if(IsSuitableThread(pRecord, pRequest))
                {
                    pRecord->m_pCurrentRequest = pRequest;
                    pRecord->m_bReady = FALSE;
                    pRecord->Signal();
                    m_lNumIdle--;

                    // Done!
                    // =====

                    cs.Leave();
                    return WBEM_S_NO_ERROR;
                }
            }
        }

        // No suitable thread found. Add to the queue
        // ==========================================

        if(m_lNumRequests >= m_lAbsoluteLimitCount)
        {
            cs.Leave();
            return WBEM_E_FAILED;
        }

        // Search for insert position based on priority
        // ============================================

        AdjustInitialPriority(pRequest);

        // Create a new thread, if required
        // ================================
        if(DoesNeedNewThread(pRequest, true))
        {
            if (!CreateNewThread())
            {
                //
                // Always return a failure if we can not create a thread.
                // Avoiding very rare deadlocks when rest of system is
                // dependent on a request to finish.
                //
                return WBEM_E_OUT_OF_MEMORY;                
            }
        }

        HRESULT hr = PlaceRequestInQueue( pRequest );

        long lIndex = m_lNumRequests;
        cs.Leave();

        return hr;

    }   // end try
    catch(...)
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::EnqueueWithoutSleep() exception\n"));
        return WBEM_E_CRITICAL_ERROR;
    }
}

HRESULT CCoreQueue::PlaceRequestInQueue( CCoreExecReq* pRequest )
{
    CCoreExecReq* pCurrent = m_pHead;
    CCoreExecReq* pLast = NULL;

    // Tracks whether or not we need to cleanup the queue
    bool        bQueued = false;

    try
    {
        // Find a spot in the current queue based on priority
        while(pCurrent && pCurrent->GetPriority() <= pRequest->GetPriority())
        {
            pLast = pCurrent;
            pCurrent = pCurrent->GetNext();
        }

        // Insert
        // ======

        // If we have a pCurrent pointer, then pRequest is higher in priority, so should
        // be inserted before it.  Otherwise, we are inserting at the end of the queue

        if(pCurrent)
        {
            pRequest->SetNext(pCurrent);
        }
        else
        {
            m_pTail = pRequest;
        }

        // If we have a pLast pointer, we need to point it at pRequest, otherwise, we
        // are inserting at the head of the queue.
        if(pLast)
        {
            pLast->SetNext(pRequest);
        }
        else
        {
            m_pHead = pRequest;
        }

        m_lNumRequests++;

        bQueued = true;

        // Adjust priorities of the loosers
        // ================================

        while(pCurrent)
        {
            AdjustPriorityForPassing(pCurrent);
            pCurrent = pCurrent->GetNext();
        }

        return WBEM_S_NO_ERROR;
    }
    catch( ... )
    {
        // Fixup the queue if necessary
        if ( bQueued )
        {
            // Fixup the tail to point to the last request
            if ( pRequest == m_pTail )
            {
                m_pTail = pLast;
            }

            // Fixup the head to point to the next request
            if ( pRequest == m_pHead )
            {
                m_pHead = pRequest->GetNext();
            }

            // Fixup pLast to skip over the current request
            if ( NULL != pLast )
            {
                pLast->SetNext( pRequest->GetNext() );
            }

            // Decrement this
            m_lNumRequests--;

        }

        return WBEM_E_CRITICAL_ERROR;
    }

}

DWORD CCoreQueue::CalcSitOutPenalty(long lRequestIndex)
{
    if(lRequestIndex <= m_lStartSlowdownCount)
        return 0; // no penalty

    if(lRequestIndex >= m_lAbsoluteLimitCount)
        lRequestIndex = m_lAbsoluteLimitCount;

    // Calculate the timeout
    // =====================

    double dblTimeout =
        m_dblAlpha / (m_lAbsoluteLimitCount - lRequestIndex) +
            m_dblBeta;

    // Return penalty
    // ===========

    return ((DWORD) dblTimeout);
}

void CCoreQueue::SitOutPenalty(long lRequestIndex)
{
    DWORD   dwSitOutPenalty = CalcSitOutPenalty( lRequestIndex );

    // Sleep on it
    // ===========

    if ( 0 != dwSitOutPenalty )
    {
        Sleep( dwSitOutPenalty );
    }
}


HRESULT CCoreQueue::EnqueueAndWait(CCoreExecReq* pRequest)
{
    if(IsAppropriateThread())
    {
        pRequest->Execute();
        delete pRequest;
        return WBEM_S_NO_ERROR;
    }

    HANDLE hWhenDone = NULL;
    HRESULT hr = Enqueue(pRequest, &hWhenDone);

    // Scoped closing of the handle
    CCloseMe    cmWhenDone( hWhenDone );

    if ( FAILED(hr) )
    {
        return hr;
    }

    DWORD dwRes = CCoreQueue::QueueWaitForSingleObject(hWhenDone, INFINITE);

    return ( dwRes == WAIT_OBJECT_0 ? WBEM_S_NO_ERROR : WBEM_E_FAILED );
}


BOOL CCoreQueue::DoesNeedNewThread(CCoreExecReq* pRequest, bool bIgnoreNumRequests )
{
    // We will ignore the number or requests ONLY if requested
    // Default is to check if there are any threads in the queue

    if(m_lNumIdle > 0 || ( !bIgnoreNumRequests && m_lNumRequests == 0 ) )
        return FALSE;

    if(m_lNumThreads < m_lMaxThreads)
        return TRUE;
    else if(pRequest->GetPriority() <= m_lHiPriBound &&
            m_lNumThreads < m_lHiPriMaxThreads)
        return TRUE;
    else
        return FALSE;
}

//
// takes ownership of the CCoreExecRequest
//  
///////////////////////////////////////////////////////////
BOOL CCoreQueue::pExecute(CThreadRecord* pRecord)
{
    wmilib::auto_ptr<CCoreExecReq> pReq( pRecord->m_pCurrentRequest);
    CAutoSignal SetMe(pReq->GetWhenDoneHandle());
    NullPointer NullMe((PVOID *)&pRecord->m_pCurrentRequest);

    HRESULT hres;
    {
#ifdef WMI_PRIVATE_DBG
#ifdef DBG
        CTestNullTokenOnScope Test(__LINE__,__FILE__);
#endif
#endif
        hres =  pReq->Execute();
    }

    if(FAILED(hres))
    {
        LogError(pReq.get(), hres);
        return FALSE;
    }
        
    return TRUE;
}

BOOL CCoreQueue::Execute(CThreadRecord* pRecord)
{
    __try
    {
        return pExecute(pRecord);
    }
    __except(ExceptFilter(GetExceptionInformation(),GetExceptionCode()))
    {
        return FALSE;
    }    
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CCoreQueue::LogError(CCoreExecReq* pRequest, int nRes)
{
    try
    {
        //DbgPrintfA(0,"Error %08x occured executing request for %S\n", nRes,pRequest->GetReqInfo());
        DEBUGTRACE((LOG_WBEMCORE,"Error %08x occured executing request for %S\n", nRes,pRequest->GetReqInfo()));
        pRequest->DumpError();
    }
    catch (CX_MemoryException &)
    {
        // we might be using Internal CWbemClass|Instance
        // interfaces that throws.
        // the caller thread is unprepared to handle exceptions ...
    }
}

HRESULT CCoreQueue::InitializeThread()
{
    return InitializeCom();
}

void CCoreQueue::UninitializeThread()
{
    CoUninitialize();
}


CCoreExecReq* CCoreQueue::SearchForSuitableRequest(CThreadRecord* pRecord)
{
    try
    {
        CWmiArbitrator* pArb = (CWmiArbitrator*)pRecord->m_pArb;

        // Assumes in critical section
        // ===========================

        CCoreExecReq* pCurrent = m_pHead;
        CCoreExecReq* pPrev = NULL;

        while(pCurrent)
        {
            if(IsSuitableThread(pRecord, pCurrent))
            {
                // Always except dependent requests, otherwise, we only accept requests if we are accepting
                // new tasks

                if ( IsDependentRequest( pCurrent ) || pArb->AcceptsNewTasks(pCurrent) )
                {
                    // Found one --- take it
                    // =====================

                    if(pPrev)
                        pPrev->SetNext(pCurrent->GetNext());
                    else
                        m_pHead = pCurrent->GetNext();

                    if(pCurrent == m_pTail)
                        m_pTail = pPrev;

                    m_lNumRequests--;
                    break;
                }
                else
                {
                    // This means we have a primary task *and* we are not accepting new tasks.  Since there
                    // should NEVER be dependent tasks following primary tasks, we'll give up now.

                    pCurrent = NULL;
                    break;
                }
            }

            pPrev = pCurrent;
            pCurrent = pCurrent->GetNext();
        }

        return pCurrent;

    }   // end try
    catch(...)
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::SearchForSuitableRequest() exception\n"));
        return NULL;
    }
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
void CCoreQueue::ThreadMain(CThreadRecord* pRecord)
{
    if (FAILED(InitializeThread())) return;
    
    CCritSecWrapper cs(&m_cs);    

    // Register this queue with this thread, so any further wait would be
    // interruptable
    // ==================================================================

    Register(pRecord);
    OnDelete0<void(*)(void),&CCoreQueue::Unregister> UnRegMe;

    while (1)
    {
        // Returning from work. At this point, our event is not signaled,
        // our m_pCurrentRequest is NULL and our m_bReady is FALSE
        // ====================================================================

        // Search for work in the queue
        // ============================

        cs.Enter(); 

        CCoreExecReq* pCurrent = SearchForSuitableRequest(pRecord);
        if(pCurrent)
        {
            // Found some. Take it
            // ===================

            pRecord->m_pCurrentRequest = pCurrent;
        }
        else
        {
            // No work in the queue. Wait
            // ==========================

            pRecord->m_bReady = TRUE;
            m_lNumIdle++;
            DWORD dwTimeout = GetIdleTimeout(pRecord);
            cs.Leave();
            DWORD dwRes = WbemWaitForSingleObject(pRecord->m_hAttention,
                                        dwTimeout);
            cs.Enter(); 

            if(dwRes != WAIT_OBJECT_0)
            {
                // Check if someone managed to place a request in our record
                // after the timeout.
                // =========================================================

                if(WbemWaitForSingleObject(pRecord->m_hAttention, 0) ==
                    WAIT_OBJECT_0)
                {
                    DEBUGTRACE((LOG_WBEMCORE, "AMAZING: Thread %p received "
                        "request %p after timing out. Returning to the "
                        "queue\n", pRecord, pRecord->m_pCurrentRequest));

                    if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
                    {
                        ShutdownThread(pRecord);
                        cs.Leave();
                        return;
                    }
                    pRecord->m_pQueue->Enqueue(pRecord->m_pCurrentRequest);
                    pRecord->m_pCurrentRequest = NULL;
                }

                // Timeout. See if it is time to quit
                // ==================================

                pRecord->m_bReady = FALSE;
                if(IsIdleTooLong(pRecord, dwTimeout))
                {
                    ShutdownThread(pRecord);
                    cs.Leave();
                    return;
                }

                // Go and wait a little more
                // =========================

                m_lNumIdle--;
                cs.Leave();
                continue;
            }
            else
            {
                // Check why we were awaken
                // ========================

                if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
                {
                    ShutdownThread(pRecord);
                    cs.Leave();
                    return;
                }

                // We have a request. Enqueue already adjusted lNumIdle and
                // our m_bReady;
            }
        }

        // Execute the request
        // ===================

        cs.Leave();
        Execute(pRecord);

    }
}

DWORD CCoreQueue::GetIdleTimeout(CThreadRecord* pRecord)
{
    if(m_lNumThreads > m_lMaxThreads)
        return m_dwOverflowTimeout;
    else
        return m_dwTimeout;
}

BOOL CCoreQueue::IsIdleTooLong(CThreadRecord* pRecord, DWORD dwTimeout)
{
    if(m_lNumThreads > m_lMaxThreads)
        return TRUE;
    else if(dwTimeout < m_dwTimeout)
        return FALSE;
    else if ( m_lNumRequests > 0 && m_lNumThreads == 1 )
    {
        // If there are requests in the queue, and we're the only thread in the system, we shouldn't die.
        // The likelihood is that memory usage is causing the arbitrator to refuse tasks, and therefore
        // also disabling us from servicing requests (see SearchForSuitableRequest).
        return FALSE;
    }
    else
        return TRUE;
}

void CCoreQueue::ShutdownThread(CThreadRecord* pRecord)
{
    try
    {
        CCritSecWrapper cs(&m_cs);
        cs.Enter();      
        
        g_QueueTlsIndex.Set(NULL);
        for(int i = 0; i < m_aThreads.Size(); i++)
        {
            if(m_aThreads[i] == pRecord)
            {
                m_aThreads.RemoveAt(i);

                // Make sure we don't close the handle if the queue's Shutdown is
                // waiting on it
                // ==============================================================

                if(pRecord->m_bExitNow)
                    pRecord->m_hThread = NULL;
                delete pRecord;
                m_lNumIdle--;
                m_lNumThreads--;

                break;
            }
        }
        UninitializeThread();
        cs.Leave();

    }   // end try
    catch(...)
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::ShutdownThread() exception\n"));
    }
}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
// static
extern LONG g_lCoreThreads;

DWORD WINAPI CCoreQueue::_ThreadEntry(LPVOID pObj)
{

    try
    {
        InterlockedIncrement(&g_lCoreThreads);

        RecordPeakThreadCount ( );

        CThreadRecord* pRecord = (CThreadRecord*)pObj;
        CCoreQueue* pQueue = pRecord->m_pQueue;
        if(pQueue)
        {
            pQueue->AddRef();
            pQueue->ThreadMain(pRecord);
            pQueue->Release();
        }

        InterlockedDecrement(&g_lCoreThreads);

    }   // end try
    catch(...)
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::_ThreadEntry() unhandled exception\n"));
    }

    return 0;
}

DWORD WINAPI CCoreQueue::_ThreadEntryRescue (LPVOID pObj)
{
    try
    {        
        InterlockedIncrement ( &m_lEmergencyThreads ) ;
        RecordPeakThreadCount ( );

        CThreadRecord* pRecord = (CThreadRecord*)pObj;
        CCoreQueue* pQueue = pRecord->m_pQueue;
        if(pQueue)
        {
            pQueue->AddRef();

            CWmiArbitrator* pArb = (CWmiArbitrator*)pRecord->m_pArb;

            if (pArb) pArb->DecUncheckedCount();

            pQueue->ThreadMain(pRecord);

            if (pArb) pArb->IncUncheckedCount();

            pQueue->Release();
        }

        InterlockedDecrement ( &m_lEmergencyThreads ) ;

        return 0;
    }   // end try
    catch(...)
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::ThreadEntryRescue() exception\n"));
        return 0;
    }

}

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
BOOL CCoreQueue::CreateNewThread ( BOOL bNeedsAttention )
{
    try
    {
        CInCritSec ics(&m_cs);

        // Create new thread record
        // ========================

        wmilib::auto_ptr<CThreadRecord> pNewRecord( new CThreadRecord(this)); // throws
        if (NULL == pNewRecord.get()) return FALSE;
        if (CFlexArray::no_error != m_aThreads.Add(pNewRecord.get())) return FALSE;

        DWORD dwId;
        if ( !bNeedsAttention )
        {
            pNewRecord->m_hThread = CreateThread(0, 0, _ThreadEntry, pNewRecord.get(), 0,
                                                    &dwId);
        }
        else
        {
            pNewRecord->m_hThread = CreateThread(0, 0, _ThreadEntryRescue, pNewRecord.get(), 0,
                                                    &dwId);
        }

        if(NULL == pNewRecord->m_hThread)
        {
            m_aThreads.RemoveAt(m_aThreads.Size()-1);
            return FALSE;
        }

        pNewRecord.release(); // FlexArray took ownership
        m_lNumThreads++;
        return TRUE;
    }   // end try
    catch(CX_Exception &)
    {
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::CreateNewThread() exception\n"));
        return FALSE;
    }
}

DWORD CompensateForBug(DWORD dwOriginal, DWORD dwElapsed)
{
    if(dwOriginal == 0xFFFFFFFF)
        return 0xFFFFFFFF;

    DWORD dwLeft = dwOriginal - dwElapsed;
    if(dwLeft > 0x7FFFFFFF)
        dwLeft = 0x7FFFFFFF;

    return dwLeft;
}

DWORD CCoreQueue::WaitForSingleObjectWhileBusy(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    CCoreExecReq* pOld = pRecord->m_pCurrentRequest;
    DWORD dwStart = GetTickCount();
    while (dwWait > GetTickCount() - dwStart)
    {
        // Search for work in the queue
        // ============================

        cs.Enter();
        CCoreExecReq* pCurrent = SearchForSuitableRequest(pRecord);
        if(pCurrent != NULL)
        {
            pRecord->m_pCurrentRequest = pCurrent;

            if(pRecord->m_pCurrentRequest == pOld)
            {
                // Something is very wrong
                // =======================
            }
        }
        else
        {
            // No work in the queue. Wait
            // ==========================

            pRecord->m_bReady = TRUE;

            // Block until a request comes through.
            // ====================================

            HANDLE ahSems[2];
            ahSems[0] = hHandle;
            ahSems[1] = pRecord->m_hAttention;

            cs.Leave();
            DWORD dwLeft = CompensateForBug(dwWait, (GetTickCount() - dwStart));
            DWORD dwRes = WbemWaitForMultipleObjects(2, ahSems, dwLeft);

            cs.Enter();

            pRecord->m_bReady = FALSE;
            if(dwRes != WAIT_OBJECT_0 + 1)
            {
                // Either our target handle is ready or we timed out
                // =================================================

                // Check if anyone placed a request in our record
                // ==============================================

                if(pRecord->m_pCurrentRequest != pOld)
                {
                    // Re-issue it to the queue
                    // ========================

                    pRecord->m_pQueue->Enqueue(pRecord->m_pCurrentRequest);
                    pRecord->m_pCurrentRequest = pOld;

                    // Decrement our semaphore
                    // =======================

                    dwRes = WaitForSingleObject(pRecord->m_hAttention, 0);
                    if(dwRes != WAIT_OBJECT_0)
                    {
                        // Internal error --- whoever placed the request had
                        // to have upped the semaphore
                        // =================================================

                        ERRORTRACE((LOG_WBEMCORE, "Internal error: queue "
                            "semaphore is too low\n"));
                    }
                }

                cs.Leave();
                return dwRes;
            }
            else
            {
                // Check why we were awaken
                // ========================

                if(pRecord->m_bExitNow || pRecord->m_pCurrentRequest == NULL)
                {
                    // Can't exit in the middle of a request. Leave it for later
                    // =========================================================

                    pRecord->Signal();
                    cs.Leave();
                    DWORD dwLeft = CompensateForBug(dwWait,
                                        (GetTickCount() - dwStart));
                    return WbemWaitForSingleObject(hHandle, dwLeft);
                }

                // We've got work to do
                // ====================

                if(pRecord->m_pCurrentRequest == pOld)
                {
                    // Something is very wrong
                    // =======================
                }
            }
        }

        // Execute the request
        // ===================

        cs.Leave();
        Execute(pRecord);
        pRecord->m_pCurrentRequest = pOld;

    }
    return WAIT_TIMEOUT;
}

DWORD CCoreQueue::UnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord)
{
    CCritSecWrapper cs(&m_cs);

    // Silently bump the max threads count.  We will not allow the queue to reuse
    // this thread, so we need to account for this missing thread while we
    // are blocked.  Essentially, we are hijacking the code that was hijacking
    // the thread

    cs.Enter();
        m_lMaxThreads++;
        m_lHiPriMaxThreads++;
    cs.Leave();

    DWORD   dwRet = WbemWaitForSingleObject( hHandle, dwWait );

    // The thread is back, so bump down the max threads number.  If extra threads were in
    // fact created, they should eventually peter out and go away.
    cs.Enter(); 
        m_lMaxThreads--;
        m_lHiPriMaxThreads--;
    cs.Leave();

    return dwRet;
}


// static
DWORD CCoreQueue::ExceptFilter(LPEXCEPTION_POINTERS pExcptPtrs,DWORD Status)
{
    ExceptionCounter c;

    EXCEPTION_RECORD * pRec = pExcptPtrs->ExceptionRecord;

    ERRORTRACE((LOG_WBEMCORE, "CCoreQueue exception %08x\n",Status));
    switch(Status)
    {
    case STATUS_ACCESS_VIOLATION:
        ERRORTRACE((LOG_WBEMCORE," exr addr %p\n",pRec->ExceptionAddress));
        for (DWORD i=0;i<pRec->NumberParameters;i++)
        {
            ERRORTRACE((LOG_WBEMCORE," exr p[%d] %p\n",i,pRec->ExceptionInformation[i]));
        }
        break;
    default:
        break;
    }
    
    return EXCEPTION_EXECUTE_HANDLER;
};

//******************************************************************************
//
//  See dbgalloc.h for documentation
//
//******************************************************************************
// static
DWORD CCoreQueue::QueueWaitForSingleObject(HANDLE hHandle, DWORD dwWait)
{
    __try
    {

        // Get the queue that is registered for this thread, if any
        // ========================================================

        CThreadRecord* pRecord = (CThreadRecord*)g_QueueTlsIndex.Get(); 

        if(pRecord == NULL)
        {
            // No queue is registered with this thread. Just wait
            // ==================================================

            return WbemWaitForSingleObject(hHandle, dwWait);
        }

        CCoreQueue* pQueue = pRecord->m_pQueue;

        return pQueue->WaitForSingleObjectWhileBusy(hHandle, dwWait, pRecord);

    }
    __except(ExceptFilter(GetExceptionInformation(),GetExceptionCode()))
    {
        return WAIT_TIMEOUT;
    }
}

// static
DWORD CCoreQueue::QueueUnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait)
{
    __try
    {
        // Get the queue that is registered for this thread, if any
        // ========================================================

        CThreadRecord* pRecord = (CThreadRecord*)g_QueueTlsIndex.Get();

        if(pRecord == NULL)
        {
            // No queue is registered with this thread. Just wait
            // ==================================================

            return WbemWaitForSingleObject(hHandle, dwWait);
        }

        CCoreQueue* pQueue = pRecord->m_pQueue;

        return pQueue->UnblockedWaitForSingleObject(hHandle, dwWait, pRecord);

    }   // end try
    __except(ExceptFilter(GetExceptionInformation(),GetExceptionCode()))
    {
        return WAIT_TIMEOUT;
    }    
}

BOOL CCoreQueue::SetThreadLimits(long lMaxThreads, long lHiPriMaxThreads,
                                    long lHiPriBound)
{
    m_lMaxThreads = lMaxThreads;
    if(lHiPriMaxThreads == -1)
        m_lHiPriMaxThreads = lMaxThreads * 1.1;
    else
        m_lHiPriMaxThreads = lHiPriMaxThreads;
    m_lHiPriBound = lHiPriBound;

    BOOL bRet = TRUE;

    while(DoesNeedNewThread(NULL) && bRet)
    {
        bRet = CreateNewThread();
    }

    return bRet;
}

BOOL CCoreQueue::IsAppropriateThread()
{
    // Get the queue that is registered for this thread, if any
    // ========================================================

    CThreadRecord* pRecord = (CThreadRecord*)g_QueueTlsIndex.Get();

    if(pRecord == NULL)
        return FALSE;

    CCoreQueue* pQueue = pRecord->m_pQueue;
    if(pQueue != this)
        return FALSE;

    return TRUE;
}

void CCoreQueue::SetRequestLimits(long lAbsoluteLimitCount,
                              long lStartSlowdownCount,
                              long lOneSecondDelayCount)
{
    CCritSecWrapper cs(&m_cs);

    cs.Enter();     // SEC:REVIEWED 2002-03-22 : Assumes success, needs EH

    m_lAbsoluteLimitCount = lAbsoluteLimitCount;

    m_lStartSlowdownCount = lStartSlowdownCount;
    if(m_lStartSlowdownCount < 0)
    {
        m_lStartSlowdownCount = m_lAbsoluteLimitCount / 2;
    }

    m_lOneSecondDelayCount = lOneSecondDelayCount;

    if(m_lOneSecondDelayCount < 0)
    {
        m_lOneSecondDelayCount =
            m_lAbsoluteLimitCount * 0.2 + m_lStartSlowdownCount * 0.8;
    }

    // Calculate coefficients
    // ======================

    m_dblBeta =
        1000 *
        ((double)m_lAbsoluteLimitCount - (double)m_lOneSecondDelayCount) /
        ((double)m_lStartSlowdownCount - (double)m_lOneSecondDelayCount);

    m_dblAlpha = m_dblBeta *
        ((double)m_lStartSlowdownCount - (double)m_lAbsoluteLimitCount);
    cs.Leave();
}


BOOL CCoreQueue::IsDependentRequest ( CCoreExecReq* pRequest )
{
    try
    {
        BOOL bRet = FALSE;
        
        if ( pRequest )
        {
            CWbemRequest* pWbemRequest = (CWbemRequest*) pRequest ;
            if ( pWbemRequest )
            {
                if ( !pWbemRequest->IsDependee ( ) )
                {
                    CWmiTask* pTask = (CWmiTask*) pRequest->m_phTask;
                    if ( pTask )
                    {
                        CWbemNamespace* pNamespace = (CWbemNamespace*) pTask->GetNamespace ( );
                        if ( pNamespace )
                        {
                            if ( pNamespace->GetIsProvider ( ) || pNamespace->GetIsESS ( ) )
                            {
                                bRet = TRUE;
                            }
                        }
                    }
                }
                else
                {
                    bRet = TRUE;
                }
            }
        }
        return bRet;

    }   // end try
    catch(...)
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "CCoreQueue::IsDependentRequest() exception\n"));
        return FALSE;
    }
}



VOID CCoreQueue::RecordPeakThreadCount (  )
{
    if ( ( g_lCoreThreads + m_lEmergencyThreads ) > m_lPeakThreadCount )
    {
        m_lPeakThreadCount = g_lCoreThreads + m_lEmergencyThreads ;
    }
    if ( m_lEmergencyThreads > m_lPeakEmergencyThreadCount )
    {
        m_lPeakEmergencyThreadCount = m_lEmergencyThreads;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\coreq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    EXECQ.H

Abstract:

  Defines classes related to execution queues.

  Classes defined:

      CCoreExecReq    An abstract request.
      CCoreQueue      A queue of requests with an associated thread

History:

      23-Jul-96     raymcc    Created.
      3/10/97       levn      Fully documented
      9/6/97        levn      Rewrote for thread pool
      2-May-00      raymcc    Decoupled from shared ESS version for tasks
                              & quotas

--*/

#ifndef __EXECQUEUE__H_
#define __EXECQUEUE__H_

#include "sync.h"
#include "wbemutil.h"

#ifdef __COLLECT_ALLOC_STAT
   #include "stackcom.h"
#endif

#include "wbemint.h"

enum QueuePriorities
{
    PriorityFreeMemRequests = 0x80000000,
    PriorityCriticalRequests = 0x80000001,
    PriorityForceRunRequests = 0xA0000000,
    PriorityNeedsAttentionRequests = 0xA0000001
};

//******************************************************************************
//******************************************************************************
//
//  class CCoreExecReq
//
//  Abstract base class for any schedulable request
//
//******************************************************************************
//
//  Execute
//
//  Primary method. Executes the request, whatever that means.
//
//  Returns:
//
//      int:    return code. 0 means success, everything else --- failure.
//              Exact error codes are request-specific.
//
//******************************************************************************

class CCoreExecReq
{
protected:
    HANDLE m_hWhenDone;
    CCoreExecReq* m_pNext;
    long m_lPriority;
    bool m_fOk;
public:
    _IWmiCoreHandle *m_phTask;

    void SetWhenDoneHandle(HANDLE h) {m_hWhenDone = h;}
    HANDLE GetWhenDoneHandle() {return m_hWhenDone;}
    void SetNext(CCoreExecReq* pNext) {m_pNext = pNext;}
    CCoreExecReq* GetNext() {return m_pNext;}
    void SetPriority(long lPriority) {m_lPriority = lPriority;}
    long GetPriority() {return m_lPriority;}
    virtual void DumpError(){   DEBUGTRACE((LOG_WBEMCORE,"No additional info\n"));};
    virtual LPCWSTR GetReqInfo() = 0;
public:
    CCoreExecReq();
    virtual ~CCoreExecReq();
    virtual HRESULT Execute() = 0;
    virtual HRESULT SetTaskHandle(_IWmiCoreHandle *phTask);
    bool IsOk(){ return  m_fOk; };

#ifdef WINMGMT_THREAD_DEBUG
    static CCritSec mstatic_cs;
    static CPointerArray<CCoreExecReq> mstatic_apOut;
#endif
    
};

class CDavidsRequest
{
protected:
    LPTHREAD_START_ROUTINE m_pfn;
    void* m_pParam;
public:
    CDavidsRequest(LPTHREAD_START_ROUTINE pFunctionToExecute, void* pParam)
        : m_pfn(pFunctionToExecute), m_pParam(pParam)
    {}
    HRESULT Execute()
    {
        return (HRESULT)m_pfn(m_pParam);
    }
};

//******************************************************************************
//******************************************************************************
//
//  class CCoreQueue
//
//  CCoreQueue represents the concept of a queue of requests with an associated
//  thread to execute those requests. In a lot of respects, it is similar to
//  a message queue. Requests are added to the queue (which is represented by
//  an array) and the thread (created by the Run function) picks them up one
//  by one and executes them.
//
//  The trick is what to do if while processing one request, another one
//  is generated and needs to be processed before the first one succeeds. This
//  is similar to a SendMessage, but trickier: the thread generating the new
//  request may not be the thread attached to the queue!
//
//  To overcome this problem, we make all our waits interruptible in the
//  following sense. Whenever the thread attached to the queue needs to block
//  waiting for something to happen (which is when another thread may post a
//  new request and deadlock the system), it uses QueueWaitForSingleObject
//  instead. This function will wait for the object that the thread wanted to
//  wait for but it will also wake up if a new Critical request is added to
//  the queue and process any such request while waiting.
//
//  See QueueWaitForSingleObject for details.
//
//  Operations of CCoreQueue are protected by a critical section, so multiple
//  threads can add requests simultaneously.
//
//******************************************************************************
//
//  Constructor
//
//  Creates and initializes all the synchronization objects, as well as the
//  thread local storage required by QueueWaitForSingleObject.
//
//******************************************************************************
//
//  Destructor
//
//  Deletes synchronization objects.
//
//******************************************************************************
//
//  virtual Enqueue
//
//  Adds a request to the queue. The acction depends on whether the request is
//  critical or not.  If not, it is added to the queue and the semaphor of
//  non-critical requests is incremented. The processing thread will pick it up
//  in FIFO order. If critical, request is added to the front of the queye and
//  the semaphor of critical requests is incremented. This will cause the
//  processing thread to take this request the next time it enters into a
//  waiting state (see QueueWaitForSingleObject).
//
//******************************************************************************
//
//  QueueWaitForSingleObject
//
//  The core of the trick. In WINMGMT, whenever a thread needs to wait for an
//  object, it calls this function instead. This function checks if the calling
//  thread is the registered processing thread for any CCoreQueue object (by
//  looking up the m_dwTlsIndex thread local variable for the thread). If it
//  is not, the function simply calls WaitForSingleObject.
//
//  If it is, the function queries the queue for the semaphore indicating the
//  number of critical requests on the queue. It then calls
//  WaitForMultipleObjects with the original handle and the semaphore. If the
//  semaphore is signaled during the wait (or was singlaled when we came in),
//  this function picks up the first requests on the queue and executes it;
//  once that request is complete, it resumes the wait (with adjusted timeout).
//
//  Parameters:
//
//      HANDLE hHandle      The handle of synchronization object to wait for.
//      DWORD dwTimeout     Timeout in milliseconds.
//
//  Returns:
//
//      Same values as WaitForSingleObject:
//          WAIT_OBJECT_0   hHandle became signaled
//          WAIT_TIMEOUT    Timed out.
//
//******************************************************************************
//**************************** protected ***************************************
//
//  Register
//
//  Registers the calling thread as the processing thread of this queue by
//  storing the pointer to the queue in the m_dwTlsIndex thread local storage
//  variable. QueueWaitForSingleObject reads this index to interrupt waits
//  when needed (see QueueWaitForSingleObject).
//
//  Returns:
//
//      CCoreQueue*:    the previous CCoreQueue this thread was registered for,
//                      or NULL if none. The caller MUST not delete this object.
//
//******************************************************************************
//
//  ThreadMain
//
//  This is the function that the thread created by Run executes.  It sits in
//  an infinite loop, retrieving requests and executing them one by one.
//  This function never returns.
//
//******************************************************************************
//
//  Dequeue
//
//  Retrieves the request at the head of the queue and removes it from the
//  queue.
//
//  Returns:
//
//      CCoreExecReq*:  the request that was at the head of the queue, or NULL
//                      if the queue was empty. The caller must delete this
//                      object when no longer needed.
//
//******************************************************************************
//
//  static _ThreadEntry
//
//  Stub function used to create the tread. Calls ThreadEntry on the real
//  CCoreQueue.
//
//  Parameters:
//
//      LPVOID pObj     Actually CCoreQueue* to the queue this thread is
//                      supposed to serve.
//
//  Returns:
//
//      never.
//
//******************************************************************************
//
//  GetNormalReadyHandle
//
//  Returns the handle to the semaphore which contains the number of
//  non-critical requests currently on the queue.
//
//  Returns:
//
//      HANDLE: the the semaphore
//
//******************************************************************************
//
//  GetCriticalReadyHandle
//
//  Returns the handle to the semaphore which contains the number of
//  critical requests currently on the queue.
//
//  Returns:
//
//      HANDLE: the the semaphore
//
//******************************************************************************
//
//  Execute
//
//  Dequeues and executes a single request.
//
//******************************************************************************

class CCoreQueue
{
protected:
    class CThreadRecord
    {
    public:
        CCoreQueue* m_pQueue;
        CCoreExecReq * m_pCurrentRequest;
        BOOL m_bReady;
        BOOL m_bExitNow;
        HANDLE m_hThread;
        HANDLE m_hAttention;
        _IWmiArbitrator * m_pArb;

    public:
        CThreadRecord(CCoreQueue* pQueue);
        ~CThreadRecord();
        void Signal();
    };

protected:


    long m_lRef;
    CCritSec m_cs;

    BOOL m_bShutDownCalled;

    CFlexArray m_aThreads;
    CCoreExecReq* m_pHead;
    CCoreExecReq* m_pTail;

    long m_lNumThreads;
    long m_lNumIdle;
    long m_lNumRequests;


    long m_lMaxThreads;
    long m_lHiPriBound;
    long m_lHiPriMaxThreads;

    long m_lStartSlowdownCount;
    long m_lAbsoluteLimitCount;
    long m_lOneSecondDelayCount;

    double m_dblAlpha;
    double m_dblBeta;

    DWORD m_dwTimeout;
    DWORD m_dwOverflowTimeout;

    _IWmiArbitrator* m_pArbitrator;

    static long m_lEmergencyThreads;    
    static long m_lPeakThreadCount;
    static long m_lPeakEmergencyThreadCount;

private:
	HRESULT PlaceRequestInQueue( CCoreExecReq* pReq );

protected:
    virtual void ThreadMain(CThreadRecord* pRecord);

    virtual void LogError(CCoreExecReq* pRequest, int nRes);

    static DWORD WINAPI _ThreadEntry(LPVOID pObj);
    static DWORD WINAPI _ThreadEntryRescue(LPVOID pObj);


    virtual HRESULT InitializeThread();
    virtual void UninitializeThread();
    virtual BOOL CreateNewThread( BOOL = FALSE );
    static void Register(CThreadRecord* pRecord);
    static void Unregister();
    
    virtual void ShutdownThread(CThreadRecord* pRecord);

    virtual BOOL IsSuitableThread(CThreadRecord* pRecord, CCoreExecReq* pReq);
    virtual BOOL DoesNeedNewThread(CCoreExecReq* pReq, bool bIgnoreNumRequests = false );
    virtual BOOL IsIdleTooLong(CThreadRecord* pRecord, DWORD dwIdle);
    virtual DWORD GetIdleTimeout(CThreadRecord* pRecord);
    virtual BOOL IsAppropriateThread();
    virtual DWORD WaitForSingleObjectWhileBusy(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord);

	virtual DWORD UnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait,
                                                CThreadRecord* pRecord);

    virtual BOOL Execute(CThreadRecord* pRecord);
    virtual BOOL pExecute(CThreadRecord* pRecord);
    virtual BOOL IsSTA() {return FALSE;}
    virtual CCoreExecReq* SearchForSuitableRequest(CThreadRecord* pRecord);
    virtual void SitOutPenalty(long lRequestIndex);
    virtual DWORD CalcSitOutPenalty(long lRequestIndex);

    virtual void AdjustInitialPriority(CCoreExecReq* pRequest){}
    virtual void AdjustPriorityForPassing(CCoreExecReq* pRequest){}

    virtual BOOL IsDependentRequest ( CCoreExecReq* pRequest);
	static  VOID RecordPeakThreadCount ( ) ;

public:
    CCoreQueue();
    ~CCoreQueue();

    void AddRef() {InterlockedIncrement(&m_lRef);}
    void Release() {if(InterlockedDecrement(&m_lRef) == 0) delete this;}
    static DWORD GetTlsIndex();
	static DWORD GetSecFlagTlsIndex ( ) ;
    void Enter();
    void Leave();

    virtual HRESULT Enqueue(CCoreExecReq* pRequest, HANDLE* phWhenDone = NULL);
	HRESULT EnqueueWithoutSleep(CCoreExecReq* pRequest, HANDLE* phWhenDone = NULL );
    HRESULT EnqueueAndWait(CCoreExecReq* pRequest);

    virtual LPCWSTR GetType() = 0; 

    BOOL SetThreadLimits(long lMaxThreads, long lHiPriMaxThreads = -1,
                            long lHiPriBound = 0);
    void SetIdleTimeout(DWORD dwTimeout) {m_dwTimeout = dwTimeout;}
    void SetOverflowIdleTimeout(DWORD dwTimeout)
        {m_dwOverflowTimeout = dwTimeout;}
    void SetRequestLimits(long lAbsoluteLimitCount,
            long lStartSlowdownCount = -1, long lOneSecondDelayCount = -1);

    void Shutdown(BOOL bIsSystemShutDown);

	DWORD GetSitoutPenalty( void ) { return CalcSitOutPenalty( m_lNumRequests ); }

    static DWORD QueueWaitForSingleObject(HANDLE hHandle, DWORD dwWait);
    static DWORD QueueUnblockedWaitForSingleObject(HANDLE hHandle, DWORD dwWait);

	// Helper function for new merger requests which execute requests that
	// are stored in the merger.

	static HRESULT ExecSubRequest( CCoreExecReq* pNewRequest );

	static long GetPeakThreadCount ( ) { return m_lPeakThreadCount ; }
	static long GetPeakEmergThreadCount ( ) { return m_lPeakEmergencyThreadCount ; }
	static long GetEmergThreadCount ( )	{ return m_lEmergencyThreads ; }
	void SetArbitrator(_IWmiArbitrator* pArbitrator);
	_IWmiArbitrator* GetArbitrator(){ _IWmiArbitrator* p = m_pArbitrator; if (p) p->AddRef(); return p; };

	static DWORD ExceptFilter(LPEXCEPTION_POINTERS pExcptPtrs,DWORD Status);
 };

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\coresvc.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    coresvc.h

Abstract:

    CCoreServices Class

History:

--*/

#ifndef __CORE_SERVICES__H_
#define __CORE_SERVICES__H_

#include "sync.h"

enum CntType{
    WMICORE_SELFINST_USERS = 0,             // absolute
    WMICORE_SELFINST_CONNECTIONS,           // absolute
    WMICORE_SELFINST_TASKS,                 // absolute
    WMICORE_SELFINST_TASKS_EXECUTED,        // increment-only
    WMICORE_SELFINST_BACKLOG_BYTES,         // absolute
    WMICORE_SELFINST_TOTAL_API_CALLS,       // increment-only
    WMICORE_SELFINST_INTERNAL_OBJECT_COUNT, // absolute
    WMICORE_SELFINST_SINK_COUNT,            // absolute
    WMICORE_SELFINST_STD_SINK_COUNT,        // absolute
    WMICORE_LAST_ENTRY                      // Insert all new entries in front of this
};

typedef DWORD (*PFN_SetCounter)(DWORD dwCounter, DWORD dwValue);

class CPerTaskHook : public _IWmiCoreWriteHook
{
private:
	
    CFlexArray m_HookList;
    ULONG m_uRefCount;
public:

    CPerTaskHook();
   ~CPerTaskHook();
	
        /* IUnknown methods */

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE QueryInterface(
        IN REFIID riid,
        OUT LPVOID *ppvObj
        );

        virtual HRESULT STDMETHODCALLTYPE PrePut(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pCopy
            );

        virtual HRESULT STDMETHODCALLTYPE PostPut(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hRes,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pNew,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            );

        virtual HRESULT STDMETHODCALLTYPE PreDelete(
            /* [in] */ long lFlags,
            /* [in] */ long lUserFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass
            );

        virtual HRESULT STDMETHODCALLTYPE PostDelete(
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hRes,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemPath __RPC_FAR *pPath,
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ _IWmiObject __RPC_FAR *pOld
            );

public:
        static HRESULT CreatePerTaskHook(OUT CPerTaskHook **pNew);
};


class CCoreServices : public _IWmiCoreServices
{
protected:
    friend class CPerTaskHook;

    long m_lRef;
    LIST_ENTRY m_Entry;    
	static _IWmiProvSS *m_pProvSS;
    static IWbemEventSubsystem_m4 *m_pEssOld;
    static _IWmiESS *m_pEssNew;
	static _IWbemFetchRefresherMgr* m_pFetchRefrMgr;
    static CStaticCritSec m_csHookAccess;

protected:
    bool IsProviderSubsystemEnabled();

public:
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

	// _IWmiCoreServices methods

        virtual HRESULT STDMETHODCALLTYPE GetObjFactory(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiObjectFactory __RPC_FAR *__RPC_FAR *pFact);

        virtual HRESULT STDMETHODCALLTYPE GetServices(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszUser,
            /* [in] */ LPCWSTR pszLocale,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices);

        virtual HRESULT STDMETHODCALLTYPE GetRepositoryDriver(
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pDriver);

        virtual HRESULT STDMETHODCALLTYPE GetCallSec(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiCallSec __RPC_FAR *__RPC_FAR *pCallSec);

        virtual HRESULT STDMETHODCALLTYPE GetProviderSubsystem(
            /* [in] */ long lFlags,
            /* [out] */ _IWmiProvSS __RPC_FAR *__RPC_FAR *pProvSS);

        virtual HRESULT STDMETHODCALLTYPE StopEventDelivery( void);

        virtual HRESULT STDMETHODCALLTYPE StartEventDelivery( void);

        virtual HRESULT STDMETHODCALLTYPE DeliverIntrinsicEvent(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ ULONG uType,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ LPCWSTR pszTransGuid,
            /* [in] */ ULONG uObjectCount,
            /* [in] */ _IWmiObject __RPC_FAR *__RPC_FAR *ppObjList);

        virtual HRESULT STDMETHODCALLTYPE DeliverExtrinsicEvent(
            /* [in] */ LPCWSTR pszNamespace,
            /* [in] */ ULONG uFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ _IWmiObject __RPC_FAR *pEvt);

        virtual HRESULT STDMETHODCALLTYPE GetSystemObjects(
            /* [in] */ ULONG lFlags,
            /* [out] */ ULONG __RPC_FAR *puArraySize,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pObjects);

        virtual HRESULT STDMETHODCALLTYPE GetSystemClass(
            /* [in] */ LPCWSTR pszClassName,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pClassDef);

        virtual HRESULT STDMETHODCALLTYPE GetConfigObject(
            ULONG uID,
            /* [out] */ _IWmiObject __RPC_FAR *__RPC_FAR *pCfgObject);

        virtual HRESULT STDMETHODCALLTYPE RegisterWriteHook(
            /* [in] */ ULONG uFlags,
            /* [in] */ _IWmiCoreWriteHook __RPC_FAR *pHook);

        virtual HRESULT STDMETHODCALLTYPE UnregisterWriteHook(
            /* [in] */ _IWmiCoreWriteHook __RPC_FAR *pHook);

        virtual HRESULT STDMETHODCALLTYPE CreateCache(
            /* [in] */ ULONG uFlags,
            /* [out] */ _IWmiCache __RPC_FAR *__RPC_FAR *pCache);

        virtual HRESULT STDMETHODCALLTYPE CreateFinalizer(
            /* [in] */ ULONG uFlags,
            /* [out] */ _IWmiFinalizer __RPC_FAR *__RPC_FAR *pFinalizer);

        virtual HRESULT STDMETHODCALLTYPE CreatePathParser(
            /* [in] */ ULONG uFlags,
            /* [out] */ IWbemPath __RPC_FAR *__RPC_FAR *pParser);

        virtual HRESULT STDMETHODCALLTYPE CreateQueryParser(
            /* [in] */ ULONG uFlags,
            /* [out] */ _IWmiQuery __RPC_FAR *__RPC_FAR *pQuery);

        virtual HRESULT STDMETHODCALLTYPE GetDecorator(
            /* [in] */ ULONG uFlags,
            /* [out] */ IWbemDecorator __RPC_FAR *__RPC_FAR *pDec);


        virtual HRESULT STDMETHODCALLTYPE IncrementCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam);

        virtual HRESULT STDMETHODCALLTYPE DecrementCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam);

        virtual HRESULT STDMETHODCALLTYPE SetCounter(
            /* [in] */ ULONG uID,
            /* [in] */ ULONG uParam);

        virtual HRESULT STDMETHODCALLTYPE GetSelfInstInstances(
            /* [in] */ LPCWSTR pszClass,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

        virtual HRESULT STDMETHODCALLTYPE GetServices2(
            /* [in] */ LPCWSTR pszPath,
            /* [in] */ LPCWSTR pszUser,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ ULONG uClientFlags,
            /* [in] */ DWORD dwSecFlags,
            /* [in] */ DWORD dwPermissions,
            /* [in] */ ULONG uInternalFlags,
            /* [in] */ LPCWSTR pszClientMachine,
            /* [in] */ DWORD dwClientProcessID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pServices);


        virtual HRESULT STDMETHODCALLTYPE NewPerTaskHook(
            /* [out] */ _IWmiCoreWriteHook __RPC_FAR *__RPC_FAR *pHook);

        virtual HRESULT STDMETHODCALLTYPE GetArbitrator(
            /* [out] */ _IWmiArbitrator __RPC_FAR *__RPC_FAR *pArb);


        virtual HRESULT STDMETHODCALLTYPE InitRefresherMgr(
			/* [in] */	long lFlags );

    CCoreServices();
    ~CCoreServices();
    static HRESULT InternalSetCounter(DWORD dwCounter, DWORD dwValue);

    static HRESULT DumpCounters(FILE *);

public:
    static CCoreServices *g_pSvc;

    static CCoreServices *CreateInstance() { CCoreServices * p = new CCoreServices;
                                             if (p) p->AddRef();
                                             return  p; }
	static HRESULT Initialize () ;
	static HRESULT UnInitialize () ;

    static HRESULT SetEssPointers(
        IWbemEventSubsystem_m4 *pEssOld,
        _IWmiESS               *pEssNew);
};


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\crep.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  CREP.CPP
//
//  Wrappers for repository drivers
//
//  raymcc  27-Apr-00       WMI Repository init & mapping layer
//
//***************************************************************************

#include "precomp.h"
#include <wbemcore.h>
#include <oahelp.inl>
#include <unk.h>

extern IClassFactory* g_pQueryFact;

// ESE only.
// =========

IWmiDbController *CRepository::m_pEseController = 0;
IWmiDbSession *CRepository::m_pEseSession = 0;
IWmiDbHandle  *CRepository::m_pEseRoot = 0;

//
//
//
/////////////////////////////////////////////////////////////////

class CNamespaceListSink : public CUnkBase<IWbemObjectSink, &IID_IWbemObjectSink>
{
    CWStringArray &m_aNamespaceList;
public:
    CNamespaceListSink(CWStringArray &aNamespaceList)
        : m_aNamespaceList(aNamespaceList)
    {
    }
    ~CNamespaceListSink()
    {
    }
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        HRESULT hRes;
        for (int i = 0; i != lNumObjects; i++)
        {
            if (apObjects[i] != NULL)
            {
                _IWmiObject *pInst = NULL;
                hRes = apObjects[i]->QueryInterface(IID__IWmiObject, (void**)&pInst);
                if (FAILED(hRes))
                    return hRes;
                CReleaseMe rm(pInst);

                BSTR strKey = NULL;
                hRes = pInst->GetKeyString(0, &strKey);
                if(FAILED(hRes))
                    return hRes;
                CSysFreeMe sfm(strKey);
                if (m_aNamespaceList.Add(strKey) != CWStringArray::no_error) 
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }

        return WBEM_S_NO_ERROR;
    }
    STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult, BSTR, IWbemClassObject*)
    {
        return WBEM_S_NO_ERROR;
    }

};


//***************************************************************************
//
//  CRepository::Init
//
//***************************************************************************

HRESULT CRepository::Init()
{
    HRESULT hRes;
    IWmiDbController *pController = 0;
    WMIDB_LOGON_TEMPLATE *pTemplate = 0;
    IWmiDbSession *pSession= 0;
    IWmiDbHandle *pRoot = 0;

    // Retrieve the CLSID of the default driver.
    // =========================================
    CLSID clsid;
    hRes = ConfigMgr::GetDefaultRepDriverClsId(clsid);
    if (FAILED(hRes))
        return hRes;

    hRes = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, 
                          IID_IWmiDbController, (void **)&pController); 

    if (FAILED(hRes))
        return hRes;

    CReleaseMe _1(pController);

    hRes = pController->GetLogonTemplate(0x409, 0, &pTemplate);

    if (FAILED(hRes))
        return hRes;

    //
	// Commenting out code since its not used for its intended 'purposes' anymore. Provides
	// an excellent opportunity to pass the TlsIndex of the securityFlag to the
	// repository though.
	WMIDB_LOGON_PARAMETER LogonParam ;
	V_VT (&(pTemplate->pParm->Value)) = VT_I4 ;
	V_I4 (&(pTemplate->pParm->Value)) = CCoreQueue::GetSecFlagTlsIndex ( ) ;


	//
	//for (DWORD i = 0; i < pTemplate->dwArraySize; i++)
    //{
    //     if (!wbem_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Server"))
    //     {
    //          pTemplate->pParm[i].Value.bstrVal = 0;
    //          pTemplate->pParm[i].Value.vt = VT_BSTR;
    //     }
    //     else if (!wbem_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Database"))
    //     {
    //          WString sDir = ConfigMgr::GetWorkingDir();
    //          sDir += "\\repository\\wmi.edb";

    //          pTemplate->pParm[i].Value.bstrVal = SysAllocString(LPWSTR(sDir));
    //          pTemplate->pParm[i].Value.vt = VT_BSTR;
    //     }
    //     else if (!wbem_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"UserID"))
    //     {
    //          pTemplate->pParm[i].Value.bstrVal = SysAllocString(L"Admin");
    //          pTemplate->pParm[i].Value.vt = VT_BSTR;
    //     }
    //     else if (!wbem_wcsicmp(pTemplate->pParm[i].strParmDisplayName, L"Password"))
    //     {
    //          pTemplate->pParm[i].Value.bstrVal = SysAllocString(L"");
    //          pTemplate->pParm[i].Value.vt = VT_BSTR;
    //     }
    //}

    // Logon to Jet.
    // =============

    hRes = pController->Logon(pTemplate, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pSession, &pRoot);

    if (SUCCEEDED(hRes))
    {
        m_pEseSession = pSession;
        m_pEseRoot = pRoot;    // Refcount is ok
    }

    pController->FreeLogonTemplate(&pTemplate);

	if (SUCCEEDED(hRes))
	{
		m_pEseController = pController;
		m_pEseController->AddRef();
	}

    // Ensure ROOT and ROOT\DEFAULT are there.
    // =======================================

    if (SUCCEEDED(hRes))
        hRes = EnsureDefault();                 // SEC:REVIEWED 2002-03-22 : Needs exception handler

    if (SUCCEEDED(hRes))
        hRes = UpgradeSystemClasses();          // SEC:REVIEWED 2002-03-22 : Needs exception handler


    if (SUCCEEDED(hRes))
    {
        DWORD dwMaxSize;
        HKEY hKey;
        long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                        0, KEY_READ | KEY_WRITE, &hKey);
        if(lRes)
            return lRes;
        CRegCloseMe cm(hKey);

        DWORD dwLen = sizeof(DWORD);
        lRes = RegQueryValueExW(hKey, L"Max Class Cache Size", NULL, NULL,  
                    (LPBYTE)&dwMaxSize, &dwLen);

        if(lRes != ERROR_SUCCESS)
        {
            dwMaxSize = 5000000;
            lRes = RegSetValueExW(hKey, L"Max Class Cache Size", 0, REG_DWORD, 
                    (LPBYTE)&dwMaxSize, sizeof(DWORD));
        }
        m_pEseController->SetCacheValue(dwMaxSize);
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::EnsureDefault()
{
    HRESULT hRes;
    IWmiDbSession *pSession = NULL;
    IWmiDbSessionEx *pSessionEx = NULL;
    IWmiDbHandle *pRootNs = 0, *pRootDefaultNs = 0, *pRootSecurityNs = 0;

    //Create a new session...
    hRes = CRepository::GetNewSession(&pSession);
    if (FAILED(hRes))
        return hRes;

    //Get an EX version that supports transactioning...
    pSession->QueryInterface(IID_IWmiDbSessionEx, (void**)&pSessionEx);
    if (pSessionEx)
    {
        pSession->Release();
        pSession = pSessionEx;
    }
    CReleaseMe relMe1(pSession);

    //If we have transactionable session, use it!
    if (pSessionEx)
    {
        hRes = pSessionEx->BeginWriteTransaction(0);
        if (FAILED(hRes))
        {
            return hRes;
        }
    }

    try
    {
        //First we work on the ROOT namespace
        //-----------------------------------
        hRes = OpenEseNs(pSession, L"ROOT", &pRootNs);
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //Create as it does not exist...
            hRes = CreateEseNs(pSession, L"ROOT", &pRootNs);
        }

        //Unfortunately, root always seems to have been created, so cannot actually optimise this one!
        if (SUCCEEDED(hRes))
        {
            //Create objects that only reside in the root namespace
            hRes = EnsureNsSystemRootObjects(pSession, pRootNs, NULL,  NULL);
        }
        if (SUCCEEDED(hRes))
        {
            //Create generic instances that exist in all namespaces
            hRes = EnsureNsSystemInstances(pSession, pRootNs, NULL,  NULL);
        }
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //Something bad happened!  This error has a special meaning
            //later on, so remapping so something safer!
            hRes = WBEM_E_FAILED;
        }

        //Next we work on the ROOT\DEFAULT namesapce...
        //---------------------------------------------
        if (SUCCEEDED(hRes))
        {
            hRes = OpenEseNs(pSession, L"ROOT\\DEFAULT", &pRootDefaultNs);
        }
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //Create the namespace as it does not exist and add all the standard
            //stuff that is needed in there...
            hRes = CreateEseNs(pSession, L"ROOT\\DEFAULT", &pRootDefaultNs);
            if (SUCCEEDED(hRes))
            {
                //Need to auto-recover MOFs as this point guarentees that this is
                //a new repository
                ConfigMgr::SetDefaultMofLoadingNeeded();
            }
            if (SUCCEEDED(hRes))
            {
                //Create generic instances that exist in all namespaces
                hRes = EnsureNsSystemInstances(pSession, pRootDefaultNs, pSession, pRootNs);
            }
        }
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //Something bad happened!  This error has a special meaning
            //later on, so remapping so something safer!
            hRes = WBEM_E_FAILED;
        }

        //Finally we work on the ROOT\SECURITY namespace
        //-----------------------------------------------
        if (SUCCEEDED(hRes))
        {
            hRes = OpenEseNs(pSession,  L"ROOT\\SECURITY", &pRootSecurityNs);
        }
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //The namespace is not there so create it
            hRes = CreateEseNs(pSession, L"ROOT\\SECURITY", &pRootSecurityNs);

            if (SUCCEEDED(hRes))
            {
                //Store system instances that exist in all namespaces
                hRes = EnsureNsSystemInstances(pSession, pRootSecurityNs, pSession, pRootNs);
            }
            if (SUCCEEDED(hRes))
            {
                //Store the security objects into the namespace.  These only reside in this
                //namespace
                hRes = EnsureNsSystemSecurityObjects(pSession, pRootSecurityNs, pSession, pRootNs);
            }
        }
    }
    catch (...) // not sure about this one
    {
        ExceptionCounter c;
        ERRORTRACE((LOG_WBEMCORE, "Creation of empty repository caused a very critical error!\n"));
        hRes = WBEM_E_CRITICAL_ERROR;
    }


    if (SUCCEEDED(hRes))
    {
        //Commit the transaction
        if (pSessionEx)
        {
            hRes = pSessionEx->CommitTransaction(0);
        }
    }
    else
    {
        ERRORTRACE((LOG_WBEMCORE, "Creation of empty repository failed with error <0x%X>!\n", hRes));
        if (pSessionEx)
            pSessionEx->AbortTransaction(0);
    }

    if (pRootNs)
        pRootNs->Release();
    if (pRootDefaultNs)
        pRootDefaultNs->Release();
    if (pRootSecurityNs)
        pRootSecurityNs->Release();

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::Shutdown(BOOL bIsSystemShutDown)
{
    if (m_pEseRoot)
    {
        m_pEseRoot->Release();
        m_pEseRoot = NULL;
    }

    if (m_pEseSession)
    {
        m_pEseSession->Release();
        m_pEseSession = NULL;
    }

    if (m_pEseController)
    {
        m_pEseController->Shutdown(bIsSystemShutDown?WMIDB_SHUTDOWN_MACHINE_DOWN:0);        
        m_pEseController->Release();
        m_pEseController = NULL;
    }

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************
// ok

HRESULT CRepository::GetDefaultSession(
    OUT IWmiDbSession **pSession
    )
{
    if (m_pEseSession == 0)
        return WBEM_E_CRITICAL_ERROR;

    *pSession = m_pEseSession;
    (*pSession)->AddRef();

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CRepository::OpenNs
//
//  ESE only
//
//***************************************************************************
//
HRESULT CRepository::OpenEseNs(
    IN IWmiDbSession *pSession,
    IN  LPCWSTR pszNamespace,
    OUT IWmiDbHandle **pHandle
    )
{
    if (pHandle == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (pSession == NULL)
        pSession = m_pEseSession;

    *pHandle = 0;

    // Check for virtual root ns (one level up from ROOT).
    // ===================================================
    if (pszNamespace == 0)
    {
        if (m_pEseRoot == 0)
            return WBEM_E_CRITICAL_ERROR;

        *pHandle = m_pEseRoot;
        (*pHandle)->AddRef();

        return WBEM_S_NO_ERROR;
    }

    // Loop through the nested namespaces until we get to the last one.
    // ================================================================
    size_t tmpLength = wcslen(pszNamespace)+1;  
    wchar_t* pszSource = new wchar_t[tmpLength];
    CVectorDeleteMe<wchar_t> vdm1(pszSource);
    if (pszSource == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(pszSource, tmpLength, pszNamespace);
    LPCWSTR pszDelimit = L"\\";
    LPWSTR pszTok = wcstok(LPWSTR(pszSource), pszDelimit);  
    HRESULT hRes = 0;
    IWmiDbHandle *pCurrent = m_pEseRoot;
    IWmiDbHandle *pTmp = 0;
    if (pCurrent)
        pCurrent->AddRef();
    else
        return WBEM_E_CRITICAL_ERROR;

    while (pszTok)
    {
        // Current namespace is <pszTok>
        // =============================

        IWbemPath *pPath = ConfigMgr::GetNewPath();
        if (pPath == 0)
        {
            pCurrent->Release();
            return WBEM_E_OUT_OF_MEMORY;
        }
        CReleaseMe _1(pPath);

        WString sPath;
        try
        {
	        sPath = "__namespace='";
	        sPath += pszTok;              // SEC:REVIEWED 2002-03-22 : Needs long-name check
	        sPath += "'";
        }
        catch (CX_MemoryException &)
        {
            return WBEM_E_OUT_OF_MEMORY;
        };

        pPath->SetText(WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , sPath);

        hRes = pSession->GetObject(pCurrent, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pTmp);

        pszTok = wcstok(NULL, pszDelimit); // SEC:REVIEWED 2002-03-22 : What happens if ill formed?
        pCurrent->Release();

        if (FAILED(hRes))
            return hRes;

        // If here, we got it.  So either we are done, or we need to keep going.
        // =====================================================================
        if (pszTok)
            pCurrent = pTmp;
        else
        {
            // All done
            *pHandle = pTmp;
            break;
        }
    }


    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// Executed; seems to work

HRESULT CRepository::GetObject(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszObjectPath,           // NS relative only for now
    IN ULONG uFlags,
    OUT IWbemClassObject **pObj
    )
{
    HRESULT hRes;

    //
    // Check if the session supports faster interface
    //

    IWmiDbSessionEx* pEx = NULL;
    hRes = pSession->QueryInterface(IID_IWmiDbSessionEx, (void**)&pEx);
    if(SUCCEEDED(hRes))
    {
        CReleaseMe rm1(pEx);

        hRes = pEx->GetObjectByPath(pNs, pszObjectPath, uFlags,
                                    IID_IWbemClassObject, (void**)pObj);
    }
    else
    {
        // Path to object.
        // ===============
        IWbemPath *pPath = ConfigMgr::GetNewPath();
        if (pPath == 0)
            return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe _1(pPath);
        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszObjectPath);


        // Get it.
        // =======

        hRes = pSession->GetObjectDirect(pNs, pPath, uFlags, IID_IWbemClassObject, (void **)pObj);
    }

    if (FAILED(hRes))
    {
//      DEBUGTRACE((LOG_REPDRV, "Failed with 0x%X\n", hRes));
        return hRes;
    }
    else
    {
#ifdef TESTONLY
        BSTR str = 0;
        (*pObj)->GetObjectText(0, &str);
        DEBUGTRACE((LOG_REPDRV, "  GetObject() Text = \n%S\n\n", str));
        SysFreeString(str);
#endif
    }

    return hRes;
}

//***************************************************************************
//
//  Does not support nesting yet
//
//***************************************************************************
// ok

HRESULT CRepository::CreateEseNs(
    IN  IWmiDbSession *pSession,
    IN  LPCWSTR pszNamespace,
    OUT IWmiDbHandle **pHandle
    )
{
    HRESULT hRes = 0;

    if (pszNamespace == 0 || pHandle == 0)
        return WBEM_E_INVALID_PARAMETER;

    if (pSession == NULL)
    {
        pSession = m_pEseSession;
    }

    // Loop through each namespace and try to open it.  If we can
    // keep going.  If we fail, create it at the current level and
    // return the handle.
    // ===========================================================

    size_t tmpLength = wcslen(pszNamespace)+1; 
    wchar_t* pszSource = new wchar_t[tmpLength];
    CVectorDeleteMe<wchar_t> vdm1(pszSource);
    if (pszSource == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    StringCchCopyW(pszSource, tmpLength, pszNamespace);
    LPCWSTR pszDelimit = L"\\";
    LPWSTR pszTok = wcstok(LPWSTR(pszSource), pszDelimit);  // First ns token
    IWmiDbHandle *pCurrent = m_pEseRoot;
    IWmiDbHandle *pTmp = 0;
    pCurrent->AddRef();

    while (pszTok)
    {
        // Current namespace is <pszTok>
        // =============================

        IWbemPath *pPath = ConfigMgr::GetNewPath();
        if (pPath == 0)
        {
            pCurrent->Release();
            return WBEM_E_OUT_OF_MEMORY;
        }
        CReleaseMe _1(pPath);

        WString sPath = "__namespace='";
        sPath += pszTok;
        sPath += "'";

        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, sPath);

        hRes = pSession->GetObject(pCurrent, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pTmp);

        size_t tmpLenght = wcslen(pszTok)+1;
        wchar_t* TmpStr = new wchar_t[tmpLenght];
        if (TmpStr == NULL)
        {
            pCurrent->Release();
            return WBEM_E_OUT_OF_MEMORY;
        }
        CVectorDeleteMe<wchar_t> vdm1(TmpStr);
        *TmpStr = 0;

        if (pszTok)
            StringCchCopyW(TmpStr, tmpLenght, pszTok);

        pszTok = wcstok(NULL, pszDelimit);

        if (FAILED(hRes))
        {
            // If here, we try to create the namespace.
            // ========================================

            // Get a copy of class __Namespace
            // ================================
            IWbemClassObject *pNsClass = 0;

            hRes = GetObject(pSession, pCurrent, L"__Namespace", 0,
                                &pNsClass);
            if (FAILED(hRes))
            {
                pCurrent->Release();
                return hRes;
            }

            CReleaseMe _1(pNsClass);

            IWbemClassObject *pNs;
            pNsClass->SpawnInstance(0, &pNs);
            CReleaseMe _(pNs);

            CVARIANT v;
            v.SetStr(TmpStr);
            pNs->Put(L"Name", 0, &v, 0);

            hRes = pSession->PutObject(pCurrent, IID_IWbemClassObject, pNs, WBEM_FLAG_CREATE_ONLY, WMIDB_HANDLE_TYPE_VERSIONED, &pTmp);
            if (FAILED(hRes))
            {
                pCurrent->Release();
                return hRes;
            }
            pCurrent->Release();
            pCurrent = pTmp;
            if (pszTok)
                continue;
            *pHandle = pTmp;
            break;
        }

        // If here, we got it.  So either we are done, or we need to keep going.
        // =====================================================================

        else if (pszTok)
        {
            pCurrent->Release();
            pCurrent = pTmp;
        }
        else
        {
            // All done
            *pHandle = pTmp;
            break;
        }
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
// Executed; seems to work

HRESULT CRepository::PutObject(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN REFIID riid,
    IN LPVOID pObj,
    IN DWORD dwFlags
    )
{
    if (pNs == 0 || pObj == 0)
        return WBEM_E_INVALID_PARAMETER;

    if(dwFlags & WBEM_FLAG_NO_EVENTS)
    {
        dwFlags |= WMIDB_DISABLE_EVENTS;
    }

    // Mask out unrecognized flags
    dwFlags &=  (WBEM_FLAG_OWNER_UPDATE | WBEM_FLAG_CREATE_OR_UPDATE | WBEM_FLAG_CREATE_ONLY | WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_SAFE_MODE | WBEM_FLAG_UPDATE_FORCE_MODE
                 | WBEM_FLAG_USE_SECURITY_DESCRIPTOR | WMIDB_FLAG_ADMIN_VERIFIED | WMIDB_DISABLE_EVENTS);

    HRESULT hRes;
    try
    {
        hRes = pSession->PutObject(pNs, riid, pObj, dwFlags, 0, 0);
    }
    catch(...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// inspected; no execution history

HRESULT CRepository::ExecQuery(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszQuery,
    IN IWbemObjectSink *pSink,
    IN LONG lFlags
    )
{
    HRESULT hRes = 0;

    IWbemQuery *pQuery = NULL;
    hRes = g_pQueryFact->CreateInstance(0, IID_IWbemQuery, (void **)&pQuery);  

    if (FAILED(hRes))
    {
        pSink->SetStatus(0, WBEM_E_CRITICAL_ERROR, 0, 0);
        return WBEM_E_CRITICAL_ERROR;
    }

    CReleaseMe _1(pQuery);

    hRes = pQuery->Parse(L"SQL", pszQuery, 0);
    if (FAILED(hRes))
    {
        pSink->SetStatus(0, WBEM_E_INVALID_QUERY, 0, 0);
        return WBEM_E_INVALID_QUERY;
    }

    // Now, execute the query.
    // =======================

    IWmiDbIterator *pIterator = NULL;

    try
    {
        hRes = pSession->ExecQuery(pNs, pQuery, lFlags, WMIDB_HANDLE_TYPE_COOKIE, NULL, &pIterator);
    }
    catch(...)
    {
        ExceptionCounter c;
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    // If this is a "delete" query, there
    // will be no iterator.
    // ==================================

    if (FAILED(hRes) || !pIterator)
    {
        pSink->SetStatus(0, hRes, 0, 0);
        return hRes;
    }

    // If here, there are results, I guess.
    // ====================================

    REFIID riid = IID_IWbemClassObject;
    DWORD dwObjects = 0;

    // Convert current thread to a fiber
    // =================================

    // First, uncovert the thread to prevent a leak if we are already
    // converted.  There is no way of checking, sadly.

    void* pFiber = NULL;

	_TEB *pTeb = NtCurrentTeb();
    BOOL bIsThisThreadAlreadyAFiber = (pTeb->HasFiberData != 0);

    if (!bIsThisThreadAlreadyAFiber)
        pFiber = ConvertThreadToFiber(NULL);
    else
        pFiber = GetCurrentFiber();

    if(pFiber == NULL)
    {
        if (pIterator)
            pIterator->Release();

        pSink->SetStatus(0, WBEM_E_OUT_OF_MEMORY, 0, 0);
        return WBEM_E_OUT_OF_MEMORY;
    }

    // Extract everything from the iterator
    // ====================================

    while (1)
    {
        IWbemClassObject *pObj = 0;
        DWORD dwReturned = 0;

        hRes = pIterator->NextBatch(
            1,                        // one at a time for now
            5,                        // Timeout seconds(or milliseconds? who knows...)
            0,                        // Flags
            WMIDB_HANDLE_TYPE_COOKIE,
            riid,
            pFiber,
            &dwReturned,
            (LPVOID *) &pObj
            );

        if (dwReturned == 0 || pObj == 0 || FAILED(hRes))
            break;

        dwObjects += dwReturned;
        hRes = pSink->Indicate(1, &pObj);
        pObj->Release();
        if (FAILED(hRes))   // Allow an early cancellation
            break;
    }

    if (pIterator)
    {
        pIterator->Cancel(hRes, pFiber);
        pIterator->Release();
    }

    if (!bIsThisThreadAlreadyAFiber)
        ConvertFiberToThread();

    if (SUCCEEDED(hRes))
        hRes = WBEM_S_NO_ERROR;
    hRes = pSink->SetStatus(0, hRes, 0, 0);

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// inspected; no execution history

HRESULT CRepository::QueryClasses(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN ULONG uFlags,                //  WBEM_FLAG_DEEP = 0,  WBEM_FLAG_SHALLOW = 1,
    IN LPCWSTR pszSuperclass,
    IN IWbemObjectSink *pSink
    )
{
    HRESULT hRes;

    // Build the query required for simple class operations.
    // =====================================================

    WString sQuery = L"select * from meta_class";

    if (pszSuperclass)
    {
        if (uFlags & WBEM_FLAG_SHALLOW)
        {
            sQuery += " where ";
            sQuery += " __SuperClass = '";
            sQuery += pszSuperclass;
            sQuery += "'";

        }
        else
        {
            if (wcslen(pszSuperclass) > 0)
            {
                sQuery += " where ";
                sQuery += "__this isa '";
                sQuery += pszSuperclass;
                sQuery += "'";
                sQuery += " and __class <> '";
                sQuery += pszSuperclass;
                sQuery += "'";
            }
        }
    }


    // Ship it to the more general query function.
    // ===========================================

    hRes = CRepository::ExecQuery(pSession, pNs, sQuery, pSink, uFlags);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
// inspected; no execution history

HRESULT CRepository::DeleteObject(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN REFIID riid,
    IN LPVOID pObj,
    IN DWORD dwFlags
    )
{
    return pSession->DeleteObject(pNs, dwFlags, riid, pObj);
}

//***************************************************************************
//
//***************************************************************************

HRESULT CRepository::DeleteByPath(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszPath,
    IN DWORD uFlags
    )
{
    HRESULT hRes;

    if(uFlags & WBEM_FLAG_NO_EVENTS)
    {
        uFlags |= WMIDB_DISABLE_EVENTS;
    }

    //
    // Check if the session supports faster interface
    //

    IWmiDbSessionEx* pEx = NULL;
    hRes = pSession->QueryInterface(IID_IWmiDbSessionEx, (void**)&pEx);
    if(SUCCEEDED(hRes))
    {
        CReleaseMe rm1(pEx);

        hRes = pEx->DeleteObjectByPath(pNs, pszPath, uFlags);
    }
    else
    {
        IWmiDbHandle *pHandle = NULL;

        // Path to object.
        // ===============
        IWbemPath *pPath = ConfigMgr::GetNewPath();
        if (pPath == 0)
            return WBEM_E_OUT_OF_MEMORY;
        CReleaseMe _1(pPath);
        pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL, pszPath);

        hRes = pSession->GetObject(pNs, pPath, 0, WMIDB_HANDLE_TYPE_COOKIE|WMIDB_HANDLE_TYPE_EXCLUSIVE, &pHandle);
        if (FAILED(hRes))
            return hRes;
        hRes = DeleteObject(pSession, pNs, IID_IWmiDbHandle, pHandle, uFlags);
        pHandle->Release();
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
// visually ok

HRESULT CRepository::InheritsFrom(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszSuperclass,
    IN LPCWSTR pszSubclass
    )
{
    IWbemClassObject *pObj = 0;

    HRESULT hRes = GetObject(pSession, pNs, pszSubclass, 0, &pObj);
    if (FAILED(hRes))
        return hRes;

    CReleaseMe _(pObj);

    hRes = pObj->InheritsFrom(pszSuperclass);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CRepository::GetRefClasses(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszClass,
    IN BOOL bIncludeSubclasses,
    OUT CWStringArray &aClasses
    )
{
    WString sQuery = "references of {";
    sQuery +=pszClass;
    sQuery += "}";

    CSynchronousSink* pRefClassSink = CSynchronousSink::Create();
    if (pRefClassSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pRefClassSink->AddRef();
    CReleaseMe _1(pRefClassSink);

    HRESULT hRes = CRepository::ExecQuery(pSession, pNs, sQuery, pRefClassSink, 0);

    if (FAILED(hRes) && hRes != WBEM_E_NOT_FOUND)
        return WBEM_E_CRITICAL_ERROR;

    pRefClassSink->GetStatus(&hRes, NULL, NULL);

    CRefedPointerArray<IWbemClassObject>& raObjects = pRefClassSink->GetObjects();

    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];

        CVARIANT vGenus;
        hRes = pClsDef->Get(L"__GENUS", 0, &vGenus, 0, 0);
        if (FAILED(hRes))
            return hRes;
        if(V_VT(&vGenus) == VT_I4 && V_I4(&vGenus) == 1)
        {
            CVARIANT v;
            if(SUCCEEDED(pClsDef->Get(L"__CLASS", 0, &v, 0, 0)) && VT_BSTR == V_VT(&v))
            {
                if (CFlexArray::no_error != aClasses.Add(v.GetStr()))
                {
                    // ???
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CRepository::GetInstanceRefs(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszTargetObject,
    IN IWbemObjectSink *pSink
    )
{
    WString sQuery = "references of {";
    sQuery += pszTargetObject;
    sQuery += "}";

    HRESULT hRes = ExecQuery(pSession, pNs, sQuery, pSink, 0);

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CRepository::GetClassesWithRefs(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN IWbemObjectSink *pSink
    )
{
    // TBD: Jet Blue
    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CRepository::BuildClassHierarchy
//
//  Notes:
//  Builds a decorated class hierarchy tree.  Doesn't use dyn classes yet.
//
//  <pNs>
//      The namespace to use for classes.
//
//  <pBaseClassName>
//      May not be null.
//
//  <lFlags>
//      Not used yet.
//
//  <pDynasty>
//      Receives the class dynasty tree.
//
//  Verification:
//  (a) Verifies that pBaseClassName is a class which has a key or inherits one.
//
//******************************************************************************
//

HRESULT CRepository::BuildClassHierarchy(
    IN  IWmiDbSession *pSession,
    IN  IWmiDbHandle *pNs,
    IN  LPCWSTR pBaseClassName,
    IN  LONG lFlags,
    OUT wmilib::auto_ptr<CDynasty> & pDynasty
    )
{
    if (pNs == 0 || pBaseClassName == 0 )
        return WBEM_E_INVALID_PARAMETER;

    // First, execute a schema query for all the classes in the dynasty.
    // We verify that the base as a key, or else it is an error.
    //
    // TBD: Dynamic classes are not merged in yet
    //
    // ================================================================

    WString sQuery = "select * from meta_class where __this isa '";
    sQuery += pBaseClassName;
    sQuery += "'";

    CSynchronousSink* pRefClassSink = CSynchronousSink::Create();
    if (pRefClassSink == NULL) return WBEM_E_OUT_OF_MEMORY;
    pRefClassSink->AddRef();
    CReleaseMe _1(pRefClassSink);

    HRESULT hRes = CRepository::ExecQuery(pSession, pNs, sQuery, pRefClassSink, 0);
    if (FAILED(hRes)) return hRes;
    pRefClassSink->Block();
    pRefClassSink->GetStatus(&hRes, NULL, NULL);

    CRefedPointerArray<IWbemClassObject>& raObjects = pRefClassSink->GetObjects();

    // Find root class amongst all those relatives.
    // ============================================

    CFlexArray aClasses;
    IWbemClassObject *pRoot = 0;

    for (int i = 0; i < raObjects.GetSize(); i++)
    {
        IWbemClassObject *pClsDef = (IWbemClassObject *) raObjects[i];

        _variant_t v;
        hRes = pClsDef->Get(L"__CLASS", 0, &v, 0, 0);
        if (FAILED(hRes)) return hRes;
        if (VT_BSTR != V_VT(&v)) return WBEM_E_INVALID_OBJECT;

        if (0 == wbem_wcsicmp(V_BSTR(&v), pBaseClassName))
            pRoot = pClsDef;
        else
        {
            if (CFlexArray::no_error != aClasses.Add(pClsDef))
                return WBEM_E_OUT_OF_MEMORY;
        }
    }

    if (pRoot == 0)                     // Did we find it?
        return WBEM_E_NOT_FOUND;

    // Algorithm:
    // Add root class first, enqueue the ptr.
    //
    // (a) Dequeue ptr into pCurrentClass
    // (b) Find all classes which have pCurrentClass as the parent
    //     For each, create a CDynasty, add it to the current dynasty
    //     and enqueue each.  Remove enqueued class from array.
    // (c) Goto (a)

    CFlexQueue Q;
    pDynasty.reset( CDynasty::Create(pRoot));
    if (NULL == pDynasty.get()) return WBEM_E_OUT_OF_MEMORY;
    Q.Enqueue(pDynasty.get());

    while (aClasses.Size())
    {
        CDynasty *pCurrent = (CDynasty *) Q.Dequeue();
        if (pCurrent == 0)
            break;

        _variant_t vClassName;
        hRes = pCurrent->m_pClassObj->Get(L"__CLASS", 0, &vClassName, 0, 0);
        if (FAILED(hRes)) return hRes;
        if (VT_BSTR != V_VT(&vClassName)) return WBEM_E_INVALID_OBJECT;        

        for (int i = 0; i < aClasses.Size(); i++)
        {
            IWbemClassObject *pCandidate = (IWbemClassObject *) aClasses[i];

            _variant_t vSuperClass;
            hRes = pCandidate->Get(L"__SUPERCLASS", 0, &vSuperClass, 0, 0);
            if (FAILED(hRes)) return hRes;
            //if (VT_BSTR != V_VT(&vClassName)) return WBEM_E_INVALID_PROPERTY_TYPE;                    

            if (vSuperClass.vt == VT_BSTR && wbem_wcsicmp(V_BSTR(&vSuperClass), V_BSTR(&vClassName)) == 0)
            {
                wmilib::auto_ptr<CDynasty> pNewChild( CDynasty::Create(pCandidate));
                if (pNewChild.get() == NULL) return WBEM_E_OUT_OF_MEMORY;
                pCurrent->AddChild(pNewChild.get());      // throw             
                Q.Enqueue(pNewChild.get());
                pNewChild.release();
                aClasses.RemoveAt(i);
                i--;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CRepository::FindKeyRoot(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR wszClassName,
    OUT IWbemClassObject** ppKeyRootClass
    )
{
    if (pNs == 0 || wszClassName == 0 || ppKeyRootClass == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Work through derivation until we find the class with the key.
    // =============================================================

    *ppKeyRootClass = 0;

    HRESULT hRes;
    IWbemClassObject*   pLastClass = NULL;
    WString sNextClass = wszClassName;  // throw

    while (1)
    {
        IWbemClassObject *pNextClass = 0;

        hRes = CRepository::GetObject(pSession, pNs, sNextClass, 0, &pNextClass);
        if (FAILED(hRes)) break;
        CReleaseMe  rm(pNextClass);

        CVARIANT v;
        hRes = pNextClass->Get(L"__SUPERCLASS", 0, &v, 0, 0);

        if ( FAILED(hRes) ) break;

        if ( V_VT(&v) == VT_NULL )
        {
            sNextClass.Empty();
        }
        else
        {
            sNextClass = v.GetStr(); // throw
        }

        BSTR strProp = 0;
        LONG lFlavor = 0;
        pNextClass->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
        hRes = pNextClass->Next(0, &strProp, 0, 0, &lFlavor);

        // WBEM_S_NO_ERROR means we got a property that was defined as a key
        if (hRes == WBEM_S_NO_ERROR)
        {
            SysFreeString(strProp);

            if ( pLastClass ) pLastClass->Release();
            pLastClass = pNextClass;
            pLastClass->AddRef();
        }
        else if ( hRes == WBEM_S_NO_MORE_DATA )
        {
            // If we don't have a last class, then we didn't find anything.  Otherwise,
            // since we found no key's here, the last class was the one that defined the
            // keys

            if ( pLastClass )
            {
                *ppKeyRootClass = pLastClass;
                return WBEM_S_NO_ERROR;
            }

            // outta here
            break;

        }
        else
        {
            // Otherwise something is just plain wrong
            break;
        }

    }

    return WBEM_E_NOT_FOUND;
}

//***************************************************************************
//
//***************************************************************************
// visually ok

HRESULT CRepository::TableScanQuery(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNs,
    IN LPCWSTR pszClassName,
    IN QL_LEVEL_1_RPN_EXPRESSION *pExp,     // NOT USED
    IN DWORD dwFlags,
    IN IWbemObjectSink *pSink
    )
{
    WString sQuery = "select * from ";
    sQuery += pszClassName;
    HRESULT hRes = CRepository::ExecQuery(pSession, pNs, sQuery, pSink, 0);
    return hRes;
}



//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::InitDriver(
    IN  ULONG uFlags,
    IN  IWbemClassObject *pMappedNs,
    OUT IWmiDbController **pResultController,
    OUT IWmiDbSession **pResultRootSession,
    OUT IWmiDbHandle  **pResultVirtualRoot
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::EnsureNsSystemInstances(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        )
{
    HRESULT hRes;

    // Do a get and see if __WmiMappedDriverNamespace is there.
    // ========================================================

    IWbemClassObject *pTestObj = 0;
    hRes = GetObject(pSession, pNs, L"__systemsecurity=@", 0, &pTestObj);
    if (SUCCEEDED(hRes))
    {
        pTestObj->Release();
        return WBEM_S_NO_ERROR;
    }

    // If here, it's a new namespace that has to be populated with system classes.
    // ===========================================================================

    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (pSvc == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    _IWmiObject *Objects[256];
    ULONG uSize = 256;
    hRes = pSvc->GetSystemObjects(GET_SYSTEM_STD_INSTANCES, &uSize, Objects);

    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            IWbemClassObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = Objects[i]->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                   	AutoRevertSecTlsFlag secFlag ( (LPVOID) 0 ) ;
					hRes = PutObject(pSession, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
                    pObj->Release();
                    if (FAILED(hRes))
                    {
                        ERRORTRACE((LOG_WBEMCORE, "Creation of system instances failed during repository creation <0x%X>!\n", hRes));
                    }
                }
            }
            Objects[i]->Release();
        }
    }

    if (SUCCEEDED(hRes))
    {
        hRes = SetSecurityForNS(pSession, pNs, pParentSession, pParentNs);
        if (FAILED(hRes))
        {
            ERRORTRACE((LOG_WBEMCORE, "Setting of security on namespace failed during repository creation <0x%X>!\n", hRes));
        }
    }

    pSvc->Release();
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::EnsureNsSystemRootObjects(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        )
{
    HRESULT hRes;

    // Do a get and see if __EventSinkCacheControl=@ is there.
    // ========================================================

    IWbemClassObject *pTestObj = 0;
    hRes = GetObject(pSession, pNs, L"__EventSinkCacheControl=@", 0, &pTestObj);
    if (SUCCEEDED(hRes))
    {
        pTestObj->Release();
        return WBEM_S_NO_ERROR;
    }

    // If here, it's a new namespace that has to be populated with system classes.
    // ===========================================================================

    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (pSvc == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CReleaseMe _rm(pSvc);
    _IWmiObject *Objects[256];
    ULONG uSize = 256;
    hRes = pSvc->GetSystemObjects(GET_SYSTEM_ROOT_OBJECTS, &uSize, Objects);

    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            IWbemClassObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = Objects[i]->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                    hRes = PutObject(pSession, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
                    pObj->Release();
                    if (FAILED(hRes))
                    {
                        ERRORTRACE((LOG_WBEMCORE, "Creation of system root objects failed during repository creation <0x%X>!\n", hRes));
                    }
                }
            }
            Objects[i]->Release();
        }
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CRepository::EnsureNsSystemSecurityObjects(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        )
{
    HRESULT hRes;

    // Do a get and see if __User is there.
    // ========================================================

    IWbemClassObject *pTestObj = 0;
    hRes = GetObject(pSession, pNs, L"__User", 0, &pTestObj);
    if (SUCCEEDED(hRes))
    {
        pTestObj->Release();
        return WBEM_S_NO_ERROR;
    }

    // If here, it's a new namespace that has to be populated with system classes.
    // ===========================================================================

    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (pSvc == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    _IWmiObject *Objects[256];
    ULONG uSize = 256;
    hRes = pSvc->GetSystemObjects(GET_SYSTEM_SECURITY_OBJECTS, &uSize, Objects);

    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            IWbemClassObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = Objects[i]->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                    hRes = PutObject(pSession, pNs, IID_IWbemClassObject, pObj, WMIDB_DISABLE_EVENTS);
                    pObj->Release();
                    if (FAILED(hRes))
                    {
                        ERRORTRACE((LOG_WBEMCORE, "Creation of system security objects failed during repository creation <0x%X>!\n", hRes));
                    }
                }
            }
            Objects[i]->Release();
        }
    }


    pSvc->Release();
    return hRes;
}

//***************************************************************************
//
//  Adjusted for all repository drivers.  Works for scopes or namespaces.
//  If a scope is being opened, <pScope> will be set on return and
//  <pbIsNamespace> will point to FALSE.  Otherwise, <pScope> is set to
//  point to NULL and <pbIsNamespace> points to TRUE.
//
//  If <pszScope> is NULL, a pointer to the virtual ROOT in ESE
//  is returned.
//
//***************************************************************************
//
HRESULT CRepository::OpenScope(
    IN  IWmiDbSession *pParentSession,        //Parent session to use to
    IN  LPWSTR pszTargetScope,              // NS or scope
    IN  GUID *pTransGuid,                   // Transaction GUID for connection
    OUT IWmiDbController **pDriver,         // Driver
    OUT IWmiDbSession **pSession,           // Session
    OUT IWmiDbHandle  **pScope,             // Scope
    OUT IWmiDbHandle  **pNs                 // Nearest NS
    )
{
    HRESULT hRes;
    ULONG uNsCount = 0;
    // uScopeCount = 0;

    if (pNs == 0 || pSession == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Default settings.
    // =================

    if (pScope)
        *pScope = 0;

    *pNs = 0;
    *pSession = 0;
    if (pDriver)
      *pDriver = 0;

    // Check for virtual root ns (the parent to ROOT).
    // ===============================================

    if (pszTargetScope == 0)
    {
        if (m_pEseRoot == 0)
            return WBEM_E_CRITICAL_ERROR;

        if (pDriver)
        {
            m_pEseController->AddRef();
            *pDriver = m_pEseController;
        }

        m_pEseSession->AddRef();
        *pSession = m_pEseSession;

        m_pEseRoot->AddRef();
        *pNs = m_pEseRoot;

        return WBEM_S_NO_ERROR;
    }

    // Parse the path.
    // ===============

    IWbemPath *pPath = ConfigMgr::GetNewPath();
    if (pPath == 0)
        return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe _1(pPath);

    hRes = pPath->SetText(WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , pszTargetScope);
    if (FAILED(hRes))
        return WBEM_E_INVALID_NAMESPACE;

    // Analyze it.  Is it just a namespace?
    // Build the namespace string and normalize it.
    // ============================================

    hRes = pPath->GetNamespaceCount(&uNsCount);
    //hRes = pPath->GetScopeCount(&uScopeCount);

    // Starting handles at ROOT.
    // =========================

    IWmiDbHandle *pTempNs = 0;
    IWmiDbHandle *pMostRecent = 0;
    IWmiDbHandle *pMostRecentScope = 0;

    IWmiDbSession    *pTempSession   = m_pEseSession;            // Default virtual root
    IWmiDbController *pTempDriver    = m_pEseController;         // Default driver

    //Use the override if available
    if (pParentSession)
        pTempSession = pParentSession;

    pTempSession->AddRef();     // For later release
    pTempDriver->AddRef();      // For later release

    hRes = OpenEseNs(pTempSession, L"ROOT", &pMostRecent);
    if (FAILED(hRes))
    {
        pTempSession->Release();
        pTempDriver->Release();
        return WBEM_E_CRITICAL_ERROR;
    }

    // Starting driver.
    // ================


    WString sNsDecoration = "ROOT";

    // open up each namespace successively, mapping it.
    // ===============================================

    for (ULONG u = 0; u < uNsCount; u++)
    {
        IWbemClassObject *pNsRep = 0;

        ULONG uLen = 0;
        // Get next namespace token name.
        // ==============================
        hRes = pPath->GetNamespaceAt(u, &uLen, NULL);
        if(FAILED(hRes))
            goto Error;

        WCHAR* Buf = new WCHAR[uLen+1];
        if (Buf == NULL)
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
            goto Error;
        }
        CVectorDeleteMe<WCHAR> vdm(Buf);
        hRes = pPath->GetNamespaceAt(u, &uLen, Buf);
        if (FAILED(hRes) || *Buf == 0)
            goto Error;

        if ((u == 0) && (wbem_wcsicmp(L"root", Buf) != 0))
        {
            hRes = WBEM_E_INVALID_NAMESPACE;
            goto Error;
        }
        else if (u == 0)
            continue;

        // Build a relative scope path.
        // ============================
        WString sPath = "__namespace='";
        sPath += Buf;
        sPath += "'";

        sNsDecoration += "\\";
        sNsDecoration += Buf;

        IWbemPath *pNewPath = ConfigMgr::GetNewPath();
        if (pNewPath == 0)
        {
            hRes = WBEM_E_OUT_OF_MEMORY;
            goto Error;
        }
        CReleaseMe rm1(pNewPath);

        hRes = pNewPath->SetText(WBEMPATH_TREAT_SINGLE_IDENT_AS_NS | WBEMPATH_CREATE_ACCEPT_ALL , sPath);
        if (FAILED(hRes))
            goto Error;

        // Get the reprsentation object.
        // =============================

        hRes = pTempSession->GetObjectDirect(pMostRecent, pNewPath, 0, IID_IWbemClassObject, (void **) &pNsRep);
        if (hRes == WBEM_E_NOT_FOUND)
        {
            //If a namespace does not exist it should return a different namespace...
            hRes = WBEM_E_INVALID_NAMESPACE;
            goto Error;
        }
        else if (FAILED(hRes))
            goto Error;
        CReleaseMe _(pNsRep);

        // Now move down one namespace.
        // =============================

        hRes = pTempSession->GetObject(pMostRecent, pNewPath, 0, WMIDB_HANDLE_TYPE_COOKIE, &pTempNs);

        ReleaseIfNotNULL(pMostRecent);
        pMostRecent = pTempNs;
        pTempNs = 0;

        if (FAILED(hRes))
            goto Error;
    }

    // Final.
    // ======
    ReleaseIfNotNULL(pTempNs);

    if (pScope)
        *pScope = pMostRecentScope;

    *pNs = pMostRecent;
    *pSession = pTempSession;
    if (pDriver)
        *pDriver = pTempDriver;


    return WBEM_S_NO_ERROR;

Error:
    ReleaseIfNotNULL(pMostRecent);
    ReleaseIfNotNULL(pTempNs);
    ReleaseIfNotNULL(pTempDriver);
    ReleaseIfNotNULL(pTempSession);

    return hRes;
}

HRESULT CRepository::GetNewSession(IWmiDbSession **ppSession)
{
    HRESULT hRes;
    IWmiDbController *pController = 0;
    WMIDB_LOGON_TEMPLATE *pTemplate = 0;
    IWmiDbSession *pSession= 0;
    IWmiDbHandle *pRoot = 0;

    // Retrieve the CLSID of the default driver.
    // =========================================
    CLSID clsid;
    hRes = ConfigMgr::GetDefaultRepDriverClsId(clsid);
    if (FAILED(hRes))
        return hRes;

    hRes = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, 
                          IID_IWmiDbController, (void **)&pController);

    if (FAILED(hRes))
        return hRes;

    CReleaseMe _1(pController);

    hRes = pController->GetLogonTemplate(0x409, 0, &pTemplate);

    if (FAILED(hRes))
        return hRes;

    hRes = pController->Logon(pTemplate, 0, WMIDB_HANDLE_TYPE_VERSIONED, &pSession, &pRoot);

    if (SUCCEEDED(hRes))
    {
        *ppSession = pSession;
        pRoot->Release();
    }

    pController->FreeLogonTemplate(&pTemplate);
    return hRes;
}

HRESULT CRepository::UpgradeSystemClasses()
{
    DWORD dwOldVer = 0;
    DWORD dwNewVer = 0;
    HRESULT hRes;

    hRes = m_pEseController->GetRepositoryVersions(&dwOldVer, &dwNewVer);

    if (FAILED(hRes))
        return hRes;

    if (dwOldVer < 4)
    {
        //Lower versions stored system classes in every namespace!  We
        //should delete them!
        CWStringArray aListRootSystemClasses;

        //Retrieve the list...
        hRes = GetListOfRootSystemClasses(aListRootSystemClasses); // SEC:REVIEWED 2002-03-22 : Needs EH, throws on low-mem

        if (SUCCEEDED(hRes))
        {
            //Create a new session...
            IWmiDbSession *pSession = NULL;
            IWmiDbSessionEx *pSessionEx = NULL;
            hRes = CRepository::GetNewSession(&pSession);
            if (FAILED(hRes))
                return hRes;

            //Get an EX version that supports transactioning...
            pSession->QueryInterface(IID_IWmiDbSessionEx, (void**)&pSessionEx);
            if (pSessionEx)
            {
                pSession->Release();
                pSession = pSessionEx;
            }
            CReleaseMe relMe1(pSession);

            //If we have transactionable session, use it!
            if (pSessionEx)
            {
                hRes = pSessionEx->BeginWriteTransaction(0);
                if (FAILED(hRes))
                {
                    return hRes;
                }
            }
            try
            {
                //Recursively do the deletion, starting at root, however don't delete
                //the ones in root itself!
                hRes = RecursiveDeleteClassesFromNamespace(pSession, L"root", aListRootSystemClasses, false);
            }
            catch (CX_Exception &) // Only WStringArray should throw
            {
                hRes = WBEM_E_CRITICAL_ERROR;
            }
            if (SUCCEEDED(hRes))
            {
                //Commit the transaction
                if (pSessionEx)
                {
                    hRes = pSessionEx->CommitTransaction(0);
                }
            }
            else
            {
                ERRORTRACE((LOG_WBEMCORE, "Removal of ROOT ONLY system classes from non-ROOT namespace failed during repository upgrade <0x%X>!\n", hRes));
                if (pSessionEx)
                    pSessionEx->AbortTransaction(0);
            }

        }
    }

    return hRes;
}

HRESULT CRepository::GetListOfRootSystemClasses(CWStringArray &aListRootSystemClasses)
{
    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if (pSvc == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    _IWmiObject *Objects[256];
    ULONG uSize = 256;
    HRESULT hRes;
    hRes = pSvc->GetSystemObjects(GET_SYSTEM_ROOT_OBJECTS, &uSize, Objects);

    if (SUCCEEDED(hRes))
    {
        for (int i = 0; i < uSize; i++)
        {
            _IWmiObject *pObj;
            if (SUCCEEDED(hRes))
            {
                hRes = Objects[i]->QueryInterface(IID__IWmiObject, (LPVOID *) &pObj);
                if (SUCCEEDED(hRes))
                {
                    if (pObj->IsObjectInstance() != S_OK)
                    {
                        VARIANT var;
                        VariantInit(&var);
                        hRes = pObj->Get(L"__CLASS", 0, &var, 0, 0);
                        if (SUCCEEDED(hRes) && (V_VT(&var) == VT_BSTR))
                        {
                            if (aListRootSystemClasses.Add(V_BSTR(&var)) != CWStringArray::no_error)
                                hRes = WBEM_E_OUT_OF_MEMORY;
                        }
                        VariantClear(&var);
                    }
                    pObj->Release();
                }
            }
            Objects[i]->Release();
        }
    }

    pSvc->Release();

    return hRes;
}


//
//
//  throws because of  the WStringArray
//
//
HRESULT CRepository::RecursiveDeleteClassesFromNamespace(IWmiDbSession *pSession,
                                                         const wchar_t *wszNamespace,
                                                         CWStringArray &aListRootSystemClasses,
                                                         bool bDeleteInThisNamespace)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    IWmiDbHandle *pNs = NULL;
    //Open Namespace
    hRes = OpenEseNs(pSession, wszNamespace, &pNs); 
    CReleaseMe rmNS(pNs);

    //Delete classes from this namespace if necessary
    if (SUCCEEDED(hRes) && bDeleteInThisNamespace)
    {
        for (int i = 0; i != aListRootSystemClasses.Size(); i++)
        {
            hRes = DeleteByPath(pSession, pNs, aListRootSystemClasses[i], 0);
            if (hRes == WBEM_E_NOT_FOUND)
                hRes = WBEM_S_NO_ERROR;
            else if (FAILED(hRes))
                break;
        }
    }
    if (FAILED(hRes)) return hRes;

    //Special class that needs to be deleted is the __classes, and needs to go from all
    //namespaces
    hRes = DeleteByPath(pSession, pNs, L"__classes", 0);
    if (hRes == WBEM_E_NOT_FOUND) hRes = WBEM_S_NO_ERROR;
    if (FAILED(hRes)) return hRes;

    //Enumerate child namespaces...
    CWStringArray aListNamespaces;
    CNamespaceListSink * pSink = new CNamespaceListSink(aListNamespaces);  // SEC:REVIEWED 2002-03-22 : How does this object handle out-of-mem on the <aListNamespaces> ?
    if (pSink == NULL) return WBEM_E_OUT_OF_MEMORY;
    pSink->AddRef();    
    CReleaseMe rmSink(pSink);

    hRes = ExecQuery(pSession, pNs, L"select * from __namespace", pSink, 0);
    if (FAILED(hRes)) return hRes;

    //Work through list and call ourselves with that namespace name...
    for (int i = 0; i != aListNamespaces.Size(); i++)
    {
        //Build the full name of this namespace
        size_t tmpLength = wcslen(wszNamespace) + wcslen(aListNamespaces[i]) + wcslen(L"\\") + 1;
        wmilib::auto_buffer<WCHAR> wszChildNamespace( new WCHAR[tmpLength]);
        if (wszChildNamespace.get() == NULL) return WBEM_E_OUT_OF_MEMORY;
          
        StringCchCopyW(wszChildNamespace.get(), tmpLength, wszNamespace);
        StringCchCatW(wszChildNamespace.get(), tmpLength, L"\\");
        StringCchCatW(wszChildNamespace.get(), tmpLength, aListNamespaces[i]);

        //Do the deletion...
        hRes = RecursiveDeleteClassesFromNamespace(pSession, wszChildNamespace.get(), aListRootSystemClasses, true);
        if (FAILED(hRes)) return hRes;
    }

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\crep.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  CREP.H
//
//  Wrappers for repository drivers
//
//  raymcc  27-Apr-00       WMI Repository init & mapping layer
//
//***************************************************************************

#ifndef _CREP_H_
#define _CREP_H_


class CRepository
{
    static IWmiDbSession    *m_pEseSession;
    static IWmiDbHandle     *m_pEseRoot;
    static IWmiDbController *m_pEseController;

    static HRESULT EnsureDefault();
	static HRESULT UpgradeSystemClasses();
	static HRESULT GetListOfRootSystemClasses(CWStringArray &aListRootSystemClasses);
	static HRESULT RecursiveDeleteClassesFromNamespace(IWmiDbSession *pSession, 
														 const wchar_t *wszNamespace, 
														 CWStringArray &aListRootSystemClasses, 
														 bool bDeleteInThisNamespace);

public:
    static HRESULT GetObject(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszObjectPath,
        IN ULONG uFlags,
        OUT IWbemClassObject **pObj
        );

    static HRESULT PutObject(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN REFIID riid,
        IN LPVOID pObj,
        IN DWORD dwFlags
        );

    static HRESULT DeleteObject(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN REFIID riid,
        IN LPVOID pObj,
        IN DWORD dwFlags
        );

    static HRESULT DeleteByPath(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszPath,
        IN DWORD uFlags
        );

    static HRESULT ExecQuery(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszQuery,
        IN IWbemObjectSink *pSink,
		IN LONG lFlags
        );

    static HRESULT QueryClasses(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN ULONG uFlags,                //  WBEM_FLAG_DEEP = 0,  WBEM_FLAG_SHALLOW = 1,
        IN LPCWSTR pszSuperclass,
        IN IWbemObjectSink *pSink
        );

    static HRESULT InheritsFrom(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszSuperclass,
        IN LPCWSTR pszSubclass
        );

    static HRESULT GetRefClasses(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszClass,
        IN BOOL bIncludeSubclasses,
        OUT CWStringArray &aClasses
        );

    static HRESULT GetInstanceRefs(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszTargetObject,
        IN IWbemObjectSink *pSink
        );

    static HRESULT GetClassesWithRefs(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWbemObjectSink *pSink
        );
        // Gets all classes which have a [HasClassRefs] class qualifier

    static HRESULT BuildClassHierarchy(
        IN IWmiDbSession *pSession,
        IN  IWmiDbHandle *pNs,
        IN  LPCWSTR pBaseClassName,
        IN  LONG lFlags,
        OUT wmilib::auto_ptr<CDynasty> & pDynasty           // use operator delete
        );
         // WBEM_E_NOT_FOUND has special meaning; check lFlags too

    static HRESULT FindKeyRoot(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR wszClassName,
        OUT IWbemClassObject** ppKeyRootClass
        );

    static HRESULT TableScanQuery(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN LPCWSTR pszClassName,
        IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
        IN DWORD dwFlags,
        IN IWbemObjectSink *pSink
        );

    // Setup, startup, init, etc.
    // ==========================

    static HRESULT InitDriver(
        IN  ULONG uFlags,
        IN  IWbemClassObject *pMappedNs,
        OUT IWmiDbController **pResultController,
        OUT IWmiDbSession **pResultRootSession,
        OUT IWmiDbHandle  **pResultVirtualRoot
        );

    static HRESULT OpenScope(
        IN  IWmiDbSession *pParentSession,      //Parent session to use to 
        IN  LPWSTR pszTargetScope,              // NS or scope
        IN  GUID *pTransGuid,                   // Transaction GUID for connection
        OUT IWmiDbController **pDriver,         // Driver
        OUT IWmiDbSession **pSession,           // Session
        OUT IWmiDbHandle  **pScope,             // Scope
        OUT IWmiDbHandle  **pNs                 // Nearest NS
        );

    static HRESULT EnsureNsSystemInstances(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        );

	static HRESULT CRepository::EnsureNsSystemRootObjects(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        );

	static HRESULT CRepository::EnsureNsSystemSecurityObjects(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNs,
        IN IWmiDbSession *pParentSession,
        IN IWmiDbHandle *pParentNs
        );

    static HRESULT Init();
    static HRESULT Shutdown(BOOL bIsSystemShutDown);

    static HRESULT GetDefaultSession(
        OUT IWmiDbSession **pSession
        );

    static HRESULT OpenEseNs(
        IN IWmiDbSession *pSession,
        IN  LPCWSTR pszNamespace,
        OUT IWmiDbHandle **pHandle
        );

    static HRESULT CreateEseNs(
        IN  IWmiDbSession *pSession,
        IN  LPCWSTR pszNamespace,
        OUT IWmiDbHandle **pHandle
        );

    //Get a new session from the database that can hold transactioning states and anything else
    //needed for a particular session
    static HRESULT GetNewSession(OUT IWmiDbSession **ppSession);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\decor.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DECOR.H

Abstract:

History:

--*/

#ifndef __WBEM_DECORATOR__H_
#define __WBEM_DECORATOR__H_


class CDecorator : public IWbemDecorator
{
protected:
    long m_lRefCount;
    LIST_ENTRY m_Entry;    

public:
    CDecorator();
    ~CDecorator();

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(DecorateObject)(IWbemClassObject* pObject, 
                                WBEM_CWSTR wszNamespace);
    STDMETHOD(UndecorateObject)(IWbemClassObject* pObject);
    STDMETHOD(AddRefCore)();
    STDMETHOD(ReleaseCore)();
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\decor.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DECOR.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemcore.h>
#include <decor.h>
#include <clicnt.h>

CDecorator::CDecorator():m_lRefCount(0)
{
    gClientCounter.AddClientPtr(&m_Entry);
}

CDecorator::~CDecorator()
{
    gClientCounter.RemoveClientPtr(&m_Entry);
}
	
ULONG STDMETHODCALLTYPE CDecorator::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}

ULONG STDMETHODCALLTYPE CDecorator::Release()
{
    long lRef = InterlockedDecrement(&m_lRefCount);
    if(lRef == 0)
        delete this;
    return lRef;
}

STDMETHODIMP CDecorator::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemDecorator)
    {
        AddRef();
        *ppv = (IWbemDecorator*)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP CDecorator::DecorateObject(IWbemClassObject* pObject, 
                                        WBEM_CWSTR wszNamespace)
{
    CWbemObject* pIntObj = (CWbemObject*)pObject;
    return pIntObj->Decorate(ConfigMgr::GetMachineName(), wszNamespace);
}

STDMETHODIMP CDecorator::UndecorateObject(IWbemClassObject* pObject)
{
    CWbemObject* pIntObj = (CWbemObject*)pObject;
    pIntObj->Undecorate();
    return WBEM_S_NO_ERROR;
}
    
STDMETHODIMP CDecorator::AddRefCore()
{
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CDecorator::ReleaseCore()
{
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\dynasty.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
//***************************************************************************
//
//  DYNASTY.H
//
//  raymcc      24-Apr-00       Created
//
//***************************************************************************

#ifndef _DYNASTY_H_
#define _DYNASTY_H_

class CDynasty
{
private:
	CDynasty();
    CDynasty(IWbemClassObject* pClassObj);
public:
    LPWSTR              m_wszClassName;
    IWbemClassObject*   m_pClassObj;        // AddRef'ed, Released
    CFlexArray          m_Children;       // Child classes
    LPWSTR              m_wszKeyScope;

    BOOL                m_bKeyed;
    BOOL                m_bDynamic;
    BOOL                m_bAbstract;
    BOOL                m_bAmendment;

    ~CDynasty();

    BOOL IsKeyed() {return m_bKeyed;}
    BOOL IsDynamic() {return m_bDynamic;}
    BOOL IsAbstract() {return m_bAbstract;}
    BOOL IsAmendment() {return m_bAbstract;}

    LPCWSTR GetKeyScope() { return m_wszKeyScope; }
    void AddChild(CDynasty* pChild);
    void SetKeyScope(LPCWSTR wszKeyScope);

    static CDynasty * Create(IWbemClassObject * pObj);
};

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\localloc.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\dynasty.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  DYNASTY.H
//
//  raymcc      24-Apr-00       Created
//
//***************************************************************************


#include "precomp.h"
#include <windows.h>
#include <stdio.h>
#include <wbemcore.h>

CDynasty * CDynasty::Create(IWbemClassObject * pObj)
{

    try
    {
        return new CDynasty(pObj);
    }
    catch(CX_Exception &)
    {
        return 0;
    }
}

//***************************************************************************
//
//***************************************************************************
// ok

CDynasty::CDynasty(IWbemClassObject* pClassObj)
{
    m_wszClassName = 0;
    m_pClassObj = 0;
    m_bKeyed = 0;
    m_bDynamic = 0;
    m_bAbstract = 0;
    m_bAmendment = 0;

    

    m_wszKeyScope = 0;

    if (pClassObj)
    {
        // Get class name from the object
        CVar v;
        HRESULT hres = ((CWbemObject *) pClassObj)->GetClassName(&v);
        if (hres == WBEM_E_OUT_OF_MEMORY)
            throw CX_MemoryException();
        else if(FAILED(hres) || v.GetType() != VT_BSTR)
        {
            m_wszClassName = NULL;
            m_pClassObj = NULL;
            return;
        }
		size_t tmpLength = wcslen(v.GetLPWSTR())+1;  // SEC:REVIEWED 2002-03-22 : unbounded
        m_wszClassName = new WCHAR[tmpLength];
        if (m_wszClassName == 0)
        {
            throw CX_MemoryException();
        }
        StringCchCopyW(m_wszClassName, tmpLength, v.GetLPWSTR());

        // from now on, no throw
        m_pClassObj = pClassObj;
        m_pClassObj->AddRef();

        // Get Dynamic and Keyed bits
        // ==========================

        m_bKeyed = ((CWbemClass *) m_pClassObj)->IsKeyed();
        m_bDynamic = ((CWbemClass*)m_pClassObj)->IsDynamic();
        m_bAbstract = ((CWbemClass*)m_pClassObj)->IsAbstract();
        m_bAmendment = ((CWbemClass*)m_pClassObj)->IsAmendment();        
    }
}


//***************************************************************************
//
//***************************************************************************
// ok

CDynasty::~CDynasty()
{
    delete m_wszClassName;

    if (m_pClassObj)
        m_pClassObj->Release();

    for (int i = 0; i < m_Children.Size(); i++)
        delete (CDynasty *) m_Children.GetAt(i);

    if (m_wszKeyScope)
        delete m_wszKeyScope;
}

//***************************************************************************
//
//***************************************************************************
// ok

void CDynasty::AddChild(CDynasty* pChild)
{
    if (m_Children.Add(pChild) == CFlexArray::out_of_memory)
        throw CX_MemoryException();
}

//***************************************************************************
//
//***************************************************************************
// ok
void CDynasty::SetKeyScope(LPCWSTR wszKeyScope)
{
    // If no key scope is provided and we are keyed, we are it.
    // ========================================================

    if (wszKeyScope == NULL && m_bKeyed)
    {
        wszKeyScope = m_wszClassName; // aliasing!
    }

	size_t tmpLength = wcslen(wszKeyScope)+1;    // SEC:REVIEWED 2002-03-22 : unbounded
    m_wszKeyScope = new WCHAR[tmpLength];
    if (m_wszKeyScope == 0)
        throw CX_MemoryException();

    StringCchCopyW(m_wszKeyScope, tmpLength, wszKeyScope);

    for (int i = 0; i < m_Children.Size(); i++)
        ((CDynasty *) m_Children.GetAt(i))->SetKeyScope(wszKeyScope);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\internalmerger.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    INTERNALMERGER.CPP

Abstract:

    CInternalMerger class.

History:

    30-Nov-00   sanjes    Created.

--*/

#include "precomp.h"

#pragma warning (disable : 4786)
#include <wbemcore.h>
#include <map>
#include <vector>
#include <genutils.h>
#include <oahelp.inl>
#include <wqllex.h>
#include "wmimerger.h"
#include "internalmerger.h"

static    long    g_lNumMergers = 0L;

//***************************************************************************
//
//  class CInternalMerger
//
//  This class is a 'reverse fork'.  It consumes two sinks and outputs
//  one.  Its purpose is to merge instances of the same key in a given
//  dynasty.  Each CInternalMerger has two inputs, (a) instances of the class
//  in question, (b) instances of from another Merger representing
//  instances of subclasses.  Given classes A,B:A,C:B, for example,
//  where "<--" is a sink:
//
//      | own:Instances of A
//  <---|                 | own:Instances of B
//      | child: <--------|
//                        | child:Instances of C
//
//
//  The two input sinks for CInternalMerger are <m_pOwnSink> which receives
//  instances from the provider for "A", for example, and the <m_pChildSink>
//  which receives instances from the underyling Merger.
//
//  The mergers operate asynchronously to each other.  Therefore,
//  the instances for A may arrive in its CInternalMerger sink before instances
//  of the child classes have arrived in theirs.
//
//  As objects arrive in the owning CInternalMerger for a class, AddOwnObject()
//  is called.  As objects arrive from a child sink, AddChildObject()
//  is called.  In either case, if the object with a given key
//  arrives for the first time, it is simply added to the map. If
//  it is already there (via a key lookup), then a merge is performed
//  via CWbemInstance::AsymmetricMerge.  Immediately after this merge,
//  the object is dispatched up to the next parent sink via the parent's
//  AddChildObject and removed from the map.
//
//  Note that in a class hierarchy {A,B:A,C:B} an enumeration/query is
//  performed only against the classes in the CDynasty referenced in
//  the query. This logic occurs in CQueryEngine::EvaluateSubQuery.
//  For example, if "select * from B" is the query, only queries
//  for B and C are performed.  The CInternalMerger logic will do individual
//  'get object' calls for any instances needed in A to complete
//  the merged B/C instances while merging is taking place.
//
//***************************************************************************


#pragma warning(disable:4355)

static long g_lNumInternalMergers = 0L;

CInternalMerger::CInternalMerger(
    CWmiMergerRecord*    pWmiMergerRecord,
    CMergerSink* pDest,
    CWbemClass* pOwnClass,
    CWbemNamespace* pNamespace,
    IWbemContext* pContext
    )
    :   m_pDest(pDest), m_bOwnDone(FALSE),
        m_bChildrenDone(FALSE), m_pNamespace(pNamespace), m_pContext(pContext),
        m_pOwnClass(pOwnClass), m_bDerivedFromTarget(TRUE), m_lRef(0),
        m_pSecurity(NULL), m_pWmiMergerRecord( pWmiMergerRecord ),
        m_pOwnSink( NULL ), m_pChildSink( NULL ), m_hErrorRes( WBEM_S_NO_ERROR ),
        m_lTotalObjectData( 0L ), m_Throttler()
{
    // We do want to AddRef() in this case, since we will potentially be the only ones holding
    // onto the destination sink.  In this case, our child and owner sink will AddRef() us.  When
    // they perform a final release on us, we will release the destination sink.  If, on the other
    // hand we are outright deleted if this value is non-NULL we will clean up there as well
    m_pDest->AddRef();

    if(m_pContext)
        m_pContext->AddRef();
    if(m_pNamespace)
        m_pNamespace->AddRef();

    if(m_pOwnClass)
    {
        m_pOwnClass->AddRef();
        CVar v;
        if (SUCCEEDED(pOwnClass->GetClassName(&v)))
            m_wsClass = v.GetLPWSTR();
        // delegate Initialzie to check
    }

    // Retrieve call security. Need to create a copy for use on another thread
    // =======================================================================

    m_pSecurity = CWbemCallSecurity::MakeInternalCopyOfThread();

    // Keep the count up to date
    InterlockedIncrement( &g_lNumInternalMergers );
}

//***************************************************************************
//
//***************************************************************************

CInternalMerger::~CInternalMerger()
{
    if ( NULL != m_pDest )
    {
        m_pDest->Release();
        m_pDest = NULL;
    }

    // Map should be empty whenever we destruct
    _DBG_ASSERT( m_map.size() == 0 );
    _DBG_ASSERT( m_lTotalObjectData == 0L );

    if(m_pNamespace)
        m_pNamespace->Release();
    if(m_pContext)
        m_pContext->Release();
    if(m_pOwnClass)
        m_pOwnClass->Release();

    if(m_pSecurity)
        m_pSecurity->Release();

    // Keep the count up to date
    InterlockedDecrement( &g_lNumInternalMergers );
}
//***************************************************************************
//
//***************************************************************************

long CInternalMerger::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//***************************************************************************

long CInternalMerger::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);

    // On Final Release, we will clear up the actual destination sink
    if(lRef == 0)
    {
        // Enter the critical section, save off the sink pointer in a
        // temporary variable, set the member to NULL and then release
        // the sink.  This will prevent reentrancy issues with the merger
        // (e.g. during a Cancel).

        Enter();

        CMergerSink*    pSink = m_pDest;
        m_pDest = NULL;

        Leave();

        pSink->Release();
    }
    return lRef;
}

HRESULT CInternalMerger::Initialize( void )
{
    if (m_pOwnClass)
        if (NULL == (WCHAR *)m_wsClass)
            return WBEM_E_OUT_OF_MEMORY;

    HRESULT    hr = m_Throttler.Initialize();
    
    if ( SUCCEEDED( hr ) )
    {
        hr = m_pWmiMergerRecord->GetWmiMerger()->CreateMergingSink( eMergerOwnSink, NULL, this, (CMergerSink**) &m_pOwnSink );

        if ( SUCCEEDED( hr ) )
        {
            hr = m_pWmiMergerRecord->GetWmiMerger()->CreateMergingSink( eMergerChildSink, NULL, this, (CMergerSink**) &m_pChildSink );
        }

    }    // IF throttler initialized

    return hr;
}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::GetKey(IWbemClassObject* pObj, WString& wsKey)
{
    LPWSTR wszRelPath = ((CWbemInstance*)pObj)->GetRelPath();
    if (wszRelPath == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Object with no path submitted to a merge\n"));
        wsKey.Empty();
        return;
    }

    WCHAR* pwcDot = wcschr(wszRelPath, L'.');
    if (pwcDot == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Object with invalid path %S submitted to a merge\n", 
        	                       wszRelPath));
        wsKey.Empty();

        // Clean up the path
        delete [] wszRelPath;

        return;
    }

    wsKey = pwcDot+1;
    delete [] wszRelPath;
}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::SetIsDerivedFromTarget(BOOL bIs)
{
    m_bDerivedFromTarget = bIs;

    if (!bIs)
    {
        // We will need our OwnSink for GetObject calls
        // ============================================

        m_pOwnSink->AddRef();
    }
}

//
//    The algorithm for reporting memory usage is as follows:
//
//    Lowest level indicate (i.e. the one coming in from a provider), will iterate
//    all objects sent down by the provider and report them to the arbitrator.  At
//    the end of processing we will report the negative of this value.  Reason for
//    this is that we will be holding onto all of these objects for the length of
//    the function, and may get throttled at any time.
//
//    During processing, we will account for objects added to the map, and removed
//    from the map.  When we remove objects from the map, we add them to an array
//    which we indicate.  Usually we merge objects, sometimes we pass the objects
//    straight down.  We need to account for these objects during the call to
//    indicate, so we will total these and report usage BEFORE calling Indicate.
//    After Indicate returns we will remove their usage, since we will be releasing
//    them and hence no longer care about them.
//
//    Except for the case of the lowest level indicate, we will not account for
//    pass-through objects - those that are sent in and sent out.  It is assumed
//    that the calling function has accounted for these objects.
//
//    There will be small windows where a single object may get reported multiple
//    times.  This would occur if we reported a new object prior to indicate,
//    then in the call to indicate the merger added to the map, or the finalizer
//    added to its list.  When the call returns, we will report removal.  The object
//    may actually get removed on another thread, but if we get throttled, we
//    still need to account for it.  In tight memory conditions if multiple threads
//    cause addition/removal at jus tthe right times and are then throttled, we will
//    get stuck sleeping and each could report an object multiple times. However, this
//    should only occur in relatively stressful conditions, and should be rare.
//

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::IndicateArrayAndThrottle(
    long lObjectCount, CRefedPointerArray<IWbemClassObject>* pObjArray,
    CWStringArray* pwsKeyArray, long lMapAdjustmentSize, long lNewObjectSize, bool bThrottle,
    bool bParent, long* plNumIndicated )
{
    // In this case, we report the size of the objects as they were adjusted in the map
    // in addition to new objects we created. The new objects will be released after
    // we indicate, so we will account for them post-indicate, since we will no longer
    // be holding onto them
    HRESULT    hRes = ReportMemoryUsage( lMapAdjustmentSize);

    // Use scoped memory cleanup to handle the new objects
    // Note that in the event of an exception this will cleanup properly
    CScopedMemoryUsage    scopedMemUsage( this );

    if ( SUCCEEDED( hRes ) )
    {
        hRes = scopedMemUsage.ReportMemoryUsage( lNewObjectSize );
    }

    // If the value is > 0L, and we succeeded, we can go ahead indicate the objects now.
    // The refed pointer array should properly clean up.

    if ( SUCCEEDED( hRes ) )
    {
        // If we have "own instances" in the array, we need to retrieve those objects.
        // Each is retrieved individually
        if ( NULL != pwsKeyArray && pwsKeyArray->Size() > 0 )
        {

            for ( int x = 0; SUCCEEDED( hRes ) && x < pwsKeyArray->Size(); x++ )
            {
                IWbemClassObject*    pMergedInstance = NULL;
                hRes = GetOwnInstance( pwsKeyArray->GetAt( x ), &pMergedInstance );
                CReleaseMe    rm( pMergedInstance );

                // If we retrieved a merged instance at this time, we should place it in
                // the array for indicating
                if ( SUCCEEDED( hRes ) && NULL != pMergedInstance )
                {
                    // Handle object size here.  This is a merged object, so we must
                    // account for it in the size variable

                    long    lObjSize = 0L;
                    hRes = GetObjectLength( pMergedInstance, &lObjSize );

                    if ( SUCCEEDED( hRes ) )
                    {
                        if ( pObjArray->Add( pMergedInstance ) < 0L )
                        {
                            hRes = WBEM_E_OUT_OF_MEMORY;
                            ERRORTRACE((LOG_WBEMCORE, "Add to array failed in IndicateArrayAndThrottle, hresult is 0x%x",
                                hRes));
                            continue;
                        }

                        lNewObjectSize += lObjSize;

                        lObjectCount++;

                        // Report size now, since each call to GetOwnInstance() may take some time
                        hRes = scopedMemUsage.ReportMemoryUsage( lObjSize );

                    }    // IF SUCCEEDED( hRes )

                }    // IF we retrieved an object

            }    // FOR enum WStringArray

        }    // IF need to retrieve OWN instances

        if ( SUCCEEDED( hRes ) )
        {
            // If we have stuff to indicate, we will trust that indicate to do
            // proper throttling.  Otherwise, the buck stops here, so we will
            // request throttling
            if ( lObjectCount > 0L )
            {
                // Not a lowest level indicate
                hRes = m_pDest->Indicate( lObjectCount, pObjArray->GetArrayPtr(), false, plNumIndicated );
            }

        }    // IF success after retrieving parent instances

    }    // IF SUCCESS after reporting memory usage

    // Release all Indicated objects here in order to reduce memory overhead in case
    // we sleep.
    pObjArray->RemoveAll();

    // Finally, since we are no longer really responsible for new objects, we
    // will report removal to the arbitrator now if appropriate, and catch any
    // errors as they come up.  We do this manually since we may end up
    // throttling for awhile

    HRESULT    hrTemp = scopedMemUsage.Cleanup();

    // If this failed and we previously had a success code, record the
    // failure

    if ( SUCCEEDED( hRes ) && FAILED( hrTemp ) )
    {
        hRes = hrTemp;
    }

    // Now, if we're *still* successful, and it is appropriate to
    // throttle, we should do merger specific throttling now if it
    // is enabled.
    if ( SUCCEEDED( hRes ) && bThrottle && m_pWmiMergerRecord->GetWmiMerger()->MergerThrottlingEnabled() )
    {
        hRes = m_Throttler.Throttle( bParent, m_pWmiMergerRecord );
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::AddOwnObjects(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  )
{


    // Ping the throttler
    m_Throttler.Ping( true, m_pWmiMergerRecord->GetWmiMerger() );

    // On the lowest level indicate, we will walk all of the objects and log them to the arbitrator
    // since we will effectively be holding them for the duration of this operation
    long        lIndicateSize = 0L;

    // Use scoped memory cleanup to handle the new objects
    // Note that in the event of an exception this will cleanup properly
    CScopedMemoryUsage    scopedMemUsage( this );

    HRESULT hRes = S_OK ;
    if ( bLowestLevel )
    {
        for ( long lCtr = 0L; lCtr < lObjectCount; lCtr++ )
        {
            lIndicateSize += ((CWbemObject*) pObjArray[lCtr])->GetBlockLength();
        }

        // If we're going further, we also report the total size of the indicate, since we
        // may be sitting on the memory for awhile what with throttling and all.
        hRes = scopedMemUsage.ReportMemoryUsage( lIndicateSize );
    }

    // Used to track dispersion of objects so we can keep the throttler adjusted
    // properly
    long    lNumChildObjAdjust = 0L;
    long    lNumOwnObjAdjust = 0L;

    CRefedPointerArray<IWbemClassObject> objArray;
    long        lNumToIndicate = 0L;

    // Following variables track the memory size adjustments for the arbitrator and
    // batching
    long        lMapAdjustmentSize = 0L;
    long        lSizeMergedObjects = 0L;
    long        lBatchSize = 0L;

    // Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec    ics( m_Throttler.GetCritSec() );   // SEC:REVIEWED 2002-03-22 : Assumes entry

    // If we've been cancelled, then we should bail out.


    
    if ( SUCCEEDED( hRes ) )
    {
        if ( FAILED ( m_hErrorRes ) )
        {
            hRes = m_hErrorRes;
        }
        else
        {
            // We shouldn't be here if m_bOwnDone is set!
            _DBG_ASSERT( !m_bOwnDone );
            if ( m_bOwnDone )
            {
                hRes = WBEM_E_INVALID_OPERATION;
            }

        }
    }    // IF still in a success State

    try
    {

        for ( long    x = 0; SUCCEEDED( hRes ) && x < lObjectCount; x++ )
        {
            // If we've been cancelled, then we should bail out.
            // We need to do the check in here, since this loop can
            // exit and reeenter the critical section in the middle
            // of processing.
            if ( FAILED( m_hErrorRes ) )
            {
                hRes = m_hErrorRes;
                continue;
            }

            IWbemClassObject*    pObj = pObjArray[x];
            WString wsKey;

            // Track the size for batching
            lBatchSize += ((CWbemObject*) pObj)->GetBlockLength();

            GetKey(pObj, wsKey);

            MRGRKEYTOINSTMAPITER it = m_map.find(wsKey);
            if (it == m_map.end())
            {
                // Not there. Check if there is any hope for children
                // ==================================================

                if (m_bChildrenDone)
                {
                    if (m_bDerivedFromTarget)
                    {
                        // We queue up all results for the ensuing indicate into a single batch we will
                        // send down the line after we exit our critical section.  This is especially
                        // important since we may get blocked during the call to indicate by the
                        // finalizer.

                        if ( objArray.Add( pObj ) < 0L )   // SEC:REVIEWED 2002-03-22 : Needs EH
                        {
                            hRes = WBEM_E_OUT_OF_MEMORY;
                            ERRORTRACE((LOG_WBEMCORE, "Add to array failed in AddOwnObject, hresult is 0x%x",
                                hRes));
                            continue;
                        }
                        lNumToIndicate++;

                    }
                    else
                    {
                        // ignore
                    }
                }
                else
                {
                    // Insert
                    CInternalMergerRecord& rRecord = m_map[wsKey];
                    rRecord.m_pData = (CWbemInstance*) pObj;
                    pObj->AddRef();
                    rRecord.m_bOwn = TRUE;
                    rRecord.m_dwObjSize = ((CWbemObject*)pObj)->GetBlockLength();

                    // We just added a parent object to the map, so reflect that in the totals
                    lNumOwnObjAdjust++;

                    // Add since we are adding to the map
                    lMapAdjustmentSize += rRecord.m_dwObjSize;

                }
            }
            else if(it->second.m_bOwn)
            {
                ERRORTRACE((LOG_WBEMCORE, "Provider supplied duplicate instances for key %S\n", wsKey));
            }
            else
            {
                // Attempt to merge
                // ================

                hRes = CWbemInstance::AsymmetricMerge(
                                    (CWbemInstance*)pObj,
                                    (CWbemInstance*)it->second.m_pData);
                if(FAILED(hRes))
                {
                    ERRORTRACE((LOG_WBEMCORE, "Merge conflict for instances with key %S\n", wsKey));
                    continue;
                }

                // We queue up all results for the ensuing indicate into a single batch we will
                // send down the line after we exit our critical section.  This is especially
                // important since we may get blocked during the call to indicate by the
                // finalizer.

                if ( objArray.Add( (IWbemClassObject*) it->second.m_pData ) < 0L )   // SEC:REVIEWED 2002-03-22 : Needs EH
                {
                    hRes = WBEM_E_OUT_OF_MEMORY;
                    ERRORTRACE((LOG_WBEMCORE, "Add to array failed in AddOwnObject, hresult is 0x%x",
                        hRes));
                    continue;
                }

                // Account for objects we have created/modified on the fly
                lSizeMergedObjects += ((CWbemObject*)it->second.m_pData)->GetBlockLength();
                lNumToIndicate++;

                // Subtract since we are removing from the map
                lMapAdjustmentSize -= it->second.m_dwObjSize;

                // Tricky
                // If Children are done and the DispatchOwnIter happens to be pointing
                // at the object we are about to erase, we should point it to the result
                // of the call to erase so we won't potentially access released memory
                // when DispatchOwn reenters its critical section

                bool    bSaveErase = false;

                if ( m_bChildrenDone )
                {
                    bSaveErase = ( m_DispatchOwnIter == it );
                }

                it->second.m_pData->Release();

                if ( bSaveErase )
                {
                    m_DispatchOwnIter = m_map.erase(it);
                }
                else
                {
                    m_map.erase(it);
                }

                // We just removed a child object from the map, so reflect that in the totals
                lNumChildObjAdjust--;

            }

            if ( SUCCEEDED( hRes ) )
            {
                // If we have reached a complete batch, or reached the last object we need to
                // send stuff down the wire.
                if ( m_Throttler.IsCompleteBatch( lBatchSize ) || x == ( lObjectCount - 1 ) )
                {
                    // Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
                    // section.  Note that we may not be in a critical section here, but that would be if something
                    // happened when trying to retrieve an instance.  In that case, we'll be returning an error, so
                    // the adjustment should be 0L anyway.
                    _DBG_ASSERT( SUCCEEDED( hRes ) || lMapAdjustmentSize == 0L );
                    AdjustLocalObjectSize( lMapAdjustmentSize );

                    if ( SUCCEEDED( hRes ) )
                    {
                        // Adjust the throttler now.
                        AdjustThrottle( lNumOwnObjAdjust, lNumChildObjAdjust );
                    }

                    // This object is smart enough to recognize if we've already left and not do
                    // so again, if we have.
                    ics.Leave();

                    // Now go ahead and perform the indicate we've been leading ourselves up to
                    if ( SUCCEEDED( hRes ) )
                    {
                        hRes = IndicateArrayAndThrottle( lNumToIndicate,
                                                        &objArray,
                                                        NULL,
                                                        lMapAdjustmentSize,
                                                        lSizeMergedObjects,
                                                        true,
                                                        true,    // Child
                                                        plNumIndicated );

                        // If we are in a success state and we have not enumerated all objects
                        // we should reset the size counters and reenter the critical section
                        if ( SUCCEEDED( hRes ) && x < ( lObjectCount ) - 1 )
                        {
                            lMapAdjustmentSize = 0L;
                            lSizeMergedObjects = 0L;
                            lBatchSize = 0L;
                            lNumToIndicate = 0L;
                            lNumOwnObjAdjust = 0L;
                            lNumChildObjAdjust = 0L;

                            ics.Enter();
                        }
                    }

                }    // IF we should send the objects out

            }    // IF we are in a success state

        }    // FOR enum objects

    }
    catch( CX_MemoryException )
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
    }

    // Check error one last time
    if ( FAILED( m_hErrorRes ) )
    {
        hRes = m_hErrorRes;
    }

    // We may have looped, entered the critical section and exited, so make
    // sure we force our way out in case we're about to cancel
    ics.Leave();

    // If we are the lowest level and no objects made it out of the merger
    // we will ask the arbitrator to throttle this call
    if ( SUCCEEDED( hRes ) && bLowestLevel && *plNumIndicated == 0L )
    {
        // Since we don't want the fact we're sleeping in the arbitrator to
        // cause the merger to cancel operations, we'll increase the count
        // of threads throttling, and decrement when we return
        m_pWmiMergerRecord->GetWmiMerger()->IncrementArbitratorThrottling();

        // If we get an error indicating we were throttled, that is okay
        hRes = m_pWmiMergerRecord->GetWmiMerger()->Throttle();

        m_pWmiMergerRecord->GetWmiMerger()->DecrementArbitratorThrottling();


        if ( WBEM_E_ARB_THROTTLE == hRes || WBEM_S_ARB_NOTHROTTLING == hRes )
        {
            hRes = WBEM_S_NO_ERROR;
        }
    }

    if ( hRes == WBEM_E_ARB_CANCEL )
    {
        hRes = WBEM_E_CALL_CANCELLED ;
    }
    
    // If we are in a failed state, nothing is going to matter from this point on,
    // so tell the merger to cancel all underlying sinks.
    if ( FAILED( hRes ) )
    {
        m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::AddChildObjects(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated )
{
    HRESULT hRes = S_OK ;

    // Ping the throttler
    m_Throttler.Ping( false, m_pWmiMergerRecord->GetWmiMerger() );

    // On the lowest level indicate, we will walk all of the objects and log them to the arbitrator
    // since we will effectively be holding them for the duration of this operation
    long        lIndicateSize = 0L;
    long        lTotalIndicated = 0L;

    // Use scoped memory cleanup to handle the new objects
    // Note that in the event of an exception this will cleanup properly
    CScopedMemoryUsage    scopedMemUsage( this );

    if ( bLowestLevel )
    {
        for ( long lCtr = 0L; lCtr < lObjectCount; lCtr++ )
        {
            lIndicateSize += ((CWbemObject*) pObjArray[lCtr])->GetBlockLength();
        }

        // If we're going further, we also report the total size of the indicate, since we
        // may be sitting on the memory for awhile what with throttling and all.
        hRes = scopedMemUsage.ReportMemoryUsage( lIndicateSize );
    }


    // Used to track dispersion of objects so we can keep the throttler adjusted
    // properly
    long    lNumChildObjAdjust = 0L;
    long    lNumOwnObjAdjust = 0L;

    CRefedPointerArray<IWbemClassObject> objArray;
    long        lNumToIndicate = 0L;

    // Following variables track the memory size adjustments for the arbitrator and
    // batching
    long        lMapAdjustmentSize = 0L;
    long        lSizeMergedObjects = 0L;
    long        lBatchSize = 0L;

    // Used to keep track of instance keys we need to retrieve using
    // GetOwnInstance
    CWStringArray    wsOwnInstanceKeyArray;                 // SEC:REVIEWED 2002-03-22 : Needs EH

    // Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec    ics( m_Throttler.GetCritSec() );   // SEC:REVIEWED 2002-03-22 : Assumes entry

    // If we've been cancelled, then we should bail out.
    if ( SUCCEEDED( hRes ) )
    {
        if ( FAILED ( m_hErrorRes ) )
        {
            hRes = m_hErrorRes;
        }
        else
        {
            // We shouldn't be here if m_bChildrenDone is set!
            _DBG_ASSERT( !m_bChildrenDone );
            if ( m_bChildrenDone )
            {
                hRes = WBEM_E_INVALID_OPERATION;
            }

        }
    }    // IF still in a success State

    try
    {
        for ( long    x = 0; SUCCEEDED( hRes ) && x < lObjectCount; x++ )
        {

            // If we've been cancelled, then we should bail out.
            // We need to do the check in here, since this loop can
            // exit and reeenter the critical section in the middle
            // of processing.
            if ( FAILED( m_hErrorRes ) )
            {
                hRes = m_hErrorRes;
                continue;
            }

            IWbemClassObject*    pObj = pObjArray[x];
            
            // Track the size for batching
            lBatchSize += ((CWbemObject*) pObj)->GetBlockLength();

            WString wsKey;

            GetKey(pObj, wsKey);

            MRGRKEYTOINSTMAPITER it = m_map.find(wsKey);

            if (it == m_map.end())
            {
                // Check if there is any hope for parent
                // =====================================

                if(m_bOwnDone)
                {
    //                BSTR str = NULL;
    //                pObj->GetObjectText(0, &str);

                    // The following was commented out because it actually incorrectly logs
                    // an error if the child provider enumerates when the parent provider
                    // interprets a query and returns fewer instances.  Neither provider is wrong,
                    // but this error message causes needless worry.  In Quasar, we have to fix
                    // this whole merger thing to be smarter anyway.
                    //
                    // ERRORTRACE((LOG_WBEMCORE, "[Chkpt_1] [%S] Orphaned object %S returned by "
                    //    "provider\n", LPWSTR(m_wsClass), str));
    //                SysFreeString(str);
                    // m_pDest->Add(pObj);
                }
                else
                {
                    // insert

                    CInternalMergerRecord& rRecord = m_map[wsKey];
                    rRecord.m_pData = (CWbemInstance*)pObj;
                    pObj->AddRef();
                    rRecord.m_bOwn = FALSE;
                    rRecord.m_dwObjSize = ((CWbemObject*)pObj)->GetBlockLength();

                    // We just added a child object to the map, so reflect that in the totals
                    lNumChildObjAdjust++;

                    // Add since we are adding to the map
                    lMapAdjustmentSize += rRecord.m_dwObjSize;

                    // Check if parent's retrieval is needed
                    // =====================================

                    if (!m_bDerivedFromTarget)
                    {

                        // Add the instance name to the key array.  We will perform retrieval
                        // of these parent instances *outside* of our critical section
                        if ( wsOwnInstanceKeyArray.Add( wsKey ) != CFlexArray::no_error )   // SEC:REVIEWED 2002-03-22 : Needs EH
                        {
                            hRes = WBEM_E_OUT_OF_MEMORY;
                        }

                    }    // IF !m_bDerivedFromTarget

                 }
            }
            else if(!it->second.m_bOwn)
            {
                ERRORTRACE((LOG_WBEMCORE, "Two providers supplied conflicting "
                                "instances for key %S\n", wsKey));
            }
            else
            {
                // Attempt to merge
                // ================

                hRes = CWbemInstance::AsymmetricMerge(
                                            (CWbemInstance*)it->second.m_pData,
                                            (CWbemInstance*)pObj
                                            );
                if (FAILED(hRes))
                {
                    ERRORTRACE((LOG_WBEMCORE, "Merge conflict for instances with "
                        "key %S\n", wsKey));
                    continue;
                }

                // We queue up all results for the ensuing indicate into a single batch we will
                // send down the line after we exit our critical section.  This is especially
                // important since we may get blocked during the call to indicate by the
                // finalizer.

                if ( objArray.Add( pObj ) < 0L )   // SEC:REVIEWED 2002-03-22 : Needs EH
                {
                    hRes = WBEM_E_OUT_OF_MEMORY;
                    ERRORTRACE((LOG_WBEMCORE, "Add to array failed in AddChildObject, hresult is 0x%x",
                        hRes));
                    continue;
                }

                // Account for objects we have created on the fly
                lSizeMergedObjects += ((CWbemObject*) pObj)->GetBlockLength();
                lNumToIndicate++;

                // Subtract since we are removing from the map
                lMapAdjustmentSize -= it->second.m_dwObjSize;

                it->second.m_pData->Release();
                m_map.erase(it);

                // We just removed a parent object from the map, so reflect that in the totals
                lNumOwnObjAdjust--;

            }

            if ( SUCCEEDED( hRes ) )
            {
                // If we have reached a complete batch, or reached the last object we need to
                // send stuff down the wire.
                if ( m_Throttler.IsCompleteBatch( lBatchSize ) || x == ( lObjectCount - 1 ) )
                {
                    // Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
                    // section.  Note that we may not be in a critical section here, but that would be if something
                    // happened when trying to retrieve an instance.  In that case, we'll be returning an error, so
                    // the adjustment should be 0L anyway.
                    _DBG_ASSERT( SUCCEEDED( hRes ) || lMapAdjustmentSize == 0L );
                    AdjustLocalObjectSize( lMapAdjustmentSize );

                    if ( SUCCEEDED( hRes ) )
                    {
                        // Adjust the throttler now.
                        AdjustThrottle( lNumOwnObjAdjust, lNumChildObjAdjust );
                    }

                    // This object is smart enough to recognize if we've already left and not do
                    // so again, if we have.
                    ics.Leave();

                    // Now go ahead and perform the indicate we've been leading ourselves up to
                    if ( SUCCEEDED( hRes ) )
                    {
                        hRes = IndicateArrayAndThrottle( lNumToIndicate,
                                                        &objArray,
                                                        &wsOwnInstanceKeyArray,
                                                        lMapAdjustmentSize,
                                                        lSizeMergedObjects,
                                                        true,
                                                        false,    // Child
                                                        plNumIndicated
                                                        );

                        // If we are in a success state and we have not enumerated all objects
                        // we should reset the size counters and reenter the critical section
                        if ( SUCCEEDED( hRes ) && x < ( lObjectCount ) - 1 )
                        {
                            lMapAdjustmentSize = 0L;
                            lSizeMergedObjects = 0L;
                            lBatchSize = 0L;
                            lNumToIndicate = 0L;
                            lNumOwnObjAdjust = 0L;
                            lNumChildObjAdjust = 0L;

                            // Clear out the array
                            wsOwnInstanceKeyArray.Empty();

                            ics.Enter();
                        }
                    }

                }    // IF we should send the objects out

            }    // IF we are in a success state

        }    // FOR Enum Objects

    }
    catch( CX_MemoryException )
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_CRITICAL_ERROR;
    }


    // Check error one last time
    if ( FAILED( m_hErrorRes ) )
    {
        hRes = m_hErrorRes;
    }

    // We may have looped, entered the critical section and exited, so make
    // sure we force our way out in case we're about to cancel
    ics.Leave();

    // If we are the lowest level and no objects made it out of the merger
    // we will ask the arbitrator to throttle this call
    if ( SUCCEEDED( hRes ) && bLowestLevel && *plNumIndicated == 0L )
    {
        // Since we don't want the fact we're sleeping in the arbitrator to
        // cause the merger to cancel operations, we'll increase the count
        // of threads throttling, and decrement when we return
        m_pWmiMergerRecord->GetWmiMerger()->IncrementArbitratorThrottling();

        // If we get an error indicating we were throttled, that is okay
        hRes = m_pWmiMergerRecord->GetWmiMerger()->Throttle();

        m_pWmiMergerRecord->GetWmiMerger()->DecrementArbitratorThrottling();


        if ( WBEM_E_ARB_THROTTLE == hRes || WBEM_S_ARB_NOTHROTTLING == hRes )
        {
            hRes = WBEM_S_NO_ERROR;
        }
    }

    if ( hRes == WBEM_E_ARB_CANCEL )
    {
        hRes = WBEM_E_CALL_CANCELLED ;
    }

    // If we are in a failed state, nothing is going to matter from this point on,
    // so tell the merger to cancel all underlying sinks.
    if ( FAILED( hRes ) )
    {
        m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::AddOwnInstance( IWbemClassObject* pObj, LPCWSTR pwszTargetPath, IWbemClassObject** ppMergedInstance)
{
    HRESULT hRes = S_OK ;
    WString wsKey;

    // Ping the throttler
    m_Throttler.Ping( true, m_pWmiMergerRecord->GetWmiMerger() );

    // Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec    ics( m_Throttler.GetCritSec() );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    // If we've been cancelled, then we should bail out.
    if ( FAILED( m_hErrorRes ) )
    {
        hRes = m_hErrorRes;
    }

    GetKey(pObj, wsKey);

    // Find the instance - it should already be in the map.  If not, we shouldn't be
    // here

    long        lArbitratorAdjust = 0L;
    long        lNumChildObjAdjust = 0L;

    MRGRKEYTOINSTMAPITER it = m_map.find(wsKey);
    if (it != m_map.end())
    {
        // Attempt to merge
        // ================

        hRes = CWbemInstance::AsymmetricMerge(
                            (CWbemInstance*)pObj,
                            (CWbemInstance*)it->second.m_pData);

        if ( SUCCEEDED( hRes ) )
        {
            *ppMergedInstance = (IWbemClassObject*) it->second.m_pData;
            (*ppMergedInstance)->AddRef();

            // Subtract since we are removing from the map
            lArbitratorAdjust -= it->second.m_dwObjSize;

            it->second.m_pData->Release();
            m_map.erase(it);

            // We just removed a child object from the map, so reflect that in the totals
            lNumChildObjAdjust--;
        }
        else
        {
            ERRORTRACE((LOG_WBEMCORE, "Merge conflict for instances with "
                "key %S\n", wsKey));
        }

    }
    else
    {
        BSTR str = NULL;
        pObj->GetObjectText(0, &str);
        CSysFreeMe    sfm( str );

        // The provider has indicated an improper instance to an OwnInstance request.
        // We should always be able to find an instance in here.  We'll toss the instance
        // but we should output something to the error log since it sounds like
        // we have a broken provider
        //
         ERRORTRACE((LOG_WBEMCORE, "Provider responded to request for instance %S, with object %S  not in map\n", pwszTargetPath, str ));
    }

    // Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
    // section
    AdjustLocalObjectSize( lArbitratorAdjust );

    if ( SUCCEEDED( hRes ) )
    {
        // Adjust the throttler now.
        AdjustThrottle( 0L, lNumChildObjAdjust );
    }

    // This object is smart enough to recognize if we've already left and not do
    // so again, if we have.
    ics.Leave();

    // Always report adjustments
    hRes = ReportMemoryUsage( lArbitratorAdjust );

    // If we are in a failed state, nothing is going to matter from this point on,
    // so tell the merger to cancel all underlying sinks.
    if ( FAILED( hRes ) )
    {
        m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::RemoveInstance( LPCWSTR pwszTargetPath )
{
    HRESULT hRes = S_OK ;
    WString wsKey;

    // Track what we clean up
    long    lNumChildObjAdjust = 0L;
    long    lArbitratorAdjust = 0L;

    // Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec    ics( m_Throttler.GetCritSec() ); // SEC:REVIEWED 2002-03-22 : Assumes entry

    // If we've been cancelled, then we should bail out.
    if ( FAILED( m_hErrorRes ) )
    {
        hRes = m_hErrorRes;
    }

    // If the instance path is in our map, we should remove it
    MRGRKEYTOINSTMAPITER it = m_map.find( pwszTargetPath );
    if (it != m_map.end())
    {
        
        // Subtract since we are removing from the map
        lArbitratorAdjust -= it->second.m_dwObjSize;

        it->second.m_pData->Release();
        m_map.erase(it);

        // We just removed a child object from the map, so reflect that in the totals
        lNumChildObjAdjust--;
    }
    // Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
    // section
    AdjustLocalObjectSize( lArbitratorAdjust );

    if ( SUCCEEDED( hRes ) )
    {
        // Adjust the throttler now.
        AdjustThrottle( 0L, lNumChildObjAdjust );
    }

    // This object is smart enough to recognize if we've already left and not do
    // so again, if we have.
    ics.Leave();

    // Always report adjustments (this should be negative).
    hRes = ReportMemoryUsage( lArbitratorAdjust );

    // If we are in a failed state, nothing is going to matter from this point on,
    // so tell the merger to cancel all underlying sinks.
    if ( FAILED( hRes ) )
    {
        m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::DispatchChildren()
{
    long    lNumChildObjAdjust = 0L;
    long    lArbitratorAdjust = 0L;

    // Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec    ics( m_Throttler.GetCritSec() );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    MRGRKEYTOINSTMAPITER it = m_map.begin();

    while (it != m_map.end())
    {
        if (!it->second.m_bOwn)
        {
//            BSTR str = NULL;
//            it->second.m_pData->GetObjectText(0, &str);

            // The following was commented out because it actually incorrectly logs
            // an error if the child provider enumerates when the parent provider
            // interprets a query and returns fewer instances.  Neither provider is wrong,
            // but this error message causes needless worry.  In Quasar, we have to fix
            // this whole merger thing to be smarter anyway.
            //

//            ERRORTRACE((LOG_WBEMCORE, "Chkpt2 [%S] Orphaned object %S returned by "
//                "provider\n", LPWSTR(m_wsClass), str));

//            SysFreeString(str);

            // m_pDest->Add(it->second.m_pData);

            // Subtract since we are removing from the map
            lArbitratorAdjust -= it->second.m_dwObjSize;

            // Tricky
            // If Children are done and the DispatchOwnIter happens to be pointing
            // at the object we are about to erase, we should point it to the result
            // of the call to erase so we won't potentially access released memory
            // when DispatchOwn reenters its critical section

            bool    bSaveErase = false;

            if ( m_bChildrenDone )
            {
                bSaveErase = ( m_DispatchOwnIter == it );
            }

            it->second.m_pData->Release();
            it = m_map.erase(it);

            if ( bSaveErase )
            {
                m_DispatchOwnIter = it;
            }

            // We are removing child objects, so we need to adjust the throttling
            // totals appropriately

            lNumChildObjAdjust--;
        }
        else it++;
    }

    // Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
    // section
    AdjustLocalObjectSize( lArbitratorAdjust );

    // Apply the adjustment now.
    m_Throttler.AdjustNumChildObjects( lNumChildObjAdjust );

    // Mark the appropriate flags now this will also release throttling
    OwnIsDone();

    ics.Leave();

    // Always report adjustments
    HRESULT hrArbitrate = ReportMemoryUsage( lArbitratorAdjust );

    // If we get a failure we're over, the function will filter out noise, such as
    // requests to throttle (we're should actually *always* decrease the value here)
    if ( FAILED( hrArbitrate ) )
    {
        m_pWmiMergerRecord->GetWmiMerger()->Cancel( hrArbitrate );
    }

}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::DispatchOwn()
{

    HRESULT    hRes = S_OK;
    long    lNumOwnObjAdjust = 0L;

    // Temporary object storage
    CRefedPointerArray<IWbemClassObject> objArray;

    // Used for tracking object sizes
    long        lTotalMapAdjust = 0L;

    // Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec    ics( m_Throttler.GetCritSec() );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    // Mark the appropriate flags now this will also release throttling
    ChildrenAreDone();

    try
    {

        // Walk the map, and for all own objects, store the pointer and record the size, then
        // clear the element from the map.  None of these objects should be merged, but we want
        // them out of the map before we start batch processing them

        // We use a member variable since we may leave a critical section while iterating
        // and it is possible for AddOwnObject or Cancel to cause the iterator to be cleared
        // before we reenter the critical section - This is the only please we have code
        // like this
        m_DispatchOwnIter = m_map.begin();
        int    x = 0;
        int y = 0;

        while ( SUCCEEDED( hRes ) && m_DispatchOwnIter != m_map.end())
        {
            // If we are not derived from the target class, this more or less
            // just cleans up the array.  Otherwise, instances left in the map
            // are instances provided at this level, but not by children, so we
            // need to send them up the line with an Indicate

            if(m_DispatchOwnIter->second.m_bOwn)
            {
                IWbemClassObject*    pObjToIndicate = NULL;
                long                lMapAdjust = 0L;

                // If we are not derived from the target class, this more or less
                // just cleans up the array.  Otherwise, instances left in the map
                // are instances provided at this level, but not by children, so we
                // need to send them up the line with an Indicate

                if ( m_bDerivedFromTarget )
                {
                    // We will actually just go one object at a time.
                    if ( objArray.Add( m_DispatchOwnIter->second.m_pData ) < 0L )   // SEC:REVIEWED 2002-03-22 : Needs EH
                    {
                        hRes = WBEM_E_OUT_OF_MEMORY;
                        ERRORTRACE((LOG_WBEMCORE, "Add to array failed in AddChildObject, hresult is 0x%x",
                            hRes));
                        continue;
                    }

                    lMapAdjust -= m_DispatchOwnIter->second.m_dwObjSize;

                    // Store the actual adjustment size
                }    // IF m_bDerivedFromTarget

                // Adjust the total map size (this is in case we are not derived from
                // target and are just removing objects).
                lTotalMapAdjust -= m_DispatchOwnIter->second.m_dwObjSize;

                m_DispatchOwnIter->second.m_pData->Release();
                m_DispatchOwnIter = m_map.erase(m_DispatchOwnIter);

                // Apply the object adjustment now.
                m_Throttler.AdjustNumParentObjects( -1 );

                if ( objArray.GetSize() > 0L )
                {
                    // Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
                    // section
                    AdjustLocalObjectSize( lMapAdjust );

                    // This object is smart enough to recognize if we've already left and not do
                    // so again, if we have.
                    ics.Leave();

                    // Now go ahead and perform the indicate we've been leading ourselves up to, adjustment
                    // will be negative, but conversely, we'll be holding onto that size of objects if anything
                    // is indicated, so call as follows...oh yeah, and don't throttle explicitly
                    if ( SUCCEEDED( hRes ) )
                    {
                        hRes = IndicateArrayAndThrottle( 1,
                                                        &objArray,
                                                        NULL,
                                                        lMapAdjust,
                                                        -lMapAdjust,
                                                        false,
                                                        false,    // no throttling here
                                                        NULL
                                                        );

                        // If we are in a success state we should reenter the critical section
                        if ( SUCCEEDED( hRes ) )
                        {
                            ics.Enter();
                        }
                    }

                }    // IF NULL != pObjToIndicate

            }    // IF !m_bOwn
            else
            {
                m_DispatchOwnIter++;
            }

        }    // WHILE enuming objects


    }    // try
    catch(...)
    {
        ExceptionCounter c;    
    }

    if ( !m_bDerivedFromTarget )
    {
        // Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
        // section.
        AdjustLocalObjectSize( lTotalMapAdjust );
    }

    // Any further code MUST be executed outside of a critical
    // section
    ics.Leave();

    if ( !m_bDerivedFromTarget )
    {
        // Report to the arbitrator now.

        if ( 0L != lTotalMapAdjust )
        {
            ReportMemoryUsage( lTotalMapAdjust );
        }
    }

    // If something went wrong, we need to cancel at this point.
    if ( FAILED( hRes ) )
    {
        // If we are in a failed state, nothing is going to matter from this point on,
        // so tell the merger to cancel all underlying sinks.
        m_pWmiMergerRecord->GetWmiMerger()->Cancel( hRes );

    }

}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::GetOwnInstance(LPCWSTR wszKey, IWbemClassObject** ppMergedInstance)
{
    HRESULT    hRes = WBEM_S_NO_ERROR;

    if (NULL == wszKey)
        return WBEM_E_OUT_OF_MEMORY;

    size_t tmpLength = wcslen(wszKey) + m_wsClass.Length() + 2;   // SEC:REVIEWED 2002-03-22 : OK ; precondition that these are valid
    WCHAR * wszPath = new WCHAR[tmpLength];
    if (NULL == wszPath) return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> dm(wszPath);

    if (wcslen(wszKey))  // SEC:REVIEWED 2002-03-22 : OK; precondition that this is valid
    {
        StringCchPrintf(wszPath, tmpLength, L"%s.%s", (LPCWSTR)m_wsClass, wszKey);

        IServerSecurity * pSec = NULL;
        hRes = CoGetCallContext(IID_IServerSecurity,(void **)&pSec);
        CReleaseMe rmSec(pSec);
        if (RPC_E_CALL_COMPLETE == hRes ) hRes = S_OK; // no call context
        if (FAILED(hRes)) return hRes;
        BOOL bImper = (pSec)?pSec->IsImpersonating():FALSE;
        if (pSec && bImper && FAILED(hRes = pSec->RevertToSelf())) return hRes;
        
        COwnInstanceSink*    pOwnInstanceSink = NULL;

        hRes = m_pWmiMergerRecord->GetWmiMerger()->CreateMergingSink( eMergerOwnInstanceSink,
                    NULL, this, (CMergerSink**) &pOwnInstanceSink );

        if ( SUCCEEDED( hRes ) )
        {
            // Scoped release
            pOwnInstanceSink->AddRef();
            CReleaseMe    rm( pOwnInstanceSink );

            hRes = pOwnInstanceSink->SetInstancePath( wszKey );

            if ( SUCCEEDED( hRes ) )
            {
                // Impersonate original client
                IUnknown* pOld;                
                hRes = CoSwitchCallContext(m_pSecurity, &pOld);
                if (SUCCEEDED(hRes))
                {
                    {
                    	// Revert to self this will succeed is the first has succeeded
                        IUnknown* pThis;
                    	OnDelete2<IUnknown *,IUnknown **,HRESULT(*)(IUnknown *,IUnknown **),CoSwitchCallContext> SwitchBack(pOld, &pThis);
                        hRes = m_pNamespace->DynAux_GetSingleInstance(m_pOwnClass,                         	
                    	                                          0, wszPath,
                                                                  m_pContext, 
                                                                  pOwnInstanceSink); // throw
                	}

                    if ( SUCCEEDED( hRes ) )
                    {
                        hRes = pOwnInstanceSink->GetObject( ppMergedInstance );

                        // Means there was no object to retrieve
                        if ( WBEM_S_FALSE == hRes )
                        {
                            hRes = WBEM_S_NO_ERROR;
                        }
                    }
                    else if ( WBEM_E_NOT_FOUND == hRes )
                    {
                        // In this case, this is really not an error
                        hRes = WBEM_S_NO_ERROR;
                    }
                }
            }
        }    // If created sink

        if (bImper && pSec)
        {
            HRESULT hrInner = pSec->ImpersonateClient();
            if (FAILED(hrInner)) return hrInner;
        }
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::OwnIsDone()
{
    // Let the throttler know what's up
    m_Throttler.SetParentDone();

    m_bOwnDone = TRUE;
    m_pOwnSink = NULL;
}

//***************************************************************************
//
//***************************************************************************

void CInternalMerger::ChildrenAreDone()
{
    // Let the throttler know what's up
    m_Throttler.SetChildrenDone();

    m_bChildrenDone = TRUE;
    m_pChildSink = NULL;

    if(!m_bDerivedFromTarget)
    {
        // Don't need that ref count on pOwnSink anymore
        // =============================================

        m_pOwnSink->Release();
    }
}


//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::GetObjectLength( IWbemClassObject* pObj, long* plObjectSize )
{
    _IWmiObject*    pWmiObject = NULL;

    HRESULT            hr = pObj->QueryInterface( IID__IWmiObject, (void**) &pWmiObject );

    if ( SUCCEEDED( hr ) )
    {
        CReleaseMe        rm1( pWmiObject );
        CWbemObject*    pWbemObj = NULL;

        hr = pWmiObject->_GetCoreInfo( 0L, (void**) &pWbemObj );

        if ( SUCCEEDED( hr ) )
        {
            CReleaseMe    rm2( (IWbemClassObject*) pWbemObj );
            *plObjectSize = pWbemObj->GetBlockLength();
        }
    }

    return hr;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CInternalMerger::CMemberSink::AddRef()
{
    // We keep an internal ref count and also pass up to the
    // merger

    // On first reference we AddRef() the internal merger as well

    // Note that our internal ref count is really a bookkeeping count on
    // the sink.  The actual ref count that controls the destruction is
    // that on the merger.  When the merger hits zero the sink will be deleted
    if ( InterlockedIncrement( &m_lRefCount ) == 1 )
    {
        m_pInternalMerger->AddRef();
    }

    return m_pMerger->AddRef();
}

//***************************************************************************
//
//***************************************************************************


STDMETHODIMP CInternalMerger::CMemberSink::
SetStatus(long lFlags, long lParam, BSTR strParam, IWbemClassObject* pObjParam)
{

    if(lFlags == 0 && lParam == WBEM_E_NOT_FOUND)
        lParam = WBEM_S_NO_ERROR;

    // Propagate error to error combining sink
    // =======================================

    HRESULT    hRes =  m_pInternalMerger->m_pDest->SetStatus(lFlags, lParam, strParam,
                                                    pObjParam);

    if ( FAILED ( hRes ) || !SUCCEEDED( lParam ) )
    {
        HRESULT    hrSet = ( FAILED( hRes ) ? hRes : lParam );
        m_pInternalMerger->m_pWmiMergerRecord->GetWmiMerger()->Cancel( hrSet );
    }

    return hRes;
}

//***************************************************************************
//
//***************************************************************************

CInternalMerger::COwnSink::~COwnSink()
{
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP 
CInternalMerger::COwnSink::Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
    long    lNumIndicated = 0L;

    // Internal calls don't use this, so we know we're the lowest level
    return m_pInternalMerger->AddOwnObjects( lNumObjects, apObjects, true, &lNumIndicated );
}

//***************************************************************************
//
//***************************************************************************

HRESULT 
CInternalMerger::COwnSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray, 
                                    bool bLowestLevel, long* plNumIndicated  )
{
    // Really just a place holder here.  Just call the standard version
    return m_pInternalMerger->AddOwnObjects( lObjectCount, pObjArray, bLowestLevel, plNumIndicated  );
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::COwnSink::OnFinalRelease( void )
{
    // Final cleanup occurs here.

    m_pInternalMerger->DispatchChildren();
    m_pInternalMerger->Release();

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

CInternalMerger::CChildSink::~CChildSink()
{
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP 
CInternalMerger::CChildSink::Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
    long    lNumIndicated = 0L;

    // Internal calls don't use this, so we know we're the lowest level
    return m_pInternalMerger->AddChildObjects( lNumObjects, apObjects, 
                                               true, &lNumIndicated );
}

//***************************************************************************
//
//***************************************************************************

HRESULT 
CInternalMerger::CChildSink::Indicate(long lObjectCount, 
                                      IWbemClassObject** pObjArray, 
                                      bool bLowestLevel, long* plNumIndicated  )
{
    // Pass the lowest level parameter on
    return m_pInternalMerger->AddChildObjects( lObjectCount, pObjArray, bLowestLevel, plNumIndicated );
}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::CChildSink::OnFinalRelease( void )
{
    // Final cleanup occurs here.

    m_pInternalMerger->DispatchOwn();
    m_pInternalMerger->Release();

    return WBEM_S_NO_ERROR;

}

//***************************************************************************
//
//***************************************************************************

HRESULT CInternalMerger::CreateMergingSink( MergerSinkType eType, CInternalMerger* pMerger, CWmiMerger* pWmiMerger, CMergerSink** ppSink )
{
    if ( eType == eMergerOwnSink )
    {
        *ppSink = new COwnSink( pMerger, pWmiMerger );
    }
    else if ( eType == eMergerChildSink )
    {
        *ppSink = new CChildSink( pMerger, pWmiMerger );
    }
    else if ( eType == eMergerOwnInstanceSink )
    {
        *ppSink = new COwnInstanceSink( pMerger, pWmiMerger );
    }

    return ( NULL == *ppSink ? WBEM_E_OUT_OF_MEMORY : WBEM_S_NO_ERROR );
}

// Sets our error state, and cleans up objects we're holding onto -
// no further objects should get in.  When we cancel the throttler,
// it will release any threads it is holding onto.

void CInternalMerger::Cancel( HRESULT hRes /* = WBEM_E_CALL_CANCELLED */ )
{
    long    lArbitratorAdjust = 0L;

    // Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec    ics( m_Throttler.GetCritSec() );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    // Only cancel if we're not already cancelled
    if ( WBEM_S_NO_ERROR == m_hErrorRes )
    {
        m_hErrorRes = hRes;

        // Dump the map
        MRGRKEYTOINSTMAPITER it = m_map.begin();

        while ( it != m_map.end())
        {
            // Subtract since we are removing from the map
            lArbitratorAdjust -= it->second.m_dwObjSize;

            // Inform the arbitrator of the removed object size
            it->second.m_pData->Release();
            it = m_map.erase(it);
        }    // WHILE dumping map

        // Adjust total object size now.  Actual Arbitrator adjustment should occur outside a critical
        // section
        AdjustLocalObjectSize( lArbitratorAdjust );

        // This will prevent DispatchOwn() from continuing with a now bogus
        // iteration
        m_DispatchOwnIter = m_map.end();

        m_Throttler.Cancel();

        ics.Leave();

        // Always report adjustments
        HRESULT hrArbitrate = ReportMemoryUsage( lArbitratorAdjust );

        // No sense reporting errors here, since we've just told the arbitrator to cancel anyway

    }    // IF not already cancelled

}

HRESULT    CInternalMerger::ReportMemoryUsage( long lMemUsage )
{
    // Always report adjustments
    HRESULT hRes = m_pWmiMergerRecord->GetWmiMerger()->ReportMemoryUsage( lMemUsage );

    // An indication we *should* throttle is not considered an error for purposes
    // of this function.
    if ( WBEM_E_ARB_THROTTLE == hRes || WBEM_S_ARB_NOTHROTTLING == hRes )
    {
        hRes = WBEM_S_NO_ERROR;
    }

    return hRes;
}

//***************************************************************************
//
//  CMergerSink::QueryInterface
//
//  Exports IWbemOnjectSink interface.
//
//***************************************************************************

STDMETHODIMP CMergerSink::QueryInterface(
    IN REFIID riid,
    OUT LPVOID *ppvObj
    )
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemObjectSink==riid)
    {
        *ppvObj = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CMergerSink::AddRef()
{
    // We keep an internal ref count and also pass up to the
    // merger
    InterlockedIncrement( &m_lRefCount );

    return m_pMerger->AddRef();
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CMergerSink::Release()
{
    // We keep an internal ref count and also pass up to the
    // merger
    long    lRef = InterlockedDecrement( &m_lRefCount );

    // Ref Count should never go below 0L
    _DBG_ASSERT( lRef >= 0 );

    // If we are at the final release for the sink, we will perform cleanup.
    // otherwise, the sink is more or less dead and just waiting for the WMI
    // Merger object to be destructed so we get cleaned up.
    if ( lRef == 0 )
    {
        OnFinalRelease();
    }

    return m_pMerger->Release();
}

CMergerTargetSink::CMergerTargetSink( CWmiMerger* pMerger, IWbemObjectSink* pDest )
:    CMergerSink( pMerger ),
    m_pDest( pDest )
{
    if ( NULL != m_pDest )
    {
        m_pDest->AddRef();
    }
}

CMergerTargetSink::~CMergerTargetSink()
{
    if ( NULL != m_pDest )
    {
        m_pDest->Release();
    }
}

HRESULT STDMETHODCALLTYPE CMergerTargetSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray)
{
    // Since we don't want the fact we're sleeping in the arbitrator to
    // cause the merger to cancel operations, we'll increase the count
    // of threads throttling, and decrement when we return.

    // We do this here because the call to Indicate goes outside the scope
    // of the merger, and this call may end up throttling.

    m_pMerger->IncrementArbitratorThrottling();

    HRESULT    hr = m_pDest->Indicate( lObjectCount, pObjArray );

    m_pMerger->DecrementArbitratorThrottling();

    return hr;
}

HRESULT STDMETHODCALLTYPE CMergerTargetSink::SetStatus( long lFlags, long lParam, BSTR strParam,
                                                        IWbemClassObject* pObjParam )
{
    return m_pDest->SetStatus( lFlags, lParam, strParam, pObjParam );
}

HRESULT CMergerTargetSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated )
{
    // Well, we're indicating this number of objects, aren't we?
    if ( NULL != plNumIndicated )
    {
        *plNumIndicated = lObjectCount;
    }

    // Really just a place holder here.  Just call the standard version
    return Indicate( lObjectCount, pObjArray );
}

HRESULT CMergerTargetSink::OnFinalRelease( void )
{
    // This is where we will send the actual status *and* tell the merger we're done
    return m_pMerger->Shutdown();
}

long    g_lNumMergerSinks = 0L;

CMergerSink::CMergerSink( CWmiMerger* pMerger )
: m_pMerger( pMerger ), m_lRefCount( 0L )
{
    InterlockedIncrement( &g_lNumMergerSinks );
}

CMergerSink::~CMergerSink( void )
{
    InterlockedDecrement( &g_lNumMergerSinks );
}

// OwnInstance Sink
CInternalMerger::COwnInstanceSink::~COwnInstanceSink()
{
    if ( NULL != m_pMergedInstance )
    {
        m_pMergedInstance->Release();
    }
}

// Called in response to a request for GetObject().  In this case, there should be only
// one object indicated.  Additionally, it should match the requested path.
HRESULT STDMETHODCALLTYPE CInternalMerger::COwnInstanceSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray )
{
    HRESULT    hRes = WBEM_S_NO_ERROR;

    if ( lObjectCount > 0L )
    {
        CCheckedInCritSec    ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

        // Only do this if we don't have a merged instance
        if ( NULL == m_pMergedInstance )
        {
            if ( !m_bTriedRetrieve )
            {
                // This call doesn't throttle, so don't worry about crit secs here
                for ( long x = 0; SUCCEEDED( hRes ) && x < lObjectCount; x++ )
                {
                    hRes = m_pInternalMerger->AddOwnInstance( pObjArray[x], m_wsInstPath, &m_pMergedInstance );
                }

                // Record the final status if we need to
                if ( FAILED( hRes ) )
                {
                    SetFinalStatus( hRes );
                }

            }
            else
            {
                // The following call can and will throttle, so do it
                // outside of our critical section
                ics.Leave();

                // Clearly a lowest level indicate
                hRes = m_pInternalMerger->AddOwnObjects( lObjectCount, pObjArray, true, NULL );

                // We beefed - reflect this in the final status
                if ( FAILED( hRes ) )
                {
                    ics.Enter();
                    SetFinalStatus( hRes );
                }
            }
        }
        else
        {
            hRes = WBEM_E_INVALID_OPERATION;
        }
    }

    return hRes;
}

HRESULT STDMETHODCALLTYPE CInternalMerger::COwnInstanceSink::SetStatus( long lFlags, long lParam, BSTR strParam,
                                                        IWbemClassObject* pObjParam )
{
    HRESULT    hr = WBEM_S_NO_ERROR;

    // If we got a complete, remove the instance if it was never merged
    if ( lFlags == WBEM_STATUS_COMPLETE )
    {
        CCheckedInCritSec    ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

        if ( SUCCEEDED( lParam ) )
        {
            if ( NULL == m_pMergedInstance )
            {
                hr = m_pInternalMerger->RemoveInstance( m_wsInstPath );

                // If we tanked here, we are so busted.
                if ( FAILED( hr ) )
                {
                    lParam = hr;
                }

            }    // IF NULL == m_pMergedInstance

        }
        else
        {
            // Remove the Instance now as well
            hr = m_pInternalMerger->RemoveInstance( m_wsInstPath );

            // If we tanked here, we are so busted.
            if ( FAILED( hr ) )
            {
                lParam = hr;
            }

            // We should record the final status if it is not WBEM_E_NOT_FOUND
            if ( WBEM_E_NOT_FOUND != lParam )
            {
                SetFinalStatus( lParam );
            }

            // If we got a failure status, axe the instance now
            if ( NULL != m_pMergedInstance )
            {
                m_pMergedInstance->Release();
                m_pMergedInstance = NULL;
            }
        }

        ics.Leave();

        // Always pass down to the base class
        hr = CMemberSink::SetStatus( lFlags, lParam, strParam, pObjParam );

    }
    else
    {
        // Always pass down to the base class
        hr = CMemberSink::SetStatus( lFlags, lParam, strParam, pObjParam );
    }

    return hr;
}

HRESULT CInternalMerger::COwnInstanceSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  )
{
    // This should Never be called
    _DBG_ASSERT( 0 );
    return WBEM_E_INVALID_OPERATION;
}

HRESULT CInternalMerger::COwnInstanceSink::SetInstancePath( LPCWSTR pwszPath )
{
    HRESULT    hRes = WBEM_S_NO_ERROR;

    try
    {
        m_wsInstPath = pwszPath;
    }
    catch( CX_MemoryException )
    {
        hRes = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        ExceptionCounter c;    
        hRes = WBEM_E_FAILED;
    }

    return hRes;
}

HRESULT CInternalMerger::COwnInstanceSink::GetObject( IWbemClassObject** ppMergedInst )
{
    HRESULT    hRes = WBEM_S_NO_ERROR;

    CInCritSec    ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

    // If final status on this sink shows a failure, then we should return that failure
    // mostly cause we're doomed anyway at this point
    if ( SUCCEEDED( m_hFinalStatus ) )
    {
        if ( NULL != m_pMergedInstance )
        {
            m_pMergedInstance->AddRef();
            *ppMergedInst = m_pMergedInstance;
        }
        else
        {
            hRes = WBEM_S_FALSE;
        }

    }
    else
    {
        hRes = m_hFinalStatus;
    }

    // We tried to retrieve it once - so if further indicates come in,
    // they will be passed off to AddOwnObjects
    m_bTriedRetrieve = true;

    return hRes;
}

HRESULT CInternalMerger::COwnInstanceSink::OnFinalRelease( void )
{
    // Wer should clean this up
    m_pInternalMerger->Release();

    return WBEM_S_NO_ERROR;
}

// Only reports negative memory usage if the original number was positive
CInternalMerger::CScopedMemoryUsage::~CScopedMemoryUsage( void )
{
    Cleanup();
}

// Reports memory usage and accounts for errors as deemed appropriate
HRESULT CInternalMerger::CScopedMemoryUsage::ReportMemoryUsage( long lMemUsage )
{
    _DBG_ASSERT( m_lMemUsage >= 0L );

    HRESULT    hr = m_pInternalMerger->ReportMemoryUsage( lMemUsage );

    // If we get a suceess code or WBEM_E_ARB_CANCEL, we need to cleanup
    // the memory usage when we go out of scope.

    if ( ( SUCCEEDED( hr ) || hr == WBEM_E_ARB_CANCEL ) )
    {
        m_lMemUsage += lMemUsage;
        m_bCleanup = true;
    }

    return hr;
}

// Cleans up any memory usage as we deemed appropriate
HRESULT CInternalMerger::CScopedMemoryUsage::Cleanup( void )
{
    _DBG_ASSERT( m_lMemUsage >= 0L );

    HRESULT    hr = WBEM_S_NO_ERROR;

    // Cleanup as appropriate
    if ( m_bCleanup && m_lMemUsage > 0L )
    {
        hr = m_pInternalMerger->ReportMemoryUsage( -m_lMemUsage );
    }

    m_bCleanup = false;
    m_lMemUsage = 0L;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\import.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    IMPORT.H

Abstract:

History:

--*/
#ifdef _MMF
#ifndef __wmi_import_h__
#define __wmi_import_h__

class CObjectDatabase;

/*================================================================================
 *
 * EXPORT FILE FORMAT
 * ==================
 *
 * File Header Block:
 *		wchar_t wszFileHeader								= "repexp1"
 *
 * Namespace Block:
 *		DWORD   dwObjectType								= 0x00000001
 *		DWORD   dwNamespaceNameSize
 *		wchar_t wszNamespaceName[dwNamespaceNameSize]		= Full namespace name
 *															  (\root\default\fred)
 *
 * Class Block:
 *		DWORD   dwObjectType								= 0x00000002
 *		DWORD   dwClassNameSize
 *		wchar_t wszClassName[dwClassNameSize]				= Class name (my_class_name)
 *		DWORD   dwClassObjectSize
 *		DWORD	adwClassObject[dwClassObjectSize]
 *
 * Instance Block - key of type int:
 *		DWORD   dwObjectType								= 0x00000003
 *		DWORD   dwInstanceKey
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *
 * Instance Block - key of type string
 *		DWORD	dwObjectType								= 0x00000004
 *		DWORD	dwInstanceKeySize
 *		DWORD	dwInstanceKey[dwInstanceKeySize]			= Instance key (MyKeyValue)
 *		DWORD	dwInstanceObjectSize
 *		DWORD	adwInstanceObject[dwInstanceObjectSize]
 *		
 * End of class block
 *		DWORD	dwObjectType								= 0x00000005
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * End of namespace block
 *		DWORD	dwObjectType								= 0x00000006
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * End of file block
 *		DWORD	dwObjectType								= 0xFFFFFFFF
 *		DWORD	dwEndOfBlockSize							= 0x00000010
 *		DWORD	adwEndOfBlock[dwEndOfBlockSize]				= 0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF,
 *															  0xFFFFFFFF
 *
 * Ordering:
 *		File Header Block
 *			(one or more)
 *			Namespace Block
 *				(zero or more)
 *				{
 *					Namespace Block
 *						etc...
 *					End namespace block
 *					(or)
 *					Class Block
 *						(zero or more)
 *						{
 *							Instance Block
 *							(or)
 *							Class Block
 *								etc...
 *							End class block
 *						}
 *					End class block
 *				}
 *			End namespace block
 *		End of file block
 *
 *================================================================================
 */

class CRepImporter
{
private:
	HANDLE m_hFile ;
	CObjectDatabase *m_pDb ;
	bool m_bSecurityMode;
    bool m_bSecurityClassesWritten;

	void DecodeTrailer();
	void DecodeInstanceInt(CObjDbNS *pNs, const wchar_t *pszParentClass, CWbemObject *pClass, CWbemClass *pNewParentClass);
	void DecodeInstanceString(CObjDbNS *pNs, const wchar_t *pszParentClass, CWbemObject *pClass, CWbemClass *pNewParentClass);
	void DecodeClass(CObjDbNS *pNs, const wchar_t *wszParentClass, CWbemObject *pParentClass, CWbemClass *pNewParentClass);
	void DecodeNamespace(const wchar_t *wszParentNamespace);
	void Decode();

public:
	enum { FAILURE_READ = 1,
		   FAILURE_INVALID_FILE = 2,
		   FAILURE_INVALID_TYPE = 3,
		   FAILURE_INVALID_TRAILER = 4,
		   FAILURE_CANNOT_FIND_NAMESPACE = 5,
		   FAILURE_CANNOT_GET_PARENT_CLASS = 6,
		   FAILURE_CANNOT_CREATE_INSTANCE  = 7,
		   FAILURE_CANNOT_ADD_NAMESPACE = 8,
		   FAILURE_CANNOT_ADD_NAMESPACE_SECURITY = 9,
		   FAILURE_OUT_OF_MEMORY = 10
	};
	CRepImporter() : m_hFile(INVALID_HANDLE_VALUE), m_pDb(NULL), m_bSecurityMode(false),
                        m_bSecurityClassesWritten(false){}

	int RestoreRepository(const TCHAR *pszFromFile, CObjectDatabase *pDb);
	int ImportRepository(const TCHAR *pszFromFile);
    ~CRepImporter();
};

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\intprov.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    INTPROV.CPP

Abstract:

    Defines the CIntProv class.  An object of this class is
           created by the class factory for each connection.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <wbemcore.h>
#include <intprov.h>
#include <objpath.h>
#include <reg.h>
#include <genutils.h>
#include <safearry.h>

//***************************************************************************
//
// Return:  NULL if failure, otherwise the caller must call SysFreeString.
//
//***************************************************************************

BSTR GetBSTR(WCHAR* pInput)
{     
    return SysAllocString(pInput);
}

//***************************************************************************
//
// HRESULT GetDateTime(FILETIME * pft, bool bLocalTime, LPWSTR Buff)
//
// Converts a FILETIME date to CIM_DATA representation.
//
// Parameters:
//  pft         FILETIME to be converted.
//  bLocalTime  If true, then the conversion is to local,
//                  ex 19990219112222:000000+480.  Otherwise it returns gmt
//  Buff        WCHAR buffer to be passed by the caller.  Should be 30 long
//
//***************************************************************************

HRESULT GetDateTime(FILETIME * pft, bool bLocalTime, LPWSTR Buff, size_t cchBuffer)
{
    if(pft == NULL || Buff == NULL)
        return WBEM_E_INVALID_PARAMETER;

    SYSTEMTIME st;
    int Bias=0;
    char cOffsetSign = '+';

    if(bLocalTime)
    {
        FILETIME lft;       // local file time
        TIME_ZONE_INFORMATION ZoneInformation;

        // note that win32 and the DMTF interpret bias differently.
        // For example, win32 would give redmond a bias of 480 while
        // dmtf would have -480

        DWORD dwRet = GetTimeZoneInformation(&ZoneInformation);
        if(dwRet != TIME_ZONE_ID_UNKNOWN)
            Bias = -ZoneInformation.Bias;

        if(Bias < 0)
        {
            cOffsetSign = '-';
            Bias = -Bias;
        }

        FileTimeToLocalFileTime(
            pft,   // pointer to UTC file time to convert
            &lft);                 // pointer to converted file time);
        if(!FileTimeToSystemTime(&lft, &st))
            return WBEM_E_FAILED;
    }
    if(!FileTimeToSystemTime(pft, &st))
        return WBEM_E_FAILED;

    StringCchPrintfW(Buff, cchBuffer,  L"%4d%02d%02d%02d%02d%02d.%06d%c%03d",
                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute,
                st.wSecond, st.wMilliseconds*1000, cOffsetSign, Bias);
    return S_OK;
}

//***************************************************************************
//
// CIntProv::CIntProv
// CIntProv::~CIntProv
//
//***************************************************************************

CIntProv::CIntProv()
{
    m_pNamespace = NULL;
    m_cRef=0;
    gClientCounter.AddClientPtr(&m_Entry);
}

CIntProv::~CIntProv(void)
{
    if(m_pNamespace)
        m_pNamespace->Release();
    gClientCounter.RemoveClientPtr(&m_Entry);
}

//***************************************************************************
//
// CIntProv::QueryInterface
// CIntProv::AddRef
// CIntProv::Release
//
// Purpose: IUnknown members for CIntProv object.
//***************************************************************************


STDMETHODIMP CIntProv::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;


    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;

}

STDMETHODIMP_(ULONG) CIntProv::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) CIntProv::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CIntProv::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CIntProv::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace,
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    if(pNamespace)
        pNamespace->AddRef();
    m_pNamespace = pNamespace;

    //Let CIMOM know you are initialized
    //==================================

    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CIntProv::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.
//
//***************************************************************************

SCODE CIntProv::CreateInstanceEnumAsync( const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    SCODE sc = WBEM_E_FAILED;
    IWbemClassObject FAR* pObj = NULL;
    if(RefStr == NULL || pHandler == NULL)
        return WBEM_E_INVALID_PARAMETER;

    ParsedObjectPath * pOutput = 0;
    CObjectPathParser p;
    int nStatus = p.Parse(RefStr, &pOutput);
    if(nStatus != 0)
        return WBEM_E_INVALID_PARAMETER;

    if(IsNT() && IsDcomEnabled())
	{
		sc = WbemCoImpersonateClient ( ) ;  // SEC:REVIEWED 2002-03-22 : OK
		if ( FAILED ( sc ) )
		{
			return sc ;
		}
	}

    // if the path and class are for the setting object, go get it.

    if(pOutput->IsClass() && !wbem_wcsicmp(pOutput->m_pClass, L"Win32_WMISetting"))
    {
        sc = CreateWMISetting(&pObj, pCtx);
    }
    else if(pOutput->IsClass() && !wbem_wcsicmp(pOutput->m_pClass, L"Win32_WMIElementSetting"))
    {
        sc = CreateWMIElementSetting(&pObj, pCtx);
    }
    else
        sc = WBEM_E_INVALID_PARAMETER;

    p.Free(pOutput);

    if(pObj)
    {
        pHandler->Indicate(1,&pObj);
        pObj->Release();
    }

    // Set status

    pHandler->SetStatus(0,sc,NULL, NULL);
    return S_OK;
}


//***************************************************************************
//
// CIntProv::GetObjectAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************



SCODE CIntProv::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{

    SCODE sc = WBEM_E_FAILED;
    IWbemClassObject FAR* pObj = NULL;
    BOOL bOK = FALSE;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // do the get, pass the object on to the notify

    ParsedObjectPath * pOutput = 0;
    CObjectPathParser p;
    int nStatus = p.Parse(ObjectPath, &pOutput);
    if(nStatus != 0)
        return WBEM_E_INVALID_PARAMETER;

    if(IsNT() && IsDcomEnabled())
    {
		sc = WbemCoImpersonateClient ( ) ;  // SEC:REVIEWED 2002-03-22 : OK
		if ( FAILED ( sc ) )
		{
			return sc ;
		}
	}

    // if the path and class are for the setting object, go get it.

    if(pOutput->m_bSingletonObj && !wbem_wcsicmp(pOutput->m_pClass, L"Win32_WMISetting"))
    {
        sc = CreateWMISetting(&pObj, pCtx);
    }
    if(!pOutput->m_bSingletonObj && !wbem_wcsicmp(pOutput->m_pClass, L"Win32_WMIElementSetting")
        && pOutput->m_dwNumKeys == 2)
    {
        WCHAR * pKey = pOutput->GetKeyString();
        if(pKey)
        {
            WCHAR * pTest = L"Win32_Service=\"winmgmt\"\xffffWin32_WMISetting=@";
            if(!wbem_wcsicmp(pKey, pTest))
                sc = CreateWMIElementSetting(&pObj, pCtx);
            delete [] pKey;
        }
    }

    if(pObj)
    {
        pHandler->Indicate(1,&pObj);
        pObj->Release();
        bOK = TRUE;
    }

    sc = (bOK) ? S_OK : WBEM_E_NOT_FOUND;

    // Set Status

    pHandler->SetStatus(0,sc, NULL, NULL);
    p.Free(pOutput);
    return sc;
}

//***************************************************************************
//
// CIntProv::PutInstanceAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************

SCODE CIntProv::PutInstanceAsync(IWbemClassObject __RPC_FAR *pInst, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{

    SCODE sc = WBEM_E_FAILED;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(pInst == NULL || pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Get the rel path and parse it;

    VARIANT var;
    VariantInit(&var);
    sc = pInst->Get(L"__relPath", 0, &var, NULL, NULL);
    if(sc != S_OK)
        return WBEM_E_INVALID_PARAMETER;

    // do the get, pass the object on to the notify

    ParsedObjectPath * pOutput = 0;
    CObjectPathParser p;

    int nStatus = p.Parse(var.bstrVal, &pOutput);
    VariantClear(&var);
    if(nStatus != 0)
        return WBEM_E_FAILED;

    if(IsNT() && IsDcomEnabled())
    {
		sc = WbemCoImpersonateClient ( ) ;  // SEC:REVIEWED 2002-03-22 : OK
		if ( FAILED ( sc ) )
		{
			return sc ;
		}
	}

    // if the path and class are for the setting object, go get it.

    if(pOutput->m_bSingletonObj && !wbem_wcsicmp(pOutput->m_pClass, L"Win32_WMISetting"))
    {
        sc = SaveWMISetting(pInst);
    }

    p.Free(pOutput);

    // Set Status

    pHandler->SetStatus(0,sc, NULL, NULL);

    return S_OK;
}




//***************************************************************************
//
// CIntProv::CreateInstance
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE CIntProv::CreateInstance(LPWSTR pwcClassName, IWbemClassObject FAR* FAR* ppObj,
                               IWbemContext  *pCtx)
{
    SCODE sc;
    IWbemClassObject * pClass = NULL;
    sc = m_pNamespace->GetObject(pwcClassName, 0, pCtx, &pClass, NULL);
    if(sc != S_OK)
        return WBEM_E_FAILED;
    sc = pClass->SpawnInstance(0, ppObj);
    pClass->Release();
    return sc;
}

//***************************************************************************
//
// CIntProv::GetRegStrProp
//
// Retrieves a string property from the registry and puts it into the object.
//
//***************************************************************************

SCODE CIntProv::GetRegStrProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName,
                                                            CWbemObject * pObj)
{

    SCODE sc;

    TCHAR *pszData = NULL;
    if (reg.GetStr(pRegValueName, &pszData))
        return WBEM_E_FAILED;
    CDeleteMe<TCHAR> del1(pszData);

    BSTR bstr = GetBSTR(pszData);

    if(bstr == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CVar var;
    var.SetBSTR(auto_bstr(bstr));    // this acquires and frees the bstr

    sc = pObj->SetPropValue(pwsPropName, &var, CIM_STRING);

    return sc;
}

//***************************************************************************
//
// CIntProv::GetRegUINTProp
//
// Retrieves a DWORD property from the registry and puts it into the object.
//
//***************************************************************************

SCODE CIntProv::GetRegUINTProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName,
                                                            CWbemObject * pObj)
{
    DWORD dwVal;
    if (reg.GetDWORDStr(pRegValueName, &dwVal))
        return WBEM_E_FAILED;

    VARIANT var;
    var.vt = VT_I4;
    var.lVal = dwVal;
    return pObj->Put(pwsPropName, 0, &var, 0);
}

//***************************************************************************
//
// CIntProv::PutRegStrProp
//
// Retrieves a string from the object and writes it to the registry.
//
//***************************************************************************

SCODE CIntProv::PutRegStrProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName,
                                                            CWbemObject * pObj)
{

    VARIANT var;
    VariantInit(&var);
    CClearMe me(&var);
    SCODE sc = pObj->Get(pwsPropName, 0, &var, 0, NULL);
    if(sc != S_OK || var.vt != VT_BSTR)
        return sc;

    if(var.bstrVal == NULL || wcslen(var.bstrVal) < 1)   // SEC:REVIEWED 2002-03-22 : OK, all known paths have provable NULL terminators
    {
        if (reg.SetStr(pRegValueName, __TEXT("")))
            return WBEM_E_FAILED;
        return S_OK;
    }
#ifdef UNICODE
    TCHAR *tVal = var.bstrVal;
#else
	int iLen = 2 * wcslen(var.bstrVal) + 1;  // SEC:REVIEWED 2002-03-22 : Needs EH, but since we don't use ANSI, there is no path to this
    TCHAR *tVal = new TCHAR[iLen];
    wcstombs(tVal, var.bstrVal, iLen);  // SEC:REVIEWED 2002-03-22 : Needs EH, but since we don't use ANSI, there is no path to this
    CDeleteMe<TCHAR> delMe(tVal);
#endif

    if (reg.SetStr(pRegValueName, tVal))
        return WBEM_E_FAILED;
    return S_OK;

}

//***************************************************************************
//
// CIntProv::PutRegUINTProp
//
// Retrieves a DWORD from the object and writes it to the registry.
//
//***************************************************************************

SCODE CIntProv::PutRegUINTProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName,
                                                            CWbemObject * pObj)
{
    CVar var;
    SCODE sc = pObj->Get(pwsPropName, 0, (struct tagVARIANT *)&var, 0, NULL);
    if(sc != S_OK || var.GetType() != VT_I4)
        return sc;
    if (reg.SetDWORDStr(pRegValueName, var.GetDWORD()))
        return WBEM_E_FAILED;
    return S_OK;
}

//***************************************************************************
//
// CIntProv::ReadAutoMofs
//
// Reads the autocompile list from the registry
//
//***************************************************************************

SCODE CIntProv::ReadAutoMofs(CWbemObject * pObj)
{
    Registry r(WBEM_REG_WINMGMT);
    DWORD dwSize;
    TCHAR * pMulti = r.GetMultiStr(__TEXT("Autorecover MOFs"), dwSize);
    if(pMulti == NULL)
        return S_OK;        // Not a problem

    CDeleteMe<TCHAR> del1(pMulti);

    CSafeArray csa(VT_BSTR, CSafeArray::auto_delete);  // SEC:REVIEWED 2002-03-22 : Needs EH

    TCHAR * pNext;
    int i;
    for(pNext = pMulti, i=0; *pNext; pNext += lstrlen(pNext) + 1, i++)  // SEC:REVIEWED 2002-03-22 : OK, string from registry will have a NULL
    {
        BSTR bstr = GetBSTR(pNext);
        if(bstr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        csa.SetBSTRAt(i, bstr);     // A copy of the BSTR is made
        SysFreeString(bstr);
    }
    csa.Trim();

    // put the data

    VARIANT var;
    var.vt = VT_BSTR | VT_ARRAY;
    var.parray = csa.GetArray();
    return pObj->Put( L"AutorecoverMofs", 0, &var, 0);

}

//***************************************************************************
//
// CIntProv::ReadLastBackup
//
// Gets the time of the last auto backup.
//
//***************************************************************************

SCODE CIntProv::ReadLastBackup(Registry & reg, CWbemObject * pObj)
{

    // Create the path to the auto backup file.

    LPTSTR pszData = NULL;
    if (reg.GetStr(__TEXT("Repository Directory"), &pszData))
        return WBEM_E_FAILED;
    CDeleteMe<TCHAR> del1(pszData);
    size_t tmpLength = lstrlen(pszData)+10;   // SEC:REVIEWED 2002-03-22 : OK, string will have a NULL
    TCHAR * pFullPath =  new TCHAR[tmpLength];
    if(pFullPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<TCHAR> del2(pFullPath);

    StringCchCopy(pFullPath,tmpLength, pszData);
    StringCchCat(pFullPath, tmpLength, __TEXT("\\cim.rec"));


    BY_HANDLE_FILE_INFORMATION bh;

    HANDLE hFile = CreateFile(pFullPath,      // SEC:REVIEWED 2002-03-22 : OK, full path is used
                        0,       // access (read-write) mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,           // share mode
                        NULL,
                        OPEN_EXISTING,0, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        return S_OK;
    CCloseHandle cm(hFile);
    if(!GetFileInformationByHandle(hFile, &bh))
        return S_OK;    // probably not a problem since the file may not exist
    WCHAR Date[35];
    SCODE sc = GetDateTime(&bh.ftLastWriteTime, false, Date, 35);
    if(sc != S_OK)
        return sc;

    CVar var;
    var.SetBSTR(Date);

    sc = pObj->SetPropValue(L"BackupLastTime", &var, CIM_DATETIME);
    return sc;
}
//***************************************************************************
//
// CIntProv::CreateWMIElementSetting
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE CIntProv::CreateWMIElementSetting(IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx)
{
    SCODE sc;
    sc = CreateInstance(L"Win32_WMIElementSetting", ppObj, pCtx);
    if(sc != S_OK)
        return sc;

    CVar var;
    var.SetBSTR(L"Win32_WMISetting=@");
    CWbemObject * pWbemObj = (CWbemObject *)*ppObj;

    sc |= pWbemObj->Put(L"Setting",0, (VARIANT *)&var,  0);
    CVar var2;
    var2.SetBSTR(L"Win32_Service=\"winmgmt\"");
    sc |= pWbemObj->Put(L"Element",0,  (VARIANT *)&var2, 0);

    return sc;
}

//***************************************************************************
//
// CIntProv::CreateWMISetting
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE CIntProv::CreateWMISetting(IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx)
{
    SCODE sc, scTemp;
    sc = CreateInstance(L"Win32_WMISetting", ppObj, pCtx);
    if(sc != S_OK)
        return sc;

    // Fill in the properties

    Registry rWbem(HKEY_LOCAL_MACHINE, 0, KEY_READ, WBEM_REG_WBEM);          // Top level wbem key
    Registry rCIMOM(HKEY_LOCAL_MACHINE, 0, KEY_READ, WBEM_REG_WINMGMT);      // The cimom key
    Registry rScripting(HKEY_LOCAL_MACHINE, 0, KEY_READ, __TEXT("Software\\Microsoft\\WBEM\\scripting"));

    CWbemObject * pWbemObj = (CWbemObject *)*ppObj;

    scTemp = GetRegStrProp(rCIMOM, __TEXT("Working Directory"), L"InstallationDirectory", pWbemObj);
    scTemp = GetRegStrProp(rWbem, __TEXT("Build"), L"BuildVersion", pWbemObj);

    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Log File Max Size"), L"MaxLogFileSize", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Logging"), L"LoggingLevel", pWbemObj);
    scTemp = GetRegStrProp(rCIMOM, __TEXT("Logging Directory"), L"LoggingDirectory", pWbemObj);
    scTemp = GetRegStrProp(rCIMOM, __TEXT("Repository Directory"), L"DatabaseDirectory", pWbemObj);
     scTemp = GetRegUINTProp(rCIMOM, __TEXT("Max DB Size"), L"DatabaseMaxSize", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Backup interval threshold"), L"BackupInterval", pWbemObj);

    scTemp = ReadAutoMofs(pWbemObj);
    scTemp = ReadLastBackup(rCIMOM, pWbemObj);

    DWORD dwScriptingEnabled;
    if(0 == rScripting.GetDWORD(__TEXT("Enable for ASP"), &dwScriptingEnabled))
    {
        CVar var;
        var.SetBool((dwScriptingEnabled == 0) ? VARIANT_FALSE : VARIANT_TRUE);
        scTemp = pWbemObj->SetPropValue(L"ASPScriptEnabled", &var, CIM_BOOLEAN);
    }
    scTemp = GetRegStrProp(rScripting, __TEXT("Default Namespace"), L"ASPScriptDefaultNamespace", pWbemObj);

    scTemp = GetRegUINTProp(rCIMOM, __TEXT("EnableEvents"), L"EnableEvents", pWbemObj);

    scTemp = GetRegUINTProp(rCIMOM, __TEXT("High Threshold On Client Objects (b)"), L"HighThresholdOnClientObjects", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Low Threshold On Client Objects (b)"), L"LowThresholdOnClientObjects", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Max Wait On Client Objects (ms)"), L"MaxWaitOnClientObjects", pWbemObj);

    scTemp = GetRegUINTProp(rCIMOM, __TEXT("High Threshold On Events (b)"), L"HighThresholdOnEvents", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Low Threshold On Events (b)"), L"LowThresholdOnEvents", pWbemObj);
    scTemp = GetRegUINTProp(rCIMOM, __TEXT("Max Wait On Events (ms)"), L"MaxWaitOnEvents", pWbemObj);

    // not considered to be an error if the next one isnt there

    GetRegUINTProp(rCIMOM, __TEXT("LastStartupHeapPreallocation"), L"LastStartupHeapPreallocation", pWbemObj);

    DWORD dwEnablePreallocate = 0;
    rCIMOM.GetDWORD(__TEXT("EnableStartupHeapPreallocation"), &dwEnablePreallocate);
    CVar var;
    var.SetBool((dwEnablePreallocate == 1) ?  VARIANT_TRUE : VARIANT_FALSE);
    scTemp = pWbemObj->SetPropValue(L"EnableStartupHeapPreallocation", &var, CIM_BOOLEAN);


    return sc;
}

//***************************************************************************
//
// CIntProv::SaveWMISetting
//
// Purpose: Outputs the last values back to the registry.
//
//***************************************************************************

SCODE CIntProv::SaveWMISetting(IWbemClassObject FAR* pInst)
{
    SCODE sc = S_OK;
    Registry rCIMOM(WBEM_REG_WINMGMT);      // The cimom key
    Registry rScripting(__TEXT("Software\\Microsoft\\WBEM\\scripting"));
    CWbemObject * pWbemObj = (CWbemObject *)pInst;

    // verify that the backup interval is valid

    CVar var;
    sc = pInst->Get(L"BackupInterval", 0, (struct tagVARIANT *)&var, 0, NULL);
    if(sc != S_OK)
        return sc;
    if((var.GetDWORD() < 5 || var.GetDWORD() > 60*24) && var.GetDWORD() != 0)
        return WBEM_E_INVALID_PARAMETER;

    // Write the "writeable properties back into the registry
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Backup interval threshold"), L"BackupInterval", pWbemObj);

    if(!IsNT())
    {
        sc |= PutRegUINTProp(rCIMOM, __TEXT("AutostartWin9X"), L"AutoStartWin9X", pWbemObj);
        sc = pWbemObj->Get(L"EnableAnonWin9XConnections", 0, (struct tagVARIANT *)&var, 0, NULL);
        if(sc == S_OK)
        {
            rCIMOM.SetDWORDStr(__TEXT("EnableAnonConnections"), var.GetBool() ? 1 : 0);
        }
    }

    sc |= PutRegUINTProp(rCIMOM, __TEXT("Log File Max Size"), L"MaxLogFileSize", pWbemObj);
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Logging"), L"LoggingLevel", pWbemObj);
    sc |= PutRegStrProp(rCIMOM, __TEXT("Logging Directory"), L"LoggingDirectory", pWbemObj);

    sc |= pWbemObj->Get(L"ASPScriptEnabled", 0, (struct tagVARIANT *)&var, 0, NULL);
    if(sc == S_OK)
    {
        rScripting.SetDWORD(__TEXT("Enable for ASP"), var.GetBool() ? 1 : 0);
    }
    sc |= PutRegStrProp(rScripting, __TEXT("Default Namespace"), L"ASPScriptDefaultNamespace", pWbemObj);

    sc |= pWbemObj->Get(L"EnableEvents", 0, (struct tagVARIANT *)&var, 0, NULL);
    if(sc == S_OK)
    {
        rCIMOM.SetDWORDStr(__TEXT("EnableEvents"), var.GetBool() ? 1 : 0);
    }

    sc |= PutRegUINTProp(rCIMOM, __TEXT("High Threshold On Client Objects (b)"), L"HighThresholdOnClientObjects", pWbemObj);
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Low Threshold On Client Objects (b)"), L"LowThresholdOnClientObjects", pWbemObj);
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Max Wait On Client Objects (ms)"), L"MaxWaitOnClientObjects", pWbemObj);

    sc |= PutRegUINTProp(rCIMOM, __TEXT("High Threshold On Events (b)"), L"HighThresholdOnEvents", pWbemObj);
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Low Threshold On Events (b)"), L"LowThresholdOnEvents", pWbemObj);
    sc |= PutRegUINTProp(rCIMOM, __TEXT("Max Wait On Events (ms)"), L"MaxWaitOnEvents", pWbemObj);

    sc |= pWbemObj->Get(L"EnableStartupHeapPreallocation", 0, (struct tagVARIANT *)&var, 0, NULL);
    if(sc == S_OK)
    {
        rCIMOM.SetDWORD(__TEXT("EnableStartupHeapPreallocation"), var.GetBool() ? 1 : 0);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\internalmerger.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    INTERNALMERGER.H

Abstract:

    CInternalMerger class.

History:

	30-Nov-00   sanjes    Created.

--*/

#ifndef _INTERNALMERGER_H_
#define _INTERNALMERGER_H_

#include "mergerthrottling.h"
#include "wstlallc.h"

// Forward class definitions
class CWmiMergerRecord;

// Base class for merger sinks - all of these will be created by the
// merger and will AddRef() the merger.  The merger class will be used
// to create the sinks.  When the Merger is destroyed, it will delete
// all of the sink.  Internal Merger objects MUST NOT AddRef these sinks
// so we don't create a circular dependency.

typedef enum
{
	eMergerFinalSink,
	eMergerOwnSink,
	eMergerChildSink,
	eMergerOwnInstanceSink
} MergerSinkType;

class CMergerSink : public CBasicObjectSink
{
protected:
	CWmiMerger*	m_pMerger;
	long		m_lRefCount;

	virtual HRESULT OnFinalRelease( void ) = 0;

public:
	CMergerSink( CWmiMerger* pMerger );
	virtual ~CMergerSink();

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

	virtual HRESULT Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated ) = 0L;
};

class CMergerTargetSink : public CMergerSink
{
protected:
	IWbemObjectSink*	m_pDest;

	virtual HRESULT OnFinalRelease( void );

public:
	CMergerTargetSink( CWmiMerger* pMerger, IWbemObjectSink* pDest );
	~CMergerTargetSink();

    HRESULT STDMETHODCALLTYPE Indicate(long lObjectCount, IWbemClassObject** pObjArray);
    HRESULT STDMETHODCALLTYPE SetStatus( long lFlags, long lParam, BSTR strParam,
                             IWbemClassObject* pObjParam );

	// Function allows us to track the lowest level call in the merger so we can decide
	// if we need to automagically report all indicated objects to the arbitrator
	HRESULT Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  );

};

// Causes the stl Map to use our allocator instead of the default

struct CInternalMergerRecord
{
    CWbemInstance* m_pData;
	DWORD m_dwObjSize;
    BOOL m_bOwn;
};

// Defines an allocator so we can throw exceptions
class CKeyToInstRecordAlloc : public wbem_allocator<CInternalMergerRecord>
{
};

inline bool operator==(const CKeyToInstRecordAlloc&, const CKeyToInstRecordAlloc&)
    { return (true); }
inline bool operator!=(const CKeyToInstRecordAlloc&, const CKeyToInstRecordAlloc&)
    { return (false); }

typedef	std::map<WString, CInternalMergerRecord, WSiless, CKeyToInstRecordAlloc>			MRGRKEYTOINSTMAP;
typedef	std::map<WString, CInternalMergerRecord, WSiless, CKeyToInstRecordAlloc>::iterator	MRGRKEYTOINSTMAPITER;

// This is the actual workhorse class for merging instances returned from
// queries.

class CInternalMerger
{
protected:

	// Helper class for scoped cleanup of memory usage
	class CScopedMemoryUsage
	{
		CInternalMerger*	m_pInternalMerger;
		bool				m_bCleanup;
		long				m_lMemUsage;

	public:
		CScopedMemoryUsage( CInternalMerger* pInternalMerger )
			: m_pInternalMerger( pInternalMerger ), m_bCleanup( false ), m_lMemUsage( 0L ) {};
		~CScopedMemoryUsage();

		HRESULT ReportMemoryUsage( long lMemUsage );
		HRESULT Cleanup( void );
	};

    class CMemberSink : public CMergerSink
    {
    protected:
        CInternalMerger*	m_pInternalMerger;

    public:
        CMemberSink( CInternalMerger* pMerger, CWmiMerger* pWmiMerger )
		: CMergerSink( pWmiMerger ), m_pInternalMerger( pMerger )
        {}

		STDMETHOD_(ULONG, AddRef)(THIS);

        STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    };
    friend CMemberSink;

    class COwnSink : public CMemberSink
    {
	protected:
		virtual HRESULT OnFinalRelease( void );

    public:
        COwnSink(CInternalMerger* pMerger, CWmiMerger* pWmiMerger) : CMemberSink(pMerger, pWmiMerger){};
        ~COwnSink();

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

		// Function allows us to track the lowest level call in the merger so we can decide
		// if we need to automagically report all indicated objects to the arbitrator
		HRESULT Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  );


    };
    friend COwnSink;

    class CChildSink : public CMemberSink
    {
	protected:
		virtual HRESULT OnFinalRelease( void );

    public:
        CChildSink(CInternalMerger* pMerger, CWmiMerger* pWmiMerger) : CMemberSink(pMerger, pWmiMerger){};
        ~CChildSink();

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

		// Function allows us to track the lowest level call in the merger so we can decide
		// if we need to automagically report all indicated objects to the arbitrator
		HRESULT Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated );

    };

    class COwnInstanceSink : public CMemberSink
    {
		CCritSec			m_cs;
		WString				m_wsInstPath;
		IWbemClassObject*	m_pMergedInstance;
		bool				m_bTriedRetrieve;
		HRESULT				m_hFinalStatus;

	protected:
		virtual HRESULT OnFinalRelease( void );

    public:
        COwnInstanceSink(CInternalMerger* pMerger, CWmiMerger* pWmiMerger)
			:	CMemberSink(pMerger, pWmiMerger), m_pMergedInstance( NULL ), m_wsInstPath(),
				m_cs(), m_bTriedRetrieve( false ), m_hFinalStatus( WBEM_S_NO_ERROR )
		{};
        ~COwnInstanceSink();

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
        STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);

		// This should never be called here
		HRESULT Indicate(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  );

		HRESULT	SetInstancePath( LPCWSTR pwszPath );
		HRESULT GetObject( IWbemClassObject** ppMergedInst );
		void SetFinalStatus( HRESULT hRes )
			{ if ( SUCCEEDED( m_hFinalStatus ) ) m_hFinalStatus = hRes; };
    };

    friend CChildSink;

public:

	// Helpers for creating sinks
	static HRESULT CreateMergingSink( MergerSinkType eType, CInternalMerger* pMerger, CWmiMerger* pWmiMerger, CMergerSink** ppSink );

	// 2 stage initialization
	HRESULT Initialize( void );

protected:
    COwnSink* m_pOwnSink;
    CChildSink* m_pChildSink;
    CMergerSink* m_pDest;

    BOOL m_bDerivedFromTarget;
    CWbemClass* m_pOwnClass;
    CWbemNamespace* m_pNamespace;
    IWbemContext* m_pContext;
	CWmiMergerRecord*	m_pWmiMergerRecord;

    MRGRKEYTOINSTMAP m_map;

    BOOL m_bOwnDone;
    BOOL m_bChildrenDone;
    WString m_wsClass;
    long m_lRef;

    IServerSecurity* m_pSecurity;

	// This is set when we encounter an error condition and are cancelled
	HRESULT	m_hErrorRes;

	// m_Throttler - sounds like a Supervillain...hmmm...
	CMergerThrottling	m_Throttler;

	// Helps debug how much data this internal merger is consuming
	long	m_lTotalObjectData;

	// Iterator which may require state to be kept
	MRGRKEYTOINSTMAPITER	m_DispatchOwnIter;

protected:
    HRESULT AddOwnObjects(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  );
    HRESULT AddChildObjects(long lObjectCount, IWbemClassObject** pObjArray, bool bLowestLevel, long* plNumIndicated  );
	HRESULT AddOwnInstance( IWbemClassObject* pObj, LPCWSTR wszTargetKey,
							IWbemClassObject** ppMergedInstance);
	HRESULT	RemoveInstance( LPCWSTR pwszInstancePath );

	HRESULT GetObjectLength( IWbemClassObject* pObj, long* plObjectSize );

	// inline helper - adjusts throttler totals, then allows it to release itself if
	// apropriate
	void AdjustThrottle( long lNumParentObjects, long lNumChildObjects )
	{
		// Adjust the throttler now.
		m_Throttler.AdjustNumParentObjects( lNumParentObjects );
		m_Throttler.AdjustNumChildObjects( lNumChildObjects );

		// Let the Throttler release itself if it can
		m_Throttler.ReleaseThrottle();
	}

	// Helper function to perform Indicating and throttling - a lot of the code is more or
	// less the same so this at least attempts to encapsulate it.
	HRESULT IndicateArrayAndThrottle( long lObjectCount, CRefedPointerArray<IWbemClassObject>* pObjArray,
									CWStringArray* pwsKeyArray, long lMapAdjustmentSize, long lNewObjectSize, bool bThrottle,
									bool bParent, long* plNumIndicated );

    void Enter() { m_Throttler.Enter(); }
    void Leave() { m_Throttler.Leave(); }

    long AddRef();
    long Release();

    void OwnIsDone();
    void ChildrenAreDone();

    void DispatchChildren();
    void DispatchOwn();
    void GetKey(IWbemClassObject* pInst, WString& wsKey);
    HRESULT GetOwnInstance(LPCWSTR wszKey, IWbemClassObject** ppMergedInstance);
    BOOL IsDone() {return m_bOwnDone && m_bChildrenDone;}

	void AdjustLocalObjectSize( long lAdjust )
	{ 
		m_lTotalObjectData += lAdjust;
		_DBG_ASSERT( m_lTotalObjectData >= 0L );
	}

	HRESULT	ReportMemoryUsage( long lMemUsage );

public:
    CInternalMerger(CWmiMergerRecord*	pWmiMergerRecord, CMergerSink* pDest, CWbemClass* pOwnClass,
                CWbemNamespace* pNamespace = NULL,
                IWbemContext* pContext = NULL);
    ~CInternalMerger();

    void SetIsDerivedFromTarget(BOOL bIs);

	void Cancel( HRESULT hRes = WBEM_E_CALL_CANCELLED );

    CMergerSink* GetOwnSink() { if ( NULL != m_pOwnSink ) m_pOwnSink->AddRef(); return m_pOwnSink;}
    CMergerSink* GetChildSink() { if ( NULL != m_pChildSink ) m_pChildSink->AddRef(); return m_pChildSink; }

	CWmiMerger*	GetWmiMerger( void );

	// Helper to cancel a child sink when we don't need one (i.e. if we're fully static).
	//void CancelChildSink( void )	{ ChildrenAreDone(); }
};

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\login.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOGIN.CPP

Abstract:

    WinMgmt Secure Login Module

History:

    raymcc        06-May-97       Created.
    raymcc        28-May-97       Updated for NT5/Memphis beta releases.
    raymcc        07-Aug-97       Group support and NTLM fixes.

--*/

#include "precomp.h"
#include <arena.h>
#include <stdio.h>
#include <wbemcore.h>
#include <genutils.h>
#include <winntsec.h>
#include <objidl.h>

#define ACCESS_DENIED_DELAY 5000
#include "md5wbem.h"
#include "sechelp.h"

#include <memory>
#include <lmerr.h>

typedef enum DfaStates
{
    InitialState = 0,
    FirstBackSlash,
    SecondBackSlash,
    ServerCharacters,
    NamespaceChar,
    NamespaceSep,
    ObjectBegin,
    DeadState,
    LastState
} eDfaStates;

typedef enum DfaClasses 
{
    BackSlash = 0,
    Space,
    Character,
    Colon,
    LastClass
} eDfaClasses;

eDfaStates g_States[LastState][LastClass] = 
{    
                            /* BackSlash   - Space     - Character      - Colon */
    /*InitialState     */ { FirstBackSlash,  DeadState, NamespaceChar,    DeadState  },
    /*FirstBackSlash   */ { SecondBackSlash, DeadState, DeadState,        DeadState  },
    /*SecondBackSlash  */ { DeadState,       DeadState, ServerCharacters, DeadState  },
    /*ServerCharacters */ { NamespaceChar,   DeadState, ServerCharacters, DeadState  },
    /*NamespaceChar    */ { NamespaceSep,    DeadState, NamespaceChar,    ObjectBegin},
    /*NamespaceSep     */ { DeadState,       DeadState, NamespaceChar,    DeadState  },
    /*ObjectBegin      */ { DeadState,       DeadState, DeadState,        DeadState  },
    /*DeadStat         */ { DeadState,       DeadState, DeadState,        DeadState  },
};

typedef enum AcceptingState
{
    Valid = 0,
    Invalid,
    ComponentTooLong
} eAcceptingState;

eAcceptingState PreParsePath(WCHAR * pPath,DWORD ComponentLimit)
{
    eDfaStates Status = InitialState;
    DWORD CchPerUnchangedState = 1;
    for (;*pPath;pPath++)
    {
        eDfaStates OldStatus  = Status;
        switch(*pPath)
        {
        case L'\\':
        case L'/':            
            Status = g_States[Status][BackSlash];
            break;
        case L' ':
        case L'\t':
            Status = g_States[Status][Space];
            break;
        case L':':
            Status = g_States[Status][Colon];
            break;
        default:
            Status = g_States[Status][Character];
            break;
        }
        if (ObjectBegin == Status) break; // fast track an acceptance state

        if (Status != OldStatus)
        {
            switch(OldStatus)
            {
            case ServerCharacters:
                CchPerUnchangedState = 0;
                break;
            case InitialState:
            case NamespaceSep: 
                CchPerUnchangedState = 1;
                break;
            }
        }
        if (NamespaceChar == OldStatus && NamespaceChar == Status)
        {
            CchPerUnchangedState++;
            if (CchPerUnchangedState > ComponentLimit) return ComponentTooLong;            
        }
    }
    if (ObjectBegin == Status ||
        NamespaceChar == Status )
    {
        return Valid;
    }
    else
    {
        return Invalid;
    }
}


static LPCWSTR LocateNamespaceSubstring(LPWSTR pSrc);

#define MAX_LANG_SIZE 255

void PossiblySetLocale(CWbemNamespace * pProv,LPCWSTR  pLocale)
{
    if(pLocale)  pProv->SetLocale(pLocale);
}

HRESULT EnsureInitialized();

HRESULT InitAndWaitForClient()
{
    HRESULT hr = EnsureInitialized();
    if(FAILED(hr))
        return hr;
    hr = ConfigMgr::WaitUntilClientReady();
        if(FAILED(hr)) return hr;
    return hr;
}
//***************************************************************************
//
//  GetDefaultLocale
//
//  Returns the user default locale ID, formatted correctly.
//
//***************************************************************************

LPWSTR GetDefaultLocale()
{
    LCID lcid;
    IServerSecurity * pSec = NULL;
    HRESULT hr = CoGetCallContext(IID_IServerSecurity, (void**)&pSec);
    if(SUCCEEDED(hr))
    {
        CReleaseMe rmSec(pSec);
        BOOL bImpersonating = pSec->IsImpersonating();
        if(bImpersonating == FALSE)
            hr = pSec->ImpersonateClient();
        lcid = GetUserDefaultLCID();
        if(bImpersonating == FALSE && SUCCEEDED(hr))
        {
            if (FAILED(hr = pSec->RevertToSelf()))
                return 0;
        }
    }
    else
        lcid = GetUserDefaultLCID();

    if(lcid == 0)
    {
        ERRORTRACE((LOG_WBEMCORE, "GetUserDefaultLCID failed, restorting to system verion"));
        lcid = GetSystemDefaultLCID();
    }
    if(lcid == 0)
    {
        ERRORTRACE((LOG_WBEMCORE, "GetSystemDefaultLCID failed, restorting hard coded 0x409"));
        lcid = 0x409;
    }

    wchar_t *pwName = NULL;
    if (lcid)
    {
        TCHAR szNew[MAX_LANG_SIZE + 1];
        TCHAR *pszNew = szNew;
        int iRet;
        iRet = GetLocaleInfo(lcid, LOCALE_IDEFAULTLANGUAGE, pszNew, MAX_LANG_SIZE);

        if (iRet > 0)
        {

            // Strip off initial zeros.
            while (pszNew[0] == __TEXT('0'))
            {
                pszNew++;
                iRet--;
            }

            pwName = new wchar_t[iRet + 4];
            if (pwName)
            {
                StringCchPrintfW(pwName, iRet+4, __TEXT("ms_%s"), pszNew);
            }
        }

    }
    return pwName;
}

//***************************************************************************
//
//  FindSlash
//
//  A local for finding the first '\\' or '/' in a string.  Returns null
//  if it doesnt find one.
//
//***************************************************************************
// ok


const WCHAR * FindSlash(LPCWSTR pTest)
{
    if(pTest == NULL)
        return NULL;
    for(;*pTest;pTest++)
        if(IsSlash(*pTest))
            return pTest;
    return NULL;
}

//***************************************************************************
//
//  CWbemLocator::CWbemLocator
//
//  Constructor.
//
//***************************************************************************
// ok
CWbemLocator::CWbemLocator()
{
    gClientCounter.AddClientPtr(&m_Entry);
    m_uRefCount = 0;
}


//***************************************************************************
//
//  CWbemLocator::~CWbemLocator
//
//  Destructor.
//
//***************************************************************************
// ok
CWbemLocator::~CWbemLocator()
{
    gClientCounter.RemoveClientPtr(&m_Entry);
}

//***************************************************************************
//
//  CWbemLocator::QueryInterface, AddREf, Release
//
//  Standard IUnknown implementation.
//
//***************************************************************************
// ok
SCODE CWbemLocator::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemLocator==riid)
    {
        *ppvObj = (IWbemLocator*)this;
        AddRef();
        return NOERROR;
    }
    /*
    else if (IID_IWbemConnection==riid)
    {
        *ppvObj = (IWbemConnection*)this;
        AddRef();
        return NOERROR;
    }
    */

    return ResultFromScode(E_NOINTERFACE);
}

//***************************************************************************
//
//***************************************************************************
// ok

ULONG CWbemLocator::AddRef()
{
    return ++m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************
// ok

ULONG CWbemLocator::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 == uNewCount)
        delete this;
    return uNewCount;
}

//***************************************************************************
//
//***************************************************************************
// ok
HRESULT CWbemLocator::GetNamespace(
    IN  READONLY   LPCWSTR ObjectPath,
    IN  READONLY   LPCWSTR User,
    IN  READONLY   LPCWSTR Locale,
    IWbemContext *pCtx,
    IN  READONLY   DWORD dwSecFlags,
    IN  READONLY   DWORD dwPermission,
    REFIID riid, void **pInterface,
    bool bAddToClientList, long lClientFlags)
{
    bool bIsLocal = false;
    bool bIsImpersonating = WbemIsImpersonating();

    LPWSTR pLocale = (LPWSTR)Locale;

    // Parameter validation.
    // =====================

    if (ObjectPath == 0 || pInterface == 0)
        return WBEM_E_INVALID_PARAMETER;

    *pInterface = NULL;

    // Check if there is a server name in front.  If so,
    // we skip past it, because by definition any call
    // reaching us was intended for us anyway.
    // =================================================

    LPCWSTR wszNamespace;
    if (IsSlash(ObjectPath[0]) && IsSlash(ObjectPath[1]))
    {
        // Find the next slash
        // ===================

        const WCHAR* pwcNextSlash = FindSlash(ObjectPath+2);

        if (pwcNextSlash == NULL)
            return WBEM_E_INVALID_PARAMETER;

        // Dont allow server names when using Admin, Authen, or UnAuthen locators

        if(pwcNextSlash != ObjectPath+3 || ObjectPath[2] != L'.')
            return WBEM_E_INVALID_PARAMETER;

        wszNamespace = pwcNextSlash+1;
    }
    else
    {
        wszNamespace = ObjectPath;
    }

    eAcceptingState AcceptResult = PreParsePath((WCHAR *)wszNamespace,g_PathLimit-NAMESPACE_ADJUSTMENT);
    if (Invalid == AcceptResult)
    {
       return WBEM_E_INVALID_NAMESPACE;
    }
    if (ComponentTooLong == AcceptResult)
    {
       return WBEM_E_QUOTA_VIOLATION;
    }

    WCHAR TempUser[MAX_PATH];
    bool bGetUserName = (bIsImpersonating && User == NULL);

    // If the user name was not specified and the thread is impersonating, get the user
    // name.  This is used for things like the provider cache.

    if(bGetUserName)
    {
        CNtSid sid(CNtSid::CURRENT_THREAD);
        if (CNtSid::NoError == sid.GetStatus())
        {
            TempUser[0] = 0;
            LPWSTR pRetAccount, pRetDomain;
            DWORD dwUse;
            if(0 == sid.GetInfo(&pRetAccount, &pRetDomain, &dwUse))
            {
                if(wcslen(pRetDomain) + wcslen(pRetAccount) < MAX_PATH-2)   
                {
                    StringCchCopyW(TempUser, MAX_PATH, pRetDomain);
                    StringCchCatW(TempUser, MAX_PATH, L"\\");
                    StringCchCatW(TempUser, MAX_PATH, pRetAccount);
                }
                delete [] pRetAccount;
                delete [] pRetDomain;
            }
        }
    }

    // Try to locate the namespace and bind an object to it.
    // =====================================================

    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if(pSvc == NULL) return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe rm(pSvc);

    long lIntFlags = WMICORE_CLIENT_ORIGIN_INPROC;
    if(bAddToClientList)
        lIntFlags |= WMICORE_CLIENT_TYPE_ALT_TRANSPORT;

    HRESULT hr;
    IServerSecurity * pSec = NULL;
    hr = CoGetCallContext(IID_IServerSecurity,(void **)&pSec);
    CReleaseMe rmSec(pSec);
    if (RPC_E_CALL_COMPLETE == hr ) hr = S_OK; // no call context
    if (FAILED(hr)) return hr;
    BOOL bImper = (pSec)?pSec->IsImpersonating():FALSE;
    if (pSec && bImper && FAILED(hr = pSec->RevertToSelf())) return hr;
    
    IUnknown * pIUnk = NULL;
    hr = pSvc->GetServices2(ObjectPath,
                                            User,
                                            pCtx,
                                            lClientFlags, //* [in] */ ULONG uClientFlags,
                                            0, ///* [in] */ DWORD dwSecFlags,
                                            0, //* [in] */ DWORD dwPermissions,
                                            lIntFlags, ///* [in] */ ULONG uInternalFlags,
                                            NULL,
                                            0XFFFFFFFF,
                                            riid,
                                            (void **)&pIUnk);
    CReleaseMe rmUnk(pIUnk);

    if (bImper && pSec)
    {
        HRESULT hrInner = pSec->ImpersonateClient();
        if (FAILED(hrInner)) return hrInner;
    }

    if(FAILED(hr))
        return hr;

    CWbemNamespace * pProv = (CWbemNamespace *)(void *)pIUnk;
    pProv->SetIsProvider(TRUE);


    if (!Locale || !wcslen(Locale))   
    {
        pLocale = GetDefaultLocale();
        if (NULL == pLocale) return WBEM_E_OUT_OF_MEMORY;
        PossiblySetLocale(pProv,pLocale);
        delete pLocale;
    }
    else
        PossiblySetLocale(pProv,Locale);

    *pInterface = rmUnk.dismiss();

    return WBEM_NO_ERROR;
}





STDMETHODIMP CWbemAdministrativeLocator::ConnectServer(
         const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
         LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
         IWbemServices **ppNamespace
        )
{
    HRESULT hr = EnsureInitialized();
    if(FAILED(hr))
        return hr;
    return GetNamespace(NetworkResource,  ADMINISTRATIVE_USER, Locale, pCtx,
            0, FULL_RIGHTS,IID_IWbemServices, (void **)ppNamespace, false, lSecurityFlags);
}

STDMETHODIMP CWbemAuthenticatedLocator::ConnectServer(
         const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
         LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
         IWbemServices **ppNamespace
        )
{

    HRESULT hr = InitAndWaitForClient();
    if(FAILED(hr))
        return hr;

    return GetNamespace(NetworkResource,  User, Locale,  pCtx,
            0, FULL_RIGHTS, IID_IWbemServices, (void **)ppNamespace, true, lSecurityFlags);
}

STDMETHODIMP CWbemUnauthenticatedLocator::ConnectServer(
         const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
         LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
         IWbemServices **ppNamespace
        )
{
    HRESULT hr = InitAndWaitForClient();
    if(FAILED(hr))
        return hr;

    return GetNamespace(NetworkResource,  
                                    User, 
                                    Locale, 
                                    pCtx,
                                    0,
                                    0,
                                    IID_IWbemServices, 
                                    (void **)ppNamespace, 
                                    false, 
                                    lSecurityFlags);
}


//***************************************************************************
//
//  CWbemLevel1Login::CWbemLevel1Login
//
//***************************************************************************
// ok

CWbemLevel1Login::CWbemLevel1Login()
{
    m_pszUser = 0;
    m_pszDomain = 0;
    m_uRefCount = 0;
    m_pwszClientMachine = 0;
    m_lClientProcId = -1;         // never been set
    gClientCounter.AddClientPtr(&m_Entry);
}


//***************************************************************************
//
//  CWbemLevel1Login::~CWbemLevel1Login
//
//  Destructor
//
//***************************************************************************
// ok

CWbemLevel1Login::~CWbemLevel1Login()
{
    delete [] m_pszUser;
    delete [] m_pszDomain;
    delete [] m_pwszClientMachine;
    gClientCounter.RemoveClientPtr(&m_Entry);
}

//***************************************************************************
//
//  CWbemLevel1Login::QueryInterface, AddREf, Release
//
//  Standard IUnknown implementation.
//
//***************************************************************************
// ok
SCODE CWbemLevel1Login::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IWbemLevel1Login==riid)
    {
        *ppvObj = (IWbemLevel1Login*)this;
        AddRef();
        return NOERROR;
    }
    /*
    else if(IID_IWbemLoginHelper==riid)
    {
        *ppvObj = (IWbemLoginHelper*)this;
        AddRef();
        return NOERROR;
    }
    else if(IID_IWbemConnectorLogin==riid)
    {
        *ppvObj = (IWbemConnectorLogin*)this;
        AddRef();
        return NOERROR;
    }
    */
    else if(IID_IWbemLoginClientID==riid)
    {
        *ppvObj = (IWbemLoginClientID*)this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

//***************************************************************************
//
//***************************************************************************
// ok

ULONG CWbemLevel1Login::AddRef()
{
    return ++m_uRefCount;
}

//***************************************************************************
//
//***************************************************************************
// ok

ULONG CWbemLevel1Login::Release()
{
    ULONG uNewCount = InterlockedDecrement((LONG *) &m_uRefCount);
    if (0 == uNewCount)
        delete this;
    return uNewCount;
}

//***************************************************************************
//
//  CWbemLevel1Login::EstablishPosition
//
//  Initiates proof of locality.
//
//***************************************************************************
// ok
HRESULT CWbemLevel1Login::EstablishPosition(
                                LPWSTR wszMachineName,
                                DWORD dwProcessId,
                                DWORD* phAuthEventHandle)
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//  CWbemLevel1Login::RequestChallenge
//
//  Requests a WBEM Level 1 challenge.
//
//***************************************************************************
// ok

HRESULT CWbemLevel1Login::RequestChallenge(
                            LPWSTR wszNetworkResource,
                            LPWSTR pUser,
                            WBEM_128BITS Nonce
    )
{
    return WBEM_E_NOT_SUPPORTED;
}

//***************************************************************************
//
//  CWbemLevel1Login::WBEMLogin
//
//  Logs the user in to WBEM using WBEM authentication
//
//***************************************************************************
// ok

HRESULT CWbemLevel1Login::WBEMLogin(
    LPWSTR pPreferredLocale,
    WBEM_128BITS AccessToken,
    LONG lFlags,
    IWbemContext *pCtx,
    IWbemServices **ppNamespace
    )
{
    return E_NOTIMPL;
}

//***************************************************************************
//
//  CWbemLevel1Login::IsValidLocale
//
//  Checks if the supplied locale string is valid
//
//***************************************************************************
BOOL CWbemLevel1Login::IsValidLocale(LPCWSTR wszLocale)
{
    if(wszLocale && *wszLocale)
    {
        // This has to be temporary - this eventually
        // will support non-MS locales?
        // ==========================================

        if(wbem_wcsnicmp(wszLocale, L"ms_", 3))
            return FALSE;

        WCHAR* pwcEnd = NULL;
        wcstoul(wszLocale+3, &pwcEnd, 16);
        if(pwcEnd == NULL || *pwcEnd != 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}


HRESULT CWbemLevel1Login::SetClientInfo(
            /* [string][unique][in] **/ LPWSTR wszClientMachine,
            /* [in] */ LONG lClientProcId,
            /* [in] */ LONG lReserved)
{
    m_lClientProcId = lClientProcId;
    if(wszClientMachine)
    {
        int iLen = wcslen_max(wszClientMachine,MAX_COMPUTERNAME_LENGTH);
        if (iLen > MAX_COMPUTERNAME_LENGTH)
            return WBEM_E_INVALID_PARAMETER;
        delete [] m_pwszClientMachine;
        m_pwszClientMachine = new WCHAR[iLen];
        if(m_pwszClientMachine == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        StringCchCopyW(m_pwszClientMachine, iLen, wszClientMachine);
    }
    return S_OK;
}


HRESULT CWbemLevel1Login::ConnectorLogin(
            /* [string][unique][in] */ LPWSTR wszNetworkResource,
            /* [string][unique][in] */ LPWSTR wszPreferredLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface)
{
    try
    {
        HRESULT hRes;

        HRESULT hr = InitAndWaitForClient();
        if(FAILED(hr))
            return hr;

        DEBUGTRACE((LOG_WBEMCORE,
            "CALL ConnectionLogin::NTLMLogin\n"
            "   wszNetworkResource = %S\n"
            "   pPreferredLocale = %S\n"
            "   lFlags = 0x%X\n",
            wszNetworkResource,
            wszPreferredLocale,
            lFlags
            ));

        if(pInterface == NULL || wszNetworkResource == NULL)
            return WBEM_E_INVALID_PARAMETER;

       //
       // repository only anb provider only can be used together
       //
       if (lFlags & ~(WBEM_FLAG_CONNECT_REPOSITORY_ONLY|WBEM_FLAG_CONNECT_PROVIDERS))
             return WBEM_E_INVALID_PARAMETER;
      
        if (riid != IID_IWbemServices)
             return WBEM_E_INVALID_PARAMETER;

       eAcceptingState AcceptResult = PreParsePath(wszNetworkResource,g_PathLimit-NAMESPACE_ADJUSTMENT);
       if (Invalid == AcceptResult)
       {
           return WBEM_E_INVALID_NAMESPACE;
       }
       if (ComponentTooLong == AcceptResult)
       {
           return WBEM_E_QUOTA_VIOLATION;
       }
       
        *pInterface = 0;       // default

        if(!CWin32DefaultArena::ValidateMemSize())
        {
            ERRORTRACE((LOG_WBEMCORE, "ConnectorLogin was rejected due to low memory"));
            return WBEM_E_OUT_OF_MEMORY;
        }

        // Retrieve DCOM security context
        // ==============================

        IServerSecurity* pSec = NULL;
        hRes = CoGetCallContext(IID_IServerSecurity, (void**)&pSec);
        CReleaseMe  rm( pSec );        
        if (RPC_E_CALL_COMPLETE == hRes)
        {
            // Not a problem --- just somebody coming from in-proc.
            return LoginUser(wszNetworkResource, wszPreferredLocale, lFlags,
                                        pCtx, true, riid, pInterface, true);

        }
        if(FAILED(hRes)) return hRes;

        // Check connection settings
        // =========================
        DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel, dwCapabilities;
        LPWSTR wszClientName;

        hRes = pSec->QueryBlanket(&dwAuthnSvc, &dwAuthzSvc, NULL, &dwAuthnLevel,
                                NULL, (void**)&wszClientName, &dwCapabilities);
        if(FAILED(hRes))
        {
            // In some cases, we cant get the name, but the rest is ok.  In particular
            // the temporary SMS accounts have that property.

            hRes = pSec->QueryBlanket(&dwAuthnSvc, &dwAuthzSvc, NULL, &dwAuthnLevel,
                                    NULL, NULL, &dwCapabilities);
            wszClientName = NULL;
        }

        if(FAILED(hRes))
        {
            ERRORTRACE((LOG_WBEMCORE, "Unable to retrieve NTLM connection settings."
                            " Error code: 0x%X\n", hRes));
            Sleep(ACCESS_DENIED_DELAY);
            return WBEM_E_ACCESS_DENIED;
        }

        BOOL bGotName = (wszClientName && (wcslen(wszClientName) > 0));    // SEC:REVIEWED 2002-03-22 : Needs EH

        char* szLevel = NULL;
        switch(dwAuthnLevel)
        {
        case RPC_C_AUTHN_LEVEL_NONE:
            DEBUGTRACE((LOG_WBEMCORE, "DCOM connection which is unathenticated "
                        ". NTLM authentication failing.\n"));
            Sleep(ACCESS_DENIED_DELAY);
            return WBEM_E_ACCESS_DENIED;
        case RPC_C_AUTHN_LEVEL_CONNECT:
            szLevel = "Connect";
            break;
        case RPC_C_AUTHN_LEVEL_CALL:
            szLevel = "Call";
            break;
        case RPC_C_AUTHN_LEVEL_PKT:
            szLevel = "Packet";
            break;
        case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:
            szLevel = "Integrity";
            break;
        case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
            szLevel = "Privacy";
            break;
        };

        DEBUGTRACE((LOG_WBEMCORE, "DCOM connection from %S at authentiction level "
                        "%s, AuthnSvc = %d, AuthzSvc = %d, Capabilities = %d\n",
            wszClientName, szLevel, dwAuthnSvc, dwAuthzSvc, dwCapabilities));

        // Parse the user name
        // ===================

        if(bGotName)
        {
            WCHAR* pwcSlash = wcschr(wszClientName, '\\');
            if(pwcSlash == NULL)
            {
                ERRORTRACE((LOG_WBEMCORE, "Misformed username %S received from DCOM\n",
                                wszClientName));
                Sleep(ACCESS_DENIED_DELAY);
                return WBEM_E_ACCESS_DENIED;
            }

            WCHAR* pszDomain = new WCHAR[pwcSlash - wszClientName + 1];
            if(pszDomain == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            wcsncpy(pszDomain, wszClientName, pwcSlash - wszClientName);   // SEC:REVIEWED 2002-03-22 : Needs EH
            pszDomain[pwcSlash - wszClientName] = 0;

            m_pszUser = Macro_CloneLPWSTR(wszClientName);   // SEC:REVIEWED 2002-03-22 : Needs EH because of embedded wsclen, wcscpy

             delete [] pszDomain;
        }
        else
        {
            m_pszUser = Macro_CloneLPWSTR(L"<unknown>");
        }

        // User authenticated. Proceed
        // ============================

        return LoginUser(wszNetworkResource, wszPreferredLocale, lFlags,
                                        pCtx,  false, riid, pInterface, false);
    }
    catch(...) // COM interfaces do not throw
    {
        ExceptionCounter c;
        return WBEM_E_CRITICAL_ERROR;
    }

}

//***************************************************************************
//
//  CWbemLevel1Login::NTLMLogin
//
//  Logs the user in to WBEM using NTLM authentication
//
//***************************************************************************
// ok

HRESULT CWbemLevel1Login::NTLMLogin(
    LPWSTR wszNetworkResource,
    LPWSTR pPreferredLocale,
    LONG lFlags,
    IWbemContext *pCtx,
    IWbemServices **ppNamespace
    )
{
    return ConnectorLogin(wszNetworkResource, pPreferredLocale, lFlags, pCtx,
                            IID_IWbemServices, (void **)ppNamespace);
}

//***************************************************************************
//
//  CWbemLevel1Login::LoginUser
//
//  Logs the user in to WBEM who may or may not have already been authenticated.
//
//***************************************************************************
// ok

HRESULT CWbemLevel1Login::LoginUser(
    LPWSTR wszNetworkResource,
    LPWSTR pPreferredLocale,
    long lFlags,
    IWbemContext* pCtx,
    bool bAlreadyAuthenticated,
    REFIID riid,
    void **pInterface, bool bInProc)
{

   if(riid != IID_IWbemServices ) return E_NOINTERFACE;
   if (NULL == pInterface) return E_POINTER;

   *pInterface = NULL;

    LPWSTR pLocale = pPreferredLocale;
    LPWSTR pToDelete = NULL;

    // Verify locale validity
    // Set default if not provided.
    // ============================

    if (!pLocale || !wcslen(pLocale))  
    {
        pLocale = GetDefaultLocale();
        if (pLocale == 0) return WBEM_E_OUT_OF_MEMORY;
        pToDelete = pLocale;
    }

    CDeleteMe<WCHAR> del1(pToDelete);

    if(!IsValidLocale(pLocale))
        return WBEM_E_INVALID_PARAMETER;

    // Grab the ns and hand it back to the caller.
    // ===========================================

    CCoreServices *pSvc = CCoreServices::CreateInstance();
    if(pSvc == NULL) return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe rm(pSvc);

    long lIntFlags = 0;
    if(bInProc)
        lIntFlags = WMICORE_CLIENT_ORIGIN_INPROC;
    else
        lIntFlags = WMICORE_CLIENT_ORIGIN_LOCAL;


    HRESULT hr;
    IUnknown * pIUnk = NULL;
    CReleaseMeRef<IUnknown *> rmUnk(pIUnk);
    if (lIntFlags & WMICORE_CLIENT_ORIGIN_INPROC)
    {        
        IServerSecurity * pSec = NULL;
        hr = CoGetCallContext(IID_IServerSecurity,(void **)&pSec);
        CReleaseMe rmSec(pSec);
        if (RPC_E_CALL_COMPLETE == hr ) hr = S_OK; // no call context
        if (FAILED(hr)) return hr;
        BOOL bImper = (pSec)?pSec->IsImpersonating():FALSE;
        if (pSec && bImper && FAILED(hr = pSec->RevertToSelf())) return hr;
            
        hr = pSvc->GetServices2(
                wszNetworkResource,
                m_pszUser,
                pCtx,
                lFlags, //* [in] */ ULONG uClientFlags,
                0, ///* [in] */ DWORD dwSecFlags,
                0, //* [in] */ DWORD dwPermissions,
                lIntFlags, ///* [in] */ ULONG uInternalFlags,
                m_pwszClientMachine,
                m_lClientProcId,
                riid,
                (void **)&pIUnk);
        
        if (bImper && pSec)
        {
            HRESULT hrInner = pSec->ImpersonateClient();
            if (FAILED(hrInner)) return hrInner;
        }
        
    }
    else
    {
        hr = pSvc->GetServices2(
                wszNetworkResource,
                m_pszUser,
                pCtx,
                lFlags, //* [in] */ ULONG uClientFlags,
                0, ///* [in] */ DWORD dwSecFlags,
                0, //* [in] */ DWORD dwPermissions,
                lIntFlags, ///* [in] */ ULONG uInternalFlags,
                m_pwszClientMachine,
                m_lClientProcId,
                riid,
                (void **)&pIUnk);
    }

    if(FAILED(hr))
    {
        if(hr == WBEM_E_ACCESS_DENIED)
            Sleep(ACCESS_DENIED_DELAY);
        return hr;
    }

    // Do a security check
    CWbemNamespace * pProv = (CWbemNamespace *)(void *)pIUnk;
    PossiblySetLocale(pProv, pLocale);    
    
    DWORD dwAccess = pProv->GetUserAccess();
    if((dwAccess  & WBEM_ENABLE) == 0)
    {
        Sleep(ACCESS_DENIED_DELAY);
        return WBEM_E_ACCESS_DENIED;
    }
    pProv->SetPermissions(dwAccess);

   *pInterface = rmUnk.dismiss();

    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

static LPCWSTR LocateNamespaceSubstring(LPWSTR pSrc)
{
    LPCWSTR pszNamespace;
    if (IsSlash(pSrc[0]) && IsSlash(pSrc[1]))
    {
          // Find the next slash
          // ===================

          const WCHAR* pwcNextSlash = FindSlash(pSrc+2);

          if (pwcNextSlash == NULL)
              return 0;

          pszNamespace = pwcNextSlash+1;
    }
    else
    {
        pszNamespace = pSrc;
    }

    return pszNamespace;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\login.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOGIN.H

Abstract:

	WinMgmt Secure Login Module

History:

	raymcc        06-May-97       Created.
	raymcc        28-May-97       Updated for NT5/Memphis beta releases.
	raymcc        07-Aug-97       Group support and NTLM fixes.

--*/

#ifndef _LOGIN_H_
#define _LOGIN_H_

#include "lmaccess.h"


class CWbemLocator : public IWbemLocator // public IWbemConnection
{
private:
    ULONG m_uRefCount;
protected:
    LIST_ENTRY m_Entry;    

public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    CWbemLocator();
   ~CWbemLocator();

    HRESULT GetNamespace(LPCWSTR wszNetworkResource, LPCWSTR wszUser,
                            LPCWSTR wszLocale,IWbemContext *pCtx,
                            DWORD dwSecFlags, DWORD dwPermission, 
                            REFIID riid, void **pInterface, bool bAddToClientList, 
                            long lClientFlags);
};

// This is used when a provider need a pointer to another namespace.  The access is always granted
// and the client count is not incremented

class CWbemAdministrativeLocator : public CWbemLocator
{
public:
    HRESULT STDMETHODCALLTYPE ConnectServer( 
             const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
             LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
             IWbemServices **ppNamespace
            );

};

// This is used by non dcom transports who have verified the clients identity.  The client count is 
// incremented.

class CWbemAuthenticatedLocator : public CWbemLocator
{
public:
    HRESULT STDMETHODCALLTYPE ConnectServer( 
             const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
             LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
             IWbemServices **ppNamespace );

};

// This is used by providers to get access to other namespaces for the benefit of a client which 
// may or may not have access.  Therefore, access is checked and may be denied and furthermore the
// client count is not incremented.

class CWbemUnauthenticatedLocator : public CWbemLocator
{
public:
    HRESULT STDMETHODCALLTYPE ConnectServer( 
             const BSTR NetworkResource, const BSTR User, const BSTR Password, const BSTR Locale,
             LONG lSecurityFlags, const BSTR Authority, IWbemContext *pCtx,
             IWbemServices **ppNamespace
            );

};
class CWbemLevel1Login : public IWbemLevel1Login,  public IWbemLoginClientID 
{
private:
    LPWSTR         m_pszUser;               // User
    LPWSTR         m_pszDomain;             // Domain (NTLM only)
    LPWSTR         m_pszNetworkResource;    // Namespace name
    LPWSTR         m_pwszClientMachine;
    long           m_lClientProcId;
    ULONG m_uRefCount;
    LIST_ENTRY m_Entry;    

    BOOL IsValidLocale(LPCWSTR wszLocale);
    HRESULT LoginUser(
        LPWSTR pNetworkResource,
        LPWSTR pPreferredLocale,
        long lFlags,
        IWbemContext* pCtx,
        bool bAlreadyAuthenticated,
		REFIID riid,
        void **pInterface, 
        bool bInProc);
    
public:

    CWbemLevel1Login();
    ~CWbemLevel1Login();

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    STDMETHOD(EstablishPosition)(LPWSTR wszMachineName,
                                DWORD dwProcessId,
                                DWORD* phAuthEventHandle);
    STDMETHOD(RequestChallenge)( 
             LPWSTR pNetworkResource,
             LPWSTR pUser,
             WBEM_128BITS Nonce
            );


    STDMETHOD(WBEMLogin)( 
        LPWSTR pPreferredLocale,
        WBEM_128BITS AccessToken,
        LONG lFlags,
        IN  IWbemContext *pCtx,             
        IWbemServices **ppNamespace
        );

    STDMETHOD(NTLMLogin)( 
        LPWSTR pNetworkResource,
        LPWSTR pPreferredLocale,
        LONG lFlags,
        IN  IWbemContext *pCtx,             
        IWbemServices **ppNamespace
        );

    // IWbemConnectorLogin
    HRESULT STDMETHODCALLTYPE ConnectorLogin( 
            /* [string][unique][in] */ LPWSTR wszNetworkResource,
            /* [string][unique][in] */ LPWSTR wszPreferredLocale,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface);

    // IWbemLoginClientID
    HRESULT STDMETHODCALLTYPE SetClientInfo( 
            /* [string][unique][in] * */ LPWSTR wszClientMachine,
            /* [in] */ LONG lClientProcId,
            /* [in] */ LONG lReserved);

};

#define IsSlash(x) ((x) == L'\\' || (x) == L'/')

const WCHAR * FindSlash(LPCWSTR pTest);
LPWSTR GetDefaultLocale();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\mergerreq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MERGERREQ.CPP

Abstract:

    Implementations of the various merger request classes.

History:

    sanjes    28-Feb-01  Created.

--*/

#include "precomp.h"

#pragma warning (disable : 4786)
#include <wbemcore.h>
#include <map>
#include <vector>
#include <genutils.h>
#include <oahelp.inl>
#include <wqllex.h>
#include "wmimerger.h"
#include <helper.h>

//
// Merger Request implementations.
//

CMergerClassReq::CMergerClassReq( CWmiMerger* pMerger, CWmiMergerRecord* pParentRecord,
            CWbemNamespace* pNamespace, CBasicObjectSink* pHandler,
            IWbemContext* pContext)
            :    CMergerReq( pNamespace, pHandler, pContext ),
                m_pMerger( pMerger ),
                m_pParentRecord( pParentRecord ),
                m_pSink( pHandler )
{
    if ( NULL != m_pMerger )
    {
        m_pMerger->AddRef();
    }

    if ( NULL != m_pSink )
    {
        m_pSink->AddRef();
    }
    SetForceRun(1);
    SetPriority(PriorityForceRunRequests);
}

CMergerClassReq::~CMergerClassReq()
{
    if ( NULL != m_pMerger )
    {
        m_pMerger->Release();
    }

    if ( NULL != m_pSink )
    {
        m_pSink->Release();
    }
}

void CMergerClassReq::DumpError()
{
    // none
}

// Pass off execution to the merger
HRESULT CMergerParentReq::Execute ()
{    
    try
    {
        // m_pParentRecord is NULL for the original CMergerParentRquest
        //
        return  m_pMerger->Exec_MergerParentRequest( m_pParentRecord, m_pSink ); // throw
    }
    catch (CX_MemoryException &)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT CMergerChildReq::Execute ()
{
    HRESULT hRes = m_pMerger->Exec_MergerChildRequest( m_pParentRecord, m_pSink );
    return hRes;
}

// Merger Requests
CMergerDynReq::CMergerDynReq( CWbemObject* pClassDef, CWbemNamespace* pNamespace, IWbemObjectSink* pHandler,
          IWbemContext* pContext )
          : CMergerReq( pNamespace, pHandler, pContext )
{
    HRESULT    hr = pClassDef->GetClassName( &m_varClassName );

    if ( FAILED( hr ) || m_varClassName.IsNull())
    {
        throw CX_MemoryException();
    }
}

HRESULT CMergerDynReq_DynAux_GetInstances :: Execute ()
{
    HRESULT hRes = m_pNamespace->Exec_DynAux_GetInstances (

        m_pClassDef ,
        m_lFlags ,
        m_pContext ,
        m_pSink
    ) ;

    return hRes;
}

void CMergerDynReq_DynAux_GetInstances ::DumpError()
{
    // none
}

HRESULT CMergerDynReq_DynAux_ExecQueryAsync :: Execute ()
{
    HRESULT hRes = m_pNamespace->Exec_DynAux_ExecQueryAsync (

        m_pClassDef ,
        m_Query,
        m_QueryFormat,
        m_lFlags ,
        m_pContext ,
        m_pSink
    ) ;

    return hRes;
}

void CMergerDynReq_DynAux_ExecQueryAsync ::DumpError()
{
    // none
}

// Static Requests
CMergerDynReq_Static_GetInstances::CMergerDynReq_Static_GetInstances (

    CWbemNamespace *pNamespace ,
    CWbemObject *pClassDef ,
    long lFlags ,
    IWbemContext *pCtx ,
    CBasicObjectSink *pSink ,
    QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery

) :    CMergerDynReq (
        pClassDef ,
        pNamespace ,
        pSink ,
        pCtx
    ) ,
    m_pClassDef(pClassDef),
    m_pCtx(pCtx),
    m_pSink(pSink),
    m_lFlags(lFlags),
    m_pParsedQuery( pParsedQuery )
{
    if ( m_pParsedQuery )
    {
        m_pParsedQuery->AddRef();
    }

    if (m_pClassDef)
    {
        m_pClassDef->AddRef () ;
    }

    if (m_pCtx)
    {
        m_pCtx->AddRef () ;
    }

    if (m_pSink)
    {
        m_pSink->AddRef () ;
    }

}

CMergerDynReq_Static_GetInstances::~CMergerDynReq_Static_GetInstances ()
{
    if (m_pClassDef)
    {
        m_pClassDef->Release () ;
    }

    if (m_pCtx)
    {
        m_pCtx->Release () ;
    }

    if (m_pSink)
    {
        m_pSink->Release () ;
    }

    if ( NULL != m_pParsedQuery )
    {
        m_pParsedQuery->Release();
    }
}

// Calls into the query engine
HRESULT CMergerDynReq_Static_GetInstances::Execute()
{
    HRESULT    hr = WBEM_E_FAILED;
    IWbemClassObject * pErrObj = NULL;

    CSetStatusOnMe SetStatusOnMe(m_pSink,hr,pErrObj);

    int nRes = CQueryEngine::ExecAtomicDbQuery(
                m_pNamespace->GetNsSession(),
                m_pNamespace->GetNsHandle(),
                m_pNamespace->GetScope(),
                GetName(),
                m_pParsedQuery,
                m_pSink,
                m_pNamespace );

    if (CQueryEngine::invalid_query == nRes)
        hr = WBEM_E_INVALID_QUERY;
    else if(0 == nRes)
        hr = WBEM_S_NO_ERROR;

    return hr;
}

void CMergerDynReq_Static_GetInstances ::DumpError()
{
    // none
}

//
// CWmiMergerRequestMgr implementation.
//

CWmiMergerRequestMgr::CWmiMergerRequestMgr( CWmiMerger* pMerger )
:    m_pMerger( pMerger ),
    m_HierarchyArray(),
    m_dwNumRequests( 0 ),
    m_dwMinLevel( 0xFFFFFFFF ),
    m_dwMaxLevel( 0 )
{
}

CWmiMergerRequestMgr::~CWmiMergerRequestMgr()
{
    Clear();
}

// Clears the manager of ALL arrays
HRESULT CWmiMergerRequestMgr::Clear( void )
{
    for ( int x = 0; x < m_HierarchyArray.Size(); x++ )
    {
        CSortedUniquePointerArray<CMergerDynReq>* pArray =
            (CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[x];

        if ( NULL != pArray )
        {
            delete pArray;
            m_HierarchyArray.SetAt( x, NULL );
        }
    }

    // Set to 0
    m_dwNumRequests = 0L;

    return WBEM_S_NO_ERROR;
}

// Adds a new request to the manager
HRESULT CWmiMergerRequestMgr::AddRequest( CMergerDynReq* pReq, DWORD dwLevel )
{
    // Locate the array for the level.  If we need to allocate one, do so.
    HRESULT    hr = WBEM_S_NO_ERROR;
    CSortedUniquePointerArray<CMergerDynReq>* pArray = NULL;

    // Check first if we have built out to this level, then if so, do we have
    // an array for the level.
    if ( dwLevel >= m_HierarchyArray.Size() || NULL == m_HierarchyArray[dwLevel] )
    {
        pArray = new CSortedUniquePointerArray<CMergerDynReq>;    // SEC:REVIEWED 2002-03-22 : Needs EH

        if ( NULL != pArray )
        {
            // First, if we're not built out to the required size,
            // NULL out the elements from size to our level

            if ( dwLevel >= m_HierarchyArray.Size() )
            {
                for ( int x = m_HierarchyArray.Size(); SUCCEEDED( hr ) && x <= dwLevel; x++ )
                {
                    if ( m_HierarchyArray.Add( NULL ) != CFlexArray::no_error )
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                    else
                    {
                        if ( dwLevel < m_dwMinLevel )
                        {
                            m_dwMinLevel = dwLevel;
                        }
                        else if ( dwLevel > m_dwMaxLevel )
                        {
                            m_dwMaxLevel = dwLevel;
                        }

                    }
                }    // FOR enum elements

            }    // IF dwLevel >= Array size

            if ( SUCCEEDED( hr ) )
            {
                m_HierarchyArray.SetAt( dwLevel, pArray );
            }

            if ( FAILED( hr ) )
            {
                delete pArray;
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        // This should NEVER be NULL
        pArray = (CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[dwLevel];

        _DBG_ASSERT( pArray != NULL );

        if ( NULL == pArray )
        {
            hr = WBEM_E_FAILED;
        }
    }

    // Finally, add the request to the array.  Subsequent worker threads
    // will locate requests and execute them.

    if ( SUCCEEDED( hr ) )
    {
        if ( pArray->Insert( pReq ) < 0 )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            ++m_dwNumRequests;
        }
    }

    return hr;

}

DWORD CWmiMergerRequestMgr::GetNumRequestsAtLevel( DWORD dwLevel )
{
    if ( dwLevel >= m_HierarchyArray.Size() ) return 0;
    CSortedUniquePointerArray<CMergerDynReq>* pArray = (CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[dwLevel];
    if ( NULL == pArray ) return 0;
    return pArray->GetSize();
}

//
//  this function removes the first request in the array of the requests 
//  for a given level of the hierarchy
// 
///////////////////////////////////////////////////////////////////////////////////

BOOL CWmiMergerRequestMgr::GetRequestAtLevel( DWORD dwLevel, wmilib::auto_ptr<CMergerReq> & pReq )
{
    if ( dwLevel >= m_HierarchyArray.Size() ) return FALSE;
    CSortedUniquePointerArray<CMergerDynReq>* pArray = (CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[dwLevel];
    if ( NULL == pArray ) return FALSE;
    if (0 == pArray->GetSize()) return FALSE;
    CMergerDynReq * pRealReq = NULL;
    pArray->RemoveAt(0,&pRealReq);
    pReq.reset(pRealReq);
    return TRUE;
}


// Removes a request from the manager and returns it to the caller.
// The caller is responsible for cleaning up the request.

HRESULT CWmiMergerRequestMgr::RemoveRequest( DWORD dwLevel, LPCWSTR pwszName, 
                                             wmilib::auto_ptr<CMergerReq> & pReq )
{
    // Locate the array for the level. 
    HRESULT    hr = WBEM_S_NO_ERROR;

    if ( dwLevel < m_HierarchyArray.Size() )
    {
        CSortedUniquePointerArray<CMergerDynReq>* pArray =
            (CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[dwLevel];

        // pArray is NULL if the class hierarchy combine static with dynamic
        
        if ( NULL != pArray )
        {
            int    nIndex;

            // Under certain race conditions, another thread
            // can actually remove a request before one thread
            // processes it, so if it's not there, the assumption
            // is that it was already removed.
            pReq.reset(pArray->Find( pwszName, &nIndex ));  // SEC:REVIEWED 2002-03-22 : Should have EH in case <ppReq> is NULL

            if ( NULL != pReq.get() )
            {
                // Now remove the element from the array, the caller
                // is responsible for deleting it
                pArray->RemoveAtNoDelete( nIndex );
                --m_dwNumRequests;
            }
            else
            {
                hr = WBEM_E_NOT_FOUND;
            }
        }
        else
        {
            hr = WBEM_E_FAILED;
        }
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

HRESULT CWmiMergerRequestMgr::GetTopmostParentReqName( WString& wsClassName )
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    if ( m_dwNumRequests > 0 )
    {
        for ( int x = 0; WBEM_E_NOT_FOUND == hr && x < m_HierarchyArray.Size(); x++ )
        {
            CSortedUniquePointerArray<CMergerDynReq>* pArray =
                (CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[x];

            // The Array must exist and have elements
            if ( NULL != pArray && pArray->GetSize() > 0 )
            {
                // Get the class name from the first request
                try
                {
                    wsClassName = pArray->GetAt( 0 )->GetName();
                    hr = WBEM_S_NO_ERROR;
                }
                catch(...)
                {
                    ExceptionCounter c;                
                    hr = WBEM_E_OUT_OF_MEMORY;
                }
            }

        }    // For enum arrays
    }

    return hr;
}

BOOL CWmiMergerRequestMgr::HasSingleStaticRequest( void )
{
    BOOL    fRet = FALSE;

    if ( 1 == m_dwNumRequests )
    {
        HRESULT    hr = WBEM_E_NOT_FOUND;

        for ( int x = 0; WBEM_E_NOT_FOUND == hr && x < m_HierarchyArray.Size(); x++ )
        {
            CSortedUniquePointerArray<CMergerDynReq>* pArray =
                (CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[x];

            // The Array must exist and have elements
            if ( NULL != pArray && pArray->GetSize() > 0 )
            {
                // Get the class name from the first request
                fRet = pArray->GetAt(0)->IsStatic();
                hr = WBEM_S_NO_ERROR;
            }

        }    // For enum arrays

    }    // Must be 1 and only 1 request

    return fRet;
}

#ifdef __DEBUG_MERGER_THROTTLING
void CWmiMergerRequestMgr::DumpRequestHierarchy( void )
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    if ( m_dwNumRequests > 0 )
    {
        for ( int x = 0; FAILED( hr ) && x < m_HierarchyArray.Size(); x++ )
        {
            CSortedUniquePointerArray<CMergerDynReq>* pArray =
                (CSortedUniquePointerArray<CMergerDynReq>*) m_HierarchyArray[x];

            // The Array must exist and have elements
            if ( NULL != pArray && pArray->GetSize() > 0 )
            {
                for ( int y = 0; y < pArray->GetSize(); y++ )
                {
                   DbgPrintfA(0,"Merger Request, Level %d, Class Name: %s\n", x, pArray->GetAt(y)->GetName() );
                }
            }

        }    // For enum arrays
    }

}
#else
void CWmiMergerRequestMgr::DumpRequestHierarchy( void )
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\intprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    INTPROV.H

Abstract:

History:

	raymcc        06-May-97       Created.
	raymcc        17-Jul-97       NTLM authentication support

--*/

#ifndef _INTPROV_H_
#define _INTPROV_H_

#ifndef PPVOID
#define PPVOID void **
#endif

// generally useful utilities

BSTR GetBSTR(char * pInput);
HRESULT GetDateTime(FILETIME * ft, bool bLocalTime, LPWSTR pBuff);

class CIntProv : public IWbemServices, public IWbemProviderInit
    {
    protected:
        ULONG              m_cRef;         //Object reference count
        IWbemServices *  m_pNamespace;
        LIST_ENTRY m_Entry;        
     public:
        CIntProv();
        ~CIntProv(void);

//		operator struct IUnknown * (){return (IWbemServices*)this;};
        //Non-delegating object IUnknown

        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

                //IWbemProviderInit

        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        );

		SCODE CreateWMISetting(IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx);
		SCODE CreateWMIElementSetting(IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx);

		SCODE SaveWMISetting(IWbemClassObject FAR*);
		SCODE CreateInstance(LPWSTR pwcClassName, IWbemClassObject FAR* FAR* ppObj, IWbemContext  *pCtx);
		SCODE GetRegStrProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
															CWbemObject * pObj);
		SCODE GetRegUINTProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
															CWbemObject * pObj);
		SCODE PutRegStrProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
															CWbemObject * pObj);
		SCODE PutRegUINTProp(Registry & reg, LPTSTR pRegValueName, LPWSTR pwsPropName, 
															CWbemObject * pObj);
        SCODE ReadAutoMofs(CWbemObject * pObj);
        SCODE ReadLastBackup(Registry & reg, CWbemObject * pObj);

        //IWbemServices  

		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\mergerreq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MERGERREQ.H

Abstract:

    Definitions of Merger Request classes

History:

    28-Feb-01   sanjes    Created.

--*/

#ifndef _MERGERREQ_H_
#define _MERGERREQ_H_

// forward class definitions
class CWmiMerger;
class CWmiMergerRecord;

//
// Merger Requests
//
// In previous releases, when the query engine analyzed a query, it enqueued
// a large number of requests, one for each dynamically provided class.  Each
// of these could be handled on a separate thread, which could cause a
// significant thread explosion as each request was handed to a separate thread.
//
// In order to better control the threads, we are using the merger to perform
// a more intelligent analysis of a query and then spin off threads only when
// we reach throttling conditions.  Now, instead of enqueing a large number of
// requests, the merger maintains hierarchical information regarding parents and
// their children in its record classes, and stores necessary requests in a
// manager which doles out requests as we need them.
//
// The idea is, is that we will spin off a single request which will begin
// executing the first topmost request, say "ClassA:.  As we execute the request
// for instances of "ClassA" if the request is throttled in the merger, we check
// if we have submitted a request to handle children of "ClassA".  If not, then
// prior to throttling, we will schedule a "Children of ClassA" request.  This
// request will use the merger record for "ClassA" to determine what child classes
// there are for "ClassA", and then we will walk the child classes, pulling the
// appropriate requests from the merger request manager.
//
// As we process each request, it in turn may be throttled, at which point we will
// spin off another child request.  In this way, we limit the number of threads
// required to service the query to at most one per level of a hierarchy.  In each
// case, once all children are processed, we will return the thread back to the
// threadpool.
//
// Note that we are absolutely reliant on the threadpool recognizing that these
// requests are all dependent requests and ensuring that they WILL be processed.
//


//
// CMergerReq
//
// Base class for all merger requests.
//

class CMergerReq : public CNamespaceReq
{
private:

public:
    CMergerReq( CWbemNamespace* pNamespace, IWbemObjectSink* pHandler,
              IWbemContext* pContext)
              : CNamespaceReq( pNamespace, pHandler, pContext, true )
    {};

    ~CMergerReq() {};

    virtual BOOL IsStatic( void ) { return FALSE; }

    virtual LPCWSTR GetName( void )    { return L""; }
};

//
// Class Request Base Class
//

class CMergerClassReq : public CMergerReq
{
protected:
    CWmiMerger*            m_pMerger;
    CWmiMergerRecord*    m_pParentRecord;
    CBasicObjectSink*    m_pSink;


public:
    CMergerClassReq( CWmiMerger* pMerger, CWmiMergerRecord* pParentRecord,
                CWbemNamespace* pNamespace, CBasicObjectSink* pHandler, 
                IWbemContext* pContext);

    ~CMergerClassReq();

    virtual BOOL IsLongRunning() {return TRUE;}

    void DumpError();

};

//
// Parent Class Request
//

class CMergerParentReq : public CMergerClassReq
{
public:
    CMergerParentReq( CWmiMerger* pMerger, CWmiMergerRecord* pParentRecord,
                CWbemNamespace* pNamespace, CBasicObjectSink* pHandler, 
                IWbemContext* pContext)
                : CMergerClassReq( pMerger, pParentRecord, pNamespace, pHandler, pContext )
    {};

    ~CMergerParentReq() {};

    HRESULT Execute ();
    LPCWSTR GetReqInfo(){ return L"MergerParentReq"; };
};

//
// Child Class Request
//

class CMergerChildReq : public CMergerClassReq
{

public:
    CMergerChildReq( CWmiMerger* pMerger, CWmiMergerRecord* pParentRecord,
                CWbemNamespace* pNamespace, CBasicObjectSink* pHandler, 
                IWbemContext* pContext)
                : CMergerClassReq( pMerger, pParentRecord, pNamespace, pHandler, pContext )
    {};

    ~CMergerChildReq() {};

    HRESULT Execute ();
    LPCWSTR GetReqInfo(){ return L"MergerChildReq"; };
};


// Base class for Dynamic requests
class CMergerDynReq : public CMergerReq
{
private:
    CVar    m_varClassName;

public:
    CMergerDynReq(CWbemObject* pClassDef, CWbemNamespace* pNamespace, IWbemObjectSink* pHandler,
              IWbemContext* pContext);

    ~CMergerDynReq() {};

    LPCWSTR GetName( void )    { return m_varClassName.GetLPWSTR(); }
};

//
// CMergerDynReq_DynAux_GetInstances
//
// This request processes CreateInstanceEnum calls to providers.
//

class CMergerDynReq_DynAux_GetInstances : public CMergerDynReq
{
private:

    CWbemObject *m_pClassDef ;
    IWbemContext *m_pCtx ;
    long m_lFlags ;
    CBasicObjectSink *m_pSink ;

public:

    CMergerDynReq_DynAux_GetInstances (CWbemNamespace *pNamespace,
                                       CWbemObject *pClassDef,
                                       long lFlags,
                                       IWbemContext *pCtx,
                                       CBasicObjectSink *pSink):    
        CMergerDynReq (pClassDef,pNamespace,pSink,pCtx),
        m_pClassDef(pClassDef), 
        m_pCtx(pCtx), 
        m_pSink(pSink),
        m_lFlags(lFlags)
    {
        if (m_pClassDef) m_pClassDef->AddRef () ; 
        if (m_pCtx) m_pCtx->AddRef () ;
        if (m_pSink) m_pSink->AddRef () ;
    }

    ~CMergerDynReq_DynAux_GetInstances ()
    {
        if (m_pClassDef) m_pClassDef->Release () ; 
        if (m_pCtx) m_pCtx->Release () ;
        if (m_pSink) m_pSink->Release () ;
    }

    HRESULT Execute ();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
    LPCWSTR GetReqInfo()
    {
        _variant_t varClass;
        if (FAILED(m_pClassDef->Get(L"__CLASS",0,&varClass,0,0))) return L"";
        if (VT_BSTR == V_VT(&varClass)) 
        {
            StringCchCopyW(CNamespaceReq::s_DumpBuffer,LENGTH_OF(CNamespaceReq::s_DumpBuffer)-1,V_BSTR(&varClass));
            return CNamespaceReq::s_DumpBuffer;
        }
        else return L""; 
    };    
};

//
// CMergerDynReq_DynAux_ExecQueryAsync
//
// This request processes ExecQuery calls to providers.
//

class CMergerDynReq_DynAux_ExecQueryAsync : public CMergerDynReq
{
private:
    CWbemObject *m_pClassDef ;
    BSTR m_Query ;
    BSTR m_QueryFormat ;
    IWbemContext *m_pCtx ;
    long m_lFlags ;
    CBasicObjectSink *m_pSink ;
    HRESULT m_Result ;
public:

    CMergerDynReq_DynAux_ExecQueryAsync(CWbemNamespace *pNamespace,
                                        CWbemObject *pClassDef,
                                        long lFlags,
                                        LPCWSTR Query,
                                        LPCWSTR QueryFormat,
                                        IWbemContext *pCtx,
                                        CBasicObjectSink *pSink):
        CMergerDynReq(pClassDef,
                      pNamespace, 
                      pSink, 
                      pCtx),
        m_pClassDef(pClassDef), 
        m_pCtx(pCtx), 
        m_pSink(pSink),
        m_lFlags(lFlags),
        m_Query(NULL),
        m_QueryFormat(NULL),
        m_Result (S_OK)
    {
        if (m_pClassDef) m_pClassDef->AddRef () ;
        if (m_pCtx) m_pCtx->AddRef () ;
        if (m_pSink) m_pSink->AddRef () ;


        if (Query)
        {
            m_Query = SysAllocString ( Query ) ;
            if ( m_Query == NULL )
            {
                m_Result = WBEM_E_OUT_OF_MEMORY ;
            }
        }

        if (QueryFormat)
        {
            m_QueryFormat = SysAllocString ( QueryFormat ) ;
            if ( m_QueryFormat == NULL )
            {
                m_Result = WBEM_E_OUT_OF_MEMORY ;
            }
        }
    }

    HRESULT Initialize () 
    {
        return m_Result ;
    }

    ~CMergerDynReq_DynAux_ExecQueryAsync ()
    {
        if (m_pClassDef) m_pClassDef->Release();
        if (m_pCtx)m_pCtx->Release();
        if (m_pSink) m_pSink->Release();
        SysFreeString(m_Query);
        SysFreeString(m_QueryFormat);
    }

    HRESULT Execute ();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
    LPCWSTR GetReqInfo(){ return m_Query; };     
};

//
// CMergerDynReq_Static_GetInstances
//
// This request processes CreateInstanceEnum calls to the repository.
//

class CMergerDynReq_Static_GetInstances : public CMergerDynReq
{
private:

    CWbemObject *m_pClassDef ;
    IWbemContext *m_pCtx ;
    long m_lFlags ;
    CBasicObjectSink *m_pSink ;
    QL_LEVEL_1_RPN_EXPRESSION* m_pParsedQuery;

public:

    CMergerDynReq_Static_GetInstances (CWbemNamespace *pNamespace ,
                                       CWbemObject *pClassDef ,
                                       long lFlags ,
                                       IWbemContext *pCtx ,
                                       CBasicObjectSink *pSink ,
                                       QL_LEVEL_1_RPN_EXPRESSION* pParsedQuery);
    
    ~CMergerDynReq_Static_GetInstances();
    HRESULT Execute();
    virtual BOOL IsLongRunning() {return TRUE;}
    void DumpError();
    BOOL IsStatic( void ) { return TRUE; }
    LPCWSTR GetReqInfo()
    {
        _variant_t varClass;
        if (FAILED(m_pClassDef->Get(L"__CLASS",0,&varClass,0,0))) return L"";
        if (VT_BSTR == V_VT(&varClass)) 
        {
            StringCchCopyW(CNamespaceReq::s_DumpBuffer,LENGTH_OF(CNamespaceReq::s_DumpBuffer)-1,V_BSTR(&varClass));
            return CNamespaceReq::s_DumpBuffer;
        }
        else return L""; 
    };
};


//
// CWmiMergerRequestMgr
//
// Manager class for Merger Requests.  It keeps an array of sorted arrays
// corresponding to the actual requests we will be performing.  The sorted
// arrays contain merger requests for handling calls to the various
// dynamic instance providers.
//

class CWmiMergerRequestMgr
{
    CWmiMerger*        m_pMerger;
    CFlexArray        m_HierarchyArray;
    DWORD            m_dwNumRequests;
    DWORD            m_dwMinLevel;
    DWORD            m_dwMaxLevel;
    DWORD            m_dwLevelMask;
    DWORD*            m_pdwLevelMask;

public:
    CWmiMergerRequestMgr( CWmiMerger* pMerger );
    ~CWmiMergerRequestMgr();

    HRESULT AddRequest( CMergerDynReq* pReq, DWORD dwLevel );
    HRESULT RemoveRequest( DWORD dwLevel, LPCWSTR pwszName, 
                           wmilib::auto_ptr<CMergerReq> & pReq );
    HRESULT GetTopmostParentReqName( WString& wsClassName );
    BOOL    HasSingleStaticRequest( void );
    HRESULT Clear();
    void DumpRequestHierarchy( void );

    DWORD GetNumRequests( void ) { return m_dwNumRequests; }
    DWORD GetNumRequestsAtLevel( DWORD dwLevel );
    BOOL GetRequestAtLevel( DWORD dwLevel, wmilib::auto_ptr<CMergerReq> & pReq );
};

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\mergerthrottling.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MERGERTHROTTLING.CPP

Abstract:

    CMergerThrottling clas

History:

	30-Nov-00   sanjes    Created.

--*/


#include "precomp.h"

#pragma warning (disable : 4786)
#include <wbemcore.h>
#include <map>
#include <vector>
#include <genutils.h>
#include <oahelp.inl>
#include <wqllex.h>
#include "wmimerger.h"
#include "mergerthrottling.h"

static	long	g_lNumMergers = 0L;

//***************************************************************************
//
//***************************************************************************
//
CMergerThrottling::CMergerThrottling( void )
:	m_hParentThrottlingEvent( NULL ), m_hChildThrottlingEvent( NULL ), m_dwNumChildObjects( 0 ),
	m_dwNumParentObjects( 0 ), m_dwNumThrottledThreads( 0 ), m_bParentThrottled( false ),
	m_bChildThrottled( true ), m_bChildDone( false ), m_bParentDone( false ),
	m_dwThrottlingThreshold( 0 ), m_dwReleaseThreshold( 0 ), m_dwLastParentPing( 0 ),
	m_dwLastChildPing( 0 ), m_dwProviderDeliveryTimeout( 0xFFFFFFFF ), m_dwBatchingThreshold( 0 ),
	m_cs()
{
}

//***************************************************************************
//
//***************************************************************************
//
CMergerThrottling::~CMergerThrottling( void )
{
	_DBG_ASSERT( m_dwNumChildObjects == 0 && m_dwNumParentObjects == 0 );

	if ( NULL != m_hParentThrottlingEvent )
	{
		CloseHandle( m_hParentThrottlingEvent );
	}

	if ( NULL != m_hChildThrottlingEvent )
	{
		CloseHandle( m_hChildThrottlingEvent );
	}

}


// Two step initialization.  This retrieves values from registry to configure the
// behavior of our throttling mechanisms
HRESULT	CMergerThrottling::Initialize( void )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	ConfigMgr::GetMergerThresholdValues( &m_dwThrottlingThreshold, &m_dwReleaseThreshold,
										&m_dwBatchingThreshold );

	// Hold off on this until we work our way through
//	m_dwProviderDeliveryTimeout = ConfigMgr::GetProviderDeliveryTimeout();

	return hr;
}

// Call this function to perform proper throttling based on our registry
// configured values.
HRESULT CMergerThrottling::Throttle( bool bParent, CWmiMergerRecord* pMergerRecord )
{

	bool	bContinue = true;
	bool	bTimedOut = false;
	HRESULT	hr = WBEM_S_NO_ERROR;

	while ( bContinue && SUCCEEDED( hr ) )
	{
		// Scoped for proper cleanup if anything bad happens
		CCheckedInCritSec	ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

		DWORD	dwAdjust = 0L;
		DWORD	dwWait = 0L;

		// If the timed out flag is set, we need to check if we are
		// really timed out
		if ( bTimedOut )
		{
			bTimedOut = VerifyTimeout( pMergerRecord->GetWmiMerger()->GetLastDeliveryTime(),
						pMergerRecord->GetWmiMerger()->NumArbitratorThrottling(), &dwAdjust );
		}

		if ( bTimedOut ) 
		{
			hr = WBEM_E_PROVIDER_TIMED_OUT;
			continue;
		}
		

		HANDLE hEvent = ( bParent ? m_hParentThrottlingEvent : m_hChildThrottlingEvent );

		bool	bThrottle = ShouldThrottle( bParent );

		// These should NEVER both be TRUE
		_DBG_ASSERT( !( m_bParentThrottled && m_bChildThrottled ) );

		if ( m_bParentThrottled && m_bChildThrottled )
		{
			hr = WBEM_E_FAILED;
		    continue;
		}
		
		if ( bThrottle )
		{
			hr = PrepareThrottle( bParent, &hEvent );
			if (FAILED(hr)) continue;

			dwWait = m_dwProviderDeliveryTimeout - dwAdjust;
		}

		// Since we will wait if we choose to throttle, we should do
		// this OUTSIDE of our critical section

		ics.Leave();

		// Throttle only if appropriate
		if ( !bThrottle ) 
		{
    		bContinue = false;
    		continue;
		}


		// If we are about to throttle a parent, then we need to ensure a
		// child delivery request is scheduled
		if ( bParent )
		{
			hr = pMergerRecord->GetWmiMerger()->ScheduleMergerChildRequest( pMergerRecord );
     		if (FAILED(hr)) continue;			
		}

		InterlockedIncrement( (long*) &m_dwNumThrottledThreads );

#ifdef __DEBUG_MERGER_THROTTLING
		DbgPrintfA(0,"Thread 0x%x throttled in merger %p for 0x%x ms.\nParent Objects: %d, Child Objects: %d, Num Throttled Threads: %d\n", 
		             GetCurrentThreadId(),
			         pMergerRecord->GetWmiMerger(), 
			         dwWait, 
			         m_dwNumParentObjects, 
			         m_dwNumChildObjects, 
			         m_dwNumThrottledThreads );
#endif

		DEBUGTRACE((LOG_WBEMCORE, 
		            "Thread 0x%x throttled in merger for 0x%x ms.\n"
		            "Parent Objects: %d, Child Objects: %d, Num Throttled Threads: %d\n", 
		            GetCurrentThreadId(), dwWait, 
		            m_dwNumParentObjects, m_dwNumChildObjects, m_dwNumThrottledThreads));

		DWORD dwRet = CCoreQueue::QueueWaitForSingleObject( hEvent, dwWait );

		DEBUGTRACE((LOG_WBEMCORE, "Thread 0x%x woken up in merger.\n", 
			        GetCurrentThreadId() ) );

#ifdef __DEBUG_MERGER_THROTTLING
		DbgPrintfA(0, L"Thread 0x%x woken up in merger %p.\n", 
		              GetCurrentThreadId(), 
		              pMergerRecord->GetWmiMerger());
#endif

		InterlockedDecrement( (long*) &m_dwNumThrottledThreads );

		// Check for error return codes.
		if ( dwRet == WAIT_OBJECT_0 ) break;
				
		if ( dwRet == WAIT_TIMEOUT )
		{
			bTimedOut = true;
		}
		else
		{
			hr = WBEM_E_FAILED;
		}
	}	// WHILE check for throttling

	return hr;
}

// Call this to release any actual throttled threads.
bool CMergerThrottling::ReleaseThrottle( bool bForce /* = false */ )
{
	bool	bRelease = bForce;

	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

	if ( !bForce && ( m_bParentThrottled || m_bChildThrottled ) )
	{
		// These should NEVER both be TRUE
		_DBG_ASSERT( !( m_bParentThrottled && m_bChildThrottled ) );

		if ( !( m_bParentThrottled && m_bChildThrottled ) )
		{
			if ( m_bParentThrottled )
			{
				// We only release if we have exceeded the threshold.
				if ( m_dwNumParentObjects > m_dwNumChildObjects )
				{
					DWORD dwDiff = m_dwNumParentObjects - m_dwNumChildObjects;
					bRelease = ( dwDiff < m_dwReleaseThreshold );
				}
				else
				{
					// Always release if we are not greater than number of
					// child objects
					bRelease = true;
				}

			}
			else if ( m_bChildThrottled )
			{
				// We only release if we have exceeded the threshold.
				if ( m_dwNumChildObjects > m_dwNumParentObjects )
				{
					DWORD dwDiff = m_dwNumChildObjects - m_dwNumParentObjects;
					bRelease = ( dwDiff < m_dwReleaseThreshold );
				}
				else
				{
					// Always release if we are not greater than number of
					// child objects
					bRelease = true;
				}

			}

		}	// Only if NOT both
		else
		{
			// looks like both are throttled - we shouldn't be here, but go ahead and
			// release anyway
			bRelease = true;
		}


	}	// IF not bForce and something is throttled

	if ( bRelease )
	{
		m_bParentThrottled = false;
		m_bChildThrottled = false;
		
		// Should release everyone
		if ( NULL != m_hParentThrottlingEvent )
		{
			SetEvent( m_hParentThrottlingEvent );
		}

		// Should release everyone
		if ( NULL != m_hChildThrottlingEvent )
		{
			SetEvent( m_hChildThrottlingEvent );
		}

	}	// IF bRelease

	return bRelease;
}

// Called to log the fact that children instances are done
void CMergerThrottling::SetChildrenDone( void )
{
	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( &m_cs );  // SEC:REVIEWED 2002-03-22 : Assumes entry

	// Child is done - we should release throttling as well
	m_bChildDone = true;
	ReleaseThrottle( true );
}

// Called to log the fact that parent instances are done
void CMergerThrottling::SetParentDone( void )
{
	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( &m_cs ); // SEC:REVIEWED 2002-03-22 : Assumes entry

	// Parent is done - we should release throttling as well
	m_bParentDone = true;
	ReleaseThrottle( true );
}

// Causes us to clear any throttling we are doing
void CMergerThrottling::Cancel( void )
{
	// Scoped for proper cleanup if anything bad happens
    CCheckedInCritSec	ics( &m_cs ); // SEC:REVIEWED 2002-03-22 : Assumes entry

	// Everything is just over with - release the throttle as well
	m_bChildDone = true;
	m_bParentDone = true;

	// No point in tracking these anymore.
	m_dwNumChildObjects = 0;
	m_dwNumParentObjects = 0;

	ReleaseThrottle( true );
}

// Helper function to check if we should throttle
bool CMergerThrottling::ShouldThrottle( bool bParent )
{
	bool	bThrottle = false;

	if ( bParent )
	{
		// If the child is done, no point in throttling
		if ( !m_bChildDone )
		{

			// If for some reason parent objects are coming in on multiple threads,
			// we *could* theoretically have to throttle multiple threads.  If we're
			// not already throttling, we should check if we need to.

			if ( !m_bParentThrottled )
			{
				// We only throttle if we have exceeded the threshold.
				if ( m_dwNumParentObjects > m_dwNumChildObjects )
				{
					DWORD dwDiff = m_dwNumParentObjects - m_dwNumChildObjects;
					bThrottle = ( dwDiff > m_dwThrottlingThreshold );
					m_bParentThrottled = bThrottle;
				}
			}
			else
			{
				bThrottle = true;;
			}

		}	// IF !m_bChildDone

	}
	else
	{
		// No point in continuing if the parent is done
		if ( !m_bParentDone )
		{
			// More likely that multiple child threads could be coming in (e.g. multiple
			// classes inheriting from a base class).

			if ( !m_bChildThrottled )
			{
				// We only throttle if we have exceeded the threshold.
				if ( m_dwNumChildObjects > m_dwNumParentObjects )
				{
					DWORD dwDiff = m_dwNumChildObjects - m_dwNumParentObjects;
					bThrottle = ( dwDiff > m_dwThrottlingThreshold );
					m_bChildThrottled = bThrottle;
				}
			}
			else
			{
				bThrottle = true;
			}

		}	// IF !m_bParentDone

	}

	return bThrottle;
}

// Helper function to prepare us for throttling
HRESULT CMergerThrottling::PrepareThrottle( bool bParent, HANDLE* phEvent )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Create the event if we have to, otherwise reset it
	if ( NULL == *phEvent )
	{
		// Creates in an unsignalled state
		*phEvent = CreateEvent( NULL, TRUE, FALSE, NULL );  // SEC:REVIEWED 2002-03-22 : OK

		if ( NULL == *phEvent )
		{
			hr = WBEM_E_OUT_OF_MEMORY;
		}
		else if ( bParent )
		{
			m_hParentThrottlingEvent = *phEvent;
		}
		else
		{
			m_hChildThrottlingEvent = *phEvent;
		}

	}
	else
	{
		// Make sure the event is reset
		BOOL	fSuccess = ResetEvent( *phEvent );

		// What to do here?
		_DBG_ASSERT( fSuccess );
		if ( !fSuccess )
		{
			hr = WBEM_E_FAILED;
		}
	}

	return hr;
}

// Helper function to verify if we timed out.  For example, we may have timed out on throttling
// but, actually be receiving (albeit slowly) objects from a child or parent.  Since we are getting
// stuff, we aren't really timed out, but we should adjust our wait time based on the difference
// since the last ping.

bool CMergerThrottling::VerifyTimeout( DWORD dwLastTick, long lNumArbThrottledThreads, DWORD* pdwAdjust )
{
	// We only do this of no threads are throttled in the arbitrator - since we may actually
	// just be slow.  So if there are throttled threads, we just return that we are not timed
	//out

	_DBG_ASSERT( lNumArbThrottledThreads >= 0 );
	if ( lNumArbThrottledThreads > 0 )
	{
		return false;
	}

	DWORD	dwCurrent = GetTickCount();

	// We must deal with the fact that a rollover *can* occur
	if ( dwCurrent >= dwLastTick )
	{
		*pdwAdjust = dwCurrent - dwLastTick;
	}
	else
	{
		// Accounts for rollover - 0xFFFFFFFF minus the last tick, plus the current
		// plus 1 will give us the number of elapsed ticks
		*pdwAdjust = dwCurrent + ( 0xFFFFFFFF - dwLastTick );
	}

	// If the difference is greater
	return ( *pdwAdjust > m_dwProviderDeliveryTimeout );
}

// Sets the proper ping variable and sends it to the main merger
DWORD CMergerThrottling::Ping( bool bParent, CWmiMerger* pWmiMerger )
{
	DWORD	dwTick = GetTickCount();

	if ( bParent )
	{
		m_dwLastParentPing = dwTick;
	}
	else
	{
		m_dwLastChildPing = dwTick;
	}

	// Sets the ping delivery
	pWmiMerger->PingDelivery( dwTick );

	return dwTick;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\mergerthrottling.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MERGERTHROTTLING.H

Abstract:

    CMergerThrottling clas

History:

	30-Nov-00   sanjes    Created.

--*/

#ifndef _MERGERTHROTTLING_H_
#define _MERGERTHROTTLING_H_

// Enables debug messages for additional info.
#ifdef DBG
//#define __DEBUG_MERGER_THROTTLING
#endif

// Defaults - can be overridden from the registry
#define	DEFAULT_THROTTLE_THRESHOLD			10
#define	DEFAULT_THROTTLE_RELEASE_THRESHOLD	4

// Forward Class Definitions
class CInternalMerger;
class CWmiMergerRecord;

//	This class encapsulates the throttling behavior which will be used by the internal
//	merger in order to control delivery of parent and child objects.

class CMergerThrottling
{
	// Following members are used for throttling incoming objects so that our
	// parent and child objects don't get wildly out of control.  Note that we
	// use separate throttling events, since the decision to throttle is made in
	// a critsec, but the actual throttling occurs outside.  This can have the
	// unpleasant side effect of a race condition in which for example, the parent
	// decides to throttle, steps out of the critsec, and a context switch occurs,
	// in which the child gets a large number of objects, releases the throttle, but
	// then causes child throttling to occur, resetting the event.  If the parent
	// thread switches in at this point, we're hosed, since we will now wait on the
	// parent and the child.

	HANDLE	m_hParentThrottlingEvent;
	HANDLE	m_hChildThrottlingEvent;

	DWORD	m_dwNumChildObjects;
	DWORD	m_dwNumParentObjects;
	DWORD	m_dwNumThrottledThreads;

	// Contains the time of the last ping from a parent or child.
	// Used to calculate whether or not we timeout
	DWORD	m_dwLastParentPing;
	DWORD	m_dwLastChildPing;

	// These should NEVER both be TRUE
	bool	m_bParentThrottled;
	bool	m_bChildThrottled;

	// Stop us from throttling if one side or the other is done
	bool	m_bParentDone;
	bool	m_bChildDone;

	// This controls the point where we determine that we need to perform throttling
	// Once parent or children are > m_dwThrottlingThreshold objects apart, one or the
	// other will be throttled
	DWORD	m_dwThrottlingThreshold;

	// This controls the threshold where we will release currently throttled threads
	// Once we are throttled, we will remain throttled until parent or children are <
	// m_dwReleaseThreshold objects out of sync with each other.
	DWORD	m_dwReleaseThreshold;

	// This controls the amount of memory we will allow Indicates to process before
	// forcing them to send objects further down the line
	DWORD	m_dwBatchingThreshold;

	// This controls the timeout value we wait for.  If we timeout and a provider has
	// not pinged us in the specified timeout, then we will cancel the merger with
	// a provider timed out error.
	DWORD m_dwProviderDeliveryTimeout;

	// We will expose this for other synchronization activities
	CCritSec	m_cs;

	// Helper functions to control throttling
	bool ShouldThrottle( bool bParent );
	HRESULT PrepareThrottle( bool bParent, HANDLE* phEvent );
	bool VerifyTimeout( DWORD dwLastTick, long lNumArbThrottledThreads, DWORD* pdwAdjust );

public:

	CMergerThrottling();
	~CMergerThrottling();

	// Two stage initialization
	HRESULT	Initialize( void );

	// Returns TRUE if throttling occurred
	HRESULT Throttle( bool bParent, CWmiMergerRecord* pMergerRecord );

	// Returns TRUE if we released throttled threads.
	bool ReleaseThrottle( bool bForce = false );

	// Informs us that we are in fact, done with Child and/or Parent
	void SetChildrenDone( void );
	void SetParentDone( void );
	void Cancel( void );

	// Helpers to control the number of current parent and child objects
	// which we will then use to make decisions as to whether or not
	// we should block a thread or not
	DWORD AdjustNumParentObjects( long lNumParentObjects )
		{ return ( m_dwNumParentObjects += lNumParentObjects ); }
	DWORD AdjustNumChildObjects( long lNumChildObjects )
		{ return ( m_dwNumChildObjects += lNumChildObjects ); }

	// Access to our critical section
	void Enter( void ) { m_cs.Enter(); }
	void Leave( void ) { m_cs.Leave(); }

	// Adjusts ping times
	DWORD Ping( bool bParent, CWmiMerger* pWmiMerger );

	CCritSec* GetCritSec( void ) { return &m_cs; }

	// Checks batch size against our limit
	bool IsCompleteBatch( long lBatchSize ) { return lBatchSize >= m_dwBatchingThreshold; }


};

#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\oldsec.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    OLDSEC.CPP

Abstract:

    contains various routines and classes used providing backward security support.

History:

    a-davj    02-sept-99  Created.

--*/

#include "precomp.h"
#include <wbemcore.h>
#include <oleauto.h>
#include <genutils.h>
#include <safearry.h>
#include <oahelp.inl>
#include "secure.h"
#include <flexarry.h>
#include <secure.h>
#include <objpath.h>
#include "oldsec.h"

//***************************************************************************
//
//  CreateTheInstance
//
//  Takes a class object, and a CCombined entry and creates an instance.
//
//  PARAMETERS:
///
//  ppObj           used to pass back the created instance
//  pClass          Class object used for spawning
//  pCombinedEntry  Has the combined values for all the aces which mach
//                  the user or group.
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CreateTheInstance(IWbemClassObject ** ppObj, IWbemClassObject * pClass,
                                             CCombinedAce * pCombinedEntry)
{

    if(ppObj == NULL || pCombinedEntry == NULL || pClass == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // spawn the instance

    SCODE sc = pClass->SpawnInstance(0, ppObj);
    if(FAILED(sc))
        return sc;
    CReleaseMe rm(*ppObj);       // we addref at end if all is well

    // populate the instance

    bool bEnabled=false, bEditSecurity=false, bExecMethods=false;

    DWORD dwMask = pCombinedEntry->m_dwDeny;
    if(dwMask == 0)
        dwMask = pCombinedEntry->m_dwAllow;

    if( (dwMask & WBEM_ENABLE) &&
        (dwMask & WBEM_REMOTE_ACCESS) &&
        (dwMask & WBEM_WRITE_PROVIDER) &&
        pCombinedEntry->m_dwAllow)
            bEnabled = true;

    if(dwMask & READ_CONTROL)
        bEditSecurity = true;

    if(dwMask & WBEM_METHOD_EXECUTE)
       bExecMethods = true;

    DWORD dwPermission = 0;     // start at read

    if(dwMask & WBEM_PARTIAL_WRITE_REP)
        dwPermission = 1;

    if(dwMask & WBEM_FULL_WRITE_REP)
        dwPermission = 2;

    VARIANT var;
    var.vt = VT_I4;

    var.lVal = dwPermission;
    sc = (*ppObj)->Put(L"Permissions", 0, &var, 0);

    var.vt = VT_BOOL;

    var.boolVal = (bEnabled) ? VARIANT_TRUE : VARIANT_FALSE;
    sc = (*ppObj)->Put(L"Enabled", 0, &var, 0);

    var.boolVal = (bEditSecurity) ? VARIANT_TRUE : VARIANT_FALSE;
    sc = (*ppObj)->Put(L"EditSecurity", 0, &var, 0);

    var.boolVal = (bExecMethods) ? VARIANT_TRUE : VARIANT_FALSE;
    sc = (*ppObj)->Put(L"ExecuteMethods", 0, &var, 0);

    // Get the account and domain info

    LPWSTR pwszAccount = NULL;
    LPWSTR pwszDomain = NULL;

    sc = pCombinedEntry->GetNames(pwszAccount, pwszDomain);
    if(FAILED(sc))
        return sc;

    CDeleteMe<WCHAR> dm1(pwszAccount);
    CDeleteMe<WCHAR> dm2(pwszDomain);

    var.vt = VT_BSTR;
    if(pwszAccount && wcslen(pwszAccount) > 0)       // SEC:REVIEWED 2002-03-22 : OK, <->GetNames() call assures valid strings>
    {
        BSTR bstr = SysAllocString(pwszAccount);   // SEC:REVIEWED 2002-03-22 : OK
        if(bstr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        var.bstrVal = bstr;
        sc = (*ppObj)->Put(L"Name", 0, &var, 0);
        SysFreeString(bstr);
    }
    if(pwszDomain && wcslen(pwszDomain))          // SEC:REVIEWED 2002-03-22 : OK
    {
        BSTR bstr = SysAllocString(pwszDomain);   // SEC:REVIEWED 2002-03-22 : OK
        if(bstr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        var.bstrVal = bstr;
        sc = (*ppObj)->Put(L"Authority", 0, &var, 0);
        SysFreeString(bstr);
    }
    (*ppObj)->AddRef();     // make up for the releaseme
    return S_OK;
}

//***************************************************************************
//
//  GetAceStylePath
//
//  Takes a parsed object path and converts it into "authority|name"
//  format.
//
//  PARAMETERS:
//
//  pOutput         parsed path object
//  pToBeDeleted    Set to newly allocated string.  Call must free if
//                  this routine return S_OK
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT GetAceStylePath(ParsedObjectPath* pOutput, LPWSTR *pToBeDeleted)
{
    LPWSTR pRet;
    int iLen;
    int iAuthLen = 0;
    int iNameLen = 0;
    KeyRef* pAuth;
    KeyRef* pName;

    if(pOutput == NULL || pToBeDeleted == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(wbem_wcsicmp(pOutput->m_pClass, L"__ntlmuser") &&
       wbem_wcsicmp(pOutput->m_pClass, L"__ntlmgroup"))
        return WBEM_E_INVALID_OBJECT_PATH;

    if(pOutput->m_bSingletonObj || pOutput->m_dwNumKeys < 1 ||
                                   pOutput->m_dwNumKeys > 2)
        return WBEM_E_INVALID_OBJECT_PATH;

    // The authority key is optional

    if(pOutput->m_dwNumKeys == 1)
    {
        pAuth = NULL;
        pName = pOutput->m_paKeys[0];

    }
    else
    {

        // Determine which order the keys are in

        pAuth = pOutput->m_paKeys[0];
        pName = pOutput->m_paKeys[1];
        if(wbem_wcsicmp(pAuth->m_pName, L"Authority"))
        {
            pAuth = pOutput->m_paKeys[1];
            pName = pOutput->m_paKeys[0];
        }
    }
    // do some more checking

    if((pAuth && wbem_wcsicmp(pAuth->m_pName, L"Authority")) ||
       wbem_wcsicmp(pName->m_pName, L"Name"))
        return WBEM_E_INVALID_OBJECT_PATH;

    if(pAuth && pAuth->m_vValue.vt == VT_BSTR && pAuth->m_vValue.bstrVal != 0)
        iAuthLen = wcslen(pAuth->m_vValue.bstrVal);   // SEC:REVIEWED 2002-03-22 : OK, prior logic assures NULL
    else
        iAuthLen = 1;               // assume a "."
    if(pName->m_vValue.vt == VT_BSTR && pName->m_vValue.bstrVal != 0)
        iNameLen = wcslen(pName->m_vValue.bstrVal);   // SEC:REVIEWED 2002-03-22 : OK, prior logic assures NULL

    if(iNameLen == 0 || iAuthLen == 0)
        return WBEM_E_INVALID_OBJECT_PATH;

    // allocate some memory

    iLen = 2 + iNameLen + iAuthLen;

    pRet = new WCHAR[iLen];
    if(pRet == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if(pAuth && pAuth->m_vValue.vt == VT_BSTR && pAuth->m_vValue.bstrVal != 0)
        StringCchCopyW(pRet, iLen, pAuth->m_vValue.bstrVal);
    else
        StringCchCopyW(pRet, iLen, L".");
    StringCchCatW(pRet, iLen, L"|");
    StringCchCatW(pRet, iLen, pName->m_vValue.bstrVal);
    *pToBeDeleted = pRet;
    return S_OK;

}

//***************************************************************************
//
//  CCombinedAce::CCombinedAce
//
//  Constructor.  Since there might be several ACEs for a single user or
//  group in the ACL, this structure is used to combine all the aces for a
//  sid into one.
//
//  PARAMETERS:
//
//  pwszName            User/group name.
//
//***************************************************************************

CCombinedAce::CCombinedAce(WCHAR *pwszName)
{
    m_dwAllow = 0;
    m_dwDeny = 0;
    m_BadAce = false;
    m_wcFullName =  NULL;
    if(pwszName)
    {
		DUP_STRING_NEW(m_wcFullName, pwszName);
    }
}

//***************************************************************************
//
//  CCombinedAce::AddToMasks
//
//  Since this class is used to combine possibly many ACEs into a single
//  entry, this is called each time an ACE needs to be "OR"ed in.
//
//  PARAMETERS:
//
//  pAce                Pointer to the ace to be combined.
//
//***************************************************************************

void CCombinedAce::AddToMasks(CBaseAce * pAce)
{
    if(pAce == NULL)
        return;

    // Only aces with the container inherit bit can
    // be translated back.

    if(pAce->GetFlags() != CONTAINER_INHERIT_ACE)
        m_BadAce = true;
    if(pAce->GetType() == ACCESS_ALLOWED_ACE_TYPE)
        m_dwAllow |= pAce->GetAccessMask();
    else
        m_dwDeny |= pAce->GetAccessMask();
    return;
}

//***************************************************************************
//
//  CCombinedAce::IsValidOldEntry
//
//  Checks a combined ace and determines if it could be converted into
//  an old style object.
//
//  PARAMETERS:
//
//  bIsGroup            Set to true if the entry is for a group.
//
//  RETURN VALUES:
//
//  TRUE if the entry would make a valid instance
//
//***************************************************************************

bool CCombinedAce::IsValidOldEntry(bool bIsGroup)
{
    // If we have detected incompatible flags, all is done!

    if(m_BadAce)
        return false;
    if(bIsGroup && m_dwDeny)
        return false;   // group denies were not supported
    if(m_dwDeny && m_dwAllow)
        return false;   // can not mix allows and denies in old system

    if(m_dwDeny)
    {
        return true;
    }
    DWORD dwOldAllow = WBEM_ENABLE | WBEM_REMOTE_ACCESS | WBEM_WRITE_PROVIDER;
    DWORD dwMask = m_dwDeny;
    if(dwMask == 0)
        dwMask = m_dwAllow;

    // all these must be set if it is an allow.

    DWORD dwTemp = dwMask;
    dwTemp &= dwOldAllow;
    if(m_dwAllow != 0 && dwTemp != dwOldAllow)
        return false;

    // cant have full repository write without partial

    if((dwMask & WBEM_FULL_WRITE_REP) != 0 && (dwMask & WBEM_PARTIAL_WRITE_REP) == 0)
        return false;

    return true;
}

//***************************************************************************
//
//  CCombinedAce::GetNames
//
//  Retrieves the account name and authority
//
//  PARAMETERS:
//
//  pwszAccount     Set to newly allocated string, Caller must free if success
//  pwszDomain      Set to newly allocated string, Caller must free if success
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CCombinedAce::GetNames(LPWSTR & pwszAccount, LPWSTR &pwszDomain)
{
    pwszAccount = 0;
    pwszDomain = 0;

    // find the position of the '|'

    if(m_wcFullName == 0)
        return WBEM_E_FAILED;

    WCHAR * pwcSeparator;
    try
    {
        for(pwcSeparator = m_wcFullName; *pwcSeparator && *pwcSeparator != L'|'; pwcSeparator++);  // SEC:REVIEWED 2002-03-22 : OK
    }
    catch(...)
    {
        return WBEM_E_FAILED;
    }

    DWORD dwLenDomain;
    DWORD dwLenUser;
    bool bUseDotDomain = false;

    if(*pwcSeparator == 0)
    {
        return WBEM_E_FAILED;
    }
    if(pwcSeparator == m_wcFullName)
    {
        bUseDotDomain = true;
        dwLenDomain = 2;
    }
    else
    {
        dwLenDomain = pwcSeparator - m_wcFullName + 1;
    }
    dwLenUser = wcslen(pwcSeparator);            // SEC:REVIEWED 2002-03-22 : OK; prior logic assures NULL
    if(dwLenUser == 0)
        return WBEM_E_INVALID_OBJECT_PATH;

    // Allocate space for the two strings

    pwszAccount = new WCHAR[dwLenUser];
    if(pwszAccount == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    StringCchCopyW(pwszAccount, dwLenUser, pwcSeparator+1);

    pwszDomain = new WCHAR[dwLenDomain];
    if(pwszDomain == NULL)
    {
        delete pwszAccount;
        pwszAccount = 0;
        return WBEM_E_OUT_OF_MEMORY;
    }
    if(bUseDotDomain)
        StringCchCopyW(pwszDomain, dwLenDomain, L".");
    else
    {
        StringCchCopyW(pwszDomain, dwLenDomain, m_wcFullName);
    }
    return S_OK;
}

//***************************************************************************
//
//  RootSD::RootSD
//
//  Constructor.  This class contains a pointer to the root namespace and the
//  flex array of aces.
//
//***************************************************************************

RootSD::RootSD()
{
    m_bOK = false;
    m_pFlex = NULL;
    m_pRoot = CWbemNamespace::CreateInstance();

    if(m_pRoot == NULL)
        return;
    HRESULT hRes = m_pRoot->Initialize(L"root", L"Administrator",
                                                           0 ,
                                                           FULL_RIGHTS, true, false, NULL, 0xFFFFFFFF,
                                                           FALSE, NULL);

	if (FAILED(hRes))
	{
        m_pRoot->Release();
        m_pRoot = NULL;
        return;
	}
    else if (m_pRoot->GetStatus() != 0)
    {
        m_pRoot->Release();
        m_pRoot = NULL;
        return;
    }
    m_pRoot->AddRef();

    // Get the security descriptor

    m_pFlex = NULL;
    SCODE sc = m_pRoot->GetAceList(&m_pFlex);
    if(!FAILED(sc))
        m_bOK = true;
}

//***************************************************************************
//
//  RootSD::~RootSD
//
//  Destructor.
//
//***************************************************************************

RootSD::~RootSD()
{
    if(m_pRoot)
        m_pRoot->Release();
    if(m_pFlex)
        delete m_pFlex;
}


//***************************************************************************
//
//  RootSD::StoreAceList()
//
//  Stores the Ace list back into the db.
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT RootSD::StoreAceList()
{
    if(m_bOK && m_pFlex && m_pRoot)
        m_pRoot->PutAceList(m_pFlex);
    return S_OK;
}


//***************************************************************************
//
//  RootSD::RemoveMatchingEntries
//
//  Goes through the ACE list and removes all entries that match the name
//
//  PARAMETERS:
//
//  pwszAccountName     Name of the account to be deleted
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT RootSD::RemoveMatchingEntries(LPWSTR pwszAccountName)
{

    if(!m_bOK || m_pFlex == NULL)
        return WBEM_E_FAILED;

    for(int iPos = m_pFlex->Size()-1; iPos >= 0; iPos--)
    {
        CBaseAce * pListAce = (CBaseAce *)m_pFlex->GetAt(iPos);
        WCHAR * pwszAceListUserName;
        if(pListAce == NULL)
            continue;
        HRESULT hr = pListAce->GetFullUserName2(&pwszAceListUserName);
        if(FAILED(hr))
            return hr;
        CDeleteMe<WCHAR> dm1(pwszAceListUserName);

        if(wbem_wcsicmp(pwszAceListUserName, pwszAccountName) == 0)
        {
            delete pListAce;
            m_pFlex->RemoveAt(iPos);
        }
    }
    return S_OK;
}

//***************************************************************************
//
//  OldSecList::OldSecList
//
//  Constructor.  This class contains the list of combined entries for the
//  aces in the root namespace.  Note that the list is of just the users,
//  or just the groups.
//
//***************************************************************************

OldSecList::OldSecList(bool bGroups)
{

    // Attach up to the root namespace

    RootSD rsd;
    if(!rsd.IsOK())
        return;         // empty list

    // Get the Security namespace

    CFlexAceArray * pRootNsAceList =  rsd.GetAceList();

    if(pRootNsAceList == NULL)
        return;

    // For each ACE in the root namespace list

    for(int iAce = 0; iAce < pRootNsAceList->Size(); iAce++)
    {

        // Search the entries in the combined list to see if there is already one for
        // this ace

        CBaseAce * pAce = (CBaseAce *)pRootNsAceList->GetAt(iAce);

        WCHAR * pwszAceListUserName;
        if(pAce == NULL)
            continue;

        CNtAce * pNtAce = (CNtAce *)pAce;
        CNtSid sid;
        pNtAce->GetSid(sid);
        DWORD dwUsage;
        LPWSTR pAccount = NULL;
        LPWSTR pDomain = NULL;
        if(sid.GetInfo(&pAccount, &pDomain, &dwUsage))
            continue;
        delete pAccount;
        delete pDomain;
        if(dwUsage == SidTypeUser && bGroups)
            continue;
        if(dwUsage != SidTypeUser && !bGroups)
            continue;


        HRESULT hr = pAce->GetFullUserName2(&pwszAceListUserName);
        if(FAILED(hr))
            continue;
        CDeleteMe<WCHAR> dm1(pwszAceListUserName);

        bool bExisting = false;
        for(int iMergedEntry = 0; iMergedEntry < m_MergedAceList.Size(); iMergedEntry++)
        {
            CCombinedAce * pCombinedEntry = (CCombinedAce *)m_MergedAceList.GetAt(iMergedEntry);
            if(pCombinedEntry)
            {
                if(wbem_wcsicmp(pwszAceListUserName, pCombinedEntry->m_wcFullName) == 0 )
                {
                    bExisting = true;
                    pCombinedEntry->AddToMasks(pAce);
                    break;
                }
            }
        }

        // If necessary add a new entry

        if(!bExisting)
        {
            CCombinedAce * pCombinedEntry = new CCombinedAce(pwszAceListUserName);
            if(pCombinedEntry == NULL)
                return;
            pCombinedEntry->AddToMasks(pAce);
            if (CFlexArray::no_error != m_MergedAceList.Add((void *)pCombinedEntry))
            {
                //throw CX_Exception();
            }
        }
    }
}

//***************************************************************************
//
//  OldSecList::~OldSecList()
//
//  Destructor.
//
//***************************************************************************

OldSecList::~OldSecList()
{

    // Delete the stuff used in the entry list.

    for(int iCnt = m_MergedAceList.Size() - 1; iCnt >= 0; iCnt--)
    {
        CCombinedAce * pCombinedEntry = (CCombinedAce *)m_MergedAceList.GetAt(iCnt);
        delete pCombinedEntry;
    }
}

//***************************************************************************
//
//  OldSecList::GetValidCombined
//
//  Returns a combined entry at the specified index, but only if it is valid.
//
//  PARAMETERS:
//
//  iIndex          Index into the array, 0 is the first
//  bGroup          true if a group entry is desired.
//
//  RETURN VALUES:
//
//  If all is well, a pointer to the combined entry.  NULL indicates failure.
//
//***************************************************************************

CCombinedAce * OldSecList::GetValidCombined(int iIndex, bool bGroup)
{

    if(iIndex < 0 || iIndex >= m_MergedAceList.Size())
        return NULL;

    // Get the entry

    CCombinedAce * pCombinedEntry = (CCombinedAce *)m_MergedAceList.GetAt(iIndex);
    if(pCombinedEntry == NULL)
        return NULL;

    // verify that the entry can be translated back into an old security setting

    if(pCombinedEntry->IsValidOldEntry(bGroup))
        return pCombinedEntry;
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "Invalid ace entry combination encountered, name = %S, "
            "allow=0x%x, deny=0x%x, flag validity=&d", pCombinedEntry->m_wcFullName,
            pCombinedEntry->m_dwAllow, pCombinedEntry->m_dwDeny, pCombinedEntry->m_BadAce));
        return NULL;
    }
}

//***************************************************************************
//
//  OldSecList::GetValidCombined
//
//  Returns a combined entry which matches the name, but only if it is valid.
//
//  PARAMETERS:
//
//  pName           Name to be found.  It is of the format "authority|name"
//  bGroup          true if a group entry is desired.
//
//  RETURN VALUES:
//
//  If all is well, a pointer to the combined entry.  NULL indicates failure.
//
//***************************************************************************

CCombinedAce * OldSecList::GetValidCombined(LPWSTR pName, bool bGroup)
{

    if(pName == NULL)
        return NULL;

    // Go through the list and look for the matching entry

    int iCnt;
    CCombinedAce * pCombinedEntry;
    for(iCnt = 0; iCnt < m_MergedAceList.Size(); iCnt++)
    {
        pCombinedEntry = (CCombinedAce *)m_MergedAceList.GetAt(iCnt);
        if(pCombinedEntry && !wbem_wcsicmp(pCombinedEntry->m_wcFullName, pName))
            break;
    }

    if(iCnt == m_MergedAceList.Size())
        return NULL;

    // verify that the entry can be translated back into an old security setting

    if(pCombinedEntry->IsValidOldEntry(bGroup))
        return pCombinedEntry;
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "Invalid ace entry combination encountered, name = %S, "
            "allow=0x%x, deny=0x%x, flag validity=&d", pCombinedEntry->m_wcFullName,
            pCombinedEntry->m_dwAllow, pCombinedEntry->m_dwDeny, pCombinedEntry->m_BadAce));
        return NULL;
    }
}

//***************************************************************************
//
//  CWbemNamespace::EnumerateSecurityClassInstances
//
//  Equivalent the a CreateInstanceEnumAsync call.
//
//  PARAMETERS:
//
//  wszClassName    class name
//  pSink           Where to indicate the value
//  pContext        pointer to the context object.
//  lFlags          flags.
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CWbemNamespace::EnumerateSecurityClassInstances(LPWSTR wszClassName,
                    IWbemObjectSink* pSink, IWbemContext* pContext, long lFlags)
{

    SCODE sc = WBEM_E_FAILED;
    IWbemClassObject FAR* pObj = NULL;

    // Do sanity check of arguments.

    if(pSink == NULL || wszClassName == NULL )    // Should not happen
        return WBEM_E_INVALID_PARAMETER;

    // Get the class object

    IWbemClassObject * pClass = NULL;
    sc = GetObject(wszClassName, 0, pContext, &pClass, NULL);
    if(sc != S_OK)
    {
        return sc;
    }

    CReleaseMe rm(pClass);


    bool bGroup = false;
    if(wbem_wcsicmp(L"__ntlmgroup", wszClassName) == 0)
        bGroup = true;
    
    OldSecList osl(bGroup);
    sc = S_OK;
    for(int i = 0; i < osl.Size(); i++)
    {
        IWbemClassObject * pObj = NULL;
        CCombinedAce * pCombinedEntry = osl.GetValidCombined(i, bGroup);
        if(pCombinedEntry)
        {
            sc = CreateTheInstance(&pObj, pClass, pCombinedEntry);
            if(sc == S_OK)
            {
                if (SUCCEEDED(sc = DecorateObject(pObj)))
                {
                    pSink->Indicate(1,&pObj);
                }
                pObj->Release();
            }
        }
    }

    // Set status, all done
    return sc;
}

//***************************************************************************
//
//  CWbemNamespace::PutSecurityClassInstances
//
//  Equivalent to a PutInstanceAsync call.
//
//  PARAMETERS:
//
//  wszClassName    class name
//  pObj            Object to be "put"
//  pSink           where to SetStatus
//  pContext        pointer to the context object
//  lFlags          flags
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CWbemNamespace::PutSecurityClassInstances(LPWSTR wszClassName,  IWbemClassObject * pObj,
                    IWbemObjectSink* pSink, IWbemContext* pContext, long lFlags)
{
    // Check the args

    if(wszClassName == NULL || pObj == NULL || pSink == NULL)
    {
        pSink->SetStatus(0,WBEM_E_INVALID_PARAMETER,NULL,NULL);
        return S_OK;
    }

    RootSD rsd;
    if(!rsd.IsOK())
    {
        pSink->SetStatus(0,WBEM_E_FAILED,NULL,NULL);
        return S_OK;
    }

    // Get the Security namespace

    CFlexAceArray * pRootNsAceList =  rsd.GetAceList();
    bool bGroup = false;
    if(wbem_wcsicmp(L"__ntlmgroup", wszClassName) == 0)
        bGroup = true;
    
    // Convert to new sid

    CBaseAce * pAce = ConvertOldObjectToAce(pObj, bGroup);
    if(pAce == NULL)
    {
        pSink->SetStatus(0,WBEM_E_INVALID_OBJECT,NULL,NULL);
        return S_OK;
    }


    // Delete all entries with the same name

    WCHAR * pwszAccountName;
    HRESULT hr = pAce->GetFullUserName2(&pwszAccountName);
    if(FAILED(hr))
    {
        pSink->SetStatus(0,hr,NULL,NULL);
        return S_OK;
    }

    CDeleteMe<WCHAR> dm1(pwszAccountName);

    rsd.RemoveMatchingEntries(pwszAccountName);

    // Add the new entries

    pRootNsAceList->Add(pAce);

    // Put Sid back

    hr = rsd.StoreAceList();
    pSink->SetStatus(0,hr,NULL,NULL);
    return S_OK;
}

//***************************************************************************
//
//  CWbemNamespace::DeleteSecurityClassInstances
//
//  Equivalent to a DeleteInstanceAsync routine
//
//  PARAMETERS:
//
//  pParsedPath     parsed object path
//  pSink           where to SetStatus
//  pContext        pointer to the context object
//  lFlags          flags
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CWbemNamespace::DeleteSecurityClassInstances(ParsedObjectPath* pParsedPath,
                    IWbemObjectSink* pSink, IWbemContext* pContext, long lFlags)
{
    // Check the args

    if(pParsedPath == NULL || pSink == NULL || pSink == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Parse the path and contruct the domain|user string

    LPWSTR pAcePath = NULL;
    HRESULT hr = GetAceStylePath(pParsedPath, &pAcePath);
    if(FAILED(hr))
    {
        pSink->SetStatus(0,hr,NULL,NULL);
        return S_OK;
    }

    CDeleteMe<WCHAR> dm(pAcePath);

    // Delete the entries

    RootSD rsd;
    if(!rsd.IsOK())
        hr = WBEM_E_FAILED;
    else
    {
        CFlexAceArray * pRootNsAceList =  rsd.GetAceList();
        int iOriginalSize = pRootNsAceList->Size();

        // Delete all entries with the same name

        rsd.RemoveMatchingEntries(pAcePath);

        int iNewSize = pRootNsAceList->Size();
        if(iNewSize < iOriginalSize)
            hr = rsd.StoreAceList();
        else
            hr = WBEM_E_NOT_FOUND;
    }
    pSink->SetStatus(0,hr,NULL,NULL);
    return S_OK;

}

//***************************************************************************
//
//  CWbemNamespace::GetSecurityClassInstances
//
//  Equivalent to a GetObjectAsync call.
//
//  PARAMETERS:
//
//  pParsedPath     parsed object path
//  pSink           where to SetStatus
//  pContext        pointer to the context object
//  lFlags          flags
//
//  RETURN VALUES:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT CWbemNamespace::GetSecurityClassInstances(ParsedObjectPath* pParsedPath, CBasicObjectSink* pSink,
                    IWbemContext* pContext,long lFlags)
{
    // Check the args

    if(pParsedPath == NULL|| pSink == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Parse the path and contruct the domain|user string

    LPWSTR pAcePath = NULL;
    HRESULT hr = GetAceStylePath(pParsedPath, &pAcePath);
    if(FAILED(hr))
    {
        pSink->SetStatus(0,hr,NULL,NULL);
        return S_OK;
    }

    CDeleteMe<WCHAR> dm(pAcePath);

    IWbemClassObject * pClass = NULL;
    SCODE sc = GetObject(pParsedPath->m_pClass, 0, pContext, &pClass, NULL);
    if(sc != S_OK)
    {
        pSink->SetStatus(0,sc,NULL, NULL);
        return S_OK;
    }

    CReleaseMe rm(pClass);


    bool bGroup = false;
    if(wbem_wcsicmp(L"__ntlmgroup", pParsedPath->m_pClass) == 0)
        bGroup = true;
    OldSecList osl(bGroup);

    IWbemClassObject * pObj = NULL;
    CCombinedAce * pCombinedEntry = osl.GetValidCombined(pAcePath, bGroup);
    if(pCombinedEntry == NULL)
    {
        pSink->SetStatus(0, WBEM_E_INVALID_OBJECT_PATH, NULL, NULL);
        return S_OK;
    }
    sc = CreateTheInstance(&pObj, pClass, pCombinedEntry);
    if(sc == S_OK)      // not all entries make for valid old entries, so failure is common
    {
        if (SUCCEEDED(sc = DecorateObject(pObj)))
        {
        	pSink->Indicate(1,&pObj);
        }
	    pObj->Release();
    }

    // Set status, all done

    pSink->SetStatus(0,sc,NULL, NULL);
    return S_OK;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\oldsec.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    OLDSEC.H

Abstract:

	defines various routines and classes used providing backward security support.

History:

	a-davj    02-sept-99  Created.

--*/

#ifndef _OLDSEC_H_
#define _OLDSEC_H_

//***************************************************************************
//
//  CCombinedAce
//
//  Since there might be several ACEs for a single user or group in the ACL, 
//  this structure is used to combine all the aces for a sid into one.
//
//***************************************************************************

struct CCombinedAce
{
    CCombinedAce(WCHAR *pwszName);
    ~CCombinedAce(){delete m_wcFullName;};
    void AddToMasks(CBaseAce * pAce);
    bool IsValidOldEntry(bool bIsGroup);
    HRESULT GetNames(LPWSTR & pwszAccount, LPWSTR &pwszDomain);

    DWORD m_dwAllow;
    DWORD m_dwDeny;
    bool m_BadAce;
    WCHAR  *m_wcFullName;
};

//***************************************************************************
//
//  OldSecList
//
//  The list of combined entries for the aces in the root namespace.  Note
//  that the list is of just the users, or just the groups.
//
//***************************************************************************

class OldSecList 
{
private:
    CFlexArray m_MergedAceList;
public:
    OldSecList(bool bGroupsOnly);    
    ~OldSecList();    
    int Size(){return m_MergedAceList.Size();};
    CCombinedAce * GetValidCombined(int iIndex, bool bGroup);
    CCombinedAce * GetValidCombined(LPWSTR pName, bool bGroup);

};

//***************************************************************************
//
//  RootSD
//
//  Holds a pointer to the root namespace and the flex array of aces.
//
//***************************************************************************

class RootSD
{
private:
    CWbemNamespace * m_pRoot;
    CFlexAceArray * m_pFlex;
    bool m_bOK;
public:
    RootSD();
    ~RootSD();
    bool IsOK(){return m_bOK;};
    CFlexAceArray * GetAceList(){return m_pFlex;};
    HRESULT StoreAceList();
    HRESULT RemoveMatchingEntries(LPWSTR pwszObjUserName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define WIN32_NO_STATUS
#include <ole2.h>
#include <windows.h>

#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )
#define ESSLIB_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )

#include <comdef.h>
#include <strsafe.h>
#include "arena.h"
#include <helper.h>
#include <autoptr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\protoq.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PROTOQ.CPP

Abstract:

    Prototype query support for WinMgmt Query Engine.
    This was split out from QENGINE.CPP for better source
    organization.

History:

    raymcc   04-Jul-99   Created.

--*/


#include "precomp.h"
#include <stdio.h>
#include <stdlib.h>

#include <wbemcore.h>


int SelectedClass::SetAll(int & nPos)
{
    m_bAll = TRUE;

    // For each property, add an entry

    CWbemClass *pCls = (CWbemClass *)m_pClassDef;
    pCls->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    OnDeleteObj0<IWbemClassObject,
                          HRESULT(__stdcall IWbemClassObject:: *)(void),
                          IWbemClassObject::EndEnumeration> EndMe(pCls);   
    BSTR PropName = 0;
    while (S_OK == pCls->Next(0, &PropName, NULL, NULL, NULL))
    {
        CSysFreeMe smf(PropName);
        int nRes = SetNamed(PropName, nPos);
        if (CFlexArray::no_error != nRes)
            return nRes;
    }
    return CFlexArray::no_error;
};

HRESULT ReleaseClassDefs(IN CFlexArray *pDefs)
{
    for (int i = pDefs->Size()-1; i >= 0 ; i--)
    {
        SelectedClass *pSelClass = (SelectedClass *) pDefs->GetAt(i);
        delete pSelClass;
    }
    return WBEM_NO_ERROR;
}


//***************************************************************************
//
//  ExecPrototypeQuery
//
//  Called by CQueryEngine::ExecQuery for SMS-style prototypes.
//
//  Executes the query and returns only the class definition implied
//  by the query, whether a join or a simple class def.
//
//***************************************************************************

HRESULT ExecPrototypeQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQuery,
    IN IWbemContext* pContext,
    IN CBasicObjectSink *pSink
    )
{
    HRESULT hRes;
    int nRes;


    if (pSink == NULL) return WBEM_E_INVALID_PARAMETER;
    if (pNs == NULL )
            return pSink->Return(WBEM_E_INVALID_PARAMETER);

    // Parse the query and determine if it is a single class.
    // ======================================================

    CTextLexSource src(pszQuery);
    CWQLScanner Parser(&src);     
    nRes = Parser.Parse();
    if (nRes != CWQLScanner::SUCCESS)
        return pSink->Return(WBEM_E_INVALID_QUERY);

    // If a single class definition, branch, since we don't
    // want to create a __GENERIC object.
    // ====================================================

    CWStringArray aAliases;
    Parser.GetReferencedAliases(aAliases);

    if (aAliases.Size() == 1)
    {
        LPWSTR pszClass = Parser.AliasToTable(aAliases[0]);
        return GetUnaryPrototype(Parser, pszClass, aAliases[0], pNs, pContext, pSink);
    }

    // If here, a join must have occurred.
    // ===================================
    CFlexArray aClassDefs;
    OnDelete<CFlexArray *,HRESULT(*)( CFlexArray *), ReleaseClassDefs > FreeMe(&aClassDefs);
    hRes = RetrieveClassDefs(Parser,pNs, pContext,aAliases,&aClassDefs); // throw

    if (FAILED(hRes)) return pSink->Return(WBEM_E_INVALID_QUERY);

    // Iterate through all the properties selected.
    // ============================================
    const CFlexArray *pSelCols = Parser.GetSelectedColumns();

    int nPosSoFar = 0;
    for (int i = 0; i < pSelCols->Size(); i++)
    {
        SWQLColRef *pColRef = (SWQLColRef *) pSelCols->GetAt(i);
        hRes = SelectColForClass(Parser, &aClassDefs, pColRef, nPosSoFar);
        if (hRes)  return pSink->Return(hRes);
    }

    // If here, we have the class definitions.
    // =======================================

    IWbemClassObject *pProtoInst = 0;
    hRes = AdjustClassDefs(&aClassDefs, &pProtoInst);
    CReleaseMe rmProto(pProtoInst);
    if (hRes)  return pSink->Return(hRes);    

    if (FAILED(hRes = pSink->Add(pProtoInst))) return pSink->Return(hRes);

    return pSink->Return(WBEM_NO_ERROR);
}


//***************************************************************************
//
//***************************************************************************

HRESULT RetrieveClassDefs(
    IN CWQLScanner & Parser,
    IN CWbemNamespace *pNs,
    IN IWbemContext *pContext,
    IN CWStringArray & aAliasNames,
    OUT CFlexArray *pDefs
    )
{
    for (int i = 0; i < aAliasNames.Size(); i++)
    {
        // Retrieve the class definition.
        LPWSTR pszClass = Parser.AliasToTable(aAliasNames[i]);
        if (pszClass == 0)
            continue;

        IWbemClassObject *pClassDef = 0;
        HRESULT hRes = pNs->Exec_GetObjectByPath(pszClass, 0, pContext,&pClassDef, 0);
        CReleaseMe rmClassDef(pClassDef);
        if (FAILED(hRes)) return hRes;

        wmilib::auto_ptr<SelectedClass> pSelClass( new SelectedClass);
        if (NULL == pSelClass.get())
            return WBEM_E_OUT_OF_MEMORY;

        pSelClass->m_wsClass = pszClass; // throw
        pSelClass->m_wsAlias = aAliasNames[i]; // throw

        pClassDef->AddRef();
        pSelClass->m_pClassDef = pClassDef;

        if (CFlexArray::no_error != pDefs->Add(pSelClass.get())) return WBEM_E_OUT_OF_MEMORY;
        pSelClass.release();
    }

    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************



//***************************************************************************
//
//***************************************************************************

HRESULT SelectColForClass(
    IN CWQLScanner & Parser,
    IN CFlexArray *pClassDefs,
    IN SWQLColRef *pColRef,
    IN int & nPosition
    )
{
    int i;
    HRESULT hRes;

    if (!pColRef)
        return WBEM_E_FAILED;

    // If the column reference contains the class referenced
    // via an alias and there is no asterisk, we are all set.
    // ======================================================

    if (pColRef->m_pTableRef)
    {
        // We now have the class name. Let's find it and add
        // the referenced column for that class!
        // =================================================

        for (i = 0; i < pClassDefs->Size(); i++)
        {
            SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);

            if (wbem_wcsicmp(LPWSTR(pSelClass->m_wsAlias), pColRef->m_pTableRef) != 0)
                continue;

            CWbemClass *pCls = (CWbemClass *) pSelClass->m_pClassDef;

            // See if the asterisk was used for this class.
            // =============================================

            if (pColRef->m_pColName[0] == L'*' && pColRef->m_pColName[1] == 0)
            {
                pSelClass->SetAll(nPosition);
                return WBEM_NO_ERROR;
            }

            // If here, a property was mentioned by name.
            // Verify that it exists.
            // ==========================================

            CVar Prop;
            hRes = pCls->GetProperty(pColRef->m_pColName, &Prop);
            if (FAILED(hRes))
                return WBEM_E_INVALID_QUERY;

            // Mark it as seleted.
            // ===================

            if (CFlexArray::no_error != pSelClass->SetNamed(pColRef->m_pColName, nPosition))
                return WBEM_E_OUT_OF_MEMORY;

            return WBEM_NO_ERROR;
        }

        // If here, we couldn't locate the property in any class.
        // ======================================================

        return WBEM_E_INVALID_QUERY;
    }

    // Did we select * from all tables?
    // ================================

    if (pColRef->m_dwFlags & WQL_FLAG_ASTERISK)
    {
        for (i = 0; i < pClassDefs->Size(); i++)
        {
            SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
            if (CFlexArray::no_error != pSelClass->SetAll(nPosition)) 
                return WBEM_E_OUT_OF_MEMORY;
        }

        return WBEM_NO_ERROR;
    }


    // If here, we have an uncorrelated property and we have to find out
    // which class it belongs to.  If it belongs to more than one, we have
    // an ambiguous query.
    // ===================================================================

    DWORD dwTotalMatches = 0;

    for (i = 0; i < pClassDefs->Size(); i++)
    {
        SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
        CWbemClass *pCls = (CWbemClass *) pSelClass->m_pClassDef;

        // Try to locate the property in this class.
        // =========================================

        CVar Prop;
        hRes = pCls->GetProperty(pColRef->m_pColName, &Prop);

        if (hRes == 0)
        {
             if (CFlexArray::no_error != pSelClass->SetNamed(pColRef->m_pColName, nPosition))
                return WBEM_E_OUT_OF_MEMORY;                
            dwTotalMatches++;
        }
    }

    // If more than one match occurred, we have an ambiguous query.
    // ============================================================

    if (dwTotalMatches != 1)
        return WBEM_E_INVALID_QUERY;

    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT AddOrderQualifiers(
    CWbemClass *pCls,
    BSTR PropName,
    CFlexArray Matches
    )
{
    IWbemQualifierSet * pQual;
    SCODE sc = pCls->GetPropertyQualifierSet(PropName, &pQual);
    if(sc != S_OK)
        return sc;
    CReleaseMe rm(pQual);

    // Create a safe array
    SAFEARRAYBOUND aBounds[1];
    aBounds[0].lLbound = 0;
    aBounds[0].cElements = Matches.Size();

    SAFEARRAY* pArray = SafeArrayCreate(VT_I4, 1, aBounds);
    if (NULL == pArray) return WBEM_E_OUT_OF_MEMORY;

    // Stuff the individual data pieces
    // ================================

    for(int nIndex = 0; nIndex < Matches.Size(); nIndex++)
    {
        long lPos = PtrToLong(Matches.GetAt(nIndex));
        sc = SafeArrayPutElement(pArray, (long*)&nIndex, &lPos);
    }

    VARIANT var;
    var.vt = VT_ARRAY | VT_I4;
    var.parray = pArray;

    sc = pQual->Put(L"Order", &var, 0);

    VariantClear(&var);

    return sc;
}

//***************************************************************************
//
//***************************************************************************

HRESULT SetPropertyOrderQualifiers(SelectedClass *pSelClass)
{
    HRESULT hRes = S_OK;
    
    CWbemClass *pCls = (CWbemClass *) pSelClass->m_pClassDef;

    // Go through each property

    pCls->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    OnDeleteObj0<IWbemClassObject,
                          HRESULT(__stdcall IWbemClassObject:: *)(void),
                          IWbemClassObject::EndEnumeration> EndMe(pCls);
    
    BSTR PropName = 0;
    while (S_OK == pCls->Next(0, &PropName, NULL, NULL, NULL))
    {
        CSysFreeMe sfm(PropName);

        // Build up a list of properties that Match

        CFlexArray Matches;
        bool bAtLeastOne = false;
        for(int iCnt = 0; iCnt < pSelClass->m_aSelectedCols.Size(); iCnt++)
        {
            if(!wbem_wcsicmp(pSelClass->m_aSelectedCols.GetAt(iCnt), PropName))
            {
                if (CFlexArray::no_error == Matches.Add(pSelClass->m_aSelectedColsPos.GetAt(iCnt)))
                {
                    bAtLeastOne = true;
                }
            }
        }

        if(bAtLeastOne)
        {
            hRes = AddOrderQualifiers(pCls, PropName, Matches);
            if (FAILED(hRes)) return hRes;
        }

    }

    return hRes;
}


//***************************************************************************
//
//  AdjustClassDefs
//
//  After all class definitions have been retrieved, they are adjusted
//  to only have the properties required and combined into a __GENERIC
//  instance.
//
//***************************************************************************

HRESULT AdjustClassDefs(
    IN  CFlexArray *pClassDefs,
    OUT IWbemClassObject **pRetNewClass
    )
{
    int i;
    HRESULT hRes;

    for (i = 0; i < pClassDefs->Size(); i++)
    {
        SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
        CWbemClass *pCls = (CWbemClass *) pSelClass->m_pClassDef;

        if (pSelClass->m_bAll)
        {
            hRes = SetPropertyOrderQualifiers(pSelClass);
            if (FAILED(hRes)) return hRes;
            continue;
        }

        WString wsError = pCls->FindLimitationError(0, &pSelClass->m_aSelectedCols);

        if (wsError.Length() > 0)
            return WBEM_E_FAILED;

        // Map the limitaiton
        // ==================

        CLimitationMapping Map;
        BOOL bValid = pCls->MapLimitation(0, &pSelClass->m_aSelectedCols, &Map);

        if (!bValid)
            return WBEM_E_FAILED;

        CWbemClass* pStrippedClass = 0;
        hRes = pCls->GetLimitedVersion(&Map, &pStrippedClass);
        if(SUCCEEDED(hRes))
        {
            pSelClass->m_pClassDef = pStrippedClass;
            pCls->Release();            
            if (FAILED(hRes = SetPropertyOrderQualifiers(pSelClass))) return hRes;
        }
    }

    // Count the number of objects that actually have properties

    int iNumObj = 0;
    for (i = 0; i < pClassDefs->Size(); i++)
    {
        SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
        CWbemObject *pObj = (CWbemObject *) pSelClass->m_pClassDef;
        if (pObj->GetNumProperties() > 0)
            iNumObj++;
    }

    // If there is just one object with properties, return it rather than the generic object

    if(iNumObj == 1)
    {
        for (i = 0; i < pClassDefs->Size(); i++)
        {
            SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
            CWbemObject *pObj = (CWbemObject *) pSelClass->m_pClassDef;
            if (pObj->GetNumProperties() == 0)
                continue;
            // Return it.
            // ==========

            *pRetNewClass = pObj;
            pObj->AddRef();
            return WBEM_NO_ERROR;
        }
    }


    // Prepare a __GENERIC class def.  We construct a dummy definition which
    // has properties named for each of the aliases used in the query.
    // =====================================================================

    CGenericClass *pNewClass = new CGenericClass;  
    if (pNewClass == 0) return WBEM_E_OUT_OF_MEMORY;
    CReleaseMe rmNewCls((IWbemClassObject *)pNewClass);
    
    pNewClass->Init();   // throw
    

    for (i = 0; i < pClassDefs->Size(); i++)
    {
        SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
        CWbemObject *pObj = (CWbemObject *) pSelClass->m_pClassDef;

        if (pObj->GetNumProperties() == 0)
            continue;

        CVar vEmbeddedClass;
        vEmbeddedClass.SetAsNull();

        if (FAILED( hRes = pNewClass->SetPropValue(pSelClass->m_wsAlias, &vEmbeddedClass, CIM_OBJECT))) return hRes;

        CVar vClassName;
        if (FAILED(hRes = pObj->GetClassName(&vClassName))) return hRes;

        WString wsCimType = L"object:";
        wsCimType += vClassName.GetLPWSTR();
        CVar vCimType(VT_BSTR, wsCimType);

        if (FAILED( hRes = pNewClass->SetPropQualifier(pSelClass->m_wsAlias, L"cimtype", 0,&vCimType))) return hRes;
    };

    // Spawn an instance of this class.
    // ================================

    CWbemInstance* pProtoInst = 0;
    if (FAILED( hRes = pNewClass->SpawnInstance(0, (IWbemClassObject **) &pProtoInst))) return hRes;
    CReleaseMe rmProtInst((IWbemClassObject *)pProtoInst);
    rmNewCls.release();


    // Now assign the properties to the embedded instances.
    // ====================================================

    for (i = 0; i < pClassDefs->Size(); i++)
    {
        SelectedClass *pSelClass = (SelectedClass *) pClassDefs->GetAt(i);
        CWbemClass *pCls = (CWbemClass *) pSelClass->m_pClassDef;

        if (pCls->GetNumProperties() == 0)
            continue;

        CVar vEmbedded;
        vEmbedded.SetEmbeddedObject((IWbemClassObject *) pCls); 

        if (FAILED( hRes = pProtoInst->SetPropValue(pSelClass->m_wsAlias, &vEmbedded, 0))) return hRes;
    };

    // Return it.
    // ==========
    rmProtInst.dismiss();
    *pRetNewClass = pProtoInst; 

    return WBEM_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT GetUnaryPrototype(
    IN CWQLScanner & Parser,
    IN LPWSTR pszClass,
    IN LPWSTR pszAlias,
    IN CWbemNamespace *pNs,
    IN IWbemContext *pContext,
    IN CBasicObjectSink *pSink
    )
{
    int i;

    // Retrieve the class definition.
    // ==============================

    IWbemClassObject *pClassDef = 0;
    IWbemClassObject *pErrorObj = 0;

    HRESULT hRes = pNs->Exec_GetObjectByPath(pszClass, 0, pContext,&pClassDef, &pErrorObj);

    CReleaseMeRef<IWbemClassObject *> rmObj(pClassDef);
    CReleaseMe rmErrObj(pErrorObj);

    if (FAILED(hRes))
    {
        pSink->SetStatus(0, hRes, NULL, pErrorObj);
        return S_OK;
    }

    rmErrObj.release();


    CWbemClass *pCls = (CWbemClass *) pClassDef;
    BOOL bKeepAll = FALSE;

    // This keeps track of the order in which columns are selected

    SelectedClass sel;    
    sel.m_wsClass = pszClass; // throw
    sel.m_pClassDef = pClassDef;
    pClassDef->AddRef();

    // Go through all the columns and make sure that the properties are valid
    // ======================================================================

   const CFlexArray *pSelCols = Parser.GetSelectedColumns();

   int nPosition = 0;

    for (i = 0; i < pSelCols->Size(); i++)
    {
        SWQLColRef *pColRef = (SWQLColRef *) pSelCols->GetAt(i);

        if (pColRef->m_dwFlags & WQL_FLAG_ASTERISK)
        {
            bKeepAll = TRUE;
            if (CFlexArray::no_error == sel.SetAll(nPosition))
                continue;
            else
                return pSink->Return(WBEM_E_FAILED);
        }

        if (pColRef->m_pColName)
        {

            // check for the "select x.* from x" case

            if(pColRef->m_pColName[0] == L'*' && pColRef->m_pColName[1] == 0)
            {
                if (!wbem_wcsicmp(pColRef->m_pTableRef, pszAlias))   // SEC:REVIEWED 2002-03-22 : OK, prior guarantee of NULL terminators
                {
                    bKeepAll = TRUE;
                    if (CFlexArray::no_error == sel.SetAll(nPosition))
                        continue;
                    else
                        return pSink->Return(WBEM_E_FAILED);                    
                    continue;
                }
                else
                {
                    return pSink->Return(WBEM_E_INVALID_QUERY);
                }
            }

            // Verify that the class has it
            // ============================

            CIMTYPE ct;
            if(FAILED(pCls->GetPropertyType(pColRef->m_pColName, &ct)))
            {
                // No such property
                // ================

                return pSink->Return(WBEM_E_INVALID_QUERY);
            }
            if (CFlexArray::no_error != sel.SetNamed(pColRef->m_pColName, nPosition))
                return pSink->Return(WBEM_E_FAILED);                                    
        }
    }

    // Eliminate unreferenced columns from the query.
    // ==============================================

    CWStringArray aPropsToKeep;   // SEC:REVIEWED 2002-03-22 : May throw

    if(!bKeepAll)
    {
        // Move through each property in the class and
        // see if it is referenced.  If not, remove it.
        // ============================================

        int nNumProps = pCls->GetNumProperties();
        for (i = 0; i < nNumProps; i++)
        {
            CVar Prop;
            HRESULT hrInner;
            hrInner = pCls->GetPropName(i, &Prop);  
            if (FAILED(hrInner)) return pSink->Return(hrInner);

            // See if this name is used in the query.
            // ======================================

            for (int i2 = 0; i2 < pSelCols->Size(); i2++)
            {
                SWQLColRef *pColRef = (SWQLColRef *) pSelCols->GetAt(i2);

                if (pColRef->m_pColName && wbem_wcsicmp(Prop, pColRef->m_pColName) == 0)
                {
                    if (CFlexArray::no_error != aPropsToKeep.Add((LPWSTR) Prop))
                        return pSink->Return(WBEM_E_FAILED);
                    break;
                }
            }
        }
    }

    // Now we have a list of properties to remove.
    // ===========================================

    if (!bKeepAll && aPropsToKeep.Size())
    {
        WString wsError = pCls->FindLimitationError(0, &aPropsToKeep);  // throw

        if (wsError.Length() > 0)
        {
            return pSink->Return(WBEM_E_FAILED);
        }

        // Map the limitaiton
        // ==================

        CLimitationMapping Map;                    
        BOOL bValid = pCls->MapLimitation(0, &aPropsToKeep, &Map);

        if (!bValid)
        {
            return pSink->Return(WBEM_E_FAILED);
        }

        CWbemClass* pNewStrippedClass = 0;
        hRes = pCls->GetLimitedVersion(&Map, &pNewStrippedClass);
        if(SUCCEEDED(hRes))
        {
            // this is for the on-stack object
            pClassDef->Release();

            // this is for the copy given to the SelectClass object
            sel.m_pClassDef->Release();
            sel.m_pClassDef = pNewStrippedClass;
            pNewStrippedClass->AddRef();

            pClassDef = pNewStrippedClass; // give ownership to the oure scope
        }
    }

    // Add the Order qualifier

    hRes= SetPropertyOrderQualifiers(&sel); 
    if (FAILED(hRes)) return pSink->Return(hRes);

    // Return it.
    // ==========
    hRes = pSink->Add(pClassDef);
    if (FAILED(hRes)) return pSink->Return(hRes);    

    return pSink->Return(WBEM_NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\olesrvr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    OLESRVR.CPP

Abstract:

    "Main" file for wbemcore.dll: implements all DLL entry points.

    Classes defined and implemeted:

        CWbemLocator

History:

    raymcc        16-Jul-96       Created.
    raymcc        05-May-97       Security extensions

--*/

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <initguid.h>
#include <wbemcore.h>
#include <intprov.h>
#include <genutils.h>
#include <wbemint.h>
#include <windows.h>
#include <helper.h>

// {A83EF168-CA8D-11d2-B33D-00104BCC4B4A}
DEFINE_GUID(CLSID_IntProv,
0xa83ef168, 0xca8d, 0x11d2, 0xb3, 0x3d, 0x0, 0x10, 0x4b, 0xcc, 0x4b, 0x4a);

LPTSTR g_pWorkDir = 0;
LPTSTR g_pDbDir = 0;
LPTSTR g_pAutorecoverDir = 0;
DWORD g_dwQueueSize = 1;
HINSTANCE g_hInstance;
BOOL g_bDontAllowNewConnections = FALSE;
IWbemEventSubsystem_m4* g_pEss_m4 = NULL;
bool g_bDefaultMofLoadingNeeded = false;
IClassFactory* g_pContextFac = NULL;
IClassFactory* g_pPathFac = NULL;
IClassFactory* g_pQueryFact = NULL;
BOOL g_ShutdownCalled = FALSE;

extern "C" HRESULT APIENTRY Shutdown(BOOL bProcessShutdown, BOOL bIsSystemShutdown);
extern "C" HRESULT APIENTRY Reinitialize(DWORD dwReserved);

BOOL IsWhistlerPersonal ( ) ;
BOOL IsWhistlerProfessional ( ) ;
void UpdateArbitratorValues ( ) ;

//***************************************************************************
//
//  DllMain
//
//  Dll entry point function. Called when wbemcore.dll is loaded into memory.
//  Performs basic system initialization on startup and system shutdown on
//  unload. See ConfigMgr::InitSystem and ConfigMgr::Shutdown in cfgmgr.h for
//  more details.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hinstDLL;
        if (CStaticCritSec::anyFailure()) return FALSE;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DEBUGTRACE((LOG_WBEMCORE, "wbemcore!DllMain(DLL_PROCESS_DETACH)\n"));
#ifdef DBG
        if (!RtlDllShutdownInProgress())
        {
            if (!gClientCounter.OkToUnload()) DebugBreak();
        }
#endif /*DBG*/
    }
	else if ( dwReason == DLL_THREAD_ATTACH )
	{
		TlsSetValue(CCoreQueue::GetSecFlagTlsIndex(),(LPVOID)1);
	}

    return TRUE;
}



//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//  See Brockschmidt for details of IClassFactory interface.
//
//***************************************************************************

enum InitType {ENSURE_INIT, ENSURE_INIT_WAIT_FOR_CLIENT, OBJECT_HANDLES_OWN_INIT};

template<class TObj>
class CFactory : public IClassFactory
{

public:

    CFactory(BOOL bUser, InitType it);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
private:
    ULONG           m_cRef;
    InitType        m_it;
	BOOL            m_bUser;
    LIST_ENTRY      m_Entry;
};

/////////////////////////////////////////////////////////////////////////////
//
// Count number of objects and number of locks on this DLL.
//

ULONG g_cObj = 0;
ULONG g_cLock = 0;
long g_lInitCount = -1;  // 0 DURING INTIALIZATION, 1 OR MORE LATER ON!
static CWbemCriticalSection g_csInit;
bool g_bPreviousFail = false;
HRESULT g_hrLastEnsuredInitializeError = WBEM_S_NO_ERROR;

HRESULT EnsureInitialized()
{
    if(g_bPreviousFail)
        return g_hrLastEnsuredInitializeError;

	g_csInit.Enter();
	OnDeleteObjIf0<CWbemCriticalSection,
		          void (CWbemCriticalSection::*)(void),
		          &CWbemCriticalSection::Leave> LeaveMe(&g_csInit);

    // If we have been shut down by WinMgmt, bail out.
    if(g_bDontAllowNewConnections)
    {
        return CO_E_SERVER_STOPPING;
    }

	//Check again!  Previous connection could have been holding us off, and
	//may have failed!
    if(g_bPreviousFail)
        return g_hrLastEnsuredInitializeError;

    HRESULT hres;

    if(InterlockedIncrement(&g_lInitCount) == 0)
    {
        // Init Systems
        hres = ConfigMgr::InitSystem();

        if(FAILED(hres))
        {
            g_bPreviousFail = true;
            g_hrLastEnsuredInitializeError = hres;
            ConfigMgr::FatalInitializationError(hres);
            return hres;
        }

        LeaveMe.dismiss();
		g_csInit.Leave();
	
        // Get WINMGMT to run
        hres = ConfigMgr::SetReady();
        if(FAILED(hres))
        {
            g_bPreviousFail = true;
            g_hrLastEnsuredInitializeError = hres;
            ConfigMgr::FatalInitializationError(hres);
            return hres;
        }

        // if here, everything is OK
        g_bPreviousFail = false;
        g_hrLastEnsuredInitializeError = WBEM_S_NO_ERROR;

        InterlockedIncrement(&g_lInitCount);
    }
    else
    {
        InterlockedDecrement(&g_lInitCount);
    }

    return S_OK;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance. Before returning a class factory, this function performs an
//  additional round of initialization --- see ConfigMgr::SetReady in cfgmgr.h
//
//  PARAMETERS:
//
//      IN RECLSID rclsid   The CLSID of the object whose class factory is
//                          required.
//      IN REFIID riid      The interface required from the class factory.
//      OUT LPVOID* ppv     Destination for the class factory.
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    HRESULT         hr;

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    IClassFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (CLSID_InProcWbemLevel1Login == rclsid)
    {
        pFactory = new CFactory<CWbemLevel1Login>(TRUE, OBJECT_HANDLES_OWN_INIT);
    }
    else if(CLSID_ActualWbemAdministrativeLocator == rclsid)
    {
        pFactory = new CFactory<CWbemAdministrativeLocator>(FALSE, OBJECT_HANDLES_OWN_INIT);
    }
    else if(CLSID_ActualWbemAuthenticatedLocator == rclsid)
    {
        pFactory = new CFactory<CWbemAuthenticatedLocator>(TRUE, OBJECT_HANDLES_OWN_INIT);
    }
    else if(CLSID_ActualWbemUnauthenticatedLocator == rclsid)
    {
        pFactory = new CFactory<CWbemUnauthenticatedLocator>(TRUE, OBJECT_HANDLES_OWN_INIT);
    }
    else if(CLSID_IntProv == rclsid)
    {
        pFactory = new CFactory<CIntProv>(TRUE, ENSURE_INIT_WAIT_FOR_CLIENT);
    }
    else if(CLSID_IWmiCoreServices == rclsid)
    {
        pFactory = new CFactory<CCoreServices>(FALSE, ENSURE_INIT);
    }
    else
    {
        return E_FAIL;
    }

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    hr = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pFactory;

    return hr;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************
extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    DEBUGTRACE((LOG_WBEMCORE,"+ DllCanUnloadNow()\n"));
    if(!IsDcomEnabled())
        return S_FALSE;

    if(IsNtSetupRunning())
    {
        DEBUGTRACE((LOG_WBEMCORE, "- DllCanUnloadNow() returning S_FALSE because setup is running\n"));
        return S_FALSE;
    }
    if(gClientCounter.OkToUnload())
    {
         Shutdown(FALSE,FALSE); // NO Process , NO System

        DEBUGTRACE((LOG_WBEMCORE, "- DllCanUnloadNow() S_OK\n"));

        _DBG_ASSERT(gClientCounter.OkToUnload());
        return S_OK;
    }
    else
    {
        DEBUGTRACE((LOG_WBEMCORE, "- DllCanUnloadNow() S_FALSE\n"));
        return S_FALSE;
    }
}

//***************************************************************************
//
//  UpdateBackupReg
//
//  Updates the backup default options in registry.
//
//  RETURN VALUES:
//
//***************************************************************************
void UpdateBackupReg()
{
    HKEY hKey = 0;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, WBEM_REG_WINMGMT, &hKey) == ERROR_SUCCESS)   // SEC:REVIEWED 2002-03-22 : OK
    {
        char szBuff[20];
        DWORD dwSize = sizeof(szBuff);
        unsigned long ulType = REG_SZ;
        if ((RegQueryValueEx(hKey, __TEXT("Backup Interval Threshold"), 0, &ulType, (unsigned char*)szBuff, &dwSize) == ERROR_SUCCESS) && (strcmp(szBuff, "60") == 0))  // SEC:REVIEWED 2002-03-22 : OK
        {
            RegSetValueEx(hKey, __TEXT("Backup Interval Threshold"), 0, REG_SZ, (const BYTE*)(__TEXT("30")), (2+1) * sizeof(TCHAR));  // SEC:REVIEWED 2002-03-22 : OK
        }
        RegCloseKey(hKey);
    }
}

//***************************************************************************
//
//  UpdateBackupReg
//
//  Updates the unchecked task count value for the arbitrator.
//
//  RETURN VALUES:
//
//***************************************************************************
#define ARB_DEFAULT_TASK_COUNT_LESSTHAN_SERVER			50
#define ARB_DEFAULT_TASK_COUNT_GREATERHAN_SERVER		250

void UpdateArbitratorValues ()
{
    HKEY hKey = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WBEM_REG_WINMGMT, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)   // SEC:REVIEWED 2002-03-22 : OK
    {
		DWORD dwValue = 0 ;
		DWORD dwSize = sizeof (DWORD)  ;
        DWORD ulType = 0 ;
        if ((RegQueryValueEx(hKey, __TEXT("Unchecked Task Count"), 0, &ulType, LPBYTE(&dwValue), &dwSize) == ERROR_SUCCESS) )    // SEC:REVIEWED 2002-03-22 : OK
        {
			if ( !IsWhistlerPersonal ( ) && !IsWhistlerProfessional ( ) && ( dwValue == ARB_DEFAULT_TASK_COUNT_LESSTHAN_SERVER ) )
			{
				DWORD dwNewValue = ARB_DEFAULT_TASK_COUNT_GREATERHAN_SERVER ;
				RegSetValueEx(hKey, __TEXT("Unchecked Task Count"), 0, REG_DWORD, (const BYTE*)&dwNewValue, sizeof(DWORD));  // SEC:REVIEWED 2002-03-22 : OK
			}
        }
		else
		{
			//
			// Registry key non-existent
			//
			if ( !IsWhistlerPersonal ( ) && !IsWhistlerProfessional ( ) )
			{
				DWORD dwNewValue = ARB_DEFAULT_TASK_COUNT_GREATERHAN_SERVER ;
				RegSetValueEx(hKey, __TEXT("Unchecked Task Count"), 0, REG_DWORD, (const BYTE*)&dwNewValue, sizeof(DWORD));  // SEC:REVIEWED 2002-03-22 : OK
			}
			else
			{
				DWORD dwNewValue = ARB_DEFAULT_TASK_COUNT_LESSTHAN_SERVER ;
				RegSetValueEx(hKey, __TEXT("Unchecked Task Count"), 0, REG_DWORD, (const BYTE*)&dwNewValue, sizeof(DWORD));   // SEC:REVIEWED 2002-03-22 : OK
			}
		}
        RegCloseKey(hKey);
    }
}


//***************************************************************************
//
//  BOOL IsWhistlerPersonal ()
//
//  Returns true if machine is running Whistler Personal
//
//
//***************************************************************************
BOOL IsWhistlerPersonal ()
{
	BOOL bRet = TRUE ;
	OSVERSIONINFOEXW verInfo ;
	verInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFOEX ) ;

	if ( GetVersionExW ( (LPOSVERSIONINFOW) &verInfo ) == TRUE )
	{
		if ( ( verInfo.wSuiteMask != VER_SUITE_PERSONAL ) && ( verInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ) )
		{
			bRet = FALSE ;
		}
	}

	return bRet ;
}



//***************************************************************************
//
//  BOOL IsWhistlerProfessional ()
//
//  Returns true if machine is running Whistler Professional
//
//
//***************************************************************************
BOOL IsWhistlerProfessional ()
{
	BOOL bRet = TRUE ;
	OSVERSIONINFOEXW verInfo ;
	verInfo.dwOSVersionInfoSize = sizeof ( OSVERSIONINFOEX ) ;

	if ( GetVersionExW ( (LPOSVERSIONINFOW) &verInfo ) == TRUE )
	{
		if ( ( verInfo.wProductType  != VER_NT_WORKSTATION ) && ( verInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ) )
		{
			bRet = FALSE ;
		}
	}

	return bRet ;
}


//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    TCHAR* szModel = (IsDcomEnabled() ? __TEXT("Both") : __TEXT("Apartment"));

    RegisterDLL(g_hInstance, CLSID_ActualWbemAdministrativeLocator, __TEXT(""), szModel,
                NULL);
    RegisterDLL(g_hInstance, CLSID_ActualWbemAuthenticatedLocator, __TEXT(""), szModel, NULL);
    RegisterDLL(g_hInstance, CLSID_ActualWbemUnauthenticatedLocator, __TEXT(""), szModel, NULL);
    RegisterDLL(g_hInstance, CLSID_InProcWbemLevel1Login, __TEXT(""), szModel, NULL);
    RegisterDLL(g_hInstance, CLSID_IntProv, __TEXT(""), szModel, NULL);
    RegisterDLL(g_hInstance, CLSID_IWmiCoreServices, __TEXT(""), szModel, NULL);

    // Write the setup time into the registry.  This isnt actually needed
    // by dcom, but the code did need to be stuck in some place which
    // is called upon setup

    long lRes;
    DWORD ignore;
    HKEY key;
    lRes = RegCreateKeyEx(HKEY_LOCAL_MACHINE,   // SEC:REVIEWED 2002-03-22 : OK, inherits ACEs from higher key
                               WBEM_REG_WINMGMT,
                               NULL,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_READ | KEY_WRITE,
                               NULL,
                               &key,
                               &ignore);
    if(lRes == ERROR_SUCCESS)
    {
        SYSTEMTIME st;

        GetSystemTime(&st);     // get the gmt time
        TCHAR cTime[MAX_PATH];

        // convert to localized format!

        lRes = GetDateFormat(LOCALE_SYSTEM_DEFAULT, DATE_LONGDATE, &st,
                NULL, cTime, MAX_PATH);
        if(lRes)
        {
            StringCchCat(cTime, MAX_PATH, __TEXT(" GMT"));
            lRes = RegSetValueEx(key, __TEXT("SetupDate"), 0, REG_SZ,   // SEC:REVIEWED 2002-03-22 : OK
                                (BYTE *)cTime, (lstrlen(cTime)+1)  * sizeof(TCHAR));    // SEC:REVIEWED 2002-03-22 : OK
        }

        lRes = GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st,
                NULL, cTime, MAX_PATH);
        if(lRes)
        {
            StringCchCat(cTime, MAX_PATH, __TEXT(" GMT"));
            lRes = RegSetValueEx(key, __TEXT("SetupTime"), 0, REG_SZ,    // SEC:REVIEWED 2002-03-22 : OK
                                (BYTE *)cTime, (lstrlen(cTime)+1) * sizeof(TCHAR));   // SEC:REVIEWED 2002-03-22 : OK

        }

        CloseHandle(key);
    }

    UpdateBackupReg();

	UpdateArbitratorValues ( ) ;

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    UnRegisterDLL(CLSID_ActualWbemAdministrativeLocator, NULL);
    UnRegisterDLL(CLSID_ActualWbemAuthenticatedLocator, NULL);
    UnRegisterDLL(CLSID_ActualWbemUnauthenticatedLocator, NULL);
    UnRegisterDLL(CLSID_InProcWbemLevel1Login, NULL);
    UnRegisterDLL(CLSID_IntProv, NULL);
    UnRegisterDLL(CLSID_IWmiCoreServices, NULL);

    HKEY hKey;
    long lRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE,                      // SEC:REVIEWED 2002-03-22 : OK
                               WBEM_REG_WINMGMT,
                               0, KEY_ALL_ACCESS, &hKey);              // SEC:REVIEWED 2002-03-22 : OK
    if(lRes == ERROR_SUCCESS)
    {
        RegDeleteValue(hKey, __TEXT("SetupDate"));
        RegDeleteValue(hKey, __TEXT("SetupTime"));
        RegCloseKey(hKey);
    }

    return S_OK;
}

//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//***************************************************************************
template<class TObj>
CFactory<TObj>::CFactory(BOOL bUser, InitType it)
{
    m_cRef = 0;
    m_bUser = bUser;
    m_it = it;
    gClientCounter.AddClientPtr(&m_Entry);
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
template<class TObj>
CFactory<TObj>::~CFactory()
{
    gClientCounter.RemoveClientPtr(&m_Entry);
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
template<class TObj>
STDMETHODIMP CFactory<TObj>::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


template<class TObj>
ULONG CFactory<TObj>::AddRef()
{
    return ++m_cRef;
}


template<class TObj>
ULONG CFactory<TObj>::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}
//***************************************************************************
//
//  CFactory::CreateInstance
//
//  As mandated by IClassFactory, creates a new instance of its object
//  (CWbemLocator).
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//
//***************************************************************************

template<class TObj>
STDMETHODIMP CFactory<TObj>::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    TObj* pObj;
    HRESULT  hr;

    //  Defaults
    *ppvObj=NULL;

	if(m_it == ENSURE_INIT || m_it == ENSURE_INIT_WAIT_FOR_CLIENT)
	{
		hr = EnsureInitialized();
		if(FAILED(hr)) return hr;

		if(m_it == ENSURE_INIT_WAIT_FOR_CLIENT)
		{
			// Wait until user-ready
			hr = ConfigMgr::WaitUntilClientReady();
			if(FAILED(hr)) return hr;
		}
	}
    // We aren't supporting aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    pObj = new TObj;
    if (!pObj)
        return E_OUTOFMEMORY;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
template<class TObj>
STDMETHODIMP CFactory<TObj>::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}

void WarnESSOfShutdown(LONG lSystemShutDown)
{
    if(g_lInitCount != -1)
    {
        IWbemEventSubsystem_m4* pEss = ConfigMgr::GetEssSink();
        if(pEss)
        {
            pEss->LastCallForCore(lSystemShutDown);
            pEss->Release();
        }
    }
}

//
// we can have Shutdown called twice in a row, because
// DllCanUnloadNow will do that, once triggered by CoFreeUnusedLibraries
//

extern "C"
HRESULT APIENTRY Shutdown(BOOL bProcessShutdown, BOOL bIsSystemShutdown)
{
    CEnterWbemCriticalSection enterCs(&g_csInit);

    if (!bIsSystemShutdown)
    {
        DEBUGTRACE((LOG_WBEMCORE, " wbemcore!Shutdown(%d)"
        	                        "  g_ShutdownCalled = %d g_lInitCount = %d)\n",
                        bProcessShutdown, g_ShutdownCalled,g_lInitCount));
    }

    if (g_ShutdownCalled) {
        return S_OK;
    } else {
        g_ShutdownCalled = TRUE;
    }

    if(bProcessShutdown)
    {
        WarnESSOfShutdown((LONG)bIsSystemShutdown);
    }

    if(g_lInitCount == -1)
    {
        return S_OK;
    }

    if(!bProcessShutdown)
        WarnESSOfShutdown((LONG)bIsSystemShutdown);

    g_lInitCount = -1;

    ConfigMgr::Shutdown(bProcessShutdown,bIsSystemShutdown);

    if (!bIsSystemShutdown)
    {
	    DEBUGTRACE((LOG_WBEMCORE,"****** WinMgmt Shutdown ******************\n"));
    }
    return S_OK;
}

extern "C" HRESULT APIENTRY Reinitialize(DWORD dwReserved)
{

	if(g_ShutdownCalled)
	{
        CEnterWbemCriticalSection enterCs(&g_csInit);

        DEBUGTRACE((LOG_WBEMCORE, "wbemcore!Reinitialize(%d) (g_ShutdownCalled = %d)\n",
        	         dwReserved, g_ShutdownCalled));

        if(g_ShutdownCalled == FALSE)
        	return S_OK;
	    g_dwQueueSize = 1;
	    g_pEss_m4 = NULL;
	    g_lInitCount = -1;
	    g_bDefaultMofLoadingNeeded = false;
	    g_bDontAllowNewConnections = FALSE;
	    g_pContextFac = NULL;
	    g_pPathFac = NULL;
	    g_pQueryFact = NULL;
	    g_ShutdownCalled = FALSE;
		g_bPreviousFail = false;
		g_hrLastEnsuredInitializeError = WBEM_S_NO_ERROR;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\protoq.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PROTOQ.H

Abstract:

	Prototype query support for WinMgmt Query Engine.
    This was split out from QENGINE.CPP for better source
    organization.

History:

    raymcc   04-Jul-99   Created.
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/

#ifndef _PROTOQ_H_
#define _PROTOQ_H_

HRESULT ExecPrototypeQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQuery,
    IN IWbemContext* pContext,
    IN CBasicObjectSink *pSink
    );

//***************************************************************************
//
//  Local defs
//
//***************************************************************************


HRESULT SelectColForClass(
    IN CWQLScanner & Parser,
    IN CFlexArray *pClassDefs,
    IN SWQLColRef *pColRef,
    IN int & nPosition
    );

HRESULT AdjustClassDefs(
    IN  CFlexArray *pClassDefs,
    OUT IWbemClassObject **pRetNewClass
    );

HRESULT GetUnaryPrototype(
    IN CWQLScanner & Parser,
    IN LPWSTR pszClass,
    IN LPWSTR pszAlias,
    IN CWbemNamespace *pNs,
    IN IWbemContext *pContext,
    IN CBasicObjectSink *pSink
    );

HRESULT RetrieveClassDefs(
    IN CWQLScanner & Parser,
    IN CWbemNamespace *pNs,
    IN IWbemContext *pContext,
    IN CWStringArray & aAliasNames,
    OUT CFlexArray *pDefs
    );

HRESULT ReleaseClassDefs(
    IN CFlexArray *pDefs
    );

//***************************************************************************
//
//***************************************************************************

struct SelectedClass
{
    IWbemClassObject *m_pClassDef;
    WString           m_wsAlias;
    WString           m_wsClass;
    CWStringArray     m_aSelectedCols;
    BOOL              m_bAll;
    CFlexArray        m_aSelectedColsPos;

    int SetNamed(LPWSTR pName, int & nPos)
    {
        int SizeBeforeA = m_aSelectedCols.Size();
        int nRes;

        nRes = m_aSelectedCols.Add(pName);
        if (CFlexArray::no_error != nRes) return nRes;

#ifdef _WIN64
        nRes = m_aSelectedColsPos.Add(IntToPtr(nPos++));      // ok since we are really using safearray for dword
#else
        nRes = m_aSelectedColsPos.Add((void *)nPos++);
#endif
        if (CFlexArray::no_error != nRes)
        {
            m_aSelectedCols.RemoveAt(SizeBeforeA);
            nPos--;
            return nRes;
        }
        return CFlexArray::no_error;
    };

    int SetAll(int & nPos);
    SelectedClass() { m_pClassDef = 0; m_bAll = FALSE; }
   ~SelectedClass() { if (m_pClassDef) m_pClassDef->Release(); }
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\qengine.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    QENGINE.CPP

Abstract:

    WinMgmt Query Engine

History:

    raymcc   20-Dec-96  Created
    levn     97-98-99   Modified beyond comprehension
    raymcc   14-Aug-99  Ripped out and relocated assocs to happy new home
    raymcc   22-Apr-00  First mutations for new ProvSS

--*/

#include "precomp.h"

#include <stdio.h>
#include <stdlib.h>

#include <wbemcore.h>
#include <wbemstr.h>

#include <wbemmeta.h>
#include <analyser.h>
#include <genutils.h>
#include <DateTimeParser.h>
#include "stack.h"
#include <like.h>
#include "wmimerger.h"
#include <autoptr.h>
#include <wmiarbitrator.h>

//***************************************************************************
//
//  Local defs
//
//***************************************************************************

#define INVALID     0x3

//***************************************************************************
//
//***************************************************************************

CQlFilteringSink::CQlFilteringSink(
    CBasicObjectSink* pDest,
    ADDREF QL_LEVEL_1_RPN_EXPRESSION* pExpr,
    CWbemNamespace *pNamespace, BOOL bFilterNow
    )
    : CFilteringSink(pDest), m_pExpr(pExpr), m_bFilterNow(bFilterNow),
            m_pNs(pNamespace)
{
    // TBD: consider the query
    m_pExpr->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CQlFilteringSink::~CQlFilteringSink()
{
    m_pExpr->Release();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CQlFilteringSink::Indicate(
    long lObjectCount,
    IWbemClassObject** pObjArray
    )
{
    if(!m_bFilterNow)
        return m_pDest->Indicate(lObjectCount, pObjArray);

    return CFilteringSink::Indicate(lObjectCount, pObjArray);
}

BOOL CQlFilteringSink::Test(CWbemObject* pObj)
{
    return CQlFilteringSink::Test(pObj, m_pExpr, m_pNs); // this function throws
}

//***************************************************************************
//
//***************************************************************************

BOOL CQlFilteringSink::Test(
    CWbemObject* pObj,
    QL_LEVEL_1_RPN_EXPRESSION* pExpr,
    CWbemNamespace * pNs
    )
{
    CStack Stack;

    // If a pure 'select' with no 'where' clause, we always
    // return TRUE.
    // ====================================================
    if (pExpr->nNumTokens == 0)
        return TRUE;

    for (int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Tok = pExpr->pArrayOfTokens[i];

        if (Tok.nTokenType == QL_LEVEL_1_TOKEN::TOKEN_AND)
        {
            BOOL b1 = (BOOL) Stack.Pop();
            BOOL b2 = (BOOL) Stack.Pop();
            if (b1 == TRUE && b2 == TRUE)
                Stack.Push(TRUE);           
            else if (b1 == INVALID || b2 == INVALID)
                Stack.Push(INVALID);      
            else
                Stack.Push(FALSE);         
        }
        else if (Tok.nTokenType == QL_LEVEL_1_TOKEN::TOKEN_OR)
        {
            BOOL b1 = (BOOL) Stack.Pop();
            BOOL b2 = (BOOL) Stack.Pop();
            if (b1 == TRUE || b2 == TRUE)
                Stack.Push(TRUE);          
            else if (b1 == INVALID || b2 == INVALID)
                Stack.Push(INVALID);     
            else
                Stack.Push(FALSE);        
        }
        else if (Tok.nTokenType == QL_LEVEL_1_TOKEN::TOKEN_NOT)
        {
            BOOL b1 = (BOOL) Stack.Pop();
            if (b1 == TRUE)
                Stack.Push(FALSE);        
            else if (b1 == INVALID)
                Stack.Push(INVALID);    
            else
                Stack.Push(TRUE);         
        }
        else if (Tok.nTokenType == QL_LEVEL_1_TOKEN::OP_EXPRESSION)
        {
            Stack.Push(EvaluateToken(pObj, Tok, pNs));
        }
    }

    // Pop top element, which becomes the return value.
    // ================================================

    int nRes = Stack.Pop();

    if (nRes == INVALID)
        return FALSE;

    return (BOOL) nRes;
}


//***************************************************************************
//
//***************************************************************************

int CQlFilteringSink::EvaluateToken(
    IWbemPropertySource *pTestObj,
    QL_LEVEL_1_TOKEN& Tok,
    CWbemNamespace * pNs
    )
{
    _variant_t PropVal, CompVal;

    WBEM_WSTR wszCimType, wszCimType2;
    HRESULT hRes;

    // Special-case 'this'
    // ===================

    if(Tok.PropertyName.GetNumElements() == 1 &&
        !wbem_wcsicmp(Tok.PropertyName.GetStringAt(0), L"__THIS"))
    {
        wszCimType = WbemStringCopy(L"object");
        V_VT(&PropVal) = VT_UNKNOWN;
        hRes = pTestObj->QueryInterface(IID_IWbemClassObject,
                                            (void**)&V_UNKNOWN(&PropVal));
    }
    else
    {
        hRes = pTestObj->GetPropertyValue(&Tok.PropertyName, 0,
                                                &wszCimType, &PropVal);
    }
    if (FAILED(hRes)) return FALSE;
    OnDelete<WBEM_WSTR,void(*)(WBEM_WSTR),WbemStringFree> wsf(wszCimType);

    // Handle a property-to-property comparison,

    if (Tok.m_bPropComp != FALSE)
    {
        hRes = pTestObj->GetPropertyValue(&Tok.PropertyName2, 0,
                                                &wszCimType2, &CompVal);
        if (FAILED(hRes))
            return FALSE;
    }
    else
    {
        if ( FAILED (VariantCopy(&CompVal, &Tok.vConstValue)) )
            return FALSE;
    }

    // Handle NULLs
    // ============

    if(V_VT(&PropVal) == VT_NULL)
    {
        if(V_VT(&CompVal) == VT_NULL)
        {
            if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
                return TRUE;
            else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
                return FALSE;
            else
                return INVALID;
        }
        else
        {
            if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
                return FALSE;
            else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
                return TRUE;
            else
                return INVALID;
        }
    }
    else if(V_VT(&CompVal) == VT_NULL)
    {
        if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
            return FALSE;
        else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
            return TRUE;
        else
            return INVALID;
    }

    // Handle references
    // =================

    if(wszCimType &&
        wbem_wcsnicmp(wszCimType, L"ref", 3) == 0 &&
        (wszCimType[3] == 0 || wszCimType[3] == L':'))
    {
        // This is a reference. The only operators allowed are = and !=
        // ============================================================

        if(PropVal.vt != VT_BSTR || PropVal.bstrVal == NULL)
            return INVALID;
        if(CompVal.vt != VT_BSTR || CompVal.bstrVal == NULL)
            return INVALID;
        WCHAR * va = CQueryEngine::NormalizePath(V_BSTR(&PropVal), pNs);
        CVectorDeleteMe<WCHAR> del_va(va);
        WCHAR * vb = CQueryEngine::NormalizePath(V_BSTR(&CompVal), pNs);
        CVectorDeleteMe<WCHAR> del_vb(vb);        

        if(va == NULL || vb == NULL)
        {
            ERRORTRACE((LOG_WBEMCORE, "Invalid path %S or %S specified in an association\n", V_BSTR(&PropVal), V_BSTR(&CompVal)));
            return INVALID;
        }

        int nRet;
        switch (Tok.nOperator)
        {
        case QL_LEVEL_1_TOKEN::OP_EQUAL:
            nRet = (wbem_wcsicmp(va,vb) == 0);
            break;
        case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
            nRet = (wbem_wcsicmp(va, vb) != 0);
            break;
        default:
            nRet = INVALID;
            break;
        }
        return nRet;
    }


    // Check if ISA is used
    // ====================

    if(Tok.nOperator == QL1_OPERATOR_ISA ||
       Tok.nOperator == QL1_OPERATOR_ISNOTA ||
       Tok.nOperator == QL1_OPERATOR_INV_ISA ||
       Tok.nOperator == QL1_OPERATOR_INV_ISNOTA)
    {
        // Account for inversion
        // =====================

        VARIANT* pv1;
        VARIANT* pv2;
        int bNeedDerived;

        if(Tok.nOperator == QL1_OPERATOR_ISA ||
           Tok.nOperator == QL1_OPERATOR_ISNOTA)
        {
            pv2 = &CompVal;
            pv1 = &PropVal;
            bNeedDerived = (Tok.nOperator == QL1_OPERATOR_ISA);
        }
        else
        {
            pv1 = &CompVal;
            pv2 = &PropVal;
            bNeedDerived = (Tok.nOperator == QL1_OPERATOR_INV_ISA);
        }

        // The second argument has to be a string
        // ======================================

        if(V_VT(pv2) != VT_BSTR)
        {
            return INVALID;
        }

        BSTR strParentClass = V_BSTR(pv2);

        // The first argument has to be an object or a string
        // ==================================================

        BOOL bDerived;
        if(V_VT(pv1) == VT_EMBEDDED_OBJECT)
        {
            IWbemClassObject* pObj = (IWbemClassObject*)V_EMBEDDED_OBJECT(pv1);
            bDerived = (pObj->InheritsFrom(strParentClass) == WBEM_S_NO_ERROR);
        }
        else if(V_VT(pv1) == VT_BSTR)
        {
            // TBD
            // ===

            return INVALID;
        }
        else
        {
            return INVALID;
        }

        // Now that we have bDerived, see if it matches the requirement
        // ============================================================

        if(bDerived == bNeedDerived)
            return TRUE;
        else
            return FALSE;

    }

    // Perform UINT32 workaround
    // =========================

    if(wszCimType && !wbem_wcsicmp(wszCimType, L"uint32") &&
        V_VT(&PropVal) == VT_I4)
    {
        DWORD dwVal = (DWORD)V_I4(&PropVal);
        WCHAR wszVal[20];
        StringCchPrintfW(wszVal, 20, L"%lu", dwVal);
        BSTR bstrTmp = SysAllocString(wszVal);
        if (bstrTmp)
        {
            V_VT(&PropVal) = VT_BSTR;
            V_BSTR(&PropVal) = bstrTmp;
        }
        else
        {
            V_VT(&PropVal) = VT_NULL;
        }
    }

    if(wszCimType &&
            (!wbem_wcsicmp(wszCimType, L"sint64") ||
             !wbem_wcsicmp(wszCimType, L"uint64") ||
             !wbem_wcsicmp(wszCimType, L"uint32")) &&
        V_VT(&CompVal) != VT_NULL && V_VT(&PropVal) != VT_NULL)
    {
        BOOL bUnsigned = (wbem_wcsicmp(wszCimType, L"uint64") == 0);

        // We have a 64-bit comparison where both sides are present.
        // =========================================================

        hRes = VariantChangeType(&CompVal, &CompVal, 0,
                                    VT_BSTR);
        if(FAILED(hRes))
        {
            return INVALID;
        }

        if(bUnsigned)
        {
            unsigned __int64 ui64Prop, ui64Const;

            if(!ReadUI64(V_BSTR(&PropVal), ui64Prop))
                return INVALID;

            if(!ReadUI64(V_BSTR(&CompVal), ui64Const))
                return INVALID;

            switch (Tok.nOperator)
            {
                case QL_LEVEL_1_TOKEN::OP_EQUAL: return (ui64Prop == ui64Const);
                case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                    return (ui64Prop != ui64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                    return (ui64Prop >= ui64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                    return (ui64Prop <= ui64Const);
                case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                    return (ui64Prop < ui64Const);
                case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                    return (ui64Prop > ui64Const);
                case QL_LEVEL_1_TOKEN::OP_LIKE: return (ui64Prop == ui64Const);
            }
            return INVALID;
        }
        else
        {
            __int64 i64Prop, i64Const;

            if(!ReadI64(V_BSTR(&PropVal), i64Prop))
                return INVALID;

            if(!ReadI64(V_BSTR(&CompVal), i64Const))
                return INVALID;

            switch (Tok.nOperator)
            {
                case QL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
                case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                    return (i64Prop != i64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                    return (i64Prop >= i64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                    return (i64Prop <= i64Const);
                case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                    return (i64Prop < i64Const);
                case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                    return (i64Prop > i64Const);
                case QL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
            }
            return INVALID;
        }
    }

    if(wszCimType && !wbem_wcsicmp(wszCimType, L"char16") &&
        V_VT(&CompVal) == VT_BSTR && V_VT(&PropVal) != VT_NULL)
    {
        // Coerce strings correctly
        // ========================

        BSTR str = V_BSTR(&Tok.vConstValue);
        if (wcslen(str) != 1)  // SEC:REVIEWED 2002-03-22 : OK, provably recognized by lexer
            return INVALID;

        short va = V_I2(&PropVal);
        short vb = str[0];

        switch (Tok.nOperator)
        {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
            case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
        }

        return INVALID;
    }

    if(wszCimType &&
            (!wbem_wcsicmp(wszCimType, L"datetime")) &&
        V_VT(&CompVal) == VT_BSTR && V_VT(&PropVal) == VT_BSTR)
    {
        // Parse the constant specified in the query according to the
        // SQL rules
        // ==========================================================

        TCHAR *tszBuffer;
         tszBuffer = V_BSTR(&CompVal);
        CDateTimeParser dtConst(tszBuffer);

        if(!dtConst.IsValidDateTime())
            return INVALID;

        WCHAR wszConstValDMTF[26];
        dtConst.FillDMTF(wszConstValDMTF, 26);

        // Read both DMTF values and parse them
        // ====================================

        CWbemTime wtConst, wtProp;
        if(!wtConst.SetDMTF(wszConstValDMTF))
            return INVALID;
        if(!wtProp.SetDMTF(V_BSTR(&PropVal)))
            return INVALID;

        __int64 i64Const = wtConst.Get100nss();
        __int64 i64Prop = wtProp.Get100nss();

        switch (Tok.nOperator)
        {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                return (i64Prop != i64Const);
            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                return (i64Prop >= i64Const);
            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                return (i64Prop <= i64Const);
            case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                return (i64Prop < i64Const);
            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                return (i64Prop > i64Const);
            case QL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
        }
    }

    // Coerce types to match.
    // ======================


    if(V_VT(&CompVal) != VT_NULL && V_VT(&PropVal) != VT_NULL)
    {
    // Compensate for VT_UI1 > VT_I4
    //
          if (V_VT(&CompVal) == VT_UI1 && V_VT(&PropVal) !=VT_UI1)
      hRes = VariantChangeType(&CompVal,&CompVal,0, VT_I4);

    if (V_VT(&PropVal) == VT_UI1 && V_VT(&CompVal) !=VT_UI1)
      hRes = VariantChangeType(&PropVal,&PropVal,0, VT_I4);

    if (V_VT(&PropVal) > V_VT(&CompVal))
            hRes = VariantChangeType(&CompVal, &CompVal, 0, V_VT(&PropVal));
        else
            hRes = VariantChangeType(&PropVal, &PropVal, 0, V_VT(&CompVal));
        if(FAILED(hRes))
        {
            return INVALID;
        }
    }


    switch (V_VT(&CompVal))
    {
        case VT_NULL:
            return INVALID; // handled above

        case VT_I4:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                LONG va = V_I4(&PropVal);
                LONG vb = V_I4(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_I2:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                short va = V_I2(&PropVal);
                short vb = V_I2(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_UI1:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                BYTE va = V_I1(&PropVal);
                BYTE vb = V_I1(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_BSTR:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                LPWSTR va = (LPWSTR) V_BSTR(&PropVal);
                LPWSTR vb = (LPWSTR) V_BSTR(&CompVal);

                int retCode = 0;
                BOOL bDidIt = TRUE;

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL:
                        retCode = ( wbem_wcsicmp(va,vb) == 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                        retCode = (wbem_wcsicmp(va, vb) != 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                        retCode = (wbem_wcsicmp(va, vb) >= 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                        retCode = (wbem_wcsicmp(va, vb) <= 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                        retCode = (wbem_wcsicmp(va, vb) < 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                        retCode = (wbem_wcsicmp(va, vb) > 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_LIKE:
                        {
                            CLike l (vb);
                            retCode = (int)l.Match(va);
                        }
                        break;
                    default:
                        bDidIt = FALSE;
                        break;
                }
                VariantClear(&CompVal);
                if (bDidIt)
                {
                    return retCode;
                }
            }
            break;

        case VT_R8:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                double va = V_R8(&PropVal);
                double vb = V_R8(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_R4:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                float va = V_R4(&PropVal);
                float vb = V_R4(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_BOOL:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                VARIANT_BOOL va = V_BOOL(&PropVal);
                if(va != VARIANT_FALSE) va = VARIANT_TRUE;
                VARIANT_BOOL vb = V_BOOL(&CompVal);
                if(vb != VARIANT_FALSE) vb = VARIANT_TRUE;

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;
    }

    return FALSE;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CQlFilteringSink::SetStatus(
    long lFlags,
    long lParam,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
    if(lFlags == WBEM_STATUS_REQUIREMENTS)
    {
        m_bFilterNow = (lParam == S_OK);
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return CFilteringSink::SetStatus(lFlags, lParam, strParam, pObjParam);
    }
}



//***************************************************************************
//
//***************************************************************************

CProjectingSink::CProjectingSink(
    CBasicObjectSink* pDest,
    CWbemClass* pClassDef,
    READONLY QL_LEVEL_1_RPN_EXPRESSION* pExp,
    long lQueryFlags
    )
    : CForwardingSink(pDest, 0), m_bValid(FALSE), m_bProjecting(FALSE)
{
    // Extract the properties selected by the user.
    // ============================================

    CWStringArray awsPropList;
    for (int i = 0; i < pExp->nNumberOfProperties; i++)
    {
        CPropertyName& PropName = pExp->pRequestedPropertyNames[i];
        LPWSTR wszPrimaryName = CQueryEngine::GetPrimaryName(PropName);

        if (wszPrimaryName && !wbem_wcsicmp(wszPrimaryName, L"count(*)"))
        {
            m_bValid = TRUE;
            m_bProjecting = FALSE;
            return;
        }

        // Check for complexity
        // ====================

        if(PropName.GetNumElements() > 1)
        {
            // Complex --- make sure the property is an object
            // ===============================================

            CIMTYPE ct;
            if(FAILED(pClassDef->GetPropertyType(wszPrimaryName, &ct)) ||
                ct != CIM_OBJECT)
            {
                m_wsError = wszPrimaryName;
                return;
            }
        }

        if (CFlexArray::no_error != awsPropList.Add(wszPrimaryName))
        {
            return;
        }
    }

    if (awsPropList.Size() == 0)
    {
        m_bValid = TRUE;
        return;
    }

    if(lQueryFlags & WBEM_FLAG_ENSURE_LOCATABLE)
    {
        if (CFlexArray::no_error != awsPropList.Add(L"__PATH"))
        {
            return;            
        };
    }


    // Verify that the projection will succeed.
    // ========================================

    m_wsError = pClassDef->FindLimitationError(0, &awsPropList);
    if(m_wsError.Length() > 0)
        return;

    // Check for *
    // ===========

    if(pExp->bStar)
    {
        m_bValid = TRUE;
        return;
    }

    // Map the limitaiton
    // ==================

    m_bValid = pClassDef->MapLimitation(0, &awsPropList, &m_Map);
    m_bProjecting = TRUE;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CProjectingSink::Indicate(
    long lObjectCount,
    IWbemClassObject** pObjArray
    )
{
    if(!m_bProjecting)
        return m_pDest->Indicate(lObjectCount, pObjArray);

    wmilib::auto_buffer<IWbemClassObject*> apNewArray(new IWbemClassObject*[lObjectCount]);
    if (NULL == apNewArray.get())
        return WBEM_E_OUT_OF_MEMORY;
    HRESULT hres;
    int i;

    {
        CInCritSec ics(&m_cs);  // SEC:REVIEWED 2002-03-22 : Assumes entry

        for(i = 0; i < lObjectCount; i++)
        {
            CWbemInstance* pInst = (CWbemInstance*)pObjArray[i];
            CWbemInstance* pNewInst;

            hres = pInst->GetLimitedVersion(&m_Map, &pNewInst);
            if(FAILED(hres))
            {
                for(int j = 0; j < i; j++)
                    apNewArray[j]->Release();
                return hres;
            }
            apNewArray[i] = pNewInst;
        }
    }

    hres = m_pDest->Indicate(lObjectCount, (IWbemClassObject**)apNewArray.get());

    for(i = 0; i < lObjectCount; i++)
        apNewArray[i]->Release();

    return hres;
}




//***************************************************************************
//
//  class CMerger
//
//  This class is a 'reverse fork'.  It consumes two sinks and outputs
//  one.  Its purpose is to merge instances of the same key in a given
//  dynasty.  Each CMerger has two inputs, (a) instances of the class
//  in question, (b) instances of from another Merger representing
//  instances of subclasses.  Given classes A,B:A,C:B, for example,
//  where "<--" is a sink:
//
//      | own:Instances of A
//  <---|                 | own:Instances of B
//      | child: <--------|
//                        | child:Instances of C
//
//
//  The two input sinks for CMerger are <m_pOwnSink> which receives
//  instances from the provider for "A", for example, and the <m_pChildSink>
//  which receives instances from the underyling Merger.
//
//  The mergers operate asynchronously to each other.  Therefore,
//  the instances for A may arrive in its CMerger sink before instances
//  of the child classes have arrived in theirs.
//
//  As objects arrive in the owning CMerger for a class, AddOwnObject()
//  is called.  As objects arrive from a child sink, AddChildObject()
//  is called.  In either case, if the object with a given key
//  arrives for the first time, it is simply added to the map. If
//  it is already there (via a key lookup), then a merge is performed
//  via CWbemInstance::AsymmetricMerge.  Immediately after this merge,
//  the object is dispatched up to the next parent sink via the parent's
//  AddChildObject and removed from the map.
//
//  Note that in a class hierarchy {A,B:A,C:B} an enumeration/query is
//  performed only against the classes in the CDynasty referenced in
//  the query. This logic occurs in CQueryEngine::EvaluateSubQuery.
//  For example, if "select * from B" is the query, only queries
//  for B and C are performed.  The CMerger logic will do individual
//  'get object' calls for any instances needed in A to complete
//  the merged B/C instances while merging is taking place.
//
//***************************************************************************


typedef map<WString, CMerger::CRecord, WSiless, wbem_allocator<CMerger::CRecord> >::iterator TMapIterator;

#pragma warning(disable:4355)

CMerger::CMerger(
    CBasicObjectSink* pDest,
    CWbemClass* pOwnClass,
    CWbemNamespace* pNamespace,
    IWbemContext* pContext
    )
    :   m_pDest(pDest), m_bOwnDone(FALSE),
        m_bChildrenDone(FALSE), m_pNamespace(pNamespace), m_pContext(pContext),
        m_pOwnClass(pOwnClass), m_bDerivedFromTarget(TRUE), m_lRef(0),
        m_pSecurity(NULL)
{

    m_pOwnSink = new COwnSink(this);
    m_pChildSink = new CChildSink(this);

    // IsValid will check for these allocation failures

    m_pDest->AddRef();
    if(m_pContext)
        m_pContext->AddRef();
    if(m_pNamespace)
        m_pNamespace->AddRef();

    if(m_pOwnClass)
    {
        m_pOwnClass->AddRef();
        CVar v;
        pOwnClass->GetClassName(&v);
        m_wsClass = v.GetLPWSTR();
    }

    // Retrieve call security. Need to create a copy for use on another thread
    // =======================================================================

    m_pSecurity = CWbemCallSecurity::MakeInternalCopyOfThread();
}

//***************************************************************************
//
//***************************************************************************

CMerger::~CMerger()
{
    m_pDest->Release();
    if(m_pNamespace)
        m_pNamespace->Release();
    if(m_pContext)
        m_pContext->Release();
    if(m_pOwnClass)
        m_pOwnClass->Release();
    delete m_pOwnSink;
    delete m_pChildSink;

    if(m_pSecurity)
        m_pSecurity->Release();
}
//***************************************************************************
//
//***************************************************************************

long CMerger::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//***************************************************************************

long CMerger::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//***************************************************************************

void CMerger::GetKey(IWbemClassObject* pObj, WString& wsKey)
{
    LPWSTR wszRelPath = ((CWbemInstance*)pObj)->GetRelPath();
    if (wszRelPath == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Object with no path submitted to a "
                        "merge\n"));
        wsKey.Empty();
        return;
    }

    WCHAR* pwcDot = wcschr(wszRelPath, L'.');
    if (pwcDot == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "Object with invalid path %S submitted to a "
                        "merge\n", wszRelPath));
        wsKey.Empty();

        // Clean up the path
        delete [] wszRelPath;

        return;
    }

    wsKey = pwcDot+1;
    delete [] wszRelPath;
}

//***************************************************************************
//
//***************************************************************************

void CMerger::SetIsDerivedFromTarget(BOOL bIs)
{
    m_bDerivedFromTarget = bIs;

    if (!bIs)
    {
        // We will need our OwnSink for GetObject calls
        // ============================================

        m_pOwnSink->AddRef();
    }
}

//***************************************************************************
//
//***************************************************************************

HRESULT CMerger::AddOwnObject(IWbemClassObject* pObj)
{
    WString wsKey;
    GetKey(pObj, wsKey);

    CInCritSec ics(&m_cs); // SEC:REVIEWED 2002-03-22 : Assumes entry

    TMapIterator it = m_map.find(wsKey);
    if (it == m_map.end())
    {
        // Not there. Check if there is any hope for children
        // ==================================================

        if (m_bChildrenDone)
        {
            if (m_bDerivedFromTarget)
            {
                // forward
                m_pDest->Add(pObj);
            }
            else
            {
                // ignore
            }
        }
        else
        {
            try
            {
                // Insert
                CRecord& rRecord = m_map[wsKey];
                rRecord.m_pData = (CWbemInstance*) pObj;
                pObj->AddRef();
                rRecord.m_bOwn = TRUE;
            }
            catch( CX_Exception &)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
    else
    {
        // Attempt to merge
        // ================

        HRESULT hres = CWbemInstance::AsymmetricMerge(
                            (CWbemInstance*)pObj,
                            (CWbemInstance*)it->second.m_pData);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Merge conflict for instances with "
                "key %S\n", wsKey));
        }

        // Dispatch the result!
        // ====================

        m_pDest->Add(it->second.m_pData);
        it->second.m_pData->Release();
        m_map.erase(it);
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CMerger::AddChildObject(IWbemClassObject* pObj)
{
    HRESULT hRes = S_OK ;

    WString wsKey;
    GetKey(pObj, wsKey);

    CInCritSec ics(&m_cs); // SEC:REVIEWED 2002-03-22 : Assumes entry

    TMapIterator it = m_map.find(wsKey);

    if (it == m_map.end())
    {
        // Check if there is any hope for parent
        // =====================================

        if(m_bOwnDone)
        {
            BSTR str = NULL;
            pObj->GetObjectText(0, &str);

            // The following was commented out because it actually incorrectly logs
            // an error if the child provider enumerates when the parent provider
            // interprets a query and returns fewer instances.  Neither provider is wrong,
            // but this error message causes needless worry.  In Quasar, we have to fix
            // this whole merger thing to be smarter anyway.
            //
            // ERRORTRACE((LOG_WBEMCORE, "[Chkpt_1] [%S] Orphaned object %S returned by "
            //    "provider\n", LPWSTR(m_wsClass), str));
            SysFreeString(str);
            // m_pDest->Add(pObj);
        }
        else
        {
            // insert

            try
            {
                CRecord& rRecord = m_map[wsKey];
                rRecord.m_pData = (CWbemInstance*)pObj;
                pObj->AddRef();
                rRecord.m_bOwn = FALSE;

                // Check if parent's retrieval is needed
                // =====================================

                if (!m_bDerivedFromTarget)
                {

                    try
                    {
                        GetOwnInstance(wsKey);
                    }
                    catch( CX_MemoryException &)
                    {
                        hRes = WBEM_E_OUT_OF_MEMORY;
                    }
                    catch (...)
                    {
                        ExceptionCounter c;                    
                        hRes = WBEM_E_CRITICAL_ERROR;
                    }

/*
 *    return here because exclusion area has already been exited.
 */
                    return hRes ;
                }
            }
            catch( CX_MemoryException &)
            {
                hRes = WBEM_E_OUT_OF_MEMORY;
            }
            catch(...)
            {
                ExceptionCounter c;
                hRes = WBEM_E_CRITICAL_ERROR;
            }
         }
    }
    else if(!it->second.m_bOwn)
    {
        ERRORTRACE((LOG_WBEMCORE, "Two providers supplied conflicting "
                        "instances for key %S\n", wsKey));
    }
    else
    {
        // Attempt to merge
        // ================

        IWbemClassObject* pClone;
        HRESULT hres = pObj->Clone(&pClone);
        if (FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Clone failed in AddChildObject, hresult is 0x%x",
                hres));
            return hres;
        }
        hres = CWbemInstance::AsymmetricMerge(
                                    (CWbemInstance*)it->second.m_pData,
                                    (CWbemInstance*)pClone
                                    );
        if (FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Merge conflict for instances with "
                "key %S\n", wsKey));
        }

        // Dispatch the result!
        // ====================

        m_pDest->Add(pClone);
        pClone->Release();
        it->second.m_pData->Release();
        m_map.erase(it);
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

void CMerger::DispatchChildren()
{
    TMapIterator it = m_map.begin();

    while (it != m_map.end())
    {
        if (!it->second.m_bOwn)
        {
            BSTR str = NULL;
            it->second.m_pData->GetObjectText(0, &str);

            // The following was commented out because it actually incorrectly logs
            // an error if the child provider enumerates when the parent provider
            // interprets a query and returns fewer instances.  Neither provider is wrong,
            // but this error message causes needless worry.  In Quasar, we have to fix
            // this whole merger thing to be smarter anyway.
            //

//            ERRORTRACE((LOG_WBEMCORE, "Chkpt2 [%S] Orphaned object %S returned by "
//                "provider\n", LPWSTR(m_wsClass), str));

            SysFreeString(str);

            // m_pDest->Add(it->second.m_pData);

            it->second.m_pData->Release();
            it = m_map.erase(it);
        }
        else it++;
    }
}

//***************************************************************************
//
//***************************************************************************

void CMerger::DispatchOwn()
{
    if(!m_bDerivedFromTarget)
        return;

    try
    {

        TMapIterator it = m_map.begin();

        while (it != m_map.end())
        {
            if(it->second.m_bOwn)
            {
                m_pDest->Add(it->second.m_pData);
                it->second.m_pData->Release();
                it = m_map.erase(it);
            }
            else it++;
        }
    }
    catch(...)
    {
        ExceptionCounter c;    
    }
}

//***************************************************************************
//
//***************************************************************************


// SEC:REVIEWED 2002-03-22 : This whole function needs a rewrite

void CMerger::GetOwnInstance(LPCWSTR wszKey)
{
    size_t tmpLength = wcslen(wszKey) + m_wsClass.Length() + 2;   // SEC:REVIEWED 2002-03-22 : Needs EH
    WCHAR * wszPath = new WCHAR[tmpLength];
    CVectorDeleteMe<WCHAR> dm(wszPath);
    if (wszPath && wcslen(wszKey))                                // SEC:REVIEWED 2002-03-22 : Needs EH
    {
        StringCchPrintf(wszPath, tmpLength, L"%s.%s", (LPCWSTR)m_wsClass, wszKey);
        {
            HRESULT hr;
            IServerSecurity * pSec = NULL;
            hr = CoGetCallContext(IID_IServerSecurity,(void **)&pSec);
            CReleaseMe rmSec(pSec);
            if (RPC_E_CALL_COMPLETE == hr ) hr = S_OK; // no call context
            if (FAILED(hr)) return;
            BOOL bImper = (pSec)?pSec->IsImpersonating():FALSE;
            if (pSec && bImper && FAILED(hr = pSec->RevertToSelf())) return;

            // implant a call context
            IUnknown* pOld;
            // fails only if COM not initialized on the thread
            if (FAILED(CoSwitchCallContext(m_pSecurity, &pOld))) return;     

            hr = m_pNamespace->DynAux_GetSingleInstance(m_pOwnClass, 0, wszPath,m_pContext, m_pOwnSink);

            // remove the planted call context
            IUnknown* pThis;
            CoSwitchCallContext(pOld, &pThis);    

            if (bImper && pSec)
            {
                HRESULT hrInner = pSec->ImpersonateClient();
                if (FAILED(hrInner)) throw CX_Exception();
            }
        }
    }
}

//***************************************************************************
//
//***************************************************************************

void CMerger::OwnIsDone()
{
    m_bOwnDone = TRUE;
    m_pOwnSink = NULL;
}

//***************************************************************************
//
//***************************************************************************

void CMerger::ChildrenAreDone()
{
    m_bChildrenDone = TRUE;
    m_pChildSink = NULL;
    if(!m_bDerivedFromTarget)
    {
        // Don't need that ref count on pOwnSink anymore
        // =============================================

        m_pOwnSink->Release();
    }
}

//***************************************************************************
//
//***************************************************************************


STDMETHODIMP CMerger::CMemberSink::
SetStatus(long lFlags, long lParam, BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == 0 && lParam == WBEM_E_NOT_FOUND)
        lParam = WBEM_S_NO_ERROR;

    // Propagate error to error combining sink
    // =======================================

    return m_pMerger->m_pDest->SetStatus(lFlags, lParam, strParam,
                                                pObjParam);
}

//***************************************************************************
//
//***************************************************************************

CMerger::COwnSink::~COwnSink()
{
    m_pMerger->Enter();
    m_pMerger->DispatchChildren();
    m_pMerger->OwnIsDone();
    if (m_pMerger->Release())
        m_pMerger->Leave();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CMerger::COwnSink::
Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    for(long l = 0; SUCCEEDED( hr ) && l < lNumObjects; l++)
    {
        hr = m_pMerger->AddOwnObject(apObjects[l]);
    }

    return hr;
}

//***************************************************************************
//
//***************************************************************************

CMerger::CChildSink::~CChildSink()
{
    m_pMerger->Enter();
    m_pMerger->DispatchOwn();
    m_pMerger->ChildrenAreDone();
    if(m_pMerger->Release())
        m_pMerger->Leave();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CMerger::CChildSink::Indicate(long lNumObjects, IWbemClassObject** apObjects)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    for (long l = 0; SUCCEEDED( hr ) && l < lNumObjects; l++)
    {
        hr = m_pMerger->AddChildObject(apObjects[l]);
    }

    return hr;
}


//***************************************************************************
//
//***************************************************************************

CProjectionRule* CProjectionRule::Find(LPCWSTR wszName)
{
    for(int i = 0; i < m_apPropRules.GetSize(); i++)
    {
        if(!wbem_wcsicmp(m_apPropRules[i]->m_wsPropName, wszName))
            return m_apPropRules[i];
    }
    return NULL;
}

//***************************************************************************
//
//***************************************************************************

CComplexProjectionSink::CComplexProjectionSink(CBasicObjectSink* pDest,
                        CWQLScanner * pParser)
        : CForwardingSink(pDest)
{
    m_TopRule.m_eType = CProjectionRule::e_TakePart;

    bool bFirstTableEntry = true;

    CWStringArray awsTables;
    pParser->GetReferencedAliases(awsTables);
    WString wsPrefix;
    if(awsTables.Size() == 0)
    {
        m_TopRule.m_eType = CProjectionRule::e_TakeAll;
        return;
    }
    else if(awsTables.Size() == 1)
    {
        wsPrefix = awsTables[0]; // throw
    }

    // Extract projection rules from the parser
    // ========================================

    const CFlexArray* papColumns = pParser->GetSelectedColumns();
    if(papColumns == NULL)
        return;

    for(int i = 0; i < papColumns->Size(); i++)
    {
        SWQLColRef* pColRef = (SWQLColRef*)papColumns->GetAt(i);
        if(pColRef->m_dwFlags & WQL_FLAG_ASTERISK)
        {
            m_TopRule.m_eType = CProjectionRule::e_TakeAll;
        }
        else
        {
            LPWSTR pPrefix = NULL;
            if(pColRef->m_dwFlags & WQL_FLAG_TABLE || pColRef->m_dwFlags & WQL_FLAG_ALIAS)
            {
                if(bFirstTableEntry)
                    if(pColRef->m_dwFlags & WQL_FLAG_ALIAS)
                    {
                        m_FirstTable = pParser->AliasToTable(pColRef->m_pTableRef);
                        m_FirstTableAlias = pColRef->m_pTableRef;
                    }
                    else
                        m_FirstTable = pColRef->m_pTableRef;

                pPrefix = pColRef->m_pTableRef;
                bFirstTableEntry = false;
            }
            else if(wsPrefix.Length())
                pPrefix = (LPWSTR)wsPrefix;
            AddColumn(pColRef->m_pQName->m_aFields, pPrefix);
        }
    }

    if(pParser->CountQuery())
    {
        // Add the rule for 'count'
        // ========================

        wmilib::auto_ptr<CProjectionRule> pCountRule( new CProjectionRule(L"count"));
        if (NULL == pCountRule.get()) throw CX_MemoryException();

        pCountRule->m_eType = CProjectionRule::e_TakeAll;
        if (CFlexArray::no_error != m_TopRule.m_apPropRules.Add(pCountRule.get()))
            throw CX_MemoryException();
        pCountRule.release();
    }
};

//***************************************************************************
//
//***************************************************************************

void CComplexProjectionSink::AddColumn(CFlexArray& aFields, LPCWSTR wszPrefix)
{
    CProjectionRule* pCurrentRule = &m_TopRule;

    for(int i = 0; i < aFields.Size(); i++)
    {
        SWQLQualifiedNameField* pField = (SWQLQualifiedNameField*)aFields[i];

        if(!wcscmp(pField->m_pName, L"*"))
        {
            pCurrentRule->m_eType = CProjectionRule::e_TakeAll;
            return;
        }

        if(i == 0 && wszPrefix && !wbem_wcsicmp(pField->m_pName, wszPrefix) && aFields.Size() ==1)
        {
            // Skip this part because it is nothing more that a class name
            // in a single-class query
            // ===========================================================
            continue;
        }

        // Look this column up in the rule
        // ===============================

        CProjectionRule* pNewRule = pCurrentRule->Find(pField->m_pName);
        if(pNewRule == NULL)
        {
            pNewRule = new CProjectionRule(pField->m_pName);
            if (pNewRule)
            {
                pNewRule->m_eType = CProjectionRule::e_TakePart;
                if (pCurrentRule->m_apPropRules.Add(pNewRule) < 0)
                {
                    delete pNewRule;
                    pNewRule = NULL;
                }
            }
        }

        pCurrentRule = pNewRule; // possible assign to NULL
    }

    // Mark this rule as take-all
    // ==========================
    if (pCurrentRule)
        pCurrentRule->m_eType = CProjectionRule::e_TakeAll;
}

//***************************************************************************
//
//***************************************************************************

CComplexProjectionSink::~CComplexProjectionSink()
{
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CComplexProjectionSink::Indicate(long lObjectCount,
                                                IWbemClassObject** pObjArray)
{
    HRESULT hres;
    IWbemClassObject** apProjected = new IWbemClassObject*[lObjectCount];

    if (NULL == apProjected)
        return WBEM_E_OUT_OF_MEMORY;

    int i;
    for(i = 0; i < lObjectCount; i++)
    {
        hres = Project(pObjArray[i], &m_TopRule, apProjected + i);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Unable to perform a projection of an "
                "object returned by a complex query: 0x%X\n", hres));
            pObjArray[i]->Clone(apProjected + i);
        }
    }

    hres = CForwardingSink::Indicate(lObjectCount, apProjected);


    for(i = 0; i < lObjectCount; i++)
        apProjected[i]->Release();
    delete [] apProjected;

    return hres;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CComplexProjectionSink::Project(IWbemClassObject* pObj,
                                         CProjectionRule* pRule,
                                         IWbemClassObject** ppProj)
{
    // Make a copy
    // ===========

    pObj->Clone(ppProj);

    CWbemInstance* pProj = (CWbemInstance*)*ppProj;

    // Take care of the case where the object being returned is a product of a join, but is of single
    // class.  Ex; Select Site.sitenmame from Site, NotUsed.
    // This a a problem since we would normally expect a generic object as a result of a join and instead
    // get one of the objects that make up the join.

    CVar v;
    pProj->GetClassName(&v);
    bool Override = !wbem_wcsicmp(m_FirstTable, v.GetLPWSTR());
    if(Override && pRule->GetNumElements() == 1)
    {
        CProjectionRule* pNewRule = NULL;
        if(m_FirstTableAlias.Length())
            pNewRule = pRule->Find(m_FirstTableAlias);
        else
            pNewRule = pRule->Find(m_FirstTable);
        if(pNewRule)
            pRule = pNewRule;
    }

    // If take all, just return
    // ========================

    if(pRule->m_eType == CProjectionRule::e_TakeAll)
        return WBEM_S_NO_ERROR;


    // Go through all its properties
    // =============================

    for(int i = 0; i < pProj->GetNumProperties(); i++)
    {
        CVar vName;
        pProj->GetPropName(i, &vName);

        // Search for this name
        // ====================

        CProjectionRule* pPropRule = pRule->Find(vName.GetLPWSTR());

        if(pPropRule == NULL)
        {
            // Remove the property
            // ===================

            pProj->DeleteProperty(i);
            i--;
        }
        else if(pPropRule->m_eType == CProjectionRule::e_TakePart)
        {
            // Apply the same procedure
            // ========================

            CVar vValue;
            pProj->GetProperty(vName.GetLPWSTR(), &vValue);
            if(vValue.GetType() == VT_EMBEDDED_OBJECT)
            {
                // Project it
                // ==========

                IWbemClassObject* pEmb =
                    (IWbemClassObject*)vValue.GetEmbeddedObject();
                IWbemClassObject* pEmbProj;

                HRESULT hres = Project(pEmb, pPropRule, &pEmbProj);
                pEmb->Release();

                // Store it back
                // =============

                if(SUCCEEDED(hres))
                {
                    vValue.Empty();
                    vValue.SetEmbeddedObject(pEmbProj);
                    pProj->SetPropValue(vName.GetLPWSTR(), &vValue, 0);
                    pEmbProj->Release();
                }
            }
        }
    }

    pProj->CompactClass();
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//  CQueryEngine::ExecQuery
//
//  Primary entry point for execution of all queries supported by
//  the query engine.
//
//***************************************************************************
// ok

HRESULT CQueryEngine::ExecQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQueryFormat,
    IN LPWSTR pszQuery,
    IN LONG lFlags,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pSink
    )
{
    try
    {
         COperationError OpInfo(pSink, L"ExecQuery", pszQuery);
         if (!OpInfo.IsOk()) return pSink->Return(WBEM_E_OUT_OF_MEMORY);

         if (ConfigMgr::ShutdownInProgress()) return OpInfo.ErrorOccurred(WBEM_E_SHUTTING_DOWN);


        // Check query language
        if(wbem_wcsicmp(pszQueryFormat, L"WQL") != 0) return OpInfo.ErrorOccurred(WBEM_E_INVALID_QUERY_TYPE);

        while (*pszQuery && isspace((WCHAR)*pszQuery)) pszQuery++;
        if (0 == pszQuery[0]) return OpInfo.ErrorOccurred(WBEM_E_INVALID_QUERY);

        // If a prototype query is requested, get the synthesized
        // class definition.
        if (lFlags & WBEM_FLAG_PROTOTYPE)
        {
            return ExecPrototypeQuery(pNs,pszQuery,pContext,pSink);
        }

        WCHAR * pEndToken = pszQuery;
        while (*pEndToken && !isspace((WCHAR)*pEndToken)) pEndToken++;
        size_t SizeToken = (ULONG_PTR)pEndToken - (ULONG_PTR)pszQuery;
        SizeToken /= sizeof(WCHAR);

        // Get the first token of the query to see if it is SQL1 or TEMPQL
        BOOL bSelect = FALSE;        
        BOOL bDelete = FALSE;
        if (6 == SizeToken)
        {
            bSelect = (0 == wbem_wcsnicmp(pszQuery, L"select",6));
            bDelete = (0 == wbem_wcsnicmp(pszQuery, L"delete",6));
        }

        CBasicObjectSink *pNewSink = OpInfo.GetSink();

        CLocaleMergingSink *pLocaleSink = NULL;
        if (lFlags & WBEM_FLAG_USE_AMENDED_QUALIFIERS)
        {
            pLocaleSink = new CLocaleMergingSink(pNewSink, pNs->GetLocale(), pNs->GetName());
            if ( NULL == pLocaleSink ) return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);

            pLocaleSink->AddRef();
            pNewSink = pLocaleSink;
        }
        CReleaseMe rmLocale(pLocaleSink);

        CFinalizingSink* pFinalSink = new CFinalizingSink(pNs, pNewSink);
        if ( NULL == pFinalSink ) return OpInfo.ErrorOccurred(WBEM_E_OUT_OF_MEMORY);
        pFinalSink->AddRef();
        CReleaseMe rmFinal(pFinalSink);

        if (bSelect)
        {
            ExecQlQuery(pNs, pszQuery, lFlags, pContext, pFinalSink);
        }
        else if (bDelete)
        {
            ExecRepositoryQuery(pNs, pszQuery, lFlags, pContext, pFinalSink);
        }
        else    // ASSOCIATORS OF or REFERENCES OF query
        {
            CAssocQuery *pAssocQuery = CAssocQuery::CreateInst();

            if (NULL == pAssocQuery)
            {
                return pFinalSink->Return(WBEM_E_OUT_OF_MEMORY);
            }
            CReleaseMe rmAssocQ(pAssocQuery);

             // Execute the query and see what happens.
            // The object AddRefs and Releases itself as required.
            // We only need to do a Release right after Execute.
            // =====================================
            pAssocQuery->Execute(pNs, pszQuery, pContext, pFinalSink);
        }
    }
    catch (CX_Exception &)
    {
        pSink->SetStatus(0, WBEM_E_OUT_OF_MEMORY, 0, 0);
        return WBEM_E_OUT_OF_MEMORY;

    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CQueryEngine::ExecComplexQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQuery,
    IN LONG lFlags,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pSink
    )
{
    // Try to parse it
    // ===============

    CTextLexSource src(pszQuery);
    CWQLScanner Parser(&src);
    int nRes = Parser.Parse();
    if(nRes != CWQLScanner::SUCCESS)
    {
        return WBEM_E_INVALID_QUERY;
    }

    // Successfully parsed. Go to the list of tables involved
    // ======================================================

    CWStringArray awsTables;
    Parser.GetReferencedTables(awsTables);

    // Go through them and check their providers
    // =========================================

    WString wsProvider;
    for(int i = 0; i < awsTables.Size(); i++)
    {
        // Get the class
        IWbemClassObject* pObj = NULL;
        HRESULT hres = pNs->Exec_GetObjectByPath(awsTables[i], lFlags, pContext,&pObj, NULL);
        if(FAILED(hres))
        {
            if(hres == WBEM_E_NOT_FOUND)
            {
                if(!wbem_wcsicmp(awsTables[i], L"meta_class"))
                    hres = WBEM_E_INVALID_QUERY;
                else
                    hres = WBEM_E_INVALID_CLASS;
            }
            return hres;
        }
        CReleaseMe rmObj(pObj);

        // Check the qualifier
        // ===================

        CWbemClass* pClass = (CWbemClass*)pObj;
        CVar vProvider;
        hres = pClass->GetQualifier(L"provider", &vProvider);
        if(FAILED(hres) || 
            vProvider.GetType() != VT_BSTR || 
            vProvider.GetLPWSTR() == 0 ||
            wcslen(vProvider.GetLPWSTR()) == 0)                
        {
            // no provider --- can't execute
            return WBEM_E_INVALID_QUERY;
        }

        if(i == 0)
        {
            wsProvider = vProvider.GetLPWSTR(); // throw
        }
        else
        {
            if(!wsProvider.EqualNoCase(vProvider.GetLPWSTR()))
            {
                // mismatched providers!
                return WBEM_E_INVALID_QUERY;
            }
        }
    }

    CComplexProjectionSink* pProjSink = new CComplexProjectionSink(pSink, &Parser);
    if (NULL == pProjSink) return WBEM_E_OUT_OF_MEMORY;
    pProjSink->AddRef();
    CReleaseMe rm1(pProjSink);

    // All the classes have the same provider: wsProvider
    // ==================================================
    return pNs->DynAux_ExecQueryExtendedAsync(wsProvider,pszQuery,L"WQL" ,lFlags,pContext,pProjSink);

}

//
//
//  CQueryEngine::ExecQlQuery
//
//  This function MUST call SetStatus if there is an error of it's own
//
///////////////////////////////////////////////////////////////////////////////


HRESULT CQueryEngine::ExecQlQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQuery,
    IN LONG lFlags,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pSink
    )
{
    HRESULT hRes;
    BOOL bDirectQuery = FALSE;

    BOOL bShallow = (lFlags & WBEM_FLAG_SHALLOW);

    // First, try to push it off to providers,
    // that can handle the query it its entirety.
    // =================================

    if(!bShallow)
    {
        hRes = ExecComplexQuery(pNs, pszQuery, lFlags, pContext, pSink);  // throws
        if(SUCCEEDED(hRes))
            return hRes;
    }

    // Parse the query.
    // ================

    CTextLexSource src(pszQuery);
    QL1_Parser parser(&src);
    QL_LEVEL_1_RPN_EXPRESSION *pExp = 0;
    int nRes = parser.Parse(&pExp);
    if (CAbstractQl1Parser::SUCCESS != nRes)  return pSink->Return(WBEM_E_INVALID_QUERY);
    _DBG_ASSERT(pExp);
    pExp->AddRef();
    CTemplateReleaseMe<QL_LEVEL_1_RPN_EXPRESSION> trm99(pExp);

    // Check if the repository for this namespace
    // supports queries.  If so, we can pawn off
    // the entire query on it (with the exception
    // of provider-backed subclasses)
    // ===========================================

    bDirectQuery = pNs->GetNsSession()->SupportsQueries(NULL) == WBEM_S_NO_ERROR ? TRUE : FALSE;

    if (!bDirectQuery)
    {
        // Check for failure, or that pExp->bAggregated is TRUE, in which
        // case we got a "GROUP BY" query which we do not support
        if ( nRes || pExp->bAggregated || !pExp->bsClassName )
        {
            return pSink->Return(WBEM_E_INVALID_QUERY);
        }
    }
    else
    {
        // This is strictly to allow order by clauses to squeak through,
        // until we replace this parser with IWbemQuery.

        if (!pExp || !pExp->bsClassName || pExp->bAggregated)
        {
            return pSink->Return(WBEM_E_INVALID_QUERY);
        }
    }

    // We should make a check to see if we are doing a schema search.  This is
    // the case if we are doing a select against the "meta_class" class.
    // =======================================================================
    if (wbem_wcsicmp(pExp->bsClassName, L"meta_class") == 0)
    {
        if(pExp->nNumberOfProperties > 0 || !pExp->bStar)
        {
            return pSink->Return(WBEM_E_INVALID_QUERY);
        }
        return ExecSchemaQuery(pNs, pszQuery, pExp, pContext, pSink);
    }

    // Build the dynasty
    // =================

    wmilib::auto_ptr<CDynasty> pDynasty;
    IWbemClassObject* pErrorObj = NULL;
    HRESULT hres = pNs->DynAux_BuildClassHierarchy(pExp->bsClassName,
                                                                                 0, // removed the flags
                                                                                 pContext, 
                                                                                 pDynasty, 
                                                                                 &pErrorObj);
    if (FAILED(hres))
    {
        CReleaseMe rm1(pErrorObj);
        if(hres == WBEM_E_NOT_FOUND || hres == WBEM_E_INVALID_CLASS)
            return pSink->Return(WBEM_E_INVALID_CLASS, pErrorObj);
        else
            return pSink->Return(WBEM_E_INVALID_QUERY, pErrorObj);
    }

    // Construct a post-filtering (if needed) and projecting sink
    // ==========================================================

    IWbemClassObject* pClass = NULL;
    CReleaseMeRef<IWbemClassObject*> rm1(pClass);
    if (!pExp->bCount)
    {
        hres = pNs->Exec_GetObjectByPath(pExp->bsClassName, lFlags, pContext, &pClass, NULL);
        if(FAILED(hres))
        {
            return pSink->Return(WBEM_E_INVALID_CLASS);
        }
    }
    else
    {
        if (!bDirectQuery) return pSink->Return(WBEM_E_NOT_SUPPORTED);

        // here it's a Direct Query
        hres = CoCreateInstance(CLSID_WbemClassObject, 
                                              NULL, CLSCTX_INPROC_SERVER, 
                                              IID_IWbemClassObject,
                                              (void **)&pClass);
        if (FAILED(hres)) return pSink->Return(WBEM_E_OUT_OF_MEMORY);

        BSTR bstrName = SysAllocString(L"__Generic");
        if (NULL == bstrName) return pSink->Return(WBEM_E_OUT_OF_MEMORY);

        VARIANT vTemp;
        V_VT(&vTemp) = VT_BSTR;
        V_BSTR(&vTemp) = bstrName;
        _variant_t Var;
        Var.Attach(vTemp);
        hres = pClass->Put(L"__Class", 0, &vTemp, CIM_STRING);
        if (FAILED(hres)) return pSink->Return(hRes);
        hres = pClass->Put(L"Count", 0, NULL, CIM_UINT32);
        if (FAILED(hres)) return pSink->Return(hRes);
    }

    CBasicObjectSink* pPreFilterSink = NULL;

    if(lFlags & WBEM_FLAG_KEEP_SHAPE)
    {
        //
        // We must not project the results, otherwise we will destroy the shape
        // of the instance.  Remove the flag, though, lest we confuse providers
        //

        lFlags &= ~WBEM_FLAG_KEEP_SHAPE;
        pPreFilterSink = pSink;
    }
    else
    {
        // this guy throws
        CProjectingSink* pProjectingSink = new CProjectingSink(pSink, (CWbemClass*)pClass, pExp, lFlags);

        if (NULL == pProjectingSink)
            return pSink->Return(WBEM_E_OUT_OF_MEMORY);

        if(!pProjectingSink->IsValid())
        {
            delete pProjectingSink;
            return pSink->Return(WBEM_E_INVALID_QUERY);
        }
        pPreFilterSink = pProjectingSink;
    }

    CQlFilteringSink* pFilteringSink = new CQlFilteringSink(pPreFilterSink, pExp, pNs, TRUE);
    if (NULL == pFilteringSink) return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    // If shallow, force post-filtering
    // ================================
    if(bShallow) pFilteringSink->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);

    CCombiningSink* pCombiningSink = new CCombiningSink(pFilteringSink, WBEM_E_NOT_FOUND);
    if (NULL == pCombiningSink) return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    CDynPropsSink * pDynSink = new CDynPropsSink(pCombiningSink, pNs);

    if (NULL == pDynSink) return pSink->Return(WBEM_E_OUT_OF_MEMORY);

    pDynSink->AddRef();
    CReleaseMe rm99(pDynSink);

    // We simplify the query if our repository ain't too bright.
    // Otherwise, it will reject count queries.
    // Again, temporary until we get IWbemQuery plugged in.

    if (!bDirectQuery)
    {
        // "Simplify" the query (TBD: think about doing it at each level)
        // ==============================================================

        QL_LEVEL_1_RPN_EXPRESSION* pSimpleExp = NULL;
        CStandardMetaData* pRawMeta = new CStandardMetaData(pNs);
        if (NULL == pRawMeta)
        {
            pDynSink->Return(WBEM_E_OUT_OF_MEMORY);
            return WBEM_S_NO_ERROR;
        }

        CContextMetaData* pMeta = new CContextMetaData(pRawMeta, pContext);
        if (NULL == pMeta)
        {
            delete pRawMeta;
            pDynSink->Return(WBEM_E_OUT_OF_MEMORY);
            return WBEM_S_NO_ERROR;
        }


        hres = CQueryAnalyser::SimplifyQueryForChild(pExp,
                pExp->bsClassName, (CWbemClass*)pClass, pMeta, pSimpleExp);
        delete pMeta;

        if(FAILED(hres))
        {
            pDynSink->Return(WBEM_E_INVALID_QUERY);
            return WBEM_S_NO_ERROR;
        }

        if(pSimpleExp == NULL)
        {
            // Query violated intergrity constraint
            // ====================================

            pDynSink->Return(WBEM_S_NO_ERROR); // ?? WBEM_S_IMPOSSIBLE
            return WBEM_S_NO_ERROR;
        }

        // Substitute the simplified where clause into the query
        // =====================================================

        delete [] pExp->pArrayOfTokens;
        pExp->pArrayOfTokens = pSimpleExp->pArrayOfTokens;
        pExp->nNumTokens = pSimpleExp->nNumTokens;
        pSimpleExp->pArrayOfTokens = NULL;
        delete pSimpleExp;
    }

    // Now make a final pass to make sure this query is valid
    // ======================================================

    hres = ValidateQuery(pExp, (CWbemClass *)pClass);
    if (FAILED(hres))
    {
        pDynSink->Return(hres);
        return WBEM_S_NO_ERROR;
    }

    LPWSTR pszNewQuery = NULL;

    // Preserve the original query if
    // it contains count, order by
    // (or other unparsable stuff)

    if (pExp->bCount || nRes)
        pszNewQuery = Macro_CloneLPWSTR(pszQuery);
    else
        pszNewQuery = pExp->GetText();
    if (NULL == pszNewQuery)
    {
        pDynSink->Return(WBEM_E_OUT_OF_MEMORY);
        return WBEM_S_NO_ERROR;
    }
    CVectorDeleteMe<wchar_t> cdm98(pszNewQuery);

    // If direct access was requested, then don't walk
    // the dynasty. Go right to the repository or the provider.
    // ========================================================

    if (lFlags & WBEM_FLAG_DIRECT_READ)
    {
        DirectRead(pNs, pDynasty.get(), pszNewQuery, pExp, pContext,
            pDynSink, lFlags & ~WBEM_FLAG_ENSURE_LOCATABLE
            );
    }
    else // Recursively execute for all classes in the dynasty
    {
        BOOL    fUseOld = !ConfigMgr::GetMergerThrottlingEnabled();
        // Check the Registry

        if ( fUseOld )
        {
            EvaluateSubQuery_old(
                pNs, pDynasty.get(), pszNewQuery, pExp, pContext, FALSE,
                pDynSink, lFlags & ~WBEM_FLAG_ENSURE_LOCATABLE
                );
        }
        else
        {

            // Allocate a new merger and pass it down the line
            CWmiMerger*    pMerger = new CWmiMerger( pNs );
            if ( NULL == pMerger ) return pDynSink->Return( WBEM_E_OUT_OF_MEMORY );
            pMerger->AddRef();
            CReleaseMe    rmMerger( (_IWmiArbitratee*) pMerger );

            // Task handle will be available if we have an executing request,
            // if not, don't worry about it right now.  Nobody's really able
            // to give a straight answer on this, so we will simply add an assert
            // if a merger is created and no task handle is associated with the
            // main merger.

            _IWmiArbitrator*    pArbitrator = CWmiArbitrator::GetRefedArbitrator();
            if (NULL == pArbitrator) return pDynSink->Return(WBEM_E_CRITICAL_ERROR);
            CReleaseMe    rmArb( pArbitrator );
            
            _IWmiCoreHandle*    pTask = NULL;            
            CWbemRequest*        pReq = CWbemQueue::GetCurrentRequest();

            if ( pReq )
            {
                pTask = pReq->m_phTask;
            }

            //
            // creates the MergerSink as the DestinationSink
            //
            CMergerSink*    pDestSink = NULL;            
            HRESULT hr = pMerger->Initialize( pArbitrator, pTask, pExp->bsClassName, pDynSink, &pDestSink );
            CReleaseMe    rm( pDestSink );

            if (FAILED(hr)) return pDynSink->Return( hr );

            // If something goes wrong in this function, it will set the
            // error in the sink
            hr = EvaluateSubQuery(pNs, pDynasty.get(), 
                                       pszNewQuery, 
                                       pExp, pContext, FALSE,
                                       pMerger, pDestSink, lFlags & ~WBEM_FLAG_ENSURE_LOCATABLE);

            if ( SUCCEEDED( hr ) )
            {
                //
                // Schedule a parent request if appropriate
                // The Merger Request Manager knonws if it has one or more requests
                // one request is handled here synchronously
                // more request are kicked off by the MergerParent Request
                // in a different thread of the queue
                //
                hr = pMerger->ScheduleMergerParentRequest( pContext );

                if (FAILED(hr)) return pDestSink->Return( hr );
            } 

        }

    }

    return hres;
}

//***************************************************************************
//
//  CQueryEngine::DirectRead
//
//  Called to directly read the instances of a class, whether
//  from the repository or a provider.
//
//***************************************************************************

HRESULT CQueryEngine::DirectRead(
    IN CWbemNamespace *pNs,
    IN CDynasty *pCurrentDyn,
    IN LPWSTR wszTextQuery,
    IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pSink,
    IN long lFlags
    )
{
    // SJS - Amendment is the same as Abstract
    if( ( pCurrentDyn->IsAbstract() || pCurrentDyn->IsAmendment() ) && (lFlags & WBEM_FLAG_SHALLOW))
    {
        // No instances
        // ============

        return pSink->Return(WBEM_S_NO_ERROR);
    }

    // The class has its own instances if it has a key and is either dynamic
    // or the first static class in the inheritance chain (otherwise these
    // instances have been handled in the parent)
    // =====================================================================

    BOOL bHasOwnInstances = pCurrentDyn->IsKeyed() && !pCurrentDyn->IsAbstract()
        && !pCurrentDyn->IsAmendment();

    // The class has children that we need to look at if it has children.
    // ==================================================================

    BOOL bHasChildren = (pCurrentDyn->m_Children.Size() > 0);

    // Determine if the current query actually asks for instances of the
    // current CDynasty class.  This is used for WBEM_FLAG_DIRECT_READ type
    // access.
    // =======================================================================

    BOOL bQueryMatchesCurrentNode = FALSE;
    if (wbem_wcsicmp(pParsedQuery->bsClassName, pCurrentDyn->m_wszClassName) == 0)
        bQueryMatchesCurrentNode = TRUE;

    // If we are at the node we need, we can stop.
    // ===========================================

    if (bHasOwnInstances && bQueryMatchesCurrentNode)
    {
        // If a provider backs this class, then call it.
        // ==============================================

        if (pCurrentDyn->IsDynamic())
        {
            ExecAtomicDynQlQuery(
                    pNs,
                    pCurrentDyn,
                    L"WQL",
                    wszTextQuery,
                    pParsedQuery,
                    lFlags,                                      // Flags
                    pContext,
                    pSink,
                    FALSE
                    );
        }
        // Try the repository.
        // ===================
        else
        {
            int nRes = ExecAtomicDbQuery(pNs->GetNsSession(), pNs->GetNsHandle(), pNs->GetScope(), pCurrentDyn->m_wszClassName,
                        pParsedQuery, pSink, pNs
                        );

            if (nRes == invalid_query)
                pSink->Return(WBEM_E_INVALID_QUERY);
            else if(nRes != 0)
                pSink->Return(WBEM_E_FAILED);
            else
                pSink->Return(WBEM_S_NO_ERROR);
        }
    }

    // If here, we must keep looking for the target in the child classes.
    // ==================================================================

    else if (bHasChildren)
    {
        for (int i = 0; i < pCurrentDyn->m_Children.Size(); i++)
        {
            CDynasty *pSubDyn =
                (CDynasty *) pCurrentDyn->m_Children.GetAt(i);

            DirectRead(
                pNs,
                pSubDyn,
                wszTextQuery,
                pParsedQuery,
                pContext,
                pSink,
                lFlags
                );
        }
    }

    return WBEM_S_NO_ERROR;
}

// New implementation

//***************************************************************************
//
//  CQueryEngine::EvaluateSubQuery
//
//  Walks through a class hierarchy and executes smaller queries against
//  the individual classes in the dynasty.
//
//  Note that in a class hierarchy A,B:A,C:B, an enumeration/query is
//  performed only against the classes in the CDynasty referenced in
//  the query. For example, if "select * from B" is the query, only queries
//  for B and C are performed.  The CMerger logic will do individual
//  'get object' calls for any instances needed in A to complete
//  the merged B/C instances while merging is taking place.
//
//  Return values:
//  WBEM_NO_ERROR
//  WBEM_E_FAILED
//
//***************************************************************************
// error objects dealt with

HRESULT CQueryEngine::EvaluateSubQuery(
    IN CWbemNamespace *pNs,
    IN CDynasty *pCurrentDyn,
    IN LPWSTR wszTextQuery,
    IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
    IN IWbemContext* pContext,
    IN BOOL bSuppressStaticChild,
    IN CWmiMerger* pMerger, // must have combining semantics
    IN CMergerSink* pSink,
    IN long lFlags,
    IN bool bHasRightSibling
)
{
    // SJS - Amendment is the same as Abstract
    if( ( pCurrentDyn->IsAbstract() || pCurrentDyn->IsAmendment() ) && (lFlags & WBEM_FLAG_SHALLOW))
    {
        // No instances
        // ============

        pSink->SetStatus( 0L, WBEM_S_NO_ERROR, 0L, NULL);
        return WBEM_S_NO_ERROR;
    }

    // The class has its own instances if it has a key and is either dynamic
    // or the first static class in the inheritance chain (otherwise these
    // instances have been handled in the parent)
    // =====================================================================

    BOOL bHasOwnInstances = pCurrentDyn->IsKeyed() && !pCurrentDyn->IsAbstract()
        && !pCurrentDyn->IsAmendment() && (pCurrentDyn->IsDynamic() || !bSuppressStaticChild);

    // The class has children that we need to look at if it has children.
    // ==================================================================

    BOOL bHasChildren = (pCurrentDyn->m_Children.Size() > 0);

    // The class hierarchy was built down from the class of the query, as
    // well as up the inheritance chain, since parents may need to be used to
    // build complete instances. However, parents are treated very different
    // then classes derived from the class of the query (see below)
    // ======================================================================

    BOOL bDerivedFromTarget = (pCurrentDyn->m_pClassObj->InheritsFrom(pParsedQuery->bsClassName) == S_OK);


    // Next, see if the query is executing out of a scope or the primary
    // namespace.  We exclude providers if the query is executing from
    // a scope.
    // ==================================================================

    BOOL bInScope = pNs->IsSubscope();

    // Now we have enough info to start getting the instances.
    // =======================================================

    CMergerSink* pOwnSink = NULL;
    CMergerSink* pChildSink = NULL;

    //
    //  Creates a CMergerRecord if there is not already one for the class
    //  Creates an InternalMerger if there are Own instances and Child classes
    //  returns Own and Child Sink from the MergerRecord
    //
    HRESULT    hr = pMerger->RegisterSinkForClass( pCurrentDyn->m_wszClassName, 
    	                                           (_IWmiObject*) pCurrentDyn->m_pClassObj, 
    	                                           pContext,
                                                   bHasChildren, bHasOwnInstances, 
                                                   bDerivedFromTarget,!pCurrentDyn->IsDynamic(), 
                                                   pSink, &pOwnSink, &pChildSink );
    CReleaseMe    rm1( pOwnSink );
    CReleaseMe    rm2( pChildSink );

    if ( FAILED(hr) )
    {
        pSink->SetStatus( 0L, hr, 0L, NULL );
        return hr;
    }

    if(bHasOwnInstances)
    {
        if(bHasChildren)
        {
            // In order for the merge to succeed, we need to make sure that all
            // keys are provided, whether or not we are asked for them
            // ================================================================

            if(!pParsedQuery->bStar)
            {
                CPropertyName Name;
                Name.AddElement(L"__RELPATH");    // throws
                pParsedQuery->AddProperty(Name);
            }

            // We need to figure out what to ask of the provider. If the
            // provider is "downstream" from the original query, i.e. the query
            // was asked against a class that is an ancestor of this one or is
            // this one, we are fine --- this provider must understand the
            // query. If not, we don't ask any query, just wait and then call
            // GetObjectByPath.
            // ================================================================

            //pMerger->SetIsDerivedFromTarget(bDerivedFromTarget);
        }
    }
    else if(!bHasChildren)
    {
        // No instances and no children 
        pSink->SetStatus( 0L, WBEM_S_NO_ERROR, 0L, NULL );
        return WBEM_S_NO_ERROR;
    }

    // If this is an old security class, use the internal provider.
    // ====================================================================

    if((wbem_wcsicmp(pCurrentDyn->m_wszClassName, L"__ntlmgroup") == 0 ||
        wbem_wcsicmp(pCurrentDyn->m_wszClassName, L"__ntlmuser") == 0) &&
        (lFlags & WBEM_FLAG_ONLY_STATIC) == 0)
    {
            HRESULT hres = pNs->EnumerateSecurityClassInstances(pCurrentDyn->m_wszClassName,
                    pOwnSink, pContext, lFlags);
            pOwnSink->SetStatus( 0L, hres, 0L, NULL );
    }
    // If the current subclass is the first keyed statically instanced subclass.
    // =========================================================================
    else if (bHasOwnInstances && !pCurrentDyn->IsDynamic())
    {
        // Execute the query against the static portion of the database.
        // =============================================================

        int nRes = 0;

        if (pNs->GetNsSession()->SupportsQueries(NULL) == WBEM_S_NO_ERROR)
        {
            // The underlying repository automatically handles inheritance.

            if (!bSuppressStaticChild)
                nRes = ExecRepositoryQuery(pNs, wszTextQuery, lFlags, pContext, pSink);

            if (nRes == invalid_query)
                pOwnSink->SetStatus( 0L, WBEM_E_INVALID_QUERY, 0L, NULL );
            else if(nRes != 0)
                pOwnSink->SetStatus( 0L, WBEM_E_FAILED, 0L, NULL );
            else
                pOwnSink->SetStatus( 0L, WBEM_S_NO_ERROR, 0L, NULL );


        }
        else
        {
            hr = pNs->Static_QueryRepository( (CWbemObject *) pCurrentDyn->m_pClassObj,0L, 
            	                              pContext, pOwnSink, pParsedQuery, 
            	                              pCurrentDyn->m_wszClassName,pMerger );
        }

    }
    else if (bHasOwnInstances && pCurrentDyn->IsDynamic() && !bInScope)
    {
        if (bDerivedFromTarget)
        {
            // Ask the provider.
            // =================

            ExecAtomicDynQlQuery(

                pNs,
                pCurrentDyn,
                L"WQL",
                wszTextQuery,
                pParsedQuery,
                lFlags,                                      // Flags
                pContext,
                pOwnSink,
                bHasChildren || bHasRightSibling
            );
        }
        else
        {
            pOwnSink->SetStatus( 0L, WBEM_S_NO_ERROR, 0L, NULL );
        }
    }

    // Manually release pOwnSink if appropriate - use the method on CReleaseMe() so
    // as not to interfere with the auto-release functionality.  We should do
    // this here so as to relinquish any unnecessary locks we may be holding on data
    // and/or results before we start spinning off child requests - it's all about
    // throughput boyo!
    if(pOwnSink)
        rm1.release();

    // If the current subclass is the first keyed statically instanced subclass.
    // =========================================================================

    if (bHasOwnInstances && !pCurrentDyn->IsDynamic())
    {
        bSuppressStaticChild = TRUE;
    }

    // Evaluate child classes.
    // =======================

    if (bHasChildren)
    {
        for (int i = 0; i < pCurrentDyn->m_Children.Size(); i++)
        {
            CDynasty *pSubDyn = (CDynasty *) pCurrentDyn->m_Children.GetAt(i);

            EvaluateSubQuery (

                pNs,
                pSubDyn,
                wszTextQuery,
                pParsedQuery,
                pContext,
                bSuppressStaticChild,
                pMerger,
                pChildSink,
                lFlags,
                bHasRightSibling || ( ( i != ( pCurrentDyn->m_Children.Size () - 1 )) ? true : false )
            ) ;
        }
    }

    return WBEM_S_NO_ERROR;
}

// Old implementation

//***************************************************************************
//
//  CQueryEngine::EvaluateSubQuery
//
//  Walks through a class hierarchy and executes smaller queries against
//  the individual classes in the dynasty.
//
//  Note that in a class hierarchy A,B:A,C:B, an enumeration/query is
//  performed only against the classes in the CDynasty referenced in
//  the query. For example, if "select * from B" is the query, only queries
//  for B and C are performed.  The CMerger logic will do individual
//  'get object' calls for any instances needed in A to complete
//  the merged B/C instances while merging is taking place.
//
//  Return values:
//  WBEM_NO_ERROR
//  WBEM_E_FAILED
//
//***************************************************************************
// error objects dealt with

HRESULT CQueryEngine::EvaluateSubQuery_old(
    IN CWbemNamespace *pNs,
    IN CDynasty *pCurrentDyn,
    IN LPWSTR wszTextQuery,
    IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
    IN IWbemContext* pContext,
    IN BOOL bSuppressStaticChild,
    IN CBasicObjectSink* pSink, // must have combining semantics
    IN long lFlags,
    IN bool bHasRightSibling
)
{
    // SJS - Amendment is the same as Abstract
    if( ( pCurrentDyn->IsAbstract() || pCurrentDyn->IsAmendment() ) && (lFlags & WBEM_FLAG_SHALLOW))
    {
        // No instances
        // ============

        return pSink->Return(WBEM_S_NO_ERROR);
    }

    // The class has its own instances if it has a key and is either dynamic
    // or the first static class in the inheritance chain (otherwise these
    // instances have been handled in the parent)
    // =====================================================================

    BOOL bHasOwnInstances = pCurrentDyn->IsKeyed() && !pCurrentDyn->IsAbstract()
        && !pCurrentDyn->IsAmendment() && (pCurrentDyn->IsDynamic() || !bSuppressStaticChild);

    // The class has children that we need to look at if it has children.
    // ==================================================================

    BOOL bHasChildren = (pCurrentDyn->m_Children.Size() > 0);

    // The class hierarchy was built down from the class of the query, as
    // well as up the inheritance chain, since parents may need to be used to
    // build complete instances. However, parents are treated very different
    // then classes derived from the class of the query (see below)
    // ======================================================================

    BOOL bDerivedFromTarget = (pCurrentDyn->m_pClassObj->InheritsFrom(
        pParsedQuery->bsClassName) == S_OK);


    // Next, see if the query is executing out of a scope or the primary
    // namespace.  We exclude providers if the query is executing from
    // a scope.
    // ==================================================================

    BOOL bInScope = pNs->IsSubscope();

    // Now we have enough info to start getting the instances.
    // =======================================================

    CBasicObjectSink* pChildSink = NULL;
    CBasicObjectSink* pOwnSink = NULL;

    if(bHasOwnInstances)
    {
            if(bHasChildren)
        {
            // Has instances and children have instances
            // =========================================

            CMerger* pMerger = new CMerger(pSink,
                (CWbemClass*)pCurrentDyn->m_pClassObj, pNs, pContext);
            if (pMerger && pMerger->IsValid())
            {
                pOwnSink = pMerger->GetOwnSink();
                pOwnSink->AddRef();
                pChildSink = pMerger->GetChildSink();
                pChildSink->AddRef();

                // In order for the merge to succeed, we need to make sure that all
                // keys are provided, whether or not we are asked for them
                // ================================================================

                if(!pParsedQuery->bStar)
                {
                    CPropertyName Name;
                    Name.AddElement(L"__RELPATH");
                    pParsedQuery->AddProperty(Name);
                }

                // We need to figure out what to ask of the provider. If the
                // provider is "downstream" from the original query, i.e. the query
                // was asked against a class that is an ancestor of this one or is
                // this one, we are fine --- this provider must understand the
                // query. If not, we don't ask any query, just wait and then call
                // GetObjectByPath.
                // ================================================================

                pMerger->SetIsDerivedFromTarget(bDerivedFromTarget);
            }
            else
            {
                return pSink->Return(WBEM_E_OUT_OF_MEMORY);
            }
        }
        else
        {
            // No children --- own instances are it
            // ====================================

            pOwnSink = pSink;
            pSink->AddRef();
        }
    }
    else if(bHasChildren)
    {
        // Our children are it
        // ===================

        pChildSink = pSink;
        pSink->AddRef();
    }
    else
    {
        // No instances
        // ============

        return pSink->Return(WBEM_S_NO_ERROR);
    }

    // If this is an old security class, use the internal provider.
    // ====================================================================

    if((wbem_wcsicmp(pCurrentDyn->m_wszClassName, L"__ntlmgroup") == 0 ||
        wbem_wcsicmp(pCurrentDyn->m_wszClassName, L"__ntlmuser") == 0) &&
        (lFlags & WBEM_FLAG_ONLY_STATIC) == 0)
    {
            HRESULT hres = pNs->EnumerateSecurityClassInstances(pCurrentDyn->m_wszClassName,
                    pOwnSink, pContext, lFlags);
            pOwnSink->Return(hres);
    }
    // If the current subclass is the first keyed statically instanced subclass.
    // =========================================================================
    else if (bHasOwnInstances && !pCurrentDyn->IsDynamic())
    {
        // Execute the query against the static portion of the database.
        // =============================================================

        int nRes = 0;

        if (pNs->GetNsSession()->SupportsQueries(NULL) == WBEM_S_NO_ERROR)
        {
            // The underlying repository automatically handles inheritance.

            if (!bSuppressStaticChild)
                nRes = ExecRepositoryQuery(pNs, wszTextQuery, lFlags, pContext, pSink);
        }
        else
        {
            nRes = ExecAtomicDbQuery(pNs->GetNsSession(), pNs->GetNsHandle(), pNs->GetScope(), pCurrentDyn->m_wszClassName,
                        pParsedQuery, pOwnSink, pNs);
        }

        if (nRes == invalid_query)
            pOwnSink->Return(WBEM_E_INVALID_QUERY);
        else if(nRes != 0)
            pOwnSink->Return(WBEM_E_FAILED);
        else
            pOwnSink->Return(WBEM_S_NO_ERROR);

    }
    else if (bHasOwnInstances && pCurrentDyn->IsDynamic() && !bInScope)
    {
        if (bDerivedFromTarget)
        {
            // Ask the provider.
            // =================

            ExecAtomicDynQlQuery(

                pNs,
                pCurrentDyn,
                L"WQL",
                wszTextQuery,
                pParsedQuery,
                lFlags,                                      // Flags
                pContext,
                pOwnSink,
                bHasChildren || bHasRightSibling
            );
        }
        else
        {
            pOwnSink->Return(WBEM_S_NO_ERROR);
        }
    }

    if(pOwnSink)
        pOwnSink->Release();

    // If the current subclass is the first keyed statically instanced subclass.
    // =========================================================================

    if (bHasOwnInstances && !pCurrentDyn->IsDynamic())
    {
        bSuppressStaticChild = TRUE;
    }

    // Evaluate child classes.
    // =======================

    if (bHasChildren)
    {
        for (int i = 0; i < pCurrentDyn->m_Children.Size(); i++)
        {
            CDynasty *pSubDyn = (CDynasty *) pCurrentDyn->m_Children.GetAt(i);

            EvaluateSubQuery_old(
                pNs,
                pSubDyn,
                wszTextQuery,
                pParsedQuery,
                pContext,
                bSuppressStaticChild,
                pChildSink,
                lFlags,
                bHasRightSibling || ( ( i != ( pCurrentDyn->m_Children.Size () - 1 )) ? true : false )
            ) ;
        }
    }

    if(pChildSink)
        pChildSink->Release();

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CQueryEngine::EliminateDerivedProperties(
                            IN  QL_LEVEL_1_RPN_EXPRESSION* pOrigQuery,
                            IN  CWbemClass* pClass,
                            IN  BOOL bRelax,
                            OUT QL_LEVEL_1_RPN_EXPRESSION** ppNewQuery)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // Set up the new query to talk about this class
    // =============================================

    CVar vClassName;
    hres = pClass->GetClassName(&vClassName);
    if (FAILED(hres))
        return hres;

    (*ppNewQuery)->bsClassName = SysAllocString(vClassName.GetLPWSTR());

    if (0==(*ppNewQuery)->bsClassName)
        return WBEM_E_OUT_OF_MEMORY;
        
        

    if(pOrigQuery->nNumTokens == 0)
    {
        *ppNewQuery = new QL_LEVEL_1_RPN_EXPRESSION;
        if (*ppNewQuery)
            return WBEM_S_NO_ERROR;
        else
            return WBEM_E_OUT_OF_MEMORY;
    }

    // Set up a stack of expressions
    // =============================

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*, deque <QL_LEVEL_1_RPN_EXPRESSION*, wbem_allocator<QL_LEVEL_1_RPN_EXPRESSION*> > > ExprStack;

    // Recursively "evaluate" the original query
    // =========================================

    for(int i = 0; i < pOrigQuery->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pOrigQuery->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = NULL;
        QL_LEVEL_1_RPN_EXPRESSION* pFirst = NULL;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond = NULL;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            if(IsTokenAboutClass(Token, pClass))
            {
                QL_LEVEL_1_RPN_EXPRESSION* pNew = new QL_LEVEL_1_RPN_EXPRESSION;
                if (pNew)
                    pNew->AddToken(Token);
                else
                {
                    // force exit
                    i = pOrigQuery->nNumTokens;
                }
            }
            else
            {
                if(bRelax)
                {
                    QL_LEVEL_1_RPN_EXPRESSION* pNew =
                        new QL_LEVEL_1_RPN_EXPRESSION;
                    if (pNew)
                        ExprStack.push(pNew);
                    else
                    {
                        // force exit
                        i = pOrigQuery->nNumTokens;
                    }
                }
                else
                {
                    ExprStack.push(NULL);
                }
            }
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, &pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, &pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();

            if(bRelax)
            {
                QL_LEVEL_1_RPN_EXPRESSION* pNew = new QL_LEVEL_1_RPN_EXPRESSION;
                if (pNew)
                    ExprStack.push(pNew);
                else
                {
                    // force exit
                    i = pOrigQuery->nNumTokens;
                }
            }
            else
            {
                ExprStack.push(NULL);
            }

            delete pFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && ExprStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    *ppNewQuery = ExprStack.top();
    return S_OK;
}

//***************************************************************************
//
//***************************************************************************

BOOL CQueryEngine::IsTokenAboutClass(IN QL_LEVEL_1_TOKEN& Token,
                                       IN CWbemClass* pClass)
{
    CPropertyName& TokenPropName = Token.PropertyName;

    if(TokenPropName.GetNumElements() != 1)
        return FALSE;

    LPWSTR wszPropName = (LPWSTR)TokenPropName.GetStringAt(0);
    return SUCCEEDED(pClass->GetPropertyType(wszPropName, NULL, NULL));
}
//***************************************************************************
//
//***************************************************************************

HRESULT CQueryEngine::AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION** ppNew)
{
    // If either one is false, the result is false
    // ===========================================

    if(pFirst == NULL || pSecond == NULL)
    {
        *ppNew = NULL;
        return WBEM_S_NO_ERROR;
    }

    *ppNew = new QL_LEVEL_1_RPN_EXPRESSION;

    if (NULL == *ppNew)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // If either one is empty, take the other
    // ======================================

    if(pFirst->nNumTokens == 0)
    {
        AppendQueryExpression(*ppNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond->nNumTokens == 0)
    {
        AppendQueryExpression(*ppNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- and together
    // ===============================

    AppendQueryExpression(*ppNew, pFirst);
    AppendQueryExpression(*ppNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_AND;
    (*ppNew)->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CQueryEngine::OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION** ppNew)
{
    // If both are false, so is the resulkt
    // ====================================

    if(pFirst == NULL && pSecond == NULL)
    {
        *ppNew = NULL;
        return WBEM_S_NO_ERROR;
    }

    *ppNew = new QL_LEVEL_1_RPN_EXPRESSION;

    if (NULL == *ppNew)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // If either one is empty, so is the result
    // ========================================

    if(pFirst->nNumTokens == 0 || pSecond->nNumTokens == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    // If either one is false, return the other
    // ========================================

    if(pFirst == NULL)
    {
        AppendQueryExpression(*ppNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond == NULL)
    {
        AppendQueryExpression(*ppNew, pFirst);
        return WBEM_S_NO_ERROR;
    }
    // Both are there --- or together
    // ==============================

    AppendQueryExpression(*ppNew, pFirst);
    AppendQueryExpression(*ppNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_OR;
    (*ppNew)->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

void CQueryEngine::AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource)
{
    for(int i = 0; i < pSource->nNumTokens; i++)
    {
        pDest->AddToken(pSource->pArrayOfTokens[i]);
    }
}

//***************************************************************************
//
//***************************************************************************

BSTR CQueryEngine::GetParentPath(CWbemInstance* pInst, LPCWSTR wszClassName)
{
    // Get the relative path of the instance
    // =====================================

    LPWSTR wszRelPath = pInst->GetRelPath();
    if(wszRelPath == NULL)
        return NULL;

    BSTR str = AdjustPathToClass(wszRelPath, wszClassName);
    delete [] wszRelPath;
    return str;
}

//***************************************************************************
//
//***************************************************************************

BSTR CQueryEngine::AdjustPathToClass(LPCWSTR wszRelPath, LPCWSTR wszClassName)
{
    // Skip the absolute path
    // ======================

    if(wszRelPath[0] == '\\')
    {
        wszRelPath = wcschr(wszRelPath, ':');
        if(wszRelPath == NULL)
            return NULL;
        else
            wszRelPath++;
    }

    // Find the "post-classname" part
    // ==============================

    WCHAR* pwcDot = wcschr(wszRelPath, L'.');
    WCHAR* pwcEquals = wcschr(wszRelPath, L'=');
    LPWSTR wszPostClassPart;
    if(pwcDot == NULL)
        wszPostClassPart = pwcEquals;
    else if(pwcEquals == NULL)
        wszPostClassPart = pwcDot;
    else if(pwcDot < pwcEquals)
        wszPostClassPart = pwcDot;
    else
        wszPostClassPart = pwcEquals;

    // Allocate the BSTR for the real thing
    // ====================================

    BSTR strNewPath;
    if(wszPostClassPart)
    {
        size_t tmpLength = wcslen(wszClassName) + wcslen(wszPostClassPart);    // SEC:REVIEWED 2002-03-22 : OK, prior logic assures NULLs
        strNewPath = SysAllocStringLen(NULL, tmpLength);                       // SEC:REVIEWED 2002-03-22 : OK, prior logic assures proper size
        if (strNewPath)
            StringCchPrintfW(strNewPath, tmpLength+1, L"%s%s", wszClassName, wszPostClassPart);
    }
    else
    {
        strNewPath = SysAllocString(wszClassName);
    }

    return strNewPath;
}

//***************************************************************************
//
//  CQueryEngine::ExecAtomicDbQuery
//
//  General purpose query driver for QL LEVEL 1.  This method parses
//  and executes the query against the database engine.  The optimizer
//  is contained within this function and its auxiliaries.
//
//  Preconditions:
//  (1) All classes involved in the query are known to have
//  only static instances in the database.  No interface to dynamic
//  classes is provided.
//  (2) This method cannot resolve queries against abstract base classes.
//
//  Parameters:
//  <dwNs>          The target namespace.
//  <pQueryText>    The QL1 query, unparsed.
//  <pEnum>         Receives the enumerator containing the result set.
//
//  Return values:
//  <no_error>
//  <invalid_query>
//  <failed>
//  <out_of_memory>
//
//***************************************************************************
// ok / no error objects required

int CQueryEngine::ExecAtomicDbQuery(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNsHandle,
    IN IWmiDbHandle *pScopeHandle,
    IN LPCWSTR wszClassName,
    IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
    IN CBasicObjectSink* pDest, // no status
    IN CWbemNamespace * pNs)
{
    int nRetVal = 0;
    int nRes;

    // Examine the query and see if we can execute it
    // in any kind of optimized fashion.
    // ==============================================

    CWbemObject *pClassDef = 0;
    LPWSTR pPropToUse = 0;
    CVar *pValToUse = 0;
    int nType = 0;

    nRes = QueryOptimizationTest(
        pSession,
        pNsHandle,
        pScopeHandle,
        wszClassName,
        pExp,
        &pClassDef,
        &pPropToUse,
        &pValToUse,
        &nType
        );

    if (nRes == use_key)
    {
        nRes = KeyedQuery(
            pSession,
            pNsHandle,
            pExp,
            pClassDef,
            0,
            pDest,
            pNs
            );

        if (nRes != 0)
            nRetVal = failed;
    }
    else if (nRes == use_table_scan || nRes == use_index)
    {
        HRESULT hRes = CRepository::TableScanQuery(
            pSession,
            pScopeHandle,
            (LPWSTR)wszClassName,
            pExp,
            0,
            pDest
            );

        if (FAILED(hRes))
            nRetVal = failed;
        else
            nRetVal = 0;
    }

    delete pValToUse;
    delete pPropToUse;
    if (pClassDef)
        pClassDef->Release();

    return nRetVal;
}


//***************************************************************************
//
//  CQueryEngine::QueryOptimizationTest
//
//  Examines a query and its associated class definition.  It determines
//  what optimizations, if any, can be applied to speed up the query.
//  If the query is conjunctive and there is some form of primary or
//  secondary indexing which can be used, this method selects the
//  appropriate property to use for a retrieval by key or an indexed query.
//  If <table_scan> is returned, then a table scan is required.
//
//  Parameters:
//  <dwNs>              The relevant namespace.
//  <pExp>              A valid QL1 expression.
//  <pClassDef>         Always receives the deserialized class definition, as long
//                      as <invalid_class> is not returned.  Use operator
//                      delete to deallocate.
//
//  <pPropToUse>        If <use_index> is returned, this is assigned to point
//                      to an indexed property.  Use operator delete to deallocate
//                      This always refers to a non-key property name.
//                      Set to NULL if <table_scan> is returned.
//
//  <pValToUse>         The value to use if <use_index> is returned.
//                      Set to NULL if <use_index> is not returned.
//
//  <pnType>            Receives the VT_ type of the relevant property.
//                      Set to NULL if <use_index> is not returned.
//
//  Return values:
//  <invalid_class>     The class did not appear to exist.
//  <use_index>         The value returned via <pPropToUse> is a property
//                      with a secondary index which can beused to limit
//                      the query.
//  <use_key>           The query is such that all of the key properties
//                      were specified with equality tests.
//  <use_table_scan>    A table scan is required.
//
//***************************************************************************
// ok

int CQueryEngine::QueryOptimizationTest(
    IN  IWmiDbSession *pSession,
    IN  IWmiDbHandle *pNsHandle,
    IN  IWmiDbHandle *pScopeHandle,
    IN  LPCWSTR wszClassName,
    IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
    OUT CWbemObject **pClassDef,
    OUT LPWSTR *pPropToUse,
    OUT CVar **pValToUse,
    OUT int *pnType
    )
{
    int nRes;

    if (pNsHandle == 0 || pExp == 0 || pClassDef == 0 || pPropToUse == 0 ||
        pValToUse == 0 || pnType == 0)
            return invalid_parameter;

    // Defaults.
    // =========

    *pClassDef = 0;
    *pPropToUse = 0;
    *pValToUse = 0;
    *pnType = 0;

    // Look up the class definition.
    // =============================
    IWbemClassObject *pCls = 0;

    HRESULT hRes = CRepository::GetObject(pSession, pNsHandle, wszClassName, 0, &pCls);
    if (FAILED(hRes))
        return invalid_class;

    CWbemClass *pClsDef = (CWbemClass *) pCls;

    *pClassDef = pClsDef;

    // Test query for conjunctiveness.
    // ===============================
    if (!IsConjunctiveQuery(pExp))
        return use_table_scan;

    // If here, the query is conjunctive.  However, a table scan
    // may still be required if the only relational tests are on
    // non-indexed or non-keyed properties.

    // First, get the key properties.  If all of the keys
    // are used with equality tests, then we could simply retrieve
    // the object by key and test it.
    // ===========================================================
    CWStringArray aKeyProps;
    pClsDef->GetKeyProps(aKeyProps);

    if (QueryKeyTest(pExp, pClsDef, aKeyProps))
    {
        return use_key;
    }

    // If here, the keys were not adequate for limiting
    // the query. We next try to see if any indexed properties
    // were used.
    // =======================================================

    CWStringArray aIndexedProps;
    pClsDef->GetIndexedProps(aIndexedProps);

    if (QueryIndexTest(pExp, pClsDef, aIndexedProps, pPropToUse,
        pValToUse, pnType))
    {
        if (*pValToUse == 0)
            return use_table_scan;

        // Try to coerce
        // =============
        if ((*pValToUse)->ChangeTypeTo(CType::GetVARTYPE(*pnType)))
        {
            return use_index;
        }
        return use_table_scan;
    }

    // If here, we have to use a table scan after all.
    // ===============================================

    return use_table_scan;
}

//***************************************************************************
//
//  CQueryEngine::IsConjunctiveQuery
//
//  Does an initial screen of a query to see if it clearly not optimizable.
//
//  If the query contains an OR or NOT operator, it cannot currently be
//  optimized.
//
//***************************************************************************
// ok

BOOL CQueryEngine::IsConjunctiveQuery(
    IN  QL_LEVEL_1_RPN_EXPRESSION *pExp
    )
{
    for (int i2 = 0; i2 < pExp->nNumTokens; i2++)
    {
        QL_LEVEL_1_TOKEN& Tok = pExp->pArrayOfTokens[i2];

        if (Tok.nTokenType == QL_LEVEL_1_TOKEN::TOKEN_OR ||
            Tok.nTokenType == QL_LEVEL_1_TOKEN::TOKEN_NOT
            )
            return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  CQueryEngine::QueryKeyTest
//
//  Examines a query to see if the result set must be a single instance
//  due to use of the key in the 'where' clause.  Not only must the
//  key(s) be tested for equality, there must be only a single token or
//  else all operators must be AND operators.
//
//  This also performs type checking on the key(s).
//
//***************************************************************************
// ok

BOOL CQueryEngine::QueryKeyTest(
    IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
    IN  CWbemObject *pClassDef,
    IN  CWStringArray &aKeyProps
    )
{
    if (aKeyProps.Size() == 0)
        return FALSE;

    for (int i = 0; i < aKeyProps.Size(); i++)
    {
        // Check for unsupported key types
        // ===============================

        CIMTYPE ct;
        pClassDef->GetPropertyType(aKeyProps[i], &ct);
        if(ct == CIM_CHAR16 || ct == CIM_REFERENCE || ct== CIM_DATETIME)
            return FALSE;

        BOOL bFound = FALSE;

        for (int i2 = 0; i2 < pExp->nNumTokens; i2++)
        {
            QL_LEVEL_1_TOKEN& Tok = pExp->pArrayOfTokens[i2];

            if (Tok.nTokenType == QL_LEVEL_1_TOKEN::OP_EXPRESSION)
            {
                // If there is a matching property, check the rest
                // of the expression to ensure type compatibility
                // and that an equality test is used.
                // ===============================================

                LPWSTR wszPropName = GetSimplePropertyName(Tok.PropertyName);
                if (wszPropName && wbem_wcsicmp(wszPropName, aKeyProps[i]) == 0)
                {
                    if (Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
                    {
                        // TBD: Do a type check test here.
                        if(bFound)
                            return FALSE;       // Duplicate, probably not a good query for keys!
                        bFound = TRUE;
                    }
                    else
                    {
                        return FALSE;   // The key is being used in a non-equality comparison!! (Bug #43969)
                    }

                }
            }
        }

        if (!bFound)
            return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  CQueryEngine::QueryIndexTest
//
//  Examines a query to see if the result set can be limited by use
//  of a secondary index.
//
//***************************************************************************
// ok

BOOL CQueryEngine::QueryIndexTest(
    IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
    IN  CWbemObject *pClsDef,
    IN  CWStringArray &aIndexedProps,
    OUT LPWSTR *pPropToUse,
    OUT CVar **pValToUse,
    OUT int *pnType
    )
{
    for (int i = 0; i < pExp->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Tok = pExp->pArrayOfTokens[i];

        if (Tok.nTokenType == QL_LEVEL_1_TOKEN::OP_EXPRESSION &&
            Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
        {
            for (int i2 = 0; i2 < aIndexedProps.Size(); i2++)
            {
                LPWSTR wszPropName = GetSimplePropertyName(Tok.PropertyName);
                if (wszPropName &&
                    wbem_wcsicmp(wszPropName, aIndexedProps[i2]) == 0)
                {
                    CIMTYPE ctType;
                    HRESULT hRes = pClsDef->GetPropertyType(aIndexedProps[i2],
                                                            &ctType);
                    if ((ctType != CIM_SINT8) &&
                        (ctType != CIM_UINT8) &&
                        (ctType != CIM_SINT16) &&
                        (ctType != CIM_UINT16) &&
                        (ctType != CIM_SINT32) &&
                        (ctType != CIM_UINT32) &&
                        (ctType != CIM_CHAR16) &&
                        (ctType != CIM_STRING))
                        continue;

                    // If here, we have a match.
                    // =========================
                    *pPropToUse = Macro_CloneLPWSTR(aIndexedProps[i2]);
                    *pValToUse = new CVar(&Tok.vConstValue);

                    // a-levn: added support for NULLs
                    *pnType = (int)ctType;

                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}



//***************************************************************************
//
//***************************************************************************

BOOL AreWeLocal(WCHAR * pServerMachine)
{
    if(pServerMachine == NULL)
        return TRUE;
    if(0 == wbem_wcsicmp(pServerMachine,L"."))
        return TRUE;

	BOOL bRet = (0 == wbem_wcsicmp(ConfigMgr::GetMachineName(),pServerMachine));
	return bRet;
}


LPWSTR CQueryEngine::NormalizePath(LPCWSTR wszObjectPath, CWbemNamespace * pNs)
{
    CObjectPathParser Parser;
    ParsedObjectPath* pParsedPath;
    LPWSTR pReturnString = NULL;

    if(CObjectPathParser::NoError != Parser.Parse((LPWSTR)wszObjectPath, &pParsedPath)) return NULL;
    OnDeleteObj<ParsedObjectPath*,CObjectPathParser,
                         void (CObjectPathParser:: *)(ParsedObjectPath *pOutput),
                         &CObjectPathParser::Free> FreeMe(&Parser,pParsedPath);
    
    if (!pParsedPath->IsObject())  return NULL;
    if(NULL == pParsedPath->m_pClass) return NULL;


    // Start off with the server and namespace part

    WString wsNormal;
    try
    {
        wsNormal += L"\\\\";

        if(AreWeLocal(pParsedPath->m_pServer))
            wsNormal += L".";
        else
            wsNormal += pParsedPath->m_pServer;
        wsNormal += L"\\";
    
        WCHAR * pPath = pParsedPath->GetNamespacePart();
        CVectorDeleteMe<WCHAR> dm1(pPath);
    
        if(pPath)
            wsNormal += pPath;
        else
            wsNormal += pNs->GetName();
        wsNormal += L":";


        // Find the parent that defined the key
        // ====================================


        IWbemClassObject *pCls = 0;
        HRESULT hRes = CRepository::FindKeyRoot(pNs->GetNsSession(), pNs->GetScope(), pParsedPath->m_pClass, &pCls);
        CReleaseMe rmRootCls(pCls);

        if (hRes == WBEM_E_NOT_FOUND)
        {
            wsNormal += pParsedPath->m_pClass;
        }
        else if (SUCCEEDED(hRes))
        {    
            CVar vName;
            HRESULT getClassResult = ((CWbemClass *)pCls)->GetClassName(&vName);

            if (FAILED(getClassResult))
                return NULL;
            wsNormal += vName.GetLPWSTR();
        }

        // Convert this part to upper-case
        // ===============================

        LPWSTR wsz = (wchar_t*)wsNormal;
        SIZE_T Len = wsNormal.Length();
        for(int i = 0; i < Len; i++)
        {
            wsz[i] = wbem_towupper(wsz[i]);
        }

        WCHAR * wszKey = pParsedPath->GetKeyString();
        if (wszKey)
        {
            CVectorDeleteMe<WCHAR> dm2(wszKey);
        
            wsNormal += L"=";
            wsNormal += wszKey;
    
            pReturnString = wsNormal.UnbindPtr();
        }
    }
    catch (CX_MemoryException &)
    {
        // pReturnString is already NULL here
    }

    return pReturnString;
}

//***************************************************************************
//
//***************************************************************************

BOOL CQueryEngine::AreClassesRelated(CWbemNamespace* pNamespace,
                                     IWbemContext* pContext,
                                     CWbemObject* pClass1, LPCWSTR wszClass2)
{
    HRESULT hres;

    // First check if class 1 inherits from class 2
    // ============================================

    if(pClass1->InheritsFrom((LPWSTR)wszClass2) == S_OK)
        return TRUE;

    // Now, unfortunately, we have to go get the second class
    // ======================================================

    CSynchronousSink* pSink = CSynchronousSink::Create();
    if (NULL == pSink) return FALSE;
    pSink->AddRef();
    CReleaseMe rm1(pSink);

    hres = pNamespace->Exec_GetClass(wszClass2, 0, pContext, pSink);
    if(FAILED(hres)) return FALSE;    
    pSink->Block();
    pSink->GetStatus(&hres, NULL, NULL);
    if(FAILED(hres)) return FALSE;

    CWbemClass* pClass2 = (CWbemClass*)(pSink->GetObjects()[0]);

    // Get the first class's name
    // ==========================

    CVar vFirstName;
    if (FAILED(pClass1->GetClassName(&vFirstName)))
        return FALSE;

    // Check if the second class is derived from the first one
    // =======================================================

    if(pClass2->InheritsFrom(vFirstName.GetLPWSTR()) == S_OK)
        return TRUE;

    return FALSE;
}

//***************************************************************************
//
//  Determines if property <wszPropName> in object <pObj>
//  is a reference to <pTargetClass>
//
//***************************************************************************

BOOL CQueryEngine::IsAReferenceToClass(
    CWbemNamespace* pNamespace,
    IWbemContext* pContext,
    CWbemObject* pObj,
    LPCWSTR wszPropName,
    CWbemObject* pTargetClass,
    bool bCheckPropValue
    )
{
    // Get the cimtype
    // ===============

    CIMTYPE ct;
    if(FAILED(pObj->GetPropertyType((LPWSTR)wszPropName, &ct)) ||
        ct != CIM_REFERENCE)
    {
        return FALSE;
    }

    CVar vCimType;
    if(FAILED(pObj->GetPropQualifier((LPWSTR)wszPropName, TYPEQUAL,
                                                    &vCimType)))
    {
        return FALSE;
    }

    // See if it is a reference
    // ========================

    if (!wbem_wcsicmp(vCimType.GetLPWSTR(), L"ref"))
    {
        // Special case of object refs which only refer to class definitions.
        // ==================================================================

        if (bCheckPropValue)
        {
            CVar vClassPath;
            CVar vClassName;
            int nRes = pObj->GetProperty(wszPropName, &vClassPath);
            nRes = pTargetClass->GetClassName(&vClassName);
            if (!vClassPath.IsNull() && !vClassPath.IsNull())
            {
                if (wbem_wcsicmp(vClassName.GetLPWSTR(), vClassPath.GetLPWSTR()) == 0)
                    return TRUE;
            }
        }
        else
            return TRUE;
    }

    if(wbem_wcsnicmp(vCimType.GetLPWSTR(), L"ref:", 4) == 0)
    {
        LPWSTR wszClass = vCimType.GetLPWSTR() + 4;

        return CQueryEngine::AreClassesRelated(pNamespace, pContext,
                                pTargetClass, wszClass);
    }


    return FALSE;
}

//***************************************************************************
//
//  CQueryEngine::KeyedQuery
//
//  Preconditions:
//  The query is known to contain all key properties with equality
//  tests such that the object can be retrieved using
//  CObjectDatabase::GetObjectByPath and subsequently filtered.
//
//***************************************************************************
// ok
int CQueryEngine::KeyedQuery(
    IN IWmiDbSession *pSession,
    IN IWmiDbHandle *pNsHandle,
    IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
    IN CWbemObject *pClassDef,
    IN DWORD dwFlags,
    IN CBasicObjectSink* pDest, // no status
    IN CWbemNamespace * pNs
    )
{
    int nRet = no_error;

    // Convert the query into an object path.
    // ======================================

    wmilib::auto_buffer<WCHAR> pObjPath( GetObjectPathFromQuery(pClassDef, pExp, pNs));
    if (NULL == pObjPath.get()) return invalid_query;

    // Now get the object by path.
    // ===========================
    IWbemClassObject *pObj = 0;
    HRESULT hRes = CRepository::GetObject(pSession, pNsHandle, pObjPath.get(), 0, &pObj);
    CReleaseMe rmObj(pObj);

    // If there was an object, test it against the 'rest' of the query.
    // ================================================================
    if (SUCCEEDED(hRes))
    {
        CQlFilteringSink* pFilteringSink = new CQlFilteringSink(pDest, pExp, pNs);
        if (NULL == pFilteringSink) return failed;
        pFilteringSink->AddRef();
        // Indicate it in the Sink
        pFilteringSink->Add(pObj);
        pFilteringSink->Release();        
    }

    return nRet;
}


//***************************************************************************
//
//  CQueryEngine::GetObjectPathFromQuery
//
//  Converts the relevant parts of a QL query to an equivalent object
//  path.  This assumes that the query contains equality tests on all
//  key properties such that an object path would generate the same
//  single instance as the query.
//
//***************************************************************************
// ok

LPWSTR CQueryEngine::GetObjectPathFromQuery(
    IN CWbemObject *pClassDef,
    IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
    IN CWbemNamespace * pNs
    )
{
    CWStringArray aKeys;
    WString ObjPath;

    CVar v;
    HRESULT hr = pClassDef->GetClassName(&v);
    if (FAILED(hr))
        return 0;
    ObjPath += v.GetLPWSTR();
    ObjPath += L".";

    pClassDef->GetKeyProps(aKeys);

    BOOL bFirst = TRUE;

    for (int i = 0; i < aKeys.Size(); i++)
    {
        if (!bFirst)
            ObjPath += L",";

        bFirst = FALSE;
        ObjPath += aKeys[i];
        ObjPath += L"=";

        // Now find the property value.
        // ============================
        for (int i2 = 0; i2 < pExp->nNumTokens; i2++)
        {
            QL_LEVEL_1_TOKEN& Tok = pExp->pArrayOfTokens[i2];
            LPWSTR wszPropName = GetSimplePropertyName(Tok.PropertyName);

            if (Tok.nTokenType == QL_LEVEL_1_TOKEN::OP_EXPRESSION &&
                wszPropName && wbem_wcsicmp(aKeys[i], wszPropName) == 0)
            {
                if (V_VT(&Tok.vConstValue) == VT_BSTR)
                {
                    ObjPath += L"\"";
                    WString nonEscaped(V_BSTR(&Tok.vConstValue));
                    WString escaped = nonEscaped.EscapeQuotes();
                    ObjPath += escaped;
                    ObjPath += L"\"";
                }
                else if (V_VT(&Tok.vConstValue) == VT_BOOL)
                {
                    short bValue = V_I2(&Tok.vConstValue);
                    if(bValue == VARIANT_TRUE)
                        ObjPath+= L"1";
                    else
                        ObjPath += L"0";
                }
                else
                {
                    _variant_t varTo;
                    SCODE sc = VariantChangeType(&varTo, &Tok.vConstValue, 0, VT_BSTR);
                    if(sc == S_OK)
                    {
                        wchar_t buf[64];
                        StringCchPrintf(buf, 64, L"%s", varTo.bstrVal);
                        ObjPath += buf;
                    }
                }
            }
        }
    }

    return ObjPath.UnbindPtr();
}

HRESULT CQueryEngine::FindOverridenProperties(CDynasty* pDyn,
                                                CWStringArray& awsOverriden,
                                                bool bIncludeThis)
{
    //
    // If this class is included (not top-level), add all the properties
    // it overrides to the array
    //

    if(bIncludeThis)
    {
        CWbemObject *pTmp = (CWbemObject *) pDyn->m_pClassObj;

        for(int i = 0; i < pTmp->GetNumProperties(); i++)
        {
            CVar vPropName;
            pTmp->GetPropName(i, &vPropName);

            CVar vOverride;
            if(FAILED(pTmp->GetPropQualifier(vPropName.GetLPWSTR(),
                                            L"OVERRIDEVALUE",
                                             &vOverride)))
                continue;

            //
            // Overriden property --- add
            //

            if (CFlexArray::no_error != awsOverriden.Add(vPropName.GetLPWSTR()))
            {
                continue;
            }
        }
    }

    //
    // Recurse through all the children
    //
    for(int i = 0; i < pDyn->m_Children.Size(); i++)
    {
        CDynasty* pSubDyn = (CDynasty*)(pDyn->m_Children.GetAt(i));
        HRESULT hres = FindOverridenProperties(pSubDyn, awsOverriden, true);
        if(FAILED(hres))
            return hres;
    }

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//  CQueryEngine::ExecAtomicDynQlQuery
//
//***************************************************************************
// ok

HRESULT CQueryEngine::ExecAtomicDynQlQuery(
    IN CWbemNamespace *pNs,
    IN CDynasty* pDyn,
    IN LPWSTR pszQueryFormat,
    IN LPWSTR pszQuery,
    IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
    IN LONG lFlags,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pDest, // must support selective filtering ,
    IN BOOL bComplexQuery
    )
{
    HRESULT hres;

    DEBUGTRACE((LOG_WBEMCORE,"Query Engine request: querying dyn provider with <%S>\n", pszQuery));

    //
    // Find all the properties that are overriden by derived classes.
    // We must remove all references to those properties from the query, since
    // otherwise this provider might not return the parent instances needed to
    // merge with the child instances with the overriden property values.
    //

    CWStringArray awsOverriden;
    hres = FindOverridenProperties(pDyn, awsOverriden);
    if(FAILED(hres))
        return pDest->Return(hres);

    //
    // Get the query analyzer to remove all the properties that are overriden
    // or not members of this class (not possible right now anyway)
    //

    QL_LEVEL_1_RPN_EXPRESSION* pNewParsedQuery = NULL;
    hres = CQueryAnalyser::GetNecessaryQueryForClass(pParsedQuery,
                pDyn->m_pClassObj, awsOverriden, pNewParsedQuery);
    if(FAILED(hres)) return pDest->Return(hres);
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm1(pNewParsedQuery);

    //
    // Get the new text to give to provider
    //

    LPWSTR pszNewQuery = pNewParsedQuery->GetText();
    if(pszNewQuery == NULL) return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm(pszNewQuery);

    DEBUGTRACE((LOG_WBEMCORE,"Query Engine actual: querying dyn provider with <%S>\n", pszNewQuery));

    // Check if the query is empty
    // ===========================

    BOOL bEmpty = FALSE;
    if(lFlags & WBEM_FLAG_SHALLOW)
    {
        // We know that the query is actually a shallow enumeration
        // ========================================================

        bEmpty = TRUE;
    }
    else if(pNewParsedQuery == NULL ||
        (pNewParsedQuery->nNumTokens == 0 &&
         pNewParsedQuery->nNumberOfProperties == 0))
    {
        bEmpty = TRUE;
    }

    if(bEmpty)
    {
        pNs->DynAux_GetInstances (

            (CWbemObject *) pDyn->m_pClassObj,       // class def
            lFlags & ~WBEM_FLAG_SHALLOW,             // used for WBEM_FLAG_SEND_STATUS
            pContext,
            pDest,
            bComplexQuery
        );
    }
    else
    {
        pNs->DynAux_ExecQueryAsync (

            (CWbemObject *) pDyn->m_pClassObj,
            pszNewQuery,
            pszQueryFormat,
            lFlags & ~WBEM_FLAG_SHALLOW,
            pContext,
            pDest,
            bComplexQuery
        ) ;
    }

    return WBEM_S_NO_ERROR;
}



HRESULT CQueryEngine::EliminateDuplications(
                        CRefedPointerArray<CWbemClass>& apClasses,
                        LPCWSTR wszResultClass)
{
    int i;

    if(wszResultClass)
    {
        // Eliminate all classes not derived from wszResultClass
        // =====================================================

        for(i = 0; i < apClasses.GetSize(); i++)
        {
            if(apClasses[i]->InheritsFrom((LPWSTR)wszResultClass) !=
                                        WBEM_S_NO_ERROR)
            {
                // Not derived
                apClasses.RemoveAt(i);
                i--;
            }
        }
    }

    for(i = 0; i < apClasses.GetSize(); i++)
    {
        // Check if this class is abstract. There is no reason asking abstract
        // classes for their objects
        // ===================================================================

        CVar vAbstract;
        if(SUCCEEDED(apClasses[i]->GetQualifier(L"abstract", &vAbstract))
            && vAbstract.GetType() == VT_BOOL && vAbstract.GetBool())
        {
            apClasses.RemoveAt(i);
            i--;
        }
    }

    // Search for pairs // TBD: can be done more efficiently!!
    // =======================================================

    for(i = 0; i < apClasses.GetSize(); i++)
    {
        CWbemClass* pClass1 = apClasses[i];
        if(pClass1 == NULL)
            continue;

        CVar vName;
        apClasses[i]->GetClassName(&vName);

        for (int j = 0; j < apClasses.GetSize(); j++)
        {
            if(j == i) continue;

            CWbemClass* pClass2 = apClasses[j];
            if(pClass2 == NULL)
                continue;

            if (pClass2->InheritsFrom(vName.GetLPWSTR()) == WBEM_S_NO_ERROR)
            {
                // Eliminate class 2 --- it's parent is listed
                // ===========================================

                apClasses.SetAt(j, NULL);
            }
        }
    }

    return WBEM_S_NO_ERROR;
}




//***************************************************************************
//
//***************************************************************************

LPWSTR CQueryEngine::GetPrimaryName(WBEM_PROPERTY_NAME& Name)
{
    if(Name.m_lNumElements < 1 ||
        Name.m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
    {
        return NULL;
    }

    return Name.m_aElements[0].Element.m_wszPropertyName;
}

//***************************************************************************
//
//***************************************************************************

LPWSTR CQueryEngine::GetSimplePropertyName(WBEM_PROPERTY_NAME& Name)
{
    if(Name.m_lNumElements != 1 ||
        Name.m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
    {
        return NULL;
    }

    return Name.m_aElements[0].Element.m_wszPropertyName;
}


//***************************************************************************
//
//***************************************************************************



HRESULT CQueryEngine::ExecSchemaQuery(  IN CWbemNamespace *pNs,
                                        IN LPWSTR pszQuery,
                                        QL_LEVEL_1_RPN_EXPRESSION *pExp,
                                        IN IWbemContext* pContext,
                                        IN CBasicObjectSink* pSink)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    if (pExp->nNumTokens == 0)
    {
        //This means we want all classes...
        pNs->Exec_CreateClassEnum(NULL, 0, pContext, pSink);
        return WBEM_S_NO_ERROR;
    }
    else if ((pExp->nNumTokens == 1) &&
             (pExp->pArrayOfTokens[0].nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL))
    {
        //This means we have a simple expression (hopefully)

        //Now we need to check which type of retrieval we are looking for...
        LPCWSTR szPropName = pExp->pArrayOfTokens[0].PropertyName.GetStringAt(0);
        VARIANT& vValue = pExp->pArrayOfTokens[0].vConstValue;

        if (szPropName == 0)
            return pSink->Return(WBEM_E_INVALID_QUERY);

        if (wbem_wcsicmp(szPropName, L"__CLASS") == 0)
        {
            if ((V_VT(&vValue) == VT_BSTR) && (wcslen(V_BSTR(&vValue))))     // SEC:REVIEWED 2002-03-22 : Needs EH or NULL test
            {
                //Single class retrieval
                CErrorChangingSink Err(pSink, WBEM_E_NOT_FOUND, 0);
                pNs->Exec_GetObject(V_BSTR(&vValue), 0, pContext, &Err);
                return WBEM_S_NO_ERROR;
            }
            else if((V_VT(&vValue) == VT_NULL) ||
                ((V_VT(&vValue) == VT_BSTR) && (wcslen(V_BSTR(&vValue))==0)))    // SEC:REVIEWED 2002-03-22 : Needs EH or NULL test
            {
                // __CLASS = NULL
                return pSink->Return(WBEM_S_NO_ERROR);
            }
            else
            {
                return pSink->Return(WBEM_E_INVALID_QUERY);
            }

        }
        else if (wbem_wcsicmp(szPropName, L"__SUPERCLASS") == 0)
        {
            if(V_VT(&vValue) == VT_BSTR)
            {
                CErrorChangingSink Err(pSink, WBEM_E_INVALID_CLASS, 0);
                //Get things which are hanging off these items
                pNs->Exec_CreateClassEnum(V_BSTR(&vValue), WBEM_FLAG_SHALLOW,
                                            pContext, &Err);
            }
            else if(V_VT(&vValue) == VT_NULL)
            {
                // get things which are hanging off root
                pNs->Exec_CreateClassEnum(L"", WBEM_FLAG_SHALLOW,
                                            pContext, pSink);
            }
            else
            {
                pSink->Return(WBEM_E_INVALID_QUERY);
            }

            return WBEM_S_NO_ERROR;
        }
        else if (wbem_wcsicmp(szPropName, L"__DYNASTY") == 0)
        {
            if(V_VT(&vValue) == VT_BSTR)
            {
                //Get things which are hanging off these items as well as the item itself
                BSTR strClassName = V_BSTR(&vValue);
                IWbemClassObject* pClass = NULL;
                hres = pNs->Exec_GetObjectByPath(strClassName, 0, pContext,&pClass, NULL);
                CReleaseMe rmCls(pClass);
                if(FAILED(hres))
                {
                    if(hres == WBEM_E_NOT_FOUND)
                        hres = S_OK;
                    return pSink->Return(hres);
                }
                else // restore the value
                {
                    hres = WBEM_S_NO_ERROR;
                }

                // Check that this is the root of the dynasty
                CVar vDyn;
                if(FAILED(((CWbemObject*)pClass)->GetDynasty(&vDyn)))
                    return pSink->Return(WBEM_E_FAILED);
                if (vDyn.IsNull())
                    return pSink->Return(WBEM_S_NO_ERROR);
                if(wbem_wcsicmp(vDyn.GetLPWSTR(), strClassName))
                    return pSink->Return(WBEM_S_NO_ERROR);

                pSink->Add(pClass);

                pNs->Exec_CreateClassEnum(strClassName, 0, pContext, pSink);
            }
            else if(V_VT(&vValue) == VT_NULL)
            {
                pSink->Return(WBEM_S_NO_ERROR);
            }
            else
            {
                pSink->Return(WBEM_E_INVALID_QUERY);
            }

            return WBEM_S_NO_ERROR;
        }
        else
        {
            return pSink->Return(WBEM_E_INVALID_QUERY);
        }
    }
    else if ((pExp->nNumTokens == 1) &&
             (pExp->pArrayOfTokens[0].nOperator == QL1_OPERATOR_ISA) &&
             (wbem_wcsicmp(pExp->pArrayOfTokens[0].PropertyName.GetStringAt(0), L"__THIS") == 0))
    {
        //With the isa, we return everything which is derived from this, as well
        //as the class in question...


        VARIANT & var = pExp->pArrayOfTokens[0].vConstValue;
        if(var.vt != VT_BSTR || var.bstrVal == 0)
            return pSink->Return(WBEM_E_INVALID_QUERY);

        CCombiningSink* pCombiningSink = new CCombiningSink(pSink, WBEM_E_NOT_FOUND);
        if (NULL == pCombiningSink) return pSink->Return(WBEM_E_OUT_OF_MEMORY);
        pCombiningSink->AddRef();
        CReleaseMe rmCombSink(pCombiningSink);

        pNs->Exec_GetObject(V_BSTR(&(pExp->pArrayOfTokens[0].vConstValue)), 0, pContext, pCombiningSink);
        pNs->Exec_CreateClassEnum(V_BSTR(&(pExp->pArrayOfTokens[0].vConstValue)), 0, pContext, pCombiningSink);

        return WBEM_S_NO_ERROR;
    }
    // OK, so all the simple cases are dealt with here.  We should now check everything is
    // valid and process it in the best possible way.  If this is a conjunctive query
    // we can also do a little optimisation!

    //Lets validate all of the properties to make sure they are all valid.  If we
    //did not do this, there are scenarios where we would get inconsistencies
    //based on the different code paths.
    BOOL bError = FALSE;

    //While we are at it, we can do a check for the first location of each type of property
    //name (this is used for optimisation!)
    BOOL bConjunctive = IsConjunctiveQuery(pExp);
    QL_LEVEL_1_TOKEN *pThisToken = NULL,
                     *pClassToken = NULL,
                     *pSuperclassToken = NULL,
                     *pDynastyToken = NULL;

    for (int i = 0; i != pExp->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN* pCurrentToken = pExp->pArrayOfTokens + i;
        if (pCurrentToken->PropertyName.GetNumElements() > 1)
        {
            //This is probably an error!
            bError = TRUE;
            break;
        }
        else if (pCurrentToken->PropertyName.GetNumElements() == 1)
        {
            //We need to validate it...
            //If it is an isa, it can only be a "__this", otherwise it has to be one
            //of the "__superclass", "__dynasty" or "__class"

            LPCWSTR wszCurrentPropName = pCurrentToken->PropertyName.GetStringAt(0);
            if (wszCurrentPropName == 0)
            {
                bError = TRUE;
                break;
            }

            if (pCurrentToken->nOperator == QL1_OPERATOR_ISA)
            {
                if(wbem_wcsicmp(wszCurrentPropName, L"__THIS"))
                {
                    bError = TRUE;
                    break;
                }
            }
            else
            {
                if(wbem_wcsicmp(wszCurrentPropName, L"__CLASS") &&
                   wbem_wcsicmp(wszCurrentPropName, L"__SUPERCLASS") &&
                   wbem_wcsicmp(wszCurrentPropName, L"__DYNASTY"))
                {
                    bError = TRUE;
                    break;
                }
            }

            if (bConjunctive)
            {
                VARIANT* pCurrentValue = &(pCurrentToken->vConstValue);

                if (wbem_wcsicmp(wszCurrentPropName, L"__THIS") == 0)
                {
                    if(V_VT(pCurrentValue) != VT_BSTR)
                        bError = TRUE;
                    else if (!pThisToken)
                        pThisToken = pCurrentToken;
                }
                else if (wbem_wcsicmp(wszCurrentPropName, L"__CLASS") == 0)
                {
                    if(V_VT(pCurrentValue) != VT_BSTR && V_VT(pCurrentValue) != VT_NULL)
                        bError = TRUE;
                    else if (pCurrentToken->nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL)
                        bConjunctive = FALSE;
                    else if (!pClassToken)
                        pClassToken = pCurrentToken;

                }
                else if (wbem_wcsicmp(wszCurrentPropName, L"__SUPERCLASS") == 0)
                {
                    if(V_VT(pCurrentValue) != VT_BSTR && V_VT(pCurrentValue) != VT_NULL)
                        bError = TRUE;
                    else if (pCurrentToken->nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL)
                        bConjunctive = FALSE;
                    else if (!pSuperclassToken)
                        pSuperclassToken = pCurrentToken;

                }
                else // DYNASTY
                {
                    if(V_VT(pCurrentValue) != VT_BSTR)
                        bError = TRUE;
                    else if (pCurrentToken->nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL)
                        bConjunctive = FALSE;
                    else if (!pDynastyToken)
                        pDynastyToken = pCurrentToken;

                }
            }
        }

    }

    if (bError == TRUE)  return pSink->Return(WBEM_E_INVALID_QUERY);


    //We need to create a filter sink to deal with this query....
    CQlFilteringSink* pFilteringSink = new CQlFilteringSink(pSink, pExp, pNs, TRUE);
    if (NULL == pFilteringSink) return pSink->Return(WBEM_E_OUT_OF_MEMORY);
    pFilteringSink->AddRef();
    CReleaseMe rmFilter(pFilteringSink);

    //If this is conjunctive we can just retrieve a single item based on a set of
    //rules and pass this through the filter
    if (bConjunctive)
    {
        //We can pick a single item to retrieve and pass this through the filter rather
        //than retrieve all of them

        if (pClassToken)
        {
            //Single class retrieval
            if(V_VT(&(pClassToken->vConstValue)) == VT_NULL)
            {
                // null class --- no such thing
                pFilteringSink->Return(WBEM_S_NO_ERROR);
            }
            else // VT_BSTR
            {
                pNs->Exec_GetObject(V_BSTR(&(pClassToken->vConstValue)), 0,
                    pContext, pFilteringSink);
            }
        }
        else if (pSuperclassToken)
        {
            //Get things which are hanging off these items
            BSTR strParent = NULL;
            if(V_VT(&(pSuperclassToken->vConstValue)) == VT_NULL)
            {
                // null superclass
                strParent = NULL;
            }
            else // VT_BSTR
            {
                strParent = V_BSTR(&(pSuperclassToken->vConstValue));
            }
            pNs->Exec_CreateClassEnum(strParent, 0, pContext, pFilteringSink);
        }
        else if (pDynastyToken)
        {
            //Get things which are hanging off these items and the item itself
            CCombiningSink* pCombiningSink = new CCombiningSink(pFilteringSink, WBEM_E_NOT_FOUND);
            if (NULL == pCombiningSink) return pSink->Return(WBEM_E_OUT_OF_MEMORY);
            rmFilter.release(); // Combining Took Ownership

            pCombiningSink->AddRef();
            // Guaranteed to be VT_BSTR
            pNs->Exec_GetObject(V_BSTR(&(pDynastyToken->vConstValue)), 0, pContext, pCombiningSink);
            pNs->Exec_CreateClassEnum(V_BSTR(&(pDynastyToken->vConstValue)), 0, pContext, pCombiningSink);
            pCombiningSink->Release();
        }
        else if (pThisToken)
        {
            CCombiningSink* pCombiningSink = new CCombiningSink(pFilteringSink, WBEM_E_NOT_FOUND);
            if (NULL == pCombiningSink) return pSink->Return(WBEM_E_OUT_OF_MEMORY);
            rmFilter.release(); // Combining Took Ownership            
            pCombiningSink->AddRef();

            // Guaranteed to be VT_BSTR
            pNs->Exec_GetObject(V_BSTR(&(pThisToken->vConstValue)), 0, pContext, pCombiningSink);
            pNs->Exec_CreateClassEnum(V_BSTR(&(pThisToken->vConstValue)), 0, pContext, pCombiningSink);

            pCombiningSink->Release();
        }
        else
        {
            //Something strange here!
            pNs->Exec_CreateClassEnum(NULL, 0, pContext, pFilteringSink);
        }
    }
    else
    {
        //We need to retrieve all of them and pass through the filter.
        pNs->Exec_CreateClassEnum(NULL, 0, pContext, pFilteringSink);
    }

    return hres;
}

// ****************************************************************************
//
//  CQueryEngine::ValidateQuery
//
//  This function makes sure that the data type of the property matches
//  that of the const.
//
// ****************************************************************************

HRESULT CQueryEngine::ValidateQuery(IN QL_LEVEL_1_RPN_EXPRESSION *pExpr,
                             IN CWbemClass *pClassDef)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN Token = pExpr->pArrayOfTokens[i];
        if (Token.nTokenType == QL1_OP_EXPRESSION)
        {
            WBEM_WSTR wszCimType;
            VARIANT PropVal;
            VariantInit(&PropVal);

            // Make sure this property exists.
            // ===============================
            hr = pClassDef->GetPropertyValue(&Token.PropertyName, 0,
                                                    &wszCimType, &PropVal);

            // If we haven't found it, that's OK... it could
            // be a weakly-typed embedded object.

            if (FAILED(hr))
            {
                hr = WBEM_S_NO_ERROR;
                continue;
            }

            switch(Token.nOperator)
            {
                // These only apply to embedded objects.
            case QL1_OPERATOR_ISA:
            case QL1_OPERATOR_ISNOTA:
            case QL1_OPERATOR_INV_ISA:
            case QL1_OPERATOR_INV_ISNOTA:
                if(V_VT(&PropVal)!= VT_EMBEDDED_OBJECT)
                {
                    if (wszCimType != NULL)
                    {
                        wchar_t wszTemp[7];
                        wcsncpy(wszTemp, wszCimType, 6);  // SEC:REVIEWED 2002-03-22 : Fix this code to be more reasonable / RAID 591466
                        wszTemp[6] = '\0';
                        if (wcscmp(wszTemp, L"object"))
                            hr = WBEM_E_INVALID_QUERY;
                    }
                    else
                        hr = WBEM_E_INVALID_QUERY;

                    if (Token.vConstValue.vt == VT_NULL ||
                        Token.vConstValue.vt == VT_EMPTY)
                        hr = WBEM_E_INVALID_QUERY;
                }
                break;

            default:
                break;
            }

            VariantClear(&PropVal);
            WbemStringFree(wszCimType);

        }

        if (hr != WBEM_S_NO_ERROR)
            break;
    }

    // We don't support WITHIN!

    if (pExpr->Tolerance.m_bExact == FALSE)
    {
        hr = WBEM_E_INVALID_QUERY;
    }

    return hr;

}


//***************************************************************************
//
//***************************************************************************
//
HRESULT CQueryEngine::ExecRepositoryQuery(
    IN CWbemNamespace *pNs,
    IN LPWSTR pszQuery,
    IN LONG lFlags,
    IN IWbemContext* pContext,
    IN CBasicObjectSink* pSink
    )
{
    HRESULT hRes;

    // Also, add check hierarchy for dynamic instances which need deleting
    // Should we simulate by a prior enum and then executing individual delete instance
    // calls?  Would be a big performance drain, possibly.

    hRes = CRepository::ExecQuery(pNs->GetNsSession(), pNs->GetScope(), pszQuery, pSink, 0);

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\secure.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    SECURE.CPP

Abstract:

	defines various routines used for ACL based security.
	It is defined in secure.h

History:

	a-davj    05-NOV-98  Created.

--*/

#ifndef _SECURE_H_
#define _SECURE_H_

// Implements the methods that the __SystemSecurity class supports

// A variation of the CFlexArray which deletes the entries

class CFlexAceArray : public CFlexArray
{
public:
	CFlexAceArray(){};
	~CFlexAceArray();
    HRESULT Serialize(void ** pData, DWORD * pdwSize);
    HRESULT Deserialize(void * pData);
};


enum { SecFlagProvider = 0x2,
       SecFlagWin9XLocal = 0x4,
       SecFlagInProcLogin = 0x20000,
     };

#define FULL_RIGHTS WBEM_METHOD_EXECUTE | WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | \
                    WBEM_WRITE_PROVIDER | WRITE_DAC | READ_CONTROL | WBEM_ENABLE | WBEM_REMOTE_ACCESS
HRESULT GetAces(CFlexAceArray * pFlex, LPWSTR pNsName, bool bNT);
HRESULT PutAces(CFlexAceArray * pFlex, LPWSTR pNsName);
BOOL IsRemote(HANDLE hToken);
CBaseAce * ConvertOldObjectToAce(IWbemClassObject * pObj, bool bGroup);
HRESULT	SetSecurityForNS(IWmiDbSession * pSession,IWmiDbHandle *pNSToSet,
						 IWmiDbSession * pParentSession, IWmiDbHandle * pNSParent, BOOL bExisting = FALSE);
HRESULT CopyInheritAces(CNtSecurityDescriptor & sd, CNtSecurityDescriptor & sdParent);
HRESULT GetSDFromProperty(LPWSTR pPropName, CNtSecurityDescriptor &sd, IWbemClassObject *pThisNSObject);
HRESULT CopySDIntoProperty(LPWSTR pPropName, CNtSecurityDescriptor &sd, IWbemClassObject *pThisNSObject);
HRESULT AddDefaultRootAces(CNtAcl * pacl);
HRESULT StoreSDIntoNamespace(IWmiDbSession * pSession, IWmiDbHandle *pNSToSet, CNtSecurityDescriptor & sd);
bool IsAceValid(DWORD dwMask, DWORD dwType, DWORD dwFlag);
BOOL IsValidAclForNSSecurity (CNtAcl* acl);

//
// Auto reverts the sec flag to TRUE. Always set the flag to true upon method completion
//
class AutoRevertSecTlsFlag
{
private:
	LPVOID m_bDir ;

public:
	AutoRevertSecTlsFlag ( LPVOID );
	AutoRevertSecTlsFlag ( );
	~AutoRevertSecTlsFlag ( );

	VOID SetSecTlsFlag ( LPVOID );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\qengine.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    QENGINE.H

Abstract:

	WinMgmt Query Engine

History:

    raymcc  20-Dec-96   Created
    raymcc   14-Aug-99   Resubmit due to VSS problem.

--*/



#ifndef _QENGINE_H_
#define _QENGINE_H_

class CWbemNamespace;
class CWQLParser;
class CWmiMerger;

class CMergerSink;

//***************************************************************************
//
//***************************************************************************

class CQueryEngine
{
    static int QueryOptimizationTest(
        IN  IWmiDbSession *pSession,
        IN  IWmiDbHandle *pNsHandle,
        IN IWmiDbHandle *pScopeHandle,
        IN  LPCWSTR wszClassName,
        IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
        OUT CWbemObject **pClassDef,
        OUT LPWSTR *pPropToUse,
        OUT CVar **pValToUse,
        OUT int *pnType
        );

    static BOOL IsConjunctiveQuery(
        IN  QL_LEVEL_1_RPN_EXPRESSION *pExp
        );

    static BOOL QueryKeyTest(
        IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
        IN  CWbemObject *pClassDef,
        IN  CWStringArray &aKeyProps
        );

    static BOOL QueryIndexTest(
        IN  QL_LEVEL_1_RPN_EXPRESSION *pExp,
        IN  CWbemObject *pClsDef,
        IN  CWStringArray &aIndexedProps,
        OUT LPWSTR *pPropToUse,
        OUT CVar **pValToUse,
        OUT int *pnType
        );

    static int KeyedQuery(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNsHandle,
        IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
        IN CWbemObject *pClassDef,
        IN DWORD dwFlags,
        IN CBasicObjectSink* pDest, // no status
		IN CWbemNamespace * pNs
        );

    static LPWSTR GetObjectPathFromQuery(
        IN CWbemObject *pClassDef,
        IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
		IN CWbemNamespace * pNs
        );


    static HRESULT ExecQlQuery(
        IN CWbemNamespace *pNs,
        IN LPWSTR pszQuery,
        IN LONG lFlags,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pSink
        );

    static HRESULT ExecRepositoryQuery(
        IN CWbemNamespace *pNs,
        IN LPWSTR pszQuery,
        IN LONG lFlags,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pSink
        );

    static HRESULT ExecComplexQuery(
        IN CWbemNamespace *pNs,
        IN LPWSTR pszQuery,
        IN LONG lFlags,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pSink
        );

	// New Function
    static  HRESULT EvaluateSubQuery(
        IN CWbemNamespace *pNs,
        IN CDynasty *pCurrentDyn,
        IN LPWSTR pszTextQuery,
        IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
        IN IWbemContext* pContext,
        IN BOOL bSuppressStaticChild,
		IN CWmiMerger* pMerger,
		IN CMergerSink* pSink,
        long lFlags,
		bool bHasRightSibling = false
        );

	// Old Function
    static  HRESULT EvaluateSubQuery_old(
        IN CWbemNamespace *pNs,
        IN CDynasty *pCurrentDyn,
        IN LPWSTR pszTextQuery,
        IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
        IN IWbemContext* pContext,
        IN BOOL bSuppressStaticChild,
        IN CBasicObjectSink* pSink, // must have combining semantics
        long lFlags,
		bool bHasRightSibling = false
        );

    static HRESULT ExecAtomicDynQlQuery(
        IN CWbemNamespace *pNs,
        IN CDynasty* pDyn,
        IN LPWSTR pszQueryFormat,
        IN LPWSTR pszQuery,
        IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
        IN LONG lFlags,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pDest, // must support selective filtering ,
		IN BOOL bHasChildren
        );

    static HRESULT DirectRead(
        IN CWbemNamespace *pNs,
        IN CDynasty *pCurrentDyn,
        IN LPWSTR wszTextQuery,
        IN QL_LEVEL_1_RPN_EXPRESSION *pParsedQuery,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pSink,
        IN long lFlags
        );


    static LPWSTR ConstructReferenceProviderQuery(
            CWbemNamespace* pNamespace, IWbemContext* pContext,
            LPCWSTR wszRefClass, CWbemClass* pRefClass, CWbemObject* pTargetObj,
            LPCWSTR wszTargetPathQ,
            LPCWSTR wszTargetClass, LPCWSTR wszTargetRole,
            LPCWSTR wszResultClass, LPCWSTR wszRequiredQualifier,
            LPCWSTR wszEndpointClass, LPCWSTR wszEndpointRole,
            CWStringArray& awsPossibleRoles
            );


    static HRESULT ExecReferencesQuery(CWbemNamespace* pNs,
            IWbemContext* pContext,
            LPCWSTR wszTargetPath,  LPCWSTR wszTargetRole,
            LPCWSTR wszResultClass, LPCWSTR wszRequiredQualifier,
            LPCWSTR wszEndpointClass, LPCWSTR wszEndpointRole,
            CBasicObjectSink* pSink,
			DWORD dwQueryType
            );

    static HRESULT ExecSchemaReferencesQuery(CWbemNamespace* pNs,
            IWbemContext* pContext, CWbemClass* pClass,
            LPCWSTR wszRealClassName,  LPCWSTR wszTargetRole,
            LPCWSTR wszResultClass, LPCWSTR wszRequiredQualifier,
            LPCWSTR wszEndpointClass, LPCWSTR wszEndpointRole,
            CBasicObjectSink* pSink
            );

    static HRESULT ExecNormalReferencesQuery(CWbemNamespace* pNs,
            IWbemContext* pContext, CWbemObject* pObj,
            LPCWSTR wszTargetPath,  LPCWSTR wszTargetRole,
            LPCWSTR wszResultClass, LPCWSTR wszRequiredQualifier,
            LPCWSTR wszEndpointClass, LPCWSTR wszEndpointRole,
            BOOL bClassDefsOnly,
            CBasicObjectSink* pSink
            );

    static HRESULT EliminateDerivedProperties(
            IN  QL_LEVEL_1_RPN_EXPRESSION* pOrigQuery,
            IN  CWbemClass* pClass,
            IN  BOOL bRelax,
            OUT QL_LEVEL_1_RPN_EXPRESSION** ppNewQuery
            );

    static BOOL IsTokenAboutClass(IN QL_LEVEL_1_TOKEN& Token,
                                       IN CWbemClass* pClass);

    static HRESULT AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION** ppNew
                                );

    static HRESULT OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION** ppNew
                                );

    static void AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource
                                );

    static BSTR GetParentPath(CWbemInstance* pInst, LPCWSTR wszClassName);

	static HRESULT ExecSchemaQuery(
        IN CWbemNamespace *pNs,
		IN LPWSTR pszQuery,
		QL_LEVEL_1_RPN_EXPRESSION *pExp,
		IN IWbemContext* pContext,
		IN CBasicObjectSink* pSink
        );

    static HRESULT ValidateQuery(IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
                                 IN CWbemClass *pClassDef
                                 );

    static HRESULT FindOverridenProperties(CDynasty* pDyn,
                                                CWStringArray& awsOverriden,
                                                bool bIncludeThis = false);

public:
    enum { no_error, failed, syntax_error,
           invalid_query, invalid_query_language,
           use_key, use_table_scan, use_index,
           invalid_parameter, invalid_class,
           not_found
         };

    static int ExecAtomicDbQuery(
        IN IWmiDbSession *pSession,
        IN IWmiDbHandle *pNsHandle,
        IN IWmiDbHandle *pScopeHandle,
        IN LPCWSTR wszClassName,
        IN QL_LEVEL_1_RPN_EXPRESSION *pExp,
        IN CBasicObjectSink* pDest, // no status!
		IN CWbemNamespace * pNs
        );

    static HRESULT QueryAllClasses(
        IN CWbemNamespace *pNs,
        IN LPWSTR pszParent,
        OUT IEnumWbemClassObject **ppEnum
        );

    static HRESULT QueryImmediateClasses(
        IN CWbemNamespace *pNs,
        IN LPWSTR pszParent,
        OUT IEnumWbemClassObject **ppEnum
        );

    static HRESULT ExecQuery(
        IN CWbemNamespace *pNs,
        IN LPWSTR pQueryFormat,
        IN LPWSTR pQuery,
        IN LONG lFlags,
        IN IWbemContext* pContext,
        IN CBasicObjectSink* pSink
        );
    static BSTR AdjustPathToClass(LPCWSTR wszRelPath, LPCWSTR wszClassName);
    static LPWSTR NormalizePath(LPCWSTR wszObjectPath, CWbemNamespace * pNs);
    static LPWSTR GetSimplePropertyName(WBEM_PROPERTY_NAME& Name);
    static LPWSTR GetPrimaryName(WBEM_PROPERTY_NAME& Name);

    static BOOL IsAReferenceToClass(
        IN CWbemNamespace* pNamespace,
        IWbemContext* pContext,
        IN CWbemObject* pObj,
        IN LPCWSTR wszPropName,
        IN CWbemObject* pTargetClass,
        IN bool bCheckPropValue
        );

    static BOOL AreClassesRelated(
        IN CWbemNamespace* pNamespace,
        IWbemContext* pContext,
        CWbemObject* pClass1,
        LPCWSTR wszClass2
        );

protected:
    static HRESULT EliminateDuplications(
                    CRefedPointerArray<CWbemClass>& apClasses,
                    LPCWSTR wszResultClass);
};

//***************************************************************************
//
//***************************************************************************

class CQueryExpression
{
protected:
    QL_LEVEL_1_RPN_EXPRESSION* m_pExpr;
    long m_lRef;

protected:
    virtual ~CQueryExpression()
    {
        delete m_pExpr;
    }
public:
    CQueryExpression(QL_LEVEL_1_RPN_EXPRESSION* pExpr)
        : m_pExpr(pExpr), m_lRef(1)
    {
    }
    void AddRef() {InterlockedIncrement(&m_lRef);}
    void Release() {if(InterlockedDecrement(&m_lRef) == 0) delete this;}
    INTERNAL QL_LEVEL_1_RPN_EXPRESSION* GetExpr() { return m_pExpr;}
};

//***************************************************************************
//
//***************************************************************************

class CQlFilteringSink : public CFilteringSink
{
protected:
    QL_LEVEL_1_RPN_EXPRESSION* m_pExpr;
    BOOL m_bFilterNow;
	CWbemNamespace * m_pNs;
public:
    CQlFilteringSink(CBasicObjectSink* pDest,
                    ADDREF QL_LEVEL_1_RPN_EXPRESSION* pExp,
                    CWbemNamespace * pNamespace, BOOL bFilterNow = TRUE
                    );
    ~CQlFilteringSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam
                         );

    virtual IWbemObjectSink* GetIndicateSink() {return this;}
    virtual IWbemObjectSink* GetStatusSink() {return this;}

    static BOOL Test(CWbemObject* pObj, QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                        CWbemNamespace * pNs
                        );

    BOOL Test(CWbemObject* pObj);

    static int EvaluateToken(IWbemPropertySource *pTestObj,
                                QL_LEVEL_1_TOKEN& Tok,
                                CWbemNamespace * pNs
                                );
};

//***************************************************************************
//
//***************************************************************************

class CProjectingSink : public CForwardingSink
{
protected:
    CLimitationMapping m_Map;
    BOOL m_bValid;
    BOOL m_bProjecting;
    WString m_wsError;
    CCritSec m_cs;

public:
    CProjectingSink(CBasicObjectSink* pDest,
                    CWbemClass* pClassDef,
                    READONLY QL_LEVEL_1_RPN_EXPRESSION* pExp,
                    long lQueryFlags);
    BOOL IsValid() {return m_bValid;}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CClassDefsOnlyCancelSink : public CForwardingSink
{
protected:
    CCritSec m_cs;
    CWbemNamespace* m_pNamespace;
    WString m_wsTargetObj;
    CWStringArray* m_pawsRemainingRoles;
    BOOL m_bCancelled;

public:
    CClassDefsOnlyCancelSink(CBasicObjectSink* pDest,
            CWbemNamespace* pNamespace,
            LPCWSTR wszTargetObj, CWStringArray* pawsPossibleRoles);
    ~CClassDefsOnlyCancelSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}

    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
protected:
    BOOL DoHaveEnough(CWbemObject* pObj);
};

//***************************************************************************
//
//***************************************************************************

class CMerger
{
protected:
    class CMemberSink : public CObjectSink
    {
    protected:
        CMerger* m_pMerger;
    public:
        CMemberSink(CMerger* pMerger) : CObjectSink(0), m_pMerger(pMerger)
        {}

        STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
        virtual BOOL IsTrusted()
            {return m_pMerger->m_pDest->IsTrusted();}
        virtual BOOL IsApartmentSpecific()
            {return m_pMerger->m_pDest->IsApartmentSpecific();}
    };
    friend CMemberSink;

    class COwnSink : public CMemberSink
    {
    public:
        COwnSink(CMerger* pMerger) : CMemberSink(pMerger)
        {
            m_pMerger->AddRef();
        }
        ~COwnSink();

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

    };
    friend COwnSink;

    class CChildSink : public CMemberSink
    {
    public:
        CChildSink(CMerger* pMerger) : CMemberSink(pMerger)
        {
            m_pMerger->AddRef();
        }
        ~CChildSink();

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);

    };
    friend CChildSink;

public:
    struct CRecord
    {
        CWbemInstance* m_pData;
        BOOL m_bOwn;
    };
protected:
    COwnSink* m_pOwnSink;
    CChildSink* m_pChildSink;
    CBasicObjectSink* m_pDest;

    BOOL m_bDerivedFromTarget;
    CWbemClass* m_pOwnClass;
    CWbemNamespace* m_pNamespace;
    IWbemContext* m_pContext;

    CCritSec m_cs;

    std::map<WString, CRecord, WSiless, wbem_allocator<CRecord> > m_map;

    BOOL m_bOwnDone;
    BOOL m_bChildrenDone;
    WString m_wsClass;
    long m_lRef;

    IServerSecurity* m_pSecurity;

protected:
    HRESULT AddOwnObject(IWbemClassObject* pObj);
    HRESULT AddChildObject(IWbemClassObject* pObj);

    void Enter() { m_cs.Enter();}
    void Leave() { m_cs.Leave();}

    long AddRef();
    long Release();

    void OwnIsDone();
    void ChildrenAreDone();

    void DispatchChildren();
    void DispatchOwn();
    void GetKey(IWbemClassObject* pInst, WString& wsKey);
    void GetOwnInstance(LPCWSTR wszKey);
    BOOL IsDone() {return m_bOwnDone && m_bChildrenDone;}
public:
    CMerger(CBasicObjectSink* pDest, CWbemClass* pOwnClass,
                CWbemNamespace* pNamespace = NULL,
                IWbemContext* pContext = NULL);
    ~CMerger();

    BOOL IsValid(){ return (m_pOwnSink && m_pChildSink); };

    void SetIsDerivedFromTarget(BOOL bIs);
    CBasicObjectSink* GetOwnSink() {return m_pOwnSink;}
    CBasicObjectSink* GetChildSink() {return m_pChildSink;}
};



//***************************************************************************
//
//***************************************************************************

struct CProjectionRule
{
    WString m_wsPropName;
    enum {e_Invalid, e_TakeAll, e_TakePart} m_eType;
    CUniquePointerArray<CProjectionRule> m_apPropRules;

public:
    CProjectionRule() : m_eType(e_TakePart)
    {}
    CProjectionRule(LPCWSTR wszPropName)
        : m_wsPropName(wszPropName), m_eType(e_TakePart)
    {}

    CProjectionRule* Find(LPCWSTR wszName);
    int GetNumElements(){return m_apPropRules.GetSize();};
};

//***************************************************************************
//
//***************************************************************************

class CComplexProjectionSink : public CForwardingSink
{
protected:
    CProjectionRule m_TopRule;
    WString m_FirstTable;
    WString m_FirstTableAlias;

protected:
    void AddColumn(CFlexArray& aFields, LPCWSTR wszPrefix);
    HRESULT Project(IWbemClassObject* pObj, CProjectionRule* pRule,
                                         IWbemClassObject** ppProj);
public:
    CComplexProjectionSink(CBasicObjectSink* pDest, CWQLScanner* pParser);
    ~CComplexProjectionSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};


#endif




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\sechelp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SECHELP.H

Abstract:

    Security Helper functions

History:

    raymcc  29-Apr-97   Created

--*/

#ifndef _SECHELP_H_
#define _SECHELP_H_
#include "corepol.h"

class  WBEMSecurityHelp
{
public:
    enum { NoError, InvalidParameter, Failed };

    static int ComputeMD5(
        LPBYTE pSrcBuffer,         
        int    nArrayLength,
        LPBYTE *pMD5Digest         // Use operator delete to deallocate
        );
        // Returns one of the enum values

    static int MakeWBEMAccessTokenFromMD5(
        LPBYTE pNonce,             // Points to a 16-byte nonce
        LPBYTE pPasswordDigest,    // MD5 of the password
        LPBYTE *pAccessToken       // Use operator delete to deallocate
        );

    static int MakeWBEMAccessToken(
        LPBYTE pNonce,             // Points to a 16-byte nonce
        LPWSTR pszPassword,        // Can be NULL, blank, or anything normal7
        LPBYTE *pAccessToken       // Use operator delete to deallocate        
        );
        // Returns one of the enum values
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\secure.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    SECURE.CPP

Abstract:

    Contains various routines used for ACL based security.
    It is defined in secure.h

History:

    a-davj    05-NOV-98  Created.

--*/

#include "precomp.h"
#include <wbemcore.h>
#include <oleauto.h>
#include <genutils.h>
#include <safearry.h>
#include <oahelp.inl>
#include <fcntl.h>
#define WBEM_WMISETUP       __TEXT("WMISetup")

// /////////////////////////////////////////////////

AutoRevertSecTlsFlag::AutoRevertSecTlsFlag ( LPVOID dir )
{
    m_bDir = dir ;
    TlsSetValue ( CCoreQueue::GetSecFlagTlsIndex(), (LPVOID)dir );
}

AutoRevertSecTlsFlag::AutoRevertSecTlsFlag()
{
    m_bDir = TlsGetValue ( CCoreQueue::GetSecFlagTlsIndex() ) ;
}

AutoRevertSecTlsFlag::~AutoRevertSecTlsFlag()
{
    TlsSetValue ( CCoreQueue::GetSecFlagTlsIndex(), (LPVOID)1 ) ;
}

VOID AutoRevertSecTlsFlag::SetSecTlsFlag ( LPVOID dir )
{
    TlsSetValue ( CCoreQueue::GetSecFlagTlsIndex(), (LPVOID)dir );
}


//***************************************************************************
//
//  SetOwnerAndGroup
//
//  Sets the owner and group of the SD to the Admininstrators group
//
//***************************************************************************

BOOL SetOwnerAndGroup(CNtSecurityDescriptor &sd)
{
    PSID pRawSid;
    BOOL bRet = FALSE;

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    if(AllocateAndInitializeSid( &id, 2,            // SEC:REVIEWED 2002-03-22 : OK
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmins(pRawSid);
        FreeSid(pRawSid);
        if (CNtSid::NoError != SidAdmins.GetStatus()) return FALSE;
            
        bRet = sd.SetGroup(&SidAdmins);      // Access check doesnt really care what you put, so long as you
                                      // put something for the owner
        if(bRet)
            bRet = sd.SetOwner(&SidAdmins);

        return bRet;
    }
    return bRet;
}



//***************************************************************************
//
//  CFlexAceArray::~CFlexAceArray()
//
//  Cleans up safe array entries.
//
//***************************************************************************

CFlexAceArray::~CFlexAceArray()
{
    for(int iCnt = 0; iCnt < Size(); iCnt++)
    {
        CBaseAce * pace = (CBaseAce *)GetAt(iCnt);
        if(pace)
            delete pace;
    }
    Empty();
}

//***************************************************************************
//
//  SetStatusAndReturnOK
//
//  If there is an error, it dumps an error message.  It also sets the status
//
//***************************************************************************

HRESULT SetStatusAndReturnOK(SCODE sc, IWbemObjectSink* pSink, char * pMsg)
{
    if(sc != S_OK && pMsg)
        ERRORTRACE((LOG_WBEMCORE, "SecurityMethod failed doing %s, sc = 0x%x", pMsg, sc));
    pSink->SetStatus(0,sc, NULL, NULL);
    return S_OK;
}

//***************************************************************************
//
//  DumpErrorMsgAndReturn
//
//  Dumps out an error message
//
//***************************************************************************

HRESULT DumpErrorMsgAndReturn(SCODE sc, char * pMsg)
{
    if(pMsg)
        ERRORTRACE((LOG_WBEMCORE, "%s, sc = 0x%x", pMsg, sc));
    return sc;
}

//***************************************************************************
//
//  CWbemNamespace::GetSDMethod
//
//  Implements the GetSD method.  This method returns the security descriptor
//
//***************************************************************************

HRESULT CWbemNamespace::GetSDMethod(IWbemClassObject* pOutParams)
{
    // Load up the return object with the security descriptor

    SCODE sc = EnsureSecurity();
    if(sc != S_OK)
        return DumpErrorMsgAndReturn(sc, "GetSDMethod failed creating a SD");

    CNtSecurityDescriptor &sd = GetSDRef();

    sc = CopySDIntoProperty(L"SD", sd, pOutParams);
    return sc;

}

//***************************************************************************
//
//  SetSDMethod
//
//  Implements the SetSD method.  This method sets the security descriptor
//
//***************************************************************************
HRESULT CWbemNamespace::RecursiveSDMerge()
{
    // Enumerate the child namespaces

    CSynchronousSink* pSyncSink = CSynchronousSink::Create();
    if(pSyncSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pSyncSink->AddRef();
    CReleaseMe rm4(pSyncSink);

    HRESULT hres = CRepository::ExecQuery ( m_pSession, m_pNsHandle, L"select * from __Namespace", pSyncSink, WBEM_FLAG_DEEP );
    if(FAILED(hres))
        return hres;

    pSyncSink->Block();

    // For each child

    for(int i = 0; i < pSyncSink->GetObjects().GetSize(); i++)
    {

        // Get the child namespace

        CWbemNamespace* pNewNs = CWbemNamespace::CreateInstance();

        if (pNewNs == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        CReleaseMe rm2((IWbemServices *)pNewNs);

        VARIANT var;
        VariantInit(&var);
        CWbemObject* pObj = (CWbemObject*)pSyncSink->GetObjects().GetAt(i);
        hres = pObj->Get(L"name", 0, &var, NULL, NULL);
        if(SUCCEEDED(hres) && var.vt == VT_BSTR && var.bstrVal && m_pThisNamespace)
        {
            CClearMe cm(&var);
            DWORD dwLen = wcslen(m_pThisNamespace) + wcslen(var.bstrVal) + 2;    // SEC:REVIEWED 2002-03-22 : OK, Nulls are provably there
            WCHAR * pNewName = new WCHAR[dwLen];
            if(pNewName == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            CDeleteMe<WCHAR> dm(pNewName);
            StringCchCopyW(pNewName, dwLen, m_pThisNamespace);
            StringCchCatW(pNewName, dwLen, L"\\");
            StringCchCatW(pNewName, dwLen, var.bstrVal);

            hres = pNewNs->Initialize(pNewName,
                                NULL,
                                m_dwSecurityFlags, m_dwPermission, m_bForClient, FALSE,
                                NULL, 0xFFFFFFFF, FALSE, NULL);
            if(FAILED(hres))
                return hres;
            // Merge parents SD into the child

            if(pNewNs->IsNamespaceSDProtected())
                continue;

            hres = SetSecurityForNS(pNewNs->m_pSession, pNewNs->m_pNsHandle, m_pSession, m_pNsHandle, TRUE);
            if(FAILED(hres))
                return hres;
            // Recursively call the child
            
            hres = pNewNs->RecursiveSDMerge();
            if (FAILED(hres))
                return hres;
        }
    }
    return S_OK;
}

BOOL IsProtected(CNtSecurityDescriptor & sd)
{
    PSECURITY_DESCRIPTOR pActual = sd.GetPtr();
    if(pActual == NULL)
        return FALSE;

    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD dwRevision;
    BOOL bRet = GetSecurityDescriptorControl(pActual, &Control, &dwRevision);
    if(bRet == FALSE)
        return FALSE;

    if(Control & SE_DACL_PROTECTED)
        return TRUE;
    else
        return FALSE;

}

BOOL CWbemNamespace::IsNamespaceSDProtected()
{
    // Get the SD for this namespace

    HRESULT hRes = EnsureSecurity();
    if(FAILED(hRes))
        return FALSE;

    // check the control flag

    return IsProtected(m_sd);

}


HRESULT StripOutInheritedAces(CNtSecurityDescriptor &sd)
{

    // Get the DACL

    CNtAcl * DestAcl;
    DestAcl = sd.GetDacl();
    if(DestAcl == FALSE)
        return WBEM_E_INVALID_PARAMETER;
    CDeleteMe<CNtAcl> dm(DestAcl);

    // enumerate through the aces

    DWORD dwNumAces = DestAcl->GetNumAces();
    BOOL bChanged = FALSE;
    for(long nIndex = (long)dwNumAces-1; nIndex >= 0; nIndex--)
    {
        CNtAce *pAce = DestAcl->GetAce(nIndex);
        if(pAce && CNtAce::NoError == pAce->GetStatus())
        {
            long lFlags = pAce->GetFlags();
            if(lFlags & INHERITED_ACE)
            {
                DestAcl->DeleteAce(nIndex);
                bChanged = TRUE;
                delete pAce;
            }
        }
    }
    if(bChanged)
        sd.SetDacl(DestAcl);
    return S_OK;
}


HRESULT CWbemNamespace::GetParentsInheritableAces(CNtSecurityDescriptor &sd)
{
    // Get the parent namespace's SD

    if(m_pThisNamespace == NULL)
        return WBEM_E_CRITICAL_ERROR;

    // Start by figuring out what the parents name is.  Do this by copying the namespace name,
    // then nulling out the last back slash.

    int iLen = wcslen(m_pThisNamespace);   // SEC:REVIEWED 2002-03-22 : OK, Null is provably there
    WCHAR * pParentName = new WCHAR[iLen + 1];
    if(pParentName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CDeleteMe<WCHAR> dm(pParentName);
    StringCchCopyW(pParentName, iLen + 1, m_pThisNamespace);

    BOOL bFoundBackSlash = FALSE;
    WCHAR * pTest = pParentName+iLen-1;

    for (; pTest >= pParentName; pTest--)
    {
        if ( *pTest == '\\' || *pTest == '/' )
        {
            bFoundBackSlash = TRUE;
            *pTest = 0;
            break;
        }
    }
    if(!bFoundBackSlash)
        return S_OK;        // probably already in root

    // Open the parent namespace

    CWbemNamespace* pNewNs = CWbemNamespace::CreateInstance();

    if (pNewNs == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    IUnknown * pUnk = NULL;
    HRESULT hres = pNewNs->QueryInterface(IID_IUnknown, (void **)&pUnk);
    if(FAILED(hres))
        return hres;
    pNewNs->Release();      // ref count held by pUnk
    CReleaseMe rm2(pUnk);

    hres = pNewNs->Initialize(pParentName,
                            NULL,
                            m_dwSecurityFlags, m_dwPermission, m_bForClient, FALSE,
                            NULL, 0xFFFFFFFF, FALSE, NULL);
    if(FAILED(hres))
        return hres;

    hres = pNewNs->EnsureSecurity();
    if(FAILED(hres))
        return FALSE;

    // Go through the parents dacl and add and inheritiable aces to ours.

    hres = CopyInheritAces(sd, pNewNs->m_sd);
    return hres;
}


HRESULT CWbemNamespace::SetSDMethod(IWbemClassObject* pInParams)
{

    // Make sure that there is an input argument

    if(pInParams == NULL)
        return DumpErrorMsgAndReturn(WBEM_E_INVALID_PARAMETER, "SetSD failed due to null pInParams");

    // Get the security descriptor argument

    CNtSecurityDescriptor sd;
    HRESULT hr = GetSDFromProperty(L"SD", sd, pInParams);
    if(FAILED(hr))
        return hr;

    // Check to make sure the SD is valid before attempting to store it
    // CNtSecurityDescriptor does this via IsValidSecurityDescriptor so
    // all we need to do is check the status of sd before continuing.
    // NT RAID#:  152990        [marioh]
    if ( sd.GetStatus() != CNtSecurityDescriptor::NoError )
        return WBEM_E_INVALID_OBJECT;
    

    //
    // Reject SecurityDescriptors with NULL Owner or NULL group
    //
    // This is temporarily removed since _SOMEONE_ decided we need
    // to RI yesterday and test wasnt quite done with smoking this.
    //
    CNtSid *pTmpSid = sd.GetOwner ( ) ;
    CNtSid *pTmpSid2 = sd.GetGroup ( ) ;
    CDeleteMe<CNtSid> owner ( pTmpSid ) ;
    CDeleteMe<CNtSid> group ( pTmpSid2 ) ;

    if ( pTmpSid == NULL || pTmpSid2 == NULL )
    {
        return WBEM_E_FAILED ;
    }
    if (CNtSid::NoError != pTmpSid->GetStatus() || CNtSid::NoError != pTmpSid2->GetStatus())
    {
        return WBEM_E_FAILED;
    }
            
    // Some editors return inherited aces, and others dont.  Strip the inherited ones so
    // that we have a consistent SD.

    StripOutInheritedAces(sd);

    //
    // Make sure to order the ACEs that are in the pInparams.
    // NT Bug: 515545    [marioh]
    //
    CNtAcl* pAcl = sd.GetDacl ( ) ;
    CDeleteMe <CNtAcl> dacl ( pAcl ) ;
    CNtAcl* pOrderedAcl = NULL ;
    CDeleteMe <CNtAcl> ordDacl ( pOrderedAcl ) ;

    if ( pAcl != NULL )
    {
        //
        // Order the DACL.
        //
        pOrderedAcl = pAcl->OrderAces ( ) ;
        if ( pOrderedAcl == NULL )
        {
            return WBEM_E_FAILED ;
        }

        //
        // Now, set the DACL to the newly ordered one.
        //
        if ( sd.SetDacl ( pOrderedAcl ) == FALSE )
        {
            return WBEM_E_FAILED ;
        }
    }

    // Get the inherited aces from the parent

    if(!IsProtected(sd))
        GetParentsInheritableAces(sd);

    // Store the sd.
    hr = StoreSDIntoNamespace(m_pSession, m_pNsHandle, sd);
    if(FAILED(hr))
        return hr;

    hr = RecursiveSDMerge();    
    return hr;
}

//***************************************************************************
//
//  IsAceValid()
//
//  Does a sanity check on aces
//
//***************************************************************************

bool IsAceValid(DWORD dwMask, DWORD dwType, DWORD dwFlag)
{
    bool bOK = true;
    if(dwMask & WBEM_FULL_WRITE_REP && ((dwMask & WBEM_PARTIAL_WRITE_REP) == 0 ||
        (dwMask & WBEM_WRITE_PROVIDER) == 0))
    {
        bOK = false;
        return false;
    }

    // DONT allow INHERIT_ONLY_ACE with out CONTAINER_INHERIT

    DWORD dwTemp = dwFlag & (INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE);
    if(dwTemp == INHERIT_ONLY_ACE)
        bOK = false;

    DWORD dwBadAccess = dwMask & ~(FULL_RIGHTS);
    DWORD dwBadFlag = dwFlag & ~(CONTAINER_INHERIT_ACE | NO_PROPAGATE_INHERIT_ACE |
                        INHERIT_ONLY_ACE | INHERITED_ACE);
    if(dwBadFlag || dwBadAccess)
        bOK = false;

    if((dwType != 0) && (dwType != 1))
        bOK = false;

    if(!bOK)
        ERRORTRACE((LOG_WBEMCORE, "Got passed a bad ace, dwMask=0x%x, dwType=0x%x, dwFlag=0x%x",
            dwMask, dwType, dwFlag));

    return bOK;
}


//***************************************************************************
//
//  GetCallerAccessRightsMethod
//
//  Implements the GetCallerAccessRights methods.  It returns the access rignts
//  of the current caller.
//
//***************************************************************************

HRESULT CWbemNamespace::GetCallerAccessRightsMethod(IWbemClassObject* pOutParams)
{
    VARIANT var;
    var.vt = VT_I4;

    var.lVal = m_dwPermission;
    //
    // Instead of using the 'saved' permission set from original namespace connect
    // we get the caller access rights every time. This is to avoid the scenario
    // whereby user A connects and then sets the proxyblanket to user B and makes
    // a call to GetCallerAccessRights. Without getting the access rights each time
    // we would end of with A's access rights.
    //
    var.lVal = GetUserAccess ( ) ;
    //var.lVal = m_dwPermission;

    SCODE sc = pOutParams->Put(L"rights" , 0, &var, 0);
    if(sc != S_OK)
        return DumpErrorMsgAndReturn(sc, "GetCallerAccessRights failed putting the dwAccesMask property");
    return S_OK;
}

//***************************************************************************
//
//  SecurityMethod
//
//  Implements the security methods.
//
//***************************************************************************

HRESULT CWbemNamespace::SecurityMethod(LPWSTR wszMethodName, long lFlags,
                       IWbemClassObject *pInParams, IWbemContext *pCtx,
                       IWbemObjectSink* pSink)
{
    SCODE sc;

    // Do some parameter checking

    if(pSink == NULL || wszMethodName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;
    IWbemClassObject* pOutParams = NULL;

    // Get the class object

    sc = GetObject(L"__SystemSecurity", 0, pCtx, &pClass, NULL);
    if(sc != S_OK || pClass == NULL)
        return SetStatusAndReturnOK(sc, pSink, "getting the class object");

    // All the methods return data, so create an instance of the
    // output argument class.

    sc = pClass->GetMethod(wszMethodName, 0, NULL, &pOutClass);
    pClass->Release();
    if(sc != S_OK)
        return SetStatusAndReturnOK(sc, pSink, "getting the method");

    sc = pOutClass->SpawnInstance(0, &pOutParams);
    pOutClass->Release();
    if(sc != S_OK || pOutParams == NULL)
        return SetStatusAndReturnOK(sc, pSink, "spawning an instance of the output class");

    CReleaseMe rm(pOutParams);

    // Depending on the actual method, call the appropritate routine

    if(!wbem_wcsicmp(wszMethodName, L"GetSD"))
    {
        if (!Allowed(READ_CONTROL))
            sc = WBEM_E_ACCESS_DENIED;
        else
            sc = GetSDMethod(pOutParams);
    }
    else if(!wbem_wcsicmp(wszMethodName, L"Get9XUserList"))
    {
        sc = WBEM_E_METHOD_DISABLED;
    }
    else if(!wbem_wcsicmp(wszMethodName, L"SetSD"))
    {
        if (!Allowed(WRITE_DAC))
            sc = WBEM_E_ACCESS_DENIED;
        else
            sc = SetSDMethod(pInParams);
    }
    else if(!wbem_wcsicmp(wszMethodName, L"Set9XUserList"))
    {
        sc = WBEM_E_METHOD_DISABLED;
    }
    else if(!wbem_wcsicmp(wszMethodName, L"GetCallerAccessRights"))
    {
        sc = GetCallerAccessRightsMethod(pOutParams);
    }
    else
    {
        return SetStatusAndReturnOK(WBEM_E_INVALID_PARAMETER, pSink, "Invalid method name");
    }
    if(sc != S_OK)
        return SetStatusAndReturnOK(sc, pSink, "calling method");

    // Set the return code

    VARIANT var;
    var.vt = VT_I4;
    var.lVal = 0;    // special name for return value.
    sc = pOutParams->Put(L"ReturnValue" , 0, &var, 0);
    if(sc != S_OK)
        return SetStatusAndReturnOK(sc, pSink, "setting the ReturnCode property");

    // Send the output object back to the client via the sink. Then
    // release the pointers and free the strings.

    sc = pSink->Indicate(1, &pOutParams);

    // all done now, set the status
    sc = pSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  GetUserAccess
//
//  Determines the allowed access for a user.
//
//***************************************************************************

DWORD CWbemNamespace::GetUserAccess()
{
    DWORD dwRet = 0;
    if(IsInAdminGroup())
        return FULL_RIGHTS;

    if(S_OK !=EnsureSecurity())
        return dwRet;   // nothing!

    dwRet = GetNTUserAccess();

    if((dwRet & WBEM_REMOTE_ACCESS) == 0)
    {
        HANDLE hAccessToken;
        if(SUCCEEDED(GetAccessToken(hAccessToken)))
        {
            BOOL bRemote = IsRemote(hAccessToken);
            CloseHandle(hAccessToken);
            if(bRemote)
                dwRet = 0;
        }
    }
    if(m_pThisNamespace && (wbem_wcsicmp(L"root\\security", m_pThisNamespace) == 0 ||
                            wbem_wcsicmp(L"root/security", m_pThisNamespace) == 0))
        if((dwRet  & READ_CONTROL) == 0)
            dwRet = 0;
    return dwRet;

}

//***************************************************************************
//
//  GetNTUserAccess
//
//  Determines the allowed access for a user.
//
//***************************************************************************

DWORD CWbemNamespace::GetNTUserAccess()
{

    HANDLE hAccessToken = INVALID_HANDLE_VALUE;
    if(S_OK != GetAccessToken(hAccessToken))
        return FULL_RIGHTS;       // Not having a token indicates an internal thread

    CCloseHandle cm(hAccessToken);

    DWORD dwMask = 0;

    if(IsAdmin(hAccessToken))
        return FULL_RIGHTS;

    // use the SD

    GENERIC_MAPPING map;
    map.GenericRead = 1;
    map.GenericWrite = 0x1C;
    map.GenericExecute = 2;
    map.GenericAll = 0x6001f;
    PRIVILEGE_SET ps[3];
    DWORD dwSize = 3 * sizeof(PRIVILEGE_SET);
    BOOL bResult;
    long testbit = 1;
    for(int iCnt = 0; iCnt < 26; iCnt++, testbit <<= 1)
    {
        // dont bother testing bits that we dont use

        DWORD dwGranted = 0;
        if(testbit & (FULL_RIGHTS))
        {
            BOOL bOK = AccessCheck(m_sd.GetPtr(), hAccessToken, testbit, &map, ps, &dwSize, &dwGranted, &bResult);
            if(bOK && bResult && dwGranted)
            {
                // if the right is full repository, make sure the user also gets the lesser write
                // access or else the logic for putting/deleting classes will have problems.

                if(testbit == WBEM_FULL_WRITE_REP)
                    dwMask |= (WBEM_PARTIAL_WRITE_REP|WBEM_WRITE_PROVIDER);
                dwMask |= testbit;
            }
        }
    }

    return dwMask;
}

//***************************************************************************
//
//  bool CWbemNamespace::Allowed(DWORD dwRequired)
//
//  Description.  Tests if the user has the requested permission.  This is
//  called before something like a WRITE is done.  Since nt supports
//  supports impersonation, this is always called.  For 9X, a simple check
//  of the permissions strored at the time of connection is OK.
//
//***************************************************************************

bool CWbemNamespace::Allowed(DWORD dwRequired)
{
    //
    // Check for admin first
    //

    GENERIC_MAPPING map;
    map.GenericRead = 1;
    map.GenericWrite = 0x1C;
    map.GenericExecute = 2;
    map.GenericAll = 0x6001f;
    PRIVILEGE_SET ps[3];
    DWORD dwSize = 3 * sizeof(PRIVILEGE_SET);
    BOOL bResult;
    DWORD dwGranted = 0;
    BOOL bOK;

    HANDLE hAccessToken = INVALID_HANDLE_VALUE;

    if(S_OK != GetAccessToken(hAccessToken))
        return true;
    CCloseHandle cm(hAccessToken);

    bOK = AccessCheck(m_sdCheckAdmin.GetPtr(), hAccessToken, 1,
                            &map, ps, &dwSize, &dwGranted, &bResult);
    if(bOK && bResult && dwGranted)
        return true;

    //
    // Not an admin. Continue
    //

    if(EnsureSecurity() != S_OK)
        return false;

    //
    // Always include the check for account enabled right.
    // NOTE: This is safe. We dont really care about the explicit
    // checks for PARTIAL of FULL write below if the account is disabled.
    //
    // NOTE: Why, oh, why did we go the anti-NT security path???????????????
    //
    DWORD dwRequiredCheck = dwRequired ;
    dwRequired |= WBEM_ENABLE ;


    // For nt, the current users priviledges are checked on the fly via access check

    CInCritSec ics(&m_cs);  // grab the cs since we are using the security desc.  // SEC:REVIEWED 2002-03-22 : Assumes entry
    if(IsRemote(hAccessToken))
    {
        //
        // Check to see if the user is remote enabled before continuing. If they are not
        // remote enabled, we fail (except in admin cases).
        //
        dwGranted = 0 ;
        bResult = FALSE ;
        bOK = AccessCheck(m_sd.GetPtr(), hAccessToken, WBEM_REMOTE_ACCESS, &map, ps, &dwSize,
                                                &dwGranted, &bResult);
        if ( !bOK || !bResult || !dwGranted )
        {
            return IsAdmin(hAccessToken) ? true : false ;
        }
    }

    bOK = AccessCheck(m_sd.GetPtr(), hAccessToken, dwRequired, &map, ps, &dwSize, &dwGranted, &bResult);
    bool bRet = (bOK && bResult && dwGranted);

    // Having full repository write gives access to the "lower" write capabilities.  So if the lower
    // right is rejected, double check for the full access right.

    if(bRet == false && (dwRequiredCheck == WBEM_PARTIAL_WRITE_REP || dwRequiredCheck == WBEM_WRITE_PROVIDER))
    {
        bOK = AccessCheck(m_sd.GetPtr(), hAccessToken, WBEM_FULL_WRITE_REP|WBEM_ENABLE, &map, ps, &dwSize,
                                                &dwGranted, &bResult);
        bRet = (bOK && bResult && dwGranted);
    }
    if(bRet == FALSE)
        bRet = TRUE == IsAdmin(hAccessToken);

    return bRet;
}


//***************************************************************************
//
//  HRESULT CWbemNamespace::InitializeSD()
//
//  Description.  Creates the SD
//
//***************************************************************************

HRESULT CWbemNamespace::InitializeSD(IWmiDbSession *pSession)
{
    HRESULT hr;
    if (pSession == NULL)
    {
        hr = CRepository::GetDefaultSession(&pSession);
        if (FAILED(hr))
            return hr;
    }
    else
        pSession->AddRef();
    CReleaseMe relMe2(pSession);
    IWbemClassObject * pThisNSObject = NULL;

    //AutoRevert av;          // switches to system and back to client
    BOOL bWasImpersonating = WbemIsImpersonating();
    if( bWasImpersonating )
    {
        if (FAILED(hr = CoRevertToSelf())) return hr;
    }
    
    //
    // Lets disable security checks here. This is a special case. If we didnt do this
    // a connection to a namespace would fail if the user didnt have the right to see
    // the security descriptor.
    //
    AutoRevertSecTlsFlag secFlag ( (LPVOID)0 ) ;
    hr = CRepository::GetObject(pSession, m_pNsHandle, L"__thisnamespace=@",
                                            WBEM_FLAG_USE_SECURITY_DESCRIPTOR | WMIDB_FLAG_ADMIN_VERIFIED,
                                            &pThisNSObject);
    if(FAILED(hr))
    {
        if(bWasImpersonating)
        {
            if (FAILED(CoImpersonateClient())) 
            {
                hr = WBEM_E_FAILED ;
            }
        }
        return hr;
    }
    CReleaseMe rm1(pThisNSObject);
    hr = GetSDFromProperty(L"SECURITY_DESCRIPTOR", m_sd, pThisNSObject);

    if(bWasImpersonating)
    {
        if ( FAILED (CoImpersonateClient()))   
        {
            hr = WBEM_E_FAILED ;
        }
    }
    return hr ;
}

//***************************************************************************
//
//  HRESULT CWbemNamespace::EnsureSecurity()
//
//  Description.  Generally doesnt do anything except for the first time
//
//***************************************************************************

HRESULT CWbemNamespace::EnsureSecurity()
{
    SCODE sc = S_OK;
    CInCritSec cs(&m_cs);  // SEC:REVIEWED 2002-03-22 : Assumes entry

    if(m_bSecurityInitialized)
        return S_OK;

    sc = InitializeSD(NULL);
    
    if(sc == S_OK)
        m_bSecurityInitialized = true;
    return sc;
}

CBaseAce * ConvertOldObjectToAce(IWbemClassObject * pObj, bool bGroup)
{
    // Get the properties out of the old object

    CVARIANT vName;
    pObj->Get(L"Name", 0, &vName, 0, 0);
    LPWSTR pName = NULL;
    if(vName.GetType() != VT_BSTR)
        return NULL;                // ignore this one.
    pName = LPWSTR(vName);

    CVARIANT vDomain;
    LPWSTR pDomain = L".";
    pObj->Get(L"Authority", 0, &vDomain, 0, 0);
    if(vDomain.GetType() == VT_BSTR)
        pDomain = LPWSTR(vDomain);

    bool bEditSecurity = false;
    bool bEnabled = false;
    bool bExecMethods = false;

    DWORD dwMask = 0;
    CVARIANT vEnabled;
    CVARIANT vEditSecurity;
    CVARIANT vExecMethods;
    CVARIANT vPermission;

    pObj->Get(L"Enabled", 0, &vEnabled, 0, 0);
    pObj->Get(L"EditSecurity", 0, &vEditSecurity, 0, 0);
    pObj->Get(L"ExecuteMethods", 0, &vExecMethods, 0, 0);
    pObj->Get(L"Permissions", 0, &vPermission, 0, 0);

    if (vEnabled.GetType() != VT_NULL && vEnabled.GetBool())
        bEnabled = true;

    if (vEditSecurity.GetType() != VT_NULL && vEditSecurity.GetBool())
        bEditSecurity = true;

    if (vExecMethods.GetType() != VT_NULL && vExecMethods.GetBool())
        bExecMethods = true;

    DWORD dwPermission = 0;
    if (vPermission.GetType() != VT_NULL && vPermission.GetLONG() > dwPermission)
            dwPermission = vPermission.GetLONG();

    // Now translate the old settings into new ones

    if(bEnabled)
        dwMask = WBEM_ENABLE | WBEM_REMOTE_ACCESS | WBEM_WRITE_PROVIDER;

    if(bEditSecurity)
        dwMask |= READ_CONTROL;

    if(bEditSecurity && dwPermission > 0)
        dwMask |= WRITE_DAC;

    if(bExecMethods)
        dwMask |= WBEM_METHOD_EXECUTE;

    if(dwPermission >= 1)
        dwMask |= WBEM_PARTIAL_WRITE_REP;

    if(dwPermission >= 2)
        dwMask |= WBEM_FULL_WRITE_REP | WBEM_PARTIAL_WRITE_REP | WBEM_WRITE_PROVIDER;


    // By default, CNtSid will look up the group name from either the local machine,
    // the domain, or a trusted domain.  So we need to be explicit

    WString wc;
    if(pDomain)
        if(wbem_wcsicmp(pDomain, L".") )
        {
            wc = pDomain;
            wc += L"\\";
        }
    wc += pName;

    // under m1, groups that were not enabled were just ignored.  Therefore the bits
    // cannot be transfer over since m3 has allows and denies, but no noops.  Also,
    // win9x doesnt have denies, do we want to noop those users also.

    if(!bEnabled && bGroup)
        dwMask = 0;

    // In general, m1 just supported allows.  However, a user entry that was not enabled was
    // treated as a deny.  Note that win9x does not allow actual denies.
    DWORD dwType = ACCESS_ALLOWED_ACE_TYPE;

    if(!bGroup && !bEnabled)
    {
        dwMask |= (WBEM_ENABLE | WBEM_REMOTE_ACCESS | WBEM_WRITE_PROVIDER);
        dwType = ACCESS_DENIED_ACE_TYPE;
    }
    
    CNtSid Sid(wc, NULL);
    if(Sid.GetStatus() != CNtSid::NoError)
    {
        ERRORTRACE((LOG_WBEMCORE, "Error converting m1 security ace, name = %S, error = 0x%x",
            wc, Sid.GetStatus()));
        return NULL;
    }
    CNtAce * pace = new CNtAce(dwMask, dwType, CONTAINER_INHERIT_ACE, Sid);
    if (pace && CNtAce::NoError != pace->GetStatus())
    {
        delete pace;
        pace = NULL;
    }
    return pace;
}

//***************************************************************************
//
//  BOOL IsRemote()
//
//  Description. returns true if the box is NT and the caller remote
//
//***************************************************************************


BOOL IsRemote(HANDLE hToken)
{
    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    BOOL bRet = TRUE;
    
    if(AllocateAndInitializeSid( &id, 1,                    // SEC:REVIEWED 2002-03-22 : OK
        SECURITY_INTERACTIVE_RID, 0,
        0,0,0,0,0,0,&pRawSid))                             // S-1-5-4
    {
        CNtSid Sid(pRawSid);
        FreeSid(pRawSid);        
        if (CNtSid::NoError == Sid.GetStatus())
        {
            if(CNtSecurity::IsUserInGroup(hToken, Sid))
                bRet = FALSE;
        }
    }

    
    //
    //Add proper check for remotness. In addition to the INTERACTIVE group,
    //we also check NETWORK_RID membership
    //
    if ( bRet )
    {
        if(AllocateAndInitializeSid( &id, 1,                    // SEC:REVIEWED 2002-03-22 : OK
            SECURITY_NETWORK_RID, 0,
            0,0,0,0,0,0,&pRawSid))                             // S-1-5-4
        {
            CNtSid Sid(pRawSid);
            FreeSid(pRawSid);            
            if (CNtSid::NoError == Sid.GetStatus())
            {
                if(!CNtSecurity::IsUserInGroup(hToken, Sid))
                    bRet = FALSE;
            }
        }
    }
    return bRet;
}

HRESULT AddDefaultRootAces(CNtAcl * pacl)
{
    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

    if(AllocateAndInitializeSid( &id, 2,                                 // SEC:REVIEWED 2002-03-22 : OK
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidAdmin(pRawSid);
        FreeSid(pRawSid);
        if (CNtSid::NoError != SidAdmin.GetStatus()) return WBEM_E_FAILED;
        DWORD dwMask = FULL_RIGHTS;
        wmilib::auto_ptr<CNtAce> pace( new CNtAce(dwMask, ACCESS_ALLOWED_ACE_TYPE,
                                                CONTAINER_INHERIT_ACE, SidAdmin));
        if ( NULL == pace.get() )   return WBEM_E_OUT_OF_MEMORY;
        if (CNtAce::NoError != pace->GetStatus()) return WBEM_E_OUT_OF_MEMORY;

        pacl->AddAce(pace.get());
    }

    //
    // Add ACE's for NETWORK_SERVICE ACCOUNT. These accounts have the following rights:
    // 1. WBEM_ENABLE
    // 2. WBEM_METHOD_EXECUTE
    // 3. WBEM_WRITE_PROVIDER
    //
    DWORD dwAccessMaskNetworkLocalService = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER ;

    if(AllocateAndInitializeSid( &id, 1,                             // SEC:REVIEWED 2002-03-22 : OK
        SECURITY_NETWORK_SERVICE_RID,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        if (CNtSid::NoError != SidUsers.GetStatus()) return WBEM_E_FAILED;        
        wmilib::auto_ptr<CNtAce> pace( new CNtAce(dwAccessMaskNetworkLocalService, ACCESS_ALLOWED_ACE_TYPE,
                                                CONTAINER_INHERIT_ACE, SidUsers));
        if ( NULL == pace.get() ) return WBEM_E_OUT_OF_MEMORY;
        if (CNtAce::NoError != pace->GetStatus()) return WBEM_E_OUT_OF_MEMORY;

        pacl->AddAce(pace.get());
    }


    //
    // Add ACE's for NETWORK_SERVICE ACCOUNT. These accounts have the following rights:
    // 1. WBEM_ENABLE
    // 2. WBEM_METHOD_EXECUTE
    // 3. WBEM_WRITE_PROVIDER
    //
    if(AllocateAndInitializeSid( &id, 1,                                 // SEC:REVIEWED 2002-03-22 : OK
        SECURITY_LOCAL_SERVICE_RID,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        if (CNtSid::NoError != SidUsers.GetStatus()) return WBEM_E_FAILED;                
        wmilib::auto_ptr<CNtAce> pace( new CNtAce(dwAccessMaskNetworkLocalService, ACCESS_ALLOWED_ACE_TYPE,
                                                CONTAINER_INHERIT_ACE, SidUsers));
        if (NULL == pace.get())  return WBEM_E_OUT_OF_MEMORY;
        if (CNtAce::NoError != pace->GetStatus()) return WBEM_E_OUT_OF_MEMORY;

        pacl->AddAce(pace.get());
    }




    SID_IDENTIFIER_AUTHORITY id2 = SECURITY_WORLD_SID_AUTHORITY;   // SEC:REVIEWED 2002-03-22 : OK

    if(AllocateAndInitializeSid( &id2, 1,   // SEC:REVIEWED 2002-03-22 : OK
        0,0,0,0,0,0,0,0,&pRawSid))
    {
        CNtSid SidUsers(pRawSid);
        FreeSid(pRawSid);
        if (CNtSid::NoError != SidUsers.GetStatus()) return WBEM_E_FAILED;                
        DWORD dwMask = WBEM_ENABLE | WBEM_METHOD_EXECUTE | WBEM_WRITE_PROVIDER;
        wmilib::auto_ptr<CNtAce> pace( new CNtAce(dwMask, ACCESS_ALLOWED_ACE_TYPE,
                                                CONTAINER_INHERIT_ACE, SidUsers));
        if (NULL == pace.get())  return WBEM_E_OUT_OF_MEMORY;
        if (CNtAce::NoError != pace->GetStatus()) return WBEM_E_OUT_OF_MEMORY;

        pacl->AddAce(pace.get());
    }
    return S_OK;
}


HRESULT CopySDIntoProperty(LPWSTR pPropName, CNtSecurityDescriptor &sd, IWbemClassObject *pThisNSObject)
{
    if (sd.GetStatus() != CNtSecurityDescriptor::NoError)
        return WBEM_E_FAILED;

    // move the SD into a variant.
    SAFEARRAY FAR* psa;
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    long lSize = sd.GetSize();
    rgsabound[0].cElements = lSize;
    psa = SafeArrayCreate( VT_UI1, 1 , rgsabound );
    if(psa == NULL)
        return DumpErrorMsgAndReturn(WBEM_E_FAILED, "GetSDMethod failed creating a safe array");

    char * pData = NULL;
    SCODE sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pData);
    if(sc != S_OK)
        return DumpErrorMsgAndReturn(sc, "GetSDMethod failed accessing safe array data");

    memcpy(pData, sd.GetPtr(), lSize);    // SEC:REVIEWED 2002-03-22 : OK

    SafeArrayUnaccessData(psa);
    VARIANT var;
    var.vt = VT_UI1|VT_ARRAY;
    var.parray = psa;

    sc = pThisNSObject->Put(pPropName , 0, &var, 0);

    VariantClear(&var);
    return sc;
}

HRESULT GetSDFromProperty(LPWSTR pPropName, CNtSecurityDescriptor &sd, IWbemClassObject *pThisNSObject)
{
    // Get the security descriptor argument

    HRESULT hRes = S_OK ;

    _variant_t var;
    SCODE sc = pThisNSObject->Get(pPropName , 0, &var, NULL, NULL);
    if (sc != S_OK)
    {
        CVARIANT vPath;
        pThisNSObject->Get(L"__PATH", 0, &vPath, 0, 0);
        DEBUGTRACE((LOG_WBEMCORE, "Getting SD from %S failed due to code 0x%X\n", V_BSTR(&vPath), sc));
        return WBEM_E_CRITICAL_ERROR;
    }

    if(var.vt != (VT_ARRAY | VT_UI1))
    {
        CVARIANT vPath;
        pThisNSObject->Get(L"__PATH", 0, &vPath, 0, 0);
        DEBUGTRACE((LOG_WBEMCORE, "Getting SD from %S failed due to incorrect VARIANT type\n", V_BSTR(&vPath) ));
        return WBEM_E_INVALID_PARAMETER;
    }

    SAFEARRAY * psa = V_ARRAY(&var);
    PSECURITY_DESCRIPTOR pSD = NULL;
    sc = SafeArrayAccessData(psa, (void HUGEP* FAR*)&pSD);
    
    if (FAILED(sc)) return DumpErrorMsgAndReturn(WBEM_E_INVALID_PARAMETER, "SetSD failed trying accessing SD property");

    OnDelete<SAFEARRAY *,HRESULT (*)(SAFEARRAY *),SafeArrayUnaccessData> unacc(psa);

    if (0 == psa->rgsabound[0].cElements) return WBEM_E_INVALID_PARAMETER;
    if (!IsValidSecurityDescriptor(pSD)) return WBEM_E_INVALID_PARAMETER;

    CNtSecurityDescriptor sdNew(pSD);

    CNtSid *pTmpSid = sdNew.GetOwner();
    if ( pTmpSid == NULL )
    {
        ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor was retrieved and it had no owner\n"));
    }
    delete pTmpSid;

    pTmpSid = sdNew.GetGroup();
    if (pTmpSid  == NULL )
    {
        ERRORTRACE((LOG_WBEMCORE, "ERROR: Security descriptor was retrieved and it had no group\n"));
    }
    delete pTmpSid;
    
    sd = sdNew;
    if ( sd.GetStatus ( ) != CNtSecurityDescriptor::NoError )
    {
        hRes = WBEM_E_OUT_OF_MEMORY ;
    }

    return hRes ;
}

HRESULT CopyInheritAces(CNtSecurityDescriptor & sd, CNtSecurityDescriptor & sdParent)
{
    // Get the acl list for both SDs

    CNtAcl * pacl = sd.GetDacl();
    if(pacl == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CNtAcl> dm0(pacl);

    CNtAcl * paclParent = sdParent.GetDacl();
    if(paclParent == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CNtAcl> dm1(paclParent);

    int iNumParent = paclParent->GetNumAces();
    for(int iCnt = 0; iCnt < iNumParent; iCnt++)
    {
        CNtAce *pParentAce = paclParent->GetAce(iCnt);
        if (pParentAce == NULL)
        	return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<CNtAce> dm2(pParentAce);
        if (CNtAce::NoError != pParentAce->GetStatus()) continue;

        long lFlags = pParentAce->GetFlags();
        if(lFlags & CONTAINER_INHERIT_ACE)
        {

            if(lFlags & NO_PROPAGATE_INHERIT_ACE)
                lFlags ^= CONTAINER_INHERIT_ACE;
            lFlags |= INHERITED_ACE;

            // If this is an inherit only ace we need to clear this
            // in the children.
            // NT RAID: 161761        [marioh]
            if ( lFlags & INHERIT_ONLY_ACE )
                lFlags ^= INHERIT_ONLY_ACE;

            pParentAce->SetFlags(lFlags);
            pacl->AddAce(pParentAce);
        }
    }
    sd.SetDacl(pacl);
    return S_OK;
}


HRESULT StoreSDIntoNamespace(IWmiDbSession * pSession, IWmiDbHandle *pNSToSet, CNtSecurityDescriptor & sd)
{
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Check to make sure the SD DACL is valid before attempting to put
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    CNtAcl* pAcl = sd.GetDacl ( );
    if ( NULL == pAcl ) return WBEM_E_INVALID_PARAMETER;

    CDeleteMe<CNtAcl> dm (pAcl);
    if ( !IsValidAclForNSSecurity ( pAcl ) )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    AutoRevertSecTlsFlag secFlag ( (LPVOID) 0 ) ;
    IWbemClassObject * pThisNSObject = NULL;
    HRESULT hr = CRepository::GetObject(pSession, pNSToSet, L"__thisnamespace=@",
                                            WBEM_FLAG_USE_SECURITY_DESCRIPTOR, &pThisNSObject);
    if(FAILED(hr))
        return hr;
    CReleaseMe rm1(pThisNSObject);

    hr = CopySDIntoProperty(L"SECURITY_DESCRIPTOR", sd, pThisNSObject);
    if(FAILED(hr))
        return hr;
    return CRepository::PutObject(pSession, pNSToSet, IID_IWbemClassObject, pThisNSObject,
        WMIDB_DISABLE_EVENTS | WBEM_FLAG_USE_SECURITY_DESCRIPTOR);
}

HRESULT    SetSecurityForNS(IWmiDbSession * pSession, IWmiDbHandle *pNSToSet,
                         IWmiDbSession * pParentSession, IWmiDbHandle * pNSParent, BOOL bExisting)
{
    IWbemClassObject * pThisNSObject = NULL;

    // Get the __thisnamespace object
    AutoRevertSecTlsFlag secFlag ( (LPVOID) 0 ) ;
    HRESULT hr = CRepository::GetObject(pSession, pNSToSet, L"__thisnamespace=@",
                                WBEM_FLAG_USE_SECURITY_DESCRIPTOR, &pThisNSObject);
    if(FAILED(hr))
    {
        ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failed to get __thisnamespace=@ object for current namespace <0x%X>!\n", hr));
        return hr;
    }
    CReleaseMe rm1(pThisNSObject);

    // Create the new SD

    CNtSecurityDescriptor sd;
    CNtAcl DestAcl;

    if(bExisting)
    {
        // Fill in the security descriptor
        hr = GetSDFromProperty(L"SECURITY_DESCRIPTOR", sd, pThisNSObject);
        if(FAILED(hr))
        {
            ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure in GetSDFromProperty <0x%X>!\n", hr));
            return hr;
        }
    
        hr = StripOutInheritedAces (sd);
        if ( FAILED (hr) )
        {
            ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure in StripOutInheritedAces <0x%X>!\n", hr));
            return hr;
        }

    }
    else
    {
        // NT RAID: 198935 Prefix    [marioh]
        if ( !SetOwnerAndGroup(sd) )
        {
            ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure in SetOwnerAndGroup <0x%X>!\n", hr));
            return WBEM_E_FAILED;
        }

        if ( !sd.SetDacl(&DestAcl) )
        {
            ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure in SetDacl <0x%X>!\n", hr));
            return WBEM_E_FAILED;
        }
    }


    CNtAcl * pacl = sd.GetDacl();
    if (pacl == NULL)
    {
        ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure in GetDacl <0x%X>!\n", hr));
        return WBEM_E_FAILED;
    }

    CDeleteMe<CNtAcl> del1(pacl);


    if(pNSParent == NULL)
    {
        // If there is no parent, this must be root.  Create a default one
        
        hr = AddDefaultRootAces(pacl);
        if (FAILED(hr))
        {
            ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for AddDefaultRootAces <0x%X>!\n", hr));
            return hr;
        }
        BOOL bRet = sd.SetDacl(pacl);
        if (bRet == FALSE)
        {
            ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for SetDacl (2) <0x%X>!\n", hr));
            return WBEM_E_FAILED ;
        }
    }
    else
    {
        // Get the parents __thisnamespace
        IWbemClassObject * pParentThisNSObject = NULL;
        hr = CRepository::GetObject(pParentSession, pNSParent, L"__thisnamespace=@",
                                WBEM_FLAG_USE_SECURITY_DESCRIPTOR, &pParentThisNSObject);
        if(FAILED(hr))
        {
            ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failed to get __thisnamespace=@ object for parent namespace <0x%X>!\n", hr));
            return hr;
        }
        CReleaseMe rm11(pParentThisNSObject);
        CNtSecurityDescriptor sdParent;
        hr = GetSDFromProperty(L"SECURITY_DESCRIPTOR", sdParent, pParentThisNSObject);
        if(FAILED(hr))
        {
            ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for GetSDFromProperty <0x%X>!\n", hr));
            return hr;
        }
        hr = CopyInheritAces(sd, sdParent);
        if (FAILED(hr))
        {
            ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for CopyInheritAces <0x%X>!\n", hr));
            return hr;
        }
    }
    if(FAILED(hr))
        return hr;

    hr = CopySDIntoProperty(L"SECURITY_DESCRIPTOR", sd, pThisNSObject);
    if(FAILED(hr))
    {
        ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for CopySDIntoProperty <0x%X>!\n", hr));
        return hr;
    }

    // Extract sd property once more.
    // ==============================

    CNtSecurityDescriptor VerifiedSd;
    hr = GetSDFromProperty(L"SECURITY_DESCRIPTOR", VerifiedSd, pThisNSObject);

    if (FAILED(hr))
    {
        ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failure for GetSDFromProperty (2) <0x%X>!\n", hr));
        CVARIANT vPath;
        pThisNSObject->Get(L"__PATH", 0, &vPath, 0, 0);
        DEBUGTRACE((LOG_WBEMCORE, "Error creating security descriptor for new namespace %S", V_BSTR(&vPath) ));
        return WBEM_E_CRITICAL_ERROR;
    }

    // Go ahead and store the object.
    // ==============================

    hr = CRepository::PutObject(pSession, pNSToSet, IID_IWbemClassObject, pThisNSObject,
                        WMIDB_DISABLE_EVENTS  | WBEM_FLAG_USE_SECURITY_DESCRIPTOR);

    if (FAILED(hr))
    {
        ERRORTRACE((LOG_WBEMCORE, "SetSecurityForNS: Failed to put secured object back <0x%X>!\n", hr));
    }
    return hr;
}


//***************************************************************************
//
//  IsValidAclForNSSecurity
//
//    Checks the ACEs for the following:
//        2. Standard NT ACE correctness [IsValidAce]
//        1. ACE inheritance/propogation flag correctness for WMI namespace
//           security
//
//  Parameters:
//                <CNtAcl&>   ACL to be checked
//                
//  Return:
//                TRUE        if ACL is valid
//                FALSE        if ACL is invalid
//
//***************************************************************************
BOOL IsValidAclForNSSecurity (CNtAcl* pAcl)
{
    BOOL bRet = TRUE;

    // Standard NT ACL check
    if (!pAcl->IsValid()) return FALSE;
    
    // Loop through all the ACEs in the list
    ULONG ulNum = pAcl->GetNumAces( );
    for ( ULONG ulCnt = 0; ulCnt < ulNum; ulCnt++ )
    {
        CNtAce* pAce = pAcl->GetAce ( ulCnt );
        if (NULL == pAce)  return FALSE;
        CDeleteMe<CNtAce> autoDel ( pAce );
        if ( !IsAceValid ( pAce->GetAccessMask(), pAce->GetType(), pAce->GetFlags() ) )
        {
            return FALSE;
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\sinks.cpp ===
//***************************************************************************
//
//  (c) 1997-2001 by Microsoft Corporation
//
//  SINKS.CPP
//
//  raymcc      3-Mar-99        Updated for separately threaded proxies
//
//***************************************************************************

#include "precomp.h"

#include <stdio.h>
#include <wbemcore.h>
#include <evtlog.h>
#include <oahelp.inl>
#include <genutils.h>
#include <stdarg.h>
#include <autoptr.h>

#define LOWER_AUTH_LEVEL_NOTSET 0xFFFFFFFF

static HRESULT ZapWriteOnlyProps(IWbemClassObject *pObj);

extern LONG g_nSinkCount;
extern LONG g_nStdSinkCount;
extern LONG g_nSynchronousSinkCount;
extern LONG g_nProviderSinkCount;


int _Trace(char *pFile, const char *fmt, ...);

//
//
//
//////////////////////////////////////////////

void EmptyObjectList(CFlexArray &aTarget)
{
    for (int i = 0; i < aTarget.Size(); i++)
    {
        IWbemClassObject *pObj = (IWbemClassObject *) aTarget[i];
        if (pObj) pObj->Release();
    }
    aTarget.Empty();
};


//
//
//
/////////////////////////////////////////////////////

void Sink_Return(IWbemObjectSink* pSink,HRESULT & hRes, IWbemClassObject * & pObjParam)
{
    pSink->SetStatus(0,hRes,NULL,pObjParam);
}


//***************************************************************************
//
//***************************************************************************

CBasicObjectSink::CBasicObjectSink()
{
    InterlockedIncrement(&g_nSinkCount);
}

CBasicObjectSink::~CBasicObjectSink()
{
    InterlockedDecrement(&g_nSinkCount);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CBasicObjectSink::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if(riid == CLSID_WbemLocator)
    {
        // internal test
        *ppvObj = NULL;
        return S_OK;
    }

    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppvObj = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CObjectSink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CObjectSink::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//***************************************************************************


CSynchronousSink * CSynchronousSink::Create(IWbemObjectSink* pProxy)
{
    try
    {
        return new CSynchronousSink(pProxy); 
    }
    catch(CX_Exception &)
    {
        return 0;
    }
}

CSynchronousSink::CSynchronousSink(IWbemObjectSink* pProxy) :
        m_hEvent(NULL),
        m_str(NULL), m_pErrorObj(NULL), m_hres(WBEM_E_CRITICAL_ERROR)
{
    m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hEvent) throw CX_MemoryException();
    if(pProxy)
    {
        m_pCurrentProxy = pProxy;
        pProxy->AddRef();
    }
    else
        m_pCurrentProxy = NULL;
    InterlockedIncrement(&g_nSynchronousSinkCount);

};

//***************************************************************************
//
//***************************************************************************

CSynchronousSink::~CSynchronousSink()
{
    if(m_pCurrentProxy)
        m_pCurrentProxy->Release();

    CloseHandle(m_hEvent);
    SysFreeString(m_str);
    if(m_pErrorObj)
        m_pErrorObj->Release();
    InterlockedDecrement(&g_nSynchronousSinkCount);

}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CSynchronousSink::Indicate(long lNumObjects,
                                       IWbemClassObject** apObj)
{
    CInCritSec ics(&m_cs);
    HRESULT hRes = WBEM_S_NO_ERROR;
    for(long i = 0; i < lNumObjects &&  SUCCEEDED(hRes); i++)
    {
        if (m_apObjects.Add(apObj[i]) < 0)
            hRes = WBEM_E_OUT_OF_MEMORY;
    }
    return hRes;
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CSynchronousSink::SetStatus(long lFlags, long lParam,
                                    BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == WBEM_STATUS_PROGRESS)
    {
        if(m_pCurrentProxy)
            return m_pCurrentProxy->SetStatus(lFlags, lParam, strParam, pObjParam);
        else
            return S_OK;
    }

    if(lFlags != 0) return WBEM_S_NO_ERROR;

    CInCritSec ics(&m_cs);  // SEC:REVIEWED 2002-03-22 : Assumes entry

    m_hres = lParam;
    m_str = SysAllocString(strParam);
    if (m_pErrorObj)
        m_pErrorObj->Release();
    m_pErrorObj = pObjParam;
    if(m_pErrorObj)
        m_pErrorObj->AddRef();
    SetEvent(m_hEvent);

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

void CSynchronousSink::Block()
{
    if(m_hres != WBEM_E_CRITICAL_ERROR)
        return;

    CCoreQueue::QueueWaitForSingleObject(m_hEvent, INFINITE);
}

//***************************************************************************
//
//***************************************************************************

void CSynchronousSink::GetStatus(HRESULT* phres, BSTR* pstrParam,
                                IWbemClassObject** ppErrorObj)
{
    CInCritSec ics(&m_cs); // SEC:REVIEWED 2002-03-22 : Assumes entry

    if(phres)
        *phres = m_hres;
    if(pstrParam)
        *pstrParam = SysAllocString(m_str);
    if(ppErrorObj)
    {
        *ppErrorObj = m_pErrorObj;
        if(m_pErrorObj)
            m_pErrorObj->AddRef();
    }
}


//***************************************************************************
//
//***************************************************************************

CForwardingSink::CForwardingSink(CBasicObjectSink* pDest, long lRef)
    : CObjectSink(lRef),
        m_pDestIndicate(pDest->GetIndicateSink()),
        m_pDestStatus(pDest->GetStatusSink()),
        m_pDest(pDest)
{
    m_pDestIndicate->AddRef();
    m_pDestStatus->AddRef();
    m_pDest->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CForwardingSink::~CForwardingSink()
{
    if(m_pDestIndicate)
        m_pDestIndicate->Release();
    if(m_pDestStatus)
        m_pDestStatus->Release();
    if(m_pDest)
        m_pDest->Release();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CForwardingSink::Indicate(long lObjectCount,
                                       IWbemClassObject** pObjArray)
{
    return m_pDestIndicate->Indicate(lObjectCount, pObjArray);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CForwardingSink::SetStatus(long lFlags, long lParam,
                                    BSTR strParam, IWbemClassObject* pObjParam)
{
    return m_pDestStatus->SetStatus(lFlags, lParam, strParam, pObjParam);
}


//***************************************************************************
//
//***************************************************************************

CCombiningSink::CCombiningSink(CBasicObjectSink* pDest, HRESULT hresToIgnore)
    : CForwardingSink(pDest, 0), m_hresToIgnore(hresToIgnore),
        m_hres(WBEM_S_NO_ERROR), m_pErrorObj(NULL), m_strParam(NULL)
{
}

//***************************************************************************
//
//***************************************************************************

CCombiningSink::~CCombiningSink()
{
    // Time to call SetStatus on the destination
    // =========================================

    m_pDestStatus->SetStatus(0, m_hres,
        (SUCCEEDED(m_hres)?m_strParam:NULL),
        (SUCCEEDED(m_hres)?NULL:m_pErrorObj)
    );

    if(m_pErrorObj)
        m_pErrorObj->Release();
    SysFreeString(m_strParam);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CCombiningSink::SetStatus(long lFlags, long lParam, BSTR strParam,
                     IWbemClassObject* pObjParam)
{
    if(lFlags != 0)
        return m_pDestStatus->SetStatus(lFlags, lParam, strParam, pObjParam);

    // An error occurred. For now, only store one
    // ==========================================

    if(strParam)
    {
        SysFreeString(m_strParam);
        m_strParam = SysAllocString(strParam);
    }
    CInCritSec ics(&m_cs); // SEC:REVIEWED 2002-03-22 : Assumes entry
    if(SUCCEEDED(m_hres) || (m_pErrorObj == NULL && pObjParam != NULL))
    {
        // This error needs to be recorded
        // ===============================

        if(FAILED(lParam))
        {
            // Record the error code, unless it is to be ignored
            // =================================================

            if(lParam != m_hresToIgnore)
            {
                m_hres = lParam;
            }

            // Record the error object anyway
            // ==============================

            if(m_pErrorObj)
                m_pErrorObj->Release();
            m_pErrorObj = pObjParam;
            if(m_pErrorObj)
                m_pErrorObj->AddRef();
        }
        else
        {
            if(lParam != m_hresToIgnore)
            {
                m_hres = lParam;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************
/*
CAnySuccessSink::~CAnySuccessSink()
{
    // If no real success occurred, report a failure
    // =============================================

    if(!m_bSuccess && SUCCEEDED(m_hres))
    {
        // We must report a failure since there were no successes, but there
        // were no real failures either, so we must create an error code.
        // =================================================================
        if(m_hresIgnored == 0)
            m_hres = m_hresNotError1;
        else
            m_hres = m_hresIgnored;
    }
}
*/

//***************************************************************************
//
//***************************************************************************
/*
STDMETHODIMP CAnySuccessSink::SetStatus(long lFlags, long lParam, BSTR strParam,
                     IWbemClassObject* pObjParam)
{
    if(lFlags == 0)
    {
        if(SUCCEEDED(lParam))
            m_bSuccess = TRUE;
        else if(lParam == m_hresNotError1 && m_hresIgnored == 0)
        {
            m_hresIgnored = m_hresNotError1;
            lParam = WBEM_S_NO_ERROR;
        }
        else if(lParam == m_hresNotError2)
        {
            m_hresIgnored = m_hresNotError2;
            lParam = WBEM_S_NO_ERROR;
        }
    }
    return CCombiningSink::SetStatus(lFlags, lParam, strParam, pObjParam);
}
*/
//***************************************************************************
//
//***************************************************************************


STDMETHODIMP COperationErrorSink::SetStatus(long lFlags, long lParam,
                     BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == 0 && FAILED(lParam))
    {
        HRESULT hres = WBEM_S_NO_ERROR;
        IWbemClassObject* pErrorObj = NULL;
        bool    bErr = false;

        try
        {
            CErrorObject Error(pObjParam);
            Error.SetOperation(m_wsOperation);
            Error.SetParamInformation(m_wsParameter);
            Error.SetProviderName(m_wsProviderName);
            pErrorObj = Error.GetObject();
        }

        // If an exception occurs, send the error to the client and
        // return an error from the call.
        catch ( CX_Exception & )
        {
            lParam = WBEM_E_OUT_OF_MEMORY;
            bErr = true;
        }

        hres = m_pDestStatus->SetStatus(lFlags, lParam, strParam, pErrorObj);

        if ( NULL != pErrorObj )
        {
            pErrorObj->Release();
        }

        if ( bErr )
        {
            hres = lParam;
        }

        return hres;
    }
    else if(m_bFinal &&
            lFlags != WBEM_STATUS_COMPLETE && lFlags != WBEM_STATUS_PROGRESS)
    {
        DEBUGTRACE((LOG_WBEMCORE, "Ignoring internal SetStatus call to the "
            "client: 0x%X 0x%X %S\n", lFlags, lParam, strParam));
        return WBEM_S_FALSE;
    }
    else if(lFlags == 0 && strParam &&
            !m_wsOperation.EqualNoCase(L"PutInstance"))
    {
        ERRORTRACE((LOG_WBEMCORE, "Provider used strParam in SetStatus "
            "outside of PutInstance! Actual operation was <%S>, string was <%S>. Ignoring\n", (const wchar_t*)m_wsOperation, strParam));

        return m_pDestStatus->SetStatus(lFlags, lParam, NULL, pObjParam);
    }
    else
    {
        return m_pDestStatus->SetStatus(lFlags, lParam, strParam, pObjParam);
    }
}

//***************************************************************************
//
//***************************************************************************

void COperationErrorSink::SetProviderName(LPCWSTR wszName)
{
    m_wsProviderName = wszName;
}

//***************************************************************************
//
//***************************************************************************

void COperationErrorSink::SetParameterInfo(LPCWSTR wszParam)
{
    m_wsParameter = wszParam;
}


//***************************************************************************
//
//***************************************************************************

CDecoratingSink::CDecoratingSink(CBasicObjectSink* pDest,
                                    CWbemNamespace* pNamespace)
    : CForwardingSink(pDest, 0), m_pNamespace(pNamespace)
{
    m_pNamespace->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CDecoratingSink::~CDecoratingSink()
{
    m_pNamespace->Release();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CDecoratingSink::Indicate(long lNumObjects,
                                           IWbemClassObject** apObjects)
{
    // Clone the indicated objects before decorating
    HRESULT hres;

    if (0 > lNumObjects) return WBEM_E_INVALID_PARAMETER;
    if (0 == lNumObjects)
        return m_pDestIndicate->Indicate(lNumObjects, apObjects);

    // We will optimize for indicates of a single object (which will probably
    // be the most likely type of indicate.  In which case we won't allocate any
    //  memory for the cloned object array, and rather will just use a stack variable.
    if ( 1 == lNumObjects )
    {
        IWbemClassObject*   pClonedObject = NULL;
        hres = ((CWbemObject *)apObjects[0])->CloneAndDecorate(0,ConfigMgr::GetMachineName(),m_pNamespace->GetName(),&pClonedObject);
        if (SUCCEEDED(hres))
        {
            hres = m_pDestIndicate->Indicate(lNumObjects, &pClonedObject);
            pClonedObject->Release();        
        }
        /*
        hres = apObjects[0]->Clone(&pClonedObject);
        if (FAILED(hres)) return hres;
        hres = m_pNamespace->DecorateObject(pClonedObject);
        if (SUCCEEDED(hres))
            hres = m_pDestIndicate->Indicate(lNumObjects, &pClonedObject);
        pClonedObject->Release();        
        return hres;
        */
        return hres;
    }

    // Allocate an array and zero it out
    wmilib::auto_buffer<IWbemClassObject*>  apClonedObjects(new IWbemClassObject*[lNumObjects]);
    if ( NULL == apClonedObjects.get() ) return WBEM_E_OUT_OF_MEMORY;
    ZeroMemory( apClonedObjects.get(), lNumObjects * sizeof(IWbemClassObject*) );

    // Clone the objects into the array (error out if this fails)
    hres = S_OK;
    for ( long lCtr = 0; SUCCEEDED( hres ) && lCtr < lNumObjects; lCtr++ )
    {
        if (apObjects[lCtr])
        {
            hres = ((CWbemObject *)apObjects[lCtr])->CloneAndDecorate(0,ConfigMgr::GetMachineName(),m_pNamespace->GetName(),&apClonedObjects[lCtr]);
            //Clone( &apClonedObjects[lCtr] );
        }
        else
        {
            apClonedObjects[lCtr] = NULL;
        }
    }

    // Now decorate the cloned objects and indicate them
    if ( SUCCEEDED( hres ) )
    {
        /*
        for(int i = 0; i < lNumObjects && SUCCEEDED(hres); i++)
        {
            hres = m_pNamespace->DecorateObject(apClonedObjects[i]);
        }
        if (SUCCEEDED(hres))
        */        
            hres = m_pDestIndicate->Indicate(lNumObjects, (IWbemClassObject**)apClonedObjects.get());
    }

    for ( lCtr = 0; lCtr < lNumObjects; lCtr++ )
    {
        if ( apClonedObjects[lCtr] )  apClonedObjects[lCtr]->Release();
    }

    return hres;
}


//***************************************************************************
//
//***************************************************************************

CSingleMergingSink::~CSingleMergingSink()
{
    if(SUCCEEDED(m_hres))
    {
        if(m_pResult == NULL)
        {
            // Nobody succeeded, but nobody failed either. Not found
            // =====================================================

            m_hres = WBEM_E_NOT_FOUND;
        }
        else if(m_pResult->InheritsFrom(m_wsTargetClass) == S_OK)
        {
            m_pDestIndicate->Indicate(1, &m_pResult);
        }
        else
        {
            // Found somewhere, but not in this class
            // ======================================

            m_hres = WBEM_E_NOT_FOUND;
        }
    }
    if(m_pResult)
        m_pResult->Release();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CSingleMergingSink::Indicate(long lNumObjects,
                                           IWbemClassObject** apObjects)
{
    CInCritSec ics(&m_cs); // SEC:REVIEWED 2002-03-22 : Assumes entry
    if(lNumObjects != 1)
    {
        ERRORTRACE((LOG_WBEMCORE, "Provider gave %d objects for GetObject!\n",
            lNumObjects));
        return WBEM_S_NO_ERROR;
    }

    if(m_pResult == NULL)
    {
        apObjects[0]->Clone(&m_pResult);
        return WBEM_S_NO_ERROR;
    }

    CVar vName;
    ((CWbemInstance*)m_pResult)->GetClassName(&vName);

    if(apObjects[0]->InheritsFrom(vName.GetLPWSTR()) == S_OK)
    {
        IWbemClassObject* pClone;
        apObjects[0]->Clone(&pClone);

        HRESULT hres = CWbemInstance::AsymmetricMerge((CWbemInstance*)m_pResult,
                    (CWbemInstance*)pClone);

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Failed to merge instances!!\n"));
            pClone->Release();
        }
        else
        {
            m_pResult->Release();
            m_pResult = pClone; // already AddRefed
        }
    }
    else
    {
        HRESULT hres = CWbemInstance::AsymmetricMerge(
                    (CWbemInstance*)apObjects[0], (CWbemInstance*)m_pResult);

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_WBEMCORE, "Failed to merge instances!!\n"));
        }
    }
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
//***************************************************************************

CLocaleMergingSink::CLocaleMergingSink(CBasicObjectSink *pDest, LPCWSTR wszLocale, LPCWSTR pNamespace)
    : CCombiningSink(pDest, WBEM_S_NO_ERROR),
      m_wsLocale(wszLocale),
      m_pPrimaryNs(NULL),
      m_pPrimarySession(NULL),
      m_pPrimaryDriver(NULL),

      m_pDefaultNs(NULL),
      m_pDefaultSession(NULL),
      m_pDefaultDriver(NULL)
{
    GetDbPtr(pNamespace);
}

CLocaleMergingSink::~CLocaleMergingSink()
{
    releaseNS();
}

//***************************************************************************
//
//***************************************************************************

HRESULT CLocaleMergingSink::LocalizeQualifiers(bool bInstance, bool bParentLocalized,
                                               IWbemQualifierSet *pBase, IWbemQualifierSet *pLocalized, bool &bChg)
{
    HRESULT hrInner;
    HRESULT hr = WBEM_S_NO_ERROR;

    pLocalized->BeginEnumeration(0);

    BSTR strName = NULL;
    VARIANT vVal;
    VariantInit(&vVal);

    long lFlavor;
    while(pLocalized->Next(0, &strName, &vVal, &lFlavor) == S_OK)
    {
        // Ignore if this is an instance.

        if (bInstance && !(lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE))
        {
            VariantClear(&vVal);
            SysFreeString(strName);
            continue;
        }

        if (!wbem_wcsicmp(strName, L"amendment") ||
            !wbem_wcsicmp(strName, L"key") ||
            !wbem_wcsicmp(strName, L"singleton") ||
            !wbem_wcsicmp(strName, L"dynamic") ||
            !wbem_wcsicmp(strName, L"indexed") ||
            !wbem_wcsicmp(strName, L"cimtype") ||
            !wbem_wcsicmp(strName, L"static") ||
            !wbem_wcsicmp(strName, L"implemented") ||
            !wbem_wcsicmp(strName, L"abstract"))
        {
            VariantClear(&vVal);
            SysFreeString(strName);
            continue;
        }

        // If this is not a propagated qualifier,
        // ignore it.  (Bug #45799)
        // =====================================

        if (bParentLocalized &&
            !(lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS))
        {
            VariantClear(&vVal);
            SysFreeString(strName);
            continue;
        }

        // Now, we need to test for this in the other
        // class.
        // The only localized qualifiers that do not override the
        // default are where only parent qualifiers exist, but the
        // child has overriden its own parent.
        // =======================================================

        VARIANT vBasicVal;
        VariantInit(&vBasicVal);
        long lBasicFlavor;

        hrInner = pBase->Get(strName, 0, &vBasicVal, &lBasicFlavor);

        if (hrInner != WBEM_E_NOT_FOUND)
        {
            if (bParentLocalized &&                             // If there is no localized copy of this class
                (lBasicFlavor & WBEM_FLAVOR_OVERRIDABLE) &&     // .. and this is an overridable qualifier
                 (lBasicFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS) && // and this is propogated
                 (lBasicFlavor & WBEM_FLAVOR_ORIGIN_LOCAL))     // .. and this was actualy overridden
            {
                VariantClear(&vVal);                            // .. DON'T DO IT.
                VariantClear(&vBasicVal);
                SysFreeString(strName);
                continue;
            }

            if (bParentLocalized &&
                !(lBasicFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS))
            {
                VariantClear(&vVal);
                VariantClear(&vBasicVal);
                SysFreeString(strName);
                continue;
            }
        }

        pBase->Put(strName, &vVal, (lFlavor&~WBEM_FLAVOR_ORIGIN_PROPAGATED) | WBEM_FLAVOR_AMENDED);
        bChg = true;

        VariantClear(&vVal);
        VariantClear(&vBasicVal);
        SysFreeString(strName);

    }
    return hr;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CLocaleMergingSink::LocalizeProperties(bool bInstance, bool bParentLocalized, IWbemClassObject *pOriginal,
                                               IWbemClassObject *pLocalized, bool &bChg)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    pLocalized->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);

    BSTR strPropName = NULL;
    LONG lLong;
    CIMTYPE ct;
    VARIANT vNewVal;
    VariantInit(&vNewVal);

    while(pLocalized->Next(0, &strPropName, &vNewVal, &ct, &lLong) == S_OK)
    {
        CSysFreeMe sfm(strPropName);
        CClearMe ccm(&vNewVal);
        
        IWbemQualifierSet *pLocalizedQs = NULL, *pThisQs = NULL;

        if (FAILED(pLocalized->GetPropertyQualifierSet(strPropName,&pLocalizedQs)))
        {
            continue;
        }
        CReleaseMe rm1(pLocalizedQs);

        if (FAILED(pOriginal->GetPropertyQualifierSet(strPropName, &pThisQs)))
        {
            continue;
        }
        CReleaseMe rm2(pThisQs);

        hr = LocalizeQualifiers(bInstance, bParentLocalized, pThisQs, pLocalizedQs, bChg);
        if (FAILED(hr))
        {
            continue;
        }
    }

    pLocalized->EndEnumeration();

    return hr;
}

//***************************************************************************
//
//***************************************************************************

// This function sets up the pointer to the localized namespace.

void CLocaleMergingSink::GetDbPtr(const wchar_t * name_space)
{
    if (m_pThisNamespace.EqualNoCase(name_space))
      return;

    releaseNS();

    m_pThisNamespace = name_space;
    if (wcslen(name_space) == 0)  // SEC:REVIEWED 2002-03-22 : Precondition ensures NULL
        return;

    // SEC:REVIEWED 2002-03-22 : Needs EH because of WString ops below

    WString sNsName;
    sNsName = m_pThisNamespace;
    sNsName += L"\\";
    sNsName += m_wsLocale;

    IWmiDbSession *pTempSession = NULL;
    HRESULT hRes = CRepository::GetDefaultSession(&pTempSession);
    if (FAILED(hRes))
        return;

    hRes = CRepository::OpenScope(pTempSession, sNsName, 0, &m_pPrimaryDriver, &m_pPrimarySession, 0, &m_pPrimaryNs);


    if (wbem_wcsicmp(m_wsLocale, L"ms_409"))
    {
        sNsName = m_pThisNamespace;
        sNsName += L"\\ms_409";
        hRes = CRepository::OpenScope(pTempSession, sNsName, 0, &m_pDefaultDriver, &m_pDefaultSession, 0, &m_pDefaultNs);
    }

    pTempSession->Release();

}

void CLocaleMergingSink::releaseNS(void)
{
  ReleaseIfNotNULL(m_pPrimarySession);
  ReleaseIfNotNULL(m_pDefaultSession);
  ReleaseIfNotNULL(m_pPrimaryNs);
  ReleaseIfNotNULL(m_pPrimaryDriver);
  ReleaseIfNotNULL(m_pDefaultNs);
  ReleaseIfNotNULL(m_pDefaultDriver);

  m_pPrimarySession = 0;
  m_pDefaultSession = 0;
  m_pPrimaryNs = 0;
  m_pPrimaryDriver = 0;
  m_pDefaultNs = 0;
  m_pDefaultDriver = 0;
};

bool CLocaleMergingSink::hasLocale(const wchar_t * name_space)
{
  GetDbPtr(name_space) ;
  return (m_pPrimaryNs || m_pDefaultNs);
};

//***************************************************************************
//
//***************************************************************************

// Do the work.

STDMETHODIMP CLocaleMergingSink::Indicate(long lNumObjects,
                                           IWbemClassObject** apObjects)
{
    CInCritSec ics(&m_cs);  // SEC:REVIEWED 2002-03-22 : Assumes entry
    IWbemQualifierSet *pLocalizedQs = NULL, *pThisQs = NULL;
    bool bParentLocalized = false;
    bool bInstance = false;
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hRes;

        for (int i = 0; i < lNumObjects; i++)
        {
                // SEC:REVIEWED 2002-03-22 : Needs EH because of WString, CVar, etc. below

                CWbemObject *pResult = (CWbemObject *)apObjects[i];

                CVar vServer;
                if (FAILED(pResult->GetProperty(L"__SERVER", &vServer)) || vServer.IsNull())
                        continue;
                if (wbem_wcsicmp(LPWSTR(vServer), ConfigMgr::GetMachineName())!=0)
                        continue;
                VARIANT name_space;
                VariantInit(&name_space);
                CClearMe cm(&name_space);

                HRESULT hres = pResult->Get(L"__NAMESPACE", 0, &name_space, NULL, NULL);
                if (FAILED(hres) || hasLocale (V_BSTR(&name_space)) == false)
                  continue;

                if (pResult->IsInstance())
                        bInstance = true;

                CVar vName, vDeriv;
                if (FAILED(pResult->GetClassName(&vName)))
                	continue;

                WString wKey;    // SEC:REVIEWED 2002-03-22 : Can throw
                int nRes = 0;
                bool bChg = false;

                // Does this instance exist in the localized namespace?
                // Does this class exist in the localized namespace?
                // If not, loop through all the parents until we
                // run out or we have a hit.
                // =================================================

                CWbemObject *pClassDef = NULL;

                if (wcslen(vName.GetLPWSTR()) > 0)    // SEC:REVIEWED 2002-03-22 : Ok, vName can't get here unless a NULL terminator was found
                {
                        WString sName = vName.GetLPWSTR();

                        hRes = WBEM_E_NOT_FOUND;
                        if (m_pPrimaryNs)
                                hRes = CRepository::GetObject(m_pPrimarySession, m_pPrimaryNs, sName, 0, (IWbemClassObject **) &pClassDef);

                        if (FAILED(hRes) && m_pDefaultNs)
                                hRes = CRepository::GetObject(m_pDefaultSession, m_pDefaultNs, sName, 0, (IWbemClassObject **) &pClassDef);

                        if (hRes == WBEM_E_NOT_FOUND)
                        {
                                bParentLocalized = TRUE;

                                pResult->GetDerivation(&vDeriv);
                                CVarVector *pvTemp = vDeriv.GetVarVector();

                                for (int j = 0; j < pvTemp->Size(); j++)
                                {
                                        CVar vParentName = pvTemp->GetAt(j);
                                        WString sParentName = vParentName.GetLPWSTR();

                                        hRes = WBEM_E_NOT_FOUND;

                                        if (m_pPrimaryNs)
                                                hRes = CRepository::GetObject(m_pPrimarySession, m_pPrimaryNs, sParentName, 0, (IWbemClassObject **) &pClassDef);

                                        if (FAILED(hRes) && m_pDefaultNs)
                                                hRes = CRepository::GetObject(m_pDefaultSession, m_pDefaultNs, sParentName, 0, (IWbemClassObject **) &pClassDef);
                                        
                                        if (SUCCEEDED(hRes)) break;
                                }
                        }
                }


                if (pClassDef == NULL)
                {
                        nRes = WBEM_S_NO_ERROR;
                        continue;
                }

                CReleaseMe rm11((IWbemClassObject*)pClassDef);

                // At this point, we have the localized copy, and are
                // ready to combine qualifiers.  Start with class qualifiers.
                // ============================================================

                if (FAILED(pClassDef->GetQualifierSet(&pLocalizedQs)))
                        continue;

                if (FAILED(pResult->GetQualifierSet(&pThisQs)))
                {
                        pLocalizedQs->Release();
                        continue;
                }

                hr = LocalizeQualifiers(bInstance, bParentLocalized, pThisQs, pLocalizedQs, bChg);

                pLocalizedQs->EndEnumeration();
                pLocalizedQs->Release();
                pThisQs->Release();
                if (FAILED(hr))
                        break;

                hr = LocalizeProperties(bInstance, bParentLocalized, pResult, pClassDef, bChg);

                // Methods.
                // Putting a method cancels enumeration, so we have to enumerate first.

                IWbemClassObject *pLIn = NULL, *pLOut = NULL;
                IWbemClassObject *pOIn = NULL, *pOOut = NULL;
                BSTR bstrMethodName = NULL ;
                int iPos = 0;

                pClassDef->BeginMethodEnumeration(0);
                while ( pClassDef->NextMethod(0, &bstrMethodName, 0, 0) == S_OK )
                {
                        pLIn = NULL;
                        pOIn = NULL;
                        pLOut = NULL;
                        pOOut = NULL;

                        pClassDef->GetMethod(bstrMethodName, 0, &pLIn, &pLOut);
                        hr = pResult->GetMethod(bstrMethodName, 0, &pOIn, &pOOut);

                        CSysFreeMe fm(bstrMethodName);
                        CReleaseMe rm0(pLIn);
                        CReleaseMe rm1(pOIn);
                        CReleaseMe rm2(pLOut);
                        CReleaseMe rm3(pOOut);

                        // METHOD IN PARAMETERS
                        if (pLIn)
                                if (pOIn)
                                        hr = LocalizeProperties(bInstance, bParentLocalized, pOIn, pLIn, bChg);

                        if (pLOut)
                                if (pOOut)
                                        hr = LocalizeProperties(bInstance, bParentLocalized, pOOut, pLOut, bChg);

                        // METHOD QUALIFIERS

                        hr = pResult->GetMethodQualifierSet(bstrMethodName, &pThisQs);
                        if (FAILED(hr))
                        {
                                continue;
                        }

                        hr = pClassDef->GetMethodQualifierSet(bstrMethodName, &pLocalizedQs);
                        if (FAILED(hr))
                        {
                                pThisQs->Release();
                                continue;
                        }

                        hr = LocalizeQualifiers(bInstance, bParentLocalized, pThisQs, pLocalizedQs, bChg);

                        pResult->PutMethod(bstrMethodName, 0, pOIn, pOOut);

                        pThisQs->Release();
                        pLocalizedQs->Release();

                }
                pClassDef->EndMethodEnumeration();

                if (bChg)
                        pResult->SetLocalized(true);


        }

#ifdef DBG
    for(int i = 0; i < lNumObjects; i++)
    {
        CWbemObject *pResult = (CWbemObject *)apObjects[i];
        if (FAILED(pResult->ValidateObject(WMIOBJECT_VALIDATEOBJECT_FLAG_FORCE)))
        	DebugBreak();
    }
#endif

    m_pDestIndicate->Indicate(lNumObjects, apObjects);

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

/*
STDMETHODIMP CCountedSink::Indicate(long lNumObjects,
                                    IWbemClassObject** apObjects)
{
    if(lNumObjects != 1)
        return WBEM_E_UNEXPECTED;

    DWORD dwNewSent = (DWORD)InterlockedIncrement((LONG*)&m_dwSent);
    if(dwNewSent > m_dwMax)
        return WBEM_E_UNEXPECTED;

    m_pDestIndicate->Indicate(1, apObjects);

    if(dwNewSent == m_dwMax)
    {
        m_pDestStatus->SetStatus(0, WBEM_S_NO_ERROR, NULL, NULL);
        return WBEM_S_FALSE;
    }
    else return WBEM_S_NO_ERROR;
}
*/

//***************************************************************************
//
//***************************************************************************

/*
STDMETHODIMP CCountedSink::SetStatus(long lFlags, long lParam,
                        BSTR strParam, IWbemClassObject* pObjParam)
{
    // If SetStatus is 0, indicating that the enum is finished, but we
    // didn't send back the requested number of objects, we should
    // SetStatus to WBEM_S_FALSE.

    if ( WBEM_S_NO_ERROR == lParam )
    {
        if ( m_dwSent != m_dwMax )
        {
            lParam = WBEM_S_FALSE;
        }
    }

    return m_pDestStatus->SetStatus( lFlags, lParam, strParam, pObjParam );

}
*/

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CFilteringSink::Indicate(long lObjectCount,
                                    IWbemClassObject** apObjects)
{
    try
    {
        // Allocate new array
        wmilib::auto_buffer<IWbemClassObject*> apNewArray(new IWbemClassObject*[lObjectCount]);

        if (NULL == apNewArray.get())  return WBEM_E_OUT_OF_MEMORY;

        long lNewIndex = 0;
        for(int i = 0; i < lObjectCount; i++)
        {
            if(Test((CWbemObject*)apObjects[i])) // throw
            {
                apNewArray[lNewIndex++] = apObjects[i];
            }
        }

        HRESULT hres = WBEM_S_NO_ERROR;
        if(lNewIndex > 0)
        {
            hres = m_pDestIndicate->Indicate(lNewIndex, apNewArray.get());
        }

        return hres;
    }
    catch (CX_MemoryException &) // becasue Test uses CStack that throws
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CErrorChangingSink::SetStatus(long lFlags, long lParam,
                        BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == 0 && lParam == m_hresFrom)
        return m_pDestStatus->SetStatus(0, m_hresTo, NULL, NULL);
    else
        return m_pDestStatus->SetStatus(lFlags, lParam, strParam, pObjParam);
}

//***************************************************************************
//
//***************************************************************************

CNoDuplicatesSink::CNoDuplicatesSink(CBasicObjectSink* pDest)
    : CFilteringSink(pDest), m_strDupClass(NULL)
{
}

//***************************************************************************
//
//***************************************************************************

CNoDuplicatesSink::~CNoDuplicatesSink()
{
    SysFreeString(m_strDupClass);
}

//***************************************************************************
//
//***************************************************************************

BOOL CNoDuplicatesSink::Test(CWbemObject* pObj)
{
    CInCritSec ics(&m_cs); // SEC:REVIEWED 2002-03-22 : Assumes entry

    // Get the path
    // ============

    CVar vPath;
    if(FAILED(pObj->GetPath(&vPath)) || vPath.IsNull()) return FALSE;

    if(m_mapPaths.find(vPath.GetLPWSTR()) == m_mapPaths.end())
    {
        m_mapPaths[vPath.GetLPWSTR()] = true;
        return TRUE;
    }
    else
    {
        // Duplicate!
        // ==========

        ERRORTRACE((LOG_WBEMCORE, "Duplicate objects returned with path %S\n",
            vPath.GetLPWSTR()));

        ConfigMgr::GetEventLog()->Report(EVENTLOG_ERROR_TYPE,
                            WBEM_MC_DUPLICATE_OBJECTS, vPath.GetLPWSTR());

        if(m_strDupClass == NULL)
        {
            m_strDupClass = SysAllocString(vPath.GetLPWSTR());
        }
        return FALSE;
    }
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CNoDuplicatesSink::SetStatus(long lFlags, long lParam,
                            BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == WBEM_STATUS_COMPLETE && lParam == WBEM_S_NO_ERROR &&
        m_strDupClass != NULL)
    {
        // Success is being reported, but we have seen duplications
        // ========================================================

        return CFilteringSink::SetStatus(lFlags, WBEM_S_DUPLICATE_OBJECTS,
                                            m_strDupClass, pObjParam);
    }
    else
    {
        return CFilteringSink::SetStatus(lFlags, lParam, strParam, pObjParam);
    }
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CHandleClassProvErrorsSink::SetStatus(long lFlags, long lParam,
                        BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags == WBEM_STATUS_COMPLETE && FAILED(lParam) &&
        lParam != WBEM_E_NOT_FOUND)
    {
        // Log an error into the event log
        // ===============================

        ERRORTRACE((LOG_WBEMCORE,
            "Class provider '%S' installed in namespace '%S' failed to enumerate classes, "
            "returning error code 0x%lx. Operations will continue as if the class provider "
            "had no classes.  This provider-specific error condition needs to be corrected "
            "before this class provider can contribute to this namespace.\n",
            (LPWSTR)m_wsProvider, (LPWSTR) m_wsNamespace, lParam));

        lParam = WBEM_E_NOT_FOUND;
    }

    return CForwardingSink::SetStatus(lFlags, lParam, strParam, pObjParam);
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CSuccessSuppressionSink::SetStatus(long lFlags, long lParam,
                        BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lFlags != WBEM_STATUS_COMPLETE ||
            (FAILED(lParam) && lParam != m_hresNotError1 &&
                lParam != m_hresNotError2))
    {
        return CForwardingSink::SetStatus(lFlags, lParam, strParam, pObjParam);
    }
    else
    {
        return WBEM_S_NO_ERROR;
    }
}


//***************************************************************************
//
//***************************************************************************

CDynPropsSink::CDynPropsSink(CBasicObjectSink* pDest, CWbemNamespace * pNs, long lRef) : CForwardingSink(pDest, lRef)
{
    m_pNs = pNs;
    if(m_pNs)
        m_pNs->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CDynPropsSink::~CDynPropsSink()
{
    // Send all the cached entries

    DWORD dwCacheSize = m_UnsentCache.GetSize();
    for(DWORD dwCnt = 0; dwCnt < dwCacheSize; dwCnt++)
    {
        IWbemClassObject* pObj = m_UnsentCache[dwCnt];
        if(m_pNs)
            m_pNs->GetOrPutDynProps((CWbemObject *)pObj, CWbemNamespace::GET);
        m_pDestIndicate->Indicate(1, &pObj);
    }
    if(m_pNs)
        m_pNs->Release();

}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CDynPropsSink::Indicate(long lObjectCount,
                                       IWbemClassObject** pObjArray)
{
    // If there are no dyn props then immediately do the indicate

    wmilib::auto_buffer<IWbemClassObject*> apNewArray( new IWbemClassObject*[lObjectCount]);
    if (NULL == apNewArray.get()) return WBEM_E_OUT_OF_MEMORY;

    CVar vDynTest;
    HRESULT hRes = S_OK;
    long lIndex = 0 ;
    for(long lCnt = 0; lCnt < lObjectCount; lCnt++)
    {
        CWbemObject *pWbemObj = (CWbemObject *)pObjArray[lCnt];
        HRESULT hres = pWbemObj->GetQualifier(L"DYNPROPS", &vDynTest);
        if (hres == S_OK && vDynTest.GetBool() == VARIANT_TRUE)
        {
            if (m_UnsentCache.Add(pWbemObj) < 0)
                hRes = WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            apNewArray[lIndex++] = pObjArray[lCnt] ;
        }
    }

    if ( 0 == lIndex ) return hRes;

    IServerSecurity * pSec = NULL;
    hRes = CoGetCallContext(IID_IServerSecurity,(void **)&pSec);
    CReleaseMe rmSec(pSec);
    if (RPC_E_CALL_COMPLETE == hRes ) hRes = S_OK; // no call context
    if (FAILED(hRes)) return hRes;
    BOOL bImper = (pSec)?pSec->IsImpersonating():FALSE;
    if (pSec && bImper && FAILED(hRes = pSec->RevertToSelf())) return hRes;

    hRes = m_pDestIndicate->Indicate(lIndex, apNewArray.get());

    if (bImper && pSec)
    {
        HRESULT hrInner = pSec->ImpersonateClient();
        if (FAILED(hrInner)) return hrInner;
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CMethodSink::Indicate(long lObjectCount,
                                       IWbemClassObject** pObjArray)
{
    if(lObjectCount == 1 && m_pRes == NULL)
    {
        pObjArray[0]->Clone(&m_pRes);
    }
    return S_OK;
}

STDMETHODIMP CMethodSink::SetStatus(long lFlags, long lParam,
                        BSTR strParam, IWbemClassObject* pObjParam)
{
    if(lParam == S_OK && m_pRes)
    {
        m_pDestIndicate->Indicate(1, &m_pRes);
    }
    if(m_pRes)
        m_pRes->Release();

    return CForwardingSink::SetStatus(lFlags, lParam, strParam, pObjParam);
}

//***************************************************************************
//
//  ZapWriteOnlyProps
//
//  Removes write-only properties from an object.
//  Precondition: Object has been tested for presence of "HasWriteOnlyProps"
//  on the object itself.
//
//***************************************************************************

static HRESULT ZapWriteOnlyProps(IWbemClassObject *pObj)
{
    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_NULL;

    SAFEARRAY *pNames = 0;
    pObj->GetNames(L"WriteOnly", WBEM_FLAG_ONLY_IF_TRUE, 0, &pNames);
    LONG lUpper;
    SafeArrayGetUBound(pNames, 1, &lUpper);

    for (long i = 0; i <= lUpper; i++)
    {
        BSTR strName = 0;
        SafeArrayGetElement(pNames, &i, &strName);
        pObj->Put(strName, 0, &v, 0);
    }
    SafeArrayDestroy(pNames);

    return WBEM_S_NO_ERROR;
}



//***************************************************************************
//
//***************************************************************************
//

CStdSink::CStdSink(IWbemObjectSink *pRealDest)
{
    m_pDest = pRealDest;
    m_hRes = 0;
    m_bCancelForwarded = FALSE;
    m_lRefCount = 0L;

    if ( NULL != m_pDest )
        m_pDest->AddRef();

    InterlockedIncrement(&g_nStdSinkCount);
}

//***************************************************************************
//
//***************************************************************************
//

CStdSink::~CStdSink()
{
    if ( NULL != m_pDest )
        m_pDest->Release();

    InterlockedDecrement(&g_nStdSinkCount);
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT CStdSink::Cancel()
{
    HRESULT hResTmp;
    m_hRes = WBEM_E_CALL_CANCELLED;

    if (m_bCancelForwarded)
        return m_hRes;

    try
    {
        hResTmp = m_pDest->SetStatus(0, m_hRes, 0, 0);
    }
    catch (...) // untrusted code ?
    {
        ExceptionCounter c;
        m_hRes = WBEM_E_CRITICAL_ERROR;
    }

    m_bCancelForwarded = TRUE;
    return m_hRes;
}

//***************************************************************************
//
//***************************************************************************
//

ULONG STDMETHODCALLTYPE CStdSink::AddRef()
{
    return InterlockedIncrement( &m_lRefCount );
}

//***************************************************************************
//
//***************************************************************************
//

ULONG STDMETHODCALLTYPE CStdSink::Release()
{
    LONG lRes = InterlockedDecrement( &m_lRefCount );
    if (lRes == 0)
        delete this;
    return lRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStdSink::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_pDest->QueryInterface(riid, ppvObj);
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStdSink::Indicate(
    long lObjectCount,
    IWbemClassObject** pObjArray
    )
{
    HRESULT hRes;

    if (m_hRes == WBEM_E_CALL_CANCELLED)
    {
        return Cancel();
    }

    try
    {
        hRes = m_pDest->Indicate(lObjectCount, pObjArray);
    }
    catch (...) // untrusted code ?
    {
        ExceptionCounter c;
        hRes = Cancel();
    }
    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStdSink::SetStatus(
    long lFlags,
    long lParam,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
    HRESULT hRes;

    if (m_hRes == WBEM_E_CALL_CANCELLED)
    {
        return Cancel();
    }

    try
    {
        hRes = m_pDest->SetStatus(lFlags, lParam, strParam, pObjParam);
    }
    catch (...) // untrusted code ?
    {
        ExceptionCounter c;
        hRes = Cancel();
    }

    return hRes;
}


//***************************************************************************
//
//***************************************************************************
//

CFlexArray g_aProviderSinks;
CStaticCritSec  g_csProvSinkCs;

//***************************************************************************
//
//***************************************************************************
//

HRESULT WINAPI CProviderSink::Dump(FILE *f)
{

    CInCritSec ics(&g_csProvSinkCs); // SEC:REVIEWED 2002-03-22 : Assumes entry

    fprintf(f, "---Begin Provider Sink Info---\n");   // SEC:REVIEWED 2002-03-22 : Ok, debug code

    for (int i = 0; i < g_aProviderSinks.Size(); i++)
    {
        CProviderSink *pSink = (CProviderSink *) g_aProviderSinks[i];
        if (pSink)
        {
            fprintf(f, "Provider Sink 0x%p\n", pSink);                             // SEC:REVIEWED 2002-03-22 : Ok, debug code
            fprintf(f, "    Total Indicates = %d\n", pSink->m_lIndicateCount);     // SEC:REVIEWED 2002-03-22 : Ok, debug code

			// Check that this is non-NULL
			if ( NULL != pSink->m_pszDebugInfo )
			{
				fprintf(f, "    Debug Info = %S\n", pSink->m_pszDebugInfo);        // SEC:REVIEWED 2002-03-22 : Ok, debug code
			}
			else
			{
				fprintf(f, "    Debug Info = NULL\n");                             // SEC:REVIEWED 2002-03-22 : Ok, debug code
			}
            fprintf(f, "    SetStatus called? %d\n", pSink->m_bDone);              // SEC:REVIEWED 2002-03-22 : Ok, debug code
            fprintf(f, "    hRes = 0x%X\n", pSink->m_hRes);                        // SEC:REVIEWED 2002-03-22 : Ok, debug code
            fprintf(f, "    m_pNextSink = 0x%p\n", pSink->m_pNextSink);            // SEC:REVIEWED 2002-03-22 : Ok, debug code
        }
    }

    fprintf(f, "---End Provider Sink Info---\n");                                  // SEC:REVIEWED 2002-03-22 : Ok, debug code
    return 0;
}

//***************************************************************************
//
//***************************************************************************
//
CProviderSink::CProviderSink(
    LONG lStartingRefCount,
    LPWSTR pszDebugInf
    ):m_pNextSink(0)
{
    m_lRefCount = lStartingRefCount;
    InterlockedIncrement(&g_nSinkCount);
    InterlockedIncrement(&g_nProviderSinkCount);
    m_hRes = 0;
    m_bDone = FALSE;

    m_lIndicateCount = 0;
    m_pszDebugInfo = 0;

    if (pszDebugInf)
    {
    	 DUP_STRING_NEW(m_pszDebugInfo, pszDebugInf);
    }

    CInCritSec ics(&g_csProvSinkCs); 
    g_aProviderSinks.Add(this); // just for debug
}

//***************************************************************************
//
//***************************************************************************
//
CProviderSink::~CProviderSink()
{

    {
        CInCritSec ics(&g_csProvSinkCs);  // SEC:REVIEWED 2002-03-22 : Assumes entry
	    for (int i = 0; i < g_aProviderSinks.Size(); i++)
	    {
	        if (this == (CProviderSink *) g_aProviderSinks[i])
	        {
	            g_aProviderSinks.RemoveAt(i);
	            break;
	        }
	    }
    }

	// Cleanup AFTER we remove from the array so the Diagnostic Thread won't
	// crash.
    ReleaseIfNotNULL(m_pNextSink);
    InterlockedDecrement(&g_nSinkCount);
    InterlockedDecrement(&g_nProviderSinkCount);
    delete [] m_pszDebugInfo;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CProviderSink::AddRef()
{
    LONG lRes = InterlockedIncrement(&m_lRefCount);
    return (ULONG) lRes;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CProviderSink::LocalAddRef()
{
    LONG lRes = InterlockedIncrement(&m_lRefCount);
    return lRes;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CProviderSink::LocalRelease()
{
    LONG lRes = InterlockedDecrement(&m_lRefCount);
    if (lRes == 0)
        delete this;
    return lRes;
}

//***************************************************************************
//
//***************************************************************************
//
ULONG CProviderSink::Release()
{
    LONG lRes = InterlockedDecrement(&m_lRefCount);

    if (lRes == 0)
        delete this;

    return (ULONG) lRes;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CProviderSink::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppvObj = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CProviderSink::Indicate(
    long lObjectCount,
    IWbemClassObject** pObjArray
    )
{
    if (m_hRes)
        return m_hRes;

	IWbemObjectSink*	pNextSink = NULL;

    {
	    CInCritSec ics(&m_cs); // SEC:REVIEWED 2002-03-22 : Assumes entry

		pNextSink = m_pNextSink;

		if ( NULL != pNextSink )
		{
			pNextSink->AddRef();
		}
    }

	// AutoRelease
	CReleaseMe	rm( pNextSink );

	HRESULT	hRes;

	if ( NULL != pNextSink )
	{
		m_lIndicateCount += lObjectCount;
		hRes = pNextSink->Indicate(lObjectCount, pObjArray);
	}
	else
	{
		hRes = WBEM_E_CRITICAL_ERROR;
	}

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//
void CProviderSink::Cancel()
{
    if (m_bDone)
        return;

	IWbemObjectSink*	pNextSink = NULL;

    {
        CInCritSec ics(&m_cs);
        
        m_hRes = WBEM_E_CALL_CANCELLED;

    	pNextSink = m_pNextSink;

    	if ( NULL != m_pNextSink )
    	{
    		// We will release it outside the critical section
    		m_pNextSink = NULL;
    	}
    }

	// Auto Release
	CReleaseMe	rm( pNextSink );

    if ( pNextSink )
    {
        pNextSink->SetStatus(0, WBEM_E_CALL_CANCELLED, 0, 0);
	}

}

//***************************************************************************
//
//***************************************************************************
//
HRESULT CProviderSink::SetStatus(
    long lFlags,
    long lParam,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
    if (m_hRes)
        return m_hRes;

	IWbemObjectSink*	pNextSink = NULL;

    {
        CInCritSec ics(&m_cs);
        
        pNextSink = m_pNextSink;

        if ( NULL != m_pNextSink )
        {
        	// We will always release it outside the critical section

        	// If this is the completion status, then we should go ahead and set
        	// the member variable to NULL.  We're done with the sink.
        	if ( lFlags == WBEM_STATUS_COMPLETE )
        	{
        		m_pNextSink = NULL;
        	}
        	else
        	{
        		pNextSink->AddRef();
        	}
        }

    }

	// Auto Release
	CReleaseMe	rm( pNextSink );

    HRESULT hRes = WBEM_S_NO_ERROR;
	
	if ( NULL != pNextSink )
	{
		pNextSink->SetStatus(lFlags, lParam, strParam, pObjParam);
		m_bDone = TRUE;
	}

    return hRes;
}

//***************************************************************************
//
//***************************************************************************
//

long	g_lNumStatusSinks = 0L;

CStatusSink::CStatusSink( void )
:	m_hRes( WBEM_S_NO_ERROR ),
	m_lRefCount( 1 )
{
	InterlockedIncrement( &g_lNumStatusSinks );
}

//***************************************************************************
//
//***************************************************************************
//

CStatusSink::~CStatusSink()
{
	InterlockedDecrement( &g_lNumStatusSinks );
}

//***************************************************************************
//
//***************************************************************************
//

ULONG STDMETHODCALLTYPE CStatusSink::AddRef()
{
    return InterlockedIncrement( &m_lRefCount );
}

//***************************************************************************
//
//***************************************************************************
//

ULONG STDMETHODCALLTYPE CStatusSink::Release()
{
    LONG lRes = InterlockedDecrement( &m_lRefCount );
    if (lRes == 0)
        delete this;
    return lRes;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStatusSink::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if( riid == IID_IUnknown || riid == IID_IWbemObjectSink )
    {
        *ppvObj = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }

	return E_NOINTERFACE;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStatusSink::Indicate(
    long lObjectCount,
    IWbemClassObject** pObjArray
    )
{
	// Why are we even here??!?!?!?
	_DBG_ASSERT( 0 );
    return WBEM_E_FAILED;
}

//***************************************************************************
//
//***************************************************************************
//

HRESULT STDMETHODCALLTYPE CStatusSink::SetStatus(
    long lFlags,
    long lParam,
    BSTR strParam,
    IWbemClassObject* pObjParam
    )
{
	if ( lFlags == WBEM_STATUS_COMPLETE )
	{
		if ( SUCCEEDED( m_hRes ) && FAILED( lParam ) )
		{
			m_hRes = lParam;
		}
	}

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//***************************************************************************

COperationError::COperationError(CBasicObjectSink* pDest,
                                                    LPCWSTR wszOperation,
                                                    LPCWSTR wszParam,
                                                    BOOL bFinal)     
{
    m_fOk = false;
    m_pSink = NULL;    
    try 
    {
        m_pSink = new COperationErrorSink(pDest, wszOperation, wszParam, bFinal);
        if (NULL == m_pSink)
        {
            if (pDest) pDest->Return(WBEM_E_OUT_OF_MEMORY);
            return;
        }
        m_fOk = true;
    } 
    catch(CX_Exception &)
    {
            if (pDest) pDest->Return(WBEM_E_OUT_OF_MEMORY);
    }
}

//***************************************************************************
//
//***************************************************************************

COperationError::~COperationError()
{
    if (m_pSink) m_pSink->Release();
}

//***************************************************************************
//
//***************************************************************************

HRESULT COperationError::ErrorOccurred(
    HRESULT hRes,
    IWbemClassObject* pErrorObj
    )
{
    if (m_pSink) m_pSink->SetStatus(0, hRes, NULL, pErrorObj);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************

HRESULT COperationError::ProviderReturned(
    LPCWSTR wszProviderName,
    HRESULT hRes,
    IWbemClassObject* pErrorObj
    )
{
    m_pSink->SetProviderName(wszProviderName);
    m_pSink->SetStatus(0, hRes, NULL, pErrorObj);
    return hRes;
}

//***************************************************************************
//
//***************************************************************************

void COperationError::SetParameterInfo(LPCWSTR wszParam)
{
    m_pSink->SetParameterInfo(wszParam);
}

//***************************************************************************
//
//***************************************************************************

void COperationError::SetProviderName(LPCWSTR wszName)
{
    m_pSink->SetProviderName(wszName);
}

//***************************************************************************
//
//***************************************************************************

CFinalizingSink::CFinalizingSink(
    CWbemNamespace* pNamespace,
    CBasicObjectSink* pDest
    )
        : CForwardingSink(pDest, 0), m_pNamespace(pNamespace)
{
    m_pNamespace->AddRef();
}

//***************************************************************************
//
//***************************************************************************

CFinalizingSink::~CFinalizingSink()
{
    m_pNamespace->Release();
}

//***************************************************************************
//
//***************************************************************************

STDMETHODIMP CFinalizingSink::Indicate(
    long lNumObjects,
    IWbemClassObject** apObj
    )
{
    HRESULT hRes;

    for (long i = 0; i < lNumObjects; i++)
    {
        CWbemObject *pObj = (CWbemObject *) apObj[i];

        if (pObj == 0)
        {
                ERRORTRACE((LOG_WBEMCORE, "CFinalizingSink::Indicate() -- Null pointer Indicate\n"));
                continue;
        }

        // If object is an instance, we have to deal with dynamic
        // properties.
        // ======================================================

        if (pObj->IsInstance())
        {
            hRes = m_pNamespace->GetOrPutDynProps((CWbemObject*)apObj[i],CWbemNamespace::GET);
            if (FAILED(hRes))
            {
                ERRORTRACE((LOG_WBEMCORE, "CFinalizingSink::Indicate() -- Failed to post-process an instance "
                    "using a property provider. Error code %X\n", hRes));
            }
        }
    }

    return m_pDest->Indicate(lNumObjects, apObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\sinks.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SINKS.CPP

Abstract:

    Sink definitions

History:

--*/

#ifndef __WBEM_SINKS__H_
#define __WBEM_SINKS__H_

#include <sync.h>
#include <arrtempl.h>
#include <wstlallc.h>
#include <unk.h>
#include <comutil.h>


//***************************************************************************
//
//***************************************************************************

void EmptyObjectList(CFlexArray &aTarget);

class CObjDbNS;
//class CWbemNamespace;


//***************************************************************************
//
//***************************************************************************

class CDestination
{
public:
    virtual HRESULT Add(ADDREF IWbemClassObject* pObj) = 0;
};


//
//
// used for the template
//
/////////////////////////////////////////////

void Sink_Return(IWbemObjectSink* pSink,HRESULT & hRes,IWbemClassObject * & pObjParam);

typedef  OnDeleteIf3<IWbemObjectSink *,HRESULT &,IWbemClassObject * &,
                             void (*)(IWbemObjectSink *,HRESULT &,IWbemClassObject * &),
                             Sink_Return> CSetStatusOnMe;

//***************************************************************************
//
//***************************************************************************

class CBasicObjectSink : public IWbemObjectSink, public CDestination
{
public:
    CBasicObjectSink();
    virtual ~CBasicObjectSink();

    STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObj);

    inline HRESULT Add(IWbemClassObject* pObj)
        {return Indicate(1, &pObj);}
    inline HRESULT Return(HRESULT hres, IWbemClassObject* pErrorObj = NULL)
        {SetStatus(0, hres, NULL, pErrorObj); return hres;}

    virtual IWbemObjectSink* GetIndicateSink() {return this;}
    virtual IWbemObjectSink* GetStatusSink() {return this;}
    virtual BOOL IsApartmentSpecific() {return FALSE;}
    virtual BOOL IsTrusted() {return TRUE;}
};

class CStatusSink : public CBasicObjectSink
{
    HRESULT m_hRes;
	long	m_lRefCount;

public:

    CStatusSink( );
   ~CStatusSink();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);
    HRESULT STDMETHODCALLTYPE Indicate(long lObjectCount, IWbemClassObject** pObjArray);
    HRESULT STDMETHODCALLTYPE SetStatus(long lFlags, long lParam, BSTR strParam,
                             IWbemClassObject* pObjParam
                             );

	HRESULT GetLastStatus( void ) { return m_hRes; }
};

class CStdSink : public CBasicObjectSink
{
    IWbemObjectSink *m_pDest;
    HRESULT m_hRes;
    BOOL m_bCancelForwarded;
public:
    long    m_lRefCount;

    CStdSink(IWbemObjectSink *pRealDest);
   ~CStdSink();
    HRESULT Cancel();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);
    HRESULT STDMETHODCALLTYPE Indicate(long lObjectCount, IWbemClassObject** pObjArray);
    HRESULT STDMETHODCALLTYPE SetStatus(long lFlags, long lParam, BSTR strParam,
                             IWbemClassObject* pObjParam
                             );
};


//***************************************************************************
//
//  Decouples provider subsystem from the rest of the sink chain
//  for cancellation purposes.
//
//  This sink does not destruct until the Destruct() method is called
//
//***************************************************************************
//
class CProviderSink : public IWbemObjectSink
{
private:
    LONG m_lRefCount;
    LONG m_lIndicateCount;
    LPWSTR m_pszDebugInfo;

    IWbemObjectSink *m_pNextSink;
    HRESULT m_hRes;
    BOOL m_bDone;
    CCritSec m_cs;

public:
    static HRESULT WINAPI Dump(FILE *f);

    CProviderSink(LONG lStartingRefCount = 0, LPWSTR pszDebugInfo = 0);
   ~CProviderSink();

    ULONG LocalAddRef();    // Doesn't propagate AddRef()
    ULONG LocalRelease();   // Doesn't propagate Release()

    void SetNextSink(IWbemObjectSink *pSink) { m_pNextSink = pSink; m_pNextSink->AddRef(); }  // SEC:REVIEWED 2002-03-22 : OK; all users check first
    void Cancel();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);
    HRESULT STDMETHODCALLTYPE Indicate(long lObjectCount, IWbemClassObject** pObjArray);
    HRESULT STDMETHODCALLTYPE SetStatus(long lFlags, long lParam, BSTR strParam,
                             IWbemClassObject* pObjParam
                             );
};


//***************************************************************************
//
//***************************************************************************

class CObjectSink : public CBasicObjectSink
{
protected:
    long m_lRef;
public:
    CObjectSink(long lRef = 0) : m_lRef(lRef){}
    virtual ~CObjectSink(){}

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray) = 0;
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam) = 0;
};

class CSynchronousSink : public CObjectSink
{
private:
    CSynchronousSink(IWbemObjectSink* pProxy = NULL);
    
    HANDLE m_hEvent;
    HRESULT m_hres;
    BSTR m_str;
    IWbemClassObject* m_pErrorObj;
    IWbemObjectSink* m_pCurrentProxy;
    CRefedPointerArray<IWbemClassObject> m_apObjects;
    CCritSec m_cs;
public:
    static CSynchronousSink* Create(IWbemObjectSink* pProxy = NULL);
    virtual ~CSynchronousSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);

public:
    void Block();
    void GetStatus(HRESULT* phres, BSTR* pstrParam,
                        IWbemClassObject** ppErrorObj);
    INTERNAL CRefedPointerArray<IWbemClassObject>& GetObjects()
        {return m_apObjects;}

	HRESULT GetHResult() { return m_hres; }
	void ClearHResult() { m_hres = WBEM_S_NO_ERROR; }
};



//***************************************************************************
//
//***************************************************************************

class CForwardingSink : public CObjectSink
{
protected:
    IWbemObjectSink* m_pDestIndicate;
    IWbemObjectSink* m_pDestStatus;
    CBasicObjectSink* m_pDest;
public:
    CForwardingSink(CBasicObjectSink* pDest, long lRef = 0);
    virtual ~CForwardingSink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);

    virtual IWbemObjectSink* GetIndicateSink() {return m_pDestIndicate;}
    virtual IWbemObjectSink* GetStatusSink() {return m_pDestStatus;}
    virtual BOOL IsTrusted() {return m_pDest->IsTrusted();}
    virtual BOOL IsApartmentSpecific() {return m_pDest->IsApartmentSpecific();}
};


//***************************************************************************
//
//***************************************************************************


class CDynPropsSink : public CForwardingSink
{
protected:
    CRefedPointerArray<IWbemClassObject> m_UnsentCache;
    CWbemNamespace * m_pNs;
public:
    CDynPropsSink(CBasicObjectSink* pSink, CWbemNamespace * pNs, long lRef = 0);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
    ~CDynPropsSink();
    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
};


//***************************************************************************
//
//***************************************************************************

class CDecoratingSink : public CForwardingSink
{
protected:
    CWbemNamespace* m_pNamespace;

public:
    CDecoratingSink(CBasicObjectSink* pDest, CWbemNamespace* pNamespace);
    ~CDecoratingSink();

    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};


//***************************************************************************
//
//***************************************************************************

class CCombiningSink : public CForwardingSink
{
protected:
    HRESULT m_hresToIgnore;
    HRESULT m_hres;
    BSTR m_strParam;
    IWbemClassObject* m_pErrorObj;
    CCritSec m_cs;

public:
    CCombiningSink(CBasicObjectSink* pDest,
                    HRESULT hresToIgnore = WBEM_S_NO_ERROR);
    virtual ~CCombiningSink();

    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}

    HRESULT GetHResult() { return m_hres; }
    void ClearHResult() { m_hres = WBEM_S_NO_ERROR; }
	void SetHRESULTToIgnore( HRESULT hr ) { m_hresToIgnore = hr; }
};


//***************************************************************************
//
//***************************************************************************
/*
class CAnySuccessSink : public CCombiningSink
{
    BOOL m_bSuccess;
    HRESULT m_hresNotError1;
    HRESULT m_hresNotError2;
    HRESULT m_hresIgnored;
public:
    CAnySuccessSink(CBasicObjectSink* pDest, HRESULT hresNotError1,
            HRESULT hresNotError2)
        : CCombiningSink(pDest), m_bSuccess(FALSE), m_hresIgnored(0),
            m_hresNotError1(hresNotError1), m_hresNotError2(hresNotError2)
    {}
    virtual ~CAnySuccessSink();
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};
*/

//
//
//  this constructor thows, because the WString trows
//
//////////////////////////////////////////////////////////////////

class COperationErrorSink : public CForwardingSink
{
protected:
    WString m_wsOperation;
    WString m_wsParameter;
    WString m_wsProviderName;
    BOOL m_bFinal;

public:
    COperationErrorSink(CBasicObjectSink* pDest,
                        LPCWSTR wszOperation, LPCWSTR wszParameter,
                        BOOL bFinal = TRUE)
        : CForwardingSink(pDest, 1), m_wsOperation((LPWSTR)wszOperation),
            m_wsParameter((LPWSTR)wszParameter), m_wsProviderName(L"WinMgmt"),
            m_bFinal(bFinal)
    {}
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    void SetProviderName(LPCWSTR wszName);
    void SetParameterInfo(LPCWSTR wszParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CSingleMergingSink : public CCombiningSink
{
protected:
    IWbemClassObject* m_pResult;
    CCritSec m_cs;
    WString m_wsTargetClass;

public:
    CSingleMergingSink(CBasicObjectSink* pDest, LPCWSTR wszTargetClass)
        : CCombiningSink(pDest, WBEM_E_NOT_FOUND), m_pResult(NULL),
            m_wsTargetClass(wszTargetClass)
    {}
    virtual ~CSingleMergingSink();

    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CLocaleMergingSink : public CCombiningSink
{
protected:
    CCritSec m_cs;
    WString m_wsLocale;
    WString m_pThisNamespace;

    //Primary pointers are to the specified locale
    IWmiDbHandle *m_pPrimaryNs;
    IWmiDbSession *m_pPrimarySession;
    IWmiDbController *m_pPrimaryDriver;

    //Default pointers are pointing at the ms_409 default locale in case there
    //is no specific locale loaded onto the machine.
    IWmiDbHandle *m_pDefaultNs;
    IWmiDbSession *m_pDefaultSession;
    IWmiDbController *m_pDefaultDriver;

    void GetDbPtr(const wchar_t *);
    bool hasLocale(const wchar_t *);
      void releaseNS(void);

    HRESULT LocalizeQualifiers(bool, bool, IWbemQualifierSet *, IWbemQualifierSet *, bool&);
    HRESULT LocalizeProperties(bool, bool, IWbemClassObject *, IWbemClassObject *, bool&);

public:
    CLocaleMergingSink(CBasicObjectSink *pDest, LPCWSTR wszLocale, LPCWSTR pNamespace);
    virtual ~CLocaleMergingSink();
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);

    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

/*
class CCountedSink : public CForwardingSink
{
    DWORD m_dwMax;
    DWORD m_dwSent;
public:
    CCountedSink(CBasicObjectSink* pDest, DWORD dwMax) : CForwardingSink(pDest),
        m_dwMax(dwMax), m_dwSent(0)
    {}
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};
*/

//***************************************************************************
//
//***************************************************************************

class CFilteringSink : public CForwardingSink
{
public:
    CFilteringSink(CBasicObjectSink* pDest) : CForwardingSink(pDest, 0){}
    virtual ~CFilteringSink(){}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
    virtual BOOL Test(CWbemObject* pObj) = 0;
};

//***************************************************************************
//
//***************************************************************************

class CErrorChangingSink : public CForwardingSink
{
protected:
    HRESULT m_hresFrom;
    HRESULT m_hresTo;
public:
    CErrorChangingSink(CBasicObjectSink* pDest, HRESULT hresFrom, HRESULT hresTo)
        : CForwardingSink(pDest, 1), m_hresFrom(hresFrom), m_hresTo(hresTo)
    {}
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CMethodSink : public CForwardingSink
{
protected:
    IWbemClassObject * m_pRes;
public:
    CMethodSink(CBasicObjectSink* pDest)
        : CForwardingSink(pDest, 0), m_pRes(0)
    {}
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
    virtual IWbemObjectSink* GetIndicateSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CNoDuplicatesSink : public CFilteringSink
{
protected:
    std::map<WString, bool, WSiless> m_mapPaths;
    BSTR m_strDupClass;
    CCritSec m_cs;

public:
    CNoDuplicatesSink(CBasicObjectSink* pDest);
    ~CNoDuplicatesSink();

    BOOL Test(CWbemObject* pObj);

    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CHandleClassProvErrorsSink : public CForwardingSink
{
protected:
    WString m_wsProvider;
    WString m_wsNamespace;
public:
    CHandleClassProvErrorsSink(CBasicObjectSink* pDest, LPCWSTR wszProvider,
               LPCWSTR wszNamespace)
        : CForwardingSink(pDest, 0), m_wsProvider(wszProvider),
            m_wsNamespace(wszNamespace)
    {}
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CSuccessSuppressionSink : public CForwardingSink
{
protected:
    HRESULT m_hresNotError1;
    HRESULT m_hresNotError2;
public:
    CSuccessSuppressionSink(CBasicObjectSink* pDest, HRESULT hresNotError1,
            HRESULT hresNotError2)
        : CForwardingSink(pDest, 0), m_hresNotError1(hresNotError1),
            m_hresNotError2(hresNotError2)
    {}
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);
    virtual IWbemObjectSink* GetStatusSink() {return this;}
};

//***************************************************************************
//
//***************************************************************************

class CThreadSwitchSink : public CForwardingSink
{
protected:
    CRefedPointerQueue<IWbemClassObject> m_qpObjects;
    HRESULT m_hres;
    BOOL m_bSwitching;
    HANDLE m_hReady;


public:
    CThreadSwitchSink(CBasicObjectSink* pDest);
    ~CThreadSwitchSink();

    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam);

    HRESULT Next(IWbemClassObject** ppObj);
};


//***************************************************************************
//
//***************************************************************************


class CLessGuid : public binary_function<GUID, GUID, bool>
{
public:
    bool operator()(const GUID& x, const GUID& y) const
    {
        return (memcmp((void*)&x, (void*)&y, sizeof(GUID)) < 0);   // SEC:REVIEWED 2002-03-22 : OK
    }
};


//***************************************************************************
//
//***************************************************************************

/*
class CLessPtr : public binary_function<__a, __a,bool>
{
public:
    inline
    bool operator()(__a const& x, __a const& y) const
    {
        return (IWbemObjectSink*)x < (IWbemObjectSink*)y;
    }
};
*/


class CSinkGUIDAlloc : public wbem_allocator<GUID>
{
};


//***************************************************************************
//
//***************************************************************************

class CSimpleWrapperSink : public CBasicObjectSink
{
protected:
    IWbemObjectSink* m_pDest;
public:
    CSimpleWrapperSink(IWbemObjectSink* pDest) : m_pDest(pDest){}
    ~CSimpleWrapperSink(){}

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray)
    {
        return m_pDest->Indicate(lObjectCount, pObjArray);
    }
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam)
    {
        return m_pDest->SetStatus(lFlags, lParam, strParam, pObjParam);
    }
    STDMETHOD_(ULONG, AddRef)()
    {
        return m_pDest->AddRef();
    }
    STDMETHOD_(ULONG, Release)()
    {
        return m_pDest->Release();
    }
};

class COperationError
{
private:

    bool                m_fOk;
    COperationErrorSink * m_pSink;
public:
    COperationError(CBasicObjectSink* pDest, LPCWSTR wszOperation,
                        LPCWSTR wszParam, BOOL bFinal = TRUE);
    ~COperationError();
    HRESULT ErrorOccurred(HRESULT hres, IWbemClassObject* pErrorObj = NULL);
    HRESULT ProviderReturned(LPCWSTR wszProviderName, HRESULT hres,
                                IWbemClassObject* pErrorObj = NULL);
    void SetParameterInfo(LPCWSTR wszParam);
    void SetProviderName(LPCWSTR wszName);
    INTERNAL CBasicObjectSink* GetSink() {return m_pSink;}

    bool IsOk( void ) { return m_fOk; }	
};



class CFinalizingSink : public CForwardingSink
{
protected:
    CWbemNamespace* m_pNamespace;
public:
    CFinalizingSink(CWbemNamespace* pNamespace, CBasicObjectSink* pDest);
    virtual ~CFinalizingSink();

    STDMETHOD(Indicate)(long, IWbemClassObject**);
    virtual IWbemObjectSink* GetIndicateSink() {return this;}

};


class CAssocQE_Sink : public CObjectSink
{
    friend class CAssocQuery;

    BOOL                    m_bQECanceled;
    CAssocQuery             *m_pQuery;
    PF_FilterForwarder      m_pfnFilter;
    BSTR                    m_strQuery;
    BOOL                    m_bOriginalOpCanceled;

public:
    CAssocQE_Sink(CAssocQuery *pQuery, PF_FilterForwarder pFilter, BSTR m_strQuery);
   ~CAssocQE_Sink();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
                         IWbemClassObject* pObjParam
                         );

    virtual HRESULT Add(ADDREF IWbemClassObject* pObj);
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\stack.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STACK.H

Abstract:

    CStack

History:

	26-Apr-96   a-raymcc    Created.

--*/

#ifndef _STACK_H_
#define _STACK_H_


class CStack 
{
    DWORD m_dwSize;
    DWORD m_dwStackPtr;    
    DWORD* m_pData;
    DWORD m_dwGrowBy;

    explicit CStack(const CStack &){};
    CStack& operator=(const CStack &){};
    
public:
    CStack(DWORD dwInitSize = 32, DWORD dwGrowBy = 32);
   ~CStack(); 

    void  Push(DWORD);

    DWORD Pop()     { return m_pData[m_dwStackPtr--]; }
    DWORD Peek()    { return m_pData[m_dwStackPtr]; }
    BOOL  IsEmpty() { return m_dwStackPtr == -1; }
    DWORD Size()    { return m_dwStackPtr + 1; }
    void  Empty()   { m_dwStackPtr = (DWORD) -1; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\stack.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STACK.CPP

Abstract:

    CStack

History:

    26-Apr-96   a-raymcc    Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include "Arena.h"
#include "stack.h"
#include "corex.h"

CStack::CStack(DWORD dwInitSize, DWORD dwGrowBy)
{
    m_dwSize = dwInitSize;
    m_dwGrowBy = dwGrowBy * sizeof(DWORD);
    m_dwStackPtr = (DWORD) -1;
    m_pData = (DWORD *)CWin32DefaultArena::WbemMemAlloc(m_dwSize * sizeof(DWORD));
    if (m_pData == 0)
        throw CX_MemoryException();
    ZeroMemory(m_pData, m_dwSize * sizeof(DWORD));   // SEC:REVIEWED 2002-03-22 : OK
}

void CStack::Push(DWORD dwValue)
{
    if ( m_dwStackPtr + 1 == m_dwSize) {
        DWORD * pTmp = (DWORD *)CWin32DefaultArena::WbemMemReAlloc(m_pData, (m_dwSize+m_dwGrowBy) * sizeof(DWORD));
        if (0 == pTmp) throw CX_MemoryException();        
        m_dwSize += m_dwGrowBy;
        m_pData = pTmp;
    }
    m_pData[++m_dwStackPtr] = dwValue;
}

CStack::~CStack()
{
    CWin32DefaultArena::WbemMemFree(m_pData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\stdclass.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STDCLASS.CPP

Abstract:

    Class definitions for standard system classes.

History:

	raymcc    18-Jul-96       Created.

--*/


#ifndef _STDCLASS_H_
#define _STDCLASS_H_

#include <WbemUtil.h>
#include <FastAll.h>
#include <Sync.h>
#include <statsync.h>

class Registry;

class CSystemClass : public CWbemClass
{
public:
    CSystemClass(){}
    void Init();
};

class CGenericClass : public CWbemClass
{
public:
    CGenericClass(){}
    void Init();
};

class CNotifyStatusClass : public CWbemClass
{
public:
    CNotifyStatusClass(){}
    void Init();
};


class CNamespaceClass : public CWbemClass
{
public:
    CNamespaceClass(){}
    void Init();
};

class CThisNamespaceClass : public CWbemClass
{
public:
    CThisNamespaceClass(){}
    void Init();
};


class CNamespace: public CWbemInstance
{
private:
    static CNamespaceClass* mstatic_pClass;
    static CStaticCritSec mstatic_cs;

	class __CleanUp
	{
	public:
		__CleanUp() {}
		~__CleanUp() { delete CNamespace::mstatic_pClass; }
	};
	static __CleanUp cleanup;
	friend __CleanUp;

public:
    void Init(LPWSTR pName);
};

class CThisNamespaceInstance : public CWbemInstance
{
public:
    CThisNamespaceInstance(){}
    void Init(CThisNamespaceClass* pClass);
};

class CProviderClass : public CWbemClass
{
public:
    CProviderClass(){}
    void Init();
};

class CWin32ProviderClass : public CWbemClass
{
public:
    CWin32ProviderClass(){}
    void Init();
};

class CProviderRegistrationClass : public CWbemClass
{
public:
    CProviderRegistrationClass(){}
    void Init();
};

class CObjectProviderRegistrationClass : public CWbemClass
{
public:
    CObjectProviderRegistrationClass(){}
    void Init();
};

class CClassProviderRegistrationClass : public CWbemClass
{
public:
    CClassProviderRegistrationClass(){}
    void Init();
};

class CInstanceProviderRegistrationClass : public CWbemClass
{
public:
    CInstanceProviderRegistrationClass(){}
    void Init();
};

class CPropertyProviderRegistrationClass : public CWbemClass
{
public:
    CPropertyProviderRegistrationClass(){}
    void Init();
};

class CMethodProviderRegistrationClass : public CWbemClass
{
public:
    CMethodProviderRegistrationClass(){}
    void Init();
};

class CEventProviderRegistrationClass : public CWbemClass
{
public:
    CEventProviderRegistrationClass(){}
    void Init();
};

class CEventConsumerProviderRegistrationClass : public CWbemClass
{
public:
    CEventConsumerProviderRegistrationClass(){}
    void Init();
};

class CCIMOMIdentificationClass : public CWbemClass
{
public:
    CCIMOMIdentificationClass(){}
    void Init();
private:
    void SetPropFromReg(Registry * pReg, TCHAR * pcRegName, WCHAR * pwcPropName);
};

// __AdapStatus
class CAdapStatusClass : public CWbemClass
{
public:
    CAdapStatusClass(){};
    void Init();
};

class CAdapStatusInstance : public CWbemInstance
{
public:
    CAdapStatusInstance(){}
    void Init(CAdapStatusClass * pClass);
};

//__CIMOMIdentification
class CIdentificationClass : public CWbemClass
{
public:
    CIdentificationClass(){};
    void Init();
};

class CIdentificationInstance : public CWbemInstance
{
public:
    CIdentificationInstance(){}
    void Init(CIdentificationClass * pClass);
};


class CCacheControlClass : public CWbemClass
{
public:
    CCacheControlClass(){}
    void Init();
};

class CSpecificCacheControlClass : public CWbemClass
{
public:
    CSpecificCacheControlClass(){}
    void Init(LPCWSTR wszClassName);
};

class CCacheControlInstance : public CWbemInstance
{
public:
    CCacheControlInstance(){}
    void Init(CSpecificCacheControlClass* pClass, DWORD dwSeconds);
};

class CActiveNamespacesClass : public CWbemClass
{
public:
    CActiveNamespacesClass(){}
    void Init();
};
//*****************************************************************************

class CIndicationRelatedClass : public CWbemClass
{
public:
    CIndicationRelatedClass(){}
    void Init();
};

class CEventClass : public CWbemClass
{
public:
    CEventClass(){}
    void Init();
};

class CParametersClass : public CWbemClass
{
public:
    CParametersClass(){}
    void Init();
};

class CEmptyEventClass : public CWbemClass
{
public:
    CEmptyEventClass(){}
    void Init(LPWSTR wszName);
};

class CGenericDataEventClass : public CWbemClass
{
public:
    CGenericDataEventClass() {}
    void Init(LPWSTR wszCimType, LPWSTR wszPropName);
};

class CDataEventClass : public CWbemClass
{
public:
    enum {include_new = 1, include_old = 2,
          type_create = include_new,
          type_delete = include_old,
          type_change = include_new | include_old
    };
    CDataEventClass(){}
    void Init(CWbemClass& Parent,
                    LPWSTR wszCimType, LPWSTR wszPropName, int nFlags);
};

class CNamespaceEventClass : public CDataEventClass
{
public:
    CNamespaceEventClass(){}
    void Init(CWbemClass& Parent, int nFlags)
    {
        CDataEventClass::Init(Parent, L"object:__Namespace", L"Namespace",
            nFlags);
    }
};

class CClassEventClass : public CDataEventClass
{
public:
    CClassEventClass(){}
    void Init(CWbemClass& Parent, int nFlags)
    {
        CDataEventClass::Init(Parent, L"object", L"Class", nFlags);
    }

};

class CInstanceEventClass : public CDataEventClass
{
public:
    CInstanceEventClass(){}
    void Init(CWbemClass& Parent, int nFlags)
    {
        CDataEventClass::Init(Parent, L"object", L"Instance", nFlags);
    }
};

class CMethodEventClass : public CWbemClass
{
public:
    void Init();
};

class CTimerEventClass : public CWbemClass
{
public:
    CTimerEventClass(){}
    void Init();
};

class CAggregateEventClass : public CWbemClass
{
public:
    CAggregateEventClass(){}
    void Init();
};

class CSystemEventClass : public CWbemClass
{
public:
    void Init();
};

class CEventDroppedEventClass : public CWbemClass
{
public:
    void Init();
};

class CQueueOverflowEventClass : public CWbemClass
{
public:
    void Init();
};

class CConsumerFailureEventClass : public CWbemClass
{
public:
    void Init();
};

class CQoSFailureEventClass : public CWbemClass
{
public:
    void Init();
};

class CMonitorEventClass : public CWbemClass
{
public:
    void Init(CWbemClass& Parent, LPCWSTR wszClassName);
};

class CMonitorDataEventClass : public CWbemClass
{
public:
    void Init(CWbemClass& Parent, LPCWSTR wszClassName);
};

//*****************************************************************************

class CEventConsumerClass : public CWbemClass
{
public:
    CEventConsumerClass(){}
    void Init();
};

//*****************************************************************************

class CConditionalInstructionClass : public CWbemClass
{
public:
    void Init();
};

//*****************************************************************************

class CEventMonitorClass : public CWbemClass
{
public:
    void Init();
};

//*****************************************************************************

class CEventFilterClass : public CWbemClass
{
public:
    CEventFilterClass(){}
    void Init();
};

//*****************************************************************************

class CFilterConsumerBindingClass : public CWbemClass
{
public:
    CFilterConsumerBindingClass(){}
    void Init();
};

//*****************************************************************************

class CEventGeneratorClass : public CWbemClass
{
public:
    CEventGeneratorClass(){}
    void Init();
};

class CTimerInstructionClass : public CWbemClass
{
public:
    CTimerInstructionClass(){}
    void Init();
};

class CAbsoluteTimerInstructionClass : public CWbemClass
{
public:
    CAbsoluteTimerInstructionClass(){}
    void Init();
};

class CIntervalTimerInstructionClass : public CWbemClass
{
public:
    CIntervalTimerInstructionClass(){}
    void Init();
};


class CTimerNextFiringClass : public CWbemClass
{
public:
    CTimerNextFiringClass(){}
    void Init();
};


//*****************************************************************************
class CSecurityBaseClass : public CWbemClass
{
public:
    CSecurityBaseClass(){}
    void Init();
};

class CSubjectClass : public CWbemClass
{
public:
    CSubjectClass(){}
    void Init();
};

class CUserClass : public CWbemClass
{
public:
    CUserClass(){}
    void Init();
};

class CNTLMUserClass : public CWbemClass
{
public:
    CNTLMUserClass(){}
    void Init();
};

class CNTLM9XUserClass : public CWbemClass
{
public:
    CNTLM9XUserClass(){}
    void Init();
};

class CGroupClass : public CWbemClass
{
public:
    CGroupClass(){}
    void Init();
};


class CNtlmGroupClass : public CGroupClass
{
public:
    CNtlmGroupClass(){}
    void Init();
};






class CSystemConfigClass : public CWbemClass
{
public:
    CSystemConfigClass(){}
    void Init();
	void AddStaticQual(LPWSTR pMethodName);
};

class CSystemConfigInstance : public CWbemInstance
{
public:
    CSystemConfigInstance(){}
    void Init(CSystemConfigClass* pClass);
};



//*****************************************************************************

class CErrorObjectClass : public CWbemClass
{
public:
    CErrorObjectClass(){}
    void Init();
};

class CErrorObject
{
protected:
    static CErrorObjectClass* mstatic_pClass;
    static CStaticCritSec mstatic_cs;

	class __CleanUp
	{
	public:
		__CleanUp() {}
		~__CleanUp() { delete CErrorObject::mstatic_pClass; }
	};
	static __CleanUp cleanup;
	friend __CleanUp;

    CWbemInstance* m_pObject;
public:
    CErrorObject(ADDREF IWbemClassObject* pObject = NULL);
    ~CErrorObject();

    BOOL SetStatusCode(SCODE sRes);
    BOOL SetOperation(COPY LPWSTR wszOperation);
    BOOL SetParamInformation(COPY LPWSTR wszExtraInfo);
    BOOL SetProviderName(COPY LPWSTR wszName);
    BOOL MarkAsInternal();
    BOOL ContainsStatusCode();
    BOOL ContainsOperationInfo();

    RELEASE_ME IWbemClassObject* GetObject();
};

//*****************************************************************************

/*
class CNamespaceMapClass : public CWbemClass
{
public:
    CNamespaceMapClass(){}
    void Init();
};
*/

/* The following system classes are removed for Whistler; may be reintroduced
   for Blackcomb.

class CClassInstanceSecurity: public CWbemClass
{
public:
    CClassInstanceSecurity(){};
    void Init();
};

class CClassSecurity: public CWbemClass
{
public:
    CClassSecurity(){};
    void Init();
};

//*****************************************************************************

class CClassVectorClass : public CWbemClass
{
public:
    CClassVectorClass(){}
    void Init();
};


class CUncommittedEventClass : public CWbemClass
{
public:
    CUncommittedEventClass() {};
    void Init();
};


class CTransactionClass : public CWbemClass
{
public:
    CTransactionClass() {};
    void Init();
};

//*****************************************************************************

class CComTaxonomyClass : public CWbemClass
{
public:
    CComTaxonomyClass(){}
    void Init();
};

//*****************************************************************************

class CComInterfaceSetClass : public CWbemClass
{
public:
    CComInterfaceSetClass(){}
    void Init();
};

//*****************************************************************************

class CComDispatchElementClass : public CWbemClass
{
public:
    CComDispatchElementClass(){}
    void Init();
};

//*****************************************************************************

class CComDispatchInfoClass : public CWbemClass
{
public:
    CComDispatchInfoClass(){}
    void Init();
};

//*****************************************************************************

class CComBindingClass : public CWbemClass
{
public:
    CComBindingClass(){}
    void Init();
};

//*****************************************************************************

class CComInterfaceSetBindingClass : public CWbemClass
{
public:
    CComInterfaceSetBindingClass(){}
    void Init();
};

//*****************************************************************************

class CComDispatchElementBindingClass : public CWbemClass
{
public:
    CComDispatchElementBindingClass(){}
    void Init();
};


*/

//****************************************************************************

class CArbitratorConfiguration : public CWbemClass
{
public:
	CArbitratorConfiguration() {};
	void Init();
};

class CArbitratorConfigurationInstance : public CWbemInstance
{
public:
    CArbitratorConfigurationInstance(){}
    void Init(CArbitratorConfiguration* pClass);
};

class CClasses : public CWbemClass
{
public:
    CClasses() {};
    void Init();
};

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

class CProviderHostQuotaConfiguration : public CWbemClass
{
public:

	CProviderHostQuotaConfiguration() {};

	void Init();
};

class CProviderHostQuotaConfigurationInstance : public CWbemInstance
{
public:
    CProviderHostQuotaConfigurationInstance(){}
    void Init(CProviderHostQuotaConfiguration* pClass);
};


#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\str_res.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STRRES.H

Abstract:

    String resource definitions

History:

--*/

#ifndef _STR_RES_H_
#define _STR_RES_H_


#define IDS_THIS_RELEASE            101
#define IDS_ADMIN_FULL_NAME         102
#define IDS_ADMIN_DESCRIPTION       103    
#define IDS_GUEST_FULL_NAME         104
#define IDS_GUEST_DESCRIPTION       105    
#define IDS_SYSINIT_FAILURE         106
#define IDS_WINMGMT_CRITICAL          107
#define IDS_MULTIPLE_NOT_SUPPORTED  108
#define IDS_INVALID_DATABASE        109
#define IDS_WBEM_USERS_GROUP        110
#define IDS_WBEM_USERS_COMMENT      112

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\wmi\wbem\winmgmt\coredll\stdclass.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STDCLASS.CPP

Abstract:

    Class definitions for standard system classes.

History:

    raymcc    18-Jul-96       Created.

--*/

#include "precomp.h"

#include "sechelp.h"
#include "StdClass.h"
#include "Reg.h"
#include "CfgMgr.h"

#include <arrtempl.h>
#include <genutils.h>

#include <comdef.h>
#include <autoptr.h>


#define NEW_CLASS_PRECREATE_SIZE 1000
#define NEW_INSTANCE_PRECREATE_SIZE 100

#define NOT_NULL_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define READ_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define UNITS_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define SINGLETON_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define SYNTAX_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

#define ABSTRACT_FLAVOR 0 // no propagation

#define ASSOC_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS | \
        WBEM_FLAVOR_NOT_OVERRIDABLE

#define VALUES_FLAVOR \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | \
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

void CThisNamespaceClass::Init()
{
    CSystemClass System;
    System.Init();
    HRESULT hRes = CreateDerivedClass(&System);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

    CVar v(VT_BSTR, L"__thisNAMESPACE");
    hRes = SetPropValue(L"__CLASS", &v, 0);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

//    CVar vNull;
//    vNull.SetAsNull();
//    hRes = SetPropValue(L"Name", &vNull, CIM_STRING);
//    if (hRes == WBEM_E_OUT_OF_MEMORY)
//        throw CX_MemoryException();

    CVar vEmpty;
    vEmpty.SetAsNull();
    hRes = SetPropValue(L"SECURITY_DESCRIPTOR", &vEmpty, CIM_FLAG_ARRAY | CIM_UINT8);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();


    CVar vTrue(VARIANT_TRUE, VT_BOOL);
    hRes = SetQualifier(L"singleton", &vTrue, SINGLETON_FLAVOR);
    if (hRes == WBEM_E_OUT_OF_MEMORY)
        throw CX_MemoryException();

}

void CThisNamespaceInstance::Init(CThisNamespaceClass* pClass)
{
    if (FAILED(InitNew(pClass, NEW_INSTANCE_PRECREATE_SIZE)))
    	throw CX_MemoryException();
}

BOOL GetLocalSystemSid(CVar& v)
{
    PSID pSid;

    //
    // Allocate the SID for the LOCAL SYSTEM account
    //

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    if(AllocateAndInitializeSid( &id, 1,                   // SEC:REVIEWED 2002-03-22 : Ok
        SECURITY_LOCAL_SYSTEM_RID, 0,0,0,0,0,0,0,&pSid))
    {
        BYTE* pBuffer = (BYTE*)pSid;

       